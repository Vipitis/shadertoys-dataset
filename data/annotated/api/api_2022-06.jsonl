{"id": "sdtfW7", "name": "bagel slicing experiment", "author": "mds2", "description": "just an experiment to visualize a bagel sliced by two mobius strips", "tags": ["mobius", "slice", "bagel"], "likes": 7, "viewed": 272, "published": 3, "date": "1656622191", "time_retrieved": "2024-07-30T16:42:14.839815", "image_code": "const float max_dist = 10.0;\nconst float other_side_bright = 0.25;\n\n#define ENABLE_TORUS_OUTLINE 1 // set to 0 to disable outline\n\nfloat to_toroid_sdf(in vec3 pt) {\n  float to_toroid_spine = length(pt.xz) - 0.75;\n  float to_toroid = length(vec2(to_toroid_spine, pt.y)) - 0.25;\n  return to_toroid;\n}\n\nfloat sdf(in vec3 pt) {\n  float to_toroid_spine = length(pt.xz) - 0.75;\n  float to_toroid = length(vec2(to_toroid_spine, pt.y)) - 0.25;\n  float angle = atan(pt.x, pt.z);\n  vec2 p1 = vec2(sin(0.5 * angle), cos(0.5 *angle));\n  vec2 p2 = vec2(cos(0.5 * angle), -sin(0.5 *angle));\n  float d1 = dot(vec2(to_toroid_spine, pt.y), p1);\n  float d2 = dot(vec2(to_toroid_spine, pt.y), p2);\n  float max_angle_dist = min(max(d1, d2), max(-d1, -d2));\n  return max(to_toroid, max_angle_dist);\n}\n\nfloat sdf_other_side(in vec3 pt) {\n  float to_toroid_spine = length(pt.xz) - 0.75;\n  float to_toroid = length(vec2(to_toroid_spine, pt.y)) - 0.25;\n  float angle = atan(pt.x, pt.z);\n  vec2 p1 = vec2(sin(0.5 * angle), cos(0.5 *angle));\n  vec2 p2 = vec2(cos(0.5 * angle), -sin(0.5 *angle));\n  float d1 = dot(vec2(to_toroid_spine, pt.y), p1);\n  float d2 = dot(vec2(to_toroid_spine, pt.y), p2);\n  float max_angle_dist = min(max(-d1, d2), max(d1, -d2));\n  return max(to_toroid, max_angle_dist);\n}\n\nfloat rough_raycast(in vec3 orig, in vec3 dir) {\n  float accum = 0.0;\n  float d = to_toroid_sdf(orig);\n  for (int i = 0; i < 256; ++i) {\n    accum = accum + 0.9 * d;\n    vec3 pt = orig + accum * dir;\n    d = to_toroid_sdf(pt);\n    if (abs(d) < 1.0e-2) {\n      return accum;\n    }\n    if (d > max_dist) {\n      return max_dist + 1.0;\n    }\n  }\n  return accum;\n}\n\n\nfloat raycast(in vec3 orig, in vec3 dir, float start_guess) {\n  float accum = start_guess;\n  if (accum > max_dist) {\n    return accum;\n  }\n  float d = sdf(orig + accum * dir);\n  for (int i = 0; i < 256; ++i) {\n    accum = accum + 0.7 * d;\n    vec3 pt = orig + accum * dir;\n    d = sdf(pt);\n    if (abs(d) < 1.0e-6) {\n      return accum;\n    }\n    if (accum > max_dist) {\n      return max_dist + 1.0;\n    }\n  }\n  return accum;\n}\n\nfloat raycast_other_side(in vec3 orig, in vec3 dir, float start_guess) {\n  float accum = start_guess;\n  if (accum > max_dist) {\n    return accum;\n  }\n  float d = sdf_other_side(orig + dir * accum);\n  for (int i = 0; i < 256; ++i) {\n    accum = accum + 0.7 * d;\n    vec3 pt = orig + accum * dir;\n    d = sdf_other_side(pt);\n    if (d < 1.0e-6) {\n      return accum;\n    }\n    if (d > max_dist) {\n      return max_dist + 1.0;\n    }\n  }\n  return accum;\n}\n\n\nvec3 get_norm(in vec3 pt) {\n  float f = sdf(pt);\n  const float h = 1.0e-3;\n  return normalize(vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf(pt + vec3(0.0, 0.0, h)) - f));\n}\n\nvec3 get_norm_other_side(in vec3 pt) {\n  float f = sdf_other_side(pt);\n  const float h = 1.0e-3;\n  return normalize(vec3(sdf_other_side(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf_other_side(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf_other_side(pt + vec3(0.0, 0.0, h)) - f));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float uv_scale = min(iResolution.x, iResolution.y);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / uv_scale;\n    \n    vec3 orig = vec3(0.0, 0.0, -3.0);\n    vec3 ray = normalize(vec3(uv, 0) - orig);\n    \n    float theta_tilt = 2.0 * iMouse.y / iResolution.y - 1.0;\n    float ct = cos(theta_tilt);\n    float st = sin(theta_tilt);\n    mat3 tilt = mat3(1.0, 0.0, 0.0,\n                       0.0, ct, -st,\n                       0.0, st, ct);\n    \n    float phi_yaw = 8.0 * (2.0 * iMouse.x / iResolution.x - 1.0);\n    float cp = cos(phi_yaw);\n    float sp = sin(phi_yaw);\n    mat3 yaw = mat3(cp, 0.0, -sp,\n                    0.0, 1.0, 0.0,\n                    sp, 0.0, cp);\n    orig = yaw * tilt * orig;\n    ray = yaw * tilt * ray;\n    \n    float bright = 0.95;\n    \n    vec3 overlay = vec3(0.5);\n    \n    vec3 col = vec3(0.0);\n    vec3 light = -vec3(0.8 * ray.x + 0.6 * ray.z, ray.y, 0.8 * ray.z - 0.6 * ray.x);\n    \n    float start_guess = rough_raycast(orig, ray);\n\n    float dist = raycast(orig, ray, start_guess);\n    if (dist < max_dist) {\n      overlay = vec3(0.0);\n      vec3 n = get_norm(orig + dist * ray);\n      // pixel color\n      vec3 bounce = normalize(reflect(ray, n));\n      col = 0.5 * bounce + 0.5;\n      float bounce_dot = max(0.0, dot(bounce, light));\n      bounce_dot = bounce_dot * bounce_dot;\n      bounce_dot = bounce_dot * bounce_dot;\n      col += 0.5 * bounce_dot;\n      bright = 1.0;\n    }\n    \n#if ENABLE_TORUS_OUTLINE\n    float dist_other_side = raycast_other_side(orig, ray, start_guess);\n    \n    if (dist_other_side < max_dist && dist_other_side < dist) {\n      if (dist >= max_dist) {\n        overlay = vec3(0.0);\n      }\n      bright = 1.0 - other_side_bright;\n      vec3 hit_pt = orig + dist_other_side * ray;\n      vec3 n = get_norm_other_side(hit_pt);\n      vec3 bounce = normalize(reflect(ray, n));\n      float stripe = mod(atan(hit_pt.x, hit_pt.z)/3.141592654, 0.1);\n      overlay += max(0.75, dot(bounce, light)) * 0.3 * step(0.015, stripe);\n    }\n#endif\n\n    // Output to screen\n    fragColor = vec4(bright * col + overlay,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtfW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 164, 164, 298], [300, 300, 323, 323, 779], [781, 781, 815, 815, 1271], [1273, 1273, 1321, 1321, 1633], [1636, 1636, 1697, 1697, 2063], [2065, 2065, 2137, 2137, 2516], [2519, 2519, 2546, 2546, 2768], [2770, 2770, 2808, 2808, 3074], [3077, 3077, 3134, 3134, 5261]]}
{"id": "fsKcWw", "name": "Mystic cubes", "author": "z0rg", "description": "A visual to accompany a song I love !", "tags": ["cubes", "mysterious", "plant43"], "likes": 13, "viewed": 501, "published": 3, "date": "1656619871", "time_retrieved": "2024-07-30T16:42:15.791271", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvn = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    //rgb += 2.*vec3(0.,.25,.3)*sat(sin(uv.y*355.-iTime*200.)-.5);\n\n    fragColor = vec4(mix(rgb, rgb.yzz, 1.-sat(length(uvn*2.))),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define FFT(a) texelFetch(iChannel2, ivec2(a,0),0).x\n\nfloat hash11(float seed)\n{\n    return fract(sin(seed*123.456)*123.456);\n}\nfloat _seed;\n\nfloat rand()\n{\n    return hash11(_seed++);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 3.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    //acc = _min(acc, vec2(length(p)-1., 0.));\n    \n    float ground = -p.y;\n    \n    acc = _min(acc, vec2(ground, 0.));\n    \n    p.x += sin(p.y+iTime)*sat(-p.y)*.5;\n    \n    vec2 repc = vec2(.5);\n    vec3 pc = p;\n    vec2 idc = floor((pc.xz+repc*.5)/repc);\n    float h = sin(idc.x+iTime+idc.y)*.5+1.;\n    pc.xz = mod(pc.xz+repc*.5,repc)-repc*.5;\n    float cubes = _cube(pc, vec2(.1,h).xyx);\n    float matid = abs(idc.x)+100.*(abs(idc.y)+1.);\n    cubes = max(cubes, length(p.xz)-3.);\n    acc = _min(acc, vec2(cubes, 10.+matid));\n    \n    return acc;\n}\n\nvec3 getMat(vec3 p, vec3 n, vec3 rd, vec3 res)\n{\n    if (res.z > 9. && abs(dot(n, vec3(0.,1.,0.))) > 0.99)\n    {\n        float idy = floor(res.z /100.);\n        float idx = res.z-(idy*100.);\n        vec3 rgb = texture(iChannel0, vec2(idx, idy)*.1).xyz;\n        rgb.xy *= r2d(.5);\n        rgb.yz *= r2d(2.9);\n        rgb = abs(rgb);\n        float f = FFT(idx*0.1);\n        return rgb*f*5.;\n    }\n    \n    return vec3(0.835,0.824,0.804)*1.4;\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0 ; i < steps && distance(p, ro) < 25.; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x< 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+=rd*res.x*.35;\n    }\n    return vec3(-1.);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    float dist = 1.+1.*sin(iTime*.35);\n    float t = iTime*.1;\n    vec3 ro = vec3(sin(t)*dist,-3.-2.*sin(iTime*.15),cos(t)*dist);\n    vec3 ta = vec3(0.,0.,2.*sin(iTime*.1));\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    \n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        \n        col = n*.5+.5;\n        col = getMat(p, n, rd, res);\n        \n        float ao = 1.;\n        for (int iao = 0; iao < 8; ++iao)\n        {\n            vec3 ray = normalize(vec3(rand(), rand(), rand())-.5);\n            if (dot(ray, vec3(0.,1.,0.)) > 0.1)\n                ray = -ray;\n            vec3 aores = trace(p+n*0.01, ray, 64);\n            if (aores.y > 0.)\n            {\n                ao -= sat(aores.y/.3)/8.;\n            }\n        }\n        col = mix(col, vec3(0.604,0.529,0.475), 1.-ao);\n\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    _seed = texture(iChannel0, uv*10.).x+iTime;\n    vec3 col = rdr(uv);\n    col = pow(col, vec3(2.25))*.9;\n    col = sat(1.-col);\n    col = mix(col, texture(iChannel1, ouv).xyz, .5);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29245, "src": "https://soundcloud.com/dope-dope-357275790/plant43-cavernous-bones?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+2.*pow(col, vec3(GLOW_POW));\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 40\n#define GLOW_DISTANCE 0.05\n#define GLOW_POW 1.2\n#define GLOW_OPACITY 1.5\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKcWw.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1153]]}
{"id": "Nt2yW3", "name": "Functional Conch", "author": "harry7557558", "description": "My second attempt to create a conch after the [url=https://www.shadertoy.com/view/sdVGWh]nautilus shell[/url] shader.\nThe conch was modeled in a functional graphing calculator. Place it on a more decent beach.", "tags": ["water", "spiral", "function", "logarithmic", "sand", "beach", "seashell", "moana", "conch"], "likes": 38, "viewed": 746, "published": 3, "date": "1656617803", "time_retrieved": "2024-07-30T16:42:16.795585", "image_code": "// Common: Modeling\n// Image: Rendering\n\n// The conch was modeled in a \"graphing calculator\" I made.\n// (see Common for link and details)\n\n// I was inspired by:\n//  - my childhood fascination with the spiral shells of mollusks\n//  - my fascination with the sea that lasts to this day\n//  - a certain Disney movie\n//  - some thoughts when leaving high school for university\n\n// Mouse-able.\n\n// Also check my \"Nautilus Shell\" shader (modeled in GLSL):\n// https://www.shadertoy.com/view/sdVGWh\n\n\n/* CONCH INTERSECTION */\n\n// Intersect with the bounding box, used to speed up rendering\nbool boxIntersection(float offset, vec3 ro, vec3 rd, out float tn, out float tf) {\n    ro -= vec3(-0.1,0.1,0.6); // translation\n    vec3 inv_rd = 1.0 / rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*(vec3(0.9,1.3,0.7)+offset); // offset is positive for shadow\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\nbool intersectConch(vec3 ro, vec3 rd, inout float t, float tf, float eps) {\n    // intersect bounding box\n    float t0, t1;\n    if (!boxIntersection(0.0, ro, rd, t0, t1)) return false;\n    t1 = min(t1, tf);\n    if (t1 < t0) return false;\n    t = t0;\n    // raymarching, eps is the minimum step\n    float v0=0.0, v, dt;\n    for (int i=ZERO; i<80; i++) {\n        v = mapShell(ro+rd*t);\n        if (v*v0 < 0.0) { // intersect\n            t -= dt * v/(v-v0); // linear interpolation\n            return true;\n        }\n        dt = max(abs(v), eps);\n        t += dt;\n        if (t > t1) return false; // too far\n        v0 = v;\n    }\n    return true;\n    //return false;\n}\n\n// Soft shadow\nfloat calcShadow(vec3 ro, vec3 rd) {\n    // check bounding box\n    float t0, t1;\n    if (!boxIntersection(0.2, ro, rd, t0, t1)) return 1.0;\n    // https://iquilezles.org/articles/rmshadows\n    float sh = 1.;\n    float t = max(t0, 0.01) + 0.02*hash22(rd.xy).x;\n    for (int i=ZERO; i<40; i++) {\n        float h = 0.8*mapShell(ro + rd*t);\n        sh = min(sh, smoothstep(0., 1., 20.0*h/t));\n        t += clamp(h, 0.02, 0.5);\n        if (h<0.) return 0.0;\n        if (t>t1) break;\n    }\n    return max(sh, 0.);\n}\n\n\n/* BEACH INTERSECTION */\n\nbool intersectBeach(vec3 ro, vec3 rd, out float t, float tf) {\n    //t = -ro.z/rd.z; if (t < 0.0) return false;\n    t = 0.01;\n    float v0 = 0.0, v, dt;\n    for (int i = int(ZERO); i < 50; i++) {  // raymarching\n        if (t>tf) return false;\n        v = mapGround(ro+rd*t).x;\n        if (v*v0 < 0.0) break;\n        dt = i==int(ZERO)?v:dt*v/abs(v-v0); // divide by line derivative\n        dt = sign(dt)*clamp(abs(dt), 0.02, 1.0);\n        t += dt;\n        v0 = v;\n    }\n    t -= dt * clamp(v/(v-v0), 0., 1.); // linear interpolation\n    return true;\n}\n\n\n/* SKY */\n\nvec3 sundir = normalize(vec3(0.3,0.3,1.0));\n\nvec3 getSkyCol(vec3 rd) {\n    rd = normalize(vec3(rd.xy,max(rd.z,0.))); // prevent below horizon\n    vec3 sky = mix(vec3(0.8,0.9,1.0), vec3(0.3,0.6,0.9), rd.z); // higher => darker\n    vec3 sun = 1.5*vec3(0.95,0.9,0.5)*pow(max(dot(rd,sundir),0.), 8.); // warm color\n    return sky + sun;\n}\n\n\n/* MAIN */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // pass uniforms to Common\n    ZERO = min(iFrame, 0);\n    uTime = iTime;\n\n    // set camera\n    float rx = iMouse.z!=0.0 ? 1.65*(iMouse.y/iResolution.y)-0.05 : 0.12; // azimuthal angle\n    float rz = iMouse.z!=0.0 ? -iMouse.x/iResolution.x*4.0*3.14 : 0.5; // polar angle\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));  // far to near\n    vec3 u = vec3(-sin(rz),cos(rz),0);  // left to right\n    vec3 v = cross(w,u);  // down to up\n    vec3 ro = vec3(0,0,0.5)+6.0*w-0.5*u+0.2*v;  // ray origin\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);  // ray direction\n\n    // ray intersection\n    float t, t1=40.;\n    int intersect_id = -1;\n    if (intersectBeach(ro, rd, t, t1)) intersect_id=0, t1=t;\n    if (intersectConch(ro, rd, t, t1, 0.02)) intersect_id=1, t1=t;\n    t = t1;\n    \n    // shading\n    vec3 p = ro+rd*t;\n    vec3 col; // final color\n    float shadow = calcShadow(p, sundir);\n    if (intersect_id == -1) { // background\n        col = vec3(1.0); // this will be blended to sky color later\n    }\n    if (intersect_id == 0) { // beach/sea\n        vec3 n = normalize(gradGround(p));\n        //n *= -sign(dot(n,rd)); // faceforward\n        vec3 albedo = mapGround(p).yzw; // raw color\n        vec3 amb = 0.2*albedo; // ambient\n        vec3 dif = 0.6*(0.3+0.7*shadow) * max(dot(n,sundir),0.0) * albedo; // diffuse\n        vec3 spc = intersectConch(p,reflect(rd,n),t1,2.,0.05) // reflection\n            ? vec3(0.05,0.045,0.04) // occluded, conch color\n            : vec3(0.2-0.1*tanh(0.5*p.y)) * getSkyCol(reflect(rd,n)); // sky color, wetter reflects more\n        col = amb+dif+spc;\n    }\n    if (intersect_id == 1) { // shell\n        vec3 n0 = gradShell(p); // raw gradient\n        //n0 *= -sign(dot(n0,rd)); // faceforward\n        vec3 n = normalize(n0); // normal\n        vec3 albedo = albedoShell(p, n0); // color based on gradient\n        vec3 amb = (0.4-0.1*dot(rd,n))*albedo; // ambient light\n        vec3 dif = albedo*(\n            vec3(0.45,0.4,0.35)*max(dot(n,sundir),0.0)+ // sunlight, warm\n            vec3(0.2,0.3,0.4)*max(n.z,0.)); // skylight, blueish\n        col = pow(amb+dif, vec3(0.8));\n    }\n    col = mix(getSkyCol(rd), col, exp(-0.04*max(t-5.,0.))); // sky blending/fog\n    col += 0.5*vec3(0.8,0.5,0.6)*pow(max(dot(rd,sundir),0.),1.5);  // sun haze\n    col = pow(0.95*col, vec3(1.25)); // adjustment\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// Common: Modeling\n// Image: Rendering\n\n\n// Constants/Uniforms\nint ZERO;\nfloat uTime;\n\n\n/* SHELL */\n\n// Functional shell manually exported from this \"graphing calculator\":\n// https://harry7557558.github.io/tools/raymarching-implicit/index.html\n#define _uv float u, float v\n#define _xyz float x, float y, float z\n#define PI 3.1415926\nconst float a_o = 0.16*PI; // half of opening angle\nconst float b = 0.6; // r=e^bt\nfloat s_min(float a, float b, float k) { return -1./k*log(exp(-k*a)+exp(-k*b)); } // smoothed minimum\n\n// Cross section\nfloat C_m(_uv) { return 1.-(1.-0.01*exp(sin(12.*PI*(u+2.*v))))*exp(-5.*v*5.*v); } // mid rod\nfloat C_s(_uv) { // basic cross section\n    float _x = u-exp(-16.*v);\n    float _y = v*(1.-0.2*exp(-4.*sqrt(u*u+.1*.1)))-0.5+0.5*exp(-v)*sin(4.*u)+.2*cos(2.*u)*exp(-v);\n    return (sqrt(_x*_x+_y*_y)-0.55)*tanh(5.*sqrt(2.*u*u+(v-1.2)*(v-1.2)))+.01*sin(40.*u)*sin(40.*v)*exp(-(u*u+v*v));\n}\nfloat C_0(_uv) { return abs(C_s(u,v))*C_m(u,v); } // single layer\nfloat n_1(_uv) { return log(sqrt(u*u+v*v))/b+2.; } // index of layer\nfloat a_1(_uv) { return atan(v,u)/a_o; } // opening angle, 0-1\nfloat d_1(_uv, float s_d) { // map to layer\n    float n = n_1(u,v);\n    return 0.5*sqrt(u*u+v*v)*C_0(n>0.?n-s_d:fract(n)-s_d,a_1(u,v));\n}\nfloat C(_uv) { return min(d_1(u,v,0.5),d_1(u,v,1.5)); } // result cross section\n\n// Spiral\nfloat l_p(float x, float y) { return exp(b*atan(y,x)/(2.*PI)); } // a multiplying factor\nfloat U(_xyz) { return exp(log(-z)+b*atan(y,x)/(2.*PI)); } // xyz to cross section u\nfloat V(_xyz) { return sqrt(x*x+y*y)*l_p(x,y); } // xyz to cross section v\nfloat S_s(_xyz) { return C(U(x,y,z),V(x,y,z))/l_p(x,y); } // body\nfloat S_o(_xyz) { return sqrt(pow(C(exp(log(-z)-b/2.),-x*exp(-b/2.))*exp(b/2.),2.)+y*y); } // opening\nfloat S_t(_xyz) { return d_1(-z,sqrt(x*x+y*y),0.5); } // tip\nfloat S_a(_xyz) { return -z>0.?min(S_s(x,y,z),S_o(x,y,z)):S_t(x,y,z); } // body+tip\nfloat S_0(_xyz) { return S_a(x,y,z)-0.01-0.01*pow(x*x+y*y+z*z,0.4)\n    -0.02*sqrt(x*x+y*y)*exp(cos(8.*atan(y,x)))\n    -0.007*(0.5-0.5*tanh(10.*(z+1.+8.*sqrt(3.*x*x+y*y)))); } // subtract thickness\nfloat S_r(_xyz) { return -s_min(-S_0(x,y,z),z+1.7,10.); } // clip bottom\nfloat r_a(_xyz) { return -0.1*sin(3.*z)*tanh(2.*(x*x+y*y-z-1.5)); } // thicken the bottom \"rod\"\nfloat S(_xyz) { return S_r(x-r_a(x,y,z)*y,y+r_a(x,y,z)*x,z-0.8); }\n\n\n// Rotation matrices\nmat3 rotx(float a) { return mat3(1, 0, 0, 0, cos(a), sin(a), 0, -sin(a), cos(a)); }\nmat3 rotz(float a) { return mat3(cos(a), sin(a), 0, -sin(a), cos(a), 0, 0, 0, 1); }\n\n// Returns the SDF of the shell\nfloat mapShell(vec3 p) {\n    // position and orientation\n    vec3 q = rotz(0.125*PI)*rotx(0.38*PI)*(0.7*p-vec3(0,0,0.26));\n    // a relatively cheap bounding box to speed up rendering and reduce discontinuities\n    float bound = length(vec3(vec2(1.2,1.4)*exp(q.z*q.z),1.)*q)/exp(q.z*q.z)-1.0;\n    bound = max(bound, length(vec3(1.2,1.4,1)*(q+vec3(0,0.1,0)))-1.);\n    float boundw = 0.2;  // padding of the bounding box for continuous transition\n    if (bound > 0.0) return bound+boundw;  // outside bound\n    else {\n        float v = S(q.x,q.y,q.z); // sample raw SDF\n        // do some hacking to reduce the high gradient and discontinuities\n        // Adjusted with the help of this SDF visualizer:\n        // - https://www.shadertoy.com/view/ssKGWR\n        // - https://github.com/harry7557558/Shadertoy/blob/master/spiral/functional_conch.glsl\n        float k = 1.0-0.9/length(vec3(4.*q.xy,1.0*abs(q.z+0.7)+1.));  // reduce gradient at the bottom\n        k = 0.7*mix(k, 1.0, clamp(10.*max(-q.x,q.z-.7*q.x+0.5), 0., 1.));  // reduce a discontinuity\n        v = k*v/0.7;  // dividing by 0.7 is due to scaling\n        // continuous transition between bound and SDF\n        v = mix(v, bound+boundw, smoothstep(0.,1.,(bound+boundw)/boundw));\n        //return v; return min(v,1.0);  // this two are broken in Firefox for me\n        return min(v,0.1);\n    }\n}\n\n// Numerical gradient of the shell SDF\nvec3 gradShell(vec3 p) {\n    // https://iquilezles.org/articles/normalsSDF/\n    const float h = 0.001;\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++) {\n        vec3 e = 2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0;\n        n += e*mapShell(p+e*h);\n    }\n    return n*(.25/h);\n}\n\n// Color calculated from position and gradient\n// Interpolating two colors based on gradient magnitude\nvec3 albedoShell(vec3 p, vec3 g) {\n    // gradient magnitude => interpolation parameter\n    float t = 0.5-0.5*cos(2.0*log(0.6*length(g)));\n    t += 0.05*sin(40.*p.x)*sin(40.*p.y)*sin(20.*p.z); // some noise\n    vec3 col = mix(vec3(0.9,0.9,0.85), vec3(0.75,0.55,0.3), t); // interpolation\n    col = min(1.2*col, vec3(1.0)); // adjustments\n    return col;\n}\n\n\n/* NOISE */\n\n// Hash function by David Hoskins, https://www.shadertoy.com/view/4djSRW, MIT license\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n// Gradient noise\nfloat GradientNoise2D(vec2 xy) {\n    float i0 = floor(xy.x), i1 = i0 + 1.0;\n    float j0 = floor(xy.y), j1 = j0 + 1.0;\n    float v00 = dot(2.0 * hash22(vec2(i0, j0)) - 1.0, xy - vec2(i0, j0));\n    float v01 = dot(2.0 * hash22(vec2(i0, j1)) - 1.0, xy - vec2(i0, j1));\n    float v10 = dot(2.0 * hash22(vec2(i1, j0)) - 1.0, xy - vec2(i1, j0));\n    float v11 = dot(2.0 * hash22(vec2(i1, j1)) - 1.0, xy - vec2(i1, j1));\n    float xf = xy.x - i0; xf = xf * xf * xf * (10.0 + xf * (-15.0 + xf * 6.0));\n    float yf = xy.y - j0; yf = yf * yf * yf * (10.0 + yf * (-15.0 + yf * 6.0));\n    return v00 + (v10 - v00)*xf + (v01 - v00)*yf + (v00 + v11 - v01 - v10) * xf*yf;\n}\n\n\n/* SEA + BEACH */\nvec4 smin(vec4 a, vec4 b, float k) {\n    // smoothed blending with color\n    float h = clamp(0.5 + 0.5 * (b.x - a.x) / k, 0., 1.);\n    float d = mix(b.x, a.x, h) - k * h * (1.0 - h);\n    return vec4(d, mix(b.yzw, a.yzw, h));\n}\nvec4 mapGround(vec3 p) {\n    // returns drgb\n    float time = 0.25*PI*uTime; // animation time\n    float beach = 0.4*tanh(0.2*p.y)-0.2*GradientNoise2D(0.5*p.xy); // height\n    beach *= smoothstep(0.,1., 0.5*(1.+exp(0.3*p.x))\n        * (length(vec2(1.4,1.0)*p.xy-vec2(-0.2,-0.2))-0.5)); // shell \"pit\"\n    float sea = -0.2+0.1*exp(sin(time)); // animated sea level\n    if (abs(p.z-sea)<0.1)  // sea wave\n        sea += 0.005*tanh(2.*max(sea-beach,0.)) * // fade when close to beach\n            sin(10.*(p.x-uTime-sin(p.y)))*sin(10.*(p.y+uTime-sin(p.x)));\n    if (abs(p.z-beach)<0.1)  // sand grains\n        beach += 0.005*tanh(5.*max(beach-sea,0.)) // fade when close to sea\n            * GradientNoise2D(50.0*p.xy);\n    vec3 seacol = mix(vec3(0.65,0.85,0.8),vec3(0.2,0.55,0.45),\n        smoothstep(0.,1.,-0.1*p.y)); // sea color, deeper when further\n    seacol = mix(vec3(1.), seacol, clamp(4.*(sea-beach),0.,1.)); // white foam\n    seacol = mix(vec3(1.1), seacol, clamp(20.*(sea-beach),0.,1.)); // whiter foam\n    vec3 beachcol = mix(vec3(0.7,0.7,0.6),vec3(0.9,0.85,0.8),\n        clamp(5.*(beach-sea),0.,1.)); // beach color, darker when wetter\n    vec4 ground = smin(vec4(-sea,seacol), vec4(-beach,beachcol), // water-sand transition\n        0.01-0.005*cos(time)); // sharper when rising, smoother when falling\n    return vec4(p.z+ground.x, min(ground.yzw,1.));\n}\nvec3 gradGround(vec3 p) {\n    // https://iquilezles.org/articles/normalsSDF/\n    const float h = 0.01;\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++) {\n        vec3 e = 2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0;\n        n += e*mapGround(p+e*h).x;\n    }\n    return n*(.25/h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2yW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[519, 582, 664, 664, 1008], [1009, 1009, 1084, 1114, 1676], [1678, 1693, 1729, 1755, 2202], [2231, 2231, 2293, 2342, 2782], [2841, 2841, 2866, 2866, 3130], [3145, 3145, 3202, 3233, 5691]]}
{"id": "fddBDM", "name": "Cheap Lightning Flashes", "author": "gehtsiegarnixan", "description": "Tries to generate quasi random Lightning Flashes faster than a texture lookip. You can pick the parameters with the mouse", "tags": ["voronoi", "mouse", "fast", "fake", "cheap", "lightning", "cellular", "flash"], "likes": 6, "viewed": 202, "published": 3, "date": "1656596058", "time_retrieved": "2024-07-30T16:42:17.619383", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a variant of Shane's Cellular Tiling \n(https://www.shadertoy.com/view/4scXz2, https://www.shadertoy.com/view/MdKXDD).\nHis versions are pretty extensively commented so give it a read.\n\nThis is trying to emulate quasi random flashes of lightning to be used with a\nlightning map. This works by moving two differently angled square grids over \neach other. You can clearly see it if you increase the bias to like 0.8. \n\nI also have a slightly worse tiling function sflashyTiling, that doesn't produce\nperfectly round flashes, but they are a bit faster. Its bias works a bit\ndifferent so adjust it seperatly. I can't tell them appart in my clouds, so I \nwould recomend trying the cheaper variant. \n\nI changed a number of things to make it simpler and easier to understand. \nYou can also select a number of parameters with the mouse.\n- GridRes controls the size of the first grid sample\n- Degree is controlled by the y-axis of the mouse. It selects the degree of \n      rotation of each grid is offset to each other. You should avoid multiple \n      of 45 degrees and a few degrees around it.\n- Scale selects the size difference for each grid layer. Note that values \ngreater than about +-10% will make the edges rounded.\n- Bias controls the size of the flashes and a bit their number. \n- Offset controls how much the grids are offset from each other or with iTime\nthe speed of the flashes. \n\nIf you want see if this is faster than a texture lookup see the \nhere (https://www.shadertoy.com/view/sd3fDM).\n*/\n\n// Text on Screen from Piperoman https://www.shadertoy.com/view/XllSWl\nfloat DigitBin(const in int x) {\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces) {\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) \n    {\n\t\tif(fDigitIndex > fBiggestIndex) \n        {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} \n        else \n        {\t\t\n\t\t\tif(fDigitIndex == -1.0) \n            {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} \n            else \n            {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// makes YlGnBu_r colormap with polynimal 6 from https://www.shadertoy.com/view/Nd3fR2\nvec3 YlGnBu_r(float t) {\n    const vec3 c0 = vec3(0.016999,0.127718,0.329492);\n    const vec3 c1 = vec3(1.571728,0.025897,2.853610);\n    const vec3 c2 = vec3(-4.414197,5.924816,-11.635781);\n    const vec3 c3 = vec3(-12.438137,-8.086194,34.584365);\n    const vec3 c4 = vec3(67.131044,-2.929808,-58.635788);\n    const vec3 c5 = vec3(-82.372983,11.898509,47.184502);\n    const vec3 c6 = vec3(31.515446,-5.975157,-13.820580);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// creates a sphere grid of the squared distance to the center\nfloat sphereGrid(vec2 uv) {\n    vec2 squaregrid = fract(uv) - .5; //rectangular grid with center in the middle\n    float spheregrid = dot(squaregrid, squaregrid); //squared distance form scenter\n    return spheregrid;\n}\n\n#define pi              3.1415926536\n// makes a tiling flashing pattern https://www.desmos.com/calculator/kcmr5ftqqw\nfloat flashyTiling(vec2 uv, float degree, float scale, vec2 offset, float bias) {\n    float grid1 = sphereGrid(uv - offset); // first grid\n    \n    // choose a deg/scale and precalulate this when you picked your paramters\n    float rad = (pi* degree)/180.; //degree to radians\n    mat2 m = mat2(cos(rad), -sin(rad), sin(rad), cos(rad)); // rotation matric\n    m *= scale; // this make the rmatrix also scale\n    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    float grid2 = sphereGrid(uv +offset.xy); // blending the voronoi with \n    \n    float comb = (-grid1 -grid2 +bias)*(1./bias); // inverting adding bias\n    comb = clamp(comb, 0., 1.); //saturate\n    return comb; //sqrt for center distance, 1.5 for 0-1 range\n}\n\n// sine grid, a bit faster than spheregrid\nfloat bubble(vec2 uv) {\n    vec2 d = sin(uv*pi); //remove pi for pi sized grid\n    return abs(d.x*d.y);    \n}\n\n// makes a faster tiling flashing pattern, but not perfectly spherical anymore \n// https://www.desmos.com/calculator/qsqd4w4sq6\nfloat sflashyTiling(vec2 uv, float degree, float scale, vec2 offset, float bias) {\n    float grid1 = bubble(uv - offset); // first grid\n    \n    // choose a deg/scale and precalulate this when you picked your paramters\n    float rad = (pi* degree)/180.; //degree to radians\n    mat2 m = mat2(cos(rad), -sin(rad), sin(rad), cos(rad)); // rotation matric\n    m *= scale; // this make the rmatrix also scale\n    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    float grid2 = bubble(uv +offset.xy); // blending the voronoi with \n    \n    float comb = (grid1 +grid2 +bias-2.)*(1./bias); // inverting adding bias\n    comb = clamp(comb, 0., 1.); //saturate to catch rounding errors\n    return comb; //0-1 range\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 4.0; //Hex Grid Size\n    float bias = .2; //size and kind of number of the flashes\n    vec2 offset = vec2(iTime*.2, iTime*1.); //movement\n    \n    // mouse controls\n    float scale = .93; //default values for preview\n    float degree = 55.; // default values for preview\n    if(iMouse.x > 0.0)\t{\n        vec4 mouse = iMouse / iResolution.y;\n        scale = .17 * mouse.x +.85;  // value range .85-1.15\n        degree = mouse.y  * 90.; // it's a square gird going going larger than 90 is pointless\n    }\n        \n    //UV needs to be offset by a large vector from the 0,0, and avoiding 120/90/60 ... deg\n    vec2 offset2 = vec2(379., 769.); // two arbitrary large prime numbers\n    vec2 uv = vec2(fragCoord/iResolution.y); // uv scaled and offset\n    uv = (uv+offset2)*gridRes;\n    \n    float vor = flashyTiling(uv, degree, scale, offset, bias); // generating cell Tilling    \n    \n    vec3 vColour = YlGnBu_r(vor); // applying cosmetic colormap\n    \n    // Text portion\n    float fDigits = 1.0;\n\tfloat fDecimalPlaces = 3.0;\t\n    vec2 vFontSize = vec2(8.0, 15.0); // Multiples of 4x5 work best\n    \n    if(iMouse.x > 0.0)\t{\n        // Plot Mouse Pos Point\n\t    float fDistToPointB = length( vec2(iMouse.x, iMouse.y) - fragCoord.xy) - 4.0;\n\t    vColour = mix(vColour, vec3(0.0, 1.0, 0.0), (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n        \n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = iMouse.xy + vec2(-62.0, 6.0);\n\t\tfloat fValue2 = scale;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit2 = PrintValue(fragCoord, vPixelCoord2, vFontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = iMouse.xy + vec2(0.0, 6.0);\n\t\tfloat fValue3 = degree;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue(fragCoord, vPixelCoord3, vFontSize, fValue3, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\n\t}\n    \n    fragColor = vec4(vColour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddBDM.jpg", "access": "api", "license": "mit", "functions": [[4088, 4175, 4199, 4199, 4653], [4655, 4718, 4745, 4745, 4937], [4976, 5056, 5137, 5137, 5803], [5805, 5848, 5871, 5871, 5957], [5959, 6087, 6169, 6169, 6820], [6822, 6822, 6879, 6879, 8831]]}
{"id": "NstfWM", "name": "Fire Plume (No Particles)", "author": "sdfgeoff", "description": "A flame effect that lies somewhere between scrolling textures and a simulation. It works by approximating the airflow velocity and using that to alter the sampling distance. This creates nice wisps.", "tags": ["flame"], "likes": 7, "viewed": 539, "published": 3, "date": "1656593216", "time_retrieved": "2024-07-30T16:42:18.579815", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\nvec3 neon(float val, vec3 color) {\n\tfloat r = clamp(val, 0.0, 1.0);\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r16 = r4 * r4;\n    vec3 c = color;\n    vec3 c2 = pow(color, vec3(4.0)); // A darker, more saturated version of color\n    \n\tvec3 outp = vec3(0.0);\n\toutp += c2 * r2; // Darker color falloff\n\toutp += c * r4; // Specified Color main part\n\toutp += vec3(1.0) * r16; // White core\n\treturn outp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 delta = vec2(0.001, 0.01);\n    float heat_below = texture(iChannel0, uv + vec2(0.0, -0.01), 2.0).a;\n    float airflow_velocity = heat_below;\n    delta *= airflow_velocity;\n    \n    float heat_below_left = texture(iChannel0, uv + vec2(delta.x, -delta.y)).a;\n    float heat_below_right = texture(iChannel0, uv + vec2(-delta.x, -delta.y)).a;\n    \n    vec3 rand = hash33(vec3(fragCoord, iTime)) - 0.5;\n    vec3 rand1 = hash33(vec3(iTime));\n    \n    float diff = (heat_below_right - heat_below_left);\n    float ratio = clamp(-diff * 1.0 + rand1.x * 0.5, -0.5, 0.5);\n    float heat = mix(heat_below_left, heat_below_right, ratio + 0.5);\n    heat *= 0.97;\n    \n    \n    if (iFrame == 0) {\n        heat = 0.0;\n    }\n    float heat_source = clamp(1.0 - length((uv - vec2(0.35 + rand.y * 0.1 + rand1.y * 0.2, 0.0)) * vec2(2.0, 1.0)) * 10.0, 0.0, 1.0);\n    \n    \n    heat += heat_source;\n    \n    fragColor = vec4(neon(pow(heat * 0.3, 1.0), vec3(1.0, 0.5, 0.1)),heat);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstfWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 215]]}
{"id": "ss3fW7", "name": "Simpler God Rays", "author": "akufishi", "description": "Very simple post processing god rays shader", "tags": ["rays", "post", "god", "crepuscular", "processing"], "likes": 2, "viewed": 402, "published": 3, "date": "1656577934", "time_retrieved": "2024-07-30T16:42:19.406604", "image_code": "const int NumSamples = 100;\nconst float Density = 0.85f;\nconst float Weight = 0.01f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //delta between current pixel and light position\n    vec2 delta = uv - vec2(0.5);\n    \n    //define sampling step\n    delta *= 1.0f / float(NumSamples) * Density;\n    \n    //initial color\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    float illuminationDecay = 0.9f;\n    \n    for(int i = 0; i < NumSamples; i++)\n    {\n        //peform sampling step\n        uv -= delta;\n        \n        //decay the ray\n        vec3 color_sample = texture(iChannel0, uv).rgb;\n        \n        color_sample *= illuminationDecay * Weight;\n        \n        //original color + ray sample\n        color += color_sample;\n    }\n\n    // Output to screen\n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 circle(vec2 uv, vec2 pos, float radius)\n{\n    return vec3(float(dot(uv - pos, uv - pos) < radius * radius) * 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ms = iMouse.xy / iResolution.xy;\n    \n    fragColor = vec4(vec3(0.0), 1.0);\n\n    fragColor.rgb += circle(uv, vec2(0.5), 0.1);\n    fragColor.rgb -= circle(uv, ms, 0.1);\n    fragColor.rgb -= circle(uv, ms + vec2(0.2, 0.0), 0.05);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3fW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 143, 143, 858]]}
{"id": "ss3fDM", "name": "testing cineshader toy", "author": "alialsawad", "description": "test", "tags": ["cineshader"], "likes": 3, "viewed": 3037, "published": 3, "date": "1656570892", "time_retrieved": "2024-07-30T16:42:20.300215", "image_code": "float opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.5 + 0.5 * cos((b + iTime * 3.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3fDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 151], [153, 153, 188, 188, 212], [215, 215, 234, 234, 569], [571, 571, 601, 601, 883], [885, 885, 942, 942, 1660]]}
{"id": "sd3fDM", "name": "PerfTest Texture VS Cell Tiling", "author": "gehtsiegarnixan", "description": "Simple a quick performance test designed to tank your FPS to see which operation is faster.", "tags": ["voronoi", "test", "fast", "performance", "cell", "speed"], "likes": 2, "viewed": 160, "published": 3, "date": "1656569949", "time_retrieved": "2024-07-30T16:42:21.469090", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nThis is a perfromance test to see what it takes to make a cheap voronoi faster \nthan a texture lookup. As it turns out you have to cut almost everything.\n\nTwo layers of rotated sphere square grids are all that is allowed. \nI wonder what one can still add to make it more irregular, while being faster\nthan a texturelookup. This may be usefull for animation that supplements a more\ncomplex shader. \n\nIf you want to test for yourself the tests are in the main. Just comment in\nthe test of your choice and up the repeat number. \n\nThese are a variant of Shane's Cellular Tiling \n(https://www.shadertoy.com/view/4scXz2, https://www.shadertoy.com/view/MdKXDD).\nIt is also better commented than mine so check them out. \n\nIf you want select the \"seed\" for your pattern see my variant\n(https://www.shadertoy.com/view/NscBWM).\n*/\n\n// loads a texture pretend its a voronoi noise texture\nfloat loadTexture(vec2 uv) {       \n    return texture(iChannel0, uv).x;\n}\n\n// load a volumetric Texture pretend its a 3D voronoi noise texture\nfloat load3DTexture(vec3 uvw) {       \n    return texture(iChannel1, uvw).x;\n}\n\n// Wrappable circle distance. The squared distance, to be more precise.\nfloat drawShape(in vec2 p){\n    p = fract(p) - .5;    \n    return dot(p, p);\n}\n\n// Celluar Tiling from Shane https://www.shadertoy.com/view/4scXz2\n// Draw some cirlcles on a repeatable tile. The offsets were partly based on science, but\n// for the most part, you could choose any combinations you want.\nfloat cellTex(in vec2 p) {  \n    float c = .25; // Set the maximum, bearing in mind that it is multiplied by 4.\n    \n    // Draw four overlapping shapes (circles, in this case) using the darken blend \n    // at various positions on the tile.\n    c = min(c, drawShape(p - vec2(.80, .62)));\n    c = min(c, drawShape(p - vec2(.38, .20)));\n    \n    c = min(c, drawShape(p - vec2(.60, .24)));\n    c = min(c, drawShape(p - vec2(.18, .82)));\n\n    // Draw four smaller circles at various positions on the tile.\n    // By the way, when using rotation, decreasing the size is optional.\n    p *= 1.4142;  \n    //p = p.yx; // Extra option, or addition.\n    c = min(c, drawShape(p - vec2(.46, .30)));\n    c = min(c, drawShape(p - vec2(.04, .88))); \n  \n    // More shapes produce a more convincing pattern, but you could cut\n    // these two out and still produce a decent image.\n    c = min(c, drawShape(p - vec2(.06, .54)));\n    c = min(c, drawShape(p - vec2(.64, .12)));  \n    \n    return sqrt(c*4.);    \n}\n\n// Rotating Celluar Tiling from Shane https://www.shadertoy.com/view/4scXz2\nfloat rotCellTex(in vec2 p) {  \n    float c = .25; // Set the maximum, bearing in mind that it is multiplied by 4.\n    \n    // Draw four overlapping shapes (circles, in this case) using the darken blend \n    // at various positions on the tile.\n    c = min(c, drawShape(p - vec2(.80, .62)));\n    c = min(c, drawShape(p - vec2(.38, .20)));\n    \n    // Rotate the layer (coordinates) by 120 degrees. Layer rotation \n    // drastically improves randomness, for very little extra cost.\n    p = mat2(.5, -.866, .866, .5)*(p - .5); // \n    c = min(c, drawShape(p - vec2(.60, .24)));\n    c = min(c, drawShape(p - vec2(.18, .82)));\n\n    // Draw four smaller circles at various positions on the tile.\n    // By the way, when using rotation, decreasing the size is optional.\n    p *= 1.4142;  \n    //p = p.yx; // Extra option, or addition.\n    c = min(c, drawShape(p - vec2(.46, .30)));\n    c = min(c, drawShape(p - vec2(.04, .88))); \n\n    // Rotate the layer (coordinates) by 120 degrees. \n    p = mat2(.5, -.866, .866, .5)*(p - .5);   \n    // More shapes produce a more convincing pattern, but you could cut\n    // these two out and still produce a decent image.\n    c = min(c, drawShape(p - vec2(.06, .54)));\n    c = min(c, drawShape(p - vec2(.64, .12)));  \n    \n    return sqrt(c*4.);    \n}\n\n// creates a sphere grid of the squared distance to the center\nfloat sphereGrid(vec2 uv) {\n    vec2 squaregrid = fract(uv) - .5; //rectangular grid with center in the middle\n    float spheregrid = dot(squaregrid, squaregrid); //squared distance form scenter\n    return spheregrid;\n}\n\n#define cos1            1.0049000034 //cos((pi * 24.)/180.)*1.1\n#define sin1            0.4474103074 //sin((pi * 24.)/180.)*1.1\n// makes a tiling cell pattern with 3 levels\nfloat cellTiling3(vec2 uv) {\n    float c = sphereGrid(uv);// first grid\n        \n    mat2 m = mat2(cos1, -sin1, sin1, cos1); // rotation/scale matric\n    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    c = min(c, sphereGrid(uv)); // blending the voronoi with\n    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    c = min(c, sphereGrid(uv)); // blending the voronoi with \n    \n    return sqrt(c)*1.5; //sqrt for center distance, 1.5 for 0-1 range\n}\n\n// makes a tiling cell pattern with 2 levels\nfloat cellTiling2(vec2 uv) {\n    float c = sphereGrid(uv);// first grid\n    \n    mat2 m = mat2(cos1, -sin1, sin1, cos1); // rotation/scale matric\n     \n    uv *= m; //gets rotated and scaled\n    c = min(c, sphereGrid(uv)); // blending the voronoi with\n    \n    return sqrt(c)*1.5; //sqrt for center distance, 1.5 for 0-1 range\n}\n\n// makes a tiling cell pattern with 2 levels squared very repeating pattern\nfloat cellTiling2squared(vec2 uv) {\n    float c = sphereGrid(uv);// first grid\n        \n    mat2 m = mat2(cos1, -sin1, sin1, cos1); // rotation/scale matric     \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    c = min(c, sphereGrid(uv)); // blending the voronoi with\n        \n    return c*2.; //squared for center distance, 2. for 0-1 range\n}\n\n#define cos2            0.5334260858 //cos((pi * 55.)/180.)*.93\n#define sin2            0.7618114012 //sin((pi * 55.)/180.)*.93\n// makes a tiling flashing pattern https://www.desmos.com/calculator/kcmr5ftqqw\nfloat flashyTiling(vec2 uv, float bias) {\n    vec2 offset = vec2(iTime*.2, iTime*1.); //movement\n    \n    float grid1 = sphereGrid(uv - offset); // first grid\n    \n    mat2 m = mat2(cos2, -sin2, sin2, cos2); // rotation/scale matric    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    float grid2 = sphereGrid(uv +offset.xy); // blending the voronoi with \n    \n    float comb = (-grid1 -grid2 +bias)*(1./bias); // inverting adding bias\n    comb = clamp(comb, 0., 1.); //saturate\n    return comb; //sqrt for center distance, 1.5 for 0-1 range\n}\n\n#define pi              3.1415926536\n// sine grid, a tiny bit faster than spheregrid\nfloat bubble(vec2 uv) {\n    vec2 d = sin(uv); //remove pi for pi sized grid\n    return abs(d.x*d.y);    \n}\n\n// makes a faster tiling flashing pattern https://www.desmos.com/calculator/bnpkohjent\nfloat sflashyTiling(vec2 uv, float bias) {\n    vec2 offset = vec2(iTime*.6, iTime*3.); //movement\n    \n    float grid1 = bubble(uv - offset); // first grid\n    \n    mat2 m = mat2(cos2, -sin2, sin2, cos2); // rotation/scale matric    \n    uv *= m; //each iteration gets rotated and scaled one addional time\n    float grid2 = bubble(uv +offset.xy); // blending the voronoi with \n    \n    float comb = (grid1 +grid2 +bias-2.)*(1./bias); // inverting adding bias\n    comb = clamp(comb, 0., 1.); //saturate to catch rounding errors\n    return comb; //0-1 range\n}\n\n// creates a 3D sphere grid of the squared distance to the center\nfloat sphereGrid(vec3 uv) {\n    vec3 squaregrid = fract(uv) - .5; //rectangular grid with center in the middle\n    float spheregrid = dot(squaregrid, squaregrid); //squared distance form scenter\n    return spheregrid;\n}\n\n#define cos3             0.8973775077 //cos((pi * 33.)/180.)*1.07\n#define sin3             0.5827637675 //sin((pi * 33.)/180.)*1.07\n#define sqrCos3          0.7526041040 //cos((pi * 33.)/180.)^2 *1.07\n#define sqrSin3          0.3173958960 //sin((pi * 33.)/180.)^2 *1.07\n#define sinCos3         -0.4887468198 //-sin((pi * 33.)/180.)*cos((pi * 33.)/180.)*1.07\n// makes a 3D tiling cell pattern with two levels\nfloat cellTiling3D(vec3 uvw) {\n    float c = sphereGrid(uvw); // first grid\n    \n    // rotation/scale matric desmos.com/calculator/refsu6mvlj\n    mat3 m = mat3(cos3, sinCos3, sqrSin3,\n                  sin3, sqrCos3, sinCos3,\n                  0., sin3, cos3);\n    uvw *= m; //each iteration gets rotated and scaled one addional time\n    c = min(c, sphereGrid(uvw)); // blending the voronoi with \n    \n    return sqrt(c); //sqrt for center distance, 1.5 for 0-1 range\n}\n\n#define cos4             0.8660254038 //cos((pi * 30.)/180.)*1.\n#define sin4             0.5 //sin((pi * 30.)/180.)*1.\n#define cos5             0.5 //cos((pi * 60.)/180.)*1.\n#define sin5             0.8660254038 //sin((pi * 60.)/180.)*1.\n// makes a 3D tiling cell pattern with two levels with different rotation\nfloat cellTiling3D2(vec3 uvw) {\n    // rotation/scale matric desmos.com/calculator/refsu6mvlj\n    mat3 mY = mat3(cos4, 0., sin4,\n                   0., 1., 0.,\n                  -sin4, 0., cos4); // rotation matric Y Axis\n    float c = sphereGrid(uvw*mY); // first grid    \n\n    mat3 mX = mat3(1., 0., 0.,\n                   0., cos5, -sin5,\n                   0., sin5, cos5); // rotation matric X Axis  \n    c = min(c, sphereGrid(uvw*mX)); // blending the grids \n    \n    return sqrt(c); //sqrt for center distance, 1.5 for 0-1 range\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 8.0; //Hex Grid Size\n    vec2 uv = fragCoord/iResolution.y*gridRes; //square UVs\n    \n    // if you get around 144 fps use a higher repeat value\n    int repeat = 1; //2000 is enough for RTX2070\n    float test;\n    for(int i=0; i<repeat; i++) {  \n        float per = sin(float(i)); //new permutation each iteration\n        vec2 a = uv + per; \n        \n        // use which ever you wish to test\n        //float grid = loadTexture(a); //loading a texture: 75fps\n        //float grid = load3DTexture(vec3(a,per)); //loading voltex: 63fps\n        //float grid = cellTex(a); //cheap shanes cell grid: 32fps\n        //float grid = rotCellTex(a); //rotated shanes cell grid: 29fps\n        float grid = cellTiling3(a); //my 3 cell grid: 67fps\n        //float grid = cellTiling2(a); //my 2 cell grid: 86fps\n        //float grid = cellTiling2squared(a); //my squared 2 cell grid: 99fps      \n        //float grid = flashyTiling(a, .2); //flashing variant: 85 fps\n        //float grid = sflashyTiling(a*pi, .6); //sine flashing variant: 95fps\n        //float grid = cellTiling3D(vec3(a,per)); //my 2 cell 3d grid: 68fps\n        //float grid = cellTiling3D2(vec3(a,per)); //my 2 cell 3d grid v2: 68fps\n        \n        test += grid; //adding to output so every iteration matters\n    }\n        \n    // Output to screen\n    fragColor = vec4(fract(test));\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3fDM.jpg", "access": "api", "license": "mit", "functions": [[1905, 1960, 1988, 1988, 2034], [2036, 2104, 2135, 2135, 2182], [2184, 2256, 2283, 2283, 2334], [2336, 2559, 2585, 2585, 3554], [3556, 3632, 3661, 3661, 4916], [4918, 4981, 5008, 5008, 5200], [5330, 5375, 5403, 5403, 5878], [5880, 5925, 5953, 5953, 6253], [6255, 6331, 6366, 6366, 6701], [6831, 6911, 6952, 6952, 7482], [7521, 7569, 7592, 7592, 7675], [7677, 7764, 7806, 7806, 8321], [8323, 8389, 8416, 8416, 8608], [8968, 9018, 9048, 9048, 9488], [9728, 9802, 9833, 9895, 10339], [10341, 10341, 10398, 10398, 11761]]}
{"id": "7scyWl", "name": "512x512 Pipelined RGB FFT", "author": "Flyguy", "description": " Computes 4 512x512 horizontal/vertical FFT passes per cubemap face (1 per component R/G/B/A).\nAlpha channel FFT isn't shown by default but can be seen in the SPLIT_COMPONENTS/SPLIT_PHASE modes.", "tags": ["fft", "color", "cubemap", "rgb", "frequency", "fourier", "pipeline"], "likes": 12, "viewed": 467, "published": 3, "date": "1656550557", "time_retrieved": "2024-07-30T16:42:22.454456", "image_code": "#define SPLIT_RGB 0\n#define SPLIT_COMPONENTS 1\n#define SPLIT_PHASE 2\n\n#define VIEW_MODE SPLIT_RGB\n\nvec3 rainbow(float x)\n{\n    vec3 col = vec3(0);\n    col.r = cos(x * tau - (0.0/3.0)*tau);\n    col.g = cos(x * tau - (1.0/3.0)*tau);\n    col.b = cos(x * tau - (2.0/3.0)*tau);\n    \n    return col * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat cubeRes = float(textureSize(iChannel0,0).x);\n    \n    #if(VIEW_MODE == SPLIT_RGB)\n        vec2 uv = floor(fragCoord.xy) / (iResolution.x/2.);\n        float side = floor(uv.x);\n        uv.x = fract(uv.x);\n        uv.y -= (iResolution.y - iResolution.x/2.)/iResolution.x;\n\n        vec2 uvIn = floor(uv*fftSize);\n        uvIn.x = reverseBits(mod(uvIn.x,fftSize), numStages);\n        uvIn /= fftSize*2.;\n        \n        vec2 fftInR = textureCubeFace(iChannel0,0., uvIn+vec2(0.0,0.0)).xy;\n        vec2 fftInG = textureCubeFace(iChannel0,0., uvIn+vec2(0.5,0.0)).xy;\n        vec2 fftInB = textureCubeFace(iChannel0,0., uvIn+vec2(0.0,0.5)).xy;\n        vec3 fftInRGB = vec3(length(fftInR),length(fftInG),length(fftInB));\n\n        vec2 fftR = textureCubeFace(iChannel0,5., uv.yx*(fftSize/cubeRes)+vec2(0.0,0.0)).zw;\n        vec2 fftG = textureCubeFace(iChannel0,5., uv.yx*(fftSize/cubeRes)+vec2(0.5,0.0)).zw;\n        vec2 fftB = textureCubeFace(iChannel0,5., uv.yx*(fftSize/cubeRes)+vec2(0.0,0.5)).zw;\n        vec3 fftRGB = log(-2.0+vec3(fftR.x,fftG.x,fftB.x))/log(fftSize*fftSize);\n        \n        fragColor = (side == 0.) ? vec4(fftInRGB,0) : \n                                   vec4(fftRGB,0);                      \n        fragColor *= step(uv.y,1.0)*step(0.0,uv.y);\n    #endif\n    \n    #if(VIEW_MODE == SPLIT_COMPONENTS)\n        vec2 uv = floor(fragCoord.xy) / (iResolution.x/2.);\n        float side = floor(uv.x);\n        uv.x = fract(uv.x);\n        uv.y -= (iResolution.y - iResolution.x/2.)/iResolution.x;\n\n        vec2 uvIn = floor(uv*cubeRes);\n        vec2 quadOffs = floor(uvIn/fftSize)*fftSize;\n        uvIn.x = quadOffs.x + reverseBits(mod(uvIn.x,fftSize), numStages);\n        vec2 uvFFT = clamp(mod(uv.yx,0.5) + floor(uv/0.5)*0.5, 0.0, (cubeRes-1.0)/cubeRes);\n        \n        vec2 fftIn = textureCubeFace(iChannel0,0., uvIn/cubeRes).xy;\n        vec2 fftHV = textureCubeFace(iChannel0,5., uvFFT).zw;\n        \n        fragColor = (side == 0.) ? vec4(length(fftIn)) : \n                                   vec4(log(0.1+fftHV.x)/log(fftSize*fftSize));                      \n        fragColor *= step(uv.y,1.0)*step(0.0,uv.y);\n    #endif\n    \n    #if(VIEW_MODE == SPLIT_PHASE)\n                vec2 uv = floor(fragCoord.xy) / (iResolution.x/2.);\n        float side = floor(uv.x);\n        uv.x = fract(uv.x);\n        uv.y -= (iResolution.y - iResolution.x/2.)/iResolution.x;\n\n        vec2 uvIn = floor(uv*cubeRes);\n        vec2 offs = floor(uvIn/fftSize)*fftSize;\n        uvIn.x = offs.x+reverseBits(mod(uvIn.x,fftSize), numStages);\n        vec2 fftIn = textureCubeFace(iChannel0,0., uvIn/cubeRes).xy;\n\n        vec2 uvFFT = clamp(mod(uv.yx,0.5)+floor(uv/0.5)*0.5, 0.0,(cubeRes-1.)/cubeRes);\n        vec2 fftHV = textureCubeFace(iChannel0,5., uvFFT).zw;\n        \n        fragColor = (side == 0.) ? vec4(length(fftIn)) : \n                                   vec4(rainbow(fftHV.y),0);                      \n        fragColor *= step(uv.y,1.0)*step(0.0,uv.y);\n    #endif\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float fftSize = 512.;\nconst float numStages = ceil(log2(float(fftSize)));\n\n// -- Constants --\nconst float pi = 3.14159265;\nconst float tau = 6.28318531;\n\n// -- Math Functions --\n\n//Complex multiply\nvec2 cmul(vec2 a,vec2 b)\n{\n\treturn vec2(dot(a,b*vec2(1,-1)), dot(a,b.yx));\n}\n\n//Reverse 0 to 'n' in integer 'x'\nfloat reverseBits(float x, const float n)\n{\n    int r = 0;\n    int xi = int(x);\n    for(int i = 0;i < int(n);i++)\n    {\n        r = r << 1 | (xi & 1);\n        xi >>= 1;\n    }\n    return float(r);\n}\n\n/*\nButterfly operation\n\n(x0)____________(+)_(xy)\n            \\  /\n             \\/\n             /\\\n(x1)_W(i,n)_/__\\(-)_(zw)\n\nxy = x0 + W(i,n)*x1\nzw = x0 - W(i,n)*x1\n\n*/\nvec4 butterfly(vec2 x0, vec2 x1, float i, float n)\n{\n    float a = -floor(i)*tau/floor(n);\n    vec2 w = vec2(cos(a),sin(a));\n    x1 = cmul(x1, w);\n    return vec4(x0 + x1, x0 - x1);\n}\n\n// -- Windowing Functions --\n\n//Rectangular window\nfloat Rectangle(float i, float N)\n{\n    return step(0.0,i)-step(N,i);\n}\n\n//Hann Window\nfloat Hann(float i, float N)\n{\n    float x = clamp(floor(i)/floor(N),0.0,1.0);\n    float w = sin(pi*x);\n    return w*w;\n}\n\n//Triangular window\nfloat Triangle(float i, float N)\n{\n    float x = clamp(floor(i)/floor(N),0.0,1.0);\n    return 1.0-abs(2.0*x - 1.0);\n}\n\n// -- Cubemap Sampling Helper Functions --\n\n//Converts a ray direction to uv coords (xy, normalized) & a face id (z, 0-5).\n//for the cubemap face it's pointing to.\nvec3 rayToFace(vec3 rd)\n{\n    vec3 asign = sign(rd);\n    rd = abs(rd);\n    float amax = max(max(rd.x,rd.y),rd.z);\n    \n    vec3 face = (rd.x == amax) ? vec3(asign.yz*rd.yz, floor(1.+.5*asign.x)) :\n                (rd.y == amax) ? vec3(asign.xz*rd.xz, floor(3.+.5*asign.y)) :\n                (rd.z == amax) ? vec3(asign.xy*rd.xy, floor(5.+.5*asign.z)) : \n                                 vec3(0,0,-1);\n    face.xy = .5+.5*(face.xy/amax);\n    face.xy = floor(face.xy*1024.)/1024.; \n    return face;\n}\n\n//opposite of rayToFace\n//Converts normalized uv coords & a face id to a ray direction\n//for cubemap sampling\nvec3 faceToRay(vec3 face)\n{\n    face.xy = face.xy + 0.5/1024.;\n    vec3 rd = vec3(2.0*fract(face.xy)-1.0, sign(mod(face.z,2.)-.5));\n    rd = (face.z <= 1.) ? rd.zxy :\n         (face.z <= 3.) ? rd.xzy :\n         (face.z <= 5.) ? rd.xyz :\n                          vec3(0);\n    return normalize(rd);\n}\n\n//Sample a cubemap face (0-5) with normalized uv coords.\nvec4 textureCubeFace(samplerCube cube, float face, vec2 uv)\n{\n    vec3 rd = faceToRay(vec3(uv,floor(face)));\n    return texture(cube, rd, 0.0).rgba;  \n}\n\n", "cube_a_code": "\n\n//Input Windowing Function (Rectangle/Triangle/Hann)\n#define WINDOW_FUNCTION Hann\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    float cubeRes = float(textureSize(iChannel0,0).x);\n    vec3 face = rayToFace(rd);\n    vec2 uv = face.xy*cubeRes;\n    \n    vec2 quadOffs = floor(uv/fftSize)*fftSize;\n    int quadId = int(uv.x/fftSize) + 2*int(uv.y/fftSize);\n    \n    uv = mod(uv, vec2(fftSize));\n    \n    float idx = uv.x;\n    float stage = face.z;\n    vec4 cout = vec4(0.0); \n    \n    if(stage == 0.0)\n    {\n        //XY = Horizonal FFT Input (Channel 1)\n        //Input image is mapped 1:1 into the input buffer with no scaling.\n        //Input image centered in the 512x512 buffers.\n        vec2 texRes = iChannelResolution[1].xy;\n        vec2 texUV = vec2(reverseBits(uv.x, numStages), uv.y);\n        vec2 texOrig = vec2(fftSize/2.0)-vec2(texRes/2.0);\n        \n        vec2 windowOrig = texUV - max(vec2(0),texOrig);\n        vec2 windowSize = min(vec2(fftSize),\n                          min(vec2(fftSize) - texOrig,\n                          min(texOrig + texRes, texRes)));\n                          \n        vec4 col = texelFetch(iChannel1, ivec2(texUV - texOrig), 0);\n        \n        cout.xy = vec2(col[quadId], 0);         \n        cout.xy *= WINDOW_FUNCTION(windowOrig.x, windowSize.x);\n        cout.xy *= WINDOW_FUNCTION(windowOrig.y, windowSize.y);\n\n        //ZW = Vertical FFT Input (Horizontal FFT output rotated 90deg)\n        uv.x = float(reverseBits(uv.x, numStages));\n        cout.zw = textureCubeFace(iChannel0, 5.0, (uv.yx + quadOffs.xy)/cubeRes).xy;\n    }\n    else\n    {\n        //2x Horizontal 4-sample FFTs on XY & ZW components\n        float stage1Size = floor(exp2(float(stage)*2.0));\n        float stage0Size = floor(stage1Size/2.0);\n\n        float offs = floor(idx / stage1Size)*stage1Size;\n        idx -= offs;\n        \n        float w0 = mod(idx, stage0Size/2.0);\n        float w1 = mod(idx, stage1Size/2.0);\n        \n        vec4 soffs = mod(offs + w0 + vec4(0,1,2,3)*stage0Size/2., fftSize) + quadOffs.x;\n        uv.y += quadOffs.y;\n        \n        vec4 x0 = textureCubeFace(iChannel0, stage-1.0, vec2(soffs[0], uv.y)/cubeRes);\n        vec4 x1 = textureCubeFace(iChannel0, stage-1.0, vec2(soffs[1], uv.y)/cubeRes);\n        vec4 x2 = textureCubeFace(iChannel0, stage-1.0, vec2(soffs[2], uv.y)/cubeRes);\n        vec4 x3 = textureCubeFace(iChannel0, stage-1.0, vec2(soffs[3], uv.y)/cubeRes);\n\n        vec4 y0y1_H = butterfly(x0.xy, x1.xy, w0 - fftSize/2.0, stage0Size);\n        vec4 y2y3_H = butterfly(x2.xy, x3.xy, w0 - fftSize/2.0, stage0Size);\n\n        vec4 y0y1_V = butterfly(x0.zw, x1.zw, w0 - fftSize/2.0, stage0Size);\n        vec4 y2y3_V = butterfly(x2.zw, x3.zw, w0 - fftSize/2.0, stage0Size);\n        \n        vec4 z0z1_H, z0z1_V;\n        \n        if(mod(idx, stage0Size) < stage0Size/2.0)\n        {\n            z0z1_H = butterfly(y0y1_H.xy, y2y3_H.xy, w1 - fftSize/2.0, stage1Size);            \n            z0z1_V = butterfly(y0y1_V.xy, y2y3_V.xy, w1 - fftSize/2.0, stage1Size);\n        }\n        else\n        {\n            z0z1_H = butterfly(y0y1_H.zw, y2y3_H.zw, w1 - fftSize/2.0, stage1Size);            \n            z0z1_V = butterfly(y0y1_V.zw, y2y3_V.zw, w1 - fftSize/2.0, stage1Size);\n        }\n        \n        cout = (idx < stage1Size/2.0) ? vec4(z0z1_H.xy,z0z1_V.xy): \n                                        vec4(z0z1_H.zw,z0z1_V.zw);\n    }\n    \n    if(face.z == 5.0) //Convert to magnitude/phase on last stage of vertical FFT\n    {\n        cout.zw = vec2(length(cout.zw), atan(cout.w, cout.z)/pi + 0.5);\n    } \n    \n    fragColor = vec4(cout);\n}\n\n\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Debugging Test Pattern\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy/2.0) / iResolution.y;\n    \n    vec4 f = 500.0*vec4(uv.x, uv.y, (uv.x+uv.y)/sqrt(2.0), (uv.x-uv.y)/sqrt(2.0));\n    float l = length(uv)*120.0;\n    \n    fragColor = sin(l)/l * sin(f);\n}\n//*/\n\n//*\nvoid mainImage( out vec4 c, vec2 o )\n{\n    vec2 r = iResolution.xy;o-=r/2.;o*=r.y/512.;\n    o = vec2(length(o) / r.y - .25, atan(o.y,o.x));    \n    vec4 s = c.yzwx = .1*cos(1.6*vec4(0,1,2,3) + iTime + o.y + sin(o.y) * sin(iTime)*2.),\n    f = max(o.x-s, c-o.x);\n    c = dot(10.*(s-c), clamp(f*r.y, 0., 6.)) * (s-.1) + f;\n}\n//*/", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scyWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 122, 122, 307], [309, 309, 366, 366, 3339]]}
{"id": "Ns3BD7", "name": "Pride SPH", "author": "fenix", "description": "*drag with mouse* More kinda-incompressible smoothed-particle hydrodynamics. I suppose it's a metaphor for how people of all kinds have to work together to support the whole? Doesn't work very well at low resolutions...not enough particles.", "tags": ["2d", "voronoi", "simulation", "particles", "flow", "liquid", "sph"], "likes": 6, "viewed": 378, "published": 3, "date": "1656548893", "time_retrieved": "2024-07-30T16:42:23.616349", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Multipass particle physics simulation, attempting to approximate smoothed particle\n//  hydrodynamics. \n// \n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a traditional voronoi search to help out building neighborhoods\n//  Buffer C renders the particles into a density texture\n//  Buffer D blurs the density\n//\n// ---------------------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.xyz = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    //fragColor.xyz = vec3(texture(iChannel1, fragCoord/iResolution.xy).w) * 0.2;\n}\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 25000; \nconst int PARTICLE_INIT_X = 10;\nconst float PARTICLE_SIZE = 0.01;\nconst float PARTICLE_REPEL_SIZE = 0.005;\nconst float MOVING_WALL_MAG = 0.0;\nconst float MOVING_WALL_TIME = 3.0;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, (point.x + 1.0 - MOVING_WALL_MAG - MOVING_WALL_MAG*sin(time / MOVING_WALL_TIME)) * resolution.x / resolution.y);\n    minDist = min(minDist, (1.0 - point.x) * resolution.x / resolution.y);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define FLUID 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    float color;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FLUID), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.color = particleData5.x;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case FLUID:\n        return vec4(p.color, 0.0, 0.0, 0.0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nconst float PI = 3.141592653589793;\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n    {\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    }\n    else\n    {\n        return 0.0;\n    }\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n", "buffer_a_code": "// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\nconst vec2 GRAVITY = vec2(0.0000, -0.00005);\nconst float MAX_SPEED = 0.01;\nconst float DAMPING = 1.0;\nconst float PARTICLE_REPEL = 0.00001;\nconst float WALL_REPEL = 0.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    \n    fxParticle data = fxGetParticle(id);\n    \n    if (dataType == POS_VEL || dataType == FLUID)\n    {\n        if (iFrame == 0)\n        {\n            data.pos = vec2(-100.0, -100.0);\n        }\n        else if(data.pos == vec2(-100.0, -100.0))\n        {\n            const float PARTICLES_PER_SECOND = 2000.0;\n            if (id < int(iTime * PARTICLES_PER_SECOND))\n            {\n                //pick a \"random\" starting position\n                float h1 = hash(id);\n                float h2 = hash(int(h1*41343.));\n                data.pos = vec2(h1,h2) * vec2(0.2, 0.0) + vec2(-1.0 + 1.8 * iTime * PARTICLES_PER_SECOND / float(maxParticles), 1.0);\n                data.vel = vec2(0);\n                data.color = float(id) / float(maxParticles);\n            }\n        }\n        else\n        {\n            vec2 force = GRAVITY;\n            \n            // Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            vec2 disturbDelta = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = ((2.0 * iMouse.xy / iResolution.xy) - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n                disturbDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n                disturbDelta = clamp(disturbDelta, -100.0, 100.0);\n            }\n            else\n            {\n                // auto disturb\n                disturbPos = vec2(sin(iTime * 0.5), sin(iTime * 1.0))* vec2(1.2, 0.2) + vec2(0.0, -0.2);\n                disturbDelta = 75.0 * vec2(cos(iTime * 0.5), cos(iTime * 1.0));\n            }\n            const float MOUSE_FIELD_SIZE = 0.3;\n            const float MOUSE_FIELD_STRENGTH = 0.01;\n            float dist = distance(data.pos * iResolution.xy / iResolution.y, disturbPos);\n            if (dist < MOUSE_FIELD_SIZE)\n            {\n                force += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * disturbDelta / iResolution.xy;\n            }\n\n            // Sample density texture\n            const vec2 SAMPLE_OFFSET = vec2(0.007);\n            float densityU = texture(iChannel2, data.pos * 0.5 + 0.5 + vec2( 0.0,  1.0) * SAMPLE_OFFSET).w;\n            float densityD = texture(iChannel2, data.pos * 0.5 + 0.5 + vec2( 0.0, -1.0) * SAMPLE_OFFSET).w;\n            float densityL = texture(iChannel2, data.pos * 0.5 + 0.5 + vec2(-1.0,  0.0) * SAMPLE_OFFSET).w;\n            float densityR = texture(iChannel2, data.pos * 0.5 + 0.5 + vec2( 1.0,  0.0) * SAMPLE_OFFSET).w;\n            vec2 densityGrad = vec2(densityR - densityL, densityU - densityD);\n\n            float textureDensity = texture(iChannel2, data.pos * 0.5 + 0.5).w;\n\n            // Apply density texture based forces\n            const float IDEAL_DENSITY = 1.4;\n            if (textureDensity > IDEAL_DENSITY)\n            {\n                force -= 0.004 * densityGrad * (textureDensity - IDEAL_DENSITY);\n            }\n            else\n            {\n                force -= 0.0004 * densityGrad * (textureDensity - IDEAL_DENSITY);\n            }\n            \n            vec2 avgVel = data.vel * SPHKernel(0.0);\n\n            // Apply per particle forces and compute average velocity\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid > maxParticles) continue;\n\n                    fxParticle otherData = fxGetParticle(cid);\n                    vec2 otherPos = otherData.pos + otherData.vel * 0.5;\n                    vec2 deltaPos = otherPos - data.pos;\n                    vec2 deltaVel = otherData.vel - data.vel;\n                    float approach = dot(deltaPos, deltaVel);\n                    float dist = length(deltaPos) + 0.001;\n                    float nbDensity = SPHKernel(dist / PARTICLE_REPEL_SIZE);\n                    \n                    avgVel += otherData.vel*nbDensity;\n                     \n                    if (dist < (PARTICLE_REPEL_SIZE + PARTICLE_REPEL_SIZE))\n                    {\n                        force -= ( PARTICLE_REPEL * nbDensity) * normalize(deltaPos);\n                        force += deltaVel * 0.004 * PARTICLE_SIZE / dist;\n                    }\n                    force += deltaVel * 0.003 * PARTICLE_SIZE / dist;\n                }\n            }\n            \n            // Slow down relative to nearby particles\n            force -= 0.002 * (avgVel - data.vel);\n            \n            // Damping\n            data.vel -= data.vel*(1.0*tanh(1.*(length(data.vel))));\n\n            // Clamping\n            float velLength2 = dot(data.vel, data.vel);\n            if (velLength2 > MAX_SPEED * MAX_SPEED)\n            {\n                data.vel *= inversesqrt(velLength2) * MAX_SPEED;\n            }\n\n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, iTime - iTimeDelta);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.00*distNormal * (distToScene - PARTICLE_REPEL_SIZE);// + PARTICLE_SIZE);\n                float velToClip = dot(data.vel, distNormal);\n                if (velToClip < 0.0)\n                {\n                    data.vel -= distNormal * (distToSceneOld - distToScene);                    \n                }\n            }\n\n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, -1.0, 1.0);\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = fxGetParticleData(id, dataType);\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos)));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        //random sorts\n        for (int i = 0; i < 8; ++i)\n        {\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                i\n            );\n            //pick random id of particle\n            int searchId = int(h*float(maxParticles));\n            sort0(bestIds, bestDists, id, searchId, dataType, data.pos);\n        }\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(nb0[i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n            \n            //use a sudorandom direction of the neighbor\n            vec4 nb1 = fxGetParticleData(int(nb0[i]), (iFrame+id)%4);\n            sort0(bestIds, bestDists, id, int(nb1[0]), dataType, data.pos);  \n            sort0(bestIds, bestDists, id, int(nb1[1]), dataType, data.pos);  \n        }\n        \n        if(dataType==UL_NEIGHBORS ) data.neighbors[0] = bestIds;\n        else if(dataType==UR_NEIGHBORS ) data.neighbors[1] = bestIds;\n        else if(dataType==LL_NEIGHBORS ) data.neighbors[2] = bestIds;\n        else                             data.neighbors[3] = bestIds;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return (id < 0) || \n      \t\t(id == currentId) ||\n           any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n    \n    if(dir != (dataType - 1)) return; //not in this sector\n    \n    float t = length(dx);\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = fxGetParticleData(id, POS_VEL).xy-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e20);\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 5;\n    if (iFrame < 5)\n    {\n        searchIterations = 20;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n        //pick random id of particle\n        int p = int(h*float(maxParticles));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Render particle SDF\n\nconst float PARTICLE_SDF_SIZE = 0.04;\n\nvec3 particleColor(float color)\n{\n    switch (int(color * 7.0))\n    {\n        case 0:\n            return vec3(1.0, 0.0, 0.0);\n        case 1:\n            return vec3(1.0, 0.5, 0.0);\n        case 2:\n            return vec3(1.0, 1.0, 0.0);\n        case 3:\n            return vec3(0.0, 1.0, 0.0);\n        case 4:\n            return vec3(0.0, 0.0, 1.0);\n        case 5:\n            return vec3(0.25, 0.0, 0.5);\n        case 6:\n            return vec3(0.5, 0.0, 0.7);\n        default:\n            return vec3(1.0, 1.0, 1.0);\n    }\n}\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{    \n    vec2 closest;\n    float dist = linePointDist2(p.pos, p.pos - p.vel, fragCoord, iResolution, closest);\n    \n    fragColor.w += max(0.0, PARTICLE_SDF_SIZE - sqrt(dist)) / PARTICLE_SDF_SIZE;\n    fragColor.xyz += particleColor(p.color) * max(0.0, PARTICLE_SIZE - sqrt(dist)) / PARTICLE_SIZE;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++){\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N = 13; // 7                              // target sampling rate\nfloat         w = .1,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  w = .08; \\\n              z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0);                                                      \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );                 \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init \n    vec2 U = u / R.y;  \n    O = texture(iChannel0, u / iResolution.xy);\n    O.w = convol2D(U).w;\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3BD7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[646, 646, 703, 703, 857]]}
{"id": "fd3fz7", "name": "Tiny Menger Shader 004", "author": "byt3_m3chanic", "description": "Tiny Shader 004 - an isometric view of a menger spong iterations.", "tags": ["raymarching", "fractal", "menger"], "likes": 19, "viewed": 308, "published": 3, "date": "1656546766", "time_retrieved": "2024-07-30T16:42:24.877976", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   \n    Tiny Menger Shader 004 | an isometric view of a menger spong iterations.\n    06/29/22 | byt3_m3chanic\n\n    Some golfing tricks from @dean_the_coder @Fabrice @iq\n*/\n\n#define T           iTime\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define S smoothstep\n#define L length\n\n#define N(p,e) vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx))\n#define Q(a)      mat2(cos(a+vec4(0,11,33,0)))\n#define H(hs)     .5 + .4* cos( PI2*hs + vec3(4,8.7,1.6) )\n#define lsp(b,e,t) clamp((t-b)/(e-b),0.,1.)\n#define box(p,d) L(max(abs(p)-d,0.))-.025\n\nvec3 hit,hp;\nfloat time,tmod,ga1,ga2,ft;\n\nconst float size =12.;\nconst float hlf =size/2.;\n\nfloat map(vec3 p) {\n\n    p.y+=ga1*size;\n    float id =floor((p.y+hlf)/size);\n    if(ft==id-1.) p.xz*=Q(PI*ga2);\n    p.y=mod(p.y+hlf,size)-hlf;\n\n    float r = 1e5;\n    float scale = 3.;\n \tvec3 cxz = vec3(scale);\n    float ss=.75;\n    hit=p;\n    int iz = int(id)%4 + 1;\n    for (int i = 0;i<iz;i++) {\n        p=abs(p);\n        \n        if (p.x<p.y) p.yx = p.xy;\n        if (p.x<p.z) p.zx = p.xz;\n        if (p.y<p.z) p.zy = p.yz;\n        if(i==iz-2)hit=p;\n\n        p.x=scale * p.x-cxz.x*(scale-1.);\n        p.y=scale * p.y-cxz.y*(scale-1.);\n        p.z=scale * p.z;\n\n        if (p.z>0.5*cxz.z*(scale-1.)) p.z-=cxz.z*(scale-1.);\n        ss /= scale;\n    }\n    \n    r = box(p,scale);\n    return r*ss;\n}\n\nvoid mainImage(out vec4 O, vec2 F)\n{\n    time = T;\n    ft = floor(time*.1);\n    tmod = mod(time, 10.);\n    float t1 = lsp(0.0, 5.0, tmod);\n    float t2 = lsp(5.25, 9.75, tmod);\n    ga1 = (t1)+ft;\n    ga2 = (t2);\n    \n    vec2  R = iResolution.xy,\n         uv = ( F+F - R ) / max(R.x,R.y);\n    vec3 C = vec3(.0),\n         p = vec3(0),\n         c = vec3(0),\n        ro = vec3(uv*10.,-15.),\n        rd = vec3(0,0,1);\n\n    mat2 rx = Q(-.78),\n         ry = Q(-.78);\n\n    ro.yz*=rx; ro.xz*=ry; \n    rd.yz*=rx; rd.xz*=ry;\n\n        float d=0.,fm=0.;\n\n        for(int i=0; i++<100 && d<100.;) {\n            p = ro + rd * d;\n            float x = map(p);\n            d+=x;\n        }\n        \n        hp=hit;\n        float t = map(p);\n        vec2 e = vec2(d*.001,0);\n        vec3 l = normalize(vec3(2,5,-5)-p),\n             n = t - N(p,e);\n             n = normalize(n);\n        vec3 clr = H(floor(hp.z*.25)),\n             fg  = H(abs(uv.x*.75));\n        float diff = clamp(dot(n,l),.1,.9);\n\n        float px = 8./R.x;\n        float f = length(hp.z)-1.;\n        f=S(px,-px,f);\n        clr=mix(clr, H(12.-floor(hp.z*5.25)),f);\n\n        C = d<30. ? diff*clr : fg;\n\n    O = vec4(pow(C,vec3(.4545)),1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3fz7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[745, 745, 764, 764, 1443], [1445, 1445, 1481, 1481, 2635]]}
{"id": "NscBWM", "name": "Fake Voronoi Param Visualizor", "author": "gehtsiegarnixan", "description": "Emulating a Voronoi pattern in under a tweet. While being readable and letting you pick the parameters with the mouse", "tags": ["voronoi", "mouse", "fast", "fake", "cellular"], "likes": 1, "viewed": 142, "published": 3, "date": "1656532004", "time_retrieved": "2024-07-30T16:42:25.708754", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a variant of Shane's Cellular Tiling \n(https://www.shadertoy.com/view/4scXz2, https://www.shadertoy.com/view/MdKXDD).\nHis versions are pretty extensively commented so give it a read. The main \nfeature of the celluar tiling is it looks very similar to Voronoi noise, \nbut it is much faster, because it does not use hash. It essentiall rotates \na number of sphere grids around to create the illusion of randomness.\n\nIf you want to see if this is faster than a texture lookup see here \n(https://www.shadertoy.com/view/sd3fDM).\n\nI changed a number of things to make it simpler and easier to understand. \nYou can also select a number of parameters with the mouse.\n- GridRes controls the size of the first grid sample\n- Level controls the number of grids added 3-4 looks pretty good.\n- Degree is controlled by the y-axis of the mouse. It selects the degree of \n    rotation of each grid is offset to each other. You should avoid multiple \n    of 45 degrees and a few degrees around it.\n- Scale selects the size difference for each grid layer. Note that values \ngreater than about +-10% will make the edges rounded.\n\nI have made a number of comments to make it clear what is happening and why. \nThis probably only for myself, when I forgot how to do this in a year. \n*/\n\n// Text on Screen from Piperoman https://www.shadertoy.com/view/XllSWl\nfloat DigitBin(const in int x) {\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces) {\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) \n    {\n\t\tif(fDigitIndex > fBiggestIndex) \n        {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} \n        else \n        {\t\t\n\t\t\tif(fDigitIndex == -1.0) \n            {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} \n            else \n            {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// makes inferno colormap from Mattz https://www.shadertoy.com/view/3lBXR3\nvec3 inferno(float t) {\n    const vec3 c0 = vec3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);\n    const vec3 c1 = vec3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);\n    const vec3 c2 = vec3(11.60249308247187, -3.972853965665698, -15.9423941062914);\n    const vec3 c3 = vec3(-41.70399613139459, 17.43639888205313, 44.35414519872813);\n    const vec3 c4 = vec3(77.162935699427, -33.40235894210092, -81.80730925738993);\n    const vec3 c5 = vec3(-71.31942824499214, 32.62606426397723, 73.20951985803202);\n    const vec3 c6 = vec3(25.13112622477341, -12.24266895238567, -23.07032500287172);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n\n// creates a sphere grid of the squared distance to the center\nfloat sphereGrid(vec2 uv) {\n    vec2 squaregrid = fract(uv) - .5; //rectangular grid with center in the middle\n    float spheregrid = dot(squaregrid, squaregrid); //squared distance form scenter\n    return spheregrid;\n}\n\n#define pi              3.1415926536\n// makes a tiling cell pattern\nfloat cellTiling(vec2 uv, float degree, float scale, int level) {\n    float c = sphereGrid(uv); // first grid\n    \n    // choose a deg/scale and calculate it here desmos.com/calculator/8de0aaehdc\n    float rad = (pi* degree)/180.; //degree to radians\n    mat2 m = mat2(cos(rad), -sin(rad), sin(rad), cos(rad)); // rotation matric\n    m *= scale; // this make the rmatrix also scale\n    \n    // precalculate the m*m for perfromance\n    for (int i = 0; i < level-1; i++){    \n        uv *= m; //each iteration gets rotated and scaled one addional time\n        c = min(c, sphereGrid(uv)); // blending the voronoi with \n    }\n    \n    return sqrt(c)*1.5; //sqrt for center distance, 1.5 for 0-1 range\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 6.0; //Hex Grid Size\n    int level = 4; //number of point grids, should be above 1. \n    \n    // mouse controls\n    float scale = 1.10; //default values for preview\n    float degree = 24.; // default values for preview\n    if(iMouse.x > 0.0)\t{\n        vec4 mouse = iMouse / iResolution.y;\n        scale = .17 * mouse.x +.85;  // value range .85-1.15\n        degree = mouse.y  * 90.; // it's a square gird going going larger than 90 is pointless\n    }\n        \n    //UV needs to be offset by a large vector from the 0,0, and avoiding 120/90/60 ... deg\n    vec2 offset = vec2(379., 769.); // two arbitrary large prime numbers\n    vec2 ani = vec2(sin(iTime*0.1),cos(iTime*0.1)); //large circular motion\n    vec2 uv = vec2(fragCoord/iResolution.y - offset + ani)*gridRes; // uv scaled and offset\n            \n    float vor = cellTiling(uv, degree, scale, level); // generating cell Tilling    \n    \n    vec3 vColour = inferno(vor); // applying cosmetic colormap\n    \n    // Text portion\n    float fDigits = 1.0;\n\tfloat fDecimalPlaces = 3.0;\t\n    vec2 vFontSize = vec2(8.0, 15.0); // Multiples of 4x5 work best\n    \n    if(iMouse.x > 0.0)\t{\n        // Plot Mouse Pos Point\n\t    float fDistToPointB = length( vec2(iMouse.x, iMouse.y) - fragCoord.xy) - 4.0;\n\t    vColour = mix(vColour, vec3(0.0, 1.0, 0.0), (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n        \n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = iMouse.xy + vec2(-62.0, 6.0);\n\t\tfloat fValue2 = scale;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit2 = PrintValue(fragCoord, vPixelCoord2, vFontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = iMouse.xy + vec2(0.0, 6.0);\n\t\tfloat fValue3 = degree;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue(fragCoord, vPixelCoord3, vFontSize, fValue3, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\n\t}\n    \n    fragColor = vec4(vColour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscBWM.jpg", "access": "api", "license": "mit", "functions": [[3851, 3926, 3949, 3949, 4605], [4608, 4671, 4698, 4698, 4890], [4929, 4960, 5025, 5025, 5658], [5660, 5660, 5717, 5717, 7682]]}
{"id": "fd3BWM", "name": "BubbleSort in 2022?", "author": "mrange", "description": "License CC0: BubbleSort in 2022?\nI saw a tweet from hexler with some neat circle based shader\nMade a try to recreate it. Although not the same I think the result \nturned out neat\n", "tags": ["2d", "bubblesort"], "likes": 31, "viewed": 510, "published": 3, "date": "1656528871", "time_retrieved": "2024-07-30T16:42:26.625304", "image_code": "// License CC0: BubbleSort in 2022?\n// I saw a tweet from hexler with some neat circle based shader\n// Made a try to recreate it. Although not the same I think the result \n// turned out neat\n// WRT bubblesort. I do a bubble sort to sort the the circle heights.\n// I am open for better ideas!\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\nvec2 mod2_1(inout vec2 p) {\n  p += 0.5;\n  vec2 n = floor(p);\n  p = fract(p)-0.5;\n  return n;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec3 alphaBlend(vec3 back, vec4 front) {\n  // Based on: https://en.wikipedia.org/wiki/Alpha_compositing\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat cellhf(vec2 n) {\n  float h = texture(iChannel0, 0.005*n+0.5).x; \n  h = sqrt(h);\n  h = smoothstep(0.1, 0.85, h);\n  return h;\n}\n\nfloat celldf(vec2 p, vec2 n) {\n  vec2 h = hash(n);\n  const float off = 0.25;\n  p += off*h;\n  float dd = length(p) - (sqrt(0.5)+off);\n  return dd;\n}\n\nvec3 effect(vec2 p) {\n  const float sz = 0.25;\n  const float amp = 10.0;\n  const float th = -TAU*sz*20.0;\n  p += amp*cos(vec2(1.0, sqrt(0.5))*TAU*(TIME)/(amp*30.0));\n  vec2 op = p;\n  p /= sz;  \n  float aa = 2.0/(sz*RESOLUTION.y);\n  vec2 n = mod2_1(p);\n\n  const int c = 1;\n  const int l = (2*c+1)*(2*c+1);\n  vec2 results[l];\n  int j = 0;\n  for (int x = -c; x <= c; ++x) {\n    for (int y = -c; y <= c; ++y) {\n      vec2 off = vec2(float(x), float(y));\n      vec2 pp = p - off;\n      vec2 nn = n + off;\n      \n      float d = celldf(pp, nn);\n      float h = cellhf(nn);\n      \n      results[j] = vec2(d, h);\n      ++j;\n    }\n  }\n\n  // Bubble sort in 2022?\n  for (int o = 1; o < l; ++o) {\n    for (int i = o; i > 0; --i) {\n      vec2 l = results[i-1];\n      vec2 r = results[i];\n      if (l.y > r.y) {\n        results[i - 1] = r;\n        results[i] = l;\n      }\n    }\n  }\n\n  vec3 col = vec3(0.0);\n  for (int i = 0; i < l; ++i) {\n      vec2 r = results[i];\n      float d = r.x;\n      float h = r.y;\n      vec4 bcol0 = vec4(hsv2rgb(vec3(fract(0.05*length(op)),mix(0.125, 1.0, h), mix(0.25, 1.0, h))), 1.0);\n      vec4 bcol1 = vec4(vec3(bcol0*bcol0*0.25), 0.5);\n      vec4 bcol = mix(bcol0, bcol1, smoothstep(-th*aa, th*aa, sin(th*d)));\n      float t = smoothstep(aa, -aa, d);\n      vec4 ccol = bcol;\n      ccol.w *= t;\n\n\n      col *= mix(1.0, 0.25, exp(-10.0*max(d, 0.0)));\n      col = alphaBlend(col, ccol);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3BWM.jpg", "access": "api", "license": "cc0-1.0", "functions": [[624, 624, 646, 646, 792], [1088, 1088, 1115, 1115, 1182], [1184, 1244, 1263, 1263, 1386], [1388, 1476, 1516, 1579, 1621], [1623, 1683, 1711, 1777, 1853], [1855, 1855, 1877, 1877, 1986], [1988, 1988, 2018, 2018, 2135], [2137, 2137, 2158, 2158, 3559], [3561, 3561, 3616, 3616, 3855]]}
{"id": "sddfWN", "name": "The passenger window", "author": "yasuo", "description": "An animation for the NEW CHITOSE AIRPORT GIF AWARD 2022\nThe view from the passenger window.", "tags": ["newchitose2022gif"], "likes": 10, "viewed": 232, "published": 3, "date": "1656521729", "time_retrieved": "2024-07-30T16:42:27.571773", "image_code": "#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox(vec2 p, vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 Hash22(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p+p);\n}\n\nfloat planeBody(vec2 p){\n    vec2 prevP = p;\n    float w = 0.15;\n    p.x -= clamp( p.x, -w, w );\n    float d = length(p)-0.05;\n    p = prevP;\n    float a = radians(-75.0);\n    p.y+=0.04;\n    float mask = dot(p,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    p = prevP;\n    \n    p.x+=0.19;\n    p.y+=0.02;\n    p.y*=2.0;\n    float d2 = length(p)-0.04;\n    \n    d = smin(d,d2,0.05);\n    \n    return d;\n}\n\nfloat planeWingL(vec2 p){\n    vec2 prevP = p;\n    float d = sdBox(p,vec2(0.07,0.08));\n    \n    float a = radians(20.0);\n\n    p.x+=0.03;\n    float mask = dot(p,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    p = prevP;\n    \n    a = radians(10.0);\n    p.x-=0.03;\n    mask = dot(p,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    return d;\n}\n\nfloat planeWingL_rear(vec2 p){\n    vec2 prevP = p;\n    float d = sdBox(p,vec2(0.06,0.03));\n    \n    float a = radians(40.0);\n\n    p.x+=0.03;\n    float mask = dot(p,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    p = prevP;\n    \n    a = radians(30.0);\n    p.x-=0.03;\n    mask = dot(p,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    return d;\n}\n\nfloat planeWingR(vec2 p){\n    vec2 prevP = p;\n    float d = sdBox(p,vec2(0.07,0.05));\n    \n    float a = radians(-20.0);\n\n    p.x+=0.03;\n    float mask = dot(p,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    p = prevP;\n    \n    a = radians(-10.0);\n    p.x-=0.03;\n    mask = dot(p,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    \n    return d;\n}\n\nvec3 plane(vec2 p, vec3 col){\n    p.x = mod(p.x,1.2)-0.6;\n    \n    vec2 prevP = p;\n    float d = planeBody(p);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    // front window\n    d = sdBox(p-vec2(-0.18,0.02),vec2(0.03,0.012));\n    d = max(planeBody(p),d);\n    col = mix(col,vec3(0.8,0.9,1.0),S(d,0.0));\n    \n    // passenger windows\n    p.x=abs(p.x)-0.02;\n    p.x=abs(p.x)-0.02;\n    p.x=abs(p.x)-0.02;\n    p.x=abs(p.x)-0.02;\n    d = sdBox(p-vec2(0.0,0.02),vec2(0.003,0.003))-0.01;\n    col = mix(col,vec3(0.8,0.9,1.0),S(d,0.0));\n    \n    p = prevP;\n    d = sdBox(p-vec2(-0.12,0.005),vec2(0.015,0.03));\n    col = mix(col,vec3(0.95),S(d,0.0));\n    \n    // body paint\n    \n    d = sdBox(p-vec2(0.0,-0.06),vec2(0.3,0.03));\n    d = max(planeBody(p),d);\n    col = mix(col,vec3(0.2,0.6,1.),S(d,0.0));\n    \n    p = prevP;\n    p.x+=0.04;\n    p.y+=0.09;\n    d = planeWingL(p);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    p = prevP;\n    \n    p.x+=0.04;\n    p.y-=0.1;\n    d = planeWingR(p);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    p = prevP;\n    \n    p.x-=0.16;\n    p.y-=0.08;\n    p.x*=1.5;\n    p.y*=1.4;\n    d = planeWingR(p);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    \n    p = prevP;\n    \n    p.x-=0.17;\n    p.y+=0.01;\n    p.x*=1.5;\n    d = planeWingL_rear(p);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    \n    return col;\n}\n\nvec3 airship(vec2 p, vec3 col){\n    p.x+=0.6;\n    p.x = mod(p.x,1.2)-0.6;\n    p.y+=sin(iTime*0.5)*0.03;\n    vec2 prevP = p;\n\n    p.x-=0.16;\n    float d = sdBox(p,vec2(0.03,0.08));\n    float a = radians(-30.0);\n    p.y = abs(p.y)-0.04;\n    p.y -=0.05;\n\n    float mask = dot(p,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    col = mix(col,vec3(0.3,0.7,1.0),S(d,0.0));\n    p = prevP;\n\n    p.y+=0.1;\n    d = sdBox(p,vec2(0.06,0.03));\n    a = radians(25.0);\n    p.x+=0.04;\n    mask = dot(p,vec2(cos(a),sin(a)));\n    d = max(-mask,d);\n    col = mix(col,vec3(0.3,0.7,1.0),S(d,0.0));\n\n    p.y+=0.005;\n    float d2 = sdBox(p,vec2(0.05,0.008));\n    d2 = max(d,d2);\n    col = mix(col,vec3(0.6,0.9,1.0),S(d2,0.0));\n\n    p = prevP;\n    \n\n    p.x*=0.5;\n    p.y*=1.2;\n    d = length(p)-0.1;\n    col = mix(col,vec3(1.0,0.95,0.90),S(d,0.0));\n    \n    p.y*=2.5;\n    d = length(p)-0.1;\n    col = mix(col,vec3(0.3,0.7,1.0),S(d,0.0));\n    p = prevP;\n    \n    return col;\n}\n\nfloat cloud(vec2 p, float r){\n    vec2 prevP = p;\n    p.x = abs(p.x)-0.02;\n    float d = length(p)-0.04;\n    p = prevP;\n    p.y-=0.06;\n    p.x-=0.06;\n    \n    vec2 n = Hash22(vec2(r));\n    vec2 p2 = sin(n*iTime*5.0)*0.02;\n    \n    float d2 = length(p-p2)-0.05;\n    d = smin(d,d2,0.05);\n    p.x+=0.06;\n    p.y-=0.01;\n    \n    n = Hash22(vec2(r));\n    p2 = sin(n*iTime*4.5)*0.02;    \n    \n    d2 = length(p-p2)-0.05;\n    d = smin(d,d2,0.05);\n    \n    p = prevP;\n    p.y-=0.025;\n    p.x-=0.02;\n    p.x = abs(p.x)-0.08;\n    d2 = length(p)-0.05;\n    d = smin(d,d2,0.03);\n    return d;\n}\n\nvec3 clouds(vec2 p, vec3 col, float n){\n    p.x = mod(p.x,0.8)-0.4;\n    vec2 prevP = p;\n    float d = cloud(p,n);\n    col = mix(col,vec3(0.98),S(d,0.0));\n    d = abs(cloud(p,n))-0.005;\n    col = mix(col,vec3(0.9),S(d,0.0));\n    return col;\n}\n\nvec3 staticPassengerWindow(vec2 p, vec3 col){\n    p.x+=0.6;\n    p.x = mod(p.x,1.2)-0.6;\n    float mask = sdBox(p,vec2(0.25,0.35))-0.05;\n\n    col = mix(col,vec3(1.0),S(mask,0.0));\n    \n    float d = sdBox(p-vec2(0.0,0.0),vec2(0.25,0.35))-0.05;\n\n    d = max(mask,d);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    d = sdBox(p-vec2(0.0,-0.35),vec2(0.1,0.01));\n    col = mix(col,vec3(0.8),S(d,0.0));\n    \n    d = abs(sdBox(p,vec2(0.26,0.36))-0.05)-0.02;\n    col = mix(col,vec3(0.85),S(d,0.0));\n    return col;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    \n    float glitchBlock = 30.0;\n    vec2 uv2 = fract(uv*glitchBlock)-0.5;\n    vec2 id = floor(uv2);\n    \n    vec2 n2 = fract(sin(id*123.456)*789.125);\n    n2+=dot(id.x,id.y*567.89);\n    \n    float glitchDist = 0.02;\n    float glitchTime = iTime*10.0;\n    uv.x-=(fract(floor(uv.y+n2.y*glitchBlock)*glitchTime)*glitchDist);\n    uv.x+=sin(floor(uv.y*glitchBlock*10.0)*iTime*30.)*0.01;\n    \n    vec2 prevMainUV = uv;\n    \n    \n    uv = prevMainUV;\n    vec3 col = mix(vec3(0.8,0.9,1.0),vec3(0.5,0.8,0.9),uv.y+0.7);\n    float d = length(uv-vec2(0.15,0.2))-0.13;\n    col = mix(col,vec3(1.0,0.9,0.8),S(d,-0.1));\n    \n    \n    uv.x+=iTime*0.2;\n    col = clouds(uv-vec2(0.,0.12),col,0.3);\n    uv = prevMainUV;\n    \n    uv.x+=iTime*0.25;\n    uv.x+=0.55;\n    uv.y+=0.23;\n    col = airship(uv,col);\n    uv = prevMainUV;    \n    \n    uv.x+=iTime*0.1;\n    col = clouds(uv-vec2(0.4,-0.2),col,0.21);  \n    uv = prevMainUV;\n  \n    uv.x+=iTime*0.3;\n    uv.x+=0.55;\n    col = plane(uv,col);\n    uv = prevUV;\n    \n    bool displayWindows = true;\n    float frame = mod(iTime,15.);    \n    float time = frame;\n    float zoom = 0.0;\n    if(frame<1.5){\n        time = getTime(time,1.5);\n        zoom = cubicInOut(time)*2.0;\n    } else if(frame>=1.5 && frame<11.5){\n        zoom = 2.0;\n    } else {\n        time = getTime(time-11.5,1.5);\n        zoom = 2.0-(cubicInOut(time)*2.0);\n    }\n    \n    //fragColor = vec4(col,1.0);\n    //return;\n    \n    uv*=3.0-zoom;\n    \n    float mask = sdBox(uv,vec2(0.25,0.35))-0.05;\n    d = max(-mask,0.0);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    float animY = 0.0;\n    \n    if(frame>=1.5 && frame<7.){\n        time = getTime(time-1.5,1.5);\n        animY = cubicInOut(time)*0.7;\n        displayWindows = false;\n    } else if(frame>=7. && frame<10.) {\n        animY = 0.7;\n        displayWindows = false;\n    } else if(frame>=10. && frame<11.5){\n        time = getTime(time-10.,1.5);\n        animY = 0.7-(cubicInOut(time)*0.7);\n        displayWindows = false;\n    } else {\n        displayWindows = true;\n    }\n    \n    d = sdBox(uv-vec2(0.0,animY),vec2(0.25,0.35))-0.05;\n\n    d = max(mask,d);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    d = sdBox(uv-vec2(0.0,-0.35+animY),vec2(0.1,0.01));\n    col = mix(col,vec3(0.8),S(d,0.0));\n    \n    d = abs(sdBox(uv,vec2(0.26,0.36))-0.05)-0.02;\n    col = mix(col,vec3(0.85),S(d,0.0));    \n    \n    \n    if(displayWindows)col = staticPassengerWindow(uv,col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 217, 260, 260, 360], [362, 422, 452, 452, 532], [534, 534, 555, 555, 641], [643, 643, 667, 667, 1041], [1043, 1043, 1068, 1068, 1384], [1386, 1386, 1416, 1416, 1732], [1734, 1734, 1759, 1759, 2077], [2079, 2079, 2108, 2108, 3393], [3395, 3395, 3426, 3426, 4346], [4348, 4348, 4377, 4377, 4929], [4931, 4931, 4970, 4970, 5172], [5174, 5174, 5219, 5219, 5677], [5679, 5679, 5706, 5706, 5790], [5792, 5792, 5831, 5831, 5876], [5878, 5878, 5935, 5935, 8491]]}
{"id": "flBfzm", "name": "Quartic Reflections", "author": "mla", "description": "Lots of reflective quartic surfaces. Inspired by [url]https://www.shadertoy.com/view/XddfW7[/url] by @wyatt.", "tags": ["reflections", "quartic"], "likes": 18, "viewed": 491, "published": 3, "date": "1656518394", "time_retrieved": "2024-07-30T16:42:28.564120", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Quartic Reflections, mla, 2022.\n//\n// Inspired by https://www.shadertoy.com/view/XddfW7 by @wyatt - this\n// one uses a nice quartic solver and also computes the normals\n// analytically.\n//\n// A central cyclide and four smaller Goursat surfaces, all contained\n// in one larger Goursat surface.\n//\n// <mouse>: change view direction\n// <up/down>: zoom\n// <left/right>: cycle through some interesting Goursat parameters\n// 'c': inner cyclide\n// 'g': outer goursat quartic\n// 'r': autorotation\n// 'x': no light bounce\n// 'w': white objects\n// 't': textured objects\n// 'p': postprocessing\n// 'q': choose cubic solver\n//\n// http://mathworld.wolfram.com/GoursatsSurface.html\n// https://www.mathcurve.com/surfaces/goursat/goursat.shtml\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint maxbounces = 3;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\n// The Kahan cubic algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float b = -0.5*B, b2 = b*b;\n  float q = b2 - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (false && r == 0.0) {\n    res[0] = C/A;\n    res[1] = -res[0];\n  } else {\n    res[0] = C/r;\n    res[1] = r/A;\n  }\n  return 2;\n}\n\n// Evaluate cubic and derivative.\nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Solve: Ax^3 + Bx^2 + Cx + D == 0\n// Find one real root, then reduce to quadratic.\nint cubic(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  X = -(B/A)/3.0;\n  float t,r,s,q,dq,x0;\n  eval(X,A,B,C,D,q,dq,b1,c2);\n  t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n  t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n  x0 = X - s*r;\n  if (x0 != X) {\n    // We really do need this many iterations here\n    for (int i = 0; i < 6; i++) {\n      X = x0;\n      eval(X,A,B,C,D,q,dq,b1,c2);\n      if (dq == 0.0) break;\n      x0 -= (q/dq);\n    }\n    if (abs(A)*X*X > abs(D/X)) {\n      c2 = -D/X; b1 = (c2 - C)/X;\n    }\n  }\n  res.x = X;\n  return 1 + quadratic(A,b1,c2,res.yz);\n}\n\n// Special wrapper for cubic function for solving quartic.\n// Find largest real root of x**3 + a*x**2 + b*x + c\n// Assume c < 0\nfloat qcubic0(float a, float b, float c) {\n  if (c == 0.0) return 0.0;\n  vec3 res;\n  int nroots = cubic(1.0,a,b,c,res);\n  if (nroots == 1) return res.x;\n  else return max(res.x,max(res.y,res.z));\n}\n\nfloat cuberoot(float x) {\n  return sign(x)*pow(abs(x),1.0/3.0);\n}\n\nfloat dcubic(float p, float q) {\n  // NB: solves x³+3px+q = 0 & returns largest real root,\n  // which is just what we want for Lanczos.\n  float h = q*q + 4.0*p*p*p;\n  float r = sqrt(abs(h));\n  if (h >= 0.0) {\n    float u = -0.5*(q+sgn(q)*r); // Largest root of quadratic\n    float t = cuberoot(u);\n    return t - p/t;\n  } else {\n    float theta = atan(r,-q); // 0 <= theta < PI\n    float k = 2.0*sqrt(abs(p));\n    return k*cos(theta/3.0);\n  }\n}\n\nfloat qcubic1(float b, float c, float d) {\n  b /= 3.0; c /= 3.0;\n  // Now we are solving x³ + 3bx² + 3cx + d = 0\n  float p = c-b*b;\n  float q = 2.0*b*b*b - 3.0*b*c + d;\n  float x = dcubic(p,q); // Solve depressed cubic\n  x -= b; // Undepress\n  return x;\n}\n\nfloat qcubic(float b, float c, float d) {\n  if (key(CHAR_Q)) return qcubic0(b,c,d);\n  else {\n    float x = qcubic1(b,c,d);\n    for (int i = 0; i < 1; i++) {\n      // Polish root with Newton-Raphson, one round is enough.\n      float fx = d + x*(c+x*(b+x));\n      float f1x = c+x*(2.0*b+3.0*x);\n      if (f1x != 0.0) x -= fx/f1x;\n    }\n    return x;\n  }\n}\n\nint quartic0(float c1, float c2, float c3, float c4, out vec4 res) {\n  // Lanczos's quartic solution\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  // There should be a positive root, but sometimes the cubic\n  // solver doesn't find it directly (probably a double root\n  // around zero).\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int n0 = quadratic(1.0,alpha+a,beta+b,res.xy);\n  int n1 = quadratic(1.0,alpha-a,beta-b,res.zw);\n  if (n0 == 0) res.xy = res.zw;\n  return n0 + n1;\n}\n\n// Ferrari's method, from Hall and Knight, 1887.\n// Similar to Lanczos, but has some visible instabilities.\nint quartic2(float p, float q, float r, float s, out vec4 roots) {\n  p *= 0.5; r *= 0.5;\n  float B = -0.5*q;\n  float C = p*r-s;\n  float D = 0.5*(s*(q-p*p)-r*r);\n  float k = qcubic(B,C,D);\n  float a = sqrt(p*p+2.0*k-q); // The sign is immaterial\n  float b = (p*k-r)/a;         // Get b from a directly\n  int n0 = quadratic(1.0,p-a,k-b,roots.xy);\n  int n1 = quadratic(1.0,p+a,k+b,roots.zw);\n  if (n0 == 0) roots.xy = roots.zw;\n  return n0 + n1;\n}\n\n// Solver by @oneshade, based on Descartes' method\nint quartic1(in float b, in float c, in float d, in float e, inout vec4 roots) {\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cuberoot(ro - rh) + cuberoot(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of λ^3 + ra * λ^2 + rb * λ + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // Solve for the smallest cubic term, this produces the least wild behaviour.\n  bool flip = abs(B/A) >= abs(D/E);\n  float c1,c2,c3,c4;\n  if (!flip) {\n    c1 = B/A; c2 = C/A; c3 = D/A; c4 = E/A;\n  } else {\n    // Solve for reciprocal\n    c1 = D/E; c2 = C/E; c3 = B/E; c4 = A/E;\n  }\n  nroots = quartic0(c1,c2,c3,c4,roots);\n  if (flip) {\n    // We have solved for the reciprocal.\n    for (int i = 0; i < 4; i++) {\n      if (i == nroots) break;\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  return nroots;\n}\n\nint Goursat = 0;\nint Cyclide = 1;\n\nstruct Surface {\n  int type;\n  vec4 params;\n  vec3 p;\n};\n\n// Goursat Quartic Surfaces\n// Equation: pp.pp + k(p.p)^2 + k'a^2(p.p) + k''a^4 = 0\n// Derivative: 4ppp + 4k(p.p)p + 2k'a^2p\n// Expansion with p => p+tr:\n// pp => (p+tr)(p+tr) = pp + 2tpr + t^2rr\n// pp.pp => (pp + 2tpr + t^2rr).(pp + 2tpr + t^2rr)\n//  = pp.pp + 4tpp.pr + 6t^2pp.rr + 4t^3pr.rr + t^4rr.rr \n// p.p  => (p+tr).(p+tr) = p.p + 2tp.r + t^2r.r = p.p + 2tp.r + t^2\n// (p.p)^2 = (p.p + 2tp.r + t^2)(p.p + 2tp.r + t^2) =\n//         = p.p^2 + 4t^2(p.r)^2 + t^4 + 2(2t(p.p)(p.r) + (p.p)t^2 + 2t^3(p.r))\n//         = p.p^2 + 4t^2(p.r)^2 + t^4 + 4t(p.p)(p.r) + 2(p.p)t^2 + 4t^3(p.r))\n// ie.\n// pp.pp + 4tpp.pr + 6t^2pp.rr + 4t^3pr.rr + t^4rr.rr +\n// k(p.p^2 + t4[(p.p)(p.r)] + t^2[4(p.r)^2 + 2(p.p)] + t^3[4(p.r)] + t^4) +\n// k'a^2(p.p + 2tp.r + t^2) +\n// k''a^4\n// collecting terms:\n// t^0: pp.pp +   k(p.p)^2 +             k'a^2(p.p) + k''a^4\n// t^1: 4pp.pr + 4k(p.p)(p.r) +         2k'a^2(p.r)\n// t^2: 6pp.rr +  k[4(p.r)^2 + 2(p.p)] + k'a^2\n// t^3: 4pr.rr + 4k(p.r)\n// t^4: rr.rr +   k\n\nint goursatsurface(Surface surface, vec3 p, vec3 r, out vec4 roots) {\n  float t = dot(p,r);\n  p -= t*r; // Now dot(p,r) == 0\n  float k = surface.params[0];\n  float k1 = surface.params[1];\n  float k2 = surface.params[2];\n  float a = surface.params[3];\n  vec3 pp = p*p;\n  vec3 pr = p*r;\n  vec3 rr = r*r;\n  float p2 = dot(p,p);\n  float a2 = a*a;\n  float a4 = a2*a2;\n\n  float A =     dot(rr,rr) +     k;\n  float B = 4.0*dot(pr,rr);\n  float C = 6.0*dot(pp,rr) + 2.0*k*p2    + k1*a2;\n  float D = 4.0*dot(pp,pr);\n  float E =     dot(pp,pp) +     k*p2*p2 + k1*a2*p2 + k2*a4;\n\n  int res = quartic(A,B,C,D,E,roots);\n  roots -= t;\n  return res;\n}\n\nvec3 goursatnormal(Surface surface, vec3 p) {\n  // 4ppp + 4k(p.p)p + 2k'a^2p\n  float k = surface.params[0];\n  float k1 = surface.params[1];\n  float a = surface.params[3];\n  return 4.0*p*p*p + 4.0*k*dot(p,p)*p + 2.0*k1*a*a*p;\n}\n\n// Dupin Cyclides\nint cyclidesurface(Surface surface, vec3 p, vec3 r, out vec4 roots) {\n  float t = dot(p,r);\n  p -= t*r; // Now p.r == 0\n  float a = surface.params.x;\n  float b = surface.params.y;\n  float c = surface.params.z;\n  float d = surface.params.w;\n  // t0 = (p+tr).(p+tr) + K = (p.p + t^2 + K) (assuming p.r == 0)\n  // t0*t0 = (p.p + K + t^2)(p.p + K + t^2) =   (p.p + K)^2 + 2t^2(p.p + K) + t^4\n  // t = X.(p+tr) + Y = X.p + tX.r + Y      = tX.r + X.p + Y [X,Y = M,-L or N,0]\n  // t*t = (X.p + Y + tX.r)(X.p + Y + tX.r) = (X.p + Y)^2 + 2t(X.p + Y)(X.r) + t^2(X.r)^2\n  float K = (b+d)*(b-d); float L = c*d;\n  vec3 M = vec3(a,0,0); vec3 N = vec3(0,b,0);\n  float pp = dot(p,p);\n  float Mr = dot(M,r); float Mp = dot(M,p);\n  float Nr = dot(N,r); float Np = dot(N,p);\n  float A = 1.0;\n  float B = 0.0;\n  float C = 2.0*(pp+K) - 4.0*Mr*Mr - 4.0*Nr*Nr;\n  float D = -8.0*((Mp-L)*Mr + Np*Nr);\n  float E = (pp+K)*(pp+K) - 4.0*(Mp-L)*(Mp-L) - 4.0*Np*Np;\n  int res = quartic(A,B,C,D,E,roots);\n  roots -= t;\n  return res;\n}\n\nvec3 cyclidenormal(Surface surface, vec3 p) {\n  float a = surface.params.x;\n  float b = surface.params.y;\n  float c = surface.params.z;\n  float d = surface.params.w;\n  float K = (b+d)*(b-d);\n  float L = c*d;\n  vec3 M = vec3(a,0,0);\n  vec3 N = vec3(0,b,0);\n  float t0 = dot(p,p) + K;\n  float t1 = dot(M,p) - L;\n  float t2 = dot(N,p);\n  return 2.0*(2.0*t0*p - 4.0*t1*M - 4.0*N*t2);\n}\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 basecolor;\n  float t;\n};\n\nint dosurface(Surface surface, vec3 p, vec3 r, out vec4 roots) {\n  p -= surface.p;\n  if (surface.type == Goursat) return goursatsurface(surface,p,r,roots);\n  if (surface.type == Cyclide) return cyclidesurface(surface,p,r,roots);\n}\n  \nvec3 donormal(Surface surface, vec3 p) {\n  p -= surface.p;\n  if (surface.type == Goursat) return goursatnormal(surface,p);\n  if (surface.type == Cyclide) return cyclidenormal(surface,p);\n}\n\nvec3 getcol(vec3 dir) {\n  if (key(CHAR_W)) return vec3(0.8);\n  if (key(CHAR_T)) return pow(texture(iChannel0,dir).rgb,vec3(2.2));\n  return pow(abs(dir),vec3(1.4));\n}\n\nbool solve(Surface surface, vec3 p, vec3 r, inout Result result) {\n  vec4 roots;\n  int nroots = dosurface(surface,p,r,roots);\n  bool found = false;\n  for (int i = 0; i < nroots; i++) {\n    // Find closest root that is a little away from p,\n    // to avoid problems if p is in the surface.\n    if (roots[i] > 0.0001 && roots[i] < result.t) {\n      result.t = roots[i];\n      found = true;\n    }\n  }\n  if (!found) return false;\n  result.p = p + result.t*r;\n  result.n = normalize(donormal(surface, result.p));\n  if (dot(result.n,r) > 0.0) result.n = -result.n;\n  result.basecolor = getcol(result.n);\n  return true;\n}\n\n// Interesting parameters from:\n// https://www.mathcurve.com/surfaces.gb/goursat/goursat.shtml\nconst vec4 gparams[] =\n  vec4[](vec4(0,0,-1,0.5),\n         //vec4(0,0,-1,1),\n         vec4(0,-1,0,1),\n         vec4(-1,-0.25,0.25,1),\n         //vec4(-1,1,1,1),\n         vec4(0,-2,2,1),\n         //vec4(-0.5,-1,0.5,1),\n         //vec4(-0.5,1,-1.5,1),\n         vec4(-1,4,-6,1),\n         vec4(-1,1,1,1),\n         vec4(-1,2,-2,1));\n\nvec4 goursatparams(int i) {\n  if (i >= 0 && i < gparams.length()) return gparams[i];\n  return vec4(-0.333,-0.666,0.666,1);\n}\n\nint nparams = 10;\n\nint imod(int n, int m) {\n    return n-n/m*m;\n}\n\nvec4 tparams (float t) {\n  float ttime = 0.5*t;\n  float rtime = floor(ttime);\n  ttime -= rtime;\n  return mix(goursatparams(int(rtime)%nparams),\n             goursatparams(int(rtime+1.0)%nparams),\n             ttime);\n}\n\nvec3 scene(vec3 p, vec3 r) {\n  vec3 col = vec3(0);\n  float att = 0.5;\n  for (int bounce = 0; bounce <= maxbounces; bounce++) {\n    Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n    bool hit = false;\n    if (!key(CHAR_C)) {\n      float a = 1.0; float b = 0.95;\n      float c = sqrt(a*a-b*b); float d = 0.1;//sin(iTime);\n      Surface s = Surface(Cyclide,vec4(a,b,c,d),vec3(0));\n      hit = solve(s,p,r,res) || hit;\n    }\n    if (!key(CHAR_G)) {\n      Surface s = Surface(Goursat,vec4(0,0,-1,2),vec3(0));\n      hit = solve(s,p,r,res) || hit;\n    }\n    int isurface = max(0,3+keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n    for (int i = -1; i <= 1; i+=2)\n      for (int j = -1; j <= 1; j+=2)\n        for (int k = -1; k <= 1; k+=2) {\n          Surface s = Surface(Goursat,gparams[isurface%gparams.length()],vec3(i,j,k));\n          s.params.a = 0.4;\n          hit = solve(s,p,r,res) || hit;\n        }\n    vec3 bgcol = vec3(0);\n    if (key(CHAR_B)) bgcol = getcol(r);\n    if (!hit) {\n      col += att*bgcol;\n      break;\n    }\n    col += att*applylighting(res.basecolor,res.p,res.n,r);\n    if (key(CHAR_X)) break;\n    p = res.p;\n    r = reflect(r,res.n);\n    r = normalize(r);\n    att *= 0.5;\n  }\n  return col;\n}\n\n// GUI related code starts here\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime;\n    //p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.1618*t);\n  }\n  return p;\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n#define float3 vec3\nfloat3 ACESFilm(float3 x) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    x = x*(a*x+b)/(x*(c*x+d)+e);\n    return x;\n}\nvec3 postprocess(vec3 color) {\n  // Some experimental tone mapping.\n  color = ACESFilm(color);\n  //color = 2.0*color/(1.0+color);\n  //color = color*color*(3.0-2.0*color);\n  color = clamp(color,0.0,1.0);\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.2-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float scale = 1.0;\n  float camera = 2.0;\n  camera *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 p = vec3(0,0,-camera);\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  int AA = 1;\n  //if (key(CHAR_A)) AA = 2;\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n     for (int j = 0; j < AA; j++) {\n       vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n       vec3 r = vec3(uv, 2.0);\n       r = transform(r);\n       r = normalize(r);\n       color += scene(p,r);\n     }\n  }\n  color /= float(AA*AA);\n  vec2 q = fragCoord/iResolution.xy;\n  if (!key(CHAR_P)) color = postprocess(color);\n  color = pow(color,vec3(0.4545));\n  if (alert) color = vec3(1,0,0);\n  fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  //setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n#if 0\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0) {\n      t.xy = initselection(i-1); // Current coordinates\n  } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n#endif\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI =  3.141592654;\n\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\n// const int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\nconst int CHAR_G = 71;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\nconst int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_ALT = 18;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat sgn(float x) {\n  return x < 0.0 ? -1.0: 1.0; // Return 1 for x == 0\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1166, 1166, 1222, 1222, 1463], [1465, 1499, 1619, 1619, 1706], [1708, 1793, 1854, 1854, 2397], [2399, 2527, 2569, 2569, 2724], [2726, 2726, 2751, 2751, 2791], [2793, 2793, 2825, 2929, 3238], [3240, 3240, 3282, 3282, 3497], [3499, 3499, 3540, 3540, 3852], [3854, 3854, 3922, 3954, 4573], [4575, 4683, 4749, 4749, 5127], [5129, 5180, 5260, 5452, 7634], [7636, 7636, 7710, 7710, 8227], [9315, 9315, 9384, 9384, 9950], [9952, 9952, 9997, 10028, 10178], [10180, 10198, 10267, 10267, 11200], [11202, 11202, 11247, 11247, 11583], [11585, 11585, 11645, 11645, 11882], [11953, 11953, 12017, 12017, 12183], [12187, 12187, 12227, 12227, 12375], [12377, 12377, 12400, 12400, 12542], [12544, 12544, 12610, 12610, 13158], [13584, 13584, 13611, 13611, 13708], [13729, 13729, 13753, 13753, 13775], [13777, 13777, 13801, 13801, 13995], [13997, 13997, 14025, 14025, 15204], [15206, 15238, 15265, 15265, 15612], [15713, 15713, 15740, 15740, 15894], [15895, 15895, 15925, 15962, 16115], [16117, 16117, 16174, 16174, 17057]]}
{"id": "7dtBD4", "name": "cameras: photo vs antipanoramic2", "author": "FabriceNeyret2", "description": "camera:   left: flat perspective      right: anti-cylindrical perspective\n                key ↑↓ : opening           mouse.y:  focus rot speed (better > .5 )\nscene:     top: straight ribbon        bottom: cylindrical ribbon    mid: cyl ribbon around (0,Z)", "tags": ["projection", "perspective", "cameras", "cylindrical"], "likes": 7, "viewed": 279, "published": 3, "date": "1656513455", "time_retrieved": "2024-07-30T16:42:29.560456", "image_code": "// WIP. test of \"anti-panoramic\" camera, rotating around (0,0,Z).\n// mid screen: horizontal cylinder + balls around (0,0,Z).\n// variant of  https://shadertoy.com/view/NdtBDN\n// here, the camera position turns at a different speed than ray direction.\n// variant of panoramic camera https://shadertoy.com/view/ftffWN\n\n#define T(U)    ( V = smoothstep(0.,-.05,abs(fract(U)-.5) -.5 ),    \\\n                  vec4( texture(iChannel0, U).rgb * V.x*V.y,        \\\n                        smoothstep(0.,-1.5*fwidth(U).y, abs((U).y-.5) -.5 ) \\\n                )     ) // pattern\n#define rot(a)    mat2(cos( a + vec4(0,11,33,0)))\n#define blend(T)  O = O* (1.- (m=T.w)) + T , m>.5 ? z=min(z,l) :z, m=0.\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O-=O;\n    vec2  R = iResolution.xy, V,\n          U = ( 2.*u - R ) / R.x,                   // normalized screen coordinates\n          M = iMouse.xy/R;\n    if ( int(u) ==int(R)/2 ) { O = vec4(1,0,0,1); return; } // red separator\n    \n    float Z = 8.,F, H = 1.5,                        // Z: object distance\n          a,b,c,d, l,m=0.,z=1e9,                    // F: anticylindrical focus distance\n          W = iMouse.z > 1e4 ? .38/ M.x : 1.;       // 1/W: camera opening\n    F = W = 1./max(0.,texelFetch(iChannel1,ivec2(0),0).y );\n    vec3  P0 = vec3(0,0,0), P, D = vec3( U , W );   // ray direction: left: flat perspective\n    \n    if (iMouse.z > 0.) W *= 1.+ (2.*M.y-1.);\n    \n#if 1\n    if (D.x>0.) {                                   // right: cylindrical perspective (panorama)\n          a = U.x/W;\n          D.xz = W* vec2(sin(a),cos(a));\n          if (abs(a) > 3.14/2.) O.r+=.5;            // view > 180° : mid-red alert\n          if (abs(a) > 3.14)    O.r+=.5;            // view > 360° : red alert\n       }\n#endif\n    D = normalize(D);\n    \n#if 0\n    if (iMouse.z > 0.)\n        D.yz *= rot( 1.57*(2.*M.y-1.) ),\n        D.xz *= rot( 1.57*(2.*M.x-1.) );\n#endif\n\n#if 1\n    if (D.x>0.) \n          a = U.x/F,\n          P0.xz = vec2(0,Z) - Z *vec2(sin(a),cos(a));  // anticylindrical camera\n#endif   \n\n    P = ( H - sign(D.y)*P0.y ) * D/abs(D.y) + P0;   // --- roof + floor\n    if ( P.y > 0. )                                 // draw roof square grid\n        O +=   T(P.xz+vec2(.5,0) ) \n             * vec4(0,1,1,0) * exp(-P.z/Z);         // color + darkening with z\n \n    if ( P.y < 0. )                                 // draw floor polar grid\n        O +=  T(vec2(Z*atan(P.x,P.z),Z*log(length(P.xz)))+vec2(.5,0) )\n             * vec4(1,.5,0,0) * exp(-P.z/Z);        // color + darkening with z\n    \n                                                    // --- ribbons\n    l = (Z-P0.z)/abs(D.z), P = l* D +P0;            // draw flat ribbon \n    if ( abs(P.y-1.) < .5 && P.z>0. )   \n        blend( T(P.xy-.5) );                        // with mapped texture\n    \n    \n    a = dot(D.xz,D.xz), b = dot(P0.xz,D.xz), c = dot(P0.xz,P0.xz) -Z*Z,\n    d = b*b - a*c;\n    if (d>0.) {\n        l = ( -b +  sqrt(d) )/ a , P = l* D + P0;\n     // P = Z* D/length(D.xz) + P0;                 // draw cylindrical ribbon\n        if ( abs(P.y+1.) < .5 )                     // with mapped texture\n            blend( T(vec2(Z*atan(P.x,P.z),P.y+2.)-.5) );  \n    }\n    \n    float  t = 10.,s; c = 1., d=0.; P=P0;           // --- red balls\n   // P.y+= 5.;\n    for ( ; c > 0. && t > .01 && d < z; c -= .04 ) {        // march scene\n        //a = mod( atan(P.x,P.z), 6.28/16. ),\n        for( a = 0.; a < 6.29; a += 6.28/16. )\n            t = min(t, length( vec3(4.*cos(a),round(P.y),Z+4.*sin(a)) - P ) -.2 ); \n     // t =  min(s=length(mod(P,10.) -5.)-1.,P.y+5.), // distance to objects\n        d += t = max(s=t, abs(P.y)-H);\n        P += t*D; }                                 // sphere-tracing step\n    if (t<.01) { O = vec4(c,0,0,1); return; }       // coloring & shading\n\n\n    P0.z -= Z; Z = 2.;                              // --- small cylindrical ribbon\n    a = dot(D.xz,D.xz), b = dot(P0.xz,D.xz), c = dot(P0.xz,P0.xz) -Z*Z,\n    d = b*b - a*c;\n    if (d>0.) {\n        P = ( -b - sqrt(d) )/ a * D + P0;           // draw small cylindrical ribbon\n        if ( abs(P.y) < .5 )                        // with mapped texture\n            blend( T(vec2(Z*atan(P.x,P.z),P.y+1.)-.5) ); \n    }\n \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keyClick(a)   ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch(iChannel0,ivec2(U),0);\n    if (iFrame==0) O.xy = vec2(0,1.4);\n    if keyClick(38) O.x++, O.y *= 1.1;\n    if keyClick(40) O.x--, O.y /= 1.1;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[692, 692, 728, 728, 4208]]}
{"id": "NdtBDN", "name": "cameras: photo vs antipanoramic", "author": "FabriceNeyret2", "description": "camera:   left: flat perspective      right: anti-cylindrical perspective\n                key ↑↓ : opening           mouse.y:  focus distance ( better > .5 )\nscene:     top: straight ribbon        bottom: cylindrical ribbon    mid: cyl ribbon around (0,Z)", "tags": ["projection", "perspective", "cameras", "cylindrical"], "likes": 1, "viewed": 216, "published": 3, "date": "1656511724", "time_retrieved": "2024-07-30T16:42:30.457059", "image_code": "// WIP. test of \"anti-panoramic\" camera, rotating around a fix LookAt at distance F\n// mid screen: horizontal cylinder + balls around (0,0,Z).\n// variant of panoramic camera https://shadertoy.com/view/ftffWN\n\n#define T(U)    ( V = smoothstep(0.,-.05,abs(fract(U)-.5) -.5 ),    \\\n                  vec4( texture(iChannel0, U).rgb * V.x*V.y,        \\\n                        smoothstep(0.,-1.5*fwidth(U).y, abs((U).y-.5) -.5 ) \\\n                )     ) // pattern\n#define rot(a)    mat2(cos( a + vec4(0,11,33,0)))\n#define blend(T)  O = O* (1.- (m=T.w)) + T , m>.5 ? z=min(z,l) :z, m=0.\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O-=O;\n    vec2  R = iResolution.xy, V,\n          U = ( 2.*u - R ) / R.x,                   // normalized screen coordinates\n          M = iMouse.xy/R;\n    if ( int(u) ==int(R)/2 ) { O = vec4(1,0,0,1); return; } // red separator\n    \n    float Z = 8.,F = Z, H = 1.5,                    // Z: object distance\n          a,b,c,d, l,m=0.,z=1e9,                    // F: anticylindrical focus distance\n          W = iMouse.z > 1e4 ? .38/ M.x : 1.;       // 1/W: camera opening\n    W = 1./max(0.,texelFetch(iChannel1,ivec2(0),0).y );\n    vec3  P0 = vec3(0,0,0), P, D = vec3( U , W );   // ray direction: left: flat perspective\n#if 1\n    if (D.x>0.) {                                   //                right: cylindrical perspective (panorama)\n          a = U.x/W;\n          D.xz = W* vec2(sin(a),cos(a));\n          if (abs(a) > 3.14/2.) O.r+=.5;            // view > 180° : mid-red alert\n          if (abs(a) > 3.14)    O.r+=.5;            // view > 360° : red alert\n       }\n#endif\n    D = normalize(D);\n    \n    if (iMouse.z > 0.)\n#if 0\n        D.yz *= rot( 1.57*(2.*M.y-1.) ),\n        D.xz *= rot( 1.57*(2.*M.x-1.) );\n#else\n        F *= 1.+ (2.*M.y-1.);\n#endif\n\n#if 1\n    if (D.x>0.) P0.xz = vec2(0,F) - F*D.xz;         // anticylindrical camera\n#endif   \n\n    P = ( H - sign(D.y)*P0.y ) * D/abs(D.y) + P0;   // --- roof + floor\n    if ( P.y > 0. )                                 // draw roof square grid\n        O +=   T(P.xz+vec2(.5,0) ) \n             * vec4(0,1,1,0) * exp(-P.z/Z);         // color + darkening with z\n \n    if ( P.y < 0. )                                 // draw floor polar grid\n        O +=  T(vec2(Z*atan(P.x,P.z),Z*log(length(P.xz)))+vec2(.5,0) )\n             * vec4(1,.5,0,0) * exp(-P.z/Z);        // color + darkening with z\n    \n                                                    // --- ribbons\n    l = (Z-P0.z)/abs(D.z), P = l* D +P0;            // draw flat ribbon \n    if ( abs(P.y-1.) < .5 && P.z>0. )   \n        blend( T(P.xy-.5) );                        // with mapped texture\n    \n    \n    a = dot(D.xz,D.xz), b = dot(P0.xz,D.xz), c = dot(P0.xz,P0.xz) -Z*Z,\n    d = b*b - a*c;\n    if (d>0.) {\n        l = ( -b +  sqrt(d) )/ a , P = l* D + P0;\n     // P = Z* D/length(D.xz) + P0;                 // draw cylindrical ribbon\n        if ( abs(P.y+1.) < .5 )                     // with mapped texture\n            blend( T(vec2(Z*atan(P.x,P.z),P.y+2.)-.5) );  \n    }\n    \n    float  t = 10.,s; c = 1., d=0.; P=P0;           // --- red balls\n   // P.y+= 5.;\n    for ( ; c > 0. && t > .01 && d < z; c -= .04 ) {        // march scene\n        //a = mod( atan(P.x,P.z), 6.28/16. ),\n        for( a = 0.; a < 6.29; a += 6.28/16. )\n            t = min(t, length( vec3(4.*cos(a),round(P.y),Z+4.*sin(a)) - P ) -.2 ); \n     // t =  min(s=length(mod(P,10.) -5.)-1.,P.y+5.), // distance to objects\n        d += t = max(s=t, abs(P.y)-H);\n        P += t*D; }                                 // sphere-tracing step\n    if (t<.01) { O = vec4(c,0,0,1); return; }       // coloring & shading\n\n\n    P0.z -= Z; Z = 2.;                              // --- small cylindrical ribbon\n    a = dot(D.xz,D.xz), b = dot(P0.xz,D.xz), c = dot(P0.xz,P0.xz) -Z*Z,\n    d = b*b - a*c;\n    if (d>0.) {\n        P = ( -b - sqrt(d) )/ a * D + P0;           // draw small cylindrical ribbon\n        if ( abs(P.y) < .5 )                        // with mapped texture\n            blend( T(vec2(Z*atan(P.x,P.z),P.y+1.)-.5) ); \n    }\n \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keyClick(a)   ( texelFetch(iChannel3,ivec2(a,1),0).x > 0.)\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = texelFetch(iChannel0,ivec2(U),0);\n    if (iFrame==0) O.xy = vec2(0,1);\n    if keyClick(38) O.x++, O.y *= 1.1;\n    if keyClick(40) O.x--, O.y /= 1.1;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "NddfWN", "name": "Tic tac toe", "author": "VPas", "description": "Simple tic tac toe with precompilled matches.", "tags": ["2d"], "likes": 3, "viewed": 242, "published": 3, "date": "1656501291", "time_retrieved": "2024-07-30T16:42:31.214035", "image_code": "precision highp float;\nprecision highp int;\n#define V vec2\n#define F float\n#define S step\n#define SS smoothstep\n\nF R(V s,F t){F p=length(s);return SS(.255,.25,p)*SS(.20,.205,p)*S(atan(s.y,s.x)+3.,t*6.);}\nF C(V s,F t){V p=abs(V(s.x+s.y,s.y-s.x));F x=S(t,.5),y=S(t-.5,.5);F h=.275-mod(t,.5)*.56;\nreturn S(min(p.x,p.y),.025)*S(max(p.x+mix(h*y,.275,x),p.y+h*x),.3);}\nF h(F n){return fract(sin(floor(n))*43758.5453123)*2.-1.;}\n\nvoid mainImage(out vec4 o, in vec2 _f) {\n  V r=iResolution.xy,u=(_f*2.-r)/min(r.x,r.y)*1.4,p=abs(u),g=mod(p-.3,.6)-.3,A,B,D,E,Z;\n  F v=S(max(p.x,p.y),.9),w=S(min(g.x,g.y),-.28)*v,t=mod(iTime,9.),l=floor(iTime/9.),m=.62,n=.85,z=1.7,i,j,e,f,s;\n  vec3 y,q=vec3(.2,.8,.8),x=vec3(.8,.2,.2),W=vec3(.6,.7,.2),c;\n  int a=int[](809654321,-20218453,205987612,909128753,707631925)[int(mod(l,5.))],b;\n  for(;i<t&&i<8.;i++){b=(abs(a)%10)-1;a/=10;if(b<0)break;V z=u+m*V(1-b%3,b/3-1);y+=mix(q*R(z,t-i),x*C(z,t-i),S(mod(i,2.),.5));}\n  if(abs(a)<10){\n    e=F(a);c=mix(W*W,mix(x,q,S(e,0.)),S(e,8.))*.6;e=abs(e)-1.;\n    f=S(2.9,e);s=S(5.9,e);Z=V(n,n-z*min(1.1,(e-6.)));\n    A=mix(V(mix(m*(e-1.),n,f),mix(n,m*(4.-e),f)),-Z,s)+V(h(l),h(l+5.37))*.1,\n    B=mix(A-V(f,1.-f)*2.*n,Z,s)+V(h(l+7.53),h(11.47))*.1,D=u-A,E=B-A;\n    j=SS(.051,.049,length(D-E*clamp(dot(D,E)/dot(E,E),0.,mix(1.,fract(t),S(t-F(i),1.)))));\n  }\n  o=vec4(mix(y+W*w,c,j),0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 126, 126, 203], [204, 204, 217, 217, 362], [363, 363, 372, 372, 421]]}
{"id": "NsdfW4", "name": "Static Horble", "author": "pyBlob", "description": "https://en.wikipedia.org/wiki/Losharik", "tags": ["losharik", "horble"], "likes": 2, "viewed": 58, "published": 3, "date": "1656492929", "time_retrieved": "2024-07-30T16:42:32.013896", "image_code": "\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    f = 2. / iResolution.y;\n    vec2 uv = O - vec2(iResolution.x / 2., 0);\n    uv *= f;\n    uv.y -= 0.2;\n    uv.x += 0.3;\n    \n    // animation blend states\n    float t = .5+.5*cos(iTime/2.0); t*1.;\n    float u = .5+.5*cos(iTime/3.2); u*=.5;\n    float v = smoothstep(0.2,0.3,cos(iTime/2.7)); v*=1.;\n    float w = smoothstep(0.5,0.6,cos(iTime/4.2+2.0)); w*=1.;\n    float x = cos(iTime*12.); x*=smoothstep(0.5,1.0,cos(iTime/2.3));\n    float y = .5+.5*cos(iTime*2.); y*=smoothstep(0.73,1.0,cos(iTime/3.9));\n    u += .15 * y;\n\n    float bend;\n\n    // first ball\n    Circle shoulder = Circle(vec3(0.0, 0.0, 0.0), vec2(0.00 + fade(.1,u), 0.53 + fade(.02,t) + fade(-.020,u)), 0.10, radians(5. + fade(-6.,u)));\n    \n    // right leg\n    bend = 40. + fade(-2.,t) + fade(1.5,u);\n    Circle right_0 = connect(shoulder, vec3(0.70, 0.50, 0.40), radians(200. + fade(3.,t) + fade(-7.,u)), 0.05);\n    Circle right_1 = connect(right_0, vec3(0.80, 0.20, 0.00), radians(bend), 0.05);\n    Circle right_2 = connect(right_1, vec3(0.70, 0.01, 0.00), radians(bend), 0.05);\n    Circle right_3 = connect(right_2, vec3(0.60, 0.10, 0.00), radians(bend*1.2), 0.05);\n    Circle right_4 = connect(right_3, vec3(0.60, 0.00, 0.00), radians(bend*-.5), 0.05);\n    Circle rightFoot = connect(right_4, vec3(0.50, 0.01, 0.00), radians(bend*-.5), 0.06);\n\n    // back\n    bend = -20.;\n    Circle saddle = connect(shoulder, vec3(0.70, 0.10, 0.00), radians(-bend + fade(-2.,t)), 0.12);\n    Circle hip = connect(saddle, vec3(0.70, 0.00, 0.00), radians(2.*bend), 0.10); turn(hip, radians(-bend));\n\n    // tail\n    bend = -20.+fade(25.,y);\n    Circle tail_0 = connect(hip, vec3(0.90, 0.30, 0.02), radians(055.), 0.05);\n    Circle tail_1 = connect(tail_0, vec3(0.70, 0.05, 0.00), radians(bend), 0.05);\n    Circle tail_2 = connect(tail_1, vec3(0.40, 0.01, 0.00), radians(bend), 0.05);\n    Circle tail_3 = connect(tail_2, vec3(0.80, 0.35, 0.00), radians(bend), 0.07);\n    \n    // rear leg\n    bend = -15. + fade(1.,t) + fade(-10.,u);\n    Circle rear_0 = connect(hip, vec3(0.01, 0.01, 0.01), radians(310. + fade(20.,u)), 0.05);\n    Circle rear_1 = connect(rear_0, vec3(0.05, 0.20, 0.02), radians(bend), 0.05);\n    Circle rear_2 = connect(rear_1, vec3(0.00, 0.00, 0.00), radians(bend), 0.05);\n    Circle rear_3 = connect(rear_2, vec3(0.80, 0.00, 0.00), radians(bend*1.5), 0.05);\n    Circle rear_4 = connect(rear_3, vec3(0.00, 0.01, 0.03), radians(bend*.1), 0.05);\n    Circle rearFoot = connect(rear_4, vec3(0.00, 0.00, 0.00), radians(bend*-.2), 0.06);\n\n    // head\n    bend = -15.;\n    Circle neck_0 = connect(shoulder, vec3(0.80, 0.05, 0.00), radians(140.), 0.05);\n    Circle neck_1 = connect(neck_0, vec3(0.00, 0.05, 0.20), radians(bend), 0.05);\n    Circle neck_2 = connect(neck_1, vec3(0.00, 0.40, 0.00), radians(bend), 0.05);\n    Circle head = connect(neck_2, vec3(0.80, 0.40, 0.03), radians(bend), 0.15);\n    Circle hat = connect(head, vec3(0.70, 0.00, 0.00), radians(310.), 0.05); move(hat, -0.010, 0.000);\n    // eye\n    Circle eye = connect(head, vec3(0.90, 0.90, 0.90), radians(000.), 0.07); move(eye, -0.190, 0.020); turn(eye, radians(150.+fade(20.,u)));\n    Circle pupil = connect(eye, vec3(0.00, 0.00, 0.00), radians(000.), 0.06); move(pupil, -0.132+fade(-.005,w), 0.014+fade(-.007,v));\n    // nose\n    Circle nose = connect(head, vec3(0.10, 0.01, 0.00), radians(080.), 0.06); move(nose, -0.030, 0.000);\n    // mouth\n    Circle mouth = connect(head, vec3(0.40, 0.05, 0.00), radians(125.), 0.03); move(mouth, -0.030+fade(.002,x), 0.000);\n    \n    // left leg\n    bend = 25. + fade(-4., t);\n    Circle left_0 = connect(shoulder, vec3(0.00, 0.00, 0.20), radians(215. + fade(7.,t) + fade(-4.,u)), 0.05);\n    Circle left_1 = connect(left_0, vec3(0.00, 0.20, 0.00), radians(bend), 0.05);\n    Circle left_2 = connect(left_1, vec3(0.00, 0.00, 0.15), radians(bend), 0.05);\n    Circle left_3 = connect(left_2, vec3(0.01, 0.01, 0.01), radians(bend), 0.05);\n    Circle left_4 = connect(left_3, vec3(0.40, 0.02, 0.00), radians(bend*-.2), 0.05);\n    Circle leftFoot = connect(left_4, vec3(0.00, 0.00, 0.00), radians(bend*-.3), 0.06);\n\n    C = vec4(0.11, 0.40, 0.90, 1);\n    vec3 grass = vec3(0.6,0.7,0);\n    vec2 shadow = (leftFoot.center + rightFoot.center + rearFoot.center * 2.) / 4.;\n    //vec2 shadow = vec2(saddle.center.x, 0.);\n    float rshadow = length((uv - shadow)*vec2(1.5,5));\n    grass *= mix(.5, 1., smoothstep(0.1, 1., rshadow));\n    C = blend(C, grass, -uv.y/f);\n    C = blend(C, uv, shoulder);\n    C = blend(C, uv, right_0);\n\tC = blend(C, uv, right_1);\n\tC = blend(C, uv, right_2);\n\tC = blend(C, uv, right_3);\n\tC = blend(C, uv, right_4);\n\tC = blend(C, uv, rightFoot);\n\tC = blend(C, uv, saddle);\n\tC = blend(C, uv, hip);\n\tC = blend(C, uv, tail_0);\n\tC = blend(C, uv, tail_1);\n\tC = blend(C, uv, tail_2);\n\tC = blend(C, uv, tail_3);\n\tC = blend(C, uv, rear_0);\n\tC = blend(C, uv, rear_1);\n\tC = blend(C, uv, rear_2);\n\tC = blend(C, uv, rear_3);\n\tC = blend(C, uv, rear_4);\n\tC = blend(C, uv, rearFoot);\n\tC = blend(C, uv, neck_0);\n\tC = blend(C, uv, neck_1);\n\tC = blend(C, uv, neck_2);\n\tC = blend(C, uv, head);\n\tC = blend(C, uv, hat);\n\tC = blend(C, uv, eye);\n\tC = blend(C, uv, pupil);\n\tC = blend(C, uv, nose);\n\tC = blend(C, uv, mouth);\n\tC = blend(C, uv, left_0);\n\tC = blend(C, uv, left_1);\n\tC = blend(C, uv, left_2);\n\tC = blend(C, uv, left_3);\n\tC = blend(C, uv, left_4);\n\tC = blend(C, uv, leftFoot);\n    C.xyz = sqrt(C.xyz);\n}\n", "image_inputs": [], "common_code": "struct Circle\n{\n    vec3 color;\n    vec2 center;\n    float radius;\n    float angle;\n};\n\nmat2 R(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\nvec2 v(float a)\n{\n    return vec2(1, 0) * R(a);\n}\nCircle connect(Circle current, vec3 color, float angle, float radius)\n{\n    vec2 center = current.center;\n    angle += current.angle;\n    center += v(angle) * (current.radius + radius);\n    return Circle(color, center, radius, angle);\n}\nvoid move(inout Circle current, float dx, float dy)\n{\n    current.center += vec2(dx, dy) * R(current.angle);\n}\nvoid turn(inout Circle current, float da)\n{\n    current.angle += da;\n}\n\nfloat fade(float target, float x) { return target * x; }\n\nfloat l2(vec2 x)\n{\n    return dot(x, x);\n}\n\nfloat l2(vec3 x)\n{\n    return dot(x, x);\n}\n\nfloat f;\nvec4 blend(vec4 C, vec3 c, float r)\n{\n    return mix(C, vec4(c, 1), clamp(r + .5, 0., 1.));\n}\n\nvec4 blend(vec4 C, vec2 uv, Circle circle) {\n    vec3 light = normalize(vec3(10, 9, 5));\n    vec3 rd = vec3(0, 0, -1);\n\n    vec2 offset = uv - circle.center;\n    float r = length(offset);\n    vec3 normal = vec3(offset / circle.radius, 0);\n    normal.z = sqrt(max(0., 1. - l2(normal.xy)));\n\n    vec3 color = circle.color;\n    color *= .5 + clamp(dot(normal, light), 0., 1.);\n    color += vec3(.1) * pow(clamp(l2(cross(rd, normal)), 0., 1.), 4.) * clamp(dot(normal, light)+.1, 0., 1.);\n    color += vec3(.5) * pow(clamp(dot(reflect(rd, normal), light), 0., 1.), 30.);\n    C = blend(C, color, -(r-circle.radius)/f);\n    return C;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 40, 40, 5418]]}
{"id": "fsdfW4", "name": "Simple Fractal！！！！", "author": "Delincoter", "description": "study note", "tags": ["fractal"], "likes": 2, "viewed": 239, "published": 3, "date": "1656491694", "time_retrieved": "2024-07-30T16:42:32.910499", "image_code": "mat2 Rot2(float a ) \n{\n    float c = cos( a );\n    float s = sin( a );\n    return mat2( c, -s, s, c );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    float angle = (0.3333)*3.1415*0.5;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv*=1.5;\n    uv *= Rot2(iMouse.x*0.002);\n   \n    uv.x = abs(uv.x);\n    uv.x -= .075;\n     \n    uv.y = abs(uv.y);\n    uv.x -= .5;\n    uv *= Rot2(0.16667*3.1415);\n    uv.x += .5;\n\n    \n    uv *= 3.;\n    uv.x = abs(uv.x); \n    uv.x -= .5;\n    \n    uv *= -Rot2(angle);\n    uv.x = abs(uv.x);\n    uv *= Rot2(angle); \n    \n\n    \n    float b = 1.;\n    for(float i = 0.; i < floor(iMouse.y*0.01); i++)\n    {\n        uv *= 3.;\n        uv.x -= 1.5;\n        \n        uv.x = abs(uv.x); \n        uv.x -= .5;\n        \n        b *= -1.;\n        \n        uv *= -Rot2(b*angle);\n        uv.x = abs(uv.x);\n        uv *= Rot2(b*angle); \n    }\n    \n \n    float d = length(uv - vec2(clamp(uv.x, -1., 1.), 0.));\n    col += smoothstep(pow(floor(iMouse.y*0.01),3.)*0.01+0.01, 0., d);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 104], [106, 106, 163, 163, 1123]]}
{"id": "fd3fDN", "name": "Window Shades", "author": "Peace", "description": "It's just window blinds for my project", "tags": ["shades", "window", "curtains", "blinds", "windowblinds", "windowshades", "windowcurtains"], "likes": 5, "viewed": 224, "published": 3, "date": "1656478278", "time_retrieved": "2024-07-30T16:42:33.753246", "image_code": "#define BACKGROUND_COLOR vec3(0.9, 0.76, 0.55)\n#define DESK_COLOR vec3(0.1, 0.06, 0.03)\n#define WINDOW_SHADES_ON_COLOR vec3(0.855, 0.75, 0.58)\n#define WINDOW_SHADES_OFF_COLOR vec3(0.235, 0.24, 0.266)\n#define LIGHT_COLOR vec3(1.0, 0.98, 0.87)\n#define TILES 5.0\n// 0 = Off | 1 = On | 2 = On and Open\nint STATE = 0; \n\n#define LIGHTS_ON (STATE == 1 || STATE == 2)\n\nvec3 color = vec3(0);\nvec3 col = vec3(0);\nvec2 uv = vec2(0);\n#define A (iResolution.x / iResolution.y)\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n    float fl = floor(p);\n    float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm(vec2 p, int octaves)\n{\n    float n = 0.0;\n    float a = 1.0;\n    float norm = 0.0;\n    for(int i = 0; i < octaves; ++i)\n    {\n        n += noise(p) * a;\n        norm += a;\n        p *= 2.0;\n        a *= 0.7;\n    }\n    return n / norm;\n}\n\nfloat luma(vec3 color)\n{\n    return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvoid rect(float x, float y, float w, float h)\n{\n    if(uv.x >= x && uv.x <= x + w && uv.y >= y && uv.y <= y + h)\n        color = col;\n}\n\nvoid srect(float x, float y, float w, float h, float r, float s)\n{\n\tvec2 offset = abs((uv - vec2(x + w * 0.5, y + h * 0.5)) / vec2(w,h)) - (0.5 - s - r);\n\tcolor = mix(col, color, smoothstep(0.0, s, length(max(offset, 0.0)) - r));\n}\n\nvoid background()\n{\n    vec2 luv = uv;\n    uv.x = abs(uv.x);\n    \n    col = (LIGHTS_ON ? LIGHT_COLOR : WINDOW_SHADES_OFF_COLOR);\n    srect(A * 0.3, 0.6, A * 0.55, 0.06, 0.05, 0.1);\n    srect(A * 0.28, 0.1, A * 0.53, 0.06, 0.05, 0.1);\n    vec3 lcolor = color;\n    float l = luma(color); \n    \n    col = (LIGHTS_ON ? BACKGROUND_COLOR * (0.8 + 0.4 * fbm(uv * 8.0, 4)) : WINDOW_SHADES_OFF_COLOR);\n    rect(-A, -1.0, A * 2.0, 2.0);\n    \n    col = (LIGHTS_ON ? DESK_COLOR : WINDOW_SHADES_OFF_COLOR * 0.7);\n    srect(-A * 2.0, -1.0, A * 4.0, 0.5, 0.0, 0.05);\n    col = col * (LIGHTS_ON ? 2.0 : 1.5);\n    srect(-A * 2.0, -0.54, A * 4.0, 0.15, 0.0, 0.05);\n    col = col * 0.5;\n    srect(0.0, -1.0, A, 0.4, 0.0, 0.05);\n    col = (LIGHTS_ON ? DESK_COLOR : WINDOW_SHADES_OFF_COLOR);\n    srect(A * 0.25, -0.55, 0.08, 0.15, 0.0, 0.2);\n    srect(A * 0.23, -0.6, 0.08, 0.17, 0.0, 0.2);\n    srect(A * 0.21, -0.6, 0.08, 0.14, 0.0, 0.2);\n    srect(-0.1, -0.6, 0.6, 0.125, 0.0, 0.2);\n    \n    color = mix(color, lcolor, l * l * l * l);\n    \n    color += l * l * l * l * 0.2;\n    \n    uv = luv;\n}\n\nvoid shades()\n{\n    float shades = cos(uv.x * 50.0);\n    float shade_col = 0.5 + 0.5 * abs(shades);\n    shade_col /= 1.0 + smoothstep(-0.25, -1.0, -shades);\n    shade_col *= 0.8 + fbm(uv * 2.0, 8) * 0.4;\n    shade_col *= 0.9 + noise(uv.x * 200.0) * 0.2;\n    color = mix(color, sqrt(sqrt(luma(color))) * 1.3 * (LIGHTS_ON ? WINDOW_SHADES_ON_COLOR : WINDOW_SHADES_OFF_COLOR) * shade_col, step(shades, STATE == 2 ? -0.2 : 0.95));\n}\n\nvoid frame()\n{\n    float w = 0.15;\n    float h = 0.6;\n    col = vec3(0.5) * (0.8 + 0.4 * fbm(uv * 12.0, 8));\n    \n    vec2 luv = uv;\n    uv = abs(uv);\n    \n    //Lighting\n    float l = 0.2;\n    float b = 0.2;\n    float f = float(uv.y <= 1.0 - w);\n    \n    col += sqrt(smoothstep(1.0 - w * l, 1.0, abs(uv.y))) * b;\n    col += float(uv.y >= 1.0 - w && uv.x <= A - w * h + w * l && (uv.x >= A * 0.6 - w * h * l || uv.x <= A * 0.6 - w * h + w * h * l)) * sqrt(smoothstep(1.0 - w + w * l, 1.0 - w, uv.y)) * b;\n    \n    col += sqrt(smoothstep(A - w * l, A, uv.x)) * b;  \n    col += f * float(uv.x >= A - w * h) * sqrt(smoothstep(A - w * h + w * l, A - w * h, uv.x)) * b;\n    \n    col += f * float(uv.x <= A * 0.6) * sqrt(smoothstep(A * 0.6 - w * h + w * l * 0.8, A * 0.6 - w * h, uv.x)) * b;\n    col += f * float(uv.x <= A * 0.6) * sqrt(smoothstep(A * 0.6 - w * l * 0.8, A * 0.6, uv.x)) * b;   \n    \n    //Shadow rectangles\n    vec3 lcol = col;\n    col = color * 0.6;\n    float s = 0.3;\n    rect(-A, 1.0 - w * (1.0 + s / A), 2.0 * A, w * h * (1.0 + s * 2.0));\n    rect(A - w * h * (1.0 + s), -1.0, w * h * (1.0 + s * 2.0), 2.0);  \n    rect(A * 0.6 - w * h * (1.0 + s), -1.0, w * h * (1.0 + s * 2.0), 2.0);\n    col = color * 0.6;\n    s *= 0.63;\n    rect(-A, 1.0 - w * (1.0 + s / A), 2.0 * A, w * h * (1.0 + s * 2.0));\n    rect(A - w * h * (1.0 + s), -1.0, w * h * (1.0 + s * 2.0), 2.0);  \n    rect(A * 0.6 - w * h * (1.0 + s), -1.0, w * h * (1.0 + s * 2.0), 2.0);\n    \n    col = min(lcol, lcol + b);\n    \n    //Frame   \n    rect(-A, 1.0 - w, 2.0 * A, w);\n    rect(A - w * h, -1.0, w * h, 2.0);\n    rect(A * 0.6 - w * h, -1.0, w * h, 2.0);  \n    \n    uv = luv; \n}\n\nvoid window()\n{\n    background();\n    shades();\n    frame();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 index = floor(fragCoord * TILES / iResolution.xy);\n    fragCoord = mod(fragCoord * TILES, iResolution.xy);\n    uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    STATE = int(noise(index + iTime * 0.5) * 3.0);\n    window();   \n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3fDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 465, 485, 485, 523], [525, 525, 546, 546, 641], [643, 643, 663, 663, 730], [732, 732, 752, 752, 961], [963, 963, 995, 995, 1209], [1211, 1211, 1235, 1235, 1290], [1292, 1292, 1339, 1339, 1427], [1429, 1429, 1495, 1495, 1660], [1662, 1662, 1681, 1681, 2737], [2739, 2739, 2754, 2754, 3166], [3168, 3168, 3182, 3182, 4823], [4825, 4825, 4840, 4840, 4887], [4889, 4889, 4946, 4946, 5233]]}
{"id": "7s3cD4", "name": "Raycasting a Black Hole", "author": "SpinningCube", "description": "(Click and Drag)\nThis is similar to a raymarcher, but each iteration the light will move a fixed distance and change direction due to gravity, which is modeled with Newtonian gravity. The accretion disk is a textured plane in the shape of a disk.", "tags": ["3d", "blackhole", "lensing"], "likes": 8, "viewed": 541, "published": 3, "date": "1656472922", "time_retrieved": "2024-07-30T16:42:34.592003", "image_code": "// Black Hole Raycasting\n\nconst float pi = 3.1415926536;\n\nmat2 rotate(float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return mat2(cosA, -sinA, sinA, cosA);\n}\n\nvec3 sky(vec3 rayDir) {\n    //vec3 background = 10. * vec3(rayDir.xy, 0.);\n    vec3 background;\n    background = texture(iChannel0, 1. * vec2(atan(rayDir.z, rayDir.x), rayDir.y)).rrr;\n    background = 1.5 * pow(background, vec3(25.));\n    background += .1 * pow(texture(iChannel1, vec2(atan(rayDir.z, rayDir.x), rayDir.y)).rgb, vec3(2.));\n    //background = 2. * pow(background, vec3(2.2));\n    return background * pow(length(rayDir.xz), 2.0);\n}\n\n// A pattern I made for the accretion disk.\nvec3 diskTexture (vec2 pos) {\n    float D = length(pos);\n    float F = min(1., 30. * (D - .95/6.2));\n    F *= F;\n    D = 1. - D;\n    D *= min(1., 10. * D);\n    float D0 = D;\n    D = pow(D, 1.5);\n    D += D0 * D0 * D0 * 0.08 * smoothstep(0., 1., texture(iChannel0, rotate(8. * iTime) * pos/10. + 0.05 * vec2(iTime)).r);\n    float atanvalue = atan(pos.y, pos.x);\n    float sinPatterns = sin(-80. * D + 5. * iTime + -1. * atanvalue) + 0.3 * sin(-152. * D + 3. * iTime + -1. * atanvalue) + 0.2 * sin(-134. * D + 10. * iTime + -1. * atanvalue);\n    //vec3 diskCol = vec3(0.1, 0.7, 1.); // Cyan\n    //vec3 diskCol = vec3(1., 0.45, .2); // Orange\n    float colorShift = -iTime / 2. + 3.;\n    colorShift += 4. * D0;\n    vec3 diskCol = 0.5 * vec3(sin(colorShift) + 1., sin(colorShift + 2. * pi/3.) + 1., sin(colorShift + 4. * pi/3.) + 1.);\n    diskCol = mix(diskCol, vec3(1.), 0.45);\n    \n    diskCol = pow(diskCol, vec3(2.2));\n    return F * D * (0.5 * abs(sinPatterns) + 0.5) * 8. * diskCol;\n}\n\nfloat plane (vec3 rayPos, float y) {\n    return abs(rayPos.y - y);\n}\n\nvec3 ray (vec3 rayPos, vec3 rayDir) { // Might be better described as a \"photon\" instead of a ray\n    vec3 cam = rayPos;\n    float moveDist = 1.;\n    for (int i = 0; i < 600; i++) {\n        rayDir = normalize(rayDir - 10. * 0.5 * moveDist * normalize(rayPos)/(20. * length(rayPos) * length(rayPos)) ); // Gravity\n        \n        bool diskBool = false || (length(rayPos.xz) < 6. && length(rayPos.xz) > .95);\n        bool diskBool2 = false || (length(rayPos.xz) < 6. && length(rayPos.xz) > .95);\n        \n        float minDist = plane(rayPos, 0.) - 0.04;\n        moveDist = min(minDist + float(!diskBool2), .1);\n        //moveDist = .1;\n        rayPos += 0.5 * moveDist * rayDir;\n        \n        if (diskBool && minDist < 0.01) {\n            return diskTexture(rayPos.xz/6.2);\n        }\n        \n    }\n    vec3 sky = mix(sky(rayDir), sky(rayDir.yzx), 0.5);\n    return float(length(rayPos) > 10.) * sky;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates\n    vec2 screen = (fragCoord - iResolution.xy/2.)/min(iResolution.x, iResolution.y);\n    \n    vec3 col;\n    \n    // texture test\n    col = diskTexture(screen.xy);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5);\n    \n    if (mouse == vec2(-0.5)) {\n        mouse = vec2(0., -.02);\n    }\n    \n    vec3 cam = vec3(0, 0, -11);\n    vec3 rayDir = normalize(vec3(screen.xy, 1.2));\n    \n    cam.yz *= rotate(pi * -mouse.y);\n    cam.xz *= rotate(2. * pi * -mouse.x);\n    //rayDir.xy *= rotate(-.4);\n    rayDir.yz *= rotate(pi * -mouse.y);\n    rayDir.xz *= rotate(2. * pi * -mouse.x);\n    \n    col = ray(cam, rayDir);\n    col *= 1.5; col = vec3(tanh(col.r), tanh(col.g), tanh(col.b)); // Lazy tonemapping\n    \n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1./2.2)), 1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3cD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 80, 80, 174], [176, 176, 199, 250, 621], [623, 667, 696, 696, 1653], [1655, 1655, 1691, 1691, 1723], [1725, 1725, 1762, 1822, 2629], [2631, 2631, 2688, 2714, 3502]]}
{"id": "7scBD4", "name": "noise_simple_epaper_demo", "author": "SimonOakey", "description": "simple moving noise for epaper project", "tags": ["noise", "simple", "moving"], "likes": 2, "viewed": 272, "published": 3, "date": "1656459698", "time_retrieved": "2024-07-30T16:42:35.431758", "image_code": "vec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n              \n              \n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123   ) ;\n}\n\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n  //  i+=+ iTime*.01;\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy) ;    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2 ;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n\t \n    vec2 uv = gl_FragCoord.xy/iResolution.y;\n    uv.x += iResolution.y/iResolution.x;\n    \n      uv.y += iTime*.01;\n     \n     uv.x = abs( uv.x - 1.46) ;\n     \n     float nscl = sin(iTime*.2)*.4+8.;\n\t\n\tfloat f = noise( uv*nscl  );\n\n          f = sin(f*22.);\n\t\n     f = smoothstep(  .4,.5 ,f);\t\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 212], [215, 215, 241, 241, 725], [779, 779, 836, 836, 1178]]}
{"id": "ss3fW4", "name": "Triangle Voronoi Borders", "author": "tdhooper", "description": "Cell interior distances for triangle voronoi", "tags": ["2d", "voronoi", "triangle"], "likes": 51, "viewed": 1355, "published": 3, "date": "1656454983", "time_retrieved": "2024-07-30T16:42:36.237605", "image_code": "/*\n\n    Triangle Voronoi Borders\n    ........................\n\n    Based on iq's two-step voronoi distance method, but\n    using a triangle distance metric.\n    \n    To repeat iq, just doing F2-F1 Voronoi results in\n    errors at the borders, so in our second pass we\n    calculate an accurate distance to the border between\n    the overlapping triangles.\n    \n    See also:\n    \n    * Old version with sharp corners and no normals\n    https://www.shadertoy.com/view/Ns3fD7\n    \n    * Akira Saito's visualisation of how this works\n    https://twitter.com/a_saito/status/1231035875439415301\n    \n    * iq's two-step voronoi distance method\n    https://shadertoy.com/view/ldl3W8\n\n    * Overview of triangle voronoi from Shane\n    https://www.shadertoy.com/view/MlVXzd\n    \n*/\n\nconst float PI = 3.14159265359;\nconst float s3 = sin(PI / 3.);\n\nvec3 sdTriEdges(vec2 p) {\n    return vec3(\n        dot(p, vec2(0,-1)),\n        dot(p, vec2(s3, .5)),\n        dot(p, vec2(-s3, .5))\n    );\n}\n\nfloat sdTri(vec2 p) {\n    vec3 t = sdTriEdges(p);\n    return max(t.x, max(t.y, t.z));\n}\n\n// Adapted from Fizzer (found through Shane in the comments of https://www.shadertoy.com/view/Wl3fD2)\n// Picks the dominant axis and its sign:\n// vec3(1, 2, -3) -> vec3(0, 0, -1)\nvec3 primaryAxis(vec3 p) {\n    vec3 a = abs(p);\n//  return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p); // fails to pick a compoent when two have equal length, eg vec3(0,-2,2)\n    return (1.-step(a.xyz, a.yzx))*step(a.zxy, a.xyz)*sign(p);\n}\n\n// This is the interesting bit\n// Signed distance and gradient to border\nvec3 sdgBorder(vec2 pt1, vec2 pt2) {\n    \n    vec3 tbRel = sdTriEdges(pt2 - pt1);    \n    vec3 axis = primaryAxis(tbRel);\n    \n    vec2 gA = vec2(0,-1);\n    vec2 gB = vec2(s3, .5);\n    vec2 gC = vec2(-s3, .5);\n    \n    vec2 norA = gC * axis.x + gA * axis.y + gB * axis.z;\n    vec2 norB = gB * -axis.x + gC * -axis.y + gA * -axis.z;\n    \n    vec2 dir = gA * axis.x + gB * axis.y + gC * axis.z;\n    vec2 corner = dir * dot(dir, pt1 - pt2) * 2./3.;\n    \n    mat2 r90 = mat2(0,-1,1,0);\n    \n    bool isEdge = axis.x + axis.y + axis.z < 0.;\n    \n    if (isEdge) {\n        corner = pt2 + corner;\n        vec2 ca = corner + min(0., dot(corner, -norA)) * norA;\n        vec2 cb = corner + max(0., dot(corner, -norB)) * norB;\n        float side = step(dot(corner, dir * r90), 0.);\n        corner = mix(cb, ca, side);\n    } else {\n        corner = pt1 - corner;\n        vec2 ca = corner + max(0., dot(corner, -norA)) * norA;\n        vec2 cb = corner + min(0., dot(corner, -norB)) * norB;\n        float side = step(dot(corner, dir * r90), 0.);\n        corner = mix(ca, cb, side);\n    }\n    \n    vec2 nor = normalize(corner);\n\n    float d = length(corner);\n\n    return vec3(abs(d), nor);\n}\n\n\n// From here on is almost exactly like iq's voronoi https://shadertoy.com/view/ldl3W8\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat time;\n\n\nvec2 cellPoint(vec2 n, vec2 f, vec2 cell) {\n    vec2 coord = n + cell;\n    vec2 o = hash2( n + cell );\n    #ifdef ANIMATE\n        o = 0.5 + 0.5*sin( time * PI * 2. + 6.2831*o );\n    #endif\t\n    vec2 point = cell + o - f;\n    return point;\n}\n\nvec3 voronoi( in vec2 x, out vec2 nor )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 closestCell, closestPoint;\n\n    const int reach = 2;\n\n    float closestDist = 8.0;\n    for( int j = -reach; j <= reach; j++ )\n    for( int i = -reach; i <= reach; i++ )\n    {\n        vec2 cell = vec2(i, j);\n        vec2 point = cellPoint(n, f, cell);\n        float dist = sdTri(point);\n\n        if( dist < closestDist )\n        {\n            closestDist = dist;\n            closestPoint = point;\n            closestCell = cell;\n        }\n    }\n\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    closestDist = 8.0;\n    for( int j = -reach-1; j <= reach+1; j++ )\n    for( int i = -reach-1; i <= reach+1; i++ )\n    {\n        vec2 cell = closestCell + vec2(i, j);\n        vec2 point = cellPoint(n, f, cell);\n\n        float dist = sdTri(closestPoint - point);\n\n        if( dist > 0.00001 ) {\n            vec3 sdg = sdgBorder(closestPoint, point);\n            if (sdg.x < closestDist) {\n                closestDist = sdg.x;\n                nor = sdg.yz;\n            }\n        }\n    }\n\n    return vec3( closestDist, closestPoint );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xx;\n    \n    time = fract(iTime / 6.);\n\n    p *= 8.;\n\n    vec2 nor;\n    vec3 c = voronoi(p, nor);\n\n    float aa = length(fwidth(p)) * .5;\n\n\t// isolines\n    float n = 15.;\n    vec3 col = smoothstep(.25 - aa * n, .25 + aa * n, abs(mod(c.x * n + .25, 1.) - .5)) * vec3(1);\n    // normals\n    nor = mix(nor, vec2(0), smoothstep(2./n - aa, 2./n + aa, c.x));\n    col = mix(col, normalize(vec3(nor, 1)) * .5 + .5, .9);\n    // borders\t\n    col = mix( vec3(0.5,1.0,0.5) * 0., col, smoothstep( 0.01 - aa, 0.01 + aa, c.x));\n    // feature points\n\tfloat dd = length( c.yz );\n\tcol *= .2 + .8 * smoothstep( 0.00, 0.12, dd);\n    col = mix(col, vec3(1), smoothstep( 0.035 + aa, 0.035 - aa, dd));\n\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3fW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[839, 839, 864, 864, 978], [980, 980, 1001, 1001, 1067], [1069, 1248, 1274, 1274, 1490], [1492, 1565, 1601, 1601, 2741], [2848, 2848, 2870, 2900, 3081], [3097, 3097, 3140, 3140, 3337], [3339, 3339, 3380, 3380, 4654], [4656, 4656, 4713, 4713, 5459]]}
{"id": "NdcBDN", "name": "Mosaic Shuffle 2", "author": "leon", "description": "A weird mosaic", "tags": ["glitch", "weird"], "likes": 37, "viewed": 1036, "published": 3, "date": "1656449690", "time_retrieved": "2024-07-30T16:42:37.036467", "image_code": "\n\n// (main code is Buffer A)\n// Mosaic Shuffle 2 by Leon Denise 2022-06-28\n// using code from Dave Hoskins\n// Fork of \"Mosaic Shuffle\" by leon. https://shadertoy.com/view/Nd3BWN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    float unit = 1./iResolution.y;\n    \n    // timing\n    float time = iTime*10.;\n    float anim = fract(time);\n    float index = floor(time);\n    \n    // displace\n    vec2 rnd1 = hash21(index)*2.-1.;\n    vec2 target = p + rnd1;\n    float mask = hash12(floor(uv*hash11(index+78.)*32.)+index);\n    float a = 6.283*floor(hash11(index*72.)*4.)/4.;\n    vec2 dir = vec2(cos(a),sin(a));\n    vec2 offset = (mask) * dir * unit * 10. * hash12(floor(uv*16.));\n    \n    // spawn frame\n    bool spawn = hash12(floor(uv*hash11(index+78.)*8.)+index) > 0.9;\n    if (iFrame < 1 || spawn)\n    {\n        fragColor = texture(iChannel1, uv);\n    }\n    else\n    {\n        // frame buffer\n        fragColor = texture(iChannel0, uv-offset);\n    }\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ss(a,b,t) smoothstep(a,b,t)\n\n\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcBDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 236, 236, 300]]}
{"id": "7stBDH", "name": "Noise Types Experiment", "author": "cra_manning_w", "description": "Experimenting with different types of noise.", "tags": ["2d", "noise", "random"], "likes": 3, "viewed": 210, "published": 3, "date": "1656445601", "time_retrieved": "2024-07-30T16:42:38.033801", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const float BORDER_DROPOFF = 20.0,\n                BORDER_SIZE = 0.5;\n    const int N_SEGMENTS_ON_SIDE = 3;\n    const float SEGMENT_SIZE = 1.0 / float(N_SEGMENTS_ON_SIDE);\n    vec2 segmentPointer = uv;\n    if (iMouse.z > 0.5)\n        segmentPointer = iMouse.xy / iResolution.xy;\n    vec2 segmentPos = fract(segmentPointer / SEGMENT_SIZE);\n    vec2 segmentBorder2D = abs(segmentPos - 0.5);\n    float segmentBorder = 1.0 - max(border(segmentBorder2D.x, 0.5, BORDER_SIZE, BORDER_DROPOFF),\n                                    border(segmentBorder2D.y, 0.5, BORDER_SIZE, BORDER_DROPOFF));\n    \n    ivec2 segment = ivec2(segmentPointer / SEGMENT_SIZE);\n    vec2 panning = iTime * vec2(0.4, 0.2);\n    vec2 noisePos = uv * 10.0 + panning;\n    \n    //Note that segment's Y index increases as you go upwards.\n    float noise = 0.0;\n    //Column 1: plain noise.\n    if (segment == ivec2(0, 0))\n    {\n        noise = perlinNoise(noisePos, 1.430);\n    }\n    else if (segment == ivec2(0, 1))\n    {\n        noise = perlinNoise(noisePos, 1.430);\n        noise = pow(2.0 * abs(noise - 0.5), 0.75);\n    }\n    else if (segment == ivec2(0, 2))\n    {\n        noise = perlinNoise(noisePos, 1.430);\n        noise *= noise;\n    }\n    //Column 2: octave noise.\n    else if (segment == ivec2(1, 0))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            octaveNoise,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            \n        );\n        noise = octaveNoise;\n    }\n    else if (segment == ivec2(1, 1))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            octaveNoise,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            octaveValue = pow(2.0 * abs(octaveValue - 0.5), 0.75)\n        );\n        noise = octaveNoise;\n    }\n    else if (segment == ivec2(1, 2))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            octaveNoise,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            octaveValue *= octaveValue\n        );\n        noise = octaveNoise;\n    }\n    //Column 3: Interesting experiments.\n    else if (segment == ivec2(2, 0))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            noiseA,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            octaveValue *= octaveValue\n        );\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            noiseB,\n            2.0, 0.825, 5,\n            perlinNoise,\n            ,\n            octaveValue = pow(2.0 * abs(octaveValue - 0.5), 0.75)\n        );\n        noise = pow(noiseA, noiseB);\n    }\n    else if (segment == ivec2(2, 1))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            noiseA,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            octaveValue *= octaveValue\n        );\n        IMPL_OCTAVE_NOISE(\n            noisePos,\n            noiseB,\n            2.0, 0.825, 5,\n            perlinNoise,\n            ,\n            octaveValue = pow(2.0 * abs(octaveValue - 0.5), 0.75)\n        );\n        noise = min(noiseA, noiseB) / max(noiseA, noiseB);\n        noise = 1.0 - noise;\n    }\n    else if (segment == ivec2(2, 2))\n    {\n        IMPL_OCTAVE_NOISE(\n            noisePos * 0.25,\n            noiseA,\n            2.0, 1.430, 5,\n            perlinNoise,\n            ,\n            octaveValue = pow(2.0 * abs(octaveValue - 0.5), 0.75)\n        );\n        IMPL_OCTAVE_NOISE(\n            noisePos / pow(noiseA, 0.01),\n            noiseB,\n            2.0, 0.825, 5,\n            perlinNoise,\n            ,\n            octaveValue *= octaveValue\n        );\n        noise = noiseB;\n    }\n\n    float saturation = step(segmentPos.x, 0.5);\n    vec3 col = mix(vec3(noise),\n                   texture(iChannel0, vec2(0.5 + (noise * 0.0625))).rgb,\n                   saturation);\n    fragColor = vec4(col * segmentBorder, 1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n////////////////////\n//    Hashing     //\n////////////////////\n\n// A modified version of this: https://www.shadertoy.com/view/4djSRW\n//Works best with seed values in the hundreds.\n\n//Hash 1D from 1D-3D data\nfloat hashTo1(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hashTo1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hashTo1(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Hash 2D from 1D-3D data\nvec2 hashTo2(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 hashTo2(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//Hash 3D from 1D-3D data\nvec3 hashTo3(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 hashTo3(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hashTo3(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n//Hash 4D from 1D-4D data\nvec4 hashTo4(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\nvec4 hashTo4(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\nvec4 hashTo4(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvec4 hashTo4(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\n//////////////////////\n//    Utilities     //\n//////////////////////\n\n#define OSCILLATE(a, b, input) (mix(a, b, 0.5 + (0.5 * sin(2.0 * 3.14159265 * (input)))))\n\n#define INV_LERP(a, b, x) ((x-a) / (b-a))\n#define SATURATE(x) clamp(x, 0.0, 1.0)\n#define SHARPEN(t) smoothstep(0.0, 1.0, t)\n#define SHARPENER(t) SMOOTHERSTEP(t)\n\n#define COMMA ,\n\n#define RAND_IN_ARRAY(array, t) array[int(mix(0.0, float(array.length()) - 0.00001, t))]\n\n//A higher-quality smoothstep(), with a zero second-derivative at the edges.\n#define SMOOTHERSTEP(t) clamp(t * t * t * (t * (t*6.0 - 15.0) + 10.0), \\\n                              0.0, 1.0)\n\n//Returns a value that increases towards 1 as it gets closer to some target.\nfloat border(float x, float target, float thickness, float dropoff)\n{\n    float dist = abs(x - target);\n    float closeness = 1.0 - min(1.0, dist / thickness);\n    return pow(closeness, dropoff);\n}\n\n//Distance-squared is faster to compute in 2D+, but not in 1D.\n//Some noise is defined with the help of macros to work with any dimensionality,\n//    and so is agnostic to the dimensionality.\nfloat efficientDist(float a, float b) { return abs(b - a); }\nfloat efficientDist(vec2 a, vec2 b) { vec2 delta = b - a; return dot(delta, delta); }\nfloat efficientDist(vec3 a, vec3 b) { vec3 delta = b - a; return dot(delta, delta); }\nfloat efficientDist(vec4 a, vec4 b) { vec4 delta = b - a; return dot(delta, delta); }\nfloat realDist(float efficientDist, float posType) { return efficientDist; }\nfloat realDist(float efficientDist, vec2 posType) { return sqrt(efficientDist); }\nfloat realDist(float efficientDist, vec3 posType) { return sqrt(efficientDist); }\nfloat realDist(float efficientDist, vec4 posType) { return sqrt(efficientDist); }\n\nfloat sumComponents(float f) { return f; }\nfloat sumComponents(vec2 v) { return v.x + v.y; }\nfloat sumComponents(vec3 v) { return v.x + v.y + v.z; }\nfloat sumComponents(vec4 v) { return v.x + v.y + v.z + v.w; }\n\n//Gets the angle of the given vector, in the range 0-1.\nfloat angleT(vec2 dir) { return 0.5 + (0.5 * atan(dir.y, dir.x)/3.14159265); }\n\n//Given a uniformly-distributed value, and another target value,\n//    biases the uniform value towards the target.\n//The \"biasStrength\" should be between 0 and 1.\nfloat applyBias(float x, float target, float biasStrength)\n{\n    //Degenerative case if x=0.\n    if (x == 0.0)\n        return mix(x, target, biasStrength);\n    \n    //Get the \"scale\" of the target relative to x.\n    //Multiplying x by this number would give exactly the target.\n    float scale = target / x;\n    \n    //Weaken the \"scale\" by pushing it towards 1.0, then apply it to 'x'.\n    //Make sure to respect the sign, in case 'x' or 'target' is negative.\n    return x * sign(scale) * pow(abs(scale), biasStrength);\n}\n\n//Linearly interpolates between a beginning, midpoint, and endpoint.\nfloat tripleLerp(float a, float b, float c, float t)\n{\n    vec3 lerpArgs = (t < 0.5) ?\n                        vec3(a, b, INV_LERP(0.0, 0.5, t)) :\n                        vec3(b, c, INV_LERP(0.5, 1.0, t));\n    return mix(lerpArgs.x, lerpArgs.y, lerpArgs.z);\n}\nvec3 tripleLerp(vec3 a, vec3 b, vec3 c, float t)\n{\n    bool isFirstHalf = (t < 0.5);\n    return isFirstHalf ?\n               mix(a, b, INV_LERP(0.0, 0.5, t)) :\n               mix(b, c, INV_LERP(0.5, 1.0, t));\n    \n}\n//Smoothly interpolates between a beginning, midpoint, and endpoint.\nfloat tripleSmoothstep(float a, float b, float c, float t)\n{\n    vec4 lerpArgs = (t < 0.5) ?\n                        vec4(a, b, 0.0, 0.5) :\n                        vec4(b, c, 0.5, 1.0);\n    return mix(lerpArgs.x, lerpArgs.y, smoothstep(lerpArgs.z, lerpArgs.w, t));\n}\n//Interpolates between a beginning, midpoint, and endpoint, with aggressive smoothing.\nfloat tripleSmoothSmoothstep(float a, float b, float c, float t)\n{\n    vec4 lerpArgs = (t < 0.5) ?\n                        vec4(a, b, 0.0, 0.5) :\n                        vec4(b, c, 0.5, 1.0);\n    return mix(lerpArgs.x, lerpArgs.y, smoothstep(0.0, 1.0, smoothstep(lerpArgs.z, lerpArgs.w, t)));\n}\n\nvec2 randUnitVector(float uniformRandom)\n{\n    float theta = uniformRandom * 2.0 * 3.14159265;\n    return vec2(cos(theta), sin(theta));\n}\n\n///////////////////////////////\n//    Value/Octave Noise     //\n///////////////////////////////\n\nfloat valueNoise(float x, float seed)\n{\n    float xMin = floor(x),\n          xMax = ceil(x);\n\n    float noiseMin = hashTo1(vec2(xMin, seed) * 450.0),\n          noiseMax = hashTo1(vec2(xMax, seed) * 450.0);\n\n    float t = x - xMin;\n    //t = SMOOTHERSTEP(t); //Actually gives worse results due to\n                           //  the dumb simplicity of the underlying noise\n    \n    return mix(noiseMin, noiseMax, t);\n}\nfloat valueNoise(vec2 x, float seed)\n{\n    vec2 xMin = floor(x),\n         xMax = ceil(x);\n    vec4 xMinMax = vec4(xMin, xMax);\n\n    vec2 t = x - xMin;\n    //t = SMOOTHERSTEP(t); //Actually gives worse results due to\n                           //  the dumb simplicity of the underlying noise\n    \n    #define VALUE_NOISE_2D(pos) hashTo1(vec3(pos, seed) * 450.0)\n    return mix(mix(VALUE_NOISE_2D(xMinMax.xy),\n                   VALUE_NOISE_2D(xMinMax.zy),\n                   t.x),\n               mix(VALUE_NOISE_2D(xMinMax.xw),\n                   VALUE_NOISE_2D(xMinMax.zw),\n                   t.x),\n               t.y);\n}\n\n//Octave noise behaves the same regardless of dimension.\n#define IMPL_OCTAVE_NOISE(x, outputVar, persistence, seed, nOctaves, noiseFunc, noiseMidArg, octaveValueMod) \\\n    float outputVar; { \\\n    float sum = 0.0,                                                 \\\n          scale = 1.0,                                               \\\n          nextWeight = 1.0,                                          \\\n          totalWeight = 0.0;                                         \\\n    for (int i = 0; i < nOctaves; ++i)                               \\\n    {                                                                \\\n        float octaveValue = noiseFunc((x) * scale,                   \\\n                                      noiseMidArg                    \\\n                                      (seed) + float(i));            \\\n        octaveValueMod;                                              \\\n        sum += octaveValue * nextWeight;                             \\\n        totalWeight += nextWeight;                                   \\\n                                                                     \\\n        nextWeight /= (persistence);                                 \\\n        scale *= (persistence);                                      \\\n    }                                                                \\\n    outputVar = sum / totalWeight;                                   \\\n}\nfloat octaveNoise(float x, float seed, int nOctaves, float persistence) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, valueNoise, ,); return outNoise; }\nfloat octaveNoise(vec2 x, float seed, int nOctaves, float persistence) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, valueNoise, ,); return outNoise; }\n\n#define PERLIN_MAX(nDimensions) (sqrt(float(nDimensions)) / 2.0)\nfloat perlinNoise(float x, float seed)\n{\n    float xMin = floor(x),\n          xMax = ceil(x),\n          t = x - xMin;\n\n    float value = mix(t         * sign(hashTo1(vec2(xMin, seed) * 450.0) - 0.5),\n                      (1.0 - t) * sign(hashTo1(vec2(xMax, seed) * 450.0) - 0.5),\n                      SHARPENER(t));\n    return INV_LERP(-PERLIN_MAX(1), PERLIN_MAX(1), value);\n}\n\nvec2 perlinGradient2(float t)\n{\n    return randUnitVector(t);\n}\nfloat perlinNoise(vec2 p, float seed)\n{\n    vec2 pMin = floor(p),\n         pMax = pMin + 1.0,\n         t = p - pMin;\n    vec4 pMinMax = vec4(pMin, pMax),\n         tMinMax = vec4(t, p - pMax);\n\n    #define PERLIN2_POINT(ab) dot(tMinMax.ab, \\\n                                  perlinGradient2(hashTo1(vec3(pMinMax.ab, seed) * 450.0)))\n    float noiseMinXMinY = PERLIN2_POINT(xy),\n          noiseMaxXMinY = PERLIN2_POINT(zy),\n          noiseMinXMaxY = PERLIN2_POINT(xw),\n          noiseMaxXMaxY = PERLIN2_POINT(zw);\n\n    t = SHARPENER(t);\n    float value = mix(mix(noiseMinXMinY, noiseMaxXMinY, t.x),\n                      mix(noiseMinXMaxY, noiseMaxXMaxY, t.x),\n                      t.y);\n    return INV_LERP(-PERLIN_MAX(2), PERLIN_MAX(2), value);\n}\n\n\n\n/////////////////////////\n//    Worley Noise     //\n/////////////////////////\n\n//Helper function for worley noise that finds the point in a cell.\n//Outputs its position, and returns whether or not it really exists.\nbool getWorleyPoint(float cell, float chanceOfPoint, float seed, out float pos)\n{\n    vec2 rng = hashTo2(vec2(cell * 450.0, seed)).xy;\n    \n    pos = cell + rng.x;\n    return (rng.y < chanceOfPoint);\n}\nbool getWorleyPoint(vec2 cell, float chanceOfPoint, float seed, out vec2 pos)\n{\n    vec3 rng = hashTo3(vec3(cell, seed) * 450.0).xyz;\n    \n    pos = cell + rng.xy;\n    return (rng.z < chanceOfPoint);\n}\n\n//Generates worley-noise points that might influence the given position.\n//See the below functions for common use-cases.\nvoid worleyPoints(float x, float chanceOfPoint, float seed,\n                  out int outNPoints, out float outPoints[3]);\nvoid worleyPoints(vec2 x, float chanceOfPoint, float seed,\n                  out int outNPoints, out float outPoints[3]);\n//Implementation below:\n#define IMPL_WORLEY_START(T)                                    \\\n    T xCenter = floor(x),                                       \\\n      xMin = xCenter - 1.0,                                     \\\n      xMax = xCenter + 1.0;                                     \\\n    nPoints = 0;                                                \\\n    T nextPoint\n//end #define\n#define IMPL_WORLEY_POINT(cellPos)                                  \\\n    if (getWorleyPoint(cellPos, chanceOfPoint, seed, nextPoint))    \\\n        points[nPoints++] = nextPoint\n//end #define\nvoid worleyPoints(float x, float chanceOfPoint, float seed,\n                  out int nPoints, out float points[3])\n{\n    IMPL_WORLEY_START(float);\n    IMPL_WORLEY_POINT(xMin);\n    IMPL_WORLEY_POINT(xCenter);\n    IMPL_WORLEY_POINT(xMax);\n}\nvoid worleyPoints(vec2 x, float chanceOfPoint, float seed,\n                  out int nPoints, out vec2 points[9])\n{\n    IMPL_WORLEY_START(vec2);\n    \n    IMPL_WORLEY_POINT(xMin);\n    IMPL_WORLEY_POINT(xCenter);\n    IMPL_WORLEY_POINT(xMax);\n    \n    IMPL_WORLEY_POINT(vec2(xMin.x, xCenter.y));\n    IMPL_WORLEY_POINT(vec2(xMin.x, xMax.y));\n    \n    IMPL_WORLEY_POINT(vec2(xCenter.x, xMin.y));\n    IMPL_WORLEY_POINT(vec2(xCenter.x, xMax.y));\n    \n    IMPL_WORLEY_POINT(vec2(xMax.x, xMin.y));\n    IMPL_WORLEY_POINT(vec2(xMax.x, xCenter.y));\n}\n\n//Variant 1: straight-line distance, to the nearest point.\nfloat worley1(float x, float chanceOfPoint, float seed);\nfloat worley1(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY1(T, nMaxPoints)                                              \\\nfloat worley1(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist = 9999999.9;                                                   \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /*Specify a hard-coded cap,  */            \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        minDist = min(minDist, efficientDist(points[i], x));                     \\\n    }                                                                            \\\n    return min(realDist(minDist, points[0]), 1.0);                \\\n}\n//end #define\nIMPL_WORLEY1(float, 3)\nIMPL_WORLEY1(vec2,  9)\n\n//Variant 2: manhattan distance, to the nearest point.\nfloat worley2(float x, float chanceOfPoint, float seed);\nfloat worley2(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY2(T, nMaxPoints)                                              \\\nfloat worley2(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist = 9999999.9;                                                   \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /* Specify a hard-coded cap,  */           \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        minDist = min(minDist, sumComponents(abs(points[i] - x)));               \\\n    }                                                                            \\\n    return min(realDist(minDist, points[0]), 1.0);                               \\\n}\n//end #define\nIMPL_WORLEY2(float, 3)\nIMPL_WORLEY2(vec2,  9)\n\n//Variant 3: straight-line distance, to the second- nearest point.\nfloat worley3(float x, float chanceOfPoint, float seed);\nfloat worley3(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY3(T, nMaxPoints)                                              \\\nfloat worley3(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist1 = 9999999.9,                                                  \\\n          minDist2 = 9999999.9;                                                  \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /* Specify a hard-coded cap,  */           \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        float newD = efficientDist(points[i], x);                                \\\n        if (newD < minDist1) {                                                   \\\n            minDist2 = minDist1; minDist1 = newD;                                \\\n        } else if (newD < minDist2) {                                            \\\n            minDist2 = newD;                                                     \\\n        }                                                                        \\\n    }                                                                            \\\n    return SATURATE(min(realDist(minDist2, points[0]) / 1.5, 1.0));                    \\\n}\n//end #define\nIMPL_WORLEY3(float, 3)\nIMPL_WORLEY3(vec2,  9)\n\n//TODO: More variants\n\n//Octave worley noise:\nfloat octaveWorley1Noise(float x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, worley1, chanceOfCell COMMA, ); return outNoise; }\nfloat octaveWorley1Noise(vec2 x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, worley1, chanceOfCell COMMA, ); return outNoise; }\nfloat octaveWorley2Noise(float x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, worley2, chanceOfCell COMMA, ); return outNoise; }\nfloat octaveWorley2Noise(vec2 x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(x, outNoise, persistence, seed, nOctaves, worley2, chanceOfCell COMMA, ); return outNoise; }\n\n//TODO: Profile worley noise compared to a more hard-coded implementation.", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "ssdBW8", "name": "boundtesting", "author": "Del", "description": "simple test to get bounds for cut spheres (for use in a voxel engine) - mousebutton = sidecam\ncutting now uses a signed cut value so it can cut top->bottom or bottom->top", "tags": ["sphere", "box", "cut", "bounds"], "likes": 8, "viewed": 287, "published": 3, "date": "1656434439", "time_retrieved": "2024-07-30T16:42:38.816708", "image_code": "// doing some simple bounds testing (for voxel engine)\n// cut sphere distance funcs by IQ:\n// https://www.shadertoy.com/view/7tVXRt\n// https://www.shadertoy.com/view/stKSzc\n\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float w = sqrt(r*r-h*h);\n    return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                            abs(length(q)-r) ) - t;\n}\n\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for a given shape\n    vec2 q = vec2( length(p.xz), p.y );\n    float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n    return (s<0.0) ? length(q)-r :\n           (q.x<w) ? h - q.y     :\n                     length(q-vec2(w,h));\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e)\n{\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// pos, rad, signed cutvalue (-1.0 to 1.0), hollow flag\nfloat cutspheretest(vec3 pos, float rad, float scut, bool hollow)\n{\n    //scut = sin(iTime*0.5); // test cut\n    float s = scut<0.0 ? -1.0 : 1.0;\n    scut = abs(scut);\n\n    float plane = -((scut-0.5)*(rad*2.0));\n    float d = 0.0;\n    float thick = 0.0;\n    if (hollow)\n    {\n        thick = .1;\n        d = sdCutHollowSphere(pos*s,rad,plane,thick);\n    }\n    else\n    {\n        d = sdCutSphere(pos*-s,rad,-plane);\n    }\n\n    // bounding box distance\n    float h = (plane+rad)*0.5;\n    float yoff = rad-h;\n    yoff*=s;\n\n    vec3 bbmid = vec3(0.0,yoff,0.0);\n    vec3 bbsize = vec3(rad,h,rad)+thick;\n    float d2 = sdBoundingBox(pos+bbmid,bbsize,0.025);\n    return min(d,d2);\n}\n\n\nfloat map( in vec3 pos )\n{\n    float rad = 2.0;\n    float scut = sin(iTime*0.9); // signed normalized cut value\n    float d1 = cutspheretest(pos+vec3(2.5,0.0,0.0),rad,scut,false);\n    scut = sin(iTime*0.6); // signed normalized cut value\n    float d2 = cutspheretest(pos+vec3(-2.5,0.0,0.0),rad,scut,true);\n    return min(d1,d2);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n    \n    float yy = 4.0;\n    if (iMouse.z>0.5)\n        yy=0.0;\n    \n\tvec3 ro = vec3( 9.*cos(an), yy, 9.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 30.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 236, 236, 410], [412, 412, 468, 468, 748], [750, 750, 797, 797, 1077], [1079, 1135, 1202, 1243, 1810], [1813, 1813, 1839, 1839, 2143], [2145, 2191, 2223, 2223, 2461]]}
{"id": "fsdfW8", "name": "Dreamy Geometry", "author": "leon", "description": "Happy shappy shapes", "tags": ["abstract", "dream", "kif", "softracer"], "likes": 18, "viewed": 490, "published": 3, "date": "1656423728", "time_retrieved": "2024-07-30T16:42:39.600612", "image_code": "\n\n// Dreamy Geometry by Leon Denise 2022-06-28\n// using code from Inigo Quilez, Dave Hoskins, Blackle, NuSan and many more\n\n// Softracing geometry sketch using temporal accumulation to trace motion\n// trying a trick of floored hashed seeds to duplicate shapes\n// a remix of Taste of Noise 7 https://www.shadertoy.com/view/NddSWs\n\n// code is in Buffer A\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nfloat delay = 15.;\n\nfloat anim, aanim, seed, index, ttime, rng1, rng2;\nvec3 rng, rndMove1, rndMove2, rndMove3, rndMove4, rndScale1, cam;\nvec4 rndRot1, rndRot2;\n\nfloat map (vec3 pos)\n{\n    vec3 p = pos;\n    float dist = 100.;\n    float shape = 100.;\n\n    // expansion anim\n    float r = .01*rng.x+.4*aanim;\n    float t = r*.1+index+aanim;\n\n    // twist and fold\n    const float count = 3.;\n    float a = 1.;\n    for (float index = 0.; index < count; ++index)\n    {\n        p.xy *= rot(t/a);\n        p.xz *= rot(t/a);\n        p = abs(p)-r*a;\n        a /= 2.8;\n    }\n\n    // shapes\n    dist = length(p)-0.01; // curves\n    dist = smin(dist, length(pos)-.1, .1); // kernel\n    shape = max(abs(length(pos)-.5)-.01, pos.z-.1); // cocoon\n    shape = min(shape, length(pos+rndMove1*.8)-.1*rng1); // spheres\n\n    // tubes\n    p = rndrot(pos, rndRot1) + rndMove2 * .5;\n    shape = smin(shape, max(abs(p.y)-2.*aanim, length(p.xz)-.02), .2);\n\n    // rings\n    p += rndMove3 * 1.5;\n    shape = smin(shape, sdTorus(p, vec2(.2,.01) * rng2), .2);\n\n    // boxes\n    p = rndrot(pos, rndRot2) + rndMove4 * 2.;\n    shape = min(shape, sdBoxFrame(p, rndScale1*.5, .01));\n\n    // blend\n    dist = smin(dist, shape, .1);\n    return dist;\n}\n\n\n// NuSan \n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos, float e) {\n    vec2 noff = vec2(e,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // timeline\n    ttime = iTime/delay;\n    anim = fract(ttime);\n    index = floor(ttime);\n    aanim = pow(anim, .5);\n\n    // randoms\n    rng = hash33(vec3(gl_FragCoord.xy, iTime));\n    seed = floor(rng.y*32.)+index*72.;\n    rng1 = hash11(seed);\n    rng2 = hash11(seed+763.);\n    rndMove1 = normalize(tan(hash31(seed)*2.-1.));\n    rndMove2 = hash31(seed+76.)*2.-1.;\n    rndMove3 = hash31(seed+192.)*2.-1.;\n    rndRot1 = hash41(seed)*2.-1.;\n    seed = floor(rng.x*32.)+index*76.;\n    rndMove4 = hash31(seed+32.)*2.-1.;\n    rndScale1 = hash31(seed+65.);\n    rndRot2 = hash41(seed)*2.-1.;\n    cam = (hash31(index)*2.-1.)*.5 + vec3(0,0,4.5);\n    vec3 blur = hash33(vec3(gl_FragCoord.xy, iTime))*2.-1.;\n\n    // coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 at = vec3(0);\n    vec3 ray = lookAt(cam, at, p, .5+.5*length(cam));\n    blur *= 0.1 * ss(.5, 1., length(p));\n    vec3 pos = cam + ray * rng.z + blur;\n\n    // ray shooting\n    float shade = 0.;\n    const float count = 30.;\n    for (shade = 1.; shade > 0.; shade -= 1./count) {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .5 + 0.5 * rng.z;\n        pos += ray *dist;\n    }\n\n    // coloring\n    vec3 color = vec3(1);\n    vec3 normal = getNormal(pos, .001);\n    float angle = abs(dot(ray, normal));\n    color = .5+.5*cos(vec3(1,2,3)*2.+pos*3.+normal);\n    color = mix(color, vec3(1), angle);\n    color *= shade*shade;\n\n    // fade in\n    color *= ss(.0,1./delay,anim);\n\n    // temporal accumulation\n    vec4 frame = texture(iChannel0, uv);\n    color = max(frame.rgb, color);\n\n    // fade out\n    if (anim * delay > delay - 1.)\n    {\n        color = frame.rgb;\n        color -= iTimeDelta;\n    }\n\n    fragColor = vec4(color, 1);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define ss(a,b,t) smoothstep(a,b,t)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nvec3 lookAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// blackle\n// https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\nvec3 rndrot(vec3 p, vec4 rnd) {\n  return erot(p, normalize(tan(rnd.xyz)), rnd.w*3.1415);\n}\n\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hash32(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec4 hash41(float p){\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdfW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[330, 353, 410, 410, 476]]}
{"id": "NddfDr", "name": "Horble", "author": "pyBlob", "description": "https://en.wikipedia.org/wiki/Losharik", "tags": ["losharik", "horble"], "likes": 11, "viewed": 366, "published": 3, "date": "1656363924", "time_retrieved": "2024-07-30T16:42:40.351604", "image_code": "// Also see Static Horble. Same model, runs faster without arrays and without loops.\n// https://www.shadertoy.com/view/NsdfW4\n\nint leftFoot;\nint rightFoot;\nint rearFoot;\nint saddle;\n\nvoid connectHorble()\n{\n    // animation blend states\n    float t = .5+.5*cos(iTime/2.0); t*1.;\n    float u = .5+.5*cos(iTime/3.2); u*=.5;\n    float v = smoothstep(0.2,0.3,cos(iTime/2.7)); v*=1.;\n    float w = smoothstep(0.5,0.6,cos(iTime/4.2+2.0)); w*=1.;\n    float x = cos(iTime*12.); x*=smoothstep(0.5,1.0,cos(iTime/2.3));\n    float y = .5+.5*cos(iTime*2.); y*=smoothstep(0.73,1.0,cos(iTime/3.9));\n    u += .15 * y;\n\n    float bend;\n\n    // first ball\n    root(vec3(0.0, 0.0, 0.0), vec2(0.00 + fade(.1,u), 0.53 + fade(.02,t) + fade(-.020,u)), 0.10); turn(radians(5. + fade(-6.,u)));\n    \n    // right leg\n    bend = 40. + fade(-2.,t) + fade(1.5,u);\n    connect(vec3(0.70, 0.50, 0.40), radians(200. + fade(3.,t) + fade(-7.,u)), 0.05);\n    connect(vec3(0.80, 0.20, 0.00), radians(bend), 0.05);\n    connect(vec3(0.70, 0.01, 0.00), radians(bend), 0.05);\n    connect(vec3(0.60, 0.10, 0.00), radians(bend*1.2), 0.05);\n    connect(vec3(0.60, 0.00, 0.00), radians(bend*-.5), 0.05);\n    connect(vec3(0.50, 0.01, 0.00), radians(bend*-.5), 0.06); rightFoot = current;\n    up(6);\n\n    // back\n    bend = -20.;\n    connect(vec3(0.70, 0.10, 0.00), radians(-bend + fade(-2.,t)), 0.12); saddle = current;\n    connect(vec3(0.70, 0.00, 0.00), radians(2.*bend), 0.10); turn(radians(-bend)); \n\n    // tail\n    bend = -20.+fade(25.,y);\n    connect(vec3(0.90, 0.30, 0.02), radians(055.), 0.05);\n    connect(vec3(0.70, 0.05, 0.00), radians(bend), 0.05);\n    connect(vec3(0.40, 0.01, 0.00), radians(bend), 0.05);\n    connect(vec3(0.80, 0.35, 0.00), radians(bend), 0.07);\n    up(4);\n    \n    // rear leg\n    bend = -15. + fade(1.,t) + fade(-10.,u);\n    connect(vec3(0.01, 0.01, 0.01), radians(310. + fade(20.,u)), 0.05);\n    connect(vec3(0.05, 0.20, 0.02), radians(bend), 0.05);\n    connect(vec3(0.00, 0.00, 0.00), radians(bend), 0.05);\n    connect(vec3(0.80, 0.00, 0.00), radians(bend*1.5), 0.05);\n    connect(vec3(0.00, 0.01, 0.03), radians(bend*.1), 0.05);\n    connect(vec3(0.00, 0.00, 0.00), radians(bend*-.2), 0.06); rearFoot = current;\n    up(6);\n    up(2);\n\n    // head\n    bend = -15.;\n    connect(vec3(0.80, 0.05, 0.00), radians(140.), 0.05);\n    connect(vec3(0.00, 0.05, 0.20), radians(bend), 0.05);\n    connect(vec3(0.00, 0.40, 0.00), radians(bend), 0.05);\n    connect(vec3(0.80, 0.40, 0.03), radians(bend), 0.15);\n    connect(vec3(0.70, 0.00, 0.00), radians(310.), 0.05); move(-0.010, 0.000); up(1);\n    // eye\n    connect(vec3(0.90, 0.90, 0.90), radians(000.), 0.07); move(-0.190, 0.020); turn(radians(150.+fade(20.,u)));\n    connect(vec3(0.00, 0.00, 0.00), radians(000.), 0.06); move(-0.132+fade(-.005,w), 0.014+fade(-.007,v)); up(2);\n    // nose\n    connect(vec3(0.10, 0.01, 0.00), radians(080.), 0.06); move(-0.030, 0.000); up(1);\n    // mouth\n    connect(vec3(0.40, 0.05, 0.00), radians(125.), 0.03); move(-0.030+fade(.002,x), 0.000); up(1);\n    up(4);\n    \n    // left leg\n    bend = 25. + fade(-4., t);\n    connect(vec3(0.00, 0.00, 0.20), radians(215. + fade(7.,t) + fade(-4.,u)), 0.05);\n    connect(vec3(0.00, 0.20, 0.00), radians(bend), 0.05);\n    connect(vec3(0.00, 0.00, 0.15), radians(bend), 0.05);\n    connect(vec3(0.01, 0.01, 0.01), radians(bend), 0.05);\n    connect(vec3(0.40, 0.02, 0.00), radians(bend*-.2), 0.05);\n    connect(vec3(0.00, 0.00, 0.00), radians(bend*-.3), 0.06); leftFoot = current;\n    up(6);\n}\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    f = 2. / iResolution.y;\n    vec2 uv = O - vec2(iResolution.x / 2., 0);\n    uv *= f;\n    uv.y -= 0.2;\n    uv.x += 0.3;\n    \n    connectHorble();\n\n    C = vec4(0.11, 0.40, 0.90, 1);\n    vec3 light = normalize(vec3(10, 9, 5));\n    vec3 rd = vec3(0, 0, -1);\n    vec3 grass = vec3(0.6,0.7,0);\n    vec2 shadow = (circles[leftFoot].center + circles[rightFoot].center + circles[rearFoot].center * 2.) / 4.;\n    //vec2 shadow = vec2(circles[saddle].center.x, 0.);\n    float rshadow = length((uv - shadow)*vec2(1.5,5));\n    grass *= mix(.5, 1., smoothstep(0.1, 1., rshadow));\n    C = blend(C, grass, -uv.y/f);\n    for (int i=0 ; i<N ; ++i)\n    {\n        vec2 offset = uv - circles[i].center;\n        float r = length(offset);\n        vec3 color = circles[i].color;\n        vec3 normal = vec3(offset / circles[i].radius, 0);\n        normal.z = sqrt(max(0., 1. - l2(normal.xy)));\n        color *= .5 + clamp(dot(normal, light), 0., 1.);\n        color += vec3(.1) * pow(clamp(l2(cross(rd, normal)), 0., 1.), 4.) * clamp(dot(normal, light)+.1, 0., 1.);\n        color += vec3(.5) * pow(clamp(dot(reflect(rd, normal), light), 0., 1.), 30.);\n        C = blend(C, color, -(r-circles[i].radius)/f);\n    }\n    C.xyz = sqrt(C.xyz);\n}\n", "image_inputs": [], "common_code": "struct Circle\n{\n    int parent;\n    vec3 color;\n    vec2 center;\n    float radius;\n    float angle;\n};\n\nconst int N = 3 + (3+1) + (3+(1+(1+2+1+1))) + 3 * (5+1);\n\nint free, current;\nCircle[N] circles;\n\nmat2 R(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\nvec2 v(float a)\n{\n    return vec2(1, 0) * R(a);\n}\nvoid root(vec3 color, vec2 center, float radius)\n{\n    free = 0;\n    circles[free] = Circle(free, color, center, radius, 0.);\n    current = free++;\n}\nvoid connect(vec3 color, float angle, float radius)\n{\n    vec2 center = circles[current].center;\n    angle += circles[current].angle;\n    center += v(angle) * (circles[current].radius + radius);\n    circles[free] = Circle(current, color, center, radius, angle);\n    current = free++;\n}\nvoid move(float dx, float dy)\n{\n    circles[current].center += vec2(dx, dy) * R(circles[current].angle);\n}\nvoid turn(float da)\n{\n    circles[current].angle += da;\n}\nvoid up(int n)\n{\n    for (int i=0 ; i<n ; ++i)\n        current = circles[current].parent;\n}\n\nfloat fade(float target, float x) { return mix(0., target, x); }\n\nfloat f;\nvec4 blend(vec4 C, vec3 c, float r)\n{\n    return mix(C, vec4(c, 1), clamp(r + .5, 0., 1.));\n}\n\nfloat l2(vec2 x)\n{\n    return dot(x, x);\n}\n\nfloat l2(vec3 x)\n{\n    return dot(x, x);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddfDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 205, 235, 3497], [3499, 3499, 3538, 3538, 4755]]}
{"id": "7ddBDn", "name": "002 - Respiration line improve", "author": "PiGIon", "description": "002 - I studied a bit about some glsl funcions and tried to \"mathify\" the cycle function.\n\nCompared to the first version, this code is way smaller, but I think that the cycle function is less performant and can be replaced by a smooth-step function.", "tags": ["beginner", "learning", "step"], "likes": 0, "viewed": 183, "published": 3, "date": "1656357796", "time_retrieved": "2024-07-30T16:42:41.097609", "image_code": "// 2022.06.27 rev 1\n\n#define PI 3.14159265\n\n// https://www.wolframalpha.com/input?i=f%28x%29%3D0.5%2B%28cos%28%28%28x%2B0.5%2F1%29*20*1%29%2F%28PI%29%29%2F2.%29\nfloat cycle(float perSecond) {\n    // let n be the ammount of cycles per second\n    // f(x)=0.5 + (cos(((x + 0.5/ n ) * 20 * n ) / (PI)) / 2.)\n    return 0.5+(cos(((iTime+0.5/perSecond)*20.*perSecond)/(PI))/2.);\n}\n\nfloat horizontalCycle() {\n    return 0.5 + (cycle(0.34) * 0.5) - 0.25;\n}\n\nfloat diagonalLine(vec2 uv, float width) {\n    return step(distance(uv.x, uv.y), width);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    // Now, the coord system is 0 to 1\n    // [0, 0] = left bottom corner\n    // [1, 1] = top right corner\n    \n    // I had a huge problem trying to discover how to mix the middle\n    // screen divided colors with the line\n    // I noticed that I can use the step function to \"exclude\" what should be\n    // drawn to the screen\n    //\n    // red is only 1, when l is 1 AND (through a multiplication) is above the h threshould\n    // h is like the middle of the screen, but animated between 0.25 and 0.75\n    //\n    // green is only 1, when l is 1 AND (through a multiplication) is below the h threshould\n    // h is like the middle of the screen, but animated between 0.25 and 0.75\n    //\n    // blue is only 1, when l is 0 through a abs invert of abs(1-1) -> 0 and abs(0-1) -> 1\n    \n    float l = diagonalLine(uv, (0.1 + (cycle(0.233) * 0.1)));\n    float h = horizontalCycle();\n    \n    l = step(l, uv.x);\n    fragColor = vec4(\n        l * step(h, uv.x),\n        l * step(uv.x, h), \n        abs(1.-l), \n        1\n    );\n    \n    // cute bug :)\n//        fragColor = vec4(\n//            max(step(horizontalCycle(), l), uv.x),\n//            max(uv.x, step(l, horizontalCycle())), \n//            0, \n//            1\n//        );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 161, 191, 303, 374], [376, 376, 401, 401, 448], [450, 450, 492, 492, 540], [542, 542, 599, 599, 1873]]}
{"id": "fddfWn", "name": "Neon trip", "author": "marvpaul", "description": "Quick and dirty sketch for a project at work which never got the green lights", "tags": ["raymarching", "tunnel", "neon"], "likes": 8, "viewed": 393, "published": 3, "date": "1656347496", "time_retrieved": "2024-07-30T16:42:42.272468", "image_code": "//quick and dirty code for prototyping\n// Inspirartion / base from here: https://www.shadertoy.com/view/wl2SRK\n\n#define MAXSTEPS 90\n#define MAXDIST 4.0\n#define PI 3.1415926535898\n#define TWOPI 6.28318530718\n#define FUZZ 0.4\n#define PHASELENGTH 30.0\n#define PHASE mod(iTime/PHASELENGTH/5.,1.0)\n#define CUBENUM 50.0\n#define DISTANCEPERPHASE 400.0\n#define EPSILON 0.005\n\nvec3 glow = vec3(0);\nvec3 lastglow = vec3(0);\nvec3 cubeColor = vec3(0);\nfloat ringOffset = +0.6;\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nvec3 displacement(float p) {\n    p *= 5.0*TWOPI/DISTANCEPERPHASE;\n    return vec3(sin(p),cos(p*0.5+PI+PHASE*TWOPI*3.0)*0.37,0)*1.7;\n}\n\n\n//sdf functions taken from iq\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat sdBox( vec3 p, vec3 b )\n{    \n\tfloat interval = DISTANCEPERPHASE/CUBENUM;\n  \tvec3 offset = displacement(round(p.z / interval +0.5)*interval - ringOffset);\n  \tp -= offset;\n    \n    float num = mod(floor(p.z/interval)+1.0,DISTANCEPERPHASE/interval)*4.0;\n    cubeColor = normalize(texture(iChannel0, vec2((num+0.5)/256.0,0.2/256.0)).xyz);\n  \tp.z = mod(p.z,interval) - interval*0.5;\n    p = mat3(rotationX(PHASE*TWOPI*5.0) * rotationZ(PHASE*TWOPI*18.0))*p;\n    \n  \tvec3 d = abs(p) - b;\n  \tfloat res = length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n\n    lastglow = pow(max(0.0,(1.0-(res/2.0))),4.0) * cubeColor * 0.1;\n    glow += lastglow;\n    \n    return res;\n}\nfloat sdTube(vec3 p, float r)\n{\n    p.y += 0.8;\n    p -= displacement(p.z);\n    return length(p.xy)-r;\n}\n\nfloat sdTube2(vec3 p, float r)\n{\n    p -= displacement(p.z+1.5 - ringOffset);\n    return min(length(p.xy - vec2(0,0.9)),min(length(p.xy + vec2(0.9,0)),length(p.xy- vec2(0.9,0))))-r;\n}\n\nfloat sdTorus( vec3 p, float r1, float r2 )\n{\n    float interval = DISTANCEPERPHASE/CUBENUM;\n    vec3 offset = displacement(round(p.z / interval+0.5)*interval - ringOffset);\n    p -= offset;\n    p.z = mod(p.z,interval) - interval*0.5;\n    return length( vec2(length(p.xy)-r1,p.z) )-r2;\n}\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e, bool reactive )\n{\n\nfloat interval = DISTANCEPERPHASE/CUBENUM/2.0;\n  \tvec3 offset = displacement(round(p.z / interval +0.5)*interval - ringOffset);\n\n  \tp -= offset ;\n \n    float num = mod(floor(p.z/interval)+1.0,DISTANCEPERPHASE/interval)*4.0;\n    if(reactive){\n        e += texture(iChannel1, vec2((DISTANCEPERPHASE/interval)*3.,0.2/256.0)).x/4.0; \n    }\n    cubeColor = normalize(texture(iChannel0, vec2((num+0.5)/256.0,0.2/256.0)).xyz);\n  \tp.z = mod(p.z,interval) - interval*0.5;\n    //p = mat3(rotationX(PHASE*TWOPI*5.0) * rotationY(PHASE*TWOPI*18.0))*p;\n        p = mat3(rotationX(80.0)*rotationY(0.10*DISTANCEPERPHASE/interval)*rotationZ(PHASE*TWOPI*5.0))*p;\n           p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  float res = min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n\n    lastglow = pow(max(0.0,(1.0-(res/2.0))),4.0) * cubeColor * 0.1;\n    glow += lastglow/1.3;\n    \n    return res;\n}\n\n\nfloat map(vec3 pos)\n{\n    vec3 p=pos;\n    float d0 = sdTube(pos, 0.501);\n    float d1 = sdTorus(pos, 0.9, 0.05);\n    float d2 = sdTube2(pos,0.05);\n       //d0 = opSmoothUnion(d0,d1,0.5);\n    d1 = sdBoxFrame(pos, vec3(1,0.3,1), 0.05, true);\n    d2 = sdBoxFrame(pos, vec3(3.0+texture(iChannel1, vec2(0.,0.)).x*5.0,1,3.0+texture(iChannel1, vec2(0.,0.)).x), 0.05, false);\n    //d0 = opSmoothUnion(d0,d1,0.5);\n    //d0 = opSmoothUnion(d0,d2,0.1);\n    \n\n    //d1 = sdBox(pos, vec3(0.05));\n    //d1 = 1000.0;\n    return min(d1, d2);\n}\n\nvoid intersect(vec3 ro, vec3 rd)\n{\n    float res;\n    float d = 0.01;\n    for(int i = 0; i < MAXSTEPS; i++)\n    {\n        vec3 p = ro + rd * d;\n        res = map(p);\n        if(res < EPSILON * d || res > MAXDIST) {\n            break;\n        }\n        d += res*FUZZ;\n    }\n    glow += lastglow*6.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5)/ iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float fov = 0.25 * PI;\n    vec3 origin = vec3(0,0, PHASE*DISTANCEPERPHASE);\n    vec3 target = origin -vec3(0.0, 0.001, -0.05);\n    \n    target += displacement(target.z*1.0);\n    origin += displacement(origin.z*1.0);\n\n\tvec3 forward = normalize(target - origin);\n \tvec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));   \n    vec3 up = cross(right, forward);\n    vec3 dir = normalize(uv.x * right + uv.y * up + fov * forward);\n    \n    intersect(origin, dir);\n\tfragColor = vec4(glow, 1.0);\n}", "image_inputs": [{"id": 13, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 466, 500, 500, 639], [641, 641, 675, 675, 811], [813, 813, 847, 847, 980], [982, 982, 1010, 1010, 1115], [1118, 1148, 1200, 1200, 1299], [1302, 1302, 1333, 1333, 1971], [1972, 1972, 2003, 2003, 2076], [2078, 2078, 2110, 2110, 2261], [2263, 2263, 2308, 2308, 2550], [2553, 2553, 2613, 2613, 3671], [3674, 3674, 3695, 3695, 4201], [4203, 4203, 4237, 4237, 4503], [4505, 4505, 4562, 4562, 5176]]}
{"id": "wl2yD1", "name": "3d dick", "author": "maxim", "description": "shader that draw dicks in 3d", "tags": ["3ddick"], "likes": 0, "viewed": 386, "published": 3, "date": "1656343181", "time_retrieved": "2024-07-30T16:42:43.049391", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define a .12\n\nmat3 rotX(float angle){\n    return mat3(1., 0., 0.,0., cos(angle), -sin(angle),0., sin(angle), cos(angle));\n}\n\nmat3 rotY(float angle){\n    return mat3(cos(angle), 0., sin(angle), 0., 1., 0. ,-sin(angle), 0., cos(angle));\n}\n\nmat3 rotZ(float angle){\n    return mat3(cos(angle), -sin(angle), 0., sin(angle), cos(angle), 0. ,0., 0., 1.);\n}\n\n\nfloat N11(float p){\n\treturn fract(sin(p*123.230+p*p*2345.36)*256.753);\n}\n\nvec3 N13(float p){\n    float t = iTime*2.5;\n    vec3 r = vec3(sin(N11(p+.255)*235.235+t*2.),sin(N11(p-.12432)*123.234+t*1.12423),sin(N11(p*2.)*546.36+t*3.));\n    return (0.7 - (r*.5 + .5) * 0.5);\n}\n\nfloat GetDist(vec3 p){\n    \n    float id = floor(p.x*.015/a);\n    \n    p.x = fract((p.x+a)*a)/a-4.3;\n    \n    p.y += 2.;\n    //p.y = (p.y - fract((p.y+iTime*4.)/20.));\n    \n    \n    float dist = 21.;\n\n    \n    p -= vec3(0.,0.,dist);\n    p *= rotX(3.141592653589793238464*0.5);\n    //p *= rotZ(iTime*4.23);\n    //p *= rotX(iTime*3.9786);\n    p += vec3(0.,2.,dist);\n    \n    \n    float dS1 = length(p-vec3(1,0,dist))-1.;\n    float dS2 = length(p-vec3(-1,0,dist))-1.;\n    float y2 = min(max(p.y,1.),4.);\n    float dC = length(p-vec3(0,y2,dist))-1.;\n\treturn(min(min(dS1,dS2),dC));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n\tfloat dO = 0.;\n    for(int i = 0; i <= MAX_STEPS; i++){\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dS < SURF_DIST || dO > MAX_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 0);\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col;\n    \n    vec3 ro = vec3(0,2,0);\n    \n    ro.x += 20.*sin(iTime*1.);\n    \n    ro.z += 4.*sin(iTime*10.);\n    \n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro,rd);\n    vec3 p = ro + rd * d;\n    \n    float id = floor(p.x*.015/a);\n    \n    float dif = dot(GetNormal(p),vec3(0,1,-1));\n    col = vec3(dif)*N13(id);\n    \n    col = pow(col, vec3(.4545));\n    \n    //col.r = N11(id);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 104, 104, 190], [192, 192, 215, 215, 303], [305, 305, 328, 328, 416], [419, 419, 438, 438, 491], [493, 493, 511, 511, 690], [692, 692, 714, 714, 1270], [1272, 1272, 1305, 1305, 1521], [1523, 1523, 1547, 1547, 1736], [1738, 1738, 1762, 1762, 2072], [2074, 2074, 2131, 2131, 2648]]}
{"id": "NdcfDn", "name": "Spectrometer Heatmap", "author": "Peace", "description": "Spectrometer", "tags": ["sound", "spectrometer", "spectrometer", "decibalmeter", "decibalmeter"], "likes": 1, "viewed": 434, "published": 3, "date": "1656312312", "time_retrieved": "2024-07-30T16:42:43.877178", "image_code": "// Frequency goes from 0 to 12khz (left to right), frequency scaling is linear\nvec2 uv;\n\nvec3 lerp4(vec3 colors[4], float k)\n{\n    float k4 = k * 4.0;\n    int index2 = int(floor(k4));\n    int index1 = max(index2 - 1, 0);\n    return mix(colors[index1], colors[index2], mod(k4, 1.0)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord/iResolution.xy;\n    float audio = texture(iChannel0, uv).r;\n    vec3 col = lerp4(vec3[4](vec3(0,0,0),vec3(0.5,0,1.0),vec3(1.0,0.75,0.0),vec3(1.0,1.0,1.0)), audio);\n    //col = mix(col, vec3(.5), rg.g - 11111.5);\n    //float max_audio = clamp(texture(iChannel0, vec2(uv.x, 0.0)).g, 0.0, 1.0);\n    //float d = distance(uv, vec2(uv.x, (max_audio * 2.0 - 1.0)));\n    //d = smoothstep(0.02 + 2.0 / iResolution.y, 0.02 - 2.0 / iResolution.y, d);\n    //d = min(smoothstep(0.55, 0.45, d), smoothstep(0.45, 0.55, d));\n    //col = mix(col, vec3(1), d);\n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (fragCoord.y < 1.0)\n    {\n        fragColor.r = texture(iChannel0, vec2(uv.x, 0.0)).r;\n        //fragColor.g = max(texture(iChannel1, vec2(uv.x, 0.0)).g, fragColor.r);\n        return;\n    }\n    fragColor.r = texture(iChannel1, uv - vec2(0, 1.0 / iResolution.y)).r;\n}", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 126, 126, 285], [287, 287, 344, 344, 938]]}
{"id": "NscBDn", "name": "checkerboard distance field", "author": "mrange", "description": "License CC0: checkerboard distance field\nNeeded a checkerboard so threw this together. \nCheckerboard can be created by sign(p.x*p.y) but\nthe issue is the lines might look jagged once \nrotating the board", "tags": ["2d"], "likes": 12, "viewed": 316, "published": 3, "date": "1656309673", "time_retrieved": "2024-07-30T16:42:44.671055", "image_code": "// License CC0: checkerboard distance field\n// Needed a checkerboard so threw this together. \n// Checkerboard can be created by sign(p.x*p.y) but\n// the issue is the lines might look jagged once \n// rotating the board\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat checkerboard(vec2 p) {\n  p = fract(p)-0.5;\n  float s = sign(p.x*p.y);\n  p = abs(abs(p)-0.25);\n  return s*(max(p.x, p.y) - 0.25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 op = p;\n  p *= ROT(0.2*TIME);\n\n  const float sz = 2.0;\n  float aa = sz*2.0/RESOLUTION.y; \n\n  float d = checkerboard(p*sz);\n\n  vec3 col = mix(vec3(0.0), vec3(0.5), smoothstep(aa, -aa, d));\n  if (op.x > 0.0) col += 0.5*vec3(0.0, 0.5, 1.0)*sin(TAU*d/(10.0*aa));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscBDn.jpg", "access": "api", "license": "cc0-1.0", "functions": [[397, 397, 425, 425, 533], [535, 535, 592, 592, 1006]]}
{"id": "Ns3BDn", "name": "Led lights", "author": "Peace", "description": "Grid of old school Leds for personal project", "tags": ["led", "lights", "bulb", "lightbulb", "ledlights"], "likes": 16, "viewed": 483, "published": 3, "date": "1656308889", "time_retrieved": "2024-07-30T16:42:45.454959", "image_code": "vec2 uv;\nvec3 col = vec3(1);\nvec3 color;\nint ind = 0;\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvoid circle(float x, float y, float size, float smoothing)\n{\n    color = mix(color, col, pow(1.0 - smoothstep(size * (1.0 - smoothing), size * (1.0 + smoothing), distance(uv, vec2(x, y))), 2.0));\n}\n\nvoid bulb(float x, float y, float s, float brightness)\n{\n    brightness *= brightness * brightness;\n    \n    col = color * (0.85 + brightness * 0.2);\n    circle(x, y, s * 2.0, 1.0);\n    \n    col = color * 0.9;\n    circle(x, y, s * 1.25, 0.1);\n    \n    vec3 off = mix(color, vec3(0.6 + noise(uv * 32.0) * 0.3), 0.8);\n    vec3 on = vec3(1.4, 1.3, 1.15);\n    col = mix(off, on, brightness);\n    circle(x, y, s + s * brightness * 0.2, brightness * 1.0 + 0.03);\n}\n\nvoid grid()\n{\n    float s = 0.04;\n    float a = iResolution.x / iResolution.y;\n    for(float x = -a + s * a; x <= a + s * a; x += s * 4.0)\n    {\n        for(float y = -1.0 + s * 2.0; y <= 1.0 + s; y += s * 5.0)\n        {\n            float brightness = noise((x * (a + s * a) + y) * 617.2 + iTime);\n            bulb(x, y, s, brightness);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y ;\n\n    color = vec3(0.84, 0.81, 0.80);\n    color += (noise(uv * 16.0) * 0.5 + noise(uv * 32.0) * 0.3 + noise(uv * 64.0) * 0.2) * 0.12 - 0.06;\n    \n    grid();\n\n    color = pow(color, vec3(1.5));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3BDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 75, 75, 113], [115, 115, 136, 136, 226], [228, 228, 248, 248, 315], [317, 317, 337, 337, 546], [548, 548, 608, 608, 745], [747, 747, 803, 803, 1205], [1207, 1207, 1220, 1220, 1561], [1563, 1563, 1620, 1620, 1912]]}
{"id": "fdcBWn", "name": "网格线", "author": "assfafa", "description": "网格", "tags": ["grid"], "likes": 0, "viewed": 217, "published": 3, "date": "1656296529", "time_retrieved": "2024-07-30T16:42:46.251828", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    float p = cos(uv.x*100.);\n    float c = sin(uv.y*100.);\n    p = max(sign(p-0.95),0.);\n    c = max(sign(c-0.95),0.);\n    fragColor = vec4(vec3(c)+vec3(p),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcBWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 302]]}
{"id": "NsGyRG", "name": "Attempting Perlin Noise", "author": "SpinningCube", "description": "My implementation of perlin noise.", "tags": ["2d", "noise", "perlin"], "likes": 2, "viewed": 274, "published": 3, "date": "1656296119", "time_retrieved": "2024-07-30T16:42:47.027754", "image_code": "// Perlin Noise\n\nfloat hash12(vec2 p) // Hash by Dave_Hoskins\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 randUnitVector(vec2 pos) {\n    float angle = 2. * 3.1415926536 * hash12(pos);\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat perlin(vec2 pos) {\n    // Grid cell corner points\n    vec2 p00 = floor(pos);\n    vec2 p01 = p00 + vec2(0, 1);\n    vec2 p11 = p00 + vec2(1, 1);\n    vec2 p10 = p00 + vec2(1, 0);\n    \n    // Random vectors at corner points\n    vec2 r00 = randUnitVector(p00);\n    vec2 r01 = randUnitVector(p01);\n    vec2 r11 = randUnitVector(p11);\n    vec2 r10 = randUnitVector(p10);\n    \n    // Dot product between random vector and distance vector\n    float d00 = dot(r00, pos - p00);\n    float d01 = dot(r01, pos - p01);\n    float d11 = dot(r11, pos - p11);\n    float d10 = dot(r10, pos - p10);\n    \n    \n    // Bicubic interpolation\n    vec2 blend = smoothstep(0., 1., fract(pos));\n    \n    float upper = float(mix(d01, d11, blend.x));\n    float lower = float(mix(d00, d10, blend.x));\n    return 0.8 * mix(lower, upper, blend.y) + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec3 col = vec3(uv, 0.);\n    col = vec3(perlin(10. * uv + 0.8 * iTime));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGyRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 63, 63, 180], [182, 182, 213, 213, 307], [309, 309, 333, 364, 1136], [1138, 1138, 1195, 1245, 1424]]}
{"id": "ssdfzM", "name": "Lazy-Lazy!", "author": "JTAS_GANG_TV", "description": "I don't feel like doing to much work, so I made this, because I am lazy. TUT ( I CANT HELP IT! I AM TOOOOOOOO LAZY! DX)", "tags": ["lazywork"], "likes": 1, "viewed": 199, "published": 3, "date": "1656287100", "time_retrieved": "2024-07-30T16:42:47.960260", "image_code": "// Create your own shader using GLSL Shader Language!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float dy = 5.0 / iResolution.y;\n    // xy is LR Frequency domain data\n    vec2 fv = texture(iChannel0, vec2(uv.x, 0.5)).xy;\n    // zw is LR Time domain data\n    vec2 tv = texture(iChannel0, vec2(uv.x, 0.5)).zw;\n    vec3 col = vec3(0.);\n\n    // Time domain data\n    if (!(uv.y + dy < tv.x) && (uv.y - dy < tv.x)) {\n        // Color the pixel that crosses the time domain sample value\n        col += 100.;\n    }\n    \n    // Frequency domain data\n    if (uv.y < fv.x) {\n        col.gb += fv.x + 0.4;\n    }\n\n    fragColor = vec4(col,5);\n}\n", "image_inputs": [{"id": 29227, "src": "https://soundcloud.com/jason-alvarado-26743508/circle-tales-ost-main-theme", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 110, 110, 690]]}
{"id": "NsGcWm", "name": "Ray Marching - Benjyman", "author": "Benjyman", "description": "My first attempt at ray marching.", "tags": ["raymarching"], "likes": 1, "viewed": 204, "published": 3, "date": "1656276173", "time_retrieved": "2024-07-30T16:42:48.751146", "image_code": "#define STEPS 256\n#define OCC_STEPS 32\n#define EPSILON 0.01\n\n//////////// 3d Math //////////////\n\nvec3 scaleTo(vec3 v, float length) {\n  return normalize(v) * length;\n}\n\nfloat map(float numer, float denom, float low, float high) {\n  float span = high - low;\n  return (numer / denom * span) + low;\n}\n\nmat3 rotX(float rads) {\n  return mat3(\n    1., 0.,         0.,\n    0., cos(rads), -sin(rads),\n    0., sin(rads),  cos(rads)\n  );\n}\n\nmat3 rotY(float rads) {\n  return mat3(\n    cos(rads), 0., -sin(rads),\n    0.,        1.,  0.,\n    sin(rads), 0.,  cos(rads)\n  );\n}\n\nmat3 rotZ(vec3 p, float rads) {\n  return mat3(\n    cos(rads), -sin(rads), 0.,\n    sin(rads),  cos(rads), 0.,\n    0.,         0.,        1.\n  );\n}\n\nfloat max3(vec3 v) {\n  return max(max(v.x, v.y), v.z);\n}\n\n//////////// end 3d Math //////////////\n\n//////////// SDFs //////////////\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdPlane(vec3 p, vec3 n, float h) {\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.) / k;\n    return min(a, b) - h*h*k*(1./4.);\n}\n\n//////////// end SDFs //////////////\n\n////////////// Scene //////////////////\n\nconst vec3 bearColor = vec3(.4, .2, .05);\n\nstruct RenderData {\n  vec3 c;  // color\n  float d; // distance\n  float s; // specularity\n};\n\nRenderData minRd(RenderData a, RenderData b, float k) {\n  RenderData rd;\n  rd.d = smin(a.d, b.d, k);\n  if (a.d < b.d) {\n    rd.c = a.c;\n    rd.s = a.s;\n  } else {\n    rd.c = b.c;\n    rd.s = b.s;\n  }\n  return rd;\n}\n\nRenderData minRd(RenderData a, RenderData b) {\n  return minRd(a, b, .7);\n}\n\nbool groundTile(vec3 p) {\n  p /= 5.0;\n  int xSign = p.x > 0.0 ? 1 : 0;\n  int zSign = p.z > 0.0 ? 1 : 0;\n  return ((int(p.x) ^ int(p.z) ^ xSign ^ zSign) & 1) == 1;\n}\n\nRenderData ground(vec3 p) {\n  RenderData rd;\n  rd.d = sdPlane(p, vec3(0., 1., 0.), 0.);\n  rd.c = groundTile(p) ?\n           vec3(.0, .1, .0) :\n           vec3(.1, .2, .0);\n  rd.s = 42.;\n  return rd;\n}\n\nRenderData head(vec3 p) {\n  RenderData rd;\n  rd.d = sdSphere(p - vec3(0., 10, 0.), 3.);\n  rd.c = bearColor;\n  rd.s = 8.;\n  return rd;\n}\n\nRenderData ears(vec3 p) {\n  RenderData rd;\n  p.x = abs(p.x);\n  rd.d = sdSphere(p - vec3(3., 12, 0.), 1.);\n  rd.c = bearColor;\n  rd.s = 8.;\n  return rd;\n}\n\nRenderData body(vec3 p) {\n  RenderData rd;\n  rd.d = sdRoundCone(p - vec3(0., 3.5, 0.), 2., 1., 3.);\n  rd.c = bearColor;\n  rd.s = 8.;\n  return rd;\n}\n\nRenderData render(vec3 p) {\n  RenderData rd = ground(p);\n  rd = minRd(head(p), rd);\n  rd = minRd(ears(p), rd);\n  rd = minRd(body(p), rd);\n  return rd;\n}\n\nfloat f(vec3 p) {\n  return render(p).d;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(vec3 p) {\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps, 0);\n    return normalize(\n      vec3(f(p+h.xyy) - f(p-h.xyy),\n           f(p+h.yxy) - f(p-h.yxy),\n           f(p+h.yyx) - f(p-h.yyx))\n    );\n}\n\nRenderData raycast(inout vec3 pos, in vec3 ray) {\n  RenderData rd;\n  for (int i = 0; i < STEPS; ++i) {\n    rd = render(pos);\n    if (rd.d < EPSILON) {\n      break;\n    }\n    pos += scaleTo(ray, rd.d * .7);\n  }\n  return rd;\n}\n\nfloat obstruction(vec3 pos, vec3 ray, float k) {\n  float res = 1.;\n  float d = 0.1;\n  for (int i = 0; i < OCC_STEPS; ++i) {\n    RenderData rd = render(pos + scaleTo(ray, d));\n    if (rd.d < EPSILON) {\n      return 0.0;\n    }\n    res = min(res, k*rd.d/d);\n    d += max(rd.d, EPSILON);\n  }\n  return res;\n}\n\nvec3 lighting(vec3 pos, vec3 camera, vec3 lightVector, vec3 lightIntensity, float specularIntensity) {\n  vec3 normal = calcNormal(pos);\n  \n  float obVal = obstruction(pos, -lightVector, 16.);\n  vec3 diffuse = max(dot(normal, -lightVector), 0.) * lightIntensity * obVal;\n  \n  vec3 cameraVector = normalize(camera - pos);\n  float reflection = max(dot(cameraVector, reflect(lightVector, normal)), 0.);\n  vec3 specular = lightIntensity * pow(reflection, specularIntensity) * specularIntensity / 32.;\n  return diffuse + specular;\n}\n\n////////////// end Scene //////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float rads = iTime / 6.0;\n    mat3 rot = rotY(rads) * rotX(sin(rads/1.9)*.2+.2) * mat3(1.);\n    vec3 camera = rot * vec3(0.0, 10.0, 30.0);\n    vec3 xUnit = rot * vec3(1.0, 0.0, 0.0);\n    vec3 yUnit = rot * vec3(0.0, 1.0, 0.0);\n    vec3 zUnit = rot * vec3(0.0, 0.0, 1.0);\n\n    vec3 center = camera - zUnit;\n    float dx = map(fragCoord.x, iResolution.x, -1.0, 1.0);\n    float dy = map(fragCoord.y, iResolution.y, -1.0, 1.0);\n    vec3 point = center + (dx*xUnit) + (iResolution.y/iResolution.x*dy*yUnit);\n    vec3 ray = point - camera;\n\n    vec3 pos = camera;\n    RenderData rd = raycast(pos, ray);\n\n    vec3 sky = vec3(.8, .9, 1.);\n    vec3 ambientIntensity = vec3(.1, .2, .3);\n    vec3 sunVector = normalize(vec3(-1.0, -1.0, -1.0));\n    vec3 sunIntensity = vec3(.9, .8, .7);\n    vec3 backLightVector = vec3(0., 0., 1.);\n    vec3 backLightIntensity = vec3(.4);\n\n    \n    vec3 color = vec3(0.0);\n\n    if (rd.d >= EPSILON) {\n        color = sky;\n    } else {\n        color = ambientIntensity * rd.c;\n        color += rd.c * lighting(pos, camera, sunVector, sunIntensity, rd.s);\n        color += rd.c * lighting(pos, camera, backLightVector, backLightIntensity, rd.s);\n    }\n    \n    // Gamma correction\n    fragColor.rgb = pow(color, vec3(1./2.2));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGcWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 134, 134, 168], [170, 170, 230, 230, 298], [300, 300, 323, 323, 430], [432, 432, 455, 455, 562], [564, 564, 595, 595, 709], [711, 711, 731, 731, 767], [844, 894, 934, 960, 985], [987, 987, 1020, 1020, 1046], [1048, 1098, 1154, 1216, 1495], [1497, 1538, 1577, 1577, 1656], [1873, 1873, 1928, 1928, 2086], [2088, 2088, 2134, 2134, 2162], [2330, 2330, 2357, 2357, 2530], [2532, 2532, 2557, 2557, 2667], [2669, 2669, 2694, 2694, 2822], [2824, 2824, 2849, 2849, 2971], [2973, 2973, 3000, 3000, 3125], [3127, 3127, 3144, 3144, 3168], [3170, 3217, 3242, 3242, 3444], [3446, 3446, 3495, 3495, 3670], [3672, 3672, 3720, 3720, 3975], [3977, 3977, 4079, 4079, 4503], [4550, 4550, 4606, 4606, 5858]]}
{"id": "sstfzM", "name": "Complex atanh - darkmode edition", "author": "mrange", "description": "Complex atanh - darkmode edition\nMore work tinkering based on mlas shader Complex atanh - https://www.shadertoy.com/view/tsBXRW", "tags": ["2d", "complex"], "likes": 24, "viewed": 485, "published": 3, "date": "1656270750", "time_retrieved": "2024-07-30T16:42:49.646752", "image_code": "// License CC0 - Complex atanh - darkmode edition\n// More work tinkering based on mlas shader Complex atanh - https://www.shadertoy.com/view/tsBXRW\n#define DARKMODE\n#define FASTATAN\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#if defined(FASTATAN)\n#define ATAN atan_approx\n#else\n#define ATAN atan\n#endif\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// Complex trig functions found at: Complex Atanh - https://www.shadertoy.com/view/tsBXRW\n//  A very cool shader\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),ATAN(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// My own attempt at an ctanh\nvec2 cexp(vec2 z) {\n  float r = exp(z.x);\n  return r*vec2(cos(z.y), sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n  z = cexp(2.0*z);\n  return cdiv(vec2(1,0)-z,vec2(1,0)+z);\n}\n\nfloat circle8(vec2 p, float r) {\n  p *= p;\n  p *= p;\n  return pow(dot(p, p),1.0/8.0)-r;\n}\n\nvec2 transform(vec2 z, out float aa, out vec2 hscale) {\n  float A = 9.0;\n  float B = 2.0;\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= 20.0;\n    A = floor(m.x), B = floor(m.y);\n  }\n\n  vec2 rot = vec2(A, B);\n  float a = TIME;\n  z *= 2.0;\n  z = catanh(-0.5*z+0.5*vec2(sin(a*0.234*sqrt(0.5)), sin(a*0.234)))+catanh(z*ROT(0.1234*a));\n  z /= PI;\n\n  aa = fwidth(z.x);\n  aa *= length(rot);\n  z = cmul(rot,z);\n  z.x += 0.5*a;\n\n  hscale = 1.0/rot.yx;\n  return z;\n}\n\nvec3 effect(vec3 col, vec2 op) {\n  op *= ROT(0.05*TIME);\n\n  float aaa = 2.0/RESOLUTION.y;\n  float aa;\n  vec2 hscale;\n  vec2 p = transform(op, aa, hscale);\n\n  vec2 n = round(p);\n  p -= n; // Neat!\n\n  float d = circle8(p, 0.45);\n\n  vec2 pf = p;\n  float sf = sign(pf.x*pf.y);\n  pf = abs(pf);\n  float df = sf*min(pf.x, pf.y);\n  float flip = smoothstep(aa, -aa, df);\n\n#if defined(DARKMODE)\n  col = vec3(0.0);\n  float fo = tanh_approx(0.333*aaa/(aa*hscale.x*hscale.y));\n  vec3 rgb = hsv2rgb(vec3(fract(0.65+0.2*sin(0.5*TIME+0.25*flip+PI*dot(n, hscale))), mix(0.0, 0.75, fo), mix(1.0, 0.05, fo*fo)));\n#else\n  col = vec3(1.0);\n  float fo = tanh_approx(0.125*aaa/(aa*hscale.x*hscale.y));\n  vec3 rgb = hsv2rgb(vec3(fract(0.05*TIME+0.125*flip+0.5*dot(hscale, n)), mix(0.0, 0.75, fo), mix(1.0, 0.85, fo*fo)));\n#endif\n\n  rgb = mix(rgb, smoothstep(0.5, 1.0, rgb), flip);\n  col = mix(col, rgb, smoothstep(aa, -aa, d));\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q  = fragCoord/RESOLUTION.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = vec3(1.0);\n  col = effect(col, p);\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 3.0, TIME);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstfzM.jpg", "access": "api", "license": "cc0-1.0", "functions": [[621, 621, 643, 643, 789], [1084, 1170, 1206, 1206, 1300], [1302, 1362, 1390, 1456, 1532], [1534, 1620, 1657, 1657, 1764], [1766, 1879, 1906, 1906, 1958], [1960, 1960, 1979, 1979, 2030], [2032, 2032, 2059, 2059, 2087], [2089, 2089, 2108, 2108, 2170], [2172, 2203, 2224, 2224, 2276], [2278, 2308, 2327, 2327, 2388], [2390, 2390, 2410, 2410, 2471], [2473, 2473, 2505, 2505, 2562], [2564, 2564, 2619, 2619, 3103], [3105, 3105, 3137, 3137, 4025], [4027, 4027, 4082, 4082, 4353]]}
{"id": "7scfR7", "name": "YCZ*HPG 2022 student competition", "author": "yuchengzhong", "description": "https://www.highperformancegraphics.org/2022/student-competition/\nThis shader takes 6 seconds to compile on my computer, please wait or it will crash.\nFirst place winner of 2022, thank HPG and everyone very much (*^ ‿ ⁢*)♡\n@ycz\nversion2", "tags": ["pathtracing", "hpgconf"], "likes": 21, "viewed": 1125, "published": 3, "date": "1656262305", "time_retrieved": "2024-07-30T16:42:56.274032", "image_code": "//YCZ:\n//Version2 - 2022.06.27(Tokyo time)\n\n//*************About Setting******************//\n//No need additional setting. Time axis is as same as the offical one\n\n//*************About Exposure******************//\n//Exposure is under Image\nconst float exposure = 2.0;\n\n//*************About Time******************//\n//If time shift is needed for measurement, plz replace all iTime variable with desired time value(included in Buffer A and Image)\n\n//*************About Measurement******************//\n//SSIM data example(under exposure of 2):\n//Frame0(t = 0.0) ssim 0.961\n//Frame1(t = 1.0) ssim 0.963\n//Frame2(t = 5.0) ssim 0.946\n\n//(idk how my render will be measured with gt.\n//And this Shader will take around 6 seconds to compile (gtx 2070, cpu i7 11xxxx)\n//In order to avoid problems such as graphics card model browser model conflict or sth.\n//if the value is significantly lower than this value means that this shader is not compiled correctly, \n//please change the browser, \n//thank you very much ^_^\n\nvec4 GetOneFace2(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(uv.x,1.0 - uv.y)-1.0,-1.0f).xzy);\n}\nvec4 GetOneFace3(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(uv.x,uv.y)-1.0,1.0f).xzy);\n}\nvec4 GetOneFace4(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(1.0-uv.x,1.0-uv.y)-1.0,-1.0f));\n}\nvec4 GetOneFace5(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(uv.x,1.0-uv.y)-1.0,1.0f));\n}\nHidden GetHidden(vec2 FragCoord)\n{\n    Hidden R;\n    vec2 LocalUV = FragCoord / 1024.0;\n    R.H_0 = GetOneFace2(LocalUV);\n    R.H_1 = GetOneFace2(LocalUV + vec2(0.5,0.0));\n    R.H_2 = GetOneFace2(LocalUV + vec2(0.0,0.5));\n    R.H_3 = GetOneFace2(LocalUV + vec2(0.5,0.5));\n    R.H_4 = GetOneFace3(LocalUV);\n    R.H_5 = GetOneFace3(LocalUV + vec2(0.5,0.0));\n    R.H_6 = GetOneFace3(LocalUV + vec2(0.0,0.5));\n    R.H_7 = GetOneFace3(LocalUV + vec2(0.5,0.5));\n    return R;\n}\n\n#define FULL_SCENE\n#define NUM_SAMPLES 1\n\n\n#define INFINITY 9999999.0 // sorry, webgl doesn't allow to use proper float infinity :(\n#define PI 3.141592653589\n\n#ifdef FULL_SCENE\n#define NUM_BOUNCES 8\n#else\n#define NUM_BOUNCES 2\n#endif\n\n#define MAT_LEFT        0\n#define MAT_RIGHT       1\n#define MAT_CEILING     2\n#define MAT_FLOOR       3\n#define MAT_BACK        4\n#define MAT_H           5\n#define MAT_P           6\n#define MAT_G           7\n#define MAT_2           8\n#define MAT_LIGHT0      9\n#define MAT_LIGHT1      10\n#define MAT_LIGHT2      11\n#define MAT_LIGHT3      12\n#define MAT_LIGHT4      13\n#define MAT_LIGHT5      14\n#define MAT_LIGHT6      15\n#define MAT_LIGHT7      16\n#define MAT_LIGHT8      17\n\n#define USE_Bake\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\nstruct MaterialSample\n{\n\tvec3 color;\n\tfloat roughness;\n\tbool is_light;\n};\n\nint seed;\nint flat_idx;\n\nconst float cube_light_size = 0.08;\nconst vec4 cube_light_pos[4] = vec4[4](\n\t\tvec4(  -0.9, -1.0 + cube_light_size * 0.495,  0.6, 0.4),\n\t\tvec4(  0.3, -1.0 + cube_light_size * 0.495,  0.2, 0.8),\n\t\tvec4(  1.0 - 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -1.0 + 5.0 * cube_light_size, 0.0),\n\t\tvec4(  -1.0 + 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -0.6, 0.0)\n\t\t);\n\nconst vec3 light_color[4] = vec3[4](\n\t\tvec3(5),\n\t\tvec3(5),\n\t\tvec3(80.0, 50, 30),\n\t\tvec3(30, 30, 80.0)\n\t\t);\n\n\n// H\nconst vec4 coordinates_H[3] = vec4[3](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.427, 0.000, 0.627, 0.750),\nvec4(0.116, 0.310, 0.516, 0.450));\n// P\nconst vec4 coordinates_P[4] = vec4[4](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.400, 0.360, 0.540, 0.675),\nvec4(0.044, 0.288, 0.471, 0.428),\nvec4(0.000, 0.610, 0.471, 0.750));\n// G\nconst vec4 coordinates_G[6] = vec4[6](\nvec4(0.000, 0.060, 0.200, 0.670),\nvec4(0.425, 0.060, 0.625, 0.265),\nvec4(0.425, 0.520, 0.625, 0.670),\nvec4(0.100, 0.000, 0.625, 0.140),\nvec4(0.315, 0.265, 0.625, 0.405),\nvec4(0.077, 0.610, 0.550, 0.750));\n// 2\nconst vec4 coordinates_2[5] = vec4[5](\nvec4(0.000, 0.000, 0.140, 0.365) * 0.5,\nvec4(0.474, 0.365, 0.614, 0.680) * 0.5,\nvec4(0.044, 0.000, 0.614, 0.140) * 0.5,\nvec4(0.044, 0.288, 0.544, 0.428) * 0.5,\nvec4(0.044, 0.610, 0.544, 0.750) * 0.5);\n\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\nvoid\nencrypt_tea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\nvec2\nget_random()\n{\n  \tuvec2 arg = uvec2(flat_idx, seed++);\n  \tencrypt_tea(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\nmat4\nlook_at(vec3 eye, vec3 center, vec3 up)\n{\n\tmat4 ret;\n\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, normalize(up)));\n\tvec3 u = cross(s, f);\n\n\tret[0][0] = s[0];\n\tret[1][0] = s[1];\n\tret[2][0] = s[2];\n\n\tret[0][1] = u[0];\n\tret[1][1] = u[1];\n\tret[2][1] = u[2];\n\n\tret[0][2] = -f[0];\n\tret[1][2] = -f[1];\n\tret[2][2] = -f[2];\n\n\tret[0][3] = ret[1][3] = ret[2][3] = 0.0;\n\n\tret[3][0] = -dot(s, eye);\n\tret[3][1] = -dot(u, eye);\n\tret[3][2] =  dot(f, eye);\n\n\tret[3][3] = 1.0;\n\treturn ret;\n}\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) / denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\nfloat intersect_box(Ray ray, out vec3 normal, vec3 position_min, vec3 position_max)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(position_min, position_max), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\n\t\tvec3 center = (position_min + position_max) * 0.5;\n\n\t\tnormal = p - center;\n\n\t\tvec3 an = abs(normal) / (position_max - position_min);\n\n\t\tif(an.x > an.y && an.x > an.z) {\n\t\t\tnormal = vec3(normal.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t}\n\t\tif(an.y > an.x && an.y > an.z) {\n\t\t\tnormal = vec3(0, normal.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\tif(an.z > an.x && an.z > an.y) {\n\t\t\tnormal = vec3(0, 0, normal.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\nfloat intersect_simple(Ray ray, inout vec3 p, inout vec3 normal, inout vec3 color)\n{\n\tfloat t_min = INFINITY;\n\n\tint material = -1;\n    vec2 CurrentHitHiddenUV = vec2(-1.0,0.0);\n\tfor(int i = 0; i < coordinates_H.length(); i++) \n    {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.35);\n\t\tray_tmp.origin -= vec3(-0.9, -1, 0.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_H[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_H[i].zw - coordinates_H[i].xy, 0.15);\n        //intersect_box(Ray ray, out vec3 normal, vec3 position_min, vec3 position_max)\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_H;\n            CurrentHitHiddenUV = PositionToLightmap_H(ray_tmp, t, normal_tmp, i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_P.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.75);\n\t\tray_tmp.origin -= vec3(-0.28, -1, 0.2);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_P[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_P[i].zw - coordinates_P[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_P;\n            CurrentHitHiddenUV = PositionToLightmap_P(ray_tmp, t, normal_tmp, i) + vec2(256.0,0.0);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_G.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.4);\n\t\tray_tmp.origin -= vec3(0.35, -1, -0.20);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_G[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_G[i].zw - coordinates_G[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_G;\n            CurrentHitHiddenUV = PositionToLightmap_G(ray_tmp, t, normal_tmp, i) + vec2(0.0,128.0);\n\t\t}\n\t}\n\n#ifdef FULL_SCENE\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.1, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n            CurrentHitHiddenUV = PositionToLightmap_21(ray_tmp, t, normal_tmp, i) + vec2(256.0,128.0);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.45, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n            CurrentHitHiddenUV = PositionToLightmap_22(ray_tmp, t, normal_tmp, i) + vec2(384.0,128.0);\n\t\t}\n\t}\n#endif\n\n\n\t// cube light sources\n\tfor(int i = 0; i < cube_light_pos.length(); i++) {\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\t//mat4 r = rotate_y(scene_time);\n\t\tmat4 r = rotate_y(-cube_light_pos[i].w);\n\t\tray_tmp.origin -= cube_light_pos[i].xyz;\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp,\n\t\t\t\tvec3(-cube_light_size * 0.5),\n\t\t\t\tvec3(cube_light_size * 0.5));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_LIGHT0 + i;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n            CurrentHitHiddenUV.x = 1.0;\n\t\t}\n\t}\n\t// left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tmaterial = MAT_LEFT;\n                CurrentHitHiddenUV = PositionToLightmap_L(p) + vec2(0.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\t// right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tmaterial = MAT_RIGHT;\n                CurrentHitHiddenUV = PositionToLightmap_R(p) + vec2(64.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\t// floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\t\t\t\tmaterial = MAT_FLOOR;\n                CurrentHitHiddenUV = PositionToLightmap_D(p) + vec2(0.0,384.0);\n\t\t\t}\n\t\t}\n\t}\n\t// ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_CEILING;\n\n\t\t\t\tt_min = t;\n                CurrentHitHiddenUV = PositionToLightmap_U(p) + vec2(128.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\t// back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_BACK;\n\n\t\t\t\tt_min = t;\n                CurrentHitHiddenUV = PositionToLightmap_B(p) + vec2(256.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\tnormal = normalize(normal);\n    if(CurrentHitHiddenUV.x > 0.0)\n    {\n        vec3 albedo;\n        switch(material) \n        {\n\tcase MAT_LEFT   : albedo = vec3(0.9, 0.1, 0.1); break;\n\tcase MAT_RIGHT  : albedo = vec3(0.1, 0.9, 0.1); break;\n\tcase MAT_CEILING: albedo = vec3(0.7, 0.7, 0.7); break;\n\tcase MAT_FLOOR  : albedo = vec3(0.7, 0.7, 0.7); break;\n\tcase MAT_BACK   : albedo = vec3(0.7, 0.7, 0.7); break;\n\tcase MAT_H      : albedo = vec3(1.0, 0.0, 0.0); break;\n\tcase MAT_P      : albedo = vec3(0.0, 0.7, 0.7); break;\n\tcase MAT_G      : albedo = vec3(0.1, 0.1, 0.7); break;\n\tcase MAT_2      : albedo = vec3(0.8, 0.8, 0.8); break;\n\tdefault         : albedo = light_color[material - MAT_LIGHT0];color = albedo;return t_min; break;\n\t    }\n        Hidden hidden = GetHidden(CurrentHitHiddenUV);\n        if(material == MAT_LEFT || material == MAT_RIGHT || \n        material == MAT_CEILING || material == MAT_BACK || material == MAT_2)\n        {\n            color = Lightmap_Render_LRBU22(ray.dir, hidden);\n            color = color + vec3(1.0,1.0,1.0);\n            color = exp(color * 3.3994);\n            color = color - vec3(1.0,1.0,1.0);\n            color = color / 10.0;\n            color = color * (albedo + vec3(0.5,0.5,0.5));\n        }\n        else if(material == MAT_FLOOR)\n        {\n            color = Lightmap_Render_Floor(ray.dir, hidden);\n            color = color + vec3(1.0,1.0,1.0);\n            color = exp(color * 3.71775);\n            color = color - vec3(1.0,1.0,1.0);\n            color = color / 10.0;\n            color = color * (albedo + vec3(0.5,0.5,0.5));\n        }\n        else\n        {\n            color = Lightmap_Render_HPG(ray.dir, hidden);\n            color = color + vec3(1.0,1.0,1.0);\n            color = exp(color * 4.636095);\n            color = color - vec3(1.0,1.0,1.0);\n            color = color / 10.0;\n            color = color * (albedo + vec3(0.5,0.5,0.5));\n        }\n    }\n\treturn t_min;\n}\n\nfloat intersect_msaa(Ray ray, inout vec3 p, inout vec3 normal, inout vec3 color, inout int faceid, inout vec3 neuralmark, inout vec3 albedo)\n{\n\tfloat t_min = INFINITY;\n\n\tint material = -1;\n    int faceindex = -1;\n    vec2 CurrentHitHiddenUV = vec2(-1.0,0.0);\n\tfor(int i = 0; i < coordinates_H.length(); i++) \n    {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.35);\n\t\tray_tmp.origin -= vec3(-0.9, -1, 0.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_H[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_H[i].zw - coordinates_H[i].xy, 0.15);\n        //intersect_box(Ray ray, out vec3 normal, vec3 position_min, vec3 position_max)\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_H;\n            CurrentHitHiddenUV = PositionToLightmap_H(ray_tmp, t, normal_tmp, i);\n            faceindex = 0 + i * 6 + NormalToIndex(normal_tmp);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_P.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.75);\n\t\tray_tmp.origin -= vec3(-0.28, -1, 0.2);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_P[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_P[i].zw - coordinates_P[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_P;\n            CurrentHitHiddenUV = PositionToLightmap_P(ray_tmp, t, normal_tmp, i) + vec2(256.0,0.0);\n            faceindex = 3 * 6 + i * 6 + NormalToIndex(normal_tmp);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_G.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.4);\n\t\tray_tmp.origin -= vec3(0.35, -1, -0.20);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_G[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_G[i].zw - coordinates_G[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_G;\n            CurrentHitHiddenUV = PositionToLightmap_G(ray_tmp, t, normal_tmp, i) + vec2(0.0,128.0);\n            faceindex = 7 * 6 + i * 6 + NormalToIndex(normal_tmp);\n\t\t}\n\t}\n\n#ifdef FULL_SCENE\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.1, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n            CurrentHitHiddenUV = PositionToLightmap_21(ray_tmp, t, normal_tmp, i) + vec2(256.0,128.0);\n            faceindex = 13 * 6 + i * 6 + NormalToIndex(normal_tmp);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.45, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n            CurrentHitHiddenUV = PositionToLightmap_22(ray_tmp, t, normal_tmp, i) + vec2(384.0,128.0);\n            faceindex = 18 * 6 + i * 6 + NormalToIndex(normal_tmp);\n\t\t}\n\t}\n#endif\n\n\n\t// cube light sources\n\tfor(int i = 0; i < cube_light_pos.length(); i++) {\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\t//mat4 r = rotate_y(scene_time);\n\t\tmat4 r = rotate_y(-cube_light_pos[i].w);\n\t\tray_tmp.origin -= cube_light_pos[i].xyz;\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp,\n\t\t\t\tvec3(-cube_light_size * 0.5),\n\t\t\t\tvec3(cube_light_size * 0.5));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_LIGHT0 + i;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n            faceindex = 23 * 6 + i;\n            CurrentHitHiddenUV.x = 1.0;\n\t\t}\n\t}\n\t// left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n                faceindex = 23 * 6 + 4 + 0;\n\n\t\t\t\tmaterial = MAT_LEFT;\n                CurrentHitHiddenUV = PositionToLightmap_L(p) + vec2(0.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\t// right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n                faceindex = 23 * 6 + 4 + 1;\n\n\t\t\t\tmaterial = MAT_RIGHT;\n                CurrentHitHiddenUV = PositionToLightmap_R(p) + vec2(64.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\t// floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n                faceindex = 23 * 6 + 4 + 2;\n\t\t\t\tmaterial = MAT_FLOOR;\n                CurrentHitHiddenUV = PositionToLightmap_D(p) + vec2(0.0,384.0);\n\t\t\t}\n\t\t}\n\t}\n\t// ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_CEILING;\n\n\t\t\t\tt_min = t;\n                faceindex = 23 * 6 + 4 + 3;\n                CurrentHitHiddenUV = PositionToLightmap_U(p) + vec2(128.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\t// back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_BACK;\n\n\t\t\t\tt_min = t;\n                faceindex = 23 * 6 + 4 + 4;\n                CurrentHitHiddenUV = PositionToLightmap_B(p) + vec2(256.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\t//normal = normalize(normal);\n    albedo = vec3(0.0);\n    if(CurrentHitHiddenUV.x > 0.0)\n    {\n        switch(material) \n        {\n\tcase MAT_LEFT   : albedo = vec3(0.9, 0.1, 0.1); break;\n\tcase MAT_RIGHT  : albedo = vec3(0.1, 0.9, 0.1); break;\n\tcase MAT_CEILING: albedo = vec3(0.7, 0.7, 0.7); break;\n\tcase MAT_FLOOR  : albedo = vec3(0.7, 0.7, 0.7); break;\n\tcase MAT_BACK   : albedo = vec3(0.7, 0.7, 0.7); break;\n\tcase MAT_H      : albedo = vec3(1.0, 0.0, 0.0); break;\n\tcase MAT_P      : albedo = vec3(0.0, 0.7, 0.7); break;\n\tcase MAT_G      : albedo = vec3(0.1, 0.1, 0.7); break;\n\tcase MAT_2      : albedo = vec3(0.8, 0.8, 0.8); break;\n\tdefault         : albedo = light_color[material - MAT_LIGHT0];color = albedo;return t_min; break;\n\t    }\n        if(material == MAT_LEFT || material == MAT_RIGHT || \n        material == MAT_CEILING || material == MAT_BACK || material == MAT_2)\n        {\n            neuralmark = vec3(CurrentHitHiddenUV,0.0);\n        }\n        else if(material == MAT_FLOOR)\n        {\n            neuralmark = vec3(CurrentHitHiddenUV,1.0);\n        }\n        else if(material == MAT_H||material == MAT_P || material == MAT_G)\n        {\n            neuralmark = vec3(CurrentHitHiddenUV,2.0);\n        }\n        else\n        {\n            neuralmark = vec3(0.0,0.0,-1.0);\n        }\n    }\n    else\n    {\n        neuralmark = vec3(0.0,0.0,-1.0);\n    }\n    faceid = faceindex;\n\treturn t_min;\n}\n\nconst float aaclamp = 1.0;\nvec3 clampcolor(vec3 c)\n{\n    return c;//clamp(c,0.0,aaclamp);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tseed = iFrame * NUM_SAMPLES;\n\tflat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n    vec2 texelsize = 1.0/vec2(iResolution);\n\tvec2 p = fragCoord.xy / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n\n\t//vec3 cam_center = vec3(0, 0, 3.0);\n\tvec3 cam_center = vec3(sin(iTime) * 0.25, sin(iTime * 0.7345) * 0.4 + 0.2, 6.0);\n\tvec3 cam_target = vec3(0, -0.1, 0);\n\n\tmat4 cam = transpose(look_at(cam_center, cam_target, vec3(0, 1, 0)));\n\n\tvec3 s = vec3(0);\n    \n    if(iFrame == 0)\n    {\n    \tRay ray;\n\t\tray.origin = cam_center;\n\t\tvec2 r = get_random();\n\t\tvec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -2.5));\n\t\tray.dir = vec3(cam * vec4(ray_dir, 0.0));\n        vec3 c;\n        vec3 normal;\n        vec3 position;\n        intersect_simple(ray, position, normal, c);\n\t\ts = c;\n    }\n    else\n    {\n        vec4 centerresult = texelFetch(iChannel1,ivec2(fragCoord),0);\n        float eigen = centerresult.w;\n        //float depth = fract(eigen)*10.0;\n        int faceindex = int(floor(eigen));\n        vec2 msaa_pattern[4] = vec2[4](\n        vec2(-0.3162277660168379,0.9486832980505137),vec2(0.9486832980505137,0.3162277660168379),\n        vec2(0.3162277660168379,-0.9486832980505137),vec2(-0.9486832980505137,-0.3162277660168379));\n        int cnt = 0;\n        int sourcecnt = 0;\n        int addcnt = 0;\n        for(int i=0;i<4;i++)\n        {\n            vec2 r = msaa_pattern[i]*0.4995;\n            Ray ray;\n            ray.origin = cam_center;\n            vec3 ray_dir = normalize(vec3(p + r*texelsize, -2.5));\n            ray.dir = vec3(cam * vec4(ray_dir, 0.0));\n            vec3 c;\n            vec3 normal;\n            vec3 position;\n            int cfaceid;\n            vec3 neuralinfo;\n            vec3 albedo;\n            float cdepth = intersect_msaa(ray, position, normal, c, cfaceid, neuralinfo, albedo);\n            if(cfaceid != faceindex - 1)// && cdepth <= depth)\n            {\n                vec3 color;//me write this like sorry QAQ\n                {\n                    //s += vec3(1.0,0.0,0.0);\n                    //break;\n                    if(neuralinfo.z < -0.5)\n                    {\n                        color = albedo;\n                        s += clampcolor(color);\n                        cnt++;\n                        addcnt++;\n                    }\n                    else if(neuralinfo.z < 0.5)\n                    {\n                        Hidden hidden = GetHidden(neuralinfo.xy);\n                        color = Lightmap_Render_LRBU22(ray.dir, hidden);\n                        color = color + vec3(1.0,1.0,1.0);\n                        color = exp(color * 3.3994);\n                        color = color - vec3(1.0,1.0,1.0);\n                        color = color / 10.0;\n                        color = color * (albedo + vec3(0.5,0.5,0.5));\n                        s += clampcolor(color);\n                        cnt++;\n                        addcnt++;\n                        break;\n                    }\n                    else if(neuralinfo.z < 1.5)\n                    {\n                        Hidden hidden = GetHidden(neuralinfo.xy);\n                        color = Lightmap_Render_Floor(ray.dir, hidden);\n                        color = color + vec3(1.0,1.0,1.0);\n                        color = exp(color * 3.71775);\n                        color = color - vec3(1.0,1.0,1.0);\n                        color = color / 10.0;\n                        color = color * (albedo + vec3(0.5,0.5,0.5));\n                        s += clampcolor(color);\n                        cnt++;\n                        addcnt++;\n                        break;\n                    }\n                    else\n                    {\n                        Hidden hidden = GetHidden(neuralinfo.xy);\n                        color = Lightmap_Render_HPG(ray.dir, hidden);\n                        color = color + vec3(1.0,1.0,1.0);\n                        color = exp(color * 4.636095);\n                        color = color - vec3(1.0,1.0,1.0);\n                        color = color / 10.0;\n                        color = color * (albedo + vec3(0.5,0.5,0.5));\n                        s += clampcolor(color);\n                        cnt++;\n                        addcnt++;\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                s += clampcolor(centerresult.xyz);\n                cnt++;\n                sourcecnt++;\n            }\n        }\n        s += float(4- sourcecnt - addcnt) * centerresult.xyz;\n        s /= 4.0;\n    }\n\tfragColor = vec4(s,1.0);\n    \n    fragColor = pow(exposure * fragColor, vec4(1.0 / 2.2));\n    \n    \n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//YCZ:\n//Version2 - 2022.06.27(Tokyo time)\n\n//*************About Setting******************//\n//No need additional setting. Time axis is as same as the offical one\n\n//*************About Exposure******************//\n//Exposure is under Image\n\n//*************About Time******************//\n//If time shift is needed for measurement, plz replace all iTime variable with desired time value(included in Buffer A and Image)\n\n//*************About Measurement******************//\n//SSIM data example(under exposure of 2):\n//Frame0(t = 0.0) ssim 0.961\n//Frame1(t = 1.0) ssim 0.963\n//Frame2(t = 5.0) ssim 0.946\n\n//(idk how my render will be measured with gt.\n//And this Shader will take around 6 seconds to compile (gtx 2070, cpu i7 11xxxx)\n//In order to avoid problems such as graphics card model browser model conflict or sth.\n//if the value is significantly lower than this value means that this shader is not compiled correctly, \n//please change the browser, \n//thank you very much ^_^\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\nstruct Point\n{\n    vec4 Position;\n    vec4 Normal;\n    int FaceIndex;\n    int ObjectIndex;\n};\n\nstruct Hidden\n{\n    vec4 H_0;\n    vec4 H_1;\n    vec4 H_2;\n    vec4 H_3;\n    vec4 H_4;\n    vec4 H_5;\n    vec4 H_6;\n    vec4 H_7;\n};\n\nint CoordToIndex(vec2 fragCoord)\n{\n    int xx = fragCoord.x >= 512.0 ? 1 : 0;\n    int yy = fragCoord.y >= 512.0 ? 2 : 0;\n    return yy + xx;\n}\nvec2 CoordToLocalCoord(vec2 fragCoord)\n{\n    float modx = fragCoord.x >= 512.0 ? fragCoord.x - 512.0 : fragCoord.x;\n    float mody = fragCoord.y >= 512.0 ? fragCoord.y - 512.0 : fragCoord.y; \n    return vec2(modx, mody);\n}\n\nint NormalToIndex(vec3 Normal)\n{\n    bool kk = any(greaterThan(Normal,vec3(0.0)));\n    int eigen = Normal.x != 0.0 ? 0 : (Normal.y != 0.0 ? 2 : 4);\n    return int(kk) + eigen;\n}\n\nmat4 rotate_y(float a)\n{\n\tmat4 ret = mat4(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}\n\n//////////////////////Mapping////////////////////////////\nPoint LightmapToPosition_H(vec2 UV)\n{\n    ivec2 PixelCoord = ivec2(UV);\n    mat4 RotationMatrix = rotate_y(-0.350000);\n    mat4 TransposeRotationMatrix = transpose(RotationMatrix);\n//UV-Min:int2(0,0) | UV-Max:int2(57,22) | Real-Min:float3(0.116000,0.450000,0.000000) | Real-Max:float3(0.516000,0.450000,0.150000) | FaceIndex:3 | ObjectIndex:2 | bFlip:0\n    if((PixelCoord.x >= 0 && PixelCoord.y >= 0 && PixelCoord.x < 57 && PixelCoord.y < 22))//Id:15\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 0))/vec2(56, 21);\n        vec3 ObjectSpace_Position = vec3(mix(0.116000, 0.516000, AlphaCoord.x), 0.450000, mix(0.000000, 0.150000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 2);\n    }\n//UV-Min:int2(0,22) | UV-Max:int2(22,128) | Real-Min:float3(0.427000,0.000000,0.000000) | Real-Max:float3(0.427000,0.750000,0.150000) | FaceIndex:0 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 22 && PixelCoord.x < 22 && PixelCoord.y < 128))//Id:6\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 22))/vec2(21, 105);\n        vec3 ObjectSpace_Position = vec3(0.427000, mix(0.000000, 0.750000, AlphaCoord.y), mix(0.000000, 0.150000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 1);\n    }\n//UV-Min:int2(22,22) | UV-Max:int2(42,44) | Real-Min:float3(0.116000,0.310000,0.000000) | Real-Max:float3(0.116000,0.450000,0.150000) | FaceIndex:0 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 22 && PixelCoord.y >= 22 && PixelCoord.x < 42 && PixelCoord.y < 44))//Id:12\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(22, 22))/vec2(19, 21);\n        vec3 ObjectSpace_Position = vec3(0.116000, mix(0.310000, 0.450000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 2);\n    }\n//UV-Min:int2(22,44) | UV-Max:int2(128,66) | Real-Min:float3(0.200000,0.000000,0.000000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:1 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 22 && PixelCoord.y >= 44 && PixelCoord.x < 128 && PixelCoord.y < 66))//Id:1\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(22, 44))/vec2(105, 21);\n        vec3 ObjectSpace_Position = vec3(0.200000, mix(0.000000, 0.750000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 0);\n    }\n//UV-Min:int2(22,66) | UV-Max:int2(128,95) | Real-Min:float3(0.427000,0.000000,0.000000) | Real-Max:float3(0.627000,0.750000,0.000000) | FaceIndex:4 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 22 && PixelCoord.y >= 66 && PixelCoord.x < 128 && PixelCoord.y < 95))//Id:10\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(22, 66))/vec2(105, 28);\n        vec3 ObjectSpace_Position = vec3(mix(0.427000, 0.627000, AlphaCoord.y), mix(0.000000, 0.750000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 1);\n    }\n//UV-Min:int2(22,95) | UV-Max:int2(128,124) | Real-Min:float3(0.427000,0.000000,0.150000) | Real-Max:float3(0.627000,0.750000,0.150000) | FaceIndex:5 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 22 && PixelCoord.y >= 95 && PixelCoord.x < 128 && PixelCoord.y < 124))//Id:11\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(22, 95))/vec2(105, 28);\n        vec3 ObjectSpace_Position = vec3(mix(0.427000, 0.627000, AlphaCoord.y), mix(0.000000, 0.750000, AlphaCoord.x),0.150000);//2\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 1);\n    }\n//UV-Min:int2(42,22) | UV-Max:int2(99,42) | Real-Min:float3(0.116000,0.310000,0.150000) | Real-Max:float3(0.516000,0.450000,0.150000) | FaceIndex:5 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 42 && PixelCoord.y >= 22 && PixelCoord.x < 99 && PixelCoord.y < 42))//Id:17\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(42, 22))/vec2(56, 19);\n        vec3 ObjectSpace_Position = vec3(mix(0.116000, 0.516000, AlphaCoord.x), mix(0.310000, 0.450000, AlphaCoord.y),0.150000);//2\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 2);\n    }\n//UV-Min:int2(99,0) | UV-Max:int2(205,29) | Real-Min:float3(0.000000,0.000000,0.150000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:5 | ObjectIndex:0 | bFlip:1\n    else if((PixelCoord.x >= 99 && PixelCoord.y >= 0 && PixelCoord.x < 205 && PixelCoord.y < 29))//Id:5\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(99, 0))/vec2(105, 28);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.y), mix(0.000000, 0.750000, AlphaCoord.x),0.150000);//2\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 0);\n    }\n//UV-Min:int2(57,0) | UV-Max:int2(86,22) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.200000,0.000000,0.150000) | FaceIndex:2 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 57 && PixelCoord.y >= 0 && PixelCoord.x < 86 && PixelCoord.y < 22))//Id:2\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(57, 0))/vec2(28, 21);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.x), 0.000000, mix(0.000000, 0.150000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 0);\n    }\n//UV-Min:int2(205,0) | UV-Max:int2(234,106) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.200000,0.750000,0.000000) | FaceIndex:4 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 205 && PixelCoord.y >= 0 && PixelCoord.x < 234 && PixelCoord.y < 106))//Id:4\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(205, 0))/vec2(28, 105);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.x), mix(0.000000, 0.750000, AlphaCoord.y),0.000000);//2\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 0);\n    }\n//UV-Min:int2(128,29) | UV-Max:int2(150,86) | Real-Min:float3(0.116000,0.310000,0.000000) | Real-Max:float3(0.516000,0.310000,0.150000) | FaceIndex:2 | ObjectIndex:2 | bFlip:1\n    else if((PixelCoord.x >= 128 && PixelCoord.y >= 29 && PixelCoord.x < 150 && PixelCoord.y < 86))//Id:14\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(128, 29))/vec2(21, 56);\n        vec3 ObjectSpace_Position = vec3(mix(0.116000, 0.516000, AlphaCoord.y), 0.310000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 2);\n    }\n//UV-Min:int2(128,86) | UV-Max:int2(150,115) | Real-Min:float3(0.427000,0.750000,0.000000) | Real-Max:float3(0.627000,0.750000,0.150000) | FaceIndex:3 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 128 && PixelCoord.y >= 86 && PixelCoord.x < 150 && PixelCoord.y < 115))//Id:9\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(128, 86))/vec2(21, 28);\n        vec3 ObjectSpace_Position = vec3(mix(0.427000, 0.627000, AlphaCoord.y), 0.750000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 1);\n    }\n//UV-Min:int2(150,106) | UV-Max:int2(256,128) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.000000,0.750000,0.150000) | FaceIndex:0 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 150 && PixelCoord.y >= 106 && PixelCoord.x < 256 && PixelCoord.y < 128))//Id:0\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(150, 106))/vec2(105, 21);\n        vec3 ObjectSpace_Position = vec3(0.000000, mix(0.000000, 0.750000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 0);\n    }\n//UV-Min:int2(150,29) | UV-Max:int2(179,51) | Real-Min:float3(0.427000,0.000000,0.000000) | Real-Max:float3(0.627000,0.000000,0.150000) | FaceIndex:2 | ObjectIndex:1 | bFlip:0\n    else if((PixelCoord.x >= 150 && PixelCoord.y >= 29 && PixelCoord.x < 179 && PixelCoord.y < 51))//Id:8\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(150, 29))/vec2(28, 21);\n        vec3 ObjectSpace_Position = vec3(mix(0.427000, 0.627000, AlphaCoord.x), 0.000000, mix(0.000000, 0.150000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 1);\n    }\n//UV-Min:int2(150,51) | UV-Max:int2(170,73) | Real-Min:float3(0.516000,0.310000,0.000000) | Real-Max:float3(0.516000,0.450000,0.150000) | FaceIndex:1 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 150 && PixelCoord.y >= 51 && PixelCoord.x < 170 && PixelCoord.y < 73))//Id:13\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(150, 51))/vec2(19, 21);\n        vec3 ObjectSpace_Position = vec3(0.516000, mix(0.310000, 0.450000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 2);\n    }\n//UV-Min:int2(234,0) | UV-Max:int2(256,106) | Real-Min:float3(0.627000,0.000000,0.000000) | Real-Max:float3(0.627000,0.750000,0.150000) | FaceIndex:1 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 234 && PixelCoord.y >= 0 && PixelCoord.x < 256 && PixelCoord.y < 106))//Id:7\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(234, 0))/vec2(21, 105);\n        vec3 ObjectSpace_Position = vec3(0.627000, mix(0.000000, 0.750000, AlphaCoord.y), mix(0.000000, 0.150000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 1);\n    }\n//UV-Min:int2(179,29) | UV-Max:int2(199,86) | Real-Min:float3(0.116000,0.310000,0.000000) | Real-Max:float3(0.516000,0.450000,0.000000) | FaceIndex:4 | ObjectIndex:2 | bFlip:1\n    else if((PixelCoord.x >= 179 && PixelCoord.y >= 29 && PixelCoord.x < 199 && PixelCoord.y < 86))//Id:16\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(179, 29))/vec2(19, 56);\n        vec3 ObjectSpace_Position = vec3(mix(0.116000, 0.516000, AlphaCoord.y), mix(0.310000, 0.450000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 2);\n    }\n//UV-Min:int2(150,73) | UV-Max:int2(172,102) | Real-Min:float3(0.000000,0.750000,0.000000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:3 | ObjectIndex:0 | bFlip:1\n    else if((PixelCoord.x >= 150 && PixelCoord.y >= 73 && PixelCoord.x < 172 && PixelCoord.y < 102))//Id:3\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(150, 73))/vec2(21, 28);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.y), 0.750000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(-0.900000, -1.000000, 0.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 0);\n    }\n    else\n    {\n        return Point(vec4(0.0,0.0,0.0,-1.0), vec4(0.0,0.0,0.0,-1.0),-1,-1);\n    }\n}\n//####\n//####\nvec2 PositionToLightmap_H(Ray TempRay, float HitDistance, vec3 HitNormal, int CubeIndex)\n{\n    vec3 ObjectSpace_Position = TempRay.origin + TempRay.dir * HitDistance;\n    int FaceIndex = NormalToIndex(HitNormal);\n    int EigenIndex = FaceIndex + 6 * CubeIndex;\n//UV-Min:int2(0,0) | UV-Max:int2(57,22) | Real-Min:float3(0.116000,0.450000,0.000000) | Real-Max:float3(0.516000,0.450000,0.150000) | FaceIndex:3 | ObjectIndex:2 | bFlip:0\n    if(EigenIndex == 15)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.116000, 0.000000)) / vec2(0.400000, 0.150000);\n        return vec2(mix(0.500000, 56.500000, AlphaCoord.x), mix(0.500000, 21.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(0,22) | UV-Max:int2(22,128) | Real-Min:float3(0.427000,0.000000,0.000000) | Real-Max:float3(0.427000,0.750000,0.150000) | FaceIndex:0 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 6)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.750000, 0.150000);\n        return vec2(mix(0.500000, 21.500000, AlphaCoord.y), mix(22.500000, 127.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(22,22) | UV-Max:int2(42,44) | Real-Min:float3(0.116000,0.310000,0.000000) | Real-Max:float3(0.116000,0.450000,0.150000) | FaceIndex:0 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 12)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.310000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(22.500000, 41.500000, AlphaCoord.x), mix(22.500000, 43.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(22,44) | UV-Max:int2(128,66) | Real-Min:float3(0.200000,0.000000,0.000000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:1 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 1)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.750000, 0.150000);\n        return vec2(mix(22.500000, 127.500000, AlphaCoord.x), mix(44.500000, 65.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(22,66) | UV-Max:int2(128,95) | Real-Min:float3(0.427000,0.000000,0.000000) | Real-Max:float3(0.627000,0.750000,0.000000) | FaceIndex:4 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 10)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.427000, 0.000000)) / vec2(0.200000, 0.750000);\n        return vec2(mix(22.500000, 127.500000, AlphaCoord.y), mix(66.500000, 94.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(22,95) | UV-Max:int2(128,124) | Real-Min:float3(0.427000,0.000000,0.150000) | Real-Max:float3(0.627000,0.750000,0.150000) | FaceIndex:5 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 11)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.427000, 0.000000)) / vec2(0.200000, 0.750000);\n        return vec2(mix(22.500000, 127.500000, AlphaCoord.y), mix(95.500000, 123.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(42,22) | UV-Max:int2(99,42) | Real-Min:float3(0.116000,0.310000,0.150000) | Real-Max:float3(0.516000,0.450000,0.150000) | FaceIndex:5 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 17)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.116000, 0.310000)) / vec2(0.400000, 0.140000);\n        return vec2(mix(42.500000, 98.500000, AlphaCoord.x), mix(22.500000, 41.500000, AlphaCoord.y));//2N\n    }\n//UV-Min:int2(99,0) | UV-Max:int2(205,29) | Real-Min:float3(0.000000,0.000000,0.150000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:5 | ObjectIndex:0 | bFlip:1\n    else if(EigenIndex == 5)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.000000)) / vec2(0.200000, 0.750000);\n        return vec2(mix(99.500000, 204.500000, AlphaCoord.y), mix(0.500000, 28.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(57,0) | UV-Max:int2(86,22) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.200000,0.000000,0.150000) | FaceIndex:2 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 2)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(57.500000, 85.500000, AlphaCoord.x), mix(0.500000, 21.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(205,0) | UV-Max:int2(234,106) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.200000,0.750000,0.000000) | FaceIndex:4 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 4)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.000000)) / vec2(0.200000, 0.750000);\n        return vec2(mix(205.500000, 233.500000, AlphaCoord.x), mix(0.500000, 105.500000, AlphaCoord.y));//2N\n    }\n//UV-Min:int2(128,29) | UV-Max:int2(150,86) | Real-Min:float3(0.116000,0.310000,0.000000) | Real-Max:float3(0.516000,0.310000,0.150000) | FaceIndex:2 | ObjectIndex:2 | bFlip:1\n    else if(EigenIndex == 14)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.116000, 0.000000)) / vec2(0.400000, 0.150000);\n        return vec2(mix(128.500000, 149.500000, AlphaCoord.y), mix(29.500000, 85.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(128,86) | UV-Max:int2(150,115) | Real-Min:float3(0.427000,0.750000,0.000000) | Real-Max:float3(0.627000,0.750000,0.150000) | FaceIndex:3 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 9)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.427000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(128.500000, 149.500000, AlphaCoord.y), mix(86.500000, 114.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(150,106) | UV-Max:int2(256,128) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.000000,0.750000,0.150000) | FaceIndex:0 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 0)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.750000, 0.150000);\n        return vec2(mix(150.500000, 255.500000, AlphaCoord.x), mix(106.500000, 127.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(150,29) | UV-Max:int2(179,51) | Real-Min:float3(0.427000,0.000000,0.000000) | Real-Max:float3(0.627000,0.000000,0.150000) | FaceIndex:2 | ObjectIndex:1 | bFlip:0\n    else if(EigenIndex == 8)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.427000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(150.500000, 178.500000, AlphaCoord.x), mix(29.500000, 50.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(150,51) | UV-Max:int2(170,73) | Real-Min:float3(0.516000,0.310000,0.000000) | Real-Max:float3(0.516000,0.450000,0.150000) | FaceIndex:1 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 13)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.310000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(150.500000, 169.500000, AlphaCoord.x), mix(51.500000, 72.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(234,0) | UV-Max:int2(256,106) | Real-Min:float3(0.627000,0.000000,0.000000) | Real-Max:float3(0.627000,0.750000,0.150000) | FaceIndex:1 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 7)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.750000, 0.150000);\n        return vec2(mix(234.500000, 255.500000, AlphaCoord.y), mix(0.500000, 105.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(179,29) | UV-Max:int2(199,86) | Real-Min:float3(0.116000,0.310000,0.000000) | Real-Max:float3(0.516000,0.450000,0.000000) | FaceIndex:4 | ObjectIndex:2 | bFlip:1\n    else if(EigenIndex == 16)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.116000, 0.310000)) / vec2(0.400000, 0.140000);\n        return vec2(mix(179.500000, 198.500000, AlphaCoord.y), mix(29.500000, 85.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(150,73) | UV-Max:int2(172,102) | Real-Min:float3(0.000000,0.750000,0.000000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:3 | ObjectIndex:0 | bFlip:1\n    else if(EigenIndex == 3)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(150.500000, 171.500000, AlphaCoord.y), mix(73.500000, 101.500000, AlphaCoord.x));//1F\n    }\n    else\n    {\n        return vec2(0.0, 0.0);\n    }\n}\n///////////////\n//####\nPoint LightmapToPosition_P(vec2 UV)\n{\n    ivec2 PixelCoord = ivec2(UV);\n    mat4 RotationMatrix = rotate_y(0.750000);\n    mat4 TransposeRotationMatrix = transpose(RotationMatrix);\n//UV-Min:int2(0,0) | UV-Max:int2(20,61) | Real-Min:float3(0.044000,0.288000,0.000000) | Real-Max:float3(0.471000,0.428000,0.000000) | FaceIndex:4 | ObjectIndex:2 | bFlip:1\n    if((PixelCoord.x >= 0 && PixelCoord.y >= 0 && PixelCoord.x < 20 && PixelCoord.y < 61))//Id:16\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 0))/vec2(19, 60);\n        vec3 ObjectSpace_Position = vec3(mix(0.044000, 0.471000, AlphaCoord.y), mix(0.288000, 0.428000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 2);\n    }\n//UV-Min:int2(0,61) | UV-Max:int2(20,83) | Real-Min:float3(0.471000,0.610000,0.000000) | Real-Max:float3(0.471000,0.750000,0.150000) | FaceIndex:1 | ObjectIndex:3 | bFlip:0\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 61 && PixelCoord.x < 20 && PixelCoord.y < 83))//Id:19\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 61))/vec2(19, 21);\n        vec3 ObjectSpace_Position = vec3(0.471000, mix(0.610000, 0.750000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 3);\n    }\n//UV-Min:int2(0,83) | UV-Max:int2(20,105) | Real-Min:float3(0.044000,0.288000,0.000000) | Real-Max:float3(0.044000,0.428000,0.150000) | FaceIndex:0 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 83 && PixelCoord.x < 20 && PixelCoord.y < 105))//Id:12\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 83))/vec2(19, 21);\n        vec3 ObjectSpace_Position = vec3(0.044000, mix(0.288000, 0.428000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 2);\n    }\n//UV-Min:int2(0,105) | UV-Max:int2(29,127) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.200000,0.000000,0.150000) | FaceIndex:2 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 105 && PixelCoord.x < 29 && PixelCoord.y < 127))//Id:2\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 105))/vec2(28, 21);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.x), 0.000000, mix(0.000000, 0.150000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 0);\n    }\n//UV-Min:int2(20,0) | UV-Max:int2(42,67) | Real-Min:float3(0.000000,0.610000,0.000000) | Real-Max:float3(0.471000,0.610000,0.150000) | FaceIndex:2 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 20 && PixelCoord.y >= 0 && PixelCoord.x < 42 && PixelCoord.y < 67))//Id:20\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(20, 0))/vec2(21, 66);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.471000, AlphaCoord.y), 0.610000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 3);\n    }\n//UV-Min:int2(29,67) | UV-Max:int2(51,112) | Real-Min:float3(0.540000,0.360000,0.000000) | Real-Max:float3(0.540000,0.675000,0.150000) | FaceIndex:1 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 29 && PixelCoord.y >= 67 && PixelCoord.x < 51 && PixelCoord.y < 112))//Id:7\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(29, 67))/vec2(21, 44);\n        vec3 ObjectSpace_Position = vec3(0.540000, mix(0.360000, 0.675000, AlphaCoord.y), mix(0.000000, 0.150000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 1);\n    }\n//UV-Min:int2(42,0) | UV-Max:int2(87,20) | Real-Min:float3(0.400000,0.360000,0.000000) | Real-Max:float3(0.540000,0.675000,0.000000) | FaceIndex:4 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 42 && PixelCoord.y >= 0 && PixelCoord.x < 87 && PixelCoord.y < 20))//Id:10\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(42, 0))/vec2(44, 19);\n        vec3 ObjectSpace_Position = vec3(mix(0.400000, 0.540000, AlphaCoord.y), mix(0.360000, 0.675000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 1);\n    }\n//UV-Min:int2(42,20) | UV-Max:int2(87,40) | Real-Min:float3(0.400000,0.360000,0.150000) | Real-Max:float3(0.540000,0.675000,0.150000) | FaceIndex:5 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 42 && PixelCoord.y >= 20 && PixelCoord.x < 87 && PixelCoord.y < 40))//Id:11\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(42, 20))/vec2(44, 19);\n        vec3 ObjectSpace_Position = vec3(mix(0.400000, 0.540000, AlphaCoord.y), mix(0.360000, 0.675000, AlphaCoord.x),0.150000);//2\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 1);\n    }\n//UV-Min:int2(51,40) | UV-Max:int2(71,107) | Real-Min:float3(0.000000,0.610000,0.150000) | Real-Max:float3(0.471000,0.750000,0.150000) | FaceIndex:5 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 51 && PixelCoord.y >= 40 && PixelCoord.x < 71 && PixelCoord.y < 107))//Id:23\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(51, 40))/vec2(19, 66);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.471000, AlphaCoord.y), mix(0.610000, 0.750000, AlphaCoord.x),0.150000);//2\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 3);\n    }\n//UV-Min:int2(51,107) | UV-Max:int2(112,127) | Real-Min:float3(0.044000,0.288000,0.150000) | Real-Max:float3(0.471000,0.428000,0.150000) | FaceIndex:5 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 51 && PixelCoord.y >= 107 && PixelCoord.x < 112 && PixelCoord.y < 127))//Id:17\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(51, 107))/vec2(60, 19);\n        vec3 ObjectSpace_Position = vec3(mix(0.044000, 0.471000, AlphaCoord.x), mix(0.288000, 0.428000, AlphaCoord.y),0.150000);//2\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 2);\n    }\n//UV-Min:int2(71,40) | UV-Max:int2(91,107) | Real-Min:float3(0.000000,0.610000,0.000000) | Real-Max:float3(0.471000,0.750000,0.000000) | FaceIndex:4 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 71 && PixelCoord.y >= 40 && PixelCoord.x < 91 && PixelCoord.y < 107))//Id:22\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(71, 40))/vec2(19, 66);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.471000, AlphaCoord.y), mix(0.610000, 0.750000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 3);\n    }\n//UV-Min:int2(87,0) | UV-Max:int2(194,22) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.000000,0.750000,0.150000) | FaceIndex:0 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 87 && PixelCoord.y >= 0 && PixelCoord.x < 194 && PixelCoord.y < 22))//Id:0\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(87, 0))/vec2(106, 21);\n        vec3 ObjectSpace_Position = vec3(0.000000, mix(0.000000, 0.750000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 0);\n    }\n//UV-Min:int2(91,22) | UV-Max:int2(198,44) | Real-Min:float3(0.200000,0.000000,0.000000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:1 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 91 && PixelCoord.y >= 22 && PixelCoord.x < 198 && PixelCoord.y < 44))//Id:1\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(91, 22))/vec2(106, 21);\n        vec3 ObjectSpace_Position = vec3(0.200000, mix(0.000000, 0.750000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 0);\n    }\n//UV-Min:int2(91,44) | UV-Max:int2(198,73) | Real-Min:float3(0.000000,0.000000,0.150000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:5 | ObjectIndex:0 | bFlip:1\n    else if((PixelCoord.x >= 91 && PixelCoord.y >= 44 && PixelCoord.x < 198 && PixelCoord.y < 73))//Id:5\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(91, 44))/vec2(106, 28);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.y), mix(0.000000, 0.750000, AlphaCoord.x),0.150000);//2\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 0);\n    }\n//UV-Min:int2(91,73) | UV-Max:int2(113,102) | Real-Min:float3(0.000000,0.750000,0.000000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:3 | ObjectIndex:0 | bFlip:1\n    else if((PixelCoord.x >= 91 && PixelCoord.y >= 73 && PixelCoord.x < 113 && PixelCoord.y < 102))//Id:3\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(91, 73))/vec2(21, 28);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.y), 0.750000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 0);\n    }\n//UV-Min:int2(112,102) | UV-Max:int2(132,124) | Real-Min:float3(0.471000,0.288000,0.000000) | Real-Max:float3(0.471000,0.428000,0.150000) | FaceIndex:1 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 112 && PixelCoord.y >= 102 && PixelCoord.x < 132 && PixelCoord.y < 124))//Id:13\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(112, 102))/vec2(19, 21);\n        vec3 ObjectSpace_Position = vec3(0.471000, mix(0.288000, 0.428000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 2);\n    }\n//UV-Min:int2(113,73) | UV-Max:int2(174,95) | Real-Min:float3(0.044000,0.428000,0.000000) | Real-Max:float3(0.471000,0.428000,0.150000) | FaceIndex:3 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 113 && PixelCoord.y >= 73 && PixelCoord.x < 174 && PixelCoord.y < 95))//Id:15\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(113, 73))/vec2(60, 21);\n        vec3 ObjectSpace_Position = vec3(mix(0.044000, 0.471000, AlphaCoord.x), 0.428000, mix(0.000000, 0.150000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 2);\n    }\n//UV-Min:int2(198,0) | UV-Max:int2(220,61) | Real-Min:float3(0.044000,0.288000,0.000000) | Real-Max:float3(0.471000,0.288000,0.150000) | FaceIndex:2 | ObjectIndex:2 | bFlip:1\n    else if((PixelCoord.x >= 198 && PixelCoord.y >= 0 && PixelCoord.x < 220 && PixelCoord.y < 61))//Id:14\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(198, 0))/vec2(21, 60);\n        vec3 ObjectSpace_Position = vec3(mix(0.044000, 0.471000, AlphaCoord.y), 0.288000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 2);\n    }\n//UV-Min:int2(174,73) | UV-Max:int2(196,118) | Real-Min:float3(0.400000,0.360000,0.000000) | Real-Max:float3(0.400000,0.675000,0.150000) | FaceIndex:0 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 174 && PixelCoord.y >= 73 && PixelCoord.x < 196 && PixelCoord.y < 118))//Id:6\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(174, 73))/vec2(21, 44);\n        vec3 ObjectSpace_Position = vec3(0.400000, mix(0.360000, 0.675000, AlphaCoord.y), mix(0.000000, 0.150000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 1);\n    }\n//UV-Min:int2(132,95) | UV-Max:int2(154,115) | Real-Min:float3(0.400000,0.675000,0.000000) | Real-Max:float3(0.540000,0.675000,0.150000) | FaceIndex:3 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 132 && PixelCoord.y >= 95 && PixelCoord.x < 154 && PixelCoord.y < 115))//Id:9\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(132, 95))/vec2(21, 19);\n        vec3 ObjectSpace_Position = vec3(mix(0.400000, 0.540000, AlphaCoord.y), 0.675000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 1);\n    }\n//UV-Min:int2(198,61) | UV-Max:int2(220,128) | Real-Min:float3(0.000000,0.750000,0.000000) | Real-Max:float3(0.471000,0.750000,0.150000) | FaceIndex:3 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 198 && PixelCoord.y >= 61 && PixelCoord.x < 220 && PixelCoord.y < 128))//Id:21\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(198, 61))/vec2(21, 66);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.471000, AlphaCoord.y), 0.750000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 3);\n    }\n//UV-Min:int2(154,95) | UV-Max:int2(174,117) | Real-Min:float3(0.400000,0.360000,0.000000) | Real-Max:float3(0.540000,0.360000,0.150000) | FaceIndex:2 | ObjectIndex:1 | bFlip:0\n    else if((PixelCoord.x >= 154 && PixelCoord.y >= 95 && PixelCoord.x < 174 && PixelCoord.y < 117))//Id:8\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(154, 95))/vec2(19, 21);\n        vec3 ObjectSpace_Position = vec3(mix(0.400000, 0.540000, AlphaCoord.x), 0.360000, mix(0.000000, 0.150000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 1);\n    }\n//UV-Min:int2(220,0) | UV-Max:int2(242,20) | Real-Min:float3(0.000000,0.610000,0.000000) | Real-Max:float3(0.000000,0.750000,0.150000) | FaceIndex:0 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 220 && PixelCoord.y >= 0 && PixelCoord.x < 242 && PixelCoord.y < 20))//Id:18\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(220, 0))/vec2(21, 19);\n        vec3 ObjectSpace_Position = vec3(0.000000, mix(0.610000, 0.750000, AlphaCoord.y), mix(0.000000, 0.150000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 3);\n    }\n//UV-Min:int2(220,20) | UV-Max:int2(249,127) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.200000,0.750000,0.000000) | FaceIndex:4 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 220 && PixelCoord.y >= 20 && PixelCoord.x < 249 && PixelCoord.y < 127))//Id:4\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(220, 20))/vec2(28, 106);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.x), mix(0.000000, 0.750000, AlphaCoord.y),0.000000);//2\n        vec3 WorldSpace_Position = vec3(-0.280000, -1.000000, 0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 0);\n    }\n    else\n    {\n        return Point(vec4(0.0,0.0,0.0,-1.0), vec4(0.0,0.0,0.0,-1.0),-1,-1);\n    }\n}\n//####\n//####\nvec2 PositionToLightmap_P(Ray TempRay, float HitDistance, vec3 HitNormal, int CubeIndex)\n{\n    vec3 ObjectSpace_Position = TempRay.origin + TempRay.dir * HitDistance;\n    int FaceIndex = NormalToIndex(HitNormal);\n    int EigenIndex = FaceIndex + 6 * CubeIndex;\n//UV-Min:int2(0,0) | UV-Max:int2(20,61) | Real-Min:float3(0.044000,0.288000,0.000000) | Real-Max:float3(0.471000,0.428000,0.000000) | FaceIndex:4 | ObjectIndex:2 | bFlip:1\n    if(EigenIndex == 16)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.044000, 0.288000)) / vec2(0.427000, 0.140000);\n        return vec2(mix(0.500000, 19.500000, AlphaCoord.y), mix(0.500000, 60.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(0,61) | UV-Max:int2(20,83) | Real-Min:float3(0.471000,0.610000,0.000000) | Real-Max:float3(0.471000,0.750000,0.150000) | FaceIndex:1 | ObjectIndex:3 | bFlip:0\n    else if(EigenIndex == 19)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.610000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(0.500000, 19.500000, AlphaCoord.x), mix(61.500000, 82.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(0,83) | UV-Max:int2(20,105) | Real-Min:float3(0.044000,0.288000,0.000000) | Real-Max:float3(0.044000,0.428000,0.150000) | FaceIndex:0 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 12)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.288000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(0.500000, 19.500000, AlphaCoord.x), mix(83.500000, 104.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(0,105) | UV-Max:int2(29,127) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.200000,0.000000,0.150000) | FaceIndex:2 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 2)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(0.500000, 28.500000, AlphaCoord.x), mix(105.500000, 126.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(20,0) | UV-Max:int2(42,67) | Real-Min:float3(0.000000,0.610000,0.000000) | Real-Max:float3(0.471000,0.610000,0.150000) | FaceIndex:2 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 20)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.471000, 0.150000);\n        return vec2(mix(20.500000, 41.500000, AlphaCoord.y), mix(0.500000, 66.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(29,67) | UV-Max:int2(51,112) | Real-Min:float3(0.540000,0.360000,0.000000) | Real-Max:float3(0.540000,0.675000,0.150000) | FaceIndex:1 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 7)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.360000, 0.000000)) / vec2(0.315000, 0.150000);\n        return vec2(mix(29.500000, 50.500000, AlphaCoord.y), mix(67.500000, 111.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(42,0) | UV-Max:int2(87,20) | Real-Min:float3(0.400000,0.360000,0.000000) | Real-Max:float3(0.540000,0.675000,0.000000) | FaceIndex:4 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 10)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.400000, 0.360000)) / vec2(0.140000, 0.315000);\n        return vec2(mix(42.500000, 86.500000, AlphaCoord.y), mix(0.500000, 19.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(42,20) | UV-Max:int2(87,40) | Real-Min:float3(0.400000,0.360000,0.150000) | Real-Max:float3(0.540000,0.675000,0.150000) | FaceIndex:5 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 11)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.400000, 0.360000)) / vec2(0.140000, 0.315000);\n        return vec2(mix(42.500000, 86.500000, AlphaCoord.y), mix(20.500000, 39.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(51,40) | UV-Max:int2(71,107) | Real-Min:float3(0.000000,0.610000,0.150000) | Real-Max:float3(0.471000,0.750000,0.150000) | FaceIndex:5 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 23)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.610000)) / vec2(0.471000, 0.140000);\n        return vec2(mix(51.500000, 70.500000, AlphaCoord.y), mix(40.500000, 106.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(51,107) | UV-Max:int2(112,127) | Real-Min:float3(0.044000,0.288000,0.150000) | Real-Max:float3(0.471000,0.428000,0.150000) | FaceIndex:5 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 17)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.044000, 0.288000)) / vec2(0.427000, 0.140000);\n        return vec2(mix(51.500000, 111.500000, AlphaCoord.x), mix(107.500000, 126.500000, AlphaCoord.y));//2N\n    }\n//UV-Min:int2(71,40) | UV-Max:int2(91,107) | Real-Min:float3(0.000000,0.610000,0.000000) | Real-Max:float3(0.471000,0.750000,0.000000) | FaceIndex:4 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 22)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.610000)) / vec2(0.471000, 0.140000);\n        return vec2(mix(71.500000, 90.500000, AlphaCoord.y), mix(40.500000, 106.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(87,0) | UV-Max:int2(194,22) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.000000,0.750000,0.150000) | FaceIndex:0 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 0)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.750000, 0.150000);\n        return vec2(mix(87.500000, 193.500000, AlphaCoord.x), mix(0.500000, 21.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(91,22) | UV-Max:int2(198,44) | Real-Min:float3(0.200000,0.000000,0.000000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:1 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 1)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.750000, 0.150000);\n        return vec2(mix(91.500000, 197.500000, AlphaCoord.x), mix(22.500000, 43.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(91,44) | UV-Max:int2(198,73) | Real-Min:float3(0.000000,0.000000,0.150000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:5 | ObjectIndex:0 | bFlip:1\n    else if(EigenIndex == 5)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.000000)) / vec2(0.200000, 0.750000);\n        return vec2(mix(91.500000, 197.500000, AlphaCoord.y), mix(44.500000, 72.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(91,73) | UV-Max:int2(113,102) | Real-Min:float3(0.000000,0.750000,0.000000) | Real-Max:float3(0.200000,0.750000,0.150000) | FaceIndex:3 | ObjectIndex:0 | bFlip:1\n    else if(EigenIndex == 3)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(91.500000, 112.500000, AlphaCoord.y), mix(73.500000, 101.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(112,102) | UV-Max:int2(132,124) | Real-Min:float3(0.471000,0.288000,0.000000) | Real-Max:float3(0.471000,0.428000,0.150000) | FaceIndex:1 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 13)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.288000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(112.500000, 131.500000, AlphaCoord.x), mix(102.500000, 123.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(113,73) | UV-Max:int2(174,95) | Real-Min:float3(0.044000,0.428000,0.000000) | Real-Max:float3(0.471000,0.428000,0.150000) | FaceIndex:3 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 15)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.044000, 0.000000)) / vec2(0.427000, 0.150000);\n        return vec2(mix(113.500000, 173.500000, AlphaCoord.x), mix(73.500000, 94.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(198,0) | UV-Max:int2(220,61) | Real-Min:float3(0.044000,0.288000,0.000000) | Real-Max:float3(0.471000,0.288000,0.150000) | FaceIndex:2 | ObjectIndex:2 | bFlip:1\n    else if(EigenIndex == 14)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.044000, 0.000000)) / vec2(0.427000, 0.150000);\n        return vec2(mix(198.500000, 219.500000, AlphaCoord.y), mix(0.500000, 60.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(174,73) | UV-Max:int2(196,118) | Real-Min:float3(0.400000,0.360000,0.000000) | Real-Max:float3(0.400000,0.675000,0.150000) | FaceIndex:0 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 6)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.360000, 0.000000)) / vec2(0.315000, 0.150000);\n        return vec2(mix(174.500000, 195.500000, AlphaCoord.y), mix(73.500000, 117.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(132,95) | UV-Max:int2(154,115) | Real-Min:float3(0.400000,0.675000,0.000000) | Real-Max:float3(0.540000,0.675000,0.150000) | FaceIndex:3 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 9)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.400000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(132.500000, 153.500000, AlphaCoord.y), mix(95.500000, 114.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(198,61) | UV-Max:int2(220,128) | Real-Min:float3(0.000000,0.750000,0.000000) | Real-Max:float3(0.471000,0.750000,0.150000) | FaceIndex:3 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 21)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.471000, 0.150000);\n        return vec2(mix(198.500000, 219.500000, AlphaCoord.y), mix(61.500000, 127.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(154,95) | UV-Max:int2(174,117) | Real-Min:float3(0.400000,0.360000,0.000000) | Real-Max:float3(0.540000,0.360000,0.150000) | FaceIndex:2 | ObjectIndex:1 | bFlip:0\n    else if(EigenIndex == 8)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.400000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(154.500000, 173.500000, AlphaCoord.x), mix(95.500000, 116.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(220,0) | UV-Max:int2(242,20) | Real-Min:float3(0.000000,0.610000,0.000000) | Real-Max:float3(0.000000,0.750000,0.150000) | FaceIndex:0 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 18)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.610000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(220.500000, 241.500000, AlphaCoord.y), mix(0.500000, 19.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(220,20) | UV-Max:int2(249,127) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.200000,0.750000,0.000000) | FaceIndex:4 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 4)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.000000)) / vec2(0.200000, 0.750000);\n        return vec2(mix(220.500000, 248.500000, AlphaCoord.x), mix(20.500000, 126.500000, AlphaCoord.y));//2N\n    }\n    else\n    {\n        return vec2(0.0, 0.0);\n    }\n}\n//####\n///////////////\n//####\nPoint LightmapToPosition_G(vec2 UV)\n{\n    ivec2 PixelCoord = ivec2(UV);\n    mat4 RotationMatrix = rotate_y(-0.400000);\n    mat4 TransposeRotationMatrix = transpose(RotationMatrix);\n//UV-Min:int2(0,0) | UV-Max:int2(19,62) | Real-Min:float3(0.077000,0.610000,0.150000) | Real-Max:float3(0.550000,0.750000,0.150000) | FaceIndex:5 | ObjectIndex:5 | bFlip:1\n    if((PixelCoord.x >= 0 && PixelCoord.y >= 0 && PixelCoord.x < 19 && PixelCoord.y < 62))//Id:35\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 0))/vec2(18, 61);\n        vec3 ObjectSpace_Position = vec3(mix(0.077000, 0.550000, AlphaCoord.y), mix(0.610000, 0.750000, AlphaCoord.x),0.150000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 5);\n    }\n//UV-Min:int2(0,62) | UV-Max:int2(62,81) | Real-Min:float3(0.077000,0.610000,0.000000) | Real-Max:float3(0.550000,0.750000,0.000000) | FaceIndex:4 | ObjectIndex:5 | bFlip:0\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 62 && PixelCoord.x < 62 && PixelCoord.y < 81))//Id:34\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 62))/vec2(61, 18);\n        vec3 ObjectSpace_Position = vec3(mix(0.077000, 0.550000, AlphaCoord.x), mix(0.610000, 0.750000, AlphaCoord.y),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 5);\n    }\n//UV-Min:int2(0,81) | UV-Max:int2(27,107) | Real-Min:float3(0.425000,0.060000,0.150000) | Real-Max:float3(0.625000,0.265000,0.150000) | FaceIndex:5 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 81 && PixelCoord.x < 27 && PixelCoord.y < 107))//Id:11\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 81))/vec2(26, 25);\n        vec3 ObjectSpace_Position = vec3(mix(0.425000, 0.625000, AlphaCoord.y), mix(0.060000, 0.265000, AlphaCoord.x),0.150000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 1);\n    }\n//UV-Min:int2(19,0) | UV-Max:int2(39,62) | Real-Min:float3(0.077000,0.610000,0.000000) | Real-Max:float3(0.550000,0.610000,0.150000) | FaceIndex:2 | ObjectIndex:5 | bFlip:1\n    else if((PixelCoord.x >= 19 && PixelCoord.y >= 0 && PixelCoord.x < 39 && PixelCoord.y < 62))//Id:32\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(19, 0))/vec2(19, 61);\n        vec3 ObjectSpace_Position = vec3(mix(0.077000, 0.550000, AlphaCoord.y), 0.610000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 5);\n    }\n//UV-Min:int2(27,81) | UV-Max:int2(47,108) | Real-Min:float3(0.425000,0.060000,0.000000) | Real-Max:float3(0.425000,0.265000,0.150000) | FaceIndex:0 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 27 && PixelCoord.y >= 81 && PixelCoord.x < 47 && PixelCoord.y < 108))//Id:6\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(27, 81))/vec2(19, 26);\n        vec3 ObjectSpace_Position = vec3(0.425000, mix(0.060000, 0.265000, AlphaCoord.y), mix(0.000000, 0.150000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 1);\n    }\n//UV-Min:int2(0,107) | UV-Max:int2(20,127) | Real-Min:float3(0.425000,0.520000,0.000000) | Real-Max:float3(0.425000,0.670000,0.150000) | FaceIndex:0 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 107 && PixelCoord.x < 20 && PixelCoord.y < 127))//Id:12\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 107))/vec2(19, 19);\n        vec3 ObjectSpace_Position = vec3(0.425000, mix(0.520000, 0.670000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 2);\n    }\n//UV-Min:int2(39,0) | UV-Max:int2(59,26) | Real-Min:float3(0.425000,0.520000,0.000000) | Real-Max:float3(0.625000,0.520000,0.150000) | FaceIndex:2 | ObjectIndex:2 | bFlip:1\n    else if((PixelCoord.x >= 39 && PixelCoord.y >= 0 && PixelCoord.x < 59 && PixelCoord.y < 26))//Id:14\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(39, 0))/vec2(19, 25);\n        vec3 ObjectSpace_Position = vec3(mix(0.425000, 0.625000, AlphaCoord.y), 0.520000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 2);\n    }\n//UV-Min:int2(39,26) | UV-Max:int2(66,52) | Real-Min:float3(0.425000,0.060000,0.000000) | Real-Max:float3(0.625000,0.265000,0.000000) | FaceIndex:4 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 39 && PixelCoord.y >= 26 && PixelCoord.x < 66 && PixelCoord.y < 52))//Id:10\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(39, 26))/vec2(26, 25);\n        vec3 ObjectSpace_Position = vec3(mix(0.425000, 0.625000, AlphaCoord.y), mix(0.060000, 0.265000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 1);\n    }\n//UV-Min:int2(47,81) | UV-Max:int2(67,107) | Real-Min:float3(0.425000,0.265000,0.000000) | Real-Max:float3(0.625000,0.265000,0.150000) | FaceIndex:3 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 47 && PixelCoord.y >= 81 && PixelCoord.x < 67 && PixelCoord.y < 107))//Id:9\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(47, 81))/vec2(19, 25);\n        vec3 ObjectSpace_Position = vec3(mix(0.425000, 0.625000, AlphaCoord.y), 0.265000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 1);\n    }\n//UV-Min:int2(20,108) | UV-Max:int2(40,127) | Real-Min:float3(0.100000,0.000000,0.000000) | Real-Max:float3(0.100000,0.140000,0.150000) | FaceIndex:0 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 20 && PixelCoord.y >= 108 && PixelCoord.x < 40 && PixelCoord.y < 127))//Id:18\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(20, 108))/vec2(19, 18);\n        vec3 ObjectSpace_Position = vec3(0.100000, mix(0.000000, 0.140000, AlphaCoord.y), mix(0.000000, 0.150000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 3);\n    }\n//UV-Min:int2(66,0) | UV-Max:int2(86,41) | Real-Min:float3(0.315000,0.405000,0.000000) | Real-Max:float3(0.625000,0.405000,0.150000) | FaceIndex:3 | ObjectIndex:4 | bFlip:1\n    else if((PixelCoord.x >= 66 && PixelCoord.y >= 0 && PixelCoord.x < 86 && PixelCoord.y < 41))//Id:27\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(66, 0))/vec2(19, 40);\n        vec3 ObjectSpace_Position = vec3(mix(0.315000, 0.625000, AlphaCoord.y), 0.405000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 4);\n    }\n//UV-Min:int2(62,52) | UV-Max:int2(82,78) | Real-Min:float3(0.425000,0.520000,0.000000) | Real-Max:float3(0.625000,0.670000,0.000000) | FaceIndex:4 | ObjectIndex:2 | bFlip:1\n    else if((PixelCoord.x >= 62 && PixelCoord.y >= 52 && PixelCoord.x < 82 && PixelCoord.y < 78))//Id:16\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(62, 52))/vec2(19, 25);\n        vec3 ObjectSpace_Position = vec3(mix(0.425000, 0.625000, AlphaCoord.y), mix(0.520000, 0.670000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 2);\n    }\n//UV-Min:int2(40,108) | UV-Max:int2(102,128) | Real-Min:float3(0.077000,0.750000,0.000000) | Real-Max:float3(0.550000,0.750000,0.150000) | FaceIndex:3 | ObjectIndex:5 | bFlip:0\n    else if((PixelCoord.x >= 40 && PixelCoord.y >= 108 && PixelCoord.x < 102 && PixelCoord.y < 128))//Id:33\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(40, 108))/vec2(61, 19);\n        vec3 ObjectSpace_Position = vec3(mix(0.077000, 0.550000, AlphaCoord.x), 0.750000, mix(0.000000, 0.150000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 5);\n    }\n//UV-Min:int2(86,0) | UV-Max:int2(105,68) | Real-Min:float3(0.100000,0.000000,0.000000) | Real-Max:float3(0.625000,0.140000,0.000000) | FaceIndex:4 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 86 && PixelCoord.y >= 0 && PixelCoord.x < 105 && PixelCoord.y < 68))//Id:22\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(86, 0))/vec2(18, 67);\n        vec3 ObjectSpace_Position = vec3(mix(0.100000, 0.625000, AlphaCoord.y), mix(0.000000, 0.140000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 3);\n    }\n//UV-Min:int2(105,0) | UV-Max:int2(131,79) | Real-Min:float3(0.000000,0.060000,0.000000) | Real-Max:float3(0.200000,0.670000,0.000000) | FaceIndex:4 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 105 && PixelCoord.y >= 0 && PixelCoord.x < 131 && PixelCoord.y < 79))//Id:4\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(105, 0))/vec2(25, 78);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.x), mix(0.060000, 0.670000, AlphaCoord.y),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 0);\n    }\n//UV-Min:int2(67,79) | UV-Max:int2(146,105) | Real-Min:float3(0.000000,0.060000,0.150000) | Real-Max:float3(0.200000,0.670000,0.150000) | FaceIndex:5 | ObjectIndex:0 | bFlip:1\n    else if((PixelCoord.x >= 67 && PixelCoord.y >= 79 && PixelCoord.x < 146 && PixelCoord.y < 105))//Id:5\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(67, 79))/vec2(78, 25);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.y), mix(0.060000, 0.670000, AlphaCoord.x),0.150000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 0);\n    }\n//UV-Min:int2(102,105) | UV-Max:int2(121,125) | Real-Min:float3(0.625000,0.265000,0.000000) | Real-Max:float3(0.625000,0.405000,0.150000) | FaceIndex:1 | ObjectIndex:4 | bFlip:0\n    else if((PixelCoord.x >= 102 && PixelCoord.y >= 105 && PixelCoord.x < 121 && PixelCoord.y < 125))//Id:25\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(102, 105))/vec2(18, 19);\n        vec3 ObjectSpace_Position = vec3(0.625000, mix(0.265000, 0.405000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 4);\n    }\n//UV-Min:int2(131,0) | UV-Max:int2(151,68) | Real-Min:float3(0.100000,0.140000,0.000000) | Real-Max:float3(0.625000,0.140000,0.150000) | FaceIndex:3 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 131 && PixelCoord.y >= 0 && PixelCoord.x < 151 && PixelCoord.y < 68))//Id:21\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(131, 0))/vec2(19, 67);\n        vec3 ObjectSpace_Position = vec3(mix(0.100000, 0.625000, AlphaCoord.y), 0.140000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 3);\n    }\n//UV-Min:int2(121,105) | UV-Max:int2(147,125) | Real-Min:float3(0.000000,0.060000,0.000000) | Real-Max:float3(0.200000,0.060000,0.150000) | FaceIndex:2 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 121 && PixelCoord.y >= 105 && PixelCoord.x < 147 && PixelCoord.y < 125))//Id:2\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(121, 105))/vec2(25, 19);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.x), 0.060000, mix(0.000000, 0.150000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 0);\n    }\n//UV-Min:int2(146,68) | UV-Max:int2(187,88) | Real-Min:float3(0.315000,0.265000,0.000000) | Real-Max:float3(0.625000,0.265000,0.150000) | FaceIndex:2 | ObjectIndex:4 | bFlip:0\n    else if((PixelCoord.x >= 146 && PixelCoord.y >= 68 && PixelCoord.x < 187 && PixelCoord.y < 88))//Id:26\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(146, 68))/vec2(40, 19);\n        vec3 ObjectSpace_Position = vec3(mix(0.315000, 0.625000, AlphaCoord.x), 0.265000, mix(0.000000, 0.150000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 4);\n    }\n//UV-Min:int2(147,88) | UV-Max:int2(226,108) | Real-Min:float3(0.000000,0.060000,0.000000) | Real-Max:float3(0.000000,0.670000,0.150000) | FaceIndex:0 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 147 && PixelCoord.y >= 88 && PixelCoord.x < 226 && PixelCoord.y < 108))//Id:0\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(147, 88))/vec2(78, 19);\n        vec3 ObjectSpace_Position = vec3(0.000000, mix(0.060000, 0.670000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 0);\n    }\n//UV-Min:int2(147,108) | UV-Max:int2(173,128) | Real-Min:float3(0.425000,0.670000,0.000000) | Real-Max:float3(0.625000,0.670000,0.150000) | FaceIndex:3 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 147 && PixelCoord.y >= 108 && PixelCoord.x < 173 && PixelCoord.y < 128))//Id:15\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(147, 108))/vec2(25, 19);\n        vec3 ObjectSpace_Position = vec3(mix(0.425000, 0.625000, AlphaCoord.x), 0.670000, mix(0.000000, 0.150000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 2);\n    }\n//UV-Min:int2(151,0) | UV-Max:int2(170,20) | Real-Min:float3(0.315000,0.265000,0.000000) | Real-Max:float3(0.315000,0.405000,0.150000) | FaceIndex:0 | ObjectIndex:4 | bFlip:0\n    else if((PixelCoord.x >= 151 && PixelCoord.y >= 0 && PixelCoord.x < 170 && PixelCoord.y < 20))//Id:24\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(151, 0))/vec2(18, 19);\n        vec3 ObjectSpace_Position = vec3(0.315000, mix(0.265000, 0.405000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 4);\n    }\n//UV-Min:int2(170,0) | UV-Max:int2(189,68) | Real-Min:float3(0.100000,0.000000,0.150000) | Real-Max:float3(0.625000,0.140000,0.150000) | FaceIndex:5 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 170 && PixelCoord.y >= 0 && PixelCoord.x < 189 && PixelCoord.y < 68))//Id:23\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(170, 0))/vec2(18, 67);\n        vec3 ObjectSpace_Position = vec3(mix(0.100000, 0.625000, AlphaCoord.y), mix(0.000000, 0.140000, AlphaCoord.x),0.150000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 3);\n    }\n//UV-Min:int2(173,108) | UV-Max:int2(252,128) | Real-Min:float3(0.200000,0.060000,0.000000) | Real-Max:float3(0.200000,0.670000,0.150000) | FaceIndex:1 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 173 && PixelCoord.y >= 108 && PixelCoord.x < 252 && PixelCoord.y < 128))//Id:1\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(173, 108))/vec2(78, 19);\n        vec3 ObjectSpace_Position = vec3(0.200000, mix(0.060000, 0.670000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 0);\n    }\n//UV-Min:int2(151,20) | UV-Max:int2(170,61) | Real-Min:float3(0.315000,0.265000,0.150000) | Real-Max:float3(0.625000,0.405000,0.150000) | FaceIndex:5 | ObjectIndex:4 | bFlip:1\n    else if((PixelCoord.x >= 151 && PixelCoord.y >= 20 && PixelCoord.x < 170 && PixelCoord.y < 61))//Id:29\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(151, 20))/vec2(18, 40);\n        vec3 ObjectSpace_Position = vec3(mix(0.315000, 0.625000, AlphaCoord.y), mix(0.265000, 0.405000, AlphaCoord.x),0.150000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 4);\n    }\n//UV-Min:int2(189,0) | UV-Max:int2(209,68) | Real-Min:float3(0.100000,0.000000,0.000000) | Real-Max:float3(0.625000,0.000000,0.150000) | FaceIndex:2 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 189 && PixelCoord.y >= 0 && PixelCoord.x < 209 && PixelCoord.y < 68))//Id:20\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(189, 0))/vec2(19, 67);\n        vec3 ObjectSpace_Position = vec3(mix(0.100000, 0.625000, AlphaCoord.y), 0.000000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 3);\n    }\n//UV-Min:int2(187,68) | UV-Max:int2(207,87) | Real-Min:float3(0.550000,0.610000,0.000000) | Real-Max:float3(0.550000,0.750000,0.150000) | FaceIndex:1 | ObjectIndex:5 | bFlip:1\n    else if((PixelCoord.x >= 187 && PixelCoord.y >= 68 && PixelCoord.x < 207 && PixelCoord.y < 87))//Id:31\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(187, 68))/vec2(19, 18);\n        vec3 ObjectSpace_Position = vec3(0.550000, mix(0.610000, 0.750000, AlphaCoord.y), mix(0.000000, 0.150000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 5);\n    }\n//UV-Min:int2(207,68) | UV-Max:int2(226,88) | Real-Min:float3(0.077000,0.610000,0.000000) | Real-Max:float3(0.077000,0.750000,0.150000) | FaceIndex:0 | ObjectIndex:5 | bFlip:0\n    else if((PixelCoord.x >= 207 && PixelCoord.y >= 68 && PixelCoord.x < 226 && PixelCoord.y < 88))//Id:30\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(207, 68))/vec2(18, 19);\n        vec3 ObjectSpace_Position = vec3(0.077000, mix(0.610000, 0.750000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 5);\n    }\n//UV-Min:int2(209,0) | UV-Max:int2(250,19) | Real-Min:float3(0.315000,0.265000,0.000000) | Real-Max:float3(0.625000,0.405000,0.000000) | FaceIndex:4 | ObjectIndex:4 | bFlip:0\n    else if((PixelCoord.x >= 209 && PixelCoord.y >= 0 && PixelCoord.x < 250 && PixelCoord.y < 19))//Id:28\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(209, 0))/vec2(40, 18);\n        vec3 ObjectSpace_Position = vec3(mix(0.315000, 0.625000, AlphaCoord.x), mix(0.265000, 0.405000, AlphaCoord.y),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 4);\n    }\n//UV-Min:int2(209,19) | UV-Max:int2(229,46) | Real-Min:float3(0.625000,0.060000,0.000000) | Real-Max:float3(0.625000,0.265000,0.150000) | FaceIndex:1 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 209 && PixelCoord.y >= 19 && PixelCoord.x < 229 && PixelCoord.y < 46))//Id:7\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(209, 19))/vec2(19, 26);\n        vec3 ObjectSpace_Position = vec3(0.625000, mix(0.060000, 0.265000, AlphaCoord.y), mix(0.000000, 0.150000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 1);\n    }\n//UV-Min:int2(209,46) | UV-Max:int2(235,66) | Real-Min:float3(0.425000,0.060000,0.000000) | Real-Max:float3(0.625000,0.060000,0.150000) | FaceIndex:2 | ObjectIndex:1 | bFlip:0\n    else if((PixelCoord.x >= 209 && PixelCoord.y >= 46 && PixelCoord.x < 235 && PixelCoord.y < 66))//Id:8\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(209, 46))/vec2(25, 19);\n        vec3 ObjectSpace_Position = vec3(mix(0.425000, 0.625000, AlphaCoord.x), 0.060000, mix(0.000000, 0.150000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 1);\n    }\n//UV-Min:int2(226,66) | UV-Max:int2(252,86) | Real-Min:float3(0.425000,0.520000,0.150000) | Real-Max:float3(0.625000,0.670000,0.150000) | FaceIndex:5 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 226 && PixelCoord.y >= 66 && PixelCoord.x < 252 && PixelCoord.y < 86))//Id:17\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(226, 66))/vec2(25, 19);\n        vec3 ObjectSpace_Position = vec3(mix(0.425000, 0.625000, AlphaCoord.x), mix(0.520000, 0.670000, AlphaCoord.y),0.150000);//2\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 2);\n    }\n//UV-Min:int2(226,86) | UV-Max:int2(245,106) | Real-Min:float3(0.625000,0.000000,0.000000) | Real-Max:float3(0.625000,0.140000,0.150000) | FaceIndex:1 | ObjectIndex:3 | bFlip:0\n    else if((PixelCoord.x >= 226 && PixelCoord.y >= 86 && PixelCoord.x < 245 && PixelCoord.y < 106))//Id:19\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(226, 86))/vec2(18, 19);\n        vec3 ObjectSpace_Position = vec3(0.625000, mix(0.000000, 0.140000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 3);\n    }\n//UV-Min:int2(229,19) | UV-Max:int2(249,39) | Real-Min:float3(0.625000,0.520000,0.000000) | Real-Max:float3(0.625000,0.670000,0.150000) | FaceIndex:1 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 229 && PixelCoord.y >= 19 && PixelCoord.x < 249 && PixelCoord.y < 39))//Id:13\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(229, 19))/vec2(19, 19);\n        vec3 ObjectSpace_Position = vec3(0.625000, mix(0.520000, 0.670000, AlphaCoord.x), mix(0.000000, 0.150000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 2);\n    }\n//UV-Min:int2(235,39) | UV-Max:int2(255,65) | Real-Min:float3(0.000000,0.670000,0.000000) | Real-Max:float3(0.200000,0.670000,0.150000) | FaceIndex:3 | ObjectIndex:0 | bFlip:1\n    else if((PixelCoord.x >= 235 && PixelCoord.y >= 39 && PixelCoord.x < 255 && PixelCoord.y < 65))//Id:3\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(235, 39))/vec2(19, 25);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.200000, AlphaCoord.y), 0.670000, mix(0.000000, 0.150000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.350000, -1.000000, -0.200000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 0);\n    }\n    else\n    {\n        return Point(vec4(0.0,0.0,0.0,-1.0), vec4(0.0,0.0,0.0,-1.0),-1,-1);\n    }\n}\n//####\n//####\nvec2 PositionToLightmap_G(Ray TempRay, float HitDistance, vec3 HitNormal, int CubeIndex)\n{\n    vec3 ObjectSpace_Position = TempRay.origin + TempRay.dir * HitDistance;\n    int FaceIndex = NormalToIndex(HitNormal);\n    int EigenIndex = FaceIndex + 6 * CubeIndex;\n//UV-Min:int2(0,0) | UV-Max:int2(19,62) | Real-Min:float3(0.077000,0.610000,0.150000) | Real-Max:float3(0.550000,0.750000,0.150000) | FaceIndex:5 | ObjectIndex:5 | bFlip:1\n    if(EigenIndex == 35)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.077000, 0.610000)) / vec2(0.473000, 0.140000);\n        return vec2(mix(0.500000, 18.500000, AlphaCoord.y), mix(0.500000, 61.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(0,62) | UV-Max:int2(62,81) | Real-Min:float3(0.077000,0.610000,0.000000) | Real-Max:float3(0.550000,0.750000,0.000000) | FaceIndex:4 | ObjectIndex:5 | bFlip:0\n    else if(EigenIndex == 34)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.077000, 0.610000)) / vec2(0.473000, 0.140000);\n        return vec2(mix(0.500000, 61.500000, AlphaCoord.x), mix(62.500000, 80.500000, AlphaCoord.y));//2N\n    }\n//UV-Min:int2(0,81) | UV-Max:int2(27,107) | Real-Min:float3(0.425000,0.060000,0.150000) | Real-Max:float3(0.625000,0.265000,0.150000) | FaceIndex:5 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 11)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.425000, 0.060000)) / vec2(0.200000, 0.205000);\n        return vec2(mix(0.500000, 26.500000, AlphaCoord.y), mix(81.500000, 106.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(19,0) | UV-Max:int2(39,62) | Real-Min:float3(0.077000,0.610000,0.000000) | Real-Max:float3(0.550000,0.610000,0.150000) | FaceIndex:2 | ObjectIndex:5 | bFlip:1\n    else if(EigenIndex == 32)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.077000, 0.000000)) / vec2(0.473000, 0.150000);\n        return vec2(mix(19.500000, 38.500000, AlphaCoord.y), mix(0.500000, 61.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(27,81) | UV-Max:int2(47,108) | Real-Min:float3(0.425000,0.060000,0.000000) | Real-Max:float3(0.425000,0.265000,0.150000) | FaceIndex:0 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 6)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.060000, 0.000000)) / vec2(0.205000, 0.150000);\n        return vec2(mix(27.500000, 46.500000, AlphaCoord.y), mix(81.500000, 107.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(0,107) | UV-Max:int2(20,127) | Real-Min:float3(0.425000,0.520000,0.000000) | Real-Max:float3(0.425000,0.670000,0.150000) | FaceIndex:0 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 12)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.520000, 0.000000)) / vec2(0.150000, 0.150000);\n        return vec2(mix(0.500000, 19.500000, AlphaCoord.x), mix(107.500000, 126.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(39,0) | UV-Max:int2(59,26) | Real-Min:float3(0.425000,0.520000,0.000000) | Real-Max:float3(0.625000,0.520000,0.150000) | FaceIndex:2 | ObjectIndex:2 | bFlip:1\n    else if(EigenIndex == 14)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.425000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(39.500000, 58.500000, AlphaCoord.y), mix(0.500000, 25.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(39,26) | UV-Max:int2(66,52) | Real-Min:float3(0.425000,0.060000,0.000000) | Real-Max:float3(0.625000,0.265000,0.000000) | FaceIndex:4 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 10)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.425000, 0.060000)) / vec2(0.200000, 0.205000);\n        return vec2(mix(39.500000, 65.500000, AlphaCoord.y), mix(26.500000, 51.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(47,81) | UV-Max:int2(67,107) | Real-Min:float3(0.425000,0.265000,0.000000) | Real-Max:float3(0.625000,0.265000,0.150000) | FaceIndex:3 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 9)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.425000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(47.500000, 66.500000, AlphaCoord.y), mix(81.500000, 106.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(20,108) | UV-Max:int2(40,127) | Real-Min:float3(0.100000,0.000000,0.000000) | Real-Max:float3(0.100000,0.140000,0.150000) | FaceIndex:0 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 18)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(20.500000, 39.500000, AlphaCoord.y), mix(108.500000, 126.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(66,0) | UV-Max:int2(86,41) | Real-Min:float3(0.315000,0.405000,0.000000) | Real-Max:float3(0.625000,0.405000,0.150000) | FaceIndex:3 | ObjectIndex:4 | bFlip:1\n    else if(EigenIndex == 27)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.315000, 0.000000)) / vec2(0.310000, 0.150000);\n        return vec2(mix(66.500000, 85.500000, AlphaCoord.y), mix(0.500000, 40.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(62,52) | UV-Max:int2(82,78) | Real-Min:float3(0.425000,0.520000,0.000000) | Real-Max:float3(0.625000,0.670000,0.000000) | FaceIndex:4 | ObjectIndex:2 | bFlip:1\n    else if(EigenIndex == 16)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.425000, 0.520000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(62.500000, 81.500000, AlphaCoord.y), mix(52.500000, 77.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(40,108) | UV-Max:int2(102,128) | Real-Min:float3(0.077000,0.750000,0.000000) | Real-Max:float3(0.550000,0.750000,0.150000) | FaceIndex:3 | ObjectIndex:5 | bFlip:0\n    else if(EigenIndex == 33)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.077000, 0.000000)) / vec2(0.473000, 0.150000);\n        return vec2(mix(40.500000, 101.500000, AlphaCoord.x), mix(108.500000, 127.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(86,0) | UV-Max:int2(105,68) | Real-Min:float3(0.100000,0.000000,0.000000) | Real-Max:float3(0.625000,0.140000,0.000000) | FaceIndex:4 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 22)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.100000, 0.000000)) / vec2(0.525000, 0.140000);\n        return vec2(mix(86.500000, 104.500000, AlphaCoord.y), mix(0.500000, 67.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(105,0) | UV-Max:int2(131,79) | Real-Min:float3(0.000000,0.060000,0.000000) | Real-Max:float3(0.200000,0.670000,0.000000) | FaceIndex:4 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 4)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.060000)) / vec2(0.200000, 0.610000);\n        return vec2(mix(105.500000, 130.500000, AlphaCoord.x), mix(0.500000, 78.500000, AlphaCoord.y));//2N\n    }\n//UV-Min:int2(67,79) | UV-Max:int2(146,105) | Real-Min:float3(0.000000,0.060000,0.150000) | Real-Max:float3(0.200000,0.670000,0.150000) | FaceIndex:5 | ObjectIndex:0 | bFlip:1\n    else if(EigenIndex == 5)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.060000)) / vec2(0.200000, 0.610000);\n        return vec2(mix(67.500000, 145.500000, AlphaCoord.y), mix(79.500000, 104.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(102,105) | UV-Max:int2(121,125) | Real-Min:float3(0.625000,0.265000,0.000000) | Real-Max:float3(0.625000,0.405000,0.150000) | FaceIndex:1 | ObjectIndex:4 | bFlip:0\n    else if(EigenIndex == 25)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.265000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(102.500000, 120.500000, AlphaCoord.x), mix(105.500000, 124.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(131,0) | UV-Max:int2(151,68) | Real-Min:float3(0.100000,0.140000,0.000000) | Real-Max:float3(0.625000,0.140000,0.150000) | FaceIndex:3 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 21)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.100000, 0.000000)) / vec2(0.525000, 0.150000);\n        return vec2(mix(131.500000, 150.500000, AlphaCoord.y), mix(0.500000, 67.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(121,105) | UV-Max:int2(147,125) | Real-Min:float3(0.000000,0.060000,0.000000) | Real-Max:float3(0.200000,0.060000,0.150000) | FaceIndex:2 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 2)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(121.500000, 146.500000, AlphaCoord.x), mix(105.500000, 124.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(146,68) | UV-Max:int2(187,88) | Real-Min:float3(0.315000,0.265000,0.000000) | Real-Max:float3(0.625000,0.265000,0.150000) | FaceIndex:2 | ObjectIndex:4 | bFlip:0\n    else if(EigenIndex == 26)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.315000, 0.000000)) / vec2(0.310000, 0.150000);\n        return vec2(mix(146.500000, 186.500000, AlphaCoord.x), mix(68.500000, 87.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(147,88) | UV-Max:int2(226,108) | Real-Min:float3(0.000000,0.060000,0.000000) | Real-Max:float3(0.000000,0.670000,0.150000) | FaceIndex:0 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 0)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.060000, 0.000000)) / vec2(0.610000, 0.150000);\n        return vec2(mix(147.500000, 225.500000, AlphaCoord.x), mix(88.500000, 107.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(147,108) | UV-Max:int2(173,128) | Real-Min:float3(0.425000,0.670000,0.000000) | Real-Max:float3(0.625000,0.670000,0.150000) | FaceIndex:3 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 15)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.425000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(147.500000, 172.500000, AlphaCoord.x), mix(108.500000, 127.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(151,0) | UV-Max:int2(170,20) | Real-Min:float3(0.315000,0.265000,0.000000) | Real-Max:float3(0.315000,0.405000,0.150000) | FaceIndex:0 | ObjectIndex:4 | bFlip:0\n    else if(EigenIndex == 24)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.265000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(151.500000, 169.500000, AlphaCoord.x), mix(0.500000, 19.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(170,0) | UV-Max:int2(189,68) | Real-Min:float3(0.100000,0.000000,0.150000) | Real-Max:float3(0.625000,0.140000,0.150000) | FaceIndex:5 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 23)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.100000, 0.000000)) / vec2(0.525000, 0.140000);\n        return vec2(mix(170.500000, 188.500000, AlphaCoord.y), mix(0.500000, 67.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(173,108) | UV-Max:int2(252,128) | Real-Min:float3(0.200000,0.060000,0.000000) | Real-Max:float3(0.200000,0.670000,0.150000) | FaceIndex:1 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 1)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.060000, 0.000000)) / vec2(0.610000, 0.150000);\n        return vec2(mix(173.500000, 251.500000, AlphaCoord.x), mix(108.500000, 127.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(151,20) | UV-Max:int2(170,61) | Real-Min:float3(0.315000,0.265000,0.150000) | Real-Max:float3(0.625000,0.405000,0.150000) | FaceIndex:5 | ObjectIndex:4 | bFlip:1\n    else if(EigenIndex == 29)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.315000, 0.265000)) / vec2(0.310000, 0.140000);\n        return vec2(mix(151.500000, 169.500000, AlphaCoord.y), mix(20.500000, 60.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(189,0) | UV-Max:int2(209,68) | Real-Min:float3(0.100000,0.000000,0.000000) | Real-Max:float3(0.625000,0.000000,0.150000) | FaceIndex:2 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 20)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.100000, 0.000000)) / vec2(0.525000, 0.150000);\n        return vec2(mix(189.500000, 208.500000, AlphaCoord.y), mix(0.500000, 67.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(187,68) | UV-Max:int2(207,87) | Real-Min:float3(0.550000,0.610000,0.000000) | Real-Max:float3(0.550000,0.750000,0.150000) | FaceIndex:1 | ObjectIndex:5 | bFlip:1\n    else if(EigenIndex == 31)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.610000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(187.500000, 206.500000, AlphaCoord.y), mix(68.500000, 86.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(207,68) | UV-Max:int2(226,88) | Real-Min:float3(0.077000,0.610000,0.000000) | Real-Max:float3(0.077000,0.750000,0.150000) | FaceIndex:0 | ObjectIndex:5 | bFlip:0\n    else if(EigenIndex == 30)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.610000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(207.500000, 225.500000, AlphaCoord.x), mix(68.500000, 87.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(209,0) | UV-Max:int2(250,19) | Real-Min:float3(0.315000,0.265000,0.000000) | Real-Max:float3(0.625000,0.405000,0.000000) | FaceIndex:4 | ObjectIndex:4 | bFlip:0\n    else if(EigenIndex == 28)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.315000, 0.265000)) / vec2(0.310000, 0.140000);\n        return vec2(mix(209.500000, 249.500000, AlphaCoord.x), mix(0.500000, 18.500000, AlphaCoord.y));//2N\n    }\n//UV-Min:int2(209,19) | UV-Max:int2(229,46) | Real-Min:float3(0.625000,0.060000,0.000000) | Real-Max:float3(0.625000,0.265000,0.150000) | FaceIndex:1 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 7)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.060000, 0.000000)) / vec2(0.205000, 0.150000);\n        return vec2(mix(209.500000, 228.500000, AlphaCoord.y), mix(19.500000, 45.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(209,46) | UV-Max:int2(235,66) | Real-Min:float3(0.425000,0.060000,0.000000) | Real-Max:float3(0.625000,0.060000,0.150000) | FaceIndex:2 | ObjectIndex:1 | bFlip:0\n    else if(EigenIndex == 8)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.425000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(209.500000, 234.500000, AlphaCoord.x), mix(46.500000, 65.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(226,66) | UV-Max:int2(252,86) | Real-Min:float3(0.425000,0.520000,0.150000) | Real-Max:float3(0.625000,0.670000,0.150000) | FaceIndex:5 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 17)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.425000, 0.520000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(226.500000, 251.500000, AlphaCoord.x), mix(66.500000, 85.500000, AlphaCoord.y));//2N\n    }\n//UV-Min:int2(226,86) | UV-Max:int2(245,106) | Real-Min:float3(0.625000,0.000000,0.000000) | Real-Max:float3(0.625000,0.140000,0.150000) | FaceIndex:1 | ObjectIndex:3 | bFlip:0\n    else if(EigenIndex == 19)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.140000, 0.150000);\n        return vec2(mix(226.500000, 244.500000, AlphaCoord.x), mix(86.500000, 105.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(229,19) | UV-Max:int2(249,39) | Real-Min:float3(0.625000,0.520000,0.000000) | Real-Max:float3(0.625000,0.670000,0.150000) | FaceIndex:1 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 13)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.520000, 0.000000)) / vec2(0.150000, 0.150000);\n        return vec2(mix(229.500000, 248.500000, AlphaCoord.x), mix(19.500000, 38.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(235,39) | UV-Max:int2(255,65) | Real-Min:float3(0.000000,0.670000,0.000000) | Real-Max:float3(0.200000,0.670000,0.150000) | FaceIndex:3 | ObjectIndex:0 | bFlip:1\n    else if(EigenIndex == 3)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.200000, 0.150000);\n        return vec2(mix(235.500000, 254.500000, AlphaCoord.y), mix(39.500000, 64.500000, AlphaCoord.x));//1F\n    }\n    else\n    {\n        return vec2(0.0, 0.0);\n    }\n}\n//####\n//####\nPoint LightmapToPosition_21(vec2 UV)\n{\n    ivec2 PixelCoord = ivec2(UV);\n    mat4 RotationMatrix = rotate_y(0.000000);\n    mat4 TransposeRotationMatrix = transpose(RotationMatrix);\n//UV-Min:int2(0,0) | UV-Max:int2(12,21) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.307000,0.182500,0.125000) | FaceIndex:2 | ObjectIndex:1 | bFlip:0\n    if((PixelCoord.x >= 0 && PixelCoord.y >= 0 && PixelCoord.x < 12 && PixelCoord.y < 21))//Id:8\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 0))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(mix(0.237000, 0.307000, AlphaCoord.x), 0.182500, mix(0.000000, 0.125000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 1);\n    }\n//UV-Min:int2(0,21) | UV-Max:int2(21,33) | Real-Min:float3(0.237000,0.340000,0.000000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:3 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 21 && PixelCoord.x < 21 && PixelCoord.y < 33))//Id:9\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 21))/vec2(20, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.237000, 0.307000, AlphaCoord.y), 0.340000, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 1);\n    }\n//UV-Min:int2(0,33) | UV-Max:int2(48,54) | Real-Min:float3(0.022000,0.070000,0.000000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:3 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 33 && PixelCoord.x < 48 && PixelCoord.y < 54))//Id:15\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 33))/vec2(47, 20);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.307000, AlphaCoord.x), 0.070000, mix(0.000000, 0.125000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 2);\n    }\n//UV-Min:int2(0,54) | UV-Max:int2(21,81) | Real-Min:float3(0.307000,0.182500,0.000000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:1 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 54 && PixelCoord.x < 21 && PixelCoord.y < 81))//Id:7\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 54))/vec2(20, 26);\n        vec3 ObjectSpace_Position = vec3(0.307000, mix(0.182500, 0.340000, AlphaCoord.y), mix(0.000000, 0.125000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 1);\n    }\n//UV-Min:int2(0,81) | UV-Max:int2(48,93) | Real-Min:float3(0.022000,0.000000,0.125000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:5 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 81 && PixelCoord.x < 48 && PixelCoord.y < 93))//Id:17\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 81))/vec2(47, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.307000, AlphaCoord.x), mix(0.000000, 0.070000, AlphaCoord.y),0.125000);//2\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 2);\n    }\n//UV-Min:int2(0,93) | UV-Max:int2(42,105) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.272000,0.375000,0.000000) | FaceIndex:4 | ObjectIndex:4 | bFlip:0\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 93 && PixelCoord.x < 42 && PixelCoord.y < 105))//Id:28\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 93))/vec2(41, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.x), mix(0.305000, 0.375000, AlphaCoord.y),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 4);\n    }\n//UV-Min:int2(48,0) | UV-Max:int2(69,42) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.272000,0.144000,0.125000) | FaceIndex:2 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 48 && PixelCoord.y >= 0 && PixelCoord.x < 69 && PixelCoord.y < 42))//Id:20\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(48, 0))/vec2(20, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), 0.144000, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 3);\n    }\n//UV-Min:int2(48,42) | UV-Max:int2(69,84) | Real-Min:float3(0.022000,0.214000,0.000000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:3 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 48 && PixelCoord.y >= 42 && PixelCoord.x < 69 && PixelCoord.y < 84))//Id:21\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(48, 42))/vec2(20, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), 0.214000, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 3);\n    }\n//UV-Min:int2(0,105) | UV-Max:int2(31,126) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.000000,0.182500,0.125000) | FaceIndex:0 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 105 && PixelCoord.x < 31 && PixelCoord.y < 126))//Id:0\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 105))/vec2(30, 20);\n        vec3 ObjectSpace_Position = vec3(0.000000, mix(0.000000, 0.182500, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 0);\n    }\n//UV-Min:int2(69,0) | UV-Max:int2(81,48) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.307000,0.070000,0.000000) | FaceIndex:4 | ObjectIndex:2 | bFlip:1\n    else if((PixelCoord.x >= 69 && PixelCoord.y >= 0 && PixelCoord.x < 81 && PixelCoord.y < 48))//Id:16\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(69, 0))/vec2(11, 47);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.307000, AlphaCoord.y), mix(0.000000, 0.070000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 2);\n    }\n//UV-Min:int2(31,105) | UV-Max:int2(73,126) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.272000,0.305000,0.125000) | FaceIndex:2 | ObjectIndex:4 | bFlip:0\n    else if((PixelCoord.x >= 31 && PixelCoord.y >= 105 && PixelCoord.x < 73 && PixelCoord.y < 126))//Id:26\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(31, 105))/vec2(41, 20);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.x), 0.305000, mix(0.000000, 0.125000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 4);\n    }\n//UV-Min:int2(69,48) | UV-Max:int2(81,90) | Real-Min:float3(0.022000,0.305000,0.125000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:5 | ObjectIndex:4 | bFlip:1\n    else if((PixelCoord.x >= 69 && PixelCoord.y >= 48 && PixelCoord.x < 81 && PixelCoord.y < 90))//Id:29\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(69, 48))/vec2(11, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), mix(0.305000, 0.375000, AlphaCoord.x),0.125000);//2\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 4);\n    }\n//UV-Min:int2(12,0) | UV-Max:int2(24,21) | Real-Min:float3(0.272000,0.305000,0.000000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:1 | ObjectIndex:4 | bFlip:0\n    else if((PixelCoord.x >= 12 && PixelCoord.y >= 0 && PixelCoord.x < 24 && PixelCoord.y < 21))//Id:25\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(12, 0))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(0.272000, mix(0.305000, 0.375000, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 4);\n    }\n//UV-Min:int2(81,0) | UV-Max:int2(102,48) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.307000,0.000000,0.125000) | FaceIndex:2 | ObjectIndex:2 | bFlip:1\n    else if((PixelCoord.x >= 81 && PixelCoord.y >= 0 && PixelCoord.x < 102 && PixelCoord.y < 48))//Id:14\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(81, 0))/vec2(20, 47);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.307000, AlphaCoord.y), 0.000000, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 2);\n    }\n//UV-Min:int2(21,21) | UV-Max:int2(48,33) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.307000,0.340000,0.000000) | FaceIndex:4 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 21 && PixelCoord.y >= 21 && PixelCoord.x < 48 && PixelCoord.y < 33))//Id:10\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(21, 21))/vec2(26, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.237000, 0.307000, AlphaCoord.y), mix(0.182500, 0.340000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 1);\n    }\n//UV-Min:int2(42,93) | UV-Max:int2(73,105) | Real-Min:float3(0.000000,0.000000,0.125000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:5 | ObjectIndex:0 | bFlip:1\n    else if((PixelCoord.x >= 42 && PixelCoord.y >= 93 && PixelCoord.x < 73 && PixelCoord.y < 105))//Id:5\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(42, 93))/vec2(30, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.070000, AlphaCoord.y), mix(0.000000, 0.182500, AlphaCoord.x),0.125000);//2\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 0);\n    }\n//UV-Min:int2(21,54) | UV-Max:int2(42,66) | Real-Min:float3(0.000000,0.182500,0.000000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:3 | ObjectIndex:0 | bFlip:1\n    else if((PixelCoord.x >= 21 && PixelCoord.y >= 54 && PixelCoord.x < 42 && PixelCoord.y < 66))//Id:3\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(21, 54))/vec2(20, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.070000, AlphaCoord.y), 0.182500, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 0);\n    }\n//UV-Min:int2(24,0) | UV-Max:int2(36,21) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.022000,0.375000,0.125000) | FaceIndex:0 | ObjectIndex:4 | bFlip:0\n    else if((PixelCoord.x >= 24 && PixelCoord.y >= 0 && PixelCoord.x < 36 && PixelCoord.y < 21))//Id:24\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(24, 0))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(0.022000, mix(0.305000, 0.375000, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 4);\n    }\n//UV-Min:int2(81,48) | UV-Max:int2(93,90) | Real-Min:float3(0.022000,0.144000,0.125000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:5 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 81 && PixelCoord.y >= 48 && PixelCoord.x < 93 && PixelCoord.y < 90))//Id:23\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(81, 48))/vec2(11, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), mix(0.144000, 0.214000, AlphaCoord.x),0.125000);//2\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 3);\n    }\n//UV-Min:int2(36,0) | UV-Max:int2(48,21) | Real-Min:float3(0.307000,0.000000,0.000000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:1 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 36 && PixelCoord.y >= 0 && PixelCoord.x < 48 && PixelCoord.y < 21))//Id:13\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(36, 0))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(0.307000, mix(0.000000, 0.070000, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 2);\n    }\n//UV-Min:int2(93,48) | UV-Max:int2(114,90) | Real-Min:float3(0.022000,0.375000,0.000000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:3 | ObjectIndex:4 | bFlip:1\n    else if((PixelCoord.x >= 93 && PixelCoord.y >= 48 && PixelCoord.x < 114 && PixelCoord.y < 90))//Id:27\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(93, 48))/vec2(20, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), 0.375000, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 4);\n    }\n//UV-Min:int2(73,90) | UV-Max:int2(104,111) | Real-Min:float3(0.070000,0.000000,0.000000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:1 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 73 && PixelCoord.y >= 90 && PixelCoord.x < 104 && PixelCoord.y < 111))//Id:1\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(73, 90))/vec2(30, 20);\n        vec3 ObjectSpace_Position = vec3(0.070000, mix(0.000000, 0.182500, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 0);\n    }\n//UV-Min:int2(102,0) | UV-Max:int2(114,21) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.022000,0.070000,0.125000) | FaceIndex:0 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 102 && PixelCoord.y >= 0 && PixelCoord.x < 114 && PixelCoord.y < 21))//Id:12\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(102, 0))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(0.022000, mix(0.000000, 0.070000, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 2);\n    }\n//UV-Min:int2(21,66) | UV-Max:int2(48,78) | Real-Min:float3(0.237000,0.182500,0.125000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:5 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 21 && PixelCoord.y >= 66 && PixelCoord.x < 48 && PixelCoord.y < 78))//Id:11\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(21, 66))/vec2(26, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.237000, 0.307000, AlphaCoord.y), mix(0.182500, 0.340000, AlphaCoord.x),0.125000);//2\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 1);\n    }\n//UV-Min:int2(102,21) | UV-Max:int2(123,48) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.237000,0.340000,0.125000) | FaceIndex:0 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 102 && PixelCoord.y >= 21 && PixelCoord.x < 123 && PixelCoord.y < 48))//Id:6\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(102, 21))/vec2(20, 26);\n        vec3 ObjectSpace_Position = vec3(0.237000, mix(0.182500, 0.340000, AlphaCoord.y), mix(0.000000, 0.125000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 1);\n    }\n//UV-Min:int2(104,90) | UV-Max:int2(116,111) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.070000,0.000000,0.125000) | FaceIndex:2 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 104 && PixelCoord.y >= 90 && PixelCoord.x < 116 && PixelCoord.y < 111))//Id:2\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(104, 90))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.070000, AlphaCoord.x), 0.000000, mix(0.000000, 0.125000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 0);\n    }\n//UV-Min:int2(114,48) | UV-Max:int2(126,90) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.272000,0.214000,0.000000) | FaceIndex:4 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 114 && PixelCoord.y >= 48 && PixelCoord.x < 126 && PixelCoord.y < 90))//Id:22\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(114, 48))/vec2(11, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), mix(0.144000, 0.214000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 3);\n    }\n//UV-Min:int2(114,0) | UV-Max:int2(126,21) | Real-Min:float3(0.272000,0.144000,0.000000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:1 | ObjectIndex:3 | bFlip:0\n    else if((PixelCoord.x >= 114 && PixelCoord.y >= 0 && PixelCoord.x < 126 && PixelCoord.y < 21))//Id:19\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(114, 0))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(0.272000, mix(0.144000, 0.214000, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 3);\n    }\n//UV-Min:int2(73,111) | UV-Max:int2(94,123) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.022000,0.214000,0.125000) | FaceIndex:0 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 73 && PixelCoord.y >= 111 && PixelCoord.x < 94 && PixelCoord.y < 123))//Id:18\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(73, 111))/vec2(20, 11);\n        vec3 ObjectSpace_Position = vec3(0.022000, mix(0.144000, 0.214000, AlphaCoord.y), mix(0.000000, 0.125000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 3);\n    }\n//UV-Min:int2(116,90) | UV-Max:int2(128,121) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.070000,0.182500,0.000000) | FaceIndex:4 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 116 && PixelCoord.y >= 90 && PixelCoord.x < 128 && PixelCoord.y < 121))//Id:4\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(116, 90))/vec2(11, 30);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.070000, AlphaCoord.x), mix(0.000000, 0.182500, AlphaCoord.y),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.100000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 0);\n    }\n    else\n    {\n        return Point(vec4(0.0,0.0,0.0,-1.0), vec4(0.0,0.0,0.0,-1.0),-1,-1);\n    }\n}\n//####\n//####\nvec2 PositionToLightmap_21(Ray TempRay, float HitDistance, vec3 HitNormal, int CubeIndex)\n{\n    vec3 ObjectSpace_Position = TempRay.origin + TempRay.dir * HitDistance;\n    int FaceIndex = NormalToIndex(HitNormal);\n    int EigenIndex = FaceIndex + 6 * CubeIndex;\n//UV-Min:int2(0,0) | UV-Max:int2(12,21) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.307000,0.182500,0.125000) | FaceIndex:2 | ObjectIndex:1 | bFlip:0\n    if(EigenIndex == 8)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.237000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(0.500000, 11.500000, AlphaCoord.x), mix(0.500000, 20.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(0,21) | UV-Max:int2(21,33) | Real-Min:float3(0.237000,0.340000,0.000000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:3 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 9)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.237000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(0.500000, 20.500000, AlphaCoord.y), mix(21.500000, 32.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(0,33) | UV-Max:int2(48,54) | Real-Min:float3(0.022000,0.070000,0.000000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:3 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 15)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.285000, 0.125000);\n        return vec2(mix(0.500000, 47.500000, AlphaCoord.x), mix(33.500000, 53.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(0,54) | UV-Max:int2(21,81) | Real-Min:float3(0.307000,0.182500,0.000000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:1 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 7)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.182500, 0.000000)) / vec2(0.157500, 0.125000);\n        return vec2(mix(0.500000, 20.500000, AlphaCoord.y), mix(54.500000, 80.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(0,81) | UV-Max:int2(48,93) | Real-Min:float3(0.022000,0.000000,0.125000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:5 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 17)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.000000)) / vec2(0.285000, 0.070000);\n        return vec2(mix(0.500000, 47.500000, AlphaCoord.x), mix(81.500000, 92.500000, AlphaCoord.y));//2N\n    }\n//UV-Min:int2(0,93) | UV-Max:int2(42,105) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.272000,0.375000,0.000000) | FaceIndex:4 | ObjectIndex:4 | bFlip:0\n    else if(EigenIndex == 28)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.305000)) / vec2(0.250000, 0.070000);\n        return vec2(mix(0.500000, 41.500000, AlphaCoord.x), mix(93.500000, 104.500000, AlphaCoord.y));//2N\n    }\n//UV-Min:int2(48,0) | UV-Max:int2(69,42) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.272000,0.144000,0.125000) | FaceIndex:2 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 20)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.250000, 0.125000);\n        return vec2(mix(48.500000, 68.500000, AlphaCoord.y), mix(0.500000, 41.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(48,42) | UV-Max:int2(69,84) | Real-Min:float3(0.022000,0.214000,0.000000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:3 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 21)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.250000, 0.125000);\n        return vec2(mix(48.500000, 68.500000, AlphaCoord.y), mix(42.500000, 83.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(0,105) | UV-Max:int2(31,126) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.000000,0.182500,0.125000) | FaceIndex:0 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 0)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.182500, 0.125000);\n        return vec2(mix(0.500000, 30.500000, AlphaCoord.x), mix(105.500000, 125.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(69,0) | UV-Max:int2(81,48) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.307000,0.070000,0.000000) | FaceIndex:4 | ObjectIndex:2 | bFlip:1\n    else if(EigenIndex == 16)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.000000)) / vec2(0.285000, 0.070000);\n        return vec2(mix(69.500000, 80.500000, AlphaCoord.y), mix(0.500000, 47.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(31,105) | UV-Max:int2(73,126) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.272000,0.305000,0.125000) | FaceIndex:2 | ObjectIndex:4 | bFlip:0\n    else if(EigenIndex == 26)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.250000, 0.125000);\n        return vec2(mix(31.500000, 72.500000, AlphaCoord.x), mix(105.500000, 125.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(69,48) | UV-Max:int2(81,90) | Real-Min:float3(0.022000,0.305000,0.125000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:5 | ObjectIndex:4 | bFlip:1\n    else if(EigenIndex == 29)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.305000)) / vec2(0.250000, 0.070000);\n        return vec2(mix(69.500000, 80.500000, AlphaCoord.y), mix(48.500000, 89.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(12,0) | UV-Max:int2(24,21) | Real-Min:float3(0.272000,0.305000,0.000000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:1 | ObjectIndex:4 | bFlip:0\n    else if(EigenIndex == 25)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.305000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(12.500000, 23.500000, AlphaCoord.x), mix(0.500000, 20.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(81,0) | UV-Max:int2(102,48) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.307000,0.000000,0.125000) | FaceIndex:2 | ObjectIndex:2 | bFlip:1\n    else if(EigenIndex == 14)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.285000, 0.125000);\n        return vec2(mix(81.500000, 101.500000, AlphaCoord.y), mix(0.500000, 47.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(21,21) | UV-Max:int2(48,33) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.307000,0.340000,0.000000) | FaceIndex:4 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 10)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.237000, 0.182500)) / vec2(0.070000, 0.157500);\n        return vec2(mix(21.500000, 47.500000, AlphaCoord.y), mix(21.500000, 32.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(42,93) | UV-Max:int2(73,105) | Real-Min:float3(0.000000,0.000000,0.125000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:5 | ObjectIndex:0 | bFlip:1\n    else if(EigenIndex == 5)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.182500);\n        return vec2(mix(42.500000, 72.500000, AlphaCoord.y), mix(93.500000, 104.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(21,54) | UV-Max:int2(42,66) | Real-Min:float3(0.000000,0.182500,0.000000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:3 | ObjectIndex:0 | bFlip:1\n    else if(EigenIndex == 3)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(21.500000, 41.500000, AlphaCoord.y), mix(54.500000, 65.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(24,0) | UV-Max:int2(36,21) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.022000,0.375000,0.125000) | FaceIndex:0 | ObjectIndex:4 | bFlip:0\n    else if(EigenIndex == 24)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.305000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(24.500000, 35.500000, AlphaCoord.x), mix(0.500000, 20.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(81,48) | UV-Max:int2(93,90) | Real-Min:float3(0.022000,0.144000,0.125000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:5 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 23)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.144000)) / vec2(0.250000, 0.070000);\n        return vec2(mix(81.500000, 92.500000, AlphaCoord.y), mix(48.500000, 89.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(36,0) | UV-Max:int2(48,21) | Real-Min:float3(0.307000,0.000000,0.000000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:1 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 13)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(36.500000, 47.500000, AlphaCoord.x), mix(0.500000, 20.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(93,48) | UV-Max:int2(114,90) | Real-Min:float3(0.022000,0.375000,0.000000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:3 | ObjectIndex:4 | bFlip:1\n    else if(EigenIndex == 27)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.250000, 0.125000);\n        return vec2(mix(93.500000, 113.500000, AlphaCoord.y), mix(48.500000, 89.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(73,90) | UV-Max:int2(104,111) | Real-Min:float3(0.070000,0.000000,0.000000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:1 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 1)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.182500, 0.125000);\n        return vec2(mix(73.500000, 103.500000, AlphaCoord.x), mix(90.500000, 110.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(102,0) | UV-Max:int2(114,21) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.022000,0.070000,0.125000) | FaceIndex:0 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 12)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(102.500000, 113.500000, AlphaCoord.x), mix(0.500000, 20.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(21,66) | UV-Max:int2(48,78) | Real-Min:float3(0.237000,0.182500,0.125000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:5 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 11)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.237000, 0.182500)) / vec2(0.070000, 0.157500);\n        return vec2(mix(21.500000, 47.500000, AlphaCoord.y), mix(66.500000, 77.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(102,21) | UV-Max:int2(123,48) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.237000,0.340000,0.125000) | FaceIndex:0 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 6)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.182500, 0.000000)) / vec2(0.157500, 0.125000);\n        return vec2(mix(102.500000, 122.500000, AlphaCoord.y), mix(21.500000, 47.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(104,90) | UV-Max:int2(116,111) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.070000,0.000000,0.125000) | FaceIndex:2 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 2)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(104.500000, 115.500000, AlphaCoord.x), mix(90.500000, 110.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(114,48) | UV-Max:int2(126,90) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.272000,0.214000,0.000000) | FaceIndex:4 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 22)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.144000)) / vec2(0.250000, 0.070000);\n        return vec2(mix(114.500000, 125.500000, AlphaCoord.y), mix(48.500000, 89.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(114,0) | UV-Max:int2(126,21) | Real-Min:float3(0.272000,0.144000,0.000000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:1 | ObjectIndex:3 | bFlip:0\n    else if(EigenIndex == 19)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.144000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(114.500000, 125.500000, AlphaCoord.x), mix(0.500000, 20.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(73,111) | UV-Max:int2(94,123) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.022000,0.214000,0.125000) | FaceIndex:0 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 18)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.144000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(73.500000, 93.500000, AlphaCoord.y), mix(111.500000, 122.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(116,90) | UV-Max:int2(128,121) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.070000,0.182500,0.000000) | FaceIndex:4 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 4)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.182500);\n        return vec2(mix(116.500000, 127.500000, AlphaCoord.x), mix(90.500000, 120.500000, AlphaCoord.y));//2N\n    }\n    else\n    {\n        return vec2(0.0, 0.0);\n    }\n}\n//####\n//####\nPoint LightmapToPosition_22(vec2 UV)\n{\n    ivec2 PixelCoord = ivec2(UV);\n    mat4 RotationMatrix = rotate_y(0.000000);\n    mat4 TransposeRotationMatrix = transpose(RotationMatrix);\n//UV-Min:int2(0,0) | UV-Max:int2(42,21) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.272000,0.305000,0.125000) | FaceIndex:2 | ObjectIndex:4 | bFlip:0\n    if((PixelCoord.x >= 0 && PixelCoord.y >= 0 && PixelCoord.x < 42 && PixelCoord.y < 21))//Id:26\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 0))/vec2(41, 20);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.x), 0.305000, mix(0.000000, 0.125000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 4);\n    }\n//UV-Min:int2(0,21) | UV-Max:int2(21,63) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.272000,0.144000,0.125000) | FaceIndex:2 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 21 && PixelCoord.x < 21 && PixelCoord.y < 63))//Id:20\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 21))/vec2(20, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), 0.144000, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 3);\n    }\n//UV-Min:int2(0,63) | UV-Max:int2(21,75) | Real-Min:float3(0.000000,0.182500,0.000000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:3 | ObjectIndex:0 | bFlip:1\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 63 && PixelCoord.x < 21 && PixelCoord.y < 75))//Id:3\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 63))/vec2(20, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.070000, AlphaCoord.y), 0.182500, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 0);\n    }\n//UV-Min:int2(0,75) | UV-Max:int2(21,87) | Real-Min:float3(0.237000,0.340000,0.000000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:3 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 75 && PixelCoord.x < 21 && PixelCoord.y < 87))//Id:9\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 75))/vec2(20, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.237000, 0.307000, AlphaCoord.y), 0.340000, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 1);\n    }\n//UV-Min:int2(0,87) | UV-Max:int2(21,114) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.237000,0.340000,0.125000) | FaceIndex:0 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 87 && PixelCoord.x < 21 && PixelCoord.y < 114))//Id:6\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 87))/vec2(20, 26);\n        vec3 ObjectSpace_Position = vec3(0.237000, mix(0.182500, 0.340000, AlphaCoord.y), mix(0.000000, 0.125000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 1);\n    }\n//UV-Min:int2(21,21) | UV-Max:int2(42,63) | Real-Min:float3(0.022000,0.375000,0.000000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:3 | ObjectIndex:4 | bFlip:1\n    else if((PixelCoord.x >= 21 && PixelCoord.y >= 21 && PixelCoord.x < 42 && PixelCoord.y < 63))//Id:27\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(21, 21))/vec2(20, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), 0.375000, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 4);\n    }\n//UV-Min:int2(21,63) | UV-Max:int2(52,84) | Real-Min:float3(0.070000,0.000000,0.000000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:1 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 21 && PixelCoord.y >= 63 && PixelCoord.x < 52 && PixelCoord.y < 84))//Id:1\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(21, 63))/vec2(30, 20);\n        vec3 ObjectSpace_Position = vec3(0.070000, mix(0.000000, 0.182500, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 0);\n    }\n//UV-Min:int2(42,0) | UV-Max:int2(63,48) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.307000,0.000000,0.125000) | FaceIndex:2 | ObjectIndex:2 | bFlip:1\n    else if((PixelCoord.x >= 42 && PixelCoord.y >= 0 && PixelCoord.x < 63 && PixelCoord.y < 48))//Id:14\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(42, 0))/vec2(20, 47);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.307000, AlphaCoord.y), 0.000000, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 2);\n    }\n//UV-Min:int2(21,84) | UV-Max:int2(33,105) | Real-Min:float3(0.272000,0.144000,0.000000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:1 | ObjectIndex:3 | bFlip:0\n    else if((PixelCoord.x >= 21 && PixelCoord.y >= 84 && PixelCoord.x < 33 && PixelCoord.y < 105))//Id:19\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(21, 84))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(0.272000, mix(0.144000, 0.214000, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 3);\n    }\n//UV-Min:int2(0,114) | UV-Max:int2(21,126) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.022000,0.214000,0.125000) | FaceIndex:0 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 0 && PixelCoord.y >= 114 && PixelCoord.x < 21 && PixelCoord.y < 126))//Id:18\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(0, 114))/vec2(20, 11);\n        vec3 ObjectSpace_Position = vec3(0.022000, mix(0.144000, 0.214000, AlphaCoord.y), mix(0.000000, 0.125000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 3);\n    }\n//UV-Min:int2(33,84) | UV-Max:int2(45,126) | Real-Min:float3(0.022000,0.144000,0.125000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:5 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 33 && PixelCoord.y >= 84 && PixelCoord.x < 45 && PixelCoord.y < 126))//Id:23\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(33, 84))/vec2(11, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), mix(0.144000, 0.214000, AlphaCoord.x),0.125000);//2\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 3);\n    }\n//UV-Min:int2(45,84) | UV-Max:int2(93,105) | Real-Min:float3(0.022000,0.070000,0.000000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:3 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 45 && PixelCoord.y >= 84 && PixelCoord.x < 93 && PixelCoord.y < 105))//Id:15\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(45, 84))/vec2(47, 20);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.307000, AlphaCoord.x), 0.070000, mix(0.000000, 0.125000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 2);\n    }\n//UV-Min:int2(21,105) | UV-Max:int2(33,126) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.307000,0.182500,0.125000) | FaceIndex:2 | ObjectIndex:1 | bFlip:0\n    else if((PixelCoord.x >= 21 && PixelCoord.y >= 105 && PixelCoord.x < 33 && PixelCoord.y < 126))//Id:8\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(21, 105))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(mix(0.237000, 0.307000, AlphaCoord.x), 0.182500, mix(0.000000, 0.125000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 1);\n    }\n//UV-Min:int2(45,105) | UV-Max:int2(76,126) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.000000,0.182500,0.125000) | FaceIndex:0 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 45 && PixelCoord.y >= 105 && PixelCoord.x < 76 && PixelCoord.y < 126))//Id:0\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(45, 105))/vec2(30, 20);\n        vec3 ObjectSpace_Position = vec3(0.000000, mix(0.000000, 0.182500, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 0);\n    }\n//UV-Min:int2(63,0) | UV-Max:int2(75,42) | Real-Min:float3(0.022000,0.305000,0.125000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:5 | ObjectIndex:4 | bFlip:1\n    else if((PixelCoord.x >= 63 && PixelCoord.y >= 0 && PixelCoord.x < 75 && PixelCoord.y < 42))//Id:29\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(63, 0))/vec2(11, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), mix(0.305000, 0.375000, AlphaCoord.x),0.125000);//2\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 4);\n    }\n//UV-Min:int2(75,0) | UV-Max:int2(87,48) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.307000,0.070000,0.000000) | FaceIndex:4 | ObjectIndex:2 | bFlip:1\n    else if((PixelCoord.x >= 75 && PixelCoord.y >= 0 && PixelCoord.x < 87 && PixelCoord.y < 48))//Id:16\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(75, 0))/vec2(11, 47);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.307000, AlphaCoord.y), mix(0.000000, 0.070000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 2);\n    }\n//UV-Min:int2(42,48) | UV-Max:int2(73,60) | Real-Min:float3(0.000000,0.000000,0.125000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:5 | ObjectIndex:0 | bFlip:1\n    else if((PixelCoord.x >= 42 && PixelCoord.y >= 48 && PixelCoord.x < 73 && PixelCoord.y < 60))//Id:5\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(42, 48))/vec2(30, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.070000, AlphaCoord.y), mix(0.000000, 0.182500, AlphaCoord.x),0.125000);//2\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 0);\n    }\n//UV-Min:int2(52,60) | UV-Max:int2(64,81) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.070000,0.000000,0.125000) | FaceIndex:2 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 52 && PixelCoord.y >= 60 && PixelCoord.x < 64 && PixelCoord.y < 81))//Id:2\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(52, 60))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.070000, AlphaCoord.x), 0.000000, mix(0.000000, 0.125000, AlphaCoord.y));//1\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, -1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 2, 0);\n    }\n//UV-Min:int2(64,60) | UV-Max:int2(112,72) | Real-Min:float3(0.022000,0.000000,0.125000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:5 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 64 && PixelCoord.y >= 60 && PixelCoord.x < 112 && PixelCoord.y < 72))//Id:17\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(64, 60))/vec2(47, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.307000, AlphaCoord.x), mix(0.000000, 0.070000, AlphaCoord.y),0.125000);//2\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 2);\n    }\n//UV-Min:int2(87,0) | UV-Max:int2(108,27) | Real-Min:float3(0.307000,0.182500,0.000000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:1 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 87 && PixelCoord.y >= 0 && PixelCoord.x < 108 && PixelCoord.y < 27))//Id:7\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(87, 0))/vec2(20, 26);\n        vec3 ObjectSpace_Position = vec3(0.307000, mix(0.182500, 0.340000, AlphaCoord.y), mix(0.000000, 0.125000, AlphaCoord.x));//0\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 1);\n    }\n//UV-Min:int2(76,105) | UV-Max:int2(88,126) | Real-Min:float3(0.307000,0.000000,0.000000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:1 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 76 && PixelCoord.y >= 105 && PixelCoord.x < 88 && PixelCoord.y < 126))//Id:13\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(76, 105))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(0.307000, mix(0.000000, 0.070000, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 2);\n    }\n//UV-Min:int2(87,27) | UV-Max:int2(99,48) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.022000,0.375000,0.125000) | FaceIndex:0 | ObjectIndex:4 | bFlip:0\n    else if((PixelCoord.x >= 87 && PixelCoord.y >= 27 && PixelCoord.x < 99 && PixelCoord.y < 48))//Id:24\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(87, 27))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(0.022000, mix(0.305000, 0.375000, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 4);\n    }\n//UV-Min:int2(93,72) | UV-Max:int2(105,114) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.272000,0.214000,0.000000) | FaceIndex:4 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 93 && PixelCoord.y >= 72 && PixelCoord.x < 105 && PixelCoord.y < 114))//Id:22\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(93, 72))/vec2(11, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), mix(0.144000, 0.214000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 3);\n    }\n//UV-Min:int2(99,27) | UV-Max:int2(111,48) | Real-Min:float3(0.272000,0.305000,0.000000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:1 | ObjectIndex:4 | bFlip:0\n    else if((PixelCoord.x >= 99 && PixelCoord.y >= 27 && PixelCoord.x < 111 && PixelCoord.y < 48))//Id:25\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(99, 27))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(0.272000, mix(0.305000, 0.375000, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 1, 4);\n    }\n//UV-Min:int2(73,48) | UV-Max:int2(115,60) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.272000,0.375000,0.000000) | FaceIndex:4 | ObjectIndex:4 | bFlip:0\n    else if((PixelCoord.x >= 73 && PixelCoord.y >= 48 && PixelCoord.x < 115 && PixelCoord.y < 60))//Id:28\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(73, 48))/vec2(41, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.x), mix(0.305000, 0.375000, AlphaCoord.y),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 4);\n    }\n//UV-Min:int2(105,72) | UV-Max:int2(126,114) | Real-Min:float3(0.022000,0.214000,0.000000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:3 | ObjectIndex:3 | bFlip:1\n    else if((PixelCoord.x >= 105 && PixelCoord.y >= 72 && PixelCoord.x < 126 && PixelCoord.y < 114))//Id:21\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(105, 72))/vec2(20, 41);\n        vec3 ObjectSpace_Position = vec3(mix(0.022000, 0.272000, AlphaCoord.y), 0.214000, mix(0.000000, 0.125000, AlphaCoord.x));//1\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 1.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 3, 3);\n    }\n//UV-Min:int2(108,0) | UV-Max:int2(120,21) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.022000,0.070000,0.125000) | FaceIndex:0 | ObjectIndex:2 | bFlip:0\n    else if((PixelCoord.x >= 108 && PixelCoord.y >= 0 && PixelCoord.x < 120 && PixelCoord.y < 21))//Id:12\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(108, 0))/vec2(11, 20);\n        vec3 ObjectSpace_Position = vec3(0.022000, mix(0.000000, 0.070000, AlphaCoord.x), mix(0.000000, 0.125000, AlphaCoord.y));//0\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(-1.000000, 0.000000, 0.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 0, 2);\n    }\n//UV-Min:int2(64,72) | UV-Max:int2(91,84) | Real-Min:float3(0.237000,0.182500,0.125000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:5 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 64 && PixelCoord.y >= 72 && PixelCoord.x < 91 && PixelCoord.y < 84))//Id:11\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(64, 72))/vec2(26, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.237000, 0.307000, AlphaCoord.y), mix(0.182500, 0.340000, AlphaCoord.x),0.125000);//2\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, 1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 5, 1);\n    }\n//UV-Min:int2(88,114) | UV-Max:int2(115,126) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.307000,0.340000,0.000000) | FaceIndex:4 | ObjectIndex:1 | bFlip:1\n    else if((PixelCoord.x >= 88 && PixelCoord.y >= 114 && PixelCoord.x < 115 && PixelCoord.y < 126))//Id:10\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(88, 114))/vec2(26, 11);\n        vec3 ObjectSpace_Position = vec3(mix(0.237000, 0.307000, AlphaCoord.y), mix(0.182500, 0.340000, AlphaCoord.x),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 1);\n    }\n//UV-Min:int2(115,21) | UV-Max:int2(127,52) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.070000,0.182500,0.000000) | FaceIndex:4 | ObjectIndex:0 | bFlip:0\n    else if((PixelCoord.x >= 115 && PixelCoord.y >= 21 && PixelCoord.x < 127 && PixelCoord.y < 52))//Id:4\n    {\n        vec2 AlphaCoord = vec2(PixelCoord - ivec2(115, 21))/vec2(11, 30);\n        vec3 ObjectSpace_Position = vec3(mix(0.000000, 0.070000, AlphaCoord.x), mix(0.000000, 0.182500, AlphaCoord.y),0.000000);//2\n        vec3 WorldSpace_Position = vec3(0.450000, -0.200000, -1.000000) + vec3(TransposeRotationMatrix * vec4(ObjectSpace_Position, 1.0));\n        vec3 ObjectSpace_Normal = vec3(0.000000, 0.000000, -1.000000);\n        vec3 WorldSpace_Normal = vec3(TransposeRotationMatrix * vec4(ObjectSpace_Normal, 0.0));\n        return Point(vec4(WorldSpace_Position, 1.0),vec4(WorldSpace_Normal, 1.0), 4, 0);\n    }\n    else\n    {\n        return Point(vec4(0.0,0.0,0.0,-1.0), vec4(0.0,0.0,0.0,-1.0),-1,-1);\n    }\n}\n//####\n//####\nvec2 PositionToLightmap_22(Ray TempRay, float HitDistance, vec3 HitNormal, int CubeIndex)\n{\n    vec3 ObjectSpace_Position = TempRay.origin + TempRay.dir * HitDistance;\n    int FaceIndex = NormalToIndex(HitNormal);\n    int EigenIndex = FaceIndex + 6 * CubeIndex;\n//UV-Min:int2(0,0) | UV-Max:int2(42,21) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.272000,0.305000,0.125000) | FaceIndex:2 | ObjectIndex:4 | bFlip:0\n    if(EigenIndex == 26)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.250000, 0.125000);\n        return vec2(mix(0.500000, 41.500000, AlphaCoord.x), mix(0.500000, 20.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(0,21) | UV-Max:int2(21,63) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.272000,0.144000,0.125000) | FaceIndex:2 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 20)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.250000, 0.125000);\n        return vec2(mix(0.500000, 20.500000, AlphaCoord.y), mix(21.500000, 62.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(0,63) | UV-Max:int2(21,75) | Real-Min:float3(0.000000,0.182500,0.000000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:3 | ObjectIndex:0 | bFlip:1\n    else if(EigenIndex == 3)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(0.500000, 20.500000, AlphaCoord.y), mix(63.500000, 74.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(0,75) | UV-Max:int2(21,87) | Real-Min:float3(0.237000,0.340000,0.000000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:3 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 9)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.237000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(0.500000, 20.500000, AlphaCoord.y), mix(75.500000, 86.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(0,87) | UV-Max:int2(21,114) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.237000,0.340000,0.125000) | FaceIndex:0 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 6)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.182500, 0.000000)) / vec2(0.157500, 0.125000);\n        return vec2(mix(0.500000, 20.500000, AlphaCoord.y), mix(87.500000, 113.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(21,21) | UV-Max:int2(42,63) | Real-Min:float3(0.022000,0.375000,0.000000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:3 | ObjectIndex:4 | bFlip:1\n    else if(EigenIndex == 27)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.250000, 0.125000);\n        return vec2(mix(21.500000, 41.500000, AlphaCoord.y), mix(21.500000, 62.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(21,63) | UV-Max:int2(52,84) | Real-Min:float3(0.070000,0.000000,0.000000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:1 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 1)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.182500, 0.125000);\n        return vec2(mix(21.500000, 51.500000, AlphaCoord.x), mix(63.500000, 83.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(42,0) | UV-Max:int2(63,48) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.307000,0.000000,0.125000) | FaceIndex:2 | ObjectIndex:2 | bFlip:1\n    else if(EigenIndex == 14)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.285000, 0.125000);\n        return vec2(mix(42.500000, 62.500000, AlphaCoord.y), mix(0.500000, 47.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(21,84) | UV-Max:int2(33,105) | Real-Min:float3(0.272000,0.144000,0.000000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:1 | ObjectIndex:3 | bFlip:0\n    else if(EigenIndex == 19)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.144000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(21.500000, 32.500000, AlphaCoord.x), mix(84.500000, 104.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(0,114) | UV-Max:int2(21,126) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.022000,0.214000,0.125000) | FaceIndex:0 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 18)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.144000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(0.500000, 20.500000, AlphaCoord.y), mix(114.500000, 125.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(33,84) | UV-Max:int2(45,126) | Real-Min:float3(0.022000,0.144000,0.125000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:5 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 23)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.144000)) / vec2(0.250000, 0.070000);\n        return vec2(mix(33.500000, 44.500000, AlphaCoord.y), mix(84.500000, 125.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(45,84) | UV-Max:int2(93,105) | Real-Min:float3(0.022000,0.070000,0.000000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:3 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 15)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.285000, 0.125000);\n        return vec2(mix(45.500000, 92.500000, AlphaCoord.x), mix(84.500000, 104.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(21,105) | UV-Max:int2(33,126) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.307000,0.182500,0.125000) | FaceIndex:2 | ObjectIndex:1 | bFlip:0\n    else if(EigenIndex == 8)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.237000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(21.500000, 32.500000, AlphaCoord.x), mix(105.500000, 125.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(45,105) | UV-Max:int2(76,126) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.000000,0.182500,0.125000) | FaceIndex:0 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 0)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.182500, 0.125000);\n        return vec2(mix(45.500000, 75.500000, AlphaCoord.x), mix(105.500000, 125.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(63,0) | UV-Max:int2(75,42) | Real-Min:float3(0.022000,0.305000,0.125000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:5 | ObjectIndex:4 | bFlip:1\n    else if(EigenIndex == 29)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.305000)) / vec2(0.250000, 0.070000);\n        return vec2(mix(63.500000, 74.500000, AlphaCoord.y), mix(0.500000, 41.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(75,0) | UV-Max:int2(87,48) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.307000,0.070000,0.000000) | FaceIndex:4 | ObjectIndex:2 | bFlip:1\n    else if(EigenIndex == 16)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.000000)) / vec2(0.285000, 0.070000);\n        return vec2(mix(75.500000, 86.500000, AlphaCoord.y), mix(0.500000, 47.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(42,48) | UV-Max:int2(73,60) | Real-Min:float3(0.000000,0.000000,0.125000) | Real-Max:float3(0.070000,0.182500,0.125000) | FaceIndex:5 | ObjectIndex:0 | bFlip:1\n    else if(EigenIndex == 5)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.182500);\n        return vec2(mix(42.500000, 72.500000, AlphaCoord.y), mix(48.500000, 59.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(52,60) | UV-Max:int2(64,81) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.070000,0.000000,0.125000) | FaceIndex:2 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 2)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(52.500000, 63.500000, AlphaCoord.x), mix(60.500000, 80.500000, AlphaCoord.y));//1N\n    }\n//UV-Min:int2(64,60) | UV-Max:int2(112,72) | Real-Min:float3(0.022000,0.000000,0.125000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:5 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 17)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.000000)) / vec2(0.285000, 0.070000);\n        return vec2(mix(64.500000, 111.500000, AlphaCoord.x), mix(60.500000, 71.500000, AlphaCoord.y));//2N\n    }\n//UV-Min:int2(87,0) | UV-Max:int2(108,27) | Real-Min:float3(0.307000,0.182500,0.000000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:1 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 7)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.182500, 0.000000)) / vec2(0.157500, 0.125000);\n        return vec2(mix(87.500000, 107.500000, AlphaCoord.y), mix(0.500000, 26.500000, AlphaCoord.x));//0F\n    }\n//UV-Min:int2(76,105) | UV-Max:int2(88,126) | Real-Min:float3(0.307000,0.000000,0.000000) | Real-Max:float3(0.307000,0.070000,0.125000) | FaceIndex:1 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 13)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(76.500000, 87.500000, AlphaCoord.x), mix(105.500000, 125.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(87,27) | UV-Max:int2(99,48) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.022000,0.375000,0.125000) | FaceIndex:0 | ObjectIndex:4 | bFlip:0\n    else if(EigenIndex == 24)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.305000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(87.500000, 98.500000, AlphaCoord.x), mix(27.500000, 47.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(93,72) | UV-Max:int2(105,114) | Real-Min:float3(0.022000,0.144000,0.000000) | Real-Max:float3(0.272000,0.214000,0.000000) | FaceIndex:4 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 22)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.144000)) / vec2(0.250000, 0.070000);\n        return vec2(mix(93.500000, 104.500000, AlphaCoord.y), mix(72.500000, 113.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(99,27) | UV-Max:int2(111,48) | Real-Min:float3(0.272000,0.305000,0.000000) | Real-Max:float3(0.272000,0.375000,0.125000) | FaceIndex:1 | ObjectIndex:4 | bFlip:0\n    else if(EigenIndex == 25)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.305000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(99.500000, 110.500000, AlphaCoord.x), mix(27.500000, 47.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(73,48) | UV-Max:int2(115,60) | Real-Min:float3(0.022000,0.305000,0.000000) | Real-Max:float3(0.272000,0.375000,0.000000) | FaceIndex:4 | ObjectIndex:4 | bFlip:0\n    else if(EigenIndex == 28)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.022000, 0.305000)) / vec2(0.250000, 0.070000);\n        return vec2(mix(73.500000, 114.500000, AlphaCoord.x), mix(48.500000, 59.500000, AlphaCoord.y));//2N\n    }\n//UV-Min:int2(105,72) | UV-Max:int2(126,114) | Real-Min:float3(0.022000,0.214000,0.000000) | Real-Max:float3(0.272000,0.214000,0.125000) | FaceIndex:3 | ObjectIndex:3 | bFlip:1\n    else if(EigenIndex == 21)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xz - vec2(0.022000, 0.000000)) / vec2(0.250000, 0.125000);\n        return vec2(mix(105.500000, 125.500000, AlphaCoord.y), mix(72.500000, 113.500000, AlphaCoord.x));//1F\n    }\n//UV-Min:int2(108,0) | UV-Max:int2(120,21) | Real-Min:float3(0.022000,0.000000,0.000000) | Real-Max:float3(0.022000,0.070000,0.125000) | FaceIndex:0 | ObjectIndex:2 | bFlip:0\n    else if(EigenIndex == 12)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.yz - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.125000);\n        return vec2(mix(108.500000, 119.500000, AlphaCoord.x), mix(0.500000, 20.500000, AlphaCoord.y));//0N\n    }\n//UV-Min:int2(64,72) | UV-Max:int2(91,84) | Real-Min:float3(0.237000,0.182500,0.125000) | Real-Max:float3(0.307000,0.340000,0.125000) | FaceIndex:5 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 11)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.237000, 0.182500)) / vec2(0.070000, 0.157500);\n        return vec2(mix(64.500000, 90.500000, AlphaCoord.y), mix(72.500000, 83.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(88,114) | UV-Max:int2(115,126) | Real-Min:float3(0.237000,0.182500,0.000000) | Real-Max:float3(0.307000,0.340000,0.000000) | FaceIndex:4 | ObjectIndex:1 | bFlip:1\n    else if(EigenIndex == 10)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.237000, 0.182500)) / vec2(0.070000, 0.157500);\n        return vec2(mix(88.500000, 114.500000, AlphaCoord.y), mix(114.500000, 125.500000, AlphaCoord.x));//2F\n    }\n//UV-Min:int2(115,21) | UV-Max:int2(127,52) | Real-Min:float3(0.000000,0.000000,0.000000) | Real-Max:float3(0.070000,0.182500,0.000000) | FaceIndex:4 | ObjectIndex:0 | bFlip:0\n    else if(EigenIndex == 4)\n    {\n        vec2 AlphaCoord = vec2(ObjectSpace_Position.xy - vec2(0.000000, 0.000000)) / vec2(0.070000, 0.182500);\n        return vec2(mix(115.500000, 126.500000, AlphaCoord.x), mix(21.500000, 51.500000, AlphaCoord.y));//2N\n    }\n    else\n    {\n        return vec2(0.0, 0.0);\n    }\n}\n//####\nvec2 PositionToLightmap_L(vec3 Position)\n{\n    return (Position.zy *0.5 + vec2(0.5,0.5))*vec2(63.0,127.0) + vec2(0.5,0.5);\n}\nPoint LightmapToPosition_L(vec2 UV)\n{\n    UV = floor(UV);\n    return Point(vec4( -1.0, (UV.yx/vec2(127.0,63.0)-vec2(0.5,0.5))*2.0 , 1.0),vec4(vec3(1.0,0.0,0.0), 1.0), 0, 0);\n}\nvec2 PositionToLightmap_R(vec3 Position)\n{\n    return (Position.zy *0.5 + vec2(0.5,0.5))*vec2(63.0,127.0) + vec2(0.5,0.5);\n}\nPoint LightmapToPosition_R(vec2 UV)\n{\n    UV = floor(UV);\n    return Point(vec4( 1.0, (UV.yx/vec2(127.0,63.0)-vec2(0.5,0.5))*2.0 , 1.0),vec4(vec3(-1.0,0.0,0.0), 1.0), 0, 0);\n}\n\nvec2 PositionToLightmap_B(vec3 Position)\n{\n    return (Position.xy *0.5 + vec2(0.5,0.5))*255.0 + vec2(0.5,0.5);\n}\nPoint LightmapToPosition_B(vec2 UV)\n{\n    UV = floor(UV);\n    return Point(vec4((UV/255.0-vec2(0.5,0.5))*2.0 , -1.0,  1.0),vec4(vec3(0.0,0.0,1.0), 1.0), 0, 0);\n}\n\nvec2 PositionToLightmap_U(vec3 Position)\n{\n    return (Position.xz *0.5 + vec2(0.5,0.5))*127.0 + vec2(0.5,0.5);\n}\nPoint LightmapToPosition_U(vec2 UV)\n{\n    UV = floor(UV);\n    return Point(vec4((UV/127.0-vec2(0.5,0.5)).x*2.0 , 1.0, (UV/127.0-vec2(0.5,0.5)).y*2.0,1.0),vec4(vec3(0.0,-1.0,0.0), 1.0), 0, 0);\n}\nvec2 PositionToLightmap_D(vec3 Position)\n{\n    return (Position.xz *0.5 + vec2(0.5,0.5))*vec2(255,127.0) + vec2(0.5,0.5);\n}\nPoint LightmapToPosition_D(vec2 UV)\n{\n    UV = floor(UV);\n    return Point(vec4((UV/vec2(255,127.0)-vec2(0.5,0.5)).x*2.0 , -1.0, (UV/vec2(255,127.0)-vec2(0.5,0.5)).y*2.0,1.0),vec4(vec3(0.0,1.0,0.0), 1.0), 0, 0);\n}\n\n//////////////////////////////////////////////\n\n//////////////////////////////////////////////\n#pragma optimize(off)\nvec3 Lightmap_Render_LRBU22(const vec3 view_0, const Hidden hidden)\n{\nvec4 L3_0 = hidden.H_0;\nvec4 L3_1 = hidden.H_1;\nvec4 L3_2 = hidden.H_2;\nvec4 L3_3 = hidden.H_3;\nvec4 L3_4 = hidden.H_4;\nvec4 L3_5 = hidden.H_5;\nvec4 L3_6 = hidden.H_6;\nvec4 L3_7 = hidden.H_7;\nvec4 L3_8 = sin(60.000000 * (mat3x4(-0.321636,0.115784,0.075929,0.297330,0.004566,-0.231396,0.153740,-0.167359,0.004409,0.188636,0.105527,0.176368) * view_0 + vec4(0.264561,-0.210913,0.095155,-0.039588)));\nvec4 L3_9 = sin(60.000000 * (mat3x4(0.203742,-0.132912,-0.015002,0.159725,0.158575,0.163523,-0.224692,-0.003754,-0.198486,-0.010890,0.048867,0.000970) * view_0 + vec4(0.179271,0.035856,-0.450121,0.160181)));\nvec4 L4_0 = sin((mat4(0.212724,0.499688,-0.420443,-0.244629,-0.150422,0.250958,-0.104852,-0.097681,0.007542,-0.241142,-0.035762,0.081732,-0.071136,-0.072524,-0.293121,-0.267159) * L3_0 + mat4(0.035507,0.177740,-0.307044,-0.284070,-0.132807,-0.132940,0.057605,-0.155572,-0.100750,0.314475,0.109351,-0.275649,0.014840,-0.192239,0.217300,-0.207779) * L3_1 + mat4(-0.232272,0.039359,-0.042947,-0.063442,-0.395893,0.196494,0.186377,-0.242821,0.215955,-0.067279,0.205637,0.020331,0.223151,-0.340200,0.493645,0.116135) * L3_2 + mat4(-0.117530,0.272939,0.062260,-0.114027,0.118471,-0.155542,0.025188,0.112258,0.110410,-0.042122,0.033256,0.060512,-0.003434,-0.031700,0.386413,-0.017952) * L3_3 + mat4(0.062549,0.311318,0.074411,-0.325208,-0.022040,0.109149,0.156207,-0.190190,-0.087249,-0.041189,-0.529981,0.095972,0.276577,0.357292,-0.105548,0.068323) * L3_4 + mat4(-0.267993,-0.238591,-0.006611,0.110483,-0.279755,0.744764,0.110180,-0.054951,-0.113487,-0.059870,-0.135941,0.158407,0.433187,0.010076,0.230787,-0.112410) * L3_5 + mat4(-0.140628,-0.031754,0.515925,0.330062,-0.090230,-0.107655,-0.046688,-0.036831,-0.022701,0.096017,-0.122297,0.119173,0.025483,0.494070,0.248974,-0.219068) * L3_6 + mat4(-0.097235,0.099798,-0.512348,-0.430929,-0.047221,0.018424,0.142416,0.071591,0.260793,0.209341,0.469768,0.354374,-0.026720,0.315621,-0.015851,0.174419) * L3_7 + mat4(-0.334452,-0.075876,-0.042870,0.201455,-0.005094,0.020369,-0.140297,-0.180580,0.248251,0.077091,-0.152150,0.334201,0.023061,0.035879,0.072076,0.116549) * L3_8 + mat4(0.033985,-0.091296,0.025512,0.088782,0.020946,-0.023381,0.122015,-0.223822,0.185619,0.378529,0.056019,-0.880780,-0.161691,0.245913,-0.372020,0.300991) * L3_9 + vec4(0.186728,0.486795,-0.498352,-0.632135)));\nvec4 L4_1 = sin((mat4(0.652999,-0.189806,0.020908,-0.344774,-0.067864,0.205556,0.021219,-0.136504,0.307784,0.146302,0.079769,0.537971,-0.221461,-0.135594,-0.027677,0.034780) * L3_0 + mat4(-0.217510,-0.245483,-0.025218,0.042196,0.065169,-0.102474,-0.160728,0.353589,0.125579,-0.225793,-0.160230,-0.074547,0.018234,0.148011,-0.161118,-0.305407) * L3_1 + mat4(0.336047,0.074813,0.097702,-0.460553,-0.215896,-0.145457,0.204535,-0.303028,-0.151470,-0.001213,0.334167,0.301318,-0.377521,0.467780,-0.295187,0.374795) * L3_2 + mat4(0.025711,0.211448,0.278246,0.265954,0.181494,-0.095957,0.043913,0.171740,0.136662,0.064991,0.022280,0.371410,0.238573,0.366920,-0.371720,0.376865) * L3_3 + mat4(-0.366415,-0.448651,-0.233522,-0.475556,0.460356,0.479943,-0.045161,0.000658,-0.113603,-0.374397,0.017262,0.198289,-0.384275,0.021914,-0.405239,-0.045659) * L3_4 + mat4(0.244267,-0.133324,-0.166217,-0.248842,-0.253353,-0.048224,0.099745,0.439242,-0.006878,0.070610,-0.313253,0.048630,0.217975,-0.041620,0.096650,0.119196) * L3_5 + mat4(0.002678,0.302776,-0.078594,-0.060506,-0.113969,0.021092,-0.157938,0.029670,0.644223,0.321878,0.027110,-0.020942,-0.084110,0.059698,-0.254440,0.228360) * L3_6 + mat4(0.358170,-0.599452,0.333611,0.339000,0.167857,-0.023488,0.349279,0.138424,0.139466,-0.173744,0.541402,0.453257,0.058620,0.142746,0.276170,-0.364865) * L3_7 + mat4(-0.039773,0.066717,-0.236680,0.021546,-0.106454,-0.207811,-0.029979,0.128929,-0.140588,0.100760,0.137544,-0.159059,-0.112439,-0.001321,0.157102,-0.021853) * L3_8 + mat4(-0.259574,-0.193943,-0.039692,0.116454,-0.041811,0.516637,0.369689,-0.058761,-0.138728,-0.088397,-0.239248,-0.252977,0.018910,-0.004416,0.239596,-0.166837) * L3_9 + vec4(0.186845,-0.393278,0.420781,-0.368178)));\nvec4 L4_2 = sin((mat4(-0.167457,0.442363,-0.357390,0.037876,0.039663,-0.091368,-0.060933,-0.049513,-0.107977,-0.189407,0.117588,0.145490,0.103718,0.216360,-0.000005,0.326224) * L3_0 + mat4(-0.009706,-0.101286,-0.186154,-0.091638,0.217411,0.111231,-0.230591,0.153628,-0.000232,-0.039849,0.073883,-0.167897,-0.270738,-0.295149,0.263287,0.096475) * L3_1 + mat4(-0.236379,0.423005,-0.129240,-0.084991,0.489626,-0.072159,-0.020903,-0.202554,0.327887,0.077590,-0.184492,0.219792,-0.014057,0.248041,0.500683,0.415551) * L3_2 + mat4(0.207377,0.279268,-0.067708,0.018735,0.128645,-0.144540,0.100781,0.117683,-0.188850,-0.142596,0.164407,-0.083432,0.077175,0.217228,0.265570,0.502363) * L3_3 + mat4(-0.393870,0.313838,-0.342097,-0.154573,0.025455,0.180697,0.246648,0.407271,-0.171273,0.129520,-0.015852,-0.106040,0.132343,0.089331,-0.183755,-0.247642) * L3_4 + mat4(-0.086617,-0.239099,0.085797,0.059431,-0.421902,-0.122925,0.420612,0.408679,-0.090121,-0.147197,-0.227764,0.129444,0.372332,0.144394,-0.143100,-0.058028) * L3_5 + mat4(0.167749,0.305153,-0.048167,0.229030,0.093680,-0.104926,0.164906,0.000301,0.039690,-0.109015,0.193173,-0.033456,-0.433923,-0.525358,-0.177928,0.023917) * L3_6 + mat4(-0.014097,0.066675,0.589471,0.271852,0.194580,-0.115596,0.206725,-0.107898,-0.127119,0.037269,-0.487846,-0.140476,0.271984,-0.215809,-0.431181,0.437100) * L3_7 + mat4(-0.123616,-0.064845,0.049758,0.089399,0.283926,0.121827,0.305323,-0.013978,-0.114824,-0.321037,-0.239930,-0.095915,0.041903,-0.005027,-0.139939,0.018061) * L3_8 + mat4(-0.039051,0.191713,-0.098504,-0.085431,-0.280293,-0.115136,-0.339567,-0.104553,0.333060,-0.276333,0.690681,-0.103656,0.046924,0.340145,-0.437273,0.018196) * L3_9 + vec4(0.574971,-0.174500,-1.034482,0.473500)));\nvec4 L4_3 = sin((mat4(-0.019673,-0.158781,-0.323807,0.002131,0.269100,-0.023266,-0.043345,-0.161645,-0.095613,-0.492496,0.106089,0.482327,-0.091323,-0.304781,-0.128417,-0.162303) * L3_0 + mat4(0.131759,-0.035984,0.032918,0.541871,0.297868,-0.252811,-0.070689,-0.092312,0.142183,-0.326235,-0.000624,0.127253,0.055045,0.119191,-0.014498,0.098999) * L3_1 + mat4(-0.233430,0.017485,-0.067654,-0.323853,0.078919,0.186032,-0.094316,0.241424,-0.107325,-0.037892,0.282979,-0.290513,0.228615,-0.030205,0.080736,0.315920) * L3_2 + mat4(0.047386,0.015521,-0.002936,0.126107,0.039537,-0.068562,-0.256904,-0.165978,0.106280,0.007300,-0.103620,-0.368065,0.119508,-0.382067,0.016759,0.702642) * L3_3 + mat4(0.032380,-0.002729,-0.272228,-0.199208,-0.137236,0.236572,0.032933,-0.325925,0.047236,-0.038137,0.067126,-0.100829,-0.217477,-0.518732,0.246617,0.136266) * L3_4 + mat4(0.136161,-0.057155,0.108329,-0.046547,-0.415976,-0.121970,0.050399,0.162578,-0.079142,0.300144,-0.068416,0.207396,0.669493,-0.036956,0.075081,0.000140) * L3_5 + mat4(0.146291,0.334552,0.392123,0.097585,-0.021736,-0.083163,0.110152,0.026278,-0.087243,0.088958,0.101498,-0.328468,0.002133,0.153673,-0.312740,-0.113133) * L3_6 + mat4(0.033248,0.055172,0.170107,-0.162316,-0.015446,-0.142783,-0.150942,0.016169,-0.067649,-0.063057,-0.152835,-0.133344,-0.320646,0.010114,0.428602,-0.511333) * L3_7 + mat4(-0.223803,-0.568396,-0.043468,0.072645,0.176814,-0.013492,-0.193339,-0.193113,-0.280519,0.340415,-0.039158,0.049917,-0.054374,0.047950,0.006624,0.084849) * L3_8 + mat4(0.115123,-0.012904,0.069858,-0.001905,-0.258541,-0.236828,-0.040300,0.201396,-0.655839,0.225536,-0.485927,0.027165,-0.128935,-0.121966,-0.065301,-0.338265) * L3_9 + vec4(-0.212670,0.024890,0.302818,0.433537)));\nvec4 L4_4 = sin((mat4(0.180226,-0.134684,0.476181,0.009675,0.089518,0.113515,0.124578,-0.062382,-0.355913,0.213911,0.404084,0.302515,-0.326773,-0.017425,-0.185355,-0.258797) * L3_0 + mat4(0.099754,-0.383033,0.624083,0.337339,0.184309,0.279466,-0.084313,-0.058685,-0.132140,-0.214886,-0.307166,-0.132248,-0.049949,0.114865,0.485265,0.066190) * L3_1 + mat4(0.441657,-0.078869,0.052569,0.033904,0.345169,-0.161503,0.109633,0.335699,0.109854,-0.018186,-0.052178,0.067190,0.231186,0.088992,-0.405121,-0.104917) * L3_2 + mat4(-0.143535,-0.388079,0.293006,-0.201958,0.105536,0.044743,0.150872,-0.179283,0.089070,-0.241082,-0.048390,-0.206575,-0.365155,0.087612,-0.064408,0.022610) * L3_3 + mat4(-0.013054,0.277359,0.147003,-0.505218,-0.330755,0.002171,0.174780,-0.235404,0.287720,0.094782,-0.583161,-0.105180,-0.358331,0.292575,-0.153221,-0.467332) * L3_4 + mat4(-0.088390,0.368187,-0.024484,0.105558,-0.101283,0.179946,0.002998,-0.047090,0.044624,-0.133266,-0.646564,0.484552,-0.131527,-0.244890,0.215841,-0.264058) * L3_5 + mat4(0.425003,0.133227,0.151995,-0.378446,-0.214446,0.071511,-0.044809,-0.159657,-0.228869,-0.160713,-0.293974,0.255119,-0.136811,0.067416,0.230584,0.105719) * L3_6 + mat4(0.003774,-0.328494,-0.252409,-0.538947,-0.185434,0.022515,0.094227,-0.074241,0.213279,0.268613,-0.592552,-0.187379,0.023407,-0.042789,0.308208,-0.115139) * L3_7 + mat4(0.579296,-0.136890,-0.223833,-0.004824,-0.077952,-0.010719,-0.496305,-0.031910,0.189585,0.290104,0.305318,-0.035919,-0.019530,0.030246,0.101079,0.026876) * L3_8 + mat4(-0.200378,-0.187860,-0.354501,0.004700,-0.296781,-0.003775,0.417523,-0.100951,0.162606,-0.142893,0.241175,0.247706,0.483111,0.469813,0.303064,0.077615) * L3_9 + vec4(0.249900,0.591695,-0.104335,-0.507004)));\nvec4 L4_5 = sin((mat4(0.061404,0.196605,0.453229,-0.184967,0.228603,-0.293247,-0.013310,-0.137987,-0.426071,-0.073466,-0.525669,0.048265,0.110191,-0.038285,-0.009049,-0.017769) * L3_0 + mat4(0.242901,0.048384,-0.124609,0.006735,-0.244626,0.438891,0.169598,0.098107,0.116034,-0.222923,-0.174457,-0.214821,-0.009520,0.276574,0.090883,0.025863) * L3_1 + mat4(-0.080195,0.040109,-0.309738,-0.296691,0.272018,-0.015054,0.030835,0.426693,0.119772,-0.083237,0.148443,-0.039847,0.238230,-0.135263,-0.100814,0.276052) * L3_2 + mat4(0.385048,0.382709,-0.088856,-0.245175,0.113977,0.258817,0.038668,-0.084820,0.203552,0.041194,0.293542,0.021885,0.281761,0.099874,0.195505,-0.008633) * L3_3 + mat4(0.285961,0.172877,0.103099,-0.048887,0.025504,0.115044,0.094346,0.263155,0.180321,0.143607,-0.028428,-0.080254,-0.009976,-0.106746,0.296171,0.268436) * L3_4 + mat4(-0.172648,-0.005444,-0.044343,0.416086,-0.244823,-0.102413,-0.033192,0.038854,0.139180,-0.053273,-0.313029,-0.334042,0.045106,-0.400087,-0.290863,0.155427) * L3_5 + mat4(-0.406886,0.200275,0.090893,-0.077819,0.079760,0.106187,-0.020972,-0.128615,-0.013552,0.213746,-0.083189,0.216177,-0.060860,0.084179,0.258715,-0.202549) * L3_6 + mat4(-0.235832,0.568013,-0.507793,0.659126,0.051872,-0.312286,0.325820,-0.189195,0.091442,0.304836,-0.198601,-0.044158,0.122059,-0.171253,0.547384,-0.032229) * L3_7 + mat4(-0.225855,-0.333720,0.113560,-0.088836,-0.018065,-0.095193,-0.019616,0.242920,-0.021281,0.120473,0.239614,0.194965,-0.091281,0.058434,-0.046675,0.127199) * L3_8 + mat4(-0.194768,-0.132804,-0.027669,0.073217,-0.088466,-0.167341,0.222152,-0.173804,-0.483923,-0.115252,-0.088182,-0.167432,-0.226710,-0.405521,0.119505,0.509695) * L3_9 + vec4(-0.292521,-0.240776,-0.014476,-0.160579)));\nvec4 L4_6 = sin((mat4(0.138888,-0.004066,-0.011599,-0.215796,-0.130920,0.007150,-0.063569,-0.132820,0.367059,0.226737,-0.098982,-0.188437,-0.063607,-0.148677,-0.093411,0.223979) * L3_0 + mat4(-0.210804,0.085921,-0.064650,-0.148535,-0.220866,0.056979,-0.269835,-0.157301,-0.288382,0.130237,0.340019,-0.040953,0.159605,-0.109851,0.258566,-0.237864) * L3_1 + mat4(-0.183496,0.059564,0.235559,-0.119578,0.329523,-0.111873,0.100648,0.213934,0.049602,-0.153435,0.028136,0.000418,0.290022,0.332294,-0.178587,-0.017419) * L3_2 + mat4(-0.152696,-0.734025,-0.028762,-0.121308,-0.170468,0.144921,0.553577,-0.214740,-0.172964,-0.178945,0.250091,-0.228413,0.061342,0.418321,-0.078303,0.020759) * L3_3 + mat4(0.425320,0.242052,-0.214817,-0.022072,-0.050902,0.290125,0.020234,-0.181253,0.077384,-0.317244,0.214979,-0.266036,0.151957,0.318278,-0.120694,-0.091920) * L3_4 + mat4(-0.043532,-0.404221,0.265223,0.310366,0.157312,-0.268673,0.186196,-0.199726,-0.095826,-0.156052,-0.131504,-0.491982,-0.119545,-0.052237,-0.208935,-0.029973) * L3_5 + mat4(-0.055578,-0.096858,0.407572,0.197191,0.054622,0.254296,0.003355,0.087405,0.352869,-0.032560,0.175843,-0.087351,0.285897,0.038300,0.188571,0.216403) * L3_6 + mat4(-0.330676,0.043101,0.120746,0.402105,-0.064612,-0.239700,0.025810,-0.118531,0.076541,-0.081799,-0.166320,0.411678,-0.275015,0.258204,0.189619,0.232278) * L3_7 + mat4(0.072461,0.012942,-0.035772,-0.089495,-0.239567,0.087363,0.067499,-0.033818,0.179108,-0.201188,-0.142918,-0.226154,-0.005621,0.022743,0.007779,0.021107) * L3_8 + mat4(0.029608,0.034880,-0.030186,-0.161131,0.130587,-0.276169,0.018967,-0.060395,0.110687,0.108020,-0.114775,-0.069437,-0.435221,0.131811,0.533234,-0.257829) * L3_9 + vec4(0.177943,-0.024138,-0.282213,-0.230768)));\nvec4 L4_7 = sin((mat4(0.356183,0.095099,-0.162970,-0.195309,-0.129036,-0.174149,-0.226271,-0.081087,-0.029629,-0.077820,-0.134700,0.039460,-0.289463,0.166402,-0.042363,0.112979) * L3_0 + mat4(-0.108292,0.129424,0.034357,-0.103813,-0.425111,0.308024,0.051998,-0.028265,-0.181232,0.479786,0.031916,0.185425,0.012686,-0.267076,0.288551,0.323263) * L3_1 + mat4(-0.103279,0.151345,0.059857,-0.115700,0.090021,0.058885,-0.081174,-0.010395,-0.135065,-0.022554,-0.083595,0.045172,-0.219584,0.188088,0.236435,-0.136536) * L3_2 + mat4(0.110751,0.093507,0.012763,-0.020674,0.232961,0.221983,-0.082427,0.086161,0.123567,-0.060599,-0.152623,-0.126434,0.166726,0.065666,0.019739,0.279650) * L3_3 + mat4(0.096488,-0.187446,0.062641,0.264020,0.059260,0.163319,-0.336816,-0.296637,0.161341,0.156559,0.220226,0.106207,0.132154,-0.208977,0.031273,-0.398561) * L3_4 + mat4(-0.137011,0.255798,-0.271626,0.048585,0.044957,-0.309461,-0.090940,-0.145839,0.257208,0.248176,-0.145673,-0.328062,-0.273179,-0.277748,-0.061819,0.364124) * L3_5 + mat4(0.011094,0.075702,0.208671,-0.033919,-0.125691,0.004638,0.027117,-0.235430,-0.075048,-0.117723,0.267356,-0.115714,-0.337910,0.241162,0.041094,-0.004296) * L3_6 + mat4(-0.687792,-0.036408,-0.057539,0.036411,0.132357,0.091183,0.262240,-0.019298,0.010692,0.057875,-0.157951,0.109801,0.074251,0.341119,-0.138698,0.212237) * L3_7 + mat4(-0.312569,-0.219905,0.004432,-0.006270,-0.227582,0.036798,-0.000821,-0.042141,0.062616,-0.119034,0.039330,-0.012547,0.007043,0.017474,-0.019431,-0.016923) * L3_8 + mat4(-0.039157,0.094668,0.018462,-0.066639,-0.087742,0.200816,0.110138,-0.096592,-0.665706,-0.511531,-0.344666,0.046677,-0.180848,0.025787,0.014322,-0.313736) * L3_9 + vec4(-0.145623,-0.288164,-0.075662,-0.357603)));\nvec4 L4_8 = sin((mat4(-0.016366,0.014248,0.036202,-0.019833,-0.062436,-0.068480,0.389747,0.078173,-0.005459,0.507126,0.072816,-0.197644,-0.111381,0.054137,-0.032921,-0.216286) * L3_0 + mat4(0.211614,0.470686,-0.492769,0.076200,-0.041327,-0.125827,-0.232503,-0.331906,0.249220,-0.091381,0.130834,0.041945,-0.035407,-0.159467,0.155680,0.117222) * L3_1 + mat4(-0.113143,0.069706,0.119403,-0.110671,-0.110363,-0.305167,-0.197754,-0.083071,-0.088931,0.056716,0.184107,-0.322890,-0.540674,-0.256994,-0.057534,-0.119751) * L3_2 + mat4(-0.135626,-0.294898,-0.273389,-0.078984,-0.303326,-0.266012,-0.065236,0.132504,-0.040684,0.460459,0.176466,0.076873,-0.287640,0.210673,0.275112,0.484176) * L3_3 + mat4(0.051328,-0.095561,0.099031,0.006836,-0.187449,0.072778,-0.095253,-0.105815,-0.168644,-0.055027,0.354485,0.293222,0.153814,-0.454580,-0.417119,0.012419) * L3_4 + mat4(0.103540,-0.021146,-0.146560,0.327879,-0.135204,0.009159,0.288642,-0.040845,-0.042661,-0.277508,-0.116239,0.126143,-0.066720,0.002246,-0.473402,-0.069353) * L3_5 + mat4(-0.149198,0.248308,-0.068056,0.120973,-0.082914,-0.102925,0.103780,0.088318,0.050591,0.141847,0.198843,0.266996,-0.147617,-0.113799,-0.523679,-0.020351) * L3_6 + mat4(0.201702,-0.259646,0.196742,0.435519,-0.009308,-0.180351,0.228211,-0.087228,-0.115268,0.132079,-0.429632,0.031921,0.097545,-0.027312,-0.085729,0.135889) * L3_7 + mat4(-0.082980,0.115639,0.049138,0.257130,-0.074122,0.091376,0.030619,0.324837,-0.059951,0.069011,-0.243534,-0.528164,0.061231,-0.038611,-0.055606,0.027567) * L3_8 + mat4(0.003444,0.020398,-0.027879,0.237727,-0.101251,0.091872,-0.062028,0.276792,0.139084,-0.142425,-0.010463,-0.495055,-0.463583,0.250130,-0.212625,-0.071413) * L3_9 + vec4(0.606479,0.426099,0.558709,-0.045843)));\nvec4 L4_9 = sin((mat4(-0.127752,-0.409583,-0.103606,0.086557,-0.017591,0.017823,0.103014,0.065366,0.192045,-0.124942,-0.177702,0.046665,-0.181451,0.420547,-0.266235,-0.232810) * L3_0 + mat4(-0.115401,-0.315845,0.253520,0.006324,0.050996,-0.050877,-0.170125,0.057519,0.034043,0.188393,-0.348573,-0.209705,-0.319560,-0.159529,0.099452,-0.339044) * L3_1 + mat4(0.060084,0.110136,0.121685,-0.073726,0.022265,-0.383586,0.059111,0.136169,0.273068,-0.202340,0.234901,-0.553290,-0.360348,0.290610,-0.055879,0.188815) * L3_2 + mat4(-0.025928,0.143421,-0.124289,-0.074528,-0.001416,-0.092821,-0.032281,0.089003,0.076670,-0.323843,0.196673,0.114806,0.492675,-0.190933,0.223771,0.202073) * L3_3 + mat4(0.079376,-0.556849,-0.111933,-0.118897,-0.073890,-0.022710,0.153025,-0.491731,-0.099480,0.088574,0.048626,0.492355,0.120972,0.011213,-0.008184,0.140233) * L3_4 + mat4(-0.302366,-0.272895,-0.025989,-0.179501,-0.014701,-0.105481,-0.216170,0.119960,-0.056531,-0.394328,0.179460,0.196969,-0.137964,-0.335449,0.075815,-0.273785) * L3_5 + mat4(0.053783,-0.140277,0.174407,0.135466,0.191710,0.194806,0.008338,-0.113234,-0.239716,-0.158580,-0.223283,0.213971,0.093719,-0.118895,0.048446,0.057307) * L3_6 + mat4(0.227143,-0.189009,0.202840,-0.496238,0.066039,-0.102244,-0.047110,-0.046885,-0.304313,-0.009513,0.243087,0.197995,-0.177014,0.060030,0.386304,0.185926) * L3_7 + mat4(-0.294526,-0.328642,-0.146737,-0.449958,0.030253,0.180206,-0.169873,0.069258,0.099694,-0.105363,-0.852020,0.066959,-0.050049,-0.075183,-0.010738,0.015169) * L3_8 + mat4(0.010180,0.047802,0.084553,-0.029959,0.110896,0.104017,0.440120,0.218115,-0.032356,0.171158,0.212408,0.576913,-0.129069,-0.182702,-0.140743,0.139750) * L3_9 + vec4(0.257326,0.249527,-0.438306,0.331864)));\nvec4 L5_0 = sin((mat4(-0.295294,-0.406176,-0.507974,-0.081400,0.246478,0.053542,0.184931,-0.036305,-0.023532,0.174682,0.053919,0.528094,-0.064950,-0.003988,-0.277130,-0.019205) * L4_0 + mat4(0.059265,0.210922,-0.061206,0.032958,0.336871,0.008375,-0.073730,-0.081709,-0.268678,0.067660,-0.319282,0.139769,-0.007038,-0.157559,-0.420013,-0.104727) * L4_1 + mat4(0.235453,0.099479,0.209547,0.177987,0.153593,0.072827,0.190257,0.135654,0.013790,0.021465,-0.112021,-0.003220,-0.441939,0.345820,0.825396,-0.219353) * L4_2 + mat4(-0.049937,0.264240,0.341285,0.172003,-0.228006,0.121690,-0.070710,0.009296,0.194718,0.110975,-0.158939,0.297154,-0.042152,-0.058669,0.342809,0.183420) * L4_3 + mat4(0.059839,-0.010765,-0.024797,0.033068,-0.033171,0.090630,-0.573021,0.181502,0.137121,0.095443,-0.206216,0.077895,-0.108433,0.051387,-0.336157,0.002179) * L4_4 + mat4(-0.034988,-0.156506,-0.504299,0.063133,0.039100,-0.089319,-0.293618,-0.010520,0.164754,-0.234304,0.046292,0.036204,0.083813,-0.012391,-0.104638,-0.002197) * L4_5 + mat4(-0.142091,-0.022003,-0.055251,-0.011884,-0.184485,0.093534,0.516892,-0.127520,-0.012049,0.254515,0.098744,0.032548,0.429585,-0.348798,-0.320957,-0.037830) * L4_6 + mat4(-0.309432,-0.096591,-0.053466,-0.070604,-0.503776,-0.008148,0.056810,0.192226,-0.649996,-0.166903,0.084373,0.170337,0.436926,-0.131532,-0.447865,0.241202) * L4_7 + mat4(-0.280981,-0.830001,-0.825671,-0.506345,-0.263218,0.127939,0.010931,0.290635,0.020090,0.055884,0.046596,0.166220,0.068928,-0.048187,-0.380498,0.046323) * L4_8 + mat4(0.246033,0.311663,-0.225708,0.158452,-0.219081,-0.361684,0.186188,-0.021076,0.022872,0.043789,0.359737,0.005948,-0.221828,0.002306,0.000539,0.047770) * L4_9 + vec4(0.426042,0.479462,0.350328,0.293178)));\nvec4 L5_1 = sin((mat4(0.136943,-0.154446,0.338056,0.329621,-0.034627,0.089511,-0.073131,0.227852,0.121401,-0.031108,-0.118687,-0.054293,0.002339,-0.119745,-0.080337,-0.121587) * L4_0 + mat4(-0.257984,-0.206039,-0.115794,0.340535,-0.133911,-0.089993,0.074444,-0.043600,-0.056499,0.107883,-0.049104,0.052659,-0.082520,0.054206,-0.155978,0.201687) * L4_1 + mat4(0.208302,-0.037049,-0.147886,0.001134,0.310955,-0.083508,-0.064641,0.297341,-0.000218,-0.007311,-0.026624,-0.046817,-0.302657,0.205321,0.005678,-0.693350) * L4_2 + mat4(0.151185,0.104067,-0.118598,0.375266,0.038584,-0.000706,0.097406,0.225075,0.316591,0.037063,-0.154379,0.279433,-0.021144,0.026351,0.264799,0.087289) * L4_3 + mat4(0.197817,-0.033844,0.208223,0.062796,0.385352,-0.009767,-0.022784,0.253434,-0.045547,-0.173517,-0.027654,0.178412,0.069002,0.135145,0.408740,-0.046452) * L4_4 + mat4(0.137601,0.277485,0.112804,0.266298,0.028158,-0.611769,-0.308128,-0.016271,0.120946,-0.712470,0.159728,0.269327,-0.137752,0.368270,0.008567,-0.052395) * L4_5 + mat4(0.396264,-0.494127,0.045454,0.207286,0.097710,0.283214,0.281777,-0.220266,0.226971,-0.013020,-0.344896,0.262909,0.119205,0.235103,-0.392615,0.061368) * L4_6 + mat4(0.017649,-0.743395,0.078024,-0.097176,0.213957,-0.012289,-0.110943,0.242486,0.031651,0.396300,0.104958,-0.419433,0.461085,-0.094731,-0.319817,-0.269321) * L4_7 + mat4(0.109652,0.044356,0.078294,0.037065,-0.022455,0.308291,-0.342538,0.295607,0.004135,-0.131192,-0.072814,-0.022711,0.235152,-0.269651,-0.413370,0.347642) * L4_8 + mat4(0.312359,-0.542473,-0.134422,-0.441077,-0.109599,-0.025504,0.092148,0.373047,-0.006592,-0.154802,0.042401,-0.149868,0.095039,-0.013799,0.018958,0.085509) * L4_9 + vec4(-0.885262,0.466509,-0.482082,0.169149)));\nvec4 L5_2 = sin((mat4(0.049663,0.129930,0.381690,0.187554,0.439971,0.170544,0.000465,-0.105847,0.009210,-0.231927,-0.204074,0.138295,0.024004,0.242515,-0.280502,-0.173915) * L4_0 + mat4(0.043653,0.079423,0.026926,-0.084893,0.038493,0.065675,0.169940,-0.047217,0.148424,0.155668,-0.022666,0.044856,0.033489,-0.003339,0.292630,-0.100836) * L4_1 + mat4(-0.412161,0.006523,-0.139182,0.033894,-0.314263,-0.131400,0.286387,-0.043140,0.047986,-0.085822,-0.071843,-0.010849,0.436065,-0.040999,0.064093,0.246978) * L4_2 + mat4(0.385759,-0.112661,-0.048755,0.222456,-0.074367,0.131585,0.358640,0.005896,-0.276589,-0.378825,0.417852,0.221516,-0.202276,0.074093,-0.152113,0.015447) * L4_3 + mat4(0.149356,-0.085171,0.012223,-0.091354,0.027129,0.304658,0.183081,0.061774,0.347860,0.009034,-0.208075,0.062341,-0.386496,-0.072580,0.061026,-0.010858) * L4_4 + mat4(-0.339771,-0.195466,0.171490,0.193773,-0.088003,-0.071786,-0.211986,-0.114126,0.314510,0.189857,-0.078539,0.258676,0.314744,-0.270355,-0.008345,0.034420) * L4_5 + mat4(0.378443,0.310923,-0.383508,-0.006308,0.192253,0.247313,-0.035008,-0.097656,0.089813,-0.223025,0.148569,-0.296505,-0.078957,-0.148414,-0.074276,-0.131616) * L4_6 + mat4(-0.060612,0.084413,-0.416774,-0.127119,0.032970,-0.133527,-0.014693,0.104522,-0.062851,0.040292,-0.113238,0.179206,0.599320,-0.407278,-0.222906,0.648998) * L4_7 + mat4(0.544707,-0.275301,-0.410339,0.758894,0.006386,0.135532,-0.292426,0.062205,0.085840,-0.101572,-0.127869,0.157998,0.163698,-0.156357,0.052382,0.040343) * L4_8 + mat4(0.282952,-0.117880,-0.033084,-0.063551,-0.035586,-0.051589,0.007042,-0.031025,0.116398,-0.029288,0.309601,0.115756,-0.131077,-0.165963,-0.055639,0.235252) * L4_9 + vec4(-0.038610,0.211274,-0.135312,-0.498316)));\nvec4 L5_3 = sin((mat4(0.251754,0.225092,0.151575,0.205592,0.076344,0.202691,-0.251472,0.062916,-0.090013,0.117392,-0.160908,-0.132498,0.061521,0.259955,-0.072555,0.094254) * L4_0 + mat4(0.293813,0.240177,0.027832,-0.118238,0.128346,0.258300,0.155264,-0.073438,0.089938,-0.404657,-0.109440,-0.001637,-0.414954,0.154542,0.201128,-0.171905) * L4_1 + mat4(-0.052529,-0.328214,0.063620,-0.014698,0.610736,0.577916,-0.088092,0.225853,-0.013364,-0.328287,-0.007260,0.009291,0.331028,0.043167,0.397728,0.184991) * L4_2 + mat4(0.381139,-0.290828,0.229113,0.365507,-0.385221,-0.188424,-0.071145,0.117852,0.225624,-0.047553,0.202982,0.234232,0.146942,0.324256,0.045734,-0.382343) * L4_3 + mat4(0.095049,-0.060543,-0.115195,-0.186185,-0.062917,0.109645,-0.068744,-0.154196,0.115055,0.015905,-0.107450,0.084079,-0.459672,0.177079,-0.308924,0.030478) * L4_4 + mat4(-0.033705,-0.012686,0.299755,0.185648,-0.491618,-0.212590,-0.043103,-0.103596,-0.158762,-0.447048,-0.127539,0.368404,0.213818,0.235203,0.038316,-0.050231) * L4_5 + mat4(-0.458215,0.674623,0.323256,-0.147779,0.367474,-0.028939,0.059701,-0.274631,0.029876,0.029857,-0.204696,-0.242606,0.172624,0.293599,0.186151,-0.129456) * L4_6 + mat4(0.039691,-0.206041,0.022316,-0.132691,-0.269584,-0.268897,-0.177000,0.000140,0.460090,-0.047790,-0.325206,0.055631,-0.415152,-0.071539,0.656294,-0.402018) * L4_7 + mat4(0.470533,0.006723,0.037925,0.226993,0.073181,-0.059932,-0.010985,-0.389180,0.375758,-0.637519,-0.016676,0.104147,0.008487,0.313672,-0.011359,0.051757) * L4_8 + mat4(-0.294852,-0.169596,0.206671,0.535584,-0.717042,0.119455,0.062892,-0.151962,0.249891,-0.365007,0.123513,-0.161415,0.030314,-0.315907,0.102769,-0.057520) * L4_9 + vec4(-0.101036,-0.302292,-0.475327,-0.191077)));\nvec4 L5_4 = sin((mat4(0.085912,-0.064736,0.046452,-0.249847,0.113730,-0.492186,0.140513,0.322479,-0.310445,0.104398,0.274295,0.045840,-0.376543,-0.363485,-0.111474,0.067919) * L4_0 + mat4(0.100590,-0.106437,0.226191,0.229524,-0.016892,-0.182519,0.092125,-0.231335,-0.007952,0.080413,0.031284,0.023951,0.528160,0.117122,-0.073658,-0.004624) * L4_1 + mat4(0.177907,0.123312,0.105466,0.072350,0.183593,0.273928,0.127575,0.036063,0.320212,-0.011538,0.047320,-0.127717,0.106549,-0.291485,0.007131,-0.384503) * L4_2 + mat4(-0.151907,0.303357,0.292290,0.192438,0.265332,-0.313952,-0.152770,-0.188156,-0.691876,-0.306623,0.219419,0.326618,-0.017173,0.028350,0.204189,0.005054) * L4_3 + mat4(-0.239654,0.148158,-0.091786,0.078123,-0.020862,-0.504436,0.080380,-0.298972,-0.376760,-0.014570,0.386113,0.000856,0.046695,0.288102,-0.131072,0.251593) * L4_4 + mat4(-0.168675,0.052336,-0.306276,-0.211078,0.046911,-0.150315,0.237742,-0.478688,-0.201790,0.052822,0.310063,0.016920,0.070018,-0.060688,0.116516,-0.117564) * L4_5 + mat4(0.047407,-0.243552,0.370412,0.070141,0.088733,-0.083733,0.381088,-0.180308,-0.426759,-0.679023,0.303422,-0.230109,-0.067200,-0.003211,0.199852,0.192435) * L4_6 + mat4(-0.105190,0.220036,0.031074,0.196828,0.179950,-0.054034,-0.019548,-0.298538,0.513854,0.174028,0.021965,0.109814,-0.541749,-0.250966,0.124421,0.037579) * L4_7 + mat4(-0.161740,0.077630,0.229746,0.041151,-0.235672,-0.009762,-0.194501,0.030540,0.001173,-0.178381,0.079392,0.008360,0.098053,0.128650,0.087672,-0.410771) * L4_8 + mat4(0.245406,-0.128239,0.050821,-0.299500,0.043591,0.017143,0.225836,-0.175157,-0.251564,0.041390,0.539193,-0.259885,0.248198,0.255342,0.066657,0.075991) * L4_9 + vec4(-0.311553,-0.397987,-0.312685,-0.164161)));\nvec4 L5_5 = sin((mat4(0.235842,-0.231588,0.041252,0.368232,-0.009823,-0.089923,0.297118,-0.421305,0.113805,0.300651,0.313354,0.202169,0.027989,0.006803,0.355797,-0.258638) * L4_0 + mat4(0.289439,-0.016612,-0.071739,0.243632,-0.389590,0.106383,-0.071854,-0.081996,0.134814,0.307092,0.118750,-0.283012,-0.146781,0.302311,-0.200613,0.026949) * L4_1 + mat4(0.155887,0.083410,-0.197743,-0.019700,-0.045301,-0.126573,-0.184966,0.077529,-0.130780,0.092213,0.014462,0.302410,0.064937,0.510990,0.134896,-0.291214) * L4_2 + mat4(-0.121707,-0.295631,-0.218368,-0.008685,-0.045551,-0.096271,0.069214,0.118669,0.279465,-0.087670,-0.115290,0.108089,0.021579,-0.019708,0.099671,0.128416) * L4_3 + mat4(-0.073930,-0.162271,0.084580,0.200475,0.194903,-0.045475,-0.046491,0.219090,-0.129676,-0.017033,0.051078,-0.137172,0.034062,-0.224791,0.033192,-0.257605) * L4_4 + mat4(-0.214046,0.228167,-0.408803,-0.194347,-0.134771,0.181539,-0.164043,-0.136229,0.019547,0.061737,0.239824,-0.109482,-0.277440,-0.040642,0.062356,0.128419) * L4_5 + mat4(-0.024598,0.038295,0.180145,-0.387490,-0.301195,-0.157295,-0.073818,-0.198697,0.002833,-0.105711,0.033831,-0.246354,-0.030138,0.235518,-0.387378,0.185683) * L4_6 + mat4(-0.216666,-0.121214,0.134145,0.002159,-0.093282,-0.154020,-0.287491,0.199472,0.259040,-0.085979,0.145913,-0.681005,-0.517646,0.175360,0.029480,0.395562) * L4_7 + mat4(0.443614,-0.818486,-0.433152,0.133245,0.143216,-0.061862,-0.000151,-0.133703,-0.214439,0.088325,0.287010,-0.514400,-0.189784,-0.267494,-0.318645,0.030662) * L4_8 + mat4(0.186217,0.066059,-0.009357,0.363032,-0.028542,0.219500,-0.054846,-0.293585,0.158842,0.254484,-0.089242,0.058727,-0.362700,-0.093637,-0.189440,0.085659) * L4_9 + vec4(-0.735014,-0.223915,-0.547746,-0.471831)));\nvec4 L5_6 = sin((mat4(-0.022874,-0.510283,0.090932,0.021725,-0.129560,-0.041416,0.346656,-0.125406,0.004321,-0.320427,0.072173,-0.189540,-0.173783,0.081912,0.296848,0.031760) * L4_0 + mat4(0.056564,0.267953,0.290036,-0.038483,-0.023182,0.158399,-0.320243,-0.033031,0.084816,-0.087551,0.197852,0.145347,0.225463,-0.055478,-0.292706,0.076488) * L4_1 + mat4(-0.227104,-0.057390,-0.173737,-0.014841,0.072040,-0.125747,-0.088860,-0.125301,-0.156233,-0.070691,-0.428513,-0.014992,0.040734,-0.143263,-0.790738,-0.273590) * L4_2 + mat4(0.119015,0.266069,-0.159092,-0.164555,0.013770,0.311638,0.240509,-0.133501,-0.590163,-0.235814,0.212693,0.053811,0.052047,-0.129829,-0.011057,-0.110049) * L4_3 + mat4(0.210680,0.029594,0.008174,0.000249,-0.512133,-0.205973,0.236193,-0.211226,-0.006436,0.169547,-0.014617,-0.021925,-0.284006,0.117622,-0.508125,0.413904) * L4_4 + mat4(-0.141215,-0.551769,-0.177413,0.130822,-0.106083,-0.153302,-0.273673,0.106632,0.071359,0.120684,-0.023993,-0.085812,0.141290,0.093758,0.168928,0.070604) * L4_5 + mat4(-0.327443,0.210614,0.059601,-0.333851,0.101925,-0.301502,0.260996,-0.029688,-0.194590,0.156340,-0.071813,0.131268,-0.331965,-0.205807,-0.086066,-0.598870) * L4_6 + mat4(-0.191266,0.104720,-0.040498,-0.002012,-0.056600,0.229806,0.181351,-0.075435,0.349403,-0.032393,0.464793,-0.106396,-0.497664,-0.443493,-0.300028,-0.250077) * L4_7 + mat4(0.672042,-0.207873,0.760772,-0.003146,0.063605,-0.151107,-0.044796,0.255479,0.139708,-0.102448,-0.158448,0.248398,-0.050135,-0.046278,0.136415,-0.042552) * L4_8 + mat4(0.071400,0.189717,0.015298,0.124611,0.111476,-0.090182,0.101343,0.136604,-0.305125,0.042505,-0.206975,-0.059636,0.028659,-0.183641,-0.170573,0.007107) * L4_9 + vec4(0.113740,-0.488588,0.846896,-0.077665)));\nvec4 L5_7 = sin((mat4(0.184463,0.140568,-0.346258,0.017896,0.126080,0.253017,-0.024462,-0.325722,-0.152024,-0.048119,0.056745,0.270753,0.223037,-0.072972,0.072294,0.370478) * L4_0 + mat4(0.196528,0.285115,0.216042,0.129375,-0.272743,-0.205079,-0.177848,0.458302,0.056994,-0.168678,0.160801,-0.319257,-0.040788,0.083721,-0.039980,-0.225834) * L4_1 + mat4(0.047426,-0.040130,0.206232,-0.270058,-0.221816,0.198184,0.435934,0.334565,-0.162469,0.158941,0.186030,-0.439911,0.255289,0.256589,-0.318063,0.041418) * L4_2 + mat4(-0.021382,0.038573,0.270049,-0.140533,-0.032499,0.305112,0.157168,-0.175936,0.045503,0.431328,0.148724,-0.428066,-0.173661,0.246611,-0.209017,-0.743897) * L4_3 + mat4(-0.255038,-0.290295,0.134135,-0.210867,-0.304998,0.312008,-0.373401,0.141806,0.074597,-0.350532,0.112749,-0.158772,-0.313752,-0.136918,-0.595877,-0.439722) * L4_4 + mat4(0.096545,0.070081,-0.360579,-0.614866,-0.002563,0.338212,0.563201,0.097805,-0.252841,-0.233498,0.443246,-0.023717,-0.014372,0.344751,-0.479260,0.048626) * L4_5 + mat4(0.119810,0.905674,-0.056993,0.037697,0.449067,0.417030,-0.112423,0.000507,0.076269,0.424798,-0.328020,0.094395,-0.180364,0.238707,-0.278562,0.022626) * L4_6 + mat4(-0.092371,-0.089414,0.145428,0.446280,-0.058273,0.329470,-0.109620,0.058963,0.133926,0.084977,0.151042,0.327349,0.229853,-0.191668,0.185580,0.436344) * L4_7 + mat4(0.778546,0.780012,-0.145973,-0.197702,0.107749,0.233440,0.318537,-0.120296,0.029094,0.216744,-0.740623,0.310379,-0.054341,0.097149,-0.012124,-0.026073) * L4_8 + mat4(-0.497060,0.031240,0.058659,0.117381,0.124669,0.429103,-0.067885,0.461704,-0.161555,0.014619,0.117019,-0.350055,-0.129627,0.009124,0.287035,-0.107038) * L4_9 + vec4(0.842442,0.088806,-0.639743,0.514121)));\nvec4 L5_8 = sin((mat4(-0.283653,-0.119603,0.114005,0.033436,-0.383026,-0.192079,0.181083,-0.208455,-0.142292,0.305166,0.341553,-0.122507,0.052510,0.027591,-0.214888,0.141222) * L4_0 + mat4(0.118127,-0.185294,0.047143,0.003335,-0.140612,0.181426,-0.365044,-0.049303,0.315465,-0.133115,0.350158,-0.385408,-0.161735,0.119085,-0.300107,-0.232573) * L4_1 + mat4(0.131146,0.113683,-0.153375,-0.593642,-0.061161,0.091164,0.199062,0.359912,0.018369,-0.226358,0.122837,0.072103,-0.477936,-0.016393,-0.216879,-0.391695) * L4_2 + mat4(-0.264966,0.166602,0.225174,-0.008110,-0.088804,0.267111,0.143442,0.109466,0.257249,-0.223229,-0.006687,0.074445,0.262093,0.001350,-0.305883,-0.150128) * L4_3 + mat4(-0.155525,0.343381,0.007227,0.478642,-0.103819,-0.075247,0.204779,-0.126187,0.168379,0.245390,0.003869,-0.045431,-0.479363,0.234860,0.370334,-0.151906) * L4_4 + mat4(0.110028,0.161154,0.226519,-0.019755,-0.054310,-0.027645,-0.285353,0.086965,-0.156995,-0.037937,-0.308766,-0.182316,-0.021917,-0.202787,-0.311138,0.239406) * L4_5 + mat4(0.094171,0.368811,0.289051,0.139692,-0.183649,0.089615,0.201582,-0.002981,0.136811,-0.107494,-0.262208,-0.079246,-0.085532,-0.205432,0.177032,0.700004) * L4_6 + mat4(-0.112869,0.247481,-0.174907,-0.121460,-0.194569,-0.054862,-0.190152,-0.092430,-0.069201,-0.032099,0.136137,0.210540,0.066013,0.472435,0.308591,0.338014) * L4_7 + mat4(-0.493854,0.584905,-0.293397,0.468465,-0.642738,0.002820,0.060102,0.477804,-0.109408,-0.042909,0.566817,-0.314526,0.041579,0.193046,-0.117752,0.020033) * L4_8 + mat4(-0.138336,0.184133,0.270877,0.375098,-0.014296,-0.108770,-0.216673,-0.222104,-0.091971,0.126062,0.136885,-0.256618,-0.092938,-0.023960,0.257744,0.109858) * L4_9 + vec4(0.127157,-0.307873,-0.279614,-0.002481)));\nvec4 L5_9 = sin((mat4(0.384090,0.008281,-0.127042,0.189894,0.099933,-0.029748,0.334183,-0.132649,0.087315,0.019813,0.029787,0.163847,-0.010949,-0.064816,0.080909,0.056829) * L4_0 + mat4(-0.082643,0.003674,0.142511,0.083929,-0.052205,-0.003022,0.355607,0.060699,-0.198448,-0.053697,-0.014316,-0.160075,0.103734,0.058331,-0.115203,-0.066904) * L4_1 + mat4(0.036402,-0.161929,0.118912,0.243993,0.202041,-0.042716,-0.147075,-0.104126,0.029588,0.042310,0.089773,-0.077234,0.013876,-0.140415,0.142350,-0.224268) * L4_2 + mat4(0.314295,0.044726,0.018356,0.103307,-0.124135,-0.130121,-0.363323,-0.161402,-0.175222,-0.384597,0.326120,0.444916,-0.180719,-0.245817,-0.058278,-0.021490) * L4_3 + mat4(0.162676,-0.148912,0.065815,-0.127750,-0.010242,0.106841,-0.099772,0.105259,0.013601,-0.030151,-0.172276,0.123864,-0.075109,-0.092474,-0.120674,0.018945) * L4_4 + mat4(0.105635,0.040767,0.092649,0.082645,-0.139482,0.015088,-0.228556,0.172408,-0.272722,-0.230151,-0.143461,0.306999,0.089063,0.170737,-0.065055,0.074063) * L4_5 + mat4(-0.220152,0.131178,-0.005247,-0.468472,0.152215,-0.079507,-0.155215,0.152852,0.436622,-0.209420,0.205743,0.139546,-0.135217,-0.124165,-0.148010,-0.620090) * L4_6 + mat4(-0.044231,-0.123147,0.166670,0.146506,-0.282376,-0.129984,0.384748,0.121224,0.280592,-0.467954,0.028021,0.035363,0.209358,-0.191707,-0.067479,0.020234) * L4_7 + mat4(-0.185880,0.365619,-0.173892,-0.174496,-0.094528,0.279157,0.100557,-0.027253,0.059684,0.089253,-0.216568,0.157264,0.170273,-0.055182,0.091682,0.138618) * L4_8 + mat4(0.071801,-0.046130,0.440520,0.121382,-0.125678,0.174308,0.203189,0.044438,0.019336,0.004891,0.161571,-0.078164,0.041047,-0.026112,0.085234,0.227399) * L4_9 + vec4(-0.419423,0.186595,0.094528,-1.025535)));\nvec4 L6_0 = sin((mat4(-0.144066,0.033198,-0.005113,0.083893,0.109612,-0.359234,0.002145,0.007879,-0.059568,0.074156,0.004590,-0.059733,-0.176732,-0.030375,0.005210,-0.338561) * L5_0 + mat4(-0.046874,-0.036760,0.006101,0.006132,0.070138,-0.013963,0.002197,0.034468,0.129143,-0.256752,-0.003296,-0.307304,-0.013109,-0.151050,0.003799,0.091661) * L5_1 + mat4(0.012053,0.002405,-0.008069,0.055744,0.502993,-0.214823,-0.007947,-0.077583,0.259210,-0.087835,0.001155,-0.258348,-0.124691,0.370325,-0.006928,0.078854) * L5_2 + mat4(-0.112880,-0.077209,0.000072,0.020118,0.166594,-0.010105,-0.004078,-0.057749,0.038890,0.248082,0.004276,-0.150853,0.097822,0.073373,0.006621,-0.050628) * L5_3 + mat4(0.186762,0.015080,0.002120,-0.046252,0.058265,-0.045896,-0.008248,-0.064178,-0.132154,0.184211,0.005943,0.000404,-0.189994,-0.143895,-0.003652,0.084171) * L5_4 + mat4(-0.055622,0.132646,0.003642,0.181164,0.489641,-0.061242,-0.006068,-0.125125,-0.232537,-0.040709,0.009089,0.132149,-0.520813,0.027558,-0.001579,0.071262) * L5_5 + mat4(0.144251,-0.063765,-0.000670,0.061772,0.483977,-0.106320,0.001458,0.005911,-0.063424,-0.009229,0.008480,0.039612,0.089572,-0.298505,0.000081,-0.254413) * L5_6 + mat4(0.222015,-0.245302,0.015924,0.282622,-0.167670,-0.017508,-0.010795,0.027945,-0.266167,-0.029673,-0.000309,0.113470,0.008648,-0.001677,0.003391,0.083458) * L5_7 + mat4(0.003146,-0.036512,0.000452,-0.056164,-0.137418,-0.008496,-0.005286,-0.002866,-0.189359,-0.174070,-0.001189,0.184535,-0.179447,0.124553,0.003089,-0.091727) * L5_8 + mat4(-0.146164,-0.298993,-0.000545,0.125672,0.192418,0.139925,-0.007551,-0.090702,-0.151364,0.121086,-0.007166,-0.016471,0.072114,-0.032888,0.000826,-0.230362) * L5_9 + vec4(-0.033161,0.312768,-0.002978,1.013697)));\nvec4 L6_1 = sin((mat4(0.044131,-0.081094,0.392726,-0.415370,-0.066022,-0.216460,1.386513,0.385745,0.014753,-0.010582,0.227690,0.046566,0.059603,-0.224794,-0.089006,0.101189) * L5_0 + mat4(-0.107597,-0.104795,-0.275655,0.603022,0.055572,-0.088735,-0.139050,0.068714,-0.067710,0.357071,0.106918,0.304834,-0.025148,0.071951,-0.515514,0.385042) * L5_1 + mat4(-0.067600,-0.048481,0.506275,-0.325780,-0.068751,0.022151,-0.118974,0.295645,0.054959,0.021030,-0.319569,0.095280,-0.152045,0.036236,-0.299129,-0.097317) * L5_2 + mat4(0.041914,-0.029109,-0.348940,0.120380,-0.042966,0.030060,0.437987,0.090840,0.087743,-0.177098,-0.445504,-0.219969,-0.068687,-0.071690,-0.277847,-0.225116) * L5_3 + mat4(0.030618,0.063593,-0.057763,-0.027921,-0.021397,0.110624,0.055527,-0.037529,-0.023931,-0.099596,-0.525872,-0.168038,-0.036227,0.110060,-0.074188,-0.027683) * L5_4 + mat4(-0.001670,-0.065976,-0.059550,-0.051847,-0.062162,-0.154852,-0.138961,0.218430,0.095982,0.067075,-0.624926,0.447699,-0.103371,-0.044632,-0.449271,-0.172376) * L5_5 + mat4(-0.067755,-0.056332,-0.041741,-0.326104,0.037710,-0.081522,-0.646582,-0.398014,-0.003432,-0.104380,-0.231871,0.219011,-0.007042,-0.001144,0.325199,-0.178270) * L5_6 + mat4(-0.000752,0.096117,-0.125884,0.503104,-0.003371,-0.140154,-0.189647,-0.176198,-0.039758,0.067618,-0.098885,0.304870,-0.007622,-0.048444,0.190356,-0.077552) * L5_7 + mat4(0.054996,-0.078993,-0.209132,0.044746,0.015650,0.393287,-0.509614,-0.315676,0.034257,-0.001064,0.139561,0.003419,-0.032428,-0.055846,-0.350865,-0.134109) * L5_8 + mat4(-0.116457,-0.194768,0.258732,0.156564,0.020730,-0.197853,0.501461,-0.317831,-0.074082,-0.120449,0.402975,-0.269721,-0.189016,0.068865,0.447967,0.169613) * L5_9 + vec4(1.189952,-0.423619,0.212384,-1.244563)));\nvec4 L6_2 = sin((mat4(-0.003285,0.004138,0.162370,0.059720,0.002016,-0.000398,-0.005753,-0.065016,0.009793,-0.001230,-0.102999,-0.053074,-0.001826,-0.002138,0.083776,0.075881) * L5_0 + mat4(-0.004171,-0.004033,-0.485295,0.139625,0.000237,0.000513,0.066214,0.080476,-0.001179,-0.000847,0.002658,-0.118794,0.009585,0.001918,0.070385,-0.042544) * L5_1 + mat4(-0.003253,0.003053,-0.030522,-0.143234,0.000839,0.000821,0.051717,-0.038681,-0.003378,0.005917,-0.003374,-0.032231,0.002191,0.007008,0.000755,0.290543) * L5_2 + mat4(-0.005329,-0.006337,0.185507,-0.035060,0.003424,0.005780,-0.076544,0.078523,0.003600,0.000779,-0.020988,0.145730,0.007185,0.001381,-0.092855,-0.168985) * L5_3 + mat4(0.001137,-0.000062,0.070142,0.009204,-0.004200,0.002624,-0.130583,-0.044195,-0.004973,-0.001148,-0.155692,0.050208,0.008171,0.000898,-0.058783,-0.047329) * L5_4 + mat4(-0.006517,-0.000751,0.080417,0.064590,0.004747,0.005603,0.082519,-0.154952,-0.001089,-0.002241,0.128207,0.017334,0.002227,0.000205,0.031107,0.160502) * L5_5 + mat4(-0.002219,0.001886,-0.009093,-0.184979,0.003793,0.009347,0.099619,0.006300,-0.004728,-0.004239,0.016945,0.091329,-0.006240,-0.002496,0.079352,-0.104048) * L5_6 + mat4(0.002738,-0.006299,-0.052773,-0.156292,0.001620,0.007178,0.040431,0.003074,0.004779,0.006776,-0.136751,0.079121,0.006118,0.006776,-0.019171,0.007315) * L5_7 + mat4(-0.001795,-0.003025,0.045893,-0.057015,-0.006314,-0.000202,-0.114354,-0.009381,0.006330,0.001840,-0.052561,0.072060,0.008450,-0.004358,-0.085508,-0.018442) * L5_8 + mat4(-0.000750,0.002742,-0.285581,0.054080,-0.005271,-0.000784,0.120600,0.404957,0.004866,0.006757,-0.125102,-0.128683,-0.007115,-0.001893,-0.130828,0.003929) * L5_9 + vec4(0.004216,0.006850,0.430980,-1.019668)));\nvec4 L6_3 = sin((mat4(-0.000747,-0.022433,0.008087,0.002107,0.002185,-0.096476,0.000509,-0.001420,0.005530,-0.014820,-0.007268,-0.013184,0.003674,-0.362515,-0.006723,0.002431) * L5_0 + mat4(-0.006107,-0.335767,0.004824,-0.002964,0.002974,0.046142,0.003626,-0.000169,-0.002597,-0.055494,0.005599,0.004068,0.006681,0.117951,-0.003243,-0.005023) * L5_1 + mat4(0.001289,0.092949,-0.000469,0.005955,0.002415,0.269740,-0.003980,0.005296,0.000107,0.132296,-0.003508,0.002726,0.008316,-0.083378,-0.006101,0.001514) * L5_2 + mat4(-0.009243,0.051460,0.000926,-0.000442,0.004368,-0.033245,-0.001329,-0.001238,0.005041,0.072216,-0.008131,0.004265,0.006106,0.187995,0.000166,-0.006147) * L5_3 + mat4(0.002002,-0.007674,0.001312,-0.005549,0.000577,-0.089399,0.016451,0.008223,-0.003173,-0.205625,0.000995,0.001567,0.003950,0.118646,-0.008764,-0.002393) * L5_4 + mat4(-0.005442,-0.057386,0.007984,0.006704,0.000488,0.163365,0.001564,0.001587,-0.004011,0.205901,-0.009403,-0.003641,0.003885,-0.229740,-0.001864,0.000219) * L5_5 + mat4(0.000555,0.349506,-0.003413,0.007354,0.008723,-0.172111,-0.005707,0.002830,-0.001942,0.100338,0.001972,0.004077,-0.000876,0.163324,0.000917,0.004655) * L5_6 + mat4(-0.003143,-0.005412,-0.004856,-0.007765,0.002383,-0.032013,-0.000105,0.003269,0.009613,-0.139090,-0.000081,-0.001086,0.008576,0.022736,-0.001718,-0.000737) * L5_7 + mat4(-0.004594,0.045645,0.007023,0.000589,-0.006770,-0.168825,0.003623,0.000832,0.002383,0.031413,0.001495,-0.000468,0.000262,-0.056075,0.004147,-0.007217) * L5_8 + mat4(-0.002169,-0.320406,0.002525,0.002059,-0.007606,0.465250,0.014153,0.001395,0.000175,0.151245,-0.005497,0.002033,-0.008721,-0.147687,0.002447,0.002313) * L5_9 + vec4(0.006231,0.967473,-0.006938,0.001423)));\nvec4 L6_4 = sin((mat4(0.485596,-0.002142,-0.096626,0.026618,0.149859,0.004755,-0.291046,0.046841,-0.285214,0.005568,-0.025510,0.027797,-0.010641,0.009455,-0.024814,-0.256638) * L5_0 + mat4(0.638722,-0.013677,-0.354396,-0.277183,-0.013413,-0.001630,-0.255246,-0.101003,-0.466261,0.000831,0.368342,0.082035,0.024732,0.007329,0.270732,0.128692) * L5_1 + mat4(0.012829,0.003400,-0.168261,-0.063032,-0.320539,-0.003156,0.513703,0.097030,0.003354,0.001025,0.171714,0.008431,0.283031,0.003945,-0.202760,-0.180845) * L5_2 + mat4(0.012019,-0.007711,0.148138,-0.064991,-0.453299,0.001482,-0.052349,0.011923,0.061405,0.009214,-0.005794,-0.044903,0.103827,0.004398,0.146835,0.046093) * L5_3 + mat4(-0.311306,-0.000234,-0.517519,0.060807,-0.445047,-0.009871,0.361566,-0.027417,0.313117,-0.001005,-0.267729,0.023701,0.777357,0.000241,0.373951,-0.053648) * L5_4 + mat4(0.106918,-0.000883,0.020906,-0.015056,-0.319108,-0.000965,0.012464,-0.035199,-0.447025,0.007823,-0.195443,0.027221,0.004809,0.006933,-0.101792,-0.098623) * L5_5 + mat4(-0.106753,0.002339,-0.106521,-0.035335,-0.342149,0.008415,-0.029917,-0.057219,-0.158528,0.002106,-0.183657,0.033065,-0.225192,-0.000013,0.053410,0.291285) * L5_6 + mat4(-0.075009,0.003439,-0.350905,-0.073875,0.061605,-0.001634,-0.357478,-0.060214,0.112605,0.005379,0.225853,-0.035866,-0.225046,0.004623,-0.074289,-0.012324) * L5_7 + mat4(0.584297,-0.008663,0.107948,-0.041990,-0.025302,-0.007570,0.751249,-0.202029,-0.227432,-0.000008,-0.211654,-0.125932,0.116980,-0.005492,-0.170428,-0.044240) * L5_8 + mat4(0.277544,0.000715,0.186329,0.003507,-0.242025,-0.021305,-0.068272,0.409365,-0.601703,0.002936,0.410530,0.041052,0.646633,-0.009246,0.316827,0.354879) * L5_9 + vec4(-0.408463,0.005183,-0.995126,0.623014)));\nvec4 L6_5 = sin((mat4(0.002310,0.043847,-0.271866,-0.108241,0.000018,0.194846,-0.493082,-0.333811,0.004478,-0.035799,0.188459,0.031414,-0.001391,0.347814,-0.129960,-0.515395) * L5_0 + mat4(0.004522,0.086430,-0.102772,0.190382,0.007715,-0.000736,-0.275647,0.122166,0.004281,0.008926,0.003249,0.133480,0.006767,0.323311,-0.021677,0.053117) * L5_1 + mat4(-0.005632,0.140333,-0.074798,-0.265487,-0.005527,0.140678,0.012372,0.237260,0.001259,-0.184095,-0.454281,-0.004510,-0.005516,-0.031498,0.489216,-0.280652) * L5_2 + mat4(-0.002145,0.055973,-0.068693,0.101656,0.001411,0.074813,0.025716,0.060190,-0.004313,0.164356,0.161451,0.185491,0.007875,-0.406238,0.247700,0.049213) * L5_3 + mat4(-0.000523,0.404972,-0.178414,0.132799,0.002325,-0.074866,-0.105095,0.160045,-0.000057,0.258295,-0.126798,-0.084242,-0.007487,-0.194133,-0.411849,0.055622) * L5_4 + mat4(0.003021,0.331101,0.300745,0.002041,-0.000218,0.237794,0.015729,0.031800,-0.001544,0.345245,-0.063611,0.252219,-0.002901,-0.264493,-0.244733,0.076353) * L5_5 + mat4(-0.005136,0.454116,-0.693187,0.115294,-0.000501,-0.171223,-0.041670,-0.190864,0.002051,0.045294,0.634715,-0.021890,-0.008915,-0.076073,0.630079,-0.431246) * L5_6 + mat4(0.003661,0.193551,0.359997,0.224058,0.003412,-0.369409,0.028090,-0.105934,0.003677,0.018018,0.369824,0.166586,0.006183,-0.007138,0.009196,-0.112775) * L5_7 + mat4(0.002666,0.113201,0.064431,0.254363,0.006918,0.054803,0.268963,-0.409466,0.005757,0.001743,-0.001407,0.080178,0.000519,-0.074527,0.360478,-0.103192) * L5_8 + mat4(-0.005511,-0.061810,-0.510500,0.315563,0.004962,0.143077,0.090120,-0.256324,0.001153,0.368586,0.177055,-0.166559,0.004265,-0.151030,-0.027333,-0.104462) * L5_9 + vec4(0.000322,-0.136784,-0.748064,0.578112)));\nvec4 L6_6 = sin((mat4(-0.026937,-0.083897,-0.005754,-0.012289,0.570001,0.084114,0.005121,0.020419,-0.023357,0.068341,0.001368,0.114120,-0.059295,0.183631,0.003093,0.266226) * L5_0 + mat4(-0.084378,-0.081189,-0.004994,0.098704,-0.064423,-0.131673,-0.005956,0.137430,0.027853,0.022140,0.003830,-0.242948,0.180334,0.179101,0.005884,0.027394) * L5_1 + mat4(0.221914,-0.091383,0.000558,-0.147114,0.038825,0.197714,0.004411,-0.311754,0.002948,0.195726,0.002000,-0.040077,0.133186,-0.151591,0.004310,0.168559) * L5_2 + mat4(-0.037986,-0.020770,0.002817,-0.127011,0.063475,-0.078927,0.004874,0.025312,0.154534,-0.250881,0.007740,-0.162383,-0.206340,0.042400,-0.002602,-0.062529) * L5_3 + mat4(-0.080068,0.097341,-0.005893,-0.100681,-0.275758,-0.144201,-0.008792,-0.147599,0.014856,-0.108975,-0.005454,-0.045448,0.045766,0.014365,0.008126,0.191743) * L5_4 + mat4(-0.113488,0.024369,0.001380,0.089496,0.057534,0.345732,-0.004335,0.213375,0.163073,0.158424,-0.003290,-0.303479,-0.037810,0.051390,-0.006386,-0.042401) * L5_5 + mat4(0.041301,-0.273271,0.003337,-0.131837,-0.135731,0.030511,0.002007,-0.064166,0.004970,0.023501,-0.009422,0.057722,-0.370682,-0.025932,-0.004475,0.097445) * L5_6 + mat4(-0.056823,-0.228189,-0.004498,0.014105,-0.024379,0.005849,0.001063,-0.001606,0.087780,0.094916,0.003158,-0.040311,0.161469,-0.018284,0.000129,0.013812) * L5_7 + mat4(-0.155896,-0.044473,0.000721,0.100607,0.076139,-0.041781,-0.000321,-0.298487,-0.053214,-0.028806,-0.002716,-0.056824,-0.148101,0.110820,0.000882,-0.049249) * L5_8 + mat4(0.192801,-0.181967,0.002782,0.011531,0.152323,-0.257637,-0.004034,-0.362852,-0.147633,0.094132,0.004286,0.235348,-0.071106,0.185044,-0.007636,-0.059069) * L5_9 + vec4(-0.232606,-0.958810,0.003855,0.206208)));\nvec4 L6_7 = sin((mat4(-0.160899,0.026847,-0.120208,-0.200988,-0.036496,-0.197973,0.057068,-0.123375,0.032284,-0.124442,0.086689,0.005852,-0.098513,-0.298829,-0.203664,0.020646) * L5_0 + mat4(-0.177049,-0.180457,-0.096904,-0.399075,0.144918,0.063500,0.021505,0.087166,-0.387379,0.020405,-0.146353,0.460075,-0.115106,0.079158,-0.097823,-0.255314) * L5_1 + mat4(0.228080,0.115141,-0.038077,-0.176939,-0.069196,0.253861,0.086034,0.351883,0.043110,-0.222168,0.062298,-0.134790,0.384062,-0.206503,-0.109208,0.010144) * L5_2 + mat4(-0.143082,-0.139302,0.007027,-0.217486,-0.014889,0.103941,-0.087012,0.185349,0.021230,-0.482007,0.106283,-0.042584,0.123096,-0.027423,-0.102829,-0.033524) * L5_3 + mat4(-0.071509,-0.278962,0.001269,0.006125,0.153795,-0.080044,-0.035537,-0.093263,0.029272,-0.038192,0.158520,-0.224679,0.412876,0.029151,0.211076,0.096726) * L5_4 + mat4(0.078077,-0.013565,-0.212326,0.240785,0.087058,0.087234,-0.124480,-0.205671,0.044564,0.157258,0.006126,0.049892,-0.025563,-0.143003,0.005140,0.106060) * L5_5 + mat4(0.337137,-0.083980,0.133775,0.289178,0.051415,0.095608,-0.112247,0.348902,-0.014237,0.217013,-0.134296,-0.047421,-0.012892,-0.223300,0.026258,-0.000718) * L5_6 + mat4(0.328511,-0.083297,0.047975,-0.180053,-0.137153,-0.065996,0.038104,-0.012536,0.216498,0.163024,0.093157,-0.158823,0.123420,0.347769,0.050547,-0.225516) * L5_7 + mat4(-0.192129,0.040115,0.080611,0.148698,-0.064099,0.100593,-0.014197,0.081227,-0.001248,-0.229825,-0.026582,0.007027,0.030582,0.093679,0.113903,0.018991) * L5_8 + mat4(0.192102,-0.365227,-0.097994,0.161773,0.688609,-0.211920,-0.267818,-0.107061,-0.132768,-0.236561,0.036550,0.111685,-0.201417,-0.036220,-0.015441,-0.145729) * L5_9 + vec4(0.603191,-0.238116,-0.002235,0.014775)));\nvec4 L6_8 = sin((mat4(0.003222,0.002214,-0.177136,0.027539,-0.002818,0.001003,-0.204846,0.014841,-0.001755,-0.005368,-0.063689,0.012820,0.003499,0.006656,-0.275663,0.359529) * L5_0 + mat4(-0.003351,0.002976,-0.008622,0.131733,0.008288,0.000677,0.171572,0.034284,-0.002209,0.003448,-0.334218,0.021746,-0.000833,-0.001902,-0.493326,-0.111594) * L5_1 + mat4(-0.001698,-0.005353,0.056574,-0.130653,-0.005151,-0.001373,-0.417757,-0.300000,0.004821,0.005832,0.252040,-0.116914,-0.010338,-0.005408,0.320560,0.165982) * L5_2 + mat4(-0.003251,0.001468,0.331384,0.041327,-0.006067,0.002280,-0.032121,0.073372,-0.007481,0.002793,1.113302,0.174606,0.004802,0.001598,-0.079692,0.096117) * L5_3 + mat4(0.007928,-0.002558,-0.039000,0.082312,0.001877,0.000988,-0.153711,0.077239,0.005077,0.003328,0.226239,0.147422,-0.007013,-0.010869,0.292267,0.001733) * L5_4 + mat4(0.005749,0.015366,-0.493011,-0.026591,-0.002881,-0.008343,-0.431598,-0.010387,0.001657,-0.002981,0.242123,-0.126214,0.000806,0.000241,0.190841,-0.132146) * L5_5 + mat4(-0.003397,0.005433,0.130047,0.001759,-0.002638,-0.000660,0.193832,0.184789,0.007526,0.009399,-0.069649,-0.138891,-0.009093,0.006189,0.175328,0.079512) * L5_6 + mat4(0.005795,0.004181,0.016254,0.053985,0.000376,-0.001621,0.123793,0.120690,0.006838,0.001789,-0.335088,0.000444,0.005635,0.005741,-0.060492,0.037016) * L5_7 + mat4(0.006278,-0.001334,0.408018,0.026161,0.009913,0.003733,0.298592,0.273001,0.005815,-0.003325,0.074989,0.005342,0.005094,-0.011681,0.065891,0.048684) * L5_8 + mat4(0.000562,-0.002670,-0.255150,0.340128,0.006240,-0.009439,0.028960,-0.251871,0.006753,-0.007703,-0.076781,0.058590,0.001616,-0.000215,-0.786707,0.333274) * L5_9 + vec4(-0.006348,-0.002434,-0.054571,-0.000432)));\nvec4 L6_9 = sin((mat4(0.000659,0.002647,0.001206,0.005579,0.000829,0.000734,-0.001952,-0.001587,0.009065,0.003379,0.004615,0.005487,-0.000431,-0.002166,0.003456,0.004746) * L5_0 + mat4(-0.000531,-0.001175,-0.010377,-0.000977,0.005573,0.004462,-0.004774,0.005580,0.002133,-0.002535,0.001390,0.000504,0.009053,0.004867,-0.004384,0.001908) * L5_1 + mat4(-0.003694,-0.000935,0.010652,-0.003675,-0.005611,-0.001811,0.002259,-0.010141,-0.000587,0.004173,-0.003445,-0.002042,0.004400,0.003084,0.002708,-0.005979) * L5_2 + mat4(-0.002140,-0.008571,-0.005708,-0.006310,0.007303,0.004172,0.000865,0.000976,-0.000361,0.000252,0.006244,-0.004513,0.012775,0.005775,-0.004281,0.005017) * L5_3 + mat4(0.002600,0.003302,-0.003129,0.003732,0.002805,0.000596,0.004272,0.004752,0.000974,-0.000788,-0.006975,0.003438,-0.002999,0.000300,0.003408,-0.008452) * L5_4 + mat4(-0.000850,-0.000249,-0.007809,0.000638,0.003680,0.003228,0.003308,-0.001878,0.003273,-0.000313,-0.003169,-0.003094,0.000159,0.000895,-0.002098,0.010564) * L5_5 + mat4(-0.006577,-0.001008,-0.001139,-0.004395,0.005934,0.007216,-0.000876,0.002074,0.004306,-0.002237,-0.005673,0.007731,0.001061,-0.004945,0.007384,0.001765) * L5_6 + mat4(-0.002216,-0.001730,-0.000380,0.005313,0.005695,0.005676,-0.002742,-0.000915,0.001354,0.008018,-0.002943,0.004781,0.006755,0.008094,-0.000565,0.009478) * L5_7 + mat4(-0.000343,-0.003546,-0.002951,-0.002644,0.004820,0.000018,-0.012400,-0.003512,-0.001791,0.004042,0.003359,0.002072,-0.001948,-0.001289,0.002298,-0.004293) * L5_8 + mat4(0.001710,-0.000940,0.000346,-0.003884,0.000102,-0.005526,-0.000120,-0.001475,-0.000029,0.004429,-0.003084,-0.007526,-0.003728,-0.003431,0.001748,-0.004853) * L5_9 + vec4(0.004684,0.007491,-0.008331,-0.004244)));\nvec3 F_0 = (mat4x3(0.001834,-0.012685,-0.024440,-0.009253,0.085460,0.006072,0.000525,0.000705,0.000224,0.023945,-0.012163,-0.072321) * L6_0 + mat4x3(0.040536,-0.087220,-0.296239,-0.077636,-0.026266,-0.071827,0.005799,0.000135,0.002473,0.015672,-0.010792,-0.010975) * L6_1 + mat4x3(0.000401,0.000324,-0.000494,0.000039,-0.000342,-0.000142,-0.094932,-0.059335,-0.064869,-0.033916,0.100982,-0.020017) * L6_2 + mat4x3(0.000465,-0.000249,-0.000213,0.003988,-0.016761,0.007520,-0.000151,-0.001230,0.000965,-0.000604,-0.001569,0.000096) * L6_3 + mat4x3(0.008523,0.005076,0.005423,0.000494,0.000934,-0.000180,-0.016927,-0.007725,-0.014631,-0.109439,-0.070054,0.023291) * L6_4 + mat4x3(0.000512,0.000737,0.001149,0.001224,-0.005857,0.005122,0.002198,-0.006656,-0.008264,0.022649,-0.006127,-0.035694) * L6_5 + mat4x3(0.028839,0.011661,-0.029807,0.119856,0.104587,0.104108,0.000722,0.000854,-0.000264,0.059977,0.023858,0.044098) * L6_6 + mat4x3(-0.038508,-0.030428,-0.032719,-0.039204,-0.024927,-0.032312,0.007057,-0.026149,0.019247,-0.027181,-0.019447,-0.019100) * L6_7 + mat4x3(0.000287,0.000395,0.001371,0.000715,0.000238,0.001073,0.002685,0.005480,-0.001066,0.071237,0.084033,0.095065) * L6_8 + mat4x3(0.000652,0.000339,0.000897,0.000435,0.000327,0.000203,-0.000468,-0.001164,-0.001565,0.000464,-0.000044,0.000831) * L6_9 + vec3(-0.371355,-0.206290,-0.129140));\nreturn F_0;\n}\n\n#pragma optimize(on)\n\n\n\n#pragma optimize(off)\nvec3 Lightmap_Render_HPG(const vec3 view_0, const Hidden hidden)\n{\nvec4 L3_0 = hidden.H_0;\nvec4 L3_1 = hidden.H_1;\nvec4 L3_2 = hidden.H_2;\nvec4 L3_3 = hidden.H_3;\nvec4 L3_4 = hidden.H_4;\nvec4 L3_5 = hidden.H_5;\nvec4 L3_6 = hidden.H_6;\nvec4 L3_7 = hidden.H_7;\nvec4 L3_8 = sin(60.000000 * (mat3x4(-0.610537,0.026873,0.120151,-0.173276,-0.018691,1.065181,-0.357831,0.345083,-0.092272,-0.074188,0.122743,-0.126620) * view_0 + vec4(-0.174542,0.311827,0.216450,-0.354399)));\nvec4 L3_9 = sin(60.000000 * (mat3x4(-0.268041,-0.025890,-0.206641,-0.858249,-0.957573,0.574631,0.953496,0.019887,-0.017086,-0.228383,-0.736921,-0.276326) * view_0 + vec4(0.361415,0.268896,0.048870,0.123459)));\nvec4 L3_10 = sin(60.000000 * (mat3x4(0.239083,-0.557893,0.025580,0.056149,0.552965,-0.082052,0.261647,0.740962,0.024574,-0.388923,-0.172426,-0.071613) * view_0 + vec4(0.322267,-0.188535,-0.083640,0.213313)));\nvec4 L3_11 = sin(60.000000 * (mat3x4(-0.236946,-0.000105,0.241487,0.295747,-0.452796,-0.921740,-0.619225,0.446706,-0.751551,0.080143,0.479358,0.661693) * view_0 + vec4(0.628426,-0.205696,-0.485166,-0.485618)));\nvec4 L3_12 = sin(60.000000 * (mat3x4(0.770706,0.052310,0.007061,-0.427195,-0.053144,1.268753,-0.006384,0.240940,-0.018090,0.132392,-0.068430,0.147829) * view_0 + vec4(0.289557,-0.271671,0.142169,-0.173670)));\nvec4 L3_13 = sin(60.000000 * (mat3x4(-0.208015,0.422227,0.063400,0.266566,1.003101,0.108857,0.449129,1.024727,-0.705350,0.303469,-0.025732,0.220560) * view_0 + vec4(0.531450,-0.070543,-0.290068,-0.118927)));\nvec4 L3_14 = sin(60.000000 * (mat3x4(-0.023855,0.358287,0.009393,-1.122065,-0.451114,0.045567,0.002011,0.060031,0.126952,0.394753,0.031366,-0.098860) * view_0 + vec4(-0.061743,0.147228,-0.205003,-0.278900)));\nvec4 L3_15 = sin(60.000000 * (mat3x4(-0.298879,0.512687,-0.243146,-0.002393,-0.360974,-0.262116,0.629408,0.007093,0.267772,0.309964,-0.114587,0.048475) * view_0 + vec4(-0.240321,0.223124,0.566815,-0.187623)));\nvec4 L4_0 = sin((mat4(0.182893,0.213927,0.088585,-0.116092,1.244977,-0.499288,0.397595,1.189456,0.366967,-0.033382,0.237574,0.052374,-0.134688,-0.735386,0.104774,-0.009533) * L3_0 + mat4(-0.551168,0.272775,0.215810,-0.169062,-0.086989,-0.299916,-0.282983,0.236504,0.166143,-0.091491,-0.137329,-0.053605,0.137949,-0.588937,0.254492,0.411292) * L3_1 + mat4(0.099098,-0.009285,0.159274,0.019966,-0.040194,-0.080378,-0.068560,-0.016999,0.146498,0.214399,0.173040,-0.212996,0.272666,-0.434585,0.117807,0.052000) * L3_2 + mat4(-0.163521,-0.156558,0.111907,0.276012,0.528206,0.092327,0.035186,0.150352,-0.416287,-0.115415,0.362043,-0.125848,0.086268,0.209890,-0.232523,-0.312032) * L3_3 + mat4(0.143088,0.061056,-0.046702,-0.045613,0.163187,-0.246167,0.326276,-0.722202,0.174059,-0.210309,0.195414,0.110439,0.433439,0.180586,0.401291,0.351335) * L3_4 + mat4(0.123253,-0.056590,0.275740,-0.022816,-0.601899,-0.345201,-0.416777,0.339162,0.004256,0.277544,0.343400,-0.257403,0.066427,-0.001708,0.332484,-0.239291) * L3_5 + mat4(-0.120141,-0.012959,-0.061415,-0.105777,0.435278,0.188384,-0.173680,0.242145,-0.128438,-0.025784,0.023092,-0.072883,-0.079712,0.222444,0.159420,-0.190390) * L3_6 + mat4(-0.425082,0.351925,-0.136641,-0.985810,-0.192624,0.046525,-0.020374,0.158085,-1.215437,-0.178313,0.503897,-0.527848,-0.031329,-0.135637,0.129382,0.228334) * L3_7 + mat4(-0.138913,-0.024554,-0.003284,-0.130711,0.000647,-0.005100,-0.009795,-0.067029,0.062413,-0.003882,-0.150862,-0.171381,0.050102,-0.032514,-0.004903,-0.227679) * L3_8 + mat4(-0.034058,-0.013071,-0.022493,0.081959,-0.013834,0.024490,-0.029304,-0.150252,-0.003038,0.018020,0.000884,0.022678,0.100148,-0.015731,0.024361,-0.074145) * L3_9 + mat4(-0.021238,0.001230,-0.001015,-0.093024,-0.472393,0.051940,0.003996,-0.116006,0.142158,0.146445,0.011488,-0.402195,0.012921,-0.008995,-0.064019,-0.084178) * L3_10 + mat4(-0.034988,0.015318,0.008485,-0.077311,0.017556,-0.048444,0.011890,0.281820,0.002176,0.001797,0.005178,0.075244,0.072857,-0.032349,0.051973,0.038787) * L3_11 + mat4(0.103608,0.027931,-0.040363,-0.045968,0.016875,-0.006331,-0.001926,0.042707,-0.011189,-0.010918,0.009656,0.028761,-0.018420,-0.021160,0.073485,-0.062545) * L3_12 + mat4(-0.016944,-0.044370,0.022509,0.079825,0.219469,-0.004287,-0.022858,0.282878,-0.065471,0.033358,-0.059306,-0.117093,-0.016317,0.014428,0.009738,-0.046281) * L3_13 + mat4(-0.071795,-0.060057,0.050734,0.825328,-0.616639,-0.118578,-0.218547,0.029105,-0.070891,0.003532,0.180722,0.030590,-0.006952,-0.011373,0.052126,0.018754) * L3_14 + mat4(-0.010275,0.005279,-0.027315,-0.118725,-0.009546,-0.021460,-0.022389,0.025231,-0.004909,-0.007540,-0.015905,-0.146268,-0.053262,0.004631,0.183217,0.051646) * L3_15 + vec4(0.328699,0.023802,-0.303963,0.027973)));\nvec4 L4_1 = sin((mat4(-0.025375,-0.179846,0.023350,0.162621,-0.252701,-0.700915,0.607541,0.715396,0.000793,-0.007038,-0.190797,0.061400,-0.165974,-0.506361,0.551022,-0.127999) * L3_0 + mat4(0.003855,0.174961,-0.430339,0.321566,0.300884,0.016178,-0.145055,-0.167942,-0.074768,0.450353,-0.176706,0.237863,0.414531,0.186790,0.115531,-0.417002) * L3_1 + mat4(-0.272096,0.274472,-0.462249,-0.163820,0.191400,-0.276302,0.293628,0.349422,0.141706,-0.070268,-0.087389,-0.214557,0.406487,-0.040373,0.624016,0.608230) * L3_2 + mat4(-0.232471,-0.385153,0.063052,-0.268652,0.016289,-0.193116,-0.232231,-0.150750,-0.141352,-0.410258,0.804912,-0.092519,-0.176042,-0.434183,-0.509552,-0.421634) * L3_3 + mat4(0.359797,-0.215441,-0.304575,0.017939,-0.083557,-0.093167,-0.152761,0.203572,-0.147645,0.260042,0.005327,-0.092222,0.299493,-0.250953,-0.044678,0.107165) * L3_4 + mat4(-0.119042,-0.195148,-0.222488,-0.006896,0.062209,-0.481419,-0.516250,-0.227695,0.220936,0.083049,0.271307,0.011734,-0.054895,-0.132676,0.290205,0.020820) * L3_5 + mat4(-0.101312,0.033484,-0.264908,-0.069122,-0.034055,0.321589,-0.114562,-0.337930,-0.150613,0.385769,0.048225,-0.292495,0.035986,0.529289,-0.220853,-0.400869) * L3_6 + mat4(-0.161312,0.363056,-0.036695,-0.582775,-0.047044,-0.078644,-0.058163,0.329961,-0.420132,0.333895,0.242242,-0.180876,-0.000788,-0.201235,0.244958,0.095183) * L3_7 + mat4(-0.160047,-0.025729,0.054393,-0.106700,-0.003904,-0.110782,-0.000402,-0.033381,-0.040804,-0.203423,0.068091,-0.015474,-0.039614,0.068109,0.117769,0.119113) * L3_8 + mat4(-0.008565,0.054587,0.010631,0.006788,0.025728,0.051596,0.040781,0.021040,0.037736,0.107502,-0.015032,0.018658,-0.281241,0.058700,-0.022101,-0.000837) * L3_9 + mat4(0.018764,0.094803,0.007969,0.047366,0.676400,-0.101569,-0.022187,-0.091788,-0.030925,0.488987,0.244031,0.099027,0.017309,0.090539,0.018503,0.002642) * L3_10 + mat4(0.008348,0.000275,0.005342,-0.034582,0.001978,-0.046042,0.015412,-0.018558,-0.024166,-0.034330,-0.000820,-0.030687,-0.049651,-0.128488,0.009206,-0.024049) * L3_11 + mat4(-0.161484,-0.030213,-0.045238,-0.024199,0.030718,-0.079024,0.016674,-0.008085,0.017324,0.002406,0.005242,0.005335,-0.118251,0.085436,0.009826,0.036122) * L3_12 + mat4(-0.022355,0.004184,-0.013311,-0.001133,-0.254029,-0.085036,-0.000748,-0.109199,0.014793,-0.124973,-0.012299,0.042770,0.019143,0.055045,0.020720,-0.001358) * L3_13 + mat4(0.002538,-0.793725,-0.043550,-0.070673,0.441402,0.247063,0.140880,-0.019145,-0.072180,0.234444,-0.028043,-0.192562,0.015642,0.028511,-0.003364,-0.005429) * L3_14 + mat4(0.020906,0.152910,0.035965,-0.031091,0.012247,0.019884,-0.007072,-0.020729,-0.000963,0.074760,-0.021575,-0.000772,-0.078688,0.208423,-0.030316,-0.206584) * L3_15 + vec4(-0.326311,-0.232177,-0.219921,0.637027)));\nvec4 L4_2 = sin((mat4(-0.238121,0.095503,0.016082,0.040208,-1.136205,0.595208,-0.049899,-1.625274,-0.118335,-0.181101,0.858065,0.244376,-0.458563,0.348361,-0.927802,1.013896) * L3_0 + mat4(0.282980,-0.257792,-0.303630,0.185973,-0.401899,-0.086834,-0.199188,-0.215868,-0.365318,0.037065,0.043876,-0.093465,0.239140,0.050011,0.176934,-0.516509) * L3_1 + mat4(0.257365,0.141330,0.311366,0.032794,-0.665411,0.149413,-0.442700,0.113369,-0.056206,0.045953,0.456834,-0.271764,0.048649,-0.054829,-0.326922,-0.605566) * L3_2 + mat4(-0.025455,-0.033333,-0.186933,0.138911,-0.194562,0.147722,-0.001818,-0.039134,-0.322342,-0.549344,-0.470050,0.035311,0.850400,-0.222628,-0.121676,0.706312) * L3_3 + mat4(-0.337355,-0.327993,-0.284796,-0.568945,-0.080914,-0.416105,-0.271929,-0.270409,0.143547,0.081900,-0.189677,0.057905,-0.159805,-0.122396,0.342180,-0.297075) * L3_4 + mat4(-0.515696,0.133960,0.641968,0.232465,0.031313,-0.192319,0.029225,-0.321473,-0.064266,-0.099055,0.143918,-0.789194,0.054849,0.147001,-0.238249,0.557910) * L3_5 + mat4(-0.322530,0.020028,0.088761,-0.152752,-0.065647,0.019807,0.240822,0.551703,-0.052380,0.155958,0.097471,-0.092331,-0.015726,0.122159,0.373661,-0.117821) * L3_6 + mat4(0.005410,-0.365090,0.144117,-0.061299,-0.358457,0.076363,-0.338357,-0.454694,0.076493,-0.552057,0.293800,-0.423705,0.023494,0.136321,0.287765,-0.092285) * L3_7 + mat4(-0.164584,0.587751,-0.081647,0.127350,0.024306,0.081343,0.038757,0.002218,-0.023120,-0.111019,-0.004531,0.039485,0.020867,-0.004498,0.045255,-0.090866) * L3_8 + mat4(-0.031631,0.003841,-0.023204,-0.011966,-0.004018,0.021257,0.008762,0.009369,-0.016796,-0.016792,-0.034074,0.000928,-0.017044,0.048473,-0.031589,-0.045378) * L3_9 + mat4(0.010064,-0.024438,0.019147,0.019565,0.055099,-0.213649,0.109529,-0.118155,0.114300,-0.019249,0.087335,0.163557,-0.003074,0.115688,0.024839,-0.054188) * L3_10 + mat4(0.010032,-0.005971,0.006073,-0.007886,-0.014811,-0.060970,0.013215,-0.018449,0.025064,-0.009615,-0.013134,-0.017680,0.046813,0.026928,-0.017155,-0.042103) * L3_11 + mat4(0.011456,0.261236,0.035089,0.009859,-0.014464,-0.018828,-0.004038,0.010131,0.006724,0.004512,0.011882,-0.006084,0.004062,-0.031233,0.011808,-0.053442) * L3_12 + mat4(0.003782,0.037826,-0.002150,-0.001301,-0.093805,0.410402,0.048588,0.195550,-0.006036,-0.026560,-0.038818,-0.020219,0.012413,0.004991,0.003150,-0.014224) * L3_13 + mat4(0.010836,-0.039278,-0.081816,0.052611,0.136896,0.007713,-0.148314,-0.067167,0.110223,-0.237912,0.092344,0.124554,-0.001634,-0.036576,-0.030813,-0.011043) * L3_14 + mat4(-0.019209,0.016181,0.007438,0.002710,-0.010850,-0.025105,-0.027719,0.014972,-0.009553,0.014174,-0.035810,-0.012180,0.136739,-0.283821,0.085841,0.092870) * L3_15 + vec4(-0.713011,0.229140,0.446253,-0.549325)));\nvec4 L4_3 = sin((mat4(-0.227026,0.172619,-0.049994,-0.078365,-0.743494,-0.017857,0.397062,-0.559878,-0.224078,-0.368378,-0.104876,-0.275133,0.356473,-0.402999,0.413785,0.147013) * L3_0 + mat4(-0.097755,-0.059217,0.262350,-0.150403,-0.017059,0.277349,-0.026501,0.100670,-0.150745,-0.114693,-0.501529,0.113002,0.025879,0.194135,0.383026,0.475584) * L3_1 + mat4(0.155185,-0.031635,0.281567,0.024538,0.445486,-0.400110,-0.072767,-0.106790,-0.174237,0.287083,-0.362279,-0.050815,-0.262054,0.264414,-0.731848,-0.356309) * L3_2 + mat4(-0.043461,-0.133332,-0.108838,0.039897,0.210249,-0.131661,-0.170566,0.154031,-0.041441,0.246301,-0.152672,-0.087497,0.141891,-0.380359,-0.167206,0.055490) * L3_3 + mat4(0.052909,-0.012922,-0.108707,-0.325708,-0.448886,-0.474438,-0.205951,0.787156,0.084758,-0.476207,-0.288354,0.067404,-0.333384,0.538913,-0.122946,-0.058107) * L3_4 + mat4(-0.026665,-0.333049,-0.347763,-0.031658,-0.126301,0.441469,-0.261118,-0.384657,0.560101,0.099199,-0.044473,0.449983,0.376089,-0.441291,-0.006225,0.290222) * L3_5 + mat4(0.206088,-0.102049,-0.058774,-0.118927,0.095387,0.364527,0.061088,-0.253561,-0.461439,0.102310,-0.473868,0.586565,-0.304241,-0.195981,-0.330949,0.112125) * L3_6 + mat4(-0.406553,-0.088113,-0.357161,0.351848,0.114361,0.135891,-0.377352,0.043614,-0.339456,-0.162731,0.046995,-0.004809,-0.250574,-0.039249,-0.066856,0.016871) * L3_7 + mat4(0.231192,0.124199,-0.112673,0.045626,-0.087977,-0.018299,-0.033399,0.224132,0.026978,0.006729,0.428249,0.511214,-0.140145,-0.134366,0.077805,0.023953) * L3_8 + mat4(-0.015802,0.019601,-0.015967,-0.048246,-0.199147,0.007201,-0.084203,0.113783,0.011620,0.006650,0.010614,-0.038802,0.071361,-0.013018,-0.012003,0.059932) * L3_9 + mat4(0.023830,0.018976,-0.059434,0.094599,-0.089329,-0.122038,-0.109395,0.022009,-0.310960,-0.051809,0.073591,-0.437942,-0.110573,-0.040762,0.084490,-0.021670) * L3_10 + mat4(0.034646,-0.063370,-0.080676,0.071980,0.077060,-0.022590,0.076061,-0.106487,-0.026982,-0.042156,-0.024552,-0.139853,0.042689,-0.072793,0.041755,-0.049835) * L3_11 + mat4(0.068952,0.032646,-0.025462,0.025790,0.047572,-0.004335,0.021205,-0.037561,-0.004287,0.010053,-0.024098,-0.012769,0.004812,0.025165,0.042871,-0.028473) * L3_12 + mat4(-0.042171,-0.030767,-0.004755,0.078725,-0.066123,-0.179504,0.048044,0.023329,-0.100085,-0.001194,-0.165620,0.372954,0.001716,-0.009822,0.005443,-0.098478) * L3_13 + mat4(0.333999,0.017524,-0.377796,-0.619928,0.300258,-0.207289,0.097383,0.078495,0.168281,0.142198,-0.060136,0.099509,0.051467,0.013222,0.016599,0.052426) * L3_14 + mat4(0.045461,-0.049653,0.011017,0.111060,-0.040794,-0.010353,-0.012941,0.011969,0.011542,-0.034050,-0.110135,-0.040930,0.178018,0.126255,-0.076507,0.169058) * L3_15 + vec4(-0.879584,-0.348150,0.033775,-0.266481)));\nvec4 L4_4 = sin((mat4(0.247775,0.120563,0.103749,-0.016277,0.009244,-1.403101,-0.439473,0.491364,0.241299,-0.265237,-0.243672,0.127160,-0.120815,0.022354,0.077237,0.269114) * L3_0 + mat4(0.124234,0.030641,-0.167168,0.055391,-0.043323,0.004503,0.067082,0.196154,0.070911,0.003385,0.122362,0.126197,-0.591207,-0.120882,-0.265266,0.221159) * L3_1 + mat4(-0.202101,-0.154115,0.134832,-0.247680,-0.363254,0.104785,-0.668216,0.111346,-0.155901,0.183460,0.132763,0.010623,0.123401,-0.439444,0.125454,-0.012259) * L3_2 + mat4(-0.196577,0.143432,0.071710,-0.047728,0.056576,0.067783,-0.025628,0.121641,-0.304770,-0.236675,-0.511901,0.026679,-0.364925,0.724510,0.923892,0.057974) * L3_3 + mat4(-0.057569,-0.383280,-0.224221,0.305854,-0.599592,-0.297402,-0.404369,0.002327,0.245851,0.209287,-0.263262,-0.035925,-0.089758,0.144662,0.157401,0.405056) * L3_4 + mat4(0.219197,-0.108867,0.214096,-0.052080,0.014462,-0.320449,-0.493893,0.103848,-0.131528,0.518757,0.245528,0.213849,0.683764,-0.270501,-0.259141,0.167642) * L3_5 + mat4(-0.384827,0.214936,0.134327,-0.151128,0.517769,-0.108797,0.205411,-0.010231,0.346115,0.011595,-0.059253,-0.334761,0.011599,0.057463,-0.081205,0.056228) * L3_6 + mat4(-0.079446,0.072662,-0.634814,0.242625,-0.204371,0.221042,-0.260822,-0.251425,0.060817,-0.338027,0.203408,-0.426838,-0.046908,0.067275,0.293649,0.005546) * L3_7 + mat4(0.007345,-0.004799,-0.021197,0.575137,0.030735,-0.055463,-0.032703,0.010978,0.083063,-0.014983,-0.044109,-0.079281,-0.017635,-0.196417,0.018444,-0.134271) * L3_8 + mat4(-0.000095,-0.015975,0.004921,0.044937,-0.028516,-0.039164,-0.036639,-0.013654,-0.025250,0.005943,-0.019608,0.015744,0.010609,0.097639,-0.071071,-0.108055) * L3_9 + mat4(-0.011632,-0.012561,-0.009842,-0.007156,0.029398,-0.172918,0.263345,0.448328,-0.085169,-0.371884,-0.055473,0.003575,-0.002443,-0.044557,-0.022008,0.048814) * L3_10 + mat4(-0.001147,-0.016618,-0.009061,0.046648,0.017575,-0.021385,-0.041197,-0.015467,-0.009402,0.013297,-0.019728,-0.026897,0.006347,0.092360,0.000829,0.002193) * L3_11 + mat4(0.031856,0.125201,0.106570,0.250005,0.012594,-0.012565,-0.002440,-0.000648,0.001007,-0.006485,-0.014455,0.017508,-0.011700,0.007925,-0.085948,0.058289) * L3_12 + mat4(0.009687,-0.057165,-0.021405,0.007872,-0.076641,0.328448,0.343426,-0.368510,-0.019318,-0.029904,-0.002964,-0.006321,-0.010897,-0.018953,-0.005370,0.028635) * L3_13 + mat4(0.023903,-0.062031,-0.104403,-0.034459,-0.039185,0.504381,0.067876,0.815935,0.091083,0.078001,-0.021579,-0.103689,-0.010514,0.012328,-0.018604,-0.174173) * L3_14 + mat4(-0.002242,-0.028481,0.022405,0.067751,0.000627,-0.014483,0.012382,0.001534,-0.005176,0.016005,0.002411,-0.000032,0.102713,0.046635,-0.018870,-0.106098) * L3_15 + vec4(-0.368503,-1.142439,-0.595218,-1.208363)));\nvec4 L4_5 = sin((mat4(0.104710,0.048020,-0.496092,0.054151,-0.404865,0.521196,-0.754498,-0.288150,0.060045,-0.094389,-0.260899,0.071601,1.008312,-0.533465,-0.114901,0.041825) * L3_0 + mat4(0.082992,-0.152756,-0.281248,-0.050069,-0.333860,0.327574,-0.062853,-0.198374,-0.193711,0.035187,-0.047668,-0.187998,-0.090087,0.174028,-0.347503,-0.077878) * L3_1 + mat4(0.333716,0.073512,-0.066182,-0.175228,0.030918,0.110918,-0.310854,-0.008738,0.154961,-0.019698,-0.062747,0.307273,-0.421412,0.305674,0.053926,-0.443159) * L3_2 + mat4(0.238469,-0.116731,0.108687,-0.293584,0.004379,0.085501,0.313663,-0.022100,-0.369820,0.248682,-0.254227,0.537381,-0.092424,-0.554339,0.373986,-1.031652) * L3_3 + mat4(-0.191672,-0.031754,0.265715,-0.274186,0.094074,-0.193527,-0.020569,0.445600,0.367032,-0.106950,-0.061740,0.057168,-0.125946,0.290305,-0.416370,-0.216919) * L3_4 + mat4(0.216027,-0.487449,-0.312532,-0.550675,-0.533336,0.042388,-0.544904,0.068919,0.168604,-0.126482,0.132990,0.007265,0.276197,-0.241138,-0.611601,0.124573) * L3_5 + mat4(0.092804,0.084670,-0.366507,-0.141379,-0.244942,-0.012139,0.363199,0.181317,0.119278,-0.315328,-0.103125,-0.098971,-0.132894,-0.116086,-0.118033,0.633473) * L3_6 + mat4(-0.113456,0.138145,0.071266,0.174379,-0.190971,0.029882,-0.382880,-0.280438,-0.144649,-0.122198,0.045142,0.297766,-0.016755,0.050295,0.308072,0.048704) * L3_7 + mat4(0.114496,-0.204400,0.369583,0.056838,0.051377,-0.004087,-0.023654,0.034450,0.059173,0.073588,0.140436,0.035393,-0.049647,0.160702,0.119615,-0.037478) * L3_8 + mat4(-0.031917,0.033571,0.014550,0.017425,0.026922,0.055318,-0.171796,0.023036,-0.012664,-0.009810,-0.012815,-0.018576,0.069057,-0.253265,0.144094,0.003232) * L3_9 + mat4(-0.013704,-0.016666,0.032474,0.000087,-0.042290,1.008570,0.124767,-0.029361,0.091797,-0.007140,-0.193928,0.053808,0.109318,0.000426,-0.127455,0.002048) * L3_10 + mat4(-0.022898,-0.012276,0.067601,-0.013441,0.036522,-0.003600,0.057379,0.062573,0.045372,0.041156,0.023500,-0.014601,0.071802,-0.001540,0.041275,0.027120) * L3_11 + mat4(0.054952,0.034048,0.046349,-0.003381,0.024021,-0.015929,0.010331,0.010219,-0.000975,0.014515,0.008811,-0.008493,0.059645,0.003472,-0.194354,0.017393) * L3_12 + mat4(0.023146,0.024496,0.020415,0.019747,0.220345,-0.540195,0.176296,-0.107960,-0.082863,-0.051857,-0.038513,-0.071595,0.004463,0.010615,-0.030980,-0.017837) * L3_13 + mat4(-0.094800,0.031345,0.194761,0.096348,0.088512,-0.799413,0.453832,0.094691,-0.045458,0.182957,0.240562,0.223688,0.002650,-0.133868,-0.012743,0.016927) * L3_14 + mat4(0.011141,0.006155,0.011219,-0.057538,-0.009754,0.067289,-0.034087,0.027081,0.034145,0.017622,-0.004576,-0.039762,-0.032818,0.163488,0.251369,0.274737) * L3_15 + vec4(-0.304741,0.047507,-1.260944,-0.527092)));\nvec4 L4_6 = sin((mat4(-0.472306,-0.040764,-0.116849,-0.094419,-0.434076,0.065944,-0.810885,-1.345064,-0.361401,-0.024447,0.710105,0.470186,-0.388178,-0.338099,0.454812,0.598265) * L3_0 + mat4(0.173782,-0.056766,-0.079365,0.218678,0.358713,-0.006030,-0.415418,-0.004100,-0.012477,-0.139562,-0.101387,0.036390,0.365135,0.921774,-0.197564,-0.150965) * L3_1 + mat4(0.189683,0.148126,0.024232,0.248665,-0.132839,0.070808,0.192144,-0.560737,0.044030,-0.106710,-0.165860,0.469856,0.382985,-0.110275,-0.061344,-0.301006) * L3_2 + mat4(0.171389,0.032533,0.002285,-0.026302,-0.466140,-0.001049,-0.156594,-0.069937,-0.060083,0.035951,-0.122422,-0.014255,-0.165316,-0.140493,-0.194130,0.433975) * L3_3 + mat4(0.273741,-0.099656,-0.230779,0.191625,-0.163525,0.813176,-0.369459,0.004759,0.046582,-0.053996,0.016193,0.190718,-0.331711,0.492662,-0.213319,-0.434061) * L3_4 + mat4(-0.527044,-0.052602,0.611396,-0.059733,-0.436152,-0.391841,0.168500,0.012804,0.415708,0.301629,-0.154341,0.347406,-0.390533,-0.057534,0.364347,0.574497) * L3_5 + mat4(-0.212323,-0.178765,-0.024237,-0.019788,-0.682841,-0.107053,-0.240997,-0.349024,0.243811,0.502595,0.168748,-0.095109,-0.060868,-0.179145,0.049711,0.260434) * L3_6 + mat4(-0.101934,0.044932,-0.741613,0.213422,0.182891,0.156823,0.490951,0.218418,-0.132685,0.073389,-0.003229,-0.014830,-0.467206,0.164150,-0.044975,-0.049524) * L3_7 + mat4(0.022761,0.008323,0.459340,0.014092,0.008461,-0.077806,-0.052087,-0.046416,-0.278585,-0.406528,-0.116929,0.043310,0.043213,-0.259677,-0.082666,-0.156593) * L3_8 + mat4(-0.000806,-0.092351,0.015224,0.003774,-0.022401,-0.283539,0.024871,-0.121774,-0.047630,-0.075986,-0.022026,-0.014188,0.061660,0.032130,0.184966,-0.006019) * L3_9 + mat4(-0.002546,-0.071938,0.018013,-0.014106,-0.218778,-0.079789,0.340232,0.034536,-0.074616,0.733294,0.168067,-0.637229,-0.067599,-0.086412,-0.008919,-0.068589) * L3_10 + mat4(0.036527,-0.090541,0.073150,0.045914,0.021330,-0.254080,-0.012256,0.038192,-0.015844,0.044438,-0.024858,0.018886,-0.046339,-0.019326,0.068731,-0.032139) * L3_11 + mat4(0.026410,-0.042556,0.158245,0.031710,0.013057,0.152893,-0.003974,0.027124,0.004777,0.020241,0.015884,0.008251,-0.043013,0.031973,0.014736,-0.010401) * L3_12 + mat4(-0.014595,-0.105162,-0.023438,-0.000948,-0.031764,0.080419,-0.020087,-0.099555,0.153554,-0.458283,-0.043760,0.130752,-0.051277,0.093221,0.039308,-0.011592) * L3_13 + mat4(0.289046,0.403153,-0.071802,0.340683,0.028352,0.124475,0.930615,-0.002166,-0.230698,0.075545,-0.123107,0.067186,0.004056,-0.010335,-0.048654,0.001490) * L3_14 + mat4(-0.099751,-0.158607,0.018749,0.014978,0.013331,0.081473,0.071641,-0.026435,-0.068212,0.026845,0.017127,-0.038326,-0.284611,0.124662,-0.155448,0.061440) * L3_15 + vec4(1.178012,0.245354,-0.849887,-0.989431)));\nvec4 L4_7 = sin((mat4(0.253030,-0.556516,-0.124407,-0.217569,-0.083655,0.871718,-0.212592,0.429837,0.422799,0.097572,-0.350915,-0.268610,-0.065233,0.586691,0.040903,0.501978) * L3_0 + mat4(-0.130918,-0.708130,-0.088305,0.156801,-0.203959,-0.394794,0.099821,0.061211,0.357163,-0.017144,-0.202859,-0.391243,0.001838,-0.870892,0.671925,0.039490) * L3_1 + mat4(0.383794,0.282053,-0.018631,0.037553,0.524067,-0.348701,0.276340,0.262766,0.091241,-0.066781,0.172503,-0.324802,0.255259,-0.253445,0.177293,0.311601) * L3_2 + mat4(0.433664,0.027955,0.021629,0.467313,0.561311,-0.053931,0.195125,-0.410914,-0.449438,0.175656,-0.308575,-0.003810,0.356483,0.577167,0.344635,-0.327599) * L3_3 + mat4(-0.084376,0.027909,0.037334,0.034435,0.252233,-0.253605,-0.119981,-0.285205,-0.010479,-0.507669,0.051403,-0.216146,-0.218086,0.448915,-0.231930,0.027975) * L3_4 + mat4(0.432920,1.184851,-0.174916,-0.030476,-0.168117,-0.785963,-0.114943,-0.321051,-0.113910,-0.414886,-0.064453,0.155148,-0.472648,-0.450077,-0.193168,-0.215593) * L3_5 + mat4(-0.055940,0.223031,0.023789,0.041750,0.230924,0.159286,-0.290004,0.238393,0.603586,-0.235269,0.018939,-0.271529,-0.335259,-0.617181,-0.042621,0.174695) * L3_6 + mat4(-0.274444,0.379627,-0.549466,-0.304585,0.285205,0.213976,0.026287,0.236130,0.372952,-0.153245,0.035994,-0.284632,-0.173179,0.471269,-0.070488,0.090106) * L3_7 + mat4(0.040161,0.042629,-0.074241,0.094458,0.043046,-0.044660,0.179297,0.122622,-0.004072,-0.091376,-0.458082,-0.474950,-0.082691,-0.191943,-0.066513,-0.172275) * L3_8 + mat4(0.004311,0.006675,-0.068308,0.010910,0.031049,0.064012,-0.210464,0.301563,-0.006492,0.055604,-0.079245,0.039083,0.006269,-0.019300,-0.002325,0.008265) * L3_9 + mat4(-0.014039,-0.021044,0.025853,-0.072998,-0.183843,0.055349,-0.024474,0.037546,0.278749,0.059096,0.447657,0.980140,0.018239,-0.067566,-0.054999,0.273109) * L3_10 + mat4(0.010585,-0.030289,-0.132912,-0.070039,0.012257,-0.039570,-0.114172,0.008519,-0.031930,-0.026178,0.075345,0.087568,-0.073039,0.014407,-0.012751,0.064581) * L3_11 + mat4(-0.065600,0.034366,0.032088,-0.025265,-0.025801,0.018508,-0.009261,-0.183344,0.033810,-0.002407,0.009588,0.014918,-0.064786,-0.210870,0.078603,0.112819) * L3_12 + mat4(-0.022669,-0.032381,0.044554,0.117276,-0.078021,0.311655,-0.012193,0.025122,-0.105821,-0.013708,-0.323610,0.005953,-0.016319,0.030007,-0.020380,-0.029534) * L3_13 + mat4(-0.184491,0.100233,-0.091352,0.008682,0.362323,-0.082998,-0.055416,-0.050706,-0.222118,-0.025416,0.052111,0.166975,0.067970,0.025788,-0.018640,0.017157) * L3_14 + mat4(-0.061834,-0.085373,-0.166792,-0.090008,0.066469,0.012411,0.093194,0.067220,-0.023533,-0.030384,0.083487,-0.135900,-0.253697,-0.034206,0.065184,0.272103) * L3_15 + vec4(0.730494,-0.887668,0.371329,-1.144264)));\nvec4 L4_8 = sin((mat4(0.059726,0.042364,0.007704,0.099968,0.455665,-0.062193,-1.147520,0.690165,0.132498,-0.327810,0.024706,0.380698,0.382686,0.815723,-0.115952,-0.196894) * L3_0 + mat4(0.056131,0.658218,0.194699,-0.480291,-0.064578,0.013312,0.338083,-0.129797,-0.129970,-0.234196,0.129943,0.022481,-0.039299,-0.086619,-0.070784,0.392232) * L3_1 + mat4(0.014052,-0.170669,-0.137775,0.360590,-0.237556,-0.294489,-0.278569,-0.381034,0.142360,-0.107091,0.082666,0.289020,0.054601,0.022968,0.244742,0.057229) * L3_2 + mat4(0.215254,0.308499,0.010668,-0.216563,0.125157,0.404365,0.125812,-0.229110,0.056466,0.013980,0.271021,-0.591800,-0.094667,0.700335,-0.287512,-0.059109) * L3_3 + mat4(0.125062,-0.173808,0.223890,-0.150970,0.034200,0.071990,0.037072,0.375028,0.034398,0.089339,-0.161589,-0.043540,-0.158417,-0.442891,-0.297743,0.246512) * L3_4 + mat4(0.237500,0.129469,-0.072031,-0.047383,0.011640,0.043208,0.089015,-0.015567,0.355976,0.096809,-0.374844,0.301821,0.073716,0.681571,-0.253558,0.364133) * L3_5 + mat4(0.235673,-0.317849,0.006061,-0.129495,-0.259492,0.206707,0.103902,-0.104136,0.333971,0.368036,0.232711,0.255091,-0.131535,-0.308280,0.255391,0.180036) * L3_6 + mat4(-0.659201,0.104477,0.176634,-0.541298,0.050947,-0.559651,-0.103495,-0.199076,-0.302282,-0.128859,0.149036,0.113054,-0.103916,-0.048196,0.005504,0.229292) * L3_7 + mat4(-0.066720,-0.026303,-0.025678,-0.144688,0.008471,-0.018235,-0.039283,0.015011,-0.019099,-0.063096,-0.006725,-0.015585,0.041758,0.040628,-0.014458,0.020334) * L3_8 + mat4(0.004018,-0.014851,-0.004263,0.001326,0.002038,0.027742,-0.032976,0.060389,-0.009879,0.011937,0.007319,0.005131,0.009797,0.008727,-0.020919,-0.067252) * L3_9 + mat4(-0.002677,0.008959,-0.010639,-0.003567,-0.012532,0.019587,-0.065153,-0.001618,0.028979,0.054318,-0.047945,-0.043204,-0.056092,0.021843,-0.013954,0.024019) * L3_10 + mat4(-0.001191,0.003594,0.009619,0.009060,0.006587,-0.002088,-0.034658,-0.022125,0.000723,-0.019251,-0.000305,-0.009236,-0.044949,-0.001400,0.017016,0.001982) * L3_11 + mat4(0.007868,-0.001664,-0.043654,0.018435,0.010388,-0.012082,-0.006371,0.006995,-0.007452,-0.001130,0.007867,0.004012,0.013543,0.023117,0.007896,-0.057651) * L3_12 + mat4(0.006515,0.014668,-0.001764,0.018147,-0.137622,0.100141,0.011360,0.062583,0.023073,0.010911,0.037620,-0.000204,-0.016303,0.019473,-0.013414,-0.007072) * L3_13 + mat4(0.045587,-0.080930,-0.077264,-0.024353,-0.139620,0.006106,-0.057813,-0.124598,-0.016273,-0.062937,0.030796,0.119374,-0.027810,-0.030741,0.013133,-0.021264) * L3_14 + mat4(-0.000889,-0.002943,-0.023759,-0.011295,0.009517,0.002807,0.038981,0.034291,0.002518,0.025040,0.014839,-0.000498,-0.020074,-0.070262,0.020871,0.126292) * L3_15 + vec4(-0.296397,0.519125,0.221074,-0.638629)));\nvec4 L4_9 = sin((mat4(-0.137069,-0.122701,0.029780,-0.311354,-0.791484,0.427578,1.009593,-0.311937,0.064996,0.317234,0.385504,0.292048,0.167314,0.104075,0.038544,-0.209647) * L3_0 + mat4(0.269349,0.579767,-0.497151,-0.510004,-0.006832,0.280562,0.105988,0.034904,0.494223,0.329783,-0.121697,0.328238,-0.661804,-0.110711,0.661282,0.224677) * L3_1 + mat4(0.033046,0.413824,-0.041398,-0.025305,0.181627,0.022376,0.253229,0.015209,0.581921,0.018991,0.393154,0.119935,0.005538,0.378611,0.179349,-0.232651) * L3_2 + mat4(-0.218960,-0.334384,0.080492,0.589850,0.066005,-0.310722,0.017457,-0.210534,-0.065079,-0.085017,-0.130809,-0.000651,0.201456,0.125596,-0.173202,-0.171038) * L3_3 + mat4(-0.180217,-0.190778,0.102820,0.424913,0.184998,-0.056628,0.146981,0.181074,-0.100609,-0.363814,-0.175348,-0.200462,-0.106379,-0.006114,0.352124,0.097922) * L3_4 + mat4(0.272546,-0.127294,-0.032158,0.522866,-0.210199,0.229526,0.304825,0.823007,-0.832730,-0.645459,0.078897,-0.460050,-0.235860,-0.297622,0.036731,0.531024) * L3_5 + mat4(-0.417160,0.280824,-0.112708,0.391734,0.153506,-0.218901,0.026892,-0.095228,0.047820,-0.328749,-0.652449,0.255681,-0.193933,0.147640,-0.012597,-0.143718) * L3_6 + mat4(-0.042177,0.564450,-0.023790,0.097324,0.036333,-0.034725,-0.301574,-0.353978,-0.291600,0.627189,-0.483269,-0.163403,-0.236245,-0.260375,0.206721,0.224476) * L3_7 + mat4(0.060306,0.042787,-0.213113,-0.088049,-0.010319,-0.002671,-0.073714,-0.005862,0.063931,-0.040104,-0.074155,-0.031842,-0.239377,0.010048,0.124573,0.024647) * L3_8 + mat4(0.002340,-0.019213,-0.006556,-0.015118,0.021158,-0.008898,-0.001051,0.004754,-0.028421,-0.000064,0.012812,0.009660,0.025125,0.021758,0.028739,-0.007361) * L3_9 + mat4(0.031716,-0.002264,0.015172,-0.031298,-0.062128,0.034407,-0.263236,-0.095358,-0.628014,-0.137568,-0.040776,-0.090607,0.040519,0.017721,-0.078401,-0.019758) * L3_10 + mat4(-0.076694,0.001378,-0.018084,0.009229,0.032643,-0.013296,0.031658,-0.019855,-0.014011,-0.016862,0.009222,0.012475,-0.110536,-0.023772,0.065804,0.072567) * L3_11 + mat4(0.049278,0.010313,0.006107,-0.007851,0.008327,0.010335,-0.016300,-0.016111,0.002760,0.001723,-0.019902,0.008905,0.140378,0.009993,-0.029270,0.042495) * L3_12 + mat4(-0.012282,0.002725,0.015026,0.010719,0.008062,0.029503,-0.009673,-0.081357,0.120934,-0.015893,0.003324,-0.048036,0.007628,-0.001270,0.022713,0.011732) * L3_13 + mat4(-0.146523,-0.093809,0.116957,-0.013257,0.038801,0.010007,-0.444507,-0.002771,-0.063070,0.001777,0.087451,0.086845,-0.036657,-0.010591,0.024927,0.013891) * L3_14 + mat4(-0.084483,0.018066,-0.045741,0.035094,0.032357,-0.028384,-0.069387,0.028826,0.002767,-0.002639,-0.026015,0.033634,-0.084086,-0.005006,0.031684,0.084167) * L3_15 + vec4(-0.194103,-0.041546,0.222749,-0.173377)));\nvec4 L4_10 = sin((mat4(-0.059152,-0.105910,0.009818,-0.042763,1.270713,0.161831,-2.045982,-0.277741,-0.077996,-0.181772,-0.659078,0.274722,0.043339,0.383742,-0.075855,0.560979) * L3_0 + mat4(-0.156658,0.068977,0.053970,-0.002853,0.140402,0.552625,-0.313506,0.200614,0.093944,-0.247267,-0.131850,-0.260944,0.499225,0.288859,0.068918,-0.125341) * L3_1 + mat4(-0.241131,0.287598,-0.476936,-0.221831,0.521929,-0.380679,-0.187513,-0.021813,-0.478086,0.391854,-0.160459,-0.264089,0.454462,1.036683,-0.166440,-0.212427) * L3_2 + mat4(0.182003,-0.389494,0.364638,0.007535,0.098125,-0.003560,-0.357304,0.165004,0.018086,-0.352001,0.086892,0.611533,-0.086224,0.079024,0.531372,0.174954) * L3_3 + mat4(0.331327,0.411952,-0.263001,-0.158196,0.458422,0.165592,0.031208,0.599791,-0.181396,-0.129775,-0.116306,-0.078767,0.007693,0.327044,0.430093,0.227723) * L3_4 + mat4(-0.132067,-0.313809,0.176395,-0.086282,0.779109,-0.497211,-0.299547,0.187695,-0.067387,0.529924,-0.253024,0.109198,-0.540342,-0.724210,0.294569,0.333649) * L3_5 + mat4(0.048690,0.260945,-0.284411,0.350281,0.187006,-0.052755,0.480474,-0.368240,-0.534422,0.347225,0.136818,-0.416748,-0.054244,0.069078,-0.039077,0.347380) * L3_6 + mat4(0.729258,-0.751921,-0.275529,0.123133,0.498518,0.169011,0.207936,-0.094231,0.204104,-0.289475,0.118317,0.501633,-0.119570,-0.328435,0.059747,0.163115) * L3_7 + mat4(-0.117456,0.143969,0.082834,-0.080428,-0.104853,-0.003649,-0.001855,0.001356,0.008979,0.135174,-0.075932,-0.023350,-0.081178,0.060939,-0.197882,0.052218) * L3_8 + mat4(-0.012439,0.013891,-0.001423,0.012742,-0.106708,0.066557,0.015397,0.221073,0.045401,0.032571,0.009635,-0.019779,0.063941,0.058538,0.033833,-0.061846) * L3_9 + mat4(0.055521,0.011639,-0.003912,0.039780,-0.250357,-0.271563,0.134469,-0.033686,-0.288244,0.227246,-0.028408,0.555939,0.022058,-0.021486,-0.033560,0.029317) * L3_10 + mat4(0.010644,-0.031470,-0.030170,-0.055144,-0.031319,-0.007127,-0.089223,-0.081300,-0.055397,-0.014970,-0.006488,0.008518,-0.147860,-0.058110,0.036083,-0.022021) * L3_11 + mat4(-0.091223,-0.012852,0.005596,-0.101180,-0.015931,-0.008683,-0.019334,0.004514,-0.029318,0.027393,0.018512,0.006385,0.141836,-0.007698,-0.048331,0.023133) * L3_12 + mat4(-0.062949,-0.004251,0.000946,0.008150,-0.457394,0.396951,-0.047254,0.154507,0.001047,-0.003523,-0.029354,-0.103286,0.055779,0.005432,-0.013086,-0.009693) * L3_13 + mat4(-0.113003,-0.088178,-0.033844,-0.330798,-0.010463,-0.172708,0.226262,-0.102045,-0.047550,-0.131358,0.314171,0.050520,0.002449,0.010189,0.031339,0.006604) * L3_14 + mat4(0.027953,-0.038554,-0.028824,-0.032540,0.008210,-0.012726,-0.002044,-0.007047,0.060544,0.002721,0.015470,-0.005849,-0.065542,-0.118239,0.332812,0.035351) * L3_15 + vec4(0.990602,0.641505,-1.073744,-0.599792)));\nvec4 L4_11 = sin((mat4(0.273035,-0.082582,0.242667,0.436323,-0.188617,-0.465740,-0.747740,0.434821,-0.228790,-0.467507,-0.024118,0.294550,-0.160132,0.517662,0.195033,0.221664) * L3_0 + mat4(0.033533,-0.303893,-0.287930,0.022064,-0.033241,0.108284,-0.192999,-0.477619,-0.109849,-0.168505,0.095402,-0.014796,-0.031438,-0.521586,0.152141,0.711316) * L3_1 + mat4(0.051188,-0.209810,-0.057526,0.105576,-0.466011,0.362061,-0.140585,-0.041963,-0.087637,0.005822,-0.029470,-0.129946,-0.162652,-0.492590,-0.093789,-0.250368) * L3_2 + mat4(-0.052357,-0.040104,0.340586,-0.036613,-0.002216,0.068134,-0.020294,-0.212170,0.095701,-0.398771,-0.146887,-0.142997,-0.172153,1.030415,0.212080,-0.394870) * L3_3 + mat4(0.077833,-0.340253,0.261541,-0.080983,0.417754,0.054900,0.070004,0.454847,0.038004,0.178150,-0.207088,-0.276049,0.285582,0.231870,0.027746,0.856669) * L3_4 + mat4(-0.065934,0.111124,0.176327,0.135275,-0.310073,-0.249162,-0.363131,0.536006,0.266876,0.064533,0.018860,0.366162,-0.210844,0.005186,-0.026528,-0.301606) * L3_5 + mat4(0.178126,-0.003898,0.109544,-0.111902,0.062636,-0.534489,0.007582,-0.010994,0.337112,-0.124149,0.052720,0.138438,-0.040075,-0.324584,-0.171032,-0.465728) * L3_6 + mat4(0.262137,-0.537606,-0.047965,0.340653,0.111609,0.001005,0.027573,-0.046520,0.538022,-0.007720,0.114183,0.480862,-0.286997,-0.254665,-0.151502,0.258601) * L3_7 + mat4(-0.047438,-0.052479,-0.565814,-0.155516,0.026677,-0.129344,-0.030665,-0.100352,-0.011925,0.168600,0.043136,-0.368492,0.024120,0.318394,0.001738,-0.323473) * L3_8 + mat4(-0.007765,0.028902,0.068903,0.054106,-0.010878,0.068328,0.009787,0.233066,-0.026269,0.083191,-0.003316,0.069963,-0.071908,0.035005,-0.314007,-0.065343) * L3_9 + mat4(0.002892,-0.024707,-0.033830,-0.087132,0.059335,0.036568,0.645949,-0.059710,0.010431,-0.654475,-0.060711,0.552001,-0.034779,0.059859,-0.056334,0.020859) * L3_10 + mat4(-0.006707,0.122987,-0.096015,-0.072199,0.043038,0.040895,0.027791,0.068807,-0.000010,0.054944,-0.025418,0.093636,-0.005570,0.079222,0.037585,0.000217) * L3_11 + mat4(-0.033877,0.026032,-0.151702,0.029558,0.013875,-0.062506,-0.008607,-0.082895,0.004225,0.012964,0.004513,-0.004155,-0.008593,-0.024871,0.072584,-0.015536) * L3_12 + mat4(0.023560,0.031570,0.019754,0.020471,0.130305,-0.152011,-0.294245,0.164475,0.027340,0.274392,-0.029824,0.062907,-0.015246,0.019659,-0.037547,0.023472) * L3_13 + mat4(0.052714,-0.031973,-0.038212,0.404350,-0.266480,-0.056021,-0.998440,-0.023420,0.148179,-0.357044,-0.221070,0.025965,-0.004380,-0.032429,-0.133686,-0.025028) * L3_14 + mat4(-0.024815,0.130029,-0.082815,-0.036082,0.007958,-0.034158,0.038703,0.126905,-0.004312,-0.014297,-0.020870,-0.112527,0.149834,-0.377935,-0.262993,0.004401) * L3_15 + vec4(0.087713,1.105679,1.572831,-0.062088)));\nvec4 L4_12 = sin((mat4(0.038713,0.352899,0.128647,0.315333,-0.987108,-0.491990,0.828857,-0.400543,-0.219582,0.118264,0.189992,0.001852,0.136614,-0.225608,-0.060513,-0.142933) * L3_0 + mat4(-0.337609,0.130223,-0.192837,0.323520,0.176216,-0.601517,0.103318,0.011682,-0.094296,-0.360095,0.141340,-0.177187,-0.406566,-0.362963,0.209254,-0.370760) * L3_1 + mat4(0.009930,0.182688,-0.063343,0.047821,-0.351753,0.234659,0.161753,0.319815,-0.268019,-0.284221,0.173573,0.246811,-0.209722,-0.472406,0.377580,-0.099992) * L3_2 + mat4(0.245487,-0.288446,0.198049,-0.009828,-0.065960,0.419703,0.199081,0.370763,-0.022321,-0.156120,-0.690160,-0.770697,0.202005,0.298388,0.383852,0.515535) * L3_3 + mat4(-0.003018,0.085958,0.269232,0.198309,-0.117507,-0.697750,0.153626,-0.208911,0.076744,-0.141904,-0.148480,0.267767,-0.480915,-0.047661,0.375128,-0.552797) * L3_4 + mat4(0.316382,0.192809,-0.172310,-0.418256,-0.041793,0.309644,0.588425,-0.136418,0.538808,0.767177,0.083493,-0.150717,-0.215092,-0.047828,-0.039865,-0.053245) * L3_5 + mat4(0.407510,0.212726,-0.014627,-0.320087,-0.222232,0.061315,-0.045397,-0.126066,0.090898,-0.204062,0.067412,-0.247238,0.153070,-0.289434,-0.043117,0.041862) * L3_6 + mat4(0.004114,-0.200382,-0.124443,0.584165,-0.127869,-0.343138,0.175313,0.417214,-0.289035,0.038229,0.292388,-0.154778,0.121066,-0.192160,0.202180,0.076067) * L3_7 + mat4(-0.022117,0.174317,0.001935,0.043151,-0.002472,0.054527,-0.028741,-0.002349,-0.125484,0.661038,0.004810,0.008969,-0.122435,-0.368176,-0.020319,0.009020) * L3_8 + mat4(-0.017622,0.014057,0.015417,-0.002107,-0.001758,0.243026,0.050335,0.014881,0.014985,-0.049698,0.008331,-0.001298,0.013302,-0.001591,-0.000617,0.010460) * L3_9 + mat4(-0.001156,-0.044781,0.010352,0.032450,0.050104,0.037858,0.034211,-0.048513,-0.142332,-0.721023,0.064297,-0.049005,0.017405,0.191977,-0.000319,0.011172) * L3_10 + mat4(-0.045304,-0.016971,-0.021309,0.019661,-0.005287,-0.270846,-0.044715,-0.016132,-0.026481,0.105886,-0.032795,0.029271,-0.011729,0.103452,-0.037239,0.010448) * L3_11 + mat4(0.025702,0.004033,0.011446,-0.036683,-0.000753,-0.018230,-0.015837,-0.012939,-0.000733,0.022893,-0.001596,0.006212,0.010037,-0.120521,0.005973,-0.028016) * L3_12 + mat4(-0.014385,-0.040295,-0.006557,-0.000340,0.017377,-0.007662,-0.032764,0.030615,-0.005479,0.054789,-0.002698,0.045124,-0.011514,0.112962,-0.002340,-0.002947) * L3_13 + mat4(-0.130317,-0.136558,-0.106775,-0.046843,-0.058609,0.225212,-0.050174,0.028702,-0.031068,0.377067,0.005657,0.141339,0.005395,0.017671,-0.000361,0.012723) * L3_14 + mat4(-0.030210,0.038497,-0.014610,0.009350,0.023890,-0.063668,-0.004455,-0.008135,-0.003669,-0.028716,-0.009701,-0.031831,-0.023022,0.448665,0.010321,0.157156) * L3_15 + vec4(0.545818,-1.565048,-0.128011,-0.694481)));\nvec4 L4_13 = sin((mat4(0.431814,0.146430,0.145080,-0.156215,-0.605825,0.174533,0.061504,-0.184858,-0.276247,-0.628058,-0.143423,-0.023417,-0.238851,-0.075849,0.630525,0.274984) * L3_0 + mat4(0.321729,-0.144587,0.113517,0.060775,0.344290,-0.195225,-0.015427,0.022904,0.421129,-0.289924,0.053590,-0.335999,0.132965,0.001975,-0.125612,0.318745) * L3_1 + mat4(-0.154417,-0.105748,0.137928,0.125176,-0.078768,0.293033,0.363032,0.315084,0.637432,-0.012247,0.643750,-0.215455,-0.325278,-0.426309,-0.183778,-0.182360) * L3_2 + mat4(-0.263814,-0.562295,0.074566,0.246492,0.111125,-0.165683,-0.032013,-0.037131,0.169487,0.497268,-0.110451,0.189254,-0.104866,-0.546873,-0.173541,0.272708) * L3_3 + mat4(-0.175971,-0.096396,-0.100721,-0.041064,0.161267,-0.361148,-0.163726,0.003840,-0.062158,-0.063270,-0.016177,-0.088104,0.057946,0.390445,-0.110559,0.144094) * L3_4 + mat4(-0.156016,-0.070990,0.233423,0.240068,0.174788,-0.274382,-0.150501,0.030532,0.009246,0.277064,-0.226153,0.377094,0.099371,0.015650,0.011396,-0.324879) * L3_5 + mat4(0.162077,0.043223,-0.172719,-0.092956,-0.073994,0.218878,0.401697,-0.074833,0.362765,-0.065937,-0.155227,-0.319888,0.374236,0.149958,0.117572,0.057325) * L3_6 + mat4(0.176356,-0.019979,-0.674897,0.074395,0.109303,0.109911,0.098695,0.046888,0.045584,-0.370569,0.094213,0.147582,-0.004251,-0.141521,-0.401681,0.006568) * L3_7 + mat4(-0.000419,-0.131494,-0.064670,0.062373,0.034483,0.045460,-0.030765,0.036856,-0.025973,-0.047220,-0.198783,-0.474906,-0.458197,-0.014912,-0.068910,0.033487) * L3_8 + mat4(0.005956,-0.001600,-0.005027,-0.017404,0.124128,0.007966,-0.032762,-0.212145,-0.032658,-0.012413,0.026900,-0.025343,-0.004599,-0.062763,-0.012613,0.048795) * L3_9 + mat4(-0.012019,0.007077,-0.004274,0.063630,-0.017365,-0.076825,0.101709,-0.009215,0.240393,0.100765,-0.262796,0.439656,0.001368,0.054804,-0.001006,-0.199003) * L3_10 + mat4(-0.075167,-0.039598,-0.066257,-0.023381,0.117858,-0.024284,-0.028843,0.071967,-0.067100,-0.006748,-0.016686,0.004497,0.010088,0.002122,-0.013224,-0.071943) * L3_11 + mat4(-0.011948,-0.073279,-0.051848,0.022975,0.047143,-0.002936,-0.028529,-0.079862,-0.012800,0.009176,-0.010189,-0.006839,-0.017598,-0.039710,-0.007514,0.059040) * L3_12 + mat4(0.016652,0.006587,-0.007103,0.082729,0.038607,0.281801,0.061000,0.135069,-0.011430,-0.020723,-0.068681,-0.301277,-0.048326,0.017095,0.024909,0.005703) * L3_13 + mat4(0.201105,-0.046121,-0.143721,-0.506017,0.020371,0.068105,-0.134542,0.078338,0.070296,0.171471,0.082063,0.151368,0.016533,-0.021790,-0.005931,0.020610) * L3_14 + mat4(-0.069937,-0.028102,-0.006384,0.031223,0.030066,0.041591,-0.046314,0.001360,-0.107054,-0.000035,0.016871,0.020004,0.060367,0.178985,0.107213,0.162717) * L3_15 + vec4(-0.333249,-0.733987,-0.151659,-0.792937)));\nvec4 L4_14 = sin((mat4(-0.188593,0.113917,0.131578,-0.172181,-0.776950,-1.675248,-0.723894,-0.209292,-0.336024,-0.227329,0.063760,0.020959,-0.042756,0.000247,-0.140651,0.174106) * L3_0 + mat4(-0.108911,-0.413904,-0.728048,0.109726,0.407187,-0.310046,0.138332,0.053972,-0.073524,-0.525775,0.477506,0.078755,0.434816,0.026084,0.260850,-0.068219) * L3_1 + mat4(-0.004494,0.129615,-0.285861,0.007265,-0.048150,-0.261866,-0.040478,-0.008644,0.243346,-0.092511,-0.078343,0.195107,-0.274896,0.243207,0.187324,-0.018734) * L3_2 + mat4(0.227917,0.358485,-0.444932,-0.301396,-0.000664,0.126192,-0.473516,0.241955,-0.005632,0.544458,0.048062,-0.090684,0.158830,0.482977,0.205971,0.316140) * L3_3 + mat4(-0.099184,0.012349,0.014310,-0.017923,0.171112,-0.051602,0.774967,-0.333799,0.030939,-0.320432,0.162187,0.133208,0.000927,0.082746,0.232467,-0.160685) * L3_4 + mat4(-0.125597,0.164405,0.421593,0.191378,-0.356140,-0.196089,-0.134431,0.255052,0.333953,0.110424,0.290414,-0.174150,-0.040654,-0.579209,0.013982,0.224127) * L3_5 + mat4(-0.128565,0.157458,-0.274738,-0.060533,-0.200598,-0.175989,-0.279851,-0.137888,0.174708,-0.019317,0.144084,-0.040720,-0.029345,0.246070,0.145453,-0.036049) * L3_6 + mat4(-0.071199,0.119161,-0.439674,-0.212031,-0.013012,-0.328788,0.181988,0.167243,0.059236,0.601379,0.025478,-0.266262,0.111405,0.079344,0.547889,0.039798) * L3_7 + mat4(-0.015902,0.209391,-0.146233,0.241166,-0.215672,-0.059883,0.168133,-0.060894,-0.437246,0.320899,0.133000,-0.043625,-0.199623,-0.042256,-0.369713,-0.032800) * L3_8 + mat4(0.027322,-0.006342,-0.069949,-0.027530,-0.021541,0.040223,-0.030271,-0.010327,0.048022,-0.002657,-0.124589,0.035219,0.033080,0.082686,-0.011119,0.305700) * L3_9 + mat4(-0.110559,0.113584,-0.149313,0.078675,-0.002996,0.018591,-0.096630,-0.736411,0.489599,-0.373898,-0.668056,0.007336,0.137881,-0.022456,0.129937,0.002043) * L3_10 + mat4(-0.065449,0.005592,0.039031,0.053901,-0.031664,0.076794,-0.431317,-0.026332,0.068622,-0.038738,0.072571,-0.015948,0.019623,-0.159620,0.028068,0.044903) * L3_11 + mat4(-0.025730,0.023208,0.005692,-0.027799,0.061721,0.014928,-0.103800,0.007148,-0.018402,-0.000753,0.028004,0.003487,0.018510,-0.024438,-0.026294,-0.080796) * L3_12 + mat4(-0.118149,-0.069848,-0.049144,-0.041086,-0.057205,0.053315,0.137434,0.306232,-0.344906,0.057348,0.021443,0.010616,0.111227,-0.013665,0.096283,0.019799) * L3_13 + mat4(0.502819,-0.163727,0.082593,-0.023852,-0.069500,-0.039523,0.215450,1.296982,0.019774,0.039748,0.148699,0.382182,-0.017121,0.028920,0.027773,0.155006) * L3_14 + mat4(-0.102679,0.024398,-0.083679,0.042263,0.046486,-0.041545,0.027088,-0.034868,-0.071456,-0.051286,-0.138662,0.026489,0.041189,0.084099,0.137041,0.408862) * L3_15 + vec4(0.649406,-0.944559,-0.318574,-1.800340)));\nvec4 L4_15 = sin((mat4(-0.193610,0.234965,-0.339523,-0.124192,0.088026,-0.355450,0.897258,-0.447793,-0.243532,0.103511,-0.091402,-0.159508,-0.440932,0.420622,-0.003462,0.673386) * L3_0 + mat4(0.413917,0.270336,-0.197083,-0.080718,0.121831,-0.526457,-0.260678,0.589299,-0.016415,0.391076,0.428675,-0.092081,0.234842,-0.393554,0.068039,-0.204442) * L3_1 + mat4(0.083134,0.213586,0.138565,0.242902,0.242671,0.090980,0.242897,-0.013780,-0.138714,0.082039,-0.206922,0.369204,-0.435595,-0.137133,-0.344922,0.144143) * L3_2 + mat4(0.019386,0.043224,-0.132627,0.015882,0.112410,-0.227814,0.333580,0.345239,-0.031089,-0.598024,0.114686,-0.028908,0.035921,-0.283044,-0.194891,1.106296) * L3_3 + mat4(0.115273,-0.090698,0.014675,-0.083196,-0.701948,-0.029184,0.177943,0.013093,-0.033490,-0.270446,-0.098737,0.053347,-0.015347,0.273176,0.541621,-0.519666) * L3_4 + mat4(-0.039301,-0.083367,0.765868,0.430194,-0.355021,0.552302,0.144284,-0.152092,-0.100154,-0.366346,-0.545792,0.149820,0.254537,-0.244315,0.056158,0.088561) * L3_5 + mat4(0.041993,0.026330,0.089928,0.445333,0.619500,-0.090242,-0.071036,0.507818,0.401185,-0.145505,-0.416838,0.547949,-0.314761,-0.356643,-0.082651,-0.148096) * L3_6 + mat4(-0.376552,-0.320257,0.570724,0.066869,0.030138,-0.025907,0.402337,0.020209,-1.236007,0.339153,-0.019131,0.369512,-0.060879,-0.117206,0.116368,-0.185383) * L3_7 + mat4(-0.319565,-0.014850,0.036297,-0.104442,-0.003332,0.096778,-0.018679,0.036856,0.076944,-0.045190,-0.335217,0.072023,0.179260,-0.205444,-0.222678,-0.042670) * L3_8 + mat4(0.011790,-0.017860,0.022875,-0.027369,-0.011204,0.170126,0.036623,-0.060981,0.019620,-0.072890,-0.052159,-0.029460,-0.048956,-0.018367,-0.005668,-0.033431) * L3_9 + mat4(-0.003586,-0.030374,0.025043,-0.004332,-0.305921,-0.067467,0.051817,-0.128726,-0.048046,0.477708,0.057244,-0.097019,-0.013109,-0.025683,-0.097964,-0.007887) * L3_10 + mat4(-0.028372,0.048315,0.037793,-0.019950,-0.030039,-0.006101,-0.122912,0.010280,0.011307,-0.001201,-0.034703,0.006629,0.029949,0.044274,-0.026439,-0.026584) * L3_11 + mat4(-0.251610,0.027558,0.014030,-0.087165,-0.004563,0.004484,0.011550,0.000730,0.014298,0.004695,0.015845,0.012115,0.223082,0.010728,0.015026,0.081948) * L3_12 + mat4(0.004640,0.027068,-0.033875,0.027968,-0.279822,-0.092679,-0.066533,-0.492719,0.044442,0.048738,0.140100,-0.052663,0.000925,0.020153,0.019745,0.001986) * L3_13 + mat4(0.039704,0.183720,0.207207,0.065268,-0.356011,0.112063,0.219752,-0.140764,0.304498,0.024452,-0.144575,0.142083,0.028543,-0.007549,0.006075,0.002258) * L3_14 + mat4(-0.016618,0.087560,0.018421,0.007690,0.072805,0.038279,0.000819,0.069567,0.030685,-0.054886,-0.040805,0.007728,0.349656,0.016558,-0.153294,0.113195) * L3_15 + vec4(-0.141989,0.242422,0.195537,0.247534)));\nvec4 L5_0 = sin((mat4(0.039427,0.138913,0.119630,-0.117879,-0.230608,0.169907,0.137664,0.649228,0.114733,0.684189,-0.327663,-0.128826,0.010672,-0.123531,0.219981,0.004687) * L4_0 + mat4(0.402910,-0.081841,-0.030203,0.023349,0.043794,0.188029,0.090069,-0.100493,-0.139471,0.261745,-0.289637,-0.173410,0.014129,0.036629,-0.299393,0.253627) * L4_1 + mat4(0.241885,-0.083486,-0.531010,0.099423,0.179835,0.755720,0.221810,0.143019,0.182815,0.125914,0.311106,0.102524,-0.034665,-0.084542,0.240524,0.134001) * L4_2 + mat4(-0.078853,0.260913,-0.269602,-0.195038,0.298498,-0.258411,-1.025682,0.449836,0.142030,0.134438,0.086969,0.009983,0.152743,0.039048,0.021129,-0.048755) * L4_3 + mat4(-0.219229,0.020250,0.258431,0.369411,-0.179953,0.332962,0.021361,-0.249242,-0.119104,-0.219837,-0.255494,0.310091,0.414286,0.474119,0.102832,0.193864) * L4_4 + mat4(-0.124295,-0.020224,-0.347257,-0.241424,0.149487,-0.062697,0.160616,-0.128554,-0.009680,0.013116,-0.094929,0.065228,0.294902,-0.505564,-0.535431,0.285546) * L4_5 + mat4(0.094635,0.129271,0.138068,-0.073132,0.050356,-0.106075,-0.029254,0.007305,-0.182738,0.146923,-0.012035,-0.045837,0.111350,0.025493,0.181952,-0.095907) * L4_6 + mat4(-0.434707,0.201032,-0.117786,0.207957,0.039665,0.151958,-0.167507,0.040334,-0.032650,0.414811,-0.013015,-0.030780,0.012599,-0.163379,-0.046189,0.095029) * L4_7 + mat4(0.080182,-1.045844,0.185666,-0.148771,-0.464480,0.235904,-0.167967,0.252485,-0.300491,-0.197813,0.698978,-0.115019,-0.212803,-0.660495,-0.329353,-0.528807) * L4_8 + mat4(0.023281,0.091524,0.049319,0.090663,-0.417464,-0.013886,0.732095,-0.197913,-0.340983,-0.171138,0.258727,0.122782,-0.008795,-0.232607,-0.048960,0.091316) * L4_9 + mat4(-0.087734,-0.165813,-0.065297,-0.000825,-0.022316,0.149163,-0.030533,0.026917,0.083673,0.164017,-0.002036,0.107857,0.034509,0.027300,-0.151695,0.111994) * L4_10 + mat4(0.351351,0.412747,-0.168414,-0.033677,0.088645,0.047216,0.081950,-0.099499,-0.100452,-0.484895,-0.011968,0.121165,0.169103,-0.192341,0.042186,0.029101) * L4_11 + mat4(-0.328179,-0.466187,0.531368,0.162801,-0.066654,0.156066,-0.022422,0.029382,-0.480389,-0.109899,-0.674514,0.245114,-0.232957,-0.154723,0.312286,0.117518) * L4_12 + mat4(0.013658,0.006848,-0.040409,-0.125555,0.088386,0.055684,-0.251450,-0.119961,0.251058,-0.437116,0.434511,-0.018404,0.122986,-0.048497,-0.005597,0.084254) * L4_13 + mat4(-0.122058,0.071042,-0.102344,0.016887,-0.233981,0.085219,-0.105899,-0.093906,0.064735,-0.199905,-0.026170,-0.024808,-0.181238,-0.048179,0.016932,0.224056) * L4_14 + mat4(-0.028574,0.171688,-0.245304,0.049639,-0.280773,0.004444,-0.373706,0.130891,-0.109165,0.359796,0.305680,-0.159381,-0.198747,0.128572,0.151327,-0.189237) * L4_15 + vec4(0.586843,0.613812,0.613264,-0.576665)));\nvec4 L5_1 = sin((mat4(0.039907,-0.075223,-0.103016,0.064076,0.070765,0.313916,-0.541970,-0.471992,-0.366122,-0.160056,-0.234335,-0.278302,0.041052,0.062097,0.115278,-0.025541) * L4_0 + mat4(0.143539,0.142425,0.113691,-0.137400,-0.009802,0.127803,-0.080571,-0.085496,0.147883,-0.316059,-0.004421,0.279712,0.187021,-0.173892,-0.262804,-0.061415) * L4_1 + mat4(0.273418,0.318719,-0.063583,-0.086014,0.009446,0.028414,0.017838,0.026378,0.024528,0.171177,0.035457,0.125276,-0.202075,0.108755,-0.131440,0.133571) * L4_2 + mat4(-0.146780,-0.107645,0.028466,0.108206,0.138862,0.107955,0.240066,-0.064701,-0.022169,0.055673,-0.025175,-0.027742,0.128796,0.072979,0.080010,-0.114819) * L4_3 + mat4(-0.535019,0.333318,-0.041914,-0.044748,0.006078,0.082926,-0.001242,-0.155682,-0.053274,0.090634,-0.063165,0.016715,-0.001589,0.089166,0.019376,0.159575) * L4_4 + mat4(0.022474,-0.040497,-0.293555,0.133784,-0.235436,-0.002445,0.042416,-0.052411,0.212122,-0.103457,0.009385,-0.158963,-0.245707,-0.064379,-0.006096,-0.162469) * L4_5 + mat4(0.218921,0.093505,-0.038257,0.052144,-0.064890,-0.017932,0.082700,0.110600,-0.189221,0.083775,0.065898,0.041375,0.238422,0.160153,0.202098,-0.045800) * L4_6 + mat4(-0.157466,-0.106917,0.015378,0.274976,0.052170,-0.011256,-0.008882,-0.020885,-0.086023,0.041576,-0.068045,-0.152853,0.026966,-0.114937,-0.020114,0.230826) * L4_7 + mat4(-0.164987,-0.614068,0.620082,0.160047,-0.120763,-0.012834,-0.006953,0.223249,0.161641,0.313128,-0.129287,-0.370926,0.311225,0.088088,-0.033681,-0.317898) * L4_8 + mat4(-0.013957,0.040516,-0.008101,0.011423,0.097833,-0.389228,-0.257539,0.096273,0.097598,0.221717,0.055792,-0.104567,-0.067734,0.111843,0.189513,0.223688) * L4_9 + mat4(-0.034023,-0.127993,0.031243,-0.066377,0.161613,0.007257,0.084965,0.034554,-0.124800,0.037074,-0.266393,-0.090460,-0.189800,-0.036855,0.066689,0.026215) * L4_10 + mat4(-0.415508,-0.243958,0.258617,-0.242709,-0.102176,0.175493,0.134895,-0.131825,0.186066,-0.057014,0.027392,-0.242943,0.186658,-0.012085,0.106493,0.053125) * L4_11 + mat4(-0.284609,-0.479206,0.268497,0.005032,-0.066085,0.092660,0.047746,-0.053483,0.348941,-0.012596,0.632970,0.621214,-0.069170,0.259009,-0.182741,0.009722) * L4_12 + mat4(0.209169,-0.067021,0.014873,-0.047800,-0.284422,0.105471,-0.050563,-0.167963,-0.756813,0.052269,-0.032078,-0.012347,0.094153,-0.096457,0.070917,0.206311) * L4_13 + mat4(0.118971,0.009443,-0.142987,-0.140462,-0.094054,-0.069160,0.020919,0.014494,-0.099076,0.040706,-0.032895,0.021678,0.225711,-0.053943,0.040211,-0.199040) * L4_14 + mat4(0.149514,-0.101243,0.019376,0.188544,-0.074695,-0.165276,-0.074950,0.212403,0.264255,-0.009658,-0.095976,-0.037982,-0.318717,-0.006623,0.059834,-0.078008) * L4_15 + vec4(0.305446,-0.478096,1.226682,1.359219)));\nvec4 L5_2 = sin((mat4(-0.033817,0.087602,0.077938,0.144153,-0.089818,0.338326,0.022565,0.454685,0.387221,0.010029,0.358646,-0.268442,-0.089638,-0.074998,-0.121524,-0.071888) * L4_0 + mat4(0.093851,-0.108344,0.058583,-0.145550,0.017661,0.075852,0.127798,-0.072358,0.301901,0.014240,-0.040544,0.258085,0.324038,0.255531,0.136712,-0.026500) * L4_1 + mat4(-0.046587,0.024074,0.318482,0.215552,-0.060682,-0.114721,-0.224001,0.425314,-0.064652,0.119298,0.133302,0.231604,-0.012358,0.008762,-0.088322,0.184256) * L4_2 + mat4(0.030403,0.024879,-0.270095,-0.246073,0.049324,0.179806,0.120737,0.106583,-0.059298,0.096316,0.259773,0.278413,0.008446,-0.043953,0.106298,-0.065236) * L4_3 + mat4(-0.032450,0.282157,0.096187,0.552127,0.063022,-0.071073,-0.118074,-0.211032,-0.201033,0.124178,-0.089040,0.014571,-0.022619,-0.097550,-0.023195,0.249885) * L4_4 + mat4(0.206372,0.123099,0.145245,-0.148395,-0.181537,-0.045870,-0.145666,0.245234,0.045414,0.046999,0.057970,-0.234357,-0.046870,0.032831,0.160645,-0.430576) * L4_5 + mat4(-0.064490,0.090338,0.014060,-0.080317,-0.023978,-0.126041,-0.122528,0.139536,-0.014694,0.020771,-0.150322,0.125129,0.102023,0.022870,-0.158558,-0.247753) * L4_6 + mat4(0.094558,-0.039909,-0.032115,-0.003721,-0.018038,-0.024192,0.055333,-0.064557,0.111512,0.214573,0.042566,-0.221666,0.009625,-0.040145,-0.191835,0.113874) * L4_7 + mat4(0.410008,-0.093252,-0.211197,0.487551,0.191122,-0.048908,0.059377,0.132490,-0.209569,0.543793,-0.537798,-0.006027,-0.084591,0.067682,-0.087000,-0.404528) * L4_8 + mat4(-0.103264,0.219439,0.161283,0.122629,-0.087942,0.017039,0.123869,-0.224104,-0.040466,-0.252438,0.050181,-0.212047,0.001434,0.171821,0.105973,0.270400) * L4_9 + mat4(-0.152464,0.164851,0.072384,0.292138,0.007883,0.126698,0.197055,0.187901,-0.067079,-0.063232,0.055878,0.147890,0.036857,-0.154458,-0.139295,0.081394) * L4_10 + mat4(0.306412,0.029222,-0.371219,-0.558702,0.031038,0.060274,0.206044,-0.042427,0.034162,0.028527,0.221398,-0.442708,-0.027494,-0.163128,-0.031733,0.030666) * L4_11 + mat4(-0.529192,-0.277873,-0.302652,0.248477,0.000485,0.107487,0.169616,0.247197,-0.049872,-0.400510,-0.230334,0.282957,-0.103698,0.198007,-0.280908,0.140896) * L4_12 + mat4(-0.043375,-0.103524,-0.284767,-0.042810,-0.014561,-0.143792,0.026315,0.430342,-0.162704,0.092103,0.035674,0.365283,-0.046618,-0.232819,-0.165543,0.255100) * L4_13 + mat4(-0.009193,0.150590,0.198842,-0.234021,-0.084111,-0.022439,0.074413,0.011011,0.022010,0.062307,0.006188,-0.125116,0.270164,-0.015987,0.304415,-0.531975) * L4_14 + mat4(0.011038,-0.021514,0.054097,0.100017,-0.049532,0.249012,0.103401,0.085349,0.098190,-0.139558,-0.034370,-0.205002,0.083662,-0.124796,-0.116586,-0.011554) * L4_15 + vec4(-0.148721,1.001666,0.448955,-1.052635)));\nvec4 L5_3 = sin((mat4(-0.218281,0.061699,-0.325623,0.054230,-0.071905,0.482121,-0.177803,0.247459,-0.324302,0.093955,0.228281,-0.270410,-0.024489,-0.057163,-0.042913,0.022345) * L4_0 + mat4(0.122906,-0.053593,0.270718,-0.065468,-0.165549,0.072556,0.086294,-0.084780,0.439418,-0.161280,0.126920,-0.136673,0.298396,-0.176184,0.050888,-0.214164) * L4_1 + mat4(-0.026339,0.035561,-0.083156,0.007511,0.026834,-0.012083,0.002299,0.071312,0.211558,0.076081,0.137181,0.032453,-0.117930,-0.119582,0.025364,0.080238) * L4_2 + mat4(-0.103211,-0.251648,-0.282302,-0.155673,0.199811,-0.107235,0.094946,0.123436,-0.192473,-0.075577,-0.380678,-0.109268,-0.056595,0.043048,0.264556,0.148616) * L4_3 + mat4(-0.460023,-0.148968,0.023331,0.262149,0.061907,-0.132582,0.012710,-0.090002,-0.051247,0.013369,-0.243006,-0.008335,0.081951,-0.043508,0.271892,-0.055717) * L4_4 + mat4(0.006434,-0.014425,0.077070,-0.150860,-0.151710,-0.005083,0.019784,0.100486,-0.349559,-0.035611,0.002924,-0.179403,-0.580986,0.039048,-0.034779,0.069030) * L4_5 + mat4(-0.154254,-0.035934,0.123626,-0.175542,-0.097860,-0.058559,-0.185480,-0.037298,-0.046718,-0.008044,0.095938,-0.103779,-0.028399,-0.088413,0.292496,0.153844) * L4_6 + mat4(-0.236949,0.001013,0.176319,-0.083553,0.026086,-0.011056,-0.256184,0.085778,0.187787,0.024590,0.218851,0.004265,0.069124,-0.069402,-0.228969,0.026639) * L4_7 + mat4(-0.817977,-0.437155,-0.022238,0.745083,0.014511,0.190315,0.063996,0.102266,0.163849,0.225237,-0.307859,-0.372697,-0.187739,-0.052048,0.212226,-0.267176) * L4_8 + mat4(-0.212950,0.039654,-0.248959,-0.077730,0.045043,0.033543,0.221521,-0.458038,0.216958,-0.096058,-0.032095,0.235825,-0.102100,0.056370,0.018013,0.090843) * L4_9 + mat4(0.218325,0.017227,-0.131211,0.064851,-0.085029,-0.029745,-0.051778,-0.126879,0.614791,-0.112195,0.132373,-0.001940,-0.019170,0.225405,0.148690,-0.006069) * L4_10 + mat4(0.110194,0.052899,0.266012,0.045335,0.005934,0.076450,0.217824,0.143771,-0.103109,-0.016182,-0.276202,-0.012682,-0.074519,-0.065309,-0.004065,0.095936) * L4_11 + mat4(-0.302210,0.123886,0.051041,0.133824,-0.051224,0.028160,-0.078004,-0.078322,-0.184377,-0.303244,0.079278,-0.051894,-0.367618,0.169414,-0.169173,-0.165175) * L4_12 + mat4(-0.040923,-0.060838,-0.097166,0.004383,0.096293,0.110073,0.025752,-0.087298,-0.227843,-0.052383,-0.434088,-0.111387,-0.029353,-0.068776,-0.198900,-0.004107) * L4_13 + mat4(0.220220,0.073884,0.273962,-0.046871,0.011814,0.000742,-0.120706,-0.053360,-0.065292,0.091006,0.089290,-0.035306,0.062475,-0.038207,-0.253202,-0.095635) * L4_14 + mat4(0.129282,0.023696,0.031652,-0.059400,-0.134810,0.028223,-0.050598,-0.050677,-0.270827,-0.059327,-0.133201,-0.114876,0.010513,0.050158,0.200707,-0.024490) * L4_15 + vec4(-0.053417,-0.147215,1.260438,-0.553405)));\nvec4 L5_4 = sin((mat4(0.016159,-0.018229,-0.066791,-0.028632,0.273216,-0.015666,0.017224,-0.259662,-0.327301,0.064869,-0.067682,0.097920,0.029071,0.094391,-0.122954,0.189130) * L4_0 + mat4(0.000763,0.140644,0.064755,-0.180767,-0.009924,0.009415,-0.113754,-0.187081,-0.093909,-0.002516,0.098185,-0.015112,0.079916,0.146429,-0.142257,0.075975) * L4_1 + mat4(0.162309,0.070800,-0.010943,-0.009065,0.073592,-0.049462,0.342838,0.129097,-0.247821,-0.146364,0.502725,-0.195684,0.036559,0.005212,-0.324767,0.084392) * L4_2 + mat4(-0.252125,0.120419,-0.153084,-0.240788,-0.209291,0.045254,-0.471647,-0.252632,0.024615,-0.025398,-0.160734,0.120861,-0.028044,-0.163906,-0.121067,-0.250759) * L4_3 + mat4(0.303213,0.179673,-0.360492,-0.217200,0.029679,0.064272,0.251505,-0.303848,0.069218,-0.169190,0.030551,-0.249747,0.017870,0.198949,0.097220,-0.035238) * L4_4 + mat4(-0.273993,-0.089255,-0.541462,-0.312586,-0.030178,-0.119900,0.172632,0.260403,-0.126611,-0.148936,0.113966,0.046470,0.088413,0.218690,-0.131529,-0.087327) * L4_5 + mat4(0.175979,-0.206402,0.505419,0.152700,0.053885,0.254983,0.016783,0.319540,0.006136,-0.126403,0.090247,-0.023133,-0.186332,0.453910,-0.143979,-0.081458) * L4_6 + mat4(0.092209,0.036597,-0.106547,-0.321836,-0.081472,-0.148149,-0.394708,-0.043196,-0.217736,-0.119888,-0.233953,-0.068104,-0.114655,0.076949,-0.089412,0.034189) * L4_7 + mat4(-0.267488,0.078972,-0.183436,0.337610,0.373478,0.321432,-0.670449,0.421413,0.318190,0.115492,0.958122,0.367137,-0.027637,-0.184480,0.701172,0.007318) * L4_8 + mat4(0.151031,-0.310525,-0.291805,0.390216,-0.032698,-0.091508,1.253089,0.005901,-0.156061,-0.129663,0.199783,-0.223445,-0.043468,0.510796,0.178312,-0.032964) * L4_9 + mat4(0.002624,-0.012132,-0.376988,-0.146193,-0.182932,-0.093470,0.235863,0.176080,0.104258,-0.018994,-0.673959,0.073210,0.176471,0.178910,0.302627,-0.314097) * L4_10 + mat4(-0.404595,-0.048958,0.000295,-0.255260,0.129580,0.017353,0.327630,-0.049273,-0.208995,-0.181817,-0.046051,-0.323734,0.002537,0.067462,0.025253,-0.076363) * L4_11 + mat4(0.287237,0.049711,0.080092,-0.332201,-0.079762,-0.163970,0.005365,-0.117871,-0.007400,-0.532869,-0.654538,-0.576985,0.664250,-0.168201,0.465370,0.165355) * L4_12 + mat4(-0.241944,-0.264149,-0.245807,-0.127927,-0.329563,0.188275,0.349560,-0.293495,-0.003205,0.113174,-0.102804,0.100702,0.141703,0.082401,-0.165265,0.276852) * L4_13 + mat4(-0.112450,-0.319589,-0.037911,-0.505773,0.061293,-0.177327,0.171048,-0.586388,-0.072919,0.109002,0.080377,-0.096755,-0.078257,-0.077324,-0.035817,-0.524564) * L4_14 + mat4(0.257050,0.032111,-0.216740,0.025503,0.036835,0.038664,-0.025459,0.111828,-0.137859,-0.061921,-0.242938,-0.265971,0.171158,-0.119909,0.423692,0.249527) * L4_15 + vec4(0.405246,0.151027,-0.499315,-0.393748)));\nvec4 L5_5 = sin((mat4(-0.086751,-0.034214,-0.024136,-0.016046,-0.047844,0.176328,-0.238547,-0.384078,-0.366899,0.262093,0.019455,0.090044,0.100695,-0.349085,-0.040848,-0.215060) * L4_0 + mat4(0.143139,0.344525,0.091084,-0.227796,0.018805,0.172289,-0.041829,-0.023323,0.115883,-0.087293,0.145919,0.202172,0.103784,-0.252257,0.237607,-0.107478) * L4_1 + mat4(-0.435000,-0.431344,0.044866,0.176670,0.118058,-0.135828,-0.048534,-0.044870,-0.341379,-0.256175,0.042987,-0.161552,-0.435088,0.038197,-0.081008,0.126004) * L4_2 + mat4(0.376915,0.221916,0.350639,-0.288902,-0.236219,-0.259256,-0.085505,-0.034165,-0.128898,0.181556,-0.129994,0.079690,0.047177,0.206309,-0.069966,-0.230007) * L4_3 + mat4(0.032276,0.374835,0.005576,0.218259,0.132572,-0.238308,0.139496,0.016817,0.699438,-0.071104,-0.181246,-0.100978,-0.153605,-0.028149,-0.099646,-0.092891) * L4_4 + mat4(0.287334,-0.401055,-0.068920,-0.216352,0.084880,-0.322628,-0.060023,0.171273,0.144171,0.171942,-0.164412,0.207569,0.079415,0.238958,0.305574,-0.459998) * L4_5 + mat4(0.344947,-0.402224,0.065094,0.109957,-0.022934,-0.163793,0.140936,-0.067664,-0.117220,-0.013589,-0.011455,-0.011636,0.043036,0.102417,-0.046145,-0.467572) * L4_6 + mat4(-0.119345,-0.111297,-0.079100,0.168008,-0.342229,-0.162730,-0.048681,0.028315,0.121017,0.244076,-0.154775,0.130454,-0.101171,-0.053389,0.099423,0.129713) * L4_7 + mat4(-0.441733,0.335032,-0.158135,-0.203281,0.335789,0.252249,0.072364,0.087012,-0.175418,-0.161789,-0.244368,-0.521734,0.234072,-0.125894,-0.065638,0.230448) * L4_8 + mat4(-0.110084,0.213571,-0.083114,-0.047012,0.210728,-0.221774,-0.069949,0.412730,-0.685263,0.006392,0.119514,0.202989,-0.595307,-0.051683,-0.053855,-0.111032) * L4_9 + mat4(0.007067,0.245476,0.067529,-0.034571,0.268049,-0.051489,-0.107101,-0.004717,0.223935,-0.199419,0.038685,-0.068506,-0.013047,0.402474,-0.003472,-0.020848) * L4_10 + mat4(-0.062643,0.712110,-0.304234,-0.086128,-0.034041,-0.059949,-0.074043,-0.167837,0.290454,0.453394,-0.108352,-0.065934,0.155908,-0.139756,-0.012925,-0.233671) * L4_11 + mat4(0.212389,1.039243,-0.167387,0.364179,-0.074770,0.025770,-0.013071,-0.122549,0.356630,-0.811840,0.468188,0.679623,-0.239375,-0.227912,-0.182846,-0.351707) * L4_12 + mat4(0.338788,0.046817,0.096970,0.064195,0.330009,-0.529540,-0.206376,0.298644,-0.168269,0.205566,-0.050685,0.149785,-0.153550,-0.185380,0.101751,0.120468) * L4_13 + mat4(0.035978,0.266285,-0.065019,0.042656,-0.089363,-0.016913,0.014496,0.062033,0.186370,0.061831,0.001458,-0.014816,-0.335323,0.450116,-0.121124,-0.092843) * L4_14 + mat4(-0.184538,-0.141923,0.054708,-0.184695,-0.304649,-0.190682,-0.139757,0.233311,0.014223,0.180397,-0.127234,0.052196,0.027403,-0.199650,-0.076536,0.123191) * L4_15 + vec4(0.972944,-1.465063,-0.942070,1.250737)));\nvec4 L5_6 = sin((mat4(0.176007,0.004510,0.210484,-0.116361,-0.175241,-0.149344,-0.284375,0.144334,0.419581,0.239931,0.184270,0.211217,-0.314614,0.080238,0.298837,0.082170) * L4_0 + mat4(-0.252537,0.055186,-0.003792,-0.054418,0.315148,0.012316,-0.349260,0.122337,-0.041333,-0.272089,0.190388,0.091500,-0.159424,0.084082,0.728472,0.309790) * L4_1 + mat4(-0.070613,0.336374,0.195147,-0.002604,-0.054330,0.052022,0.032233,-0.200178,0.294615,0.048301,0.039141,0.128298,0.090663,0.250759,0.333700,-0.255075) * L4_2 + mat4(-0.225314,-0.096612,0.267916,-0.260782,0.022612,0.121313,0.282239,0.143099,0.208478,0.178534,-0.082176,0.037083,0.112011,-0.012595,-0.206570,0.184087) * L4_3 + mat4(0.406629,0.138284,-0.270572,-0.093215,-0.111057,-0.261407,-0.157301,0.116843,-0.063951,0.889346,0.001750,-0.138067,-0.163390,0.135910,-0.214532,-0.092323) * L4_4 + mat4(0.127038,-0.154186,-0.152093,0.122434,0.058922,0.095876,0.090227,0.111874,-0.033913,-0.117699,0.356949,-0.049342,-0.370770,0.363445,0.204603,-0.051008) * L4_5 + mat4(-0.074054,-0.199809,0.034535,-0.067883,-0.118505,0.152409,-0.188185,-0.160256,-0.125170,0.155948,0.047560,0.005332,-0.101701,-0.102864,0.219054,0.240557) * L4_6 + mat4(0.014088,0.121195,-0.092579,0.132424,0.001000,0.161422,0.137763,0.163807,0.024556,-0.194762,0.124306,0.338491,-0.210456,-0.127102,-0.186014,-0.211632) * L4_7 + mat4(-0.151571,-0.745947,-0.805836,0.592838,0.399992,0.143261,-0.252485,0.044104,-0.590051,-0.094270,-0.337536,0.716827,0.063470,-0.392529,-0.075490,0.036615) * L4_8 + mat4(0.099108,-0.130522,-0.058774,0.118571,-0.197660,-0.292953,0.026993,0.067197,0.107414,-0.713779,0.018149,-0.303186,0.097203,-0.330388,-0.010118,0.075081) * L4_9 + mat4(0.004302,-0.096747,-0.062257,-0.050932,0.036843,-0.045594,0.060370,0.009164,0.064847,0.608004,-0.012569,-0.240312,0.283906,-0.190172,-0.241879,0.224916) * L4_10 + mat4(-0.196194,0.465375,-0.012528,0.055392,0.271238,-0.138789,0.040482,0.216314,0.020426,-0.333784,0.195600,0.078013,-0.254908,-0.054444,-0.211910,0.036951) * L4_11 + mat4(-0.029651,0.455325,-0.218507,0.026340,0.247933,-0.142761,-0.016131,0.041493,0.622812,-0.750117,0.021781,-0.233245,-0.060989,-0.484363,0.060939,0.140565) * L4_12 + mat4(-0.088342,0.066780,0.226953,-0.106577,0.248769,-0.150794,0.167557,-0.188580,-0.062035,-0.033646,-0.091759,-0.090122,-0.123771,0.020397,-0.144039,-0.215307) * L4_13 + mat4(0.079967,-0.051233,0.406317,0.010407,0.150447,-0.275848,-0.173449,0.020269,0.044270,0.074598,0.149774,0.093601,-0.119831,-0.626122,0.219713,-0.112798) * L4_14 + mat4(-0.007352,-0.127278,-0.070309,-0.040278,-0.099557,-0.279035,-0.186071,0.121605,0.278168,0.133640,0.028866,-0.002085,-0.045133,0.121084,-0.288771,0.161443) * L4_15 + vec4(-0.880340,-1.691927,-0.640702,0.504470)));\nvec4 L5_7 = sin((mat4(-0.109809,0.072695,-0.109224,0.074386,-0.185311,0.013126,-0.032152,1.420781,0.110956,-0.048824,-0.611644,-0.216938,0.124295,0.131292,-0.021004,0.044020) * L4_0 + mat4(0.402223,-0.017836,-0.027166,0.120931,-0.104538,-0.174982,-0.151821,-0.093678,-0.069359,-0.035342,0.079761,0.001700,-0.146907,-0.304042,-0.012870,0.318644) * L4_1 + mat4(-0.128754,0.057187,0.058324,-0.082213,-0.133301,0.221459,0.177347,0.072120,-0.016212,-0.213464,-0.247166,-0.074905,-0.056024,-0.127497,0.070218,-0.158580) * L4_2 + mat4(0.444764,0.001292,0.105346,0.244336,-0.096127,0.396686,-0.238622,-0.259145,0.166865,0.185987,0.032119,-0.233879,-0.235341,0.067532,-0.070125,0.083153) * L4_3 + mat4(0.164743,0.093481,0.098715,0.023066,-0.036033,-0.194132,-0.028369,0.352722,0.131599,0.069966,0.041007,0.055385,-0.022611,-0.003955,0.115299,-0.184167) * L4_4 + mat4(-0.169320,-0.073658,-0.084976,-0.169829,-0.435599,0.081469,0.239895,-0.027515,0.219576,0.000165,-0.126751,0.234165,0.366349,0.302036,-0.220112,-0.301662) * L4_5 + mat4(-0.194153,-0.009212,-0.037703,0.340393,0.124177,-0.037606,0.034353,0.093128,0.228410,-0.104965,0.033138,-0.028979,-0.011286,-0.169276,-0.214298,-0.135592) * L4_6 + mat4(0.339036,-0.199389,0.181045,-0.068429,-0.102803,-0.004725,-0.060683,-0.134181,-0.076316,0.041287,-0.244715,-0.044373,0.251390,-0.003543,-0.017601,0.156201) * L4_7 + mat4(0.543907,0.061127,0.209660,0.796652,-0.048554,-0.262232,-0.032135,0.031928,0.420635,-0.558214,0.420159,-0.906332,-0.201101,-0.500065,-0.301850,0.908722) * L4_8 + mat4(-0.180657,-0.022593,-0.151250,0.079015,0.068935,-0.244040,0.144756,0.484389,0.036408,0.202878,0.322533,-0.096870,0.084766,-0.020002,-0.207646,-0.274717) * L4_9 + mat4(-0.065685,0.196305,-0.088038,-0.088191,0.141294,0.075641,-0.058437,-0.115158,-0.010353,-0.029391,0.017771,-0.068232,0.001595,-0.078535,-0.034621,0.108752) * L4_10 + mat4(0.505819,0.112570,-0.516478,-0.321474,-0.139604,-0.038831,-0.011467,0.027258,0.223118,-0.144864,-0.200173,0.165379,0.075375,-0.069645,0.028126,0.115691) * L4_11 + mat4(0.007035,0.258007,-0.313113,-0.287106,-0.128333,-0.002090,-0.041362,-0.014949,-0.344198,-0.670931,0.296866,-0.312228,-0.023135,0.064944,0.166894,0.110498) * L4_12 + mat4(0.186234,0.112604,0.225865,0.035077,0.116531,0.314878,0.029977,0.245831,0.384883,0.207045,0.143490,0.186087,0.067955,-0.010890,0.323284,-0.012843) * L4_13 + mat4(-0.203100,0.065135,-0.038674,-0.051026,0.005228,-0.165026,-0.086385,-0.172651,-0.156247,-0.042954,-0.119889,-0.107727,0.365961,-0.266531,-0.368925,-0.020651) * L4_14 + mat4(-0.394713,-0.008711,0.084201,-0.130676,-0.120860,-0.068156,-0.218297,0.229459,0.105001,-0.006790,0.154813,0.043646,0.080334,-0.139140,0.192078,0.009686) * L4_15 + vec4(-0.618602,-0.013740,1.315895,1.875982)));\nvec4 L5_8 = sin((mat4(-0.029082,-0.052978,0.030510,-0.003563,0.135484,-0.096856,-0.455026,0.359639,0.080687,-0.067265,-0.368486,-0.172123,0.117484,-0.074475,-0.023033,-0.109235) * L4_0 + mat4(0.220873,0.164203,0.005846,-0.263621,-0.115926,0.028824,0.073282,-0.063847,0.039480,0.189089,-0.186543,-0.076405,0.120804,0.135905,-0.172874,-0.172966) * L4_1 + mat4(0.069040,0.028039,-0.015291,0.155131,0.195416,0.156303,-0.071419,-0.275610,-0.033714,-0.165524,-0.038773,-0.322073,-0.035282,0.095528,0.056098,-0.219392) * L4_2 + mat4(-0.081195,-0.055850,0.034587,-0.292542,0.057856,-0.212888,0.066173,0.033384,0.064466,0.185453,0.084358,-0.112517,-0.136399,0.109362,0.045443,0.051749) * L4_3 + mat4(0.036191,0.418378,0.087327,-0.169846,-0.048676,-0.039451,-0.000983,0.038487,-0.055223,-0.002700,0.070744,0.183547,0.159604,0.319087,-0.063669,-0.388240) * L4_4 + mat4(0.111425,0.119872,0.128769,-0.076340,-0.068639,0.068739,0.057287,-0.308081,0.059934,-0.069659,0.007046,0.064243,0.081160,-0.007710,-0.082023,-0.357555) * L4_5 + mat4(0.005163,-0.027087,-0.006556,0.017149,0.180644,-0.063215,0.021134,-0.037775,-0.071397,0.019656,-0.023100,-0.114235,-0.069781,0.020509,-0.126799,-0.244881) * L4_6 + mat4(0.005779,0.035573,-0.038740,0.181176,-0.023693,-0.013500,-0.022927,-0.125442,-0.307212,0.039183,0.013508,0.014212,0.098677,-0.090818,0.003875,-0.097306) * L4_7 + mat4(-0.008655,0.345825,0.517556,0.334721,0.147799,-0.096250,0.108570,-0.120243,-0.272670,-0.148679,-0.105163,-0.505619,-0.138300,-0.086604,-0.101091,-0.209324) * L4_8 + mat4(0.042718,0.208334,0.013329,-0.132859,0.129539,0.042759,0.118756,-0.458359,0.227259,0.156378,0.132316,-0.070079,0.016933,-0.079048,0.074858,0.039755) * L4_9 + mat4(-0.089645,-0.182620,0.020418,-0.016605,-0.060224,0.129362,-0.060915,-0.191681,0.120307,0.205080,-0.135123,-0.049469,-0.078819,-0.042970,0.052428,0.295628) * L4_10 + mat4(-0.053731,-0.308788,-0.477936,0.807115,0.013026,0.189951,0.009706,0.001210,-0.060617,-0.221055,0.065364,0.279034,0.012502,-0.018234,0.003675,-0.070106) * L4_11 + mat4(0.004204,0.070957,0.185257,-0.329985,0.001061,0.121569,0.024075,0.064727,0.204698,-0.073082,0.083545,0.147009,-0.058608,-0.084841,-0.003991,-0.118461) * L4_12 + mat4(0.062532,-0.249073,-0.081989,0.068539,0.175870,-0.093922,0.239954,0.039004,0.086499,0.217233,0.232417,0.000015,0.219732,-0.170852,-0.054224,-0.169565) * L4_13 + mat4(-0.179995,0.086642,-0.000372,0.174808,-0.074320,-0.054588,0.033808,0.012247,-0.076862,0.022688,0.001707,-0.025584,0.038785,-0.160868,-0.002316,0.331194) * L4_14 + mat4(-0.010104,0.222590,-0.084956,-0.158729,-0.043559,0.060118,-0.052056,-0.011856,-0.011640,-0.052497,0.151719,-0.143378,0.012555,0.057087,0.059296,0.063190) * L4_15 + vec4(-0.323497,0.450963,-0.573767,0.568868)));\nvec4 L5_9 = sin((mat4(-0.003060,-0.218878,0.237288,0.092706,0.156275,1.490067,1.325421,-0.478642,0.114838,-0.246876,0.064197,-0.126581,-0.045429,0.097073,-0.182502,0.244614) * L4_0 + mat4(-0.007506,-0.033355,0.028640,-0.262869,0.217637,-0.077264,0.103365,-0.127259,-0.076729,-0.149612,0.149213,-0.005464,0.156700,0.133240,-0.087991,-0.271003) * L4_1 + mat4(0.200140,-0.212517,-0.182011,-0.048615,-0.059343,0.022906,0.261374,0.156517,0.007078,0.300144,0.394213,0.084998,0.060460,-0.411586,0.359832,0.096765) * L4_2 + mat4(-0.055143,-0.205419,-0.068123,0.367752,0.072773,0.231847,0.016910,0.301619,0.016154,-0.256651,0.134439,-0.068591,0.182363,0.017661,0.034016,0.084991) * L4_3 + mat4(-0.353449,0.155544,0.397416,-0.189244,0.148207,0.256262,0.280176,-0.270435,-0.211019,0.249842,-0.005145,0.117132,-0.199387,0.018794,0.033655,-0.077020) * L4_4 + mat4(-0.006730,-0.269367,-0.670566,0.161541,0.165186,0.094255,0.017464,0.074859,0.137781,-0.183814,0.095175,0.068477,0.118471,0.037186,-0.323035,0.203320) * L4_5 + mat4(0.245026,0.170069,-0.190951,0.300968,-0.165362,0.363603,-0.161700,-0.002073,0.036205,0.208832,0.315250,-0.073797,-0.053514,0.136622,-0.093864,-0.144636) * L4_6 + mat4(-0.077425,-0.073857,0.242744,-0.098374,-0.128431,0.083136,-0.079077,0.028972,0.109926,-0.366302,0.033789,0.001784,-0.139428,0.080843,0.014901,-0.057167) * L4_7 + mat4(-0.015947,0.092067,0.211865,0.304119,-0.251412,0.081282,-0.587446,-0.777569,0.420892,-0.208842,-0.258876,-0.367243,0.545655,0.044204,0.370767,-0.051113) * L4_8 + mat4(-0.053473,0.003728,-0.064132,0.124203,0.240305,-0.491954,-0.664671,0.229943,0.004384,-0.282990,0.132451,0.093853,-0.354470,-0.307029,-0.123326,-0.211083) * L4_9 + mat4(-0.024131,-0.144649,-0.186354,0.149426,0.057147,-0.245432,-0.114890,0.005399,-0.232345,0.316820,0.077568,0.025836,-0.057030,0.448043,0.261314,-0.485896) * L4_10 + mat4(-0.317346,0.032752,0.481780,0.183934,0.112070,-0.065261,0.237583,0.031241,0.214932,-0.161684,0.136875,-0.354266,-0.086874,0.248199,-0.178848,0.151673) * L4_11 + mat4(-0.218184,0.157930,0.219072,0.596412,0.075356,0.052196,0.076682,-0.062166,-0.345881,0.059889,-0.444062,-0.057475,0.072093,0.284097,0.141582,-0.338632) * L4_12 + mat4(0.106617,0.080036,-0.121333,0.240386,-0.104627,-0.720209,0.050612,-0.230451,0.001925,0.144026,-0.022771,0.070854,-0.226404,0.271798,-0.124390,0.002906) * L4_13 + mat4(0.189314,-0.330251,0.083854,0.024427,0.105811,0.016295,0.097779,-0.101679,0.052355,-0.048347,0.073796,0.045219,0.180065,-0.270309,0.207187,-0.428759) * L4_14 + mat4(0.024209,0.107724,-0.310925,0.208788,0.260959,-0.379386,-0.066331,-0.231718,0.017097,-0.234894,0.013794,0.023825,-0.067835,0.153040,0.271391,-0.024923) * L4_15 + vec4(1.102188,-0.024336,-2.246161,-1.006404)));\nvec4 L5_10 = sin((mat4(0.037426,0.027015,0.071682,0.177547,0.330269,0.258548,0.378452,-0.303862,-0.247481,-0.094390,0.469441,0.171187,-0.016981,-0.054071,0.028790,-0.008916) * L4_0 + mat4(0.006977,-0.071195,0.025045,-0.090180,-0.016127,0.108021,0.031667,0.092337,0.187799,0.054896,-0.329972,-0.168269,0.182529,-0.056029,0.383038,-0.147895) * L4_1 + mat4(-0.165926,0.041532,0.100122,0.182823,0.074123,-0.008280,0.102736,-0.002104,-0.456482,-0.025505,-0.163104,-0.337253,-0.027720,0.085837,-0.188065,0.207143) * L4_2 + mat4(0.207726,0.053368,0.077355,-0.186329,-0.042771,0.122907,-0.284070,-0.076311,-0.013453,-0.120149,-0.071314,0.002921,0.038968,0.041144,0.004841,-0.076820) * L4_3 + mat4(0.170216,-0.030752,0.059686,0.134365,0.026768,0.080426,-0.026567,-0.241043,-0.288441,-0.092523,-0.303519,0.044137,-0.134799,-0.078401,-0.084533,-0.093496) * L4_4 + mat4(0.051029,-0.036742,-0.055203,0.093550,0.022112,-0.031341,0.159354,0.024827,-0.001827,-0.000758,0.144971,0.142113,0.122183,-0.057544,0.368042,-0.062305) * L4_5 + mat4(-0.083078,0.013333,0.096215,-0.364257,-0.054996,-0.101045,0.149297,0.000383,-0.061819,-0.064590,-0.044337,0.082260,-0.092859,-0.109919,0.078340,-0.347881) * L4_6 + mat4(-0.017943,0.001233,-0.041966,0.048398,-0.098196,-0.036696,-0.125761,0.094593,-0.034179,0.069888,0.023479,-0.104599,-0.031081,-0.081796,0.041622,-0.100640) * L4_7 + mat4(0.094089,-0.834507,0.096790,-0.342618,-0.143911,0.072763,0.177253,0.135522,-0.192342,0.239294,0.158610,-0.537065,0.387332,-0.181269,0.888008,-0.053126) * L4_8 + mat4(0.010473,-0.026136,-0.122189,0.100116,0.021617,0.107550,-0.515880,0.347231,0.144703,0.071669,-0.142392,-0.167987,-0.089328,0.056781,-0.144640,0.469817) * L4_9 + mat4(0.069985,0.013356,-0.146768,0.113572,-0.059519,-0.055189,-0.125012,0.184559,0.115155,0.054646,-0.153881,-0.215237,0.080607,0.012722,-0.102527,0.342443) * L4_10 + mat4(-0.502518,0.006489,-0.307340,-0.120499,0.085526,-0.052217,-0.125440,-0.123583,0.008378,0.010712,-0.269413,0.042501,-0.078238,-0.047109,0.179434,-0.107933) * L4_11 + mat4(-0.036480,-0.204534,0.131802,0.413779,0.016139,-0.029264,-0.045526,0.043039,-0.485934,-0.079572,-0.027554,-0.240097,0.178895,-0.017627,0.085789,-0.451399) * L4_12 + mat4(0.010979,-0.028978,0.239060,-0.094466,0.054055,0.000383,-0.474199,0.407166,0.118390,-0.218353,-0.280160,-0.192137,-0.008044,-0.036851,0.238650,-0.039052) * L4_13 + mat4(0.084724,0.138629,-0.126793,0.080862,0.018065,0.022423,-0.249995,-0.026071,-0.018895,0.019276,0.025520,0.167981,-0.200882,0.008841,-0.368309,0.042195) * L4_14 + mat4(0.016603,0.045884,0.341923,0.098178,-0.053316,0.091174,-0.074596,-0.032242,-0.031997,-0.153030,-0.050460,0.095495,-0.087749,-0.168861,0.264764,-0.065772) * L4_15 + vec4(-0.073083,-0.039475,0.450595,-0.542637)));\nvec4 L5_11 = sin((mat4(-0.071140,0.211118,-0.217233,-0.348041,-0.202768,0.263960,-0.349927,-0.870979,-0.236308,0.304082,0.290032,0.034360,-0.022682,-0.403648,-0.000037,-0.162323) * L4_0 + mat4(-0.112966,-0.139608,0.161165,-0.100461,-0.018342,0.347825,0.056220,0.190652,-0.095019,-0.042217,-0.191561,-0.549032,-0.064297,-1.370847,-0.018365,-0.570786) * L4_1 + mat4(-0.006123,0.354263,0.186038,-0.154208,-0.334692,0.156660,-0.109137,-0.288638,0.174823,-0.090734,-0.306944,-0.116515,-0.065333,-0.279770,-0.304006,0.336334) * L4_2 + mat4(0.029705,-0.589036,-0.132291,0.360549,-0.037570,-0.275958,0.283529,0.169975,0.081879,0.606520,-0.043954,0.090264,0.082577,-0.020053,-0.066712,0.211838) * L4_3 + mat4(0.136439,-0.142606,-0.415238,0.089464,0.166148,-0.041198,-0.003554,0.087569,-0.029818,-0.279437,-0.045181,-0.414331,-0.155616,0.234300,0.245598,0.382354) * L4_4 + mat4(-0.217994,-0.300954,0.360182,0.225436,-0.122885,0.242212,0.153164,0.137786,0.072183,0.015055,0.329447,0.151336,0.081496,0.011616,0.780220,-0.141708) * L4_5 + mat4(0.018149,-0.062470,0.112326,0.029676,-0.092530,-0.214437,0.091916,-0.237482,-0.129597,0.016348,0.097059,-0.078384,0.034927,-0.374954,0.151602,0.304657) * L4_6 + mat4(0.051372,-0.006147,-0.223346,-0.200433,-0.013528,-0.329414,-0.158463,0.072484,0.146802,0.302618,-0.013622,0.430724,-0.072281,0.004771,0.290291,-0.316542) * L4_7 + mat4(0.211162,-0.089948,-0.549898,0.523480,-0.108950,-0.261671,0.488535,-0.230498,0.345559,0.464450,-0.593619,0.361307,0.107726,0.122499,-0.108968,0.289811) * L4_8 + mat4(0.112201,-0.289958,-0.047265,0.093318,-0.236999,-0.440541,0.078224,0.085209,0.109500,-0.023720,0.119258,-0.047564,-0.083905,0.051448,-0.160321,0.370177) * L4_9 + mat4(-0.045539,-0.383447,0.021246,0.341065,-0.087510,0.178268,0.392929,0.027293,-0.070790,-0.268703,-0.356547,-0.342570,-0.134140,0.702045,0.233659,-0.438584) * L4_10 + mat4(0.043508,1.152805,0.391077,-0.183157,0.059605,-0.262200,-0.177331,0.160194,0.091623,-0.052030,0.086593,-0.454826,-0.037194,-0.426986,0.059254,-0.214389) * L4_11 + mat4(-0.074309,-0.133091,-0.451621,-0.473394,0.106171,-0.063428,-0.058869,0.266549,0.265800,-0.243145,0.163592,0.573120,-0.020648,0.366549,0.355892,0.388921) * L4_12 + mat4(0.003404,0.215005,0.127012,-0.253552,-0.071062,0.373924,-0.233093,-0.084098,-0.062996,0.227573,-0.222786,-0.014167,-0.059813,-0.031675,0.045216,-0.560638) * L4_13 + mat4(0.039904,0.144066,-0.070871,0.367580,0.148173,0.277209,-0.028964,0.394979,-0.058389,0.081948,-0.087769,-0.095964,0.081738,0.001574,0.212861,-0.280048) * L4_14 + mat4(-0.039863,0.064838,0.427395,0.212592,0.123247,0.273599,0.308263,0.378245,-0.070669,-0.050011,-0.108589,-0.278100,-0.039224,-0.189464,-0.207655,0.389815) * L4_15 + vec4(0.889211,-0.639741,-0.395681,1.395429)));\nvec4 L5_12 = sin((mat4(-0.171909,-0.298082,0.100631,0.151351,-0.583360,0.192402,-0.368463,0.219219,-0.256187,0.021806,0.219039,-0.146643,0.245344,-0.044819,-0.010593,0.080485) * L4_0 + mat4(-0.078914,0.413997,-0.218714,0.069298,-0.206003,0.286524,-0.067984,-0.056006,0.320232,-0.239027,0.490514,0.112317,0.066948,-0.123393,-0.038385,-0.617597) * L4_1 + mat4(-0.056748,0.399339,-0.417663,-0.010844,-0.053778,0.253918,-0.022926,-0.087268,-0.334139,0.087263,0.656807,0.022950,0.071403,-0.388935,0.102284,-0.227273) * L4_2 + mat4(0.036454,-0.078834,0.245793,0.329258,0.009258,0.539635,0.152637,-0.218605,0.125418,0.088832,0.065103,0.098949,-0.063417,0.220907,-0.050409,-0.013809) * L4_3 + mat4(0.282610,-0.168600,0.004326,-0.258403,-0.032276,-0.253778,-0.011175,0.034945,0.353437,0.015786,0.023541,0.357525,0.054247,0.280335,-0.163713,0.027843) * L4_4 + mat4(0.228347,0.068929,-0.061481,-0.121499,0.090941,-0.137737,0.098496,-0.013220,-0.134170,0.200384,-0.080168,-0.026064,-0.125183,0.027237,-0.266898,0.199710) * L4_5 + mat4(-0.057270,-0.255307,0.139785,-0.001076,-0.013316,-0.054377,-0.019491,-0.022951,-0.125384,0.287599,-0.071204,-0.036463,-0.097233,-0.057139,-0.253895,0.016446) * L4_6 + mat4(0.111610,0.181959,0.200149,-0.034350,-0.031621,0.045238,-0.148705,0.267303,-0.066755,0.020506,-0.009266,-0.052981,-0.009044,-0.099847,-0.045127,0.068458) * L4_7 + mat4(0.240189,-0.735344,-0.899849,0.128841,0.153910,-0.134208,0.129715,-0.257081,-1.394381,-0.407736,-0.276092,0.671508,-0.116670,-0.257546,0.026245,-0.404675) * L4_8 + mat4(-0.000349,-0.053946,0.100708,-0.044281,-0.238548,0.044801,0.533861,0.145986,0.146031,0.266919,-0.085269,-0.171884,0.256976,-0.035217,0.409285,0.171361) * L4_9 + mat4(0.209563,-0.083261,0.008936,-0.191517,-0.043086,0.436134,0.056357,-0.031903,0.203041,-0.227041,0.172681,-0.023692,0.042551,-0.050943,0.087625,0.117408) * L4_10 + mat4(-1.270879,0.066491,-0.674765,-0.004960,0.256707,0.222433,0.028217,0.162428,-0.311604,-0.298289,-0.157456,-0.039092,0.112933,0.224409,-0.043303,0.118193) * L4_11 + mat4(-0.286147,0.442584,-0.261910,0.400207,0.085511,0.272584,0.035804,0.022302,-0.317082,-0.280051,-0.059202,0.036414,-0.110372,0.112565,-0.495134,-0.358227) * L4_12 + mat4(-0.202554,-0.217522,0.086110,0.079285,-0.211100,0.524531,0.558728,-0.026312,0.316053,-0.275049,0.048578,0.260247,0.085141,0.033382,-0.007285,-0.117545) * L4_13 + mat4(-0.080415,0.064245,0.061788,-0.017421,0.034313,-0.230751,-0.016007,0.058068,-0.208677,0.119596,-0.103297,0.014290,-0.491189,-0.136454,-0.293932,-0.139991) * L4_14 + mat4(0.090962,0.044301,-0.170150,-0.234221,-0.196927,0.369764,-0.014674,-0.206797,0.188361,-0.466075,0.201550,-0.043169,0.198558,-0.200297,-0.049150,0.037024) * L4_15 + vec4(0.376045,-1.591241,0.533494,0.541412)));\nvec4 L5_13 = sin((mat4(-0.083266,-0.052203,-0.227177,-0.032820,-0.256903,-0.600253,-0.408298,0.115673,0.025425,-0.014627,0.246850,-0.159255,-0.299529,-0.043439,0.179421,0.028686) * L4_0 + mat4(0.083156,-0.098931,0.118372,0.240486,0.327658,-0.048221,0.146981,-0.022639,0.058917,-0.524714,0.144113,-0.119117,0.094840,-0.285367,0.023724,0.050592) * L4_1 + mat4(-0.208483,0.032741,-0.199098,0.117050,-0.141056,-0.192797,-0.000138,0.262152,0.033616,-0.292024,0.605471,0.005956,0.109950,0.014294,0.009427,-0.029337) * L4_2 + mat4(-0.010360,-0.039082,-0.337005,-0.117034,0.262228,0.154438,0.247452,0.003851,-0.000294,-0.079427,0.023022,0.027323,0.307244,0.142325,0.472065,-0.004525) * L4_3 + mat4(0.078239,-0.048066,-0.270108,-0.110185,0.076649,-0.050107,-0.102433,-0.097819,0.005535,-0.174841,-0.011221,-0.038541,-0.009462,-0.056986,0.138312,0.285761) * L4_4 + mat4(0.075492,-0.003539,0.317853,-0.066570,-0.167024,0.056351,-0.015437,-0.021551,-0.068381,0.046127,0.030134,0.092654,-0.184382,-0.350227,-0.092250,0.025131) * L4_5 + mat4(0.139754,-0.001506,-0.058346,0.078846,-0.188442,-0.003014,-0.196857,0.081377,0.079808,-0.074386,-0.049066,0.298605,0.087426,-0.014493,0.593843,-0.134950) * L4_6 + mat4(0.200208,-0.089176,0.249476,0.071207,-0.098835,-0.036830,-0.098193,0.032470,0.304936,-0.019112,0.352207,-0.252807,-0.269704,-0.189317,0.060385,0.089070) * L4_7 + mat4(0.531707,-0.508179,-0.243451,-0.195263,-0.221990,0.239971,-0.047885,-0.220279,0.184687,0.935813,0.089294,0.133476,0.089778,0.374823,0.336152,0.137517) * L4_8 + mat4(-0.033720,0.130830,0.217945,-0.000307,-0.061685,-0.094881,-0.109785,-0.263971,-0.147505,-0.273251,0.166891,-0.018775,0.117377,-0.084982,0.047199,-0.143054) * L4_9 + mat4(-0.046765,0.080684,0.010799,-0.067149,0.034868,-0.003615,0.038733,0.024581,-0.067184,-0.072759,-0.099624,0.129847,-0.030969,-0.056590,-0.008822,-0.289960) * L4_10 + mat4(0.165744,-0.475528,0.288421,-0.428367,0.150088,0.169426,-0.056289,-0.008129,0.352839,-0.170843,-0.092212,-0.307206,-0.035594,0.056276,0.289774,0.058546) * L4_11 + mat4(0.231090,-0.364354,-0.322816,-0.110449,0.129214,0.028677,0.045394,-0.012181,-0.000976,-0.133020,-0.210630,-0.336633,0.105545,0.010609,-0.052447,0.181062) * L4_12 + mat4(-0.316634,-0.016273,-0.103053,0.042149,0.025866,-0.020466,-0.269787,-0.184195,-0.049059,-0.155237,-0.536937,0.147660,-0.265209,-0.046561,-0.092854,0.152935) * L4_13 + mat4(0.073866,0.002073,-0.026815,-0.066456,0.102425,0.062569,0.096194,-0.125388,0.074708,0.001205,-0.055711,-0.047188,0.409126,-0.206600,-0.192685,-0.013141) * L4_14 + mat4(0.050669,0.205758,0.102332,0.155645,0.133626,0.051220,0.415186,0.084940,0.014620,-0.068809,0.199957,-0.029779,0.016952,-0.098774,-0.258311,-0.125760) * L4_15 + vec4(1.317964,1.509601,0.450778,-0.337549)));\nvec4 L5_14 = sin((mat4(-0.179457,-0.065913,0.072298,0.096835,0.352171,-0.019767,-1.202011,-0.574135,0.556793,-0.029231,0.031624,0.097187,-0.011073,0.012089,0.313551,0.056233) * L4_0 + mat4(0.126567,-0.014211,-0.120432,0.123205,-0.126122,-0.052218,0.103907,-0.043214,-0.084759,0.283977,-0.106271,0.118050,0.353111,0.320871,-0.140459,0.302528) * L4_1 + mat4(0.011727,0.078774,0.257036,0.102747,0.053601,0.035271,-0.003099,0.150318,0.064299,-0.227235,-0.164065,0.037873,0.107408,-0.094160,0.122846,-0.002624) * L4_2 + mat4(-0.306893,-0.224361,-0.430612,0.230210,-0.619777,0.038237,-0.289327,0.676513,0.095615,0.095775,0.086339,0.039292,-0.068103,-0.025421,0.114419,-0.156878) * L4_3 + mat4(0.144508,-0.124463,-0.448727,-0.288710,-0.305773,-0.031709,-0.003358,0.068820,0.212784,-0.193297,0.069610,0.186966,0.503174,0.058578,-0.309315,0.006312) * L4_4 + mat4(-0.209289,0.173307,-0.138683,0.368437,0.215149,0.104356,0.181930,-0.111565,0.270888,0.124415,0.113904,0.074115,0.155163,0.386897,-0.871555,0.496986) * L4_5 + mat4(-0.087509,0.049061,0.120592,-0.232682,-0.051777,0.071327,-0.044495,-0.030904,0.063034,0.105101,-0.071125,0.055662,-0.156981,0.065377,-0.118371,0.319782) * L4_6 + mat4(0.184683,0.061292,0.317061,-0.242961,0.105070,-0.084292,-0.428914,-0.125943,-0.075663,-0.047565,0.184025,-0.224275,0.028444,0.105632,0.056393,0.069097) * L4_7 + mat4(0.137539,0.534795,0.517402,-0.917525,0.445373,-0.035117,-0.186357,-0.268584,0.239587,-0.691823,-0.026854,-0.025479,0.558668,-0.068293,0.195401,-0.143288) * L4_8 + mat4(0.396410,-0.050202,0.084591,-0.062466,-0.592813,0.421984,-0.273140,0.353078,0.232608,-0.005625,0.182319,-0.301160,0.106982,0.104118,-0.156641,0.433303) * L4_9 + mat4(0.063602,0.000582,0.000283,0.237332,-0.151151,0.133205,0.099598,0.487886,-0.031342,-0.090622,-0.371063,0.228092,0.084852,0.092976,0.050152,0.364345) * L4_10 + mat4(0.451010,-0.034918,-0.767430,0.060788,0.174475,-0.089655,-0.012049,0.050853,-0.412526,-0.024506,0.450930,0.290275,-0.107351,0.092401,0.202219,0.083950) * L4_11 + mat4(0.592969,0.257783,0.150591,0.150699,0.075056,-0.019658,-0.032527,0.057640,-0.306453,-0.128104,0.492267,-0.530373,0.401551,0.348916,-0.286536,-0.085709) * L4_12 + mat4(-0.214858,-0.072484,-0.077353,0.178895,0.102558,-0.176568,0.758094,0.583743,-0.392444,0.092351,-0.098689,-0.224097,-0.494201,0.127222,-0.271987,0.185643) * L4_13 + mat4(0.175856,-0.039993,-0.110576,-0.160378,0.155261,-0.047766,-0.110701,0.068496,0.210198,-0.073705,0.075782,0.009047,-0.403866,-0.035323,0.278562,0.368745) * L4_14 + mat4(0.108326,0.026235,-0.318085,-0.270223,0.351048,0.076334,0.361031,-0.062434,-0.030861,0.033963,0.079217,0.001142,0.245160,-0.131042,0.117279,-0.348862) * L4_15 + vec4(-2.594345,-0.711873,1.368474,-1.236302)));\nvec4 L5_15 = sin((mat4(0.113615,0.028702,-0.196929,0.057492,0.203455,-0.614924,-0.015925,-0.452001,0.427790,-0.093369,-0.129197,-0.120074,-0.039599,0.031251,-0.205565,0.109609) * L4_0 + mat4(0.102686,-0.027227,0.004774,0.041676,0.056587,-0.152290,0.203785,-0.125003,0.009043,-0.288276,0.040211,0.007291,-0.172435,-0.081179,0.381924,-0.028243) * L4_1 + mat4(0.308095,0.077161,0.090380,0.203327,0.125075,0.045424,-0.259538,0.157187,0.092641,-0.221001,0.336097,-0.239357,-0.100744,0.004215,-0.004461,0.103509) * L4_2 + mat4(0.070691,-0.092805,0.692759,0.041198,0.106275,0.308233,-0.146390,0.160878,0.066304,-0.020465,-0.162177,0.135212,0.028216,0.013191,0.080909,-0.084004) * L4_3 + mat4(-0.153389,0.261530,0.390963,-0.109257,-0.107852,-0.185316,0.602191,0.107144,0.178663,0.192743,0.056151,0.329051,0.061491,0.013597,-0.327084,0.121035) * L4_4 + mat4(0.045573,-0.064008,-0.089413,0.081850,-0.095541,0.136395,-0.124195,-0.011263,0.062866,0.005136,-0.339028,0.185080,0.048024,-0.161781,0.274733,0.379789) * L4_5 + mat4(0.076534,-0.162304,0.046571,0.022433,0.021817,0.011314,-0.030486,0.166335,0.032334,-0.036485,-0.067755,0.046708,0.201739,-0.044315,-0.039944,-0.107302) * L4_6 + mat4(-0.049386,0.179608,0.289480,0.018677,0.065633,0.033196,0.078802,0.031548,-0.032198,-0.046191,0.078883,-0.247012,0.025621,-0.014601,0.094818,0.018670) * L4_7 + mat4(0.276025,0.016758,-1.024839,-0.268756,0.005102,0.412211,-0.092893,0.189778,-0.083946,-0.251159,-0.179581,-0.147344,0.467826,-0.212754,-0.396273,-0.318059) * L4_8 + mat4(-0.082192,0.035845,-0.513729,-0.050935,-0.271452,-0.046835,-0.526731,0.406195,0.052515,-0.024631,0.304134,0.086474,0.069664,0.112631,0.099874,-0.074220) * L4_9 + mat4(0.031660,0.119448,0.123557,0.022983,0.176131,0.126639,-0.199026,0.158207,-0.151001,0.051983,0.318591,-0.039341,0.065602,-0.033470,-0.137538,-0.054968) * L4_10 + mat4(0.433932,0.100847,-0.087179,-0.162415,0.105322,-0.056063,-0.065934,-0.031342,0.078280,-0.157382,0.441222,-0.052345,0.054461,0.023323,-0.124983,0.086100) * L4_11 + mat4(-0.414617,0.383867,-0.314463,0.320499,0.020402,0.031156,0.105373,0.036667,0.084390,0.141450,1.339032,0.202597,0.004890,-0.227225,0.093017,-0.048949) * L4_12 + mat4(0.067747,0.023084,0.040126,0.055959,0.154585,0.178046,-0.275740,-0.370752,0.071291,-0.157881,-0.067580,0.215338,0.018294,0.033986,-0.191120,0.164030) * L4_13 + mat4(-0.026692,0.002241,0.069743,-0.218351,-0.019048,0.026403,0.186797,-0.072245,-0.012628,0.096694,-0.078683,-0.047869,0.249949,-0.332291,0.218134,0.225489) * L4_14 + mat4(-0.064613,0.042801,-0.007473,0.006124,-0.229849,0.030132,0.014799,-0.073915,0.070856,-0.098571,0.049729,-0.057090,0.084014,0.116300,-0.144995,-0.016314) * L4_15 + vec4(0.336926,-0.016429,0.770550,0.259552)));\nvec4 L6_0 = sin((mat4(-0.012793,-0.046530,0.006630,-0.034733,0.021118,0.012513,0.002621,-0.106501,-0.064707,0.004403,-0.002516,-0.001603,0.173796,-0.010503,-0.015105,-0.025712) * L5_0 + mat4(-0.123482,0.010152,-0.003204,-0.097334,-0.048305,0.016568,0.010797,-0.363568,-0.102400,-0.081455,-0.007677,-0.213540,0.098205,0.003230,0.018571,0.004054) * L5_1 + mat4(0.267982,-0.236558,0.008199,0.092621,-0.051708,0.072461,-0.013008,-0.255551,-0.017913,-0.012298,-0.005814,-0.056398,-0.083174,0.013354,-0.004457,0.059106) * L5_2 + mat4(-0.040216,-0.035636,0.002686,0.022879,0.091350,-0.395351,-0.012178,-0.232935,-0.011570,-0.003878,-0.009742,-0.237488,-0.079494,0.337503,0.010046,-0.206221) * L5_3 + mat4(-0.124561,0.068777,-0.026186,0.047108,-0.046254,-0.002864,0.022869,-0.165573,-0.021421,-0.032244,0.006068,0.011688,-0.053715,0.019224,-0.005573,0.172905) * L5_4 + mat4(0.041424,-0.021019,0.012613,0.094774,-0.016717,-0.033324,-0.003230,-0.012107,-0.042399,-0.065822,-0.001236,-0.007135,0.076135,0.033409,-0.000958,0.205020) * L5_5 + mat4(-0.026549,-0.127771,0.008935,-0.239091,-0.058507,-0.002019,-0.000872,-0.081818,0.025386,-0.040057,0.000952,-0.050051,-0.073807,0.057777,0.007535,-0.162645) * L5_6 + mat4(-0.007138,-0.028918,0.000844,-0.022034,-0.160254,0.101862,0.000601,-0.008509,0.147829,0.146440,-0.000687,-0.070495,0.016097,0.056482,-0.007213,0.199519) * L5_7 + mat4(-0.088951,0.255187,-0.017033,0.402944,-0.019920,-0.013349,-0.012304,0.194599,-0.751195,0.394277,-0.009948,0.031873,-0.028833,0.019603,0.005518,0.104814) * L5_8 + mat4(-0.061161,0.075650,-0.018891,0.069522,0.134328,-0.000454,0.024457,0.139563,-0.047149,-0.027612,-0.002929,-0.024804,-0.026938,0.079768,-0.005737,-0.186671) * L5_9 + mat4(0.026978,0.137132,-0.002897,0.019152,0.270280,-0.479084,-0.001567,-0.731282,0.085477,-0.070179,0.002908,0.058022,-0.111715,-0.023511,0.002845,-0.342932) * L5_10 + mat4(0.025667,-0.072451,0.010458,-0.194629,-0.030274,-0.003890,-0.003364,-0.041719,0.078235,-0.037063,0.007857,0.020277,0.044658,0.010164,-0.007592,0.017276) * L5_11 + mat4(0.002403,-0.002271,-0.001546,0.057087,0.013895,0.012682,0.005724,0.005511,0.033541,-0.058393,0.012308,-0.077104,-0.019101,0.040509,0.008749,0.011432) * L5_12 + mat4(0.115237,0.003344,-0.001288,0.092968,0.099931,0.025813,-0.001007,0.098620,-0.015927,0.006525,-0.001913,-0.044554,0.035269,-0.010948,-0.023331,0.295466) * L5_13 + mat4(0.001271,0.011487,0.007078,-0.000201,0.168292,0.052396,0.003070,0.023206,0.052661,0.077964,0.002493,0.231535,-0.079094,-0.013411,-0.000062,-0.139395) * L5_14 + mat4(0.185394,-0.032368,-0.008426,-0.153227,-0.159727,0.061898,-0.014200,-0.144673,0.035595,0.014401,-0.000931,-0.099715,-0.105016,0.016125,0.025415,0.223486) * L5_15 + vec4(0.070161,1.147483,-0.002218,-0.858939)));\nvec4 L6_1 = sin((mat4(0.005592,-0.200121,0.102447,-0.005931,0.012192,0.073611,-0.041428,0.006916,0.005747,0.022423,0.020856,0.001752,-0.005424,0.114912,0.037309,0.004369) * L5_0 + mat4(-0.017745,0.027924,-0.100653,0.015867,0.008391,0.003026,0.057368,0.004546,0.014263,-0.357956,-0.455028,0.002911,-0.006682,0.105111,-0.111216,-0.016285) * L5_1 + mat4(0.004061,-0.264589,0.217402,0.015476,0.009348,-0.002255,-0.221479,-0.006178,-0.002313,-0.049493,0.118406,-0.010465,0.001585,-0.168467,-0.074383,-0.017009) * L5_2 + mat4(0.006354,0.285465,0.042132,0.005279,-0.000263,-0.036628,0.115910,-0.005536,0.002565,0.209672,-0.086017,-0.005640,0.006001,-0.065770,-0.066978,0.001727) * L5_3 + mat4(-0.007797,0.160245,-0.128994,-0.011860,0.004715,-0.065036,0.040350,-0.005140,-0.000660,-0.027248,-0.003224,0.014499,-0.000325,-0.065165,0.069499,0.015043) * L5_4 + mat4(0.009199,0.192652,0.019868,0.002210,-0.005320,-0.063041,0.026505,0.009299,0.009474,0.018554,0.147160,-0.015400,0.008808,0.211834,-0.000516,0.006120) * L5_5 + mat4(-0.017047,0.062540,-0.005945,0.016435,-0.007736,-0.003059,0.038593,0.002625,-0.005873,-0.109312,0.065494,-0.000580,-0.003884,0.295619,0.016502,-0.003687) * L5_6 + mat4(-0.018105,0.005070,0.014506,-0.007639,-0.005247,-0.044801,0.234909,0.005726,-0.000315,0.190373,0.066488,-0.011500,-0.002919,-0.033659,0.002652,-0.007726) * L5_7 + mat4(-0.016228,0.025896,0.256516,0.003271,0.002311,-0.254567,0.238794,-0.002489,0.017536,0.019199,-0.443605,-0.016202,-0.014538,0.042606,0.086753,0.008986) * L5_8 + mat4(-0.008336,0.090991,0.101802,0.013650,-0.000786,-0.062679,-0.039488,-0.001369,-0.008811,0.073392,-0.090032,0.002598,-0.009880,-0.044565,-0.049364,-0.013212) * L5_9 + mat4(0.019915,0.225628,0.009405,-0.004417,-0.006588,0.255799,0.135429,-0.014557,-0.001375,-0.173456,-0.159192,-0.008975,0.006045,0.039932,0.033695,0.021572) * L5_10 + mat4(0.008068,-0.355195,-0.341868,-0.009705,-0.005184,-0.008418,-0.002496,-0.002926,0.018245,0.023311,-0.033078,-0.011590,0.006089,-0.010499,0.066345,0.001771) * L5_11 + mat4(-0.000335,-0.073343,-0.047729,0.006778,0.000962,-0.109752,-0.115827,0.014605,0.009482,0.088328,0.021623,0.001059,0.014168,-0.064322,0.018991,0.012739) * L5_12 + mat4(-0.018950,0.004545,-0.190590,-0.008862,0.008297,-0.081145,-0.235883,0.008861,0.006998,-0.072843,-0.024881,0.000750,-0.001197,-0.243112,0.182009,0.008141) * L5_13 + mat4(-0.001808,0.097961,0.025027,0.013137,0.018701,0.257722,0.210575,-0.003679,-0.001229,0.025574,-0.037972,-0.003938,0.000120,0.170829,0.031850,-0.015098) * L5_14 + mat4(-0.023931,-0.319828,0.028810,-0.018307,-0.021371,0.225080,-0.029464,0.001322,-0.008690,-0.012984,0.057743,0.015469,0.012604,0.146250,0.065495,-0.001610) * L5_15 + vec4(0.001785,-0.071853,0.763478,0.005969)));\nvec4 L6_2 = sin((mat4(-0.189447,-0.057347,-0.000168,-0.053907,0.141757,0.021843,0.006355,0.023148,-0.052412,-0.005099,-0.004692,0.011981,-0.333285,-0.061261,-0.010458,0.077628) * L5_0 + mat4(-0.296238,-0.010144,-0.002522,0.001146,0.119022,0.007488,-0.005739,0.023018,0.526063,-0.116870,-0.003684,-0.159441,0.071729,0.055671,0.016363,0.105477) * L5_1 + mat4(0.112583,-0.240060,0.011429,0.256999,-0.135330,-0.009753,-0.008438,0.081242,-0.067642,-0.054626,-0.000688,0.059569,0.051244,0.013857,0.009886,-0.006511) * L5_2 + mat4(-0.330967,-0.015474,0.018103,0.001004,0.123389,-0.378338,-0.006091,0.218631,-0.227695,0.031188,-0.007142,0.004990,-0.320913,0.300558,0.008692,0.005560) * L5_3 + mat4(0.222227,0.043208,-0.014806,0.059861,0.017314,0.003372,0.000858,0.007753,-0.043868,-0.025793,0.000223,-0.028959,-0.041014,-0.006300,0.009796,0.024929) * L5_4 + mat4(0.249876,0.000899,0.005361,-0.011025,-0.027203,-0.036903,0.002497,-0.038200,0.545115,-0.037467,-0.000983,-0.142704,0.090968,0.030728,-0.001431,0.055848) * L5_5 + mat4(0.001166,-0.088091,-0.004613,0.027044,-0.068275,-0.009930,-0.000545,-0.044091,0.077283,-0.004538,0.005314,0.009060,-0.366269,0.060642,-0.002211,0.031583) * L5_6 + mat4(-0.041142,-0.013262,0.006961,-0.045076,-0.125906,0.149123,0.002193,0.150791,-0.150899,0.114860,0.001503,-0.097797,0.039755,0.019015,0.008303,-0.022389) * L5_7 + mat4(0.023683,0.279323,-0.020556,0.241018,0.163487,-0.073794,0.007478,-0.005714,0.285455,0.348675,0.000131,0.071454,-0.212709,0.006025,0.009729,0.016060) * L5_8 + mat4(-0.221521,0.069039,-0.024856,0.066813,-0.094952,0.017129,0.007152,-0.028317,0.055109,-0.016928,0.000705,0.004428,-0.005349,0.109626,-0.008456,-0.042710) * L5_9 + mat4(0.112253,0.102674,-0.002039,0.090836,0.455766,-0.556976,0.024363,0.076950,0.185688,-0.036026,0.004140,-0.051706,-0.138531,-0.061368,0.013169,-0.050304) * L5_10 + mat4(-0.043734,-0.018184,0.008612,-0.543968,0.016003,-0.008825,-0.003966,0.019410,0.017960,-0.034520,-0.004599,-0.009874,-0.031172,0.019107,-0.009255,0.018996) * L5_11 + mat4(-0.110520,0.009048,0.004454,0.003348,0.051534,0.006034,-0.002469,-0.023700,0.046801,-0.057445,0.001592,0.000757,-0.095448,-0.012227,0.016747,0.010570) * L5_12 + mat4(0.133757,0.055811,-0.003668,0.001772,-0.114073,0.042707,-0.000078,-0.058058,-0.117110,0.008255,-0.000398,0.004181,-0.236453,0.000759,-0.019129,-0.138569) * L5_13 + mat4(0.093682,0.013842,0.009277,0.012535,-0.022445,0.025166,0.013919,0.152252,0.098528,0.050439,-0.001798,0.020865,0.169386,-0.015480,0.001258,0.007892) * L5_14 + mat4(-0.126031,-0.013284,0.005670,-0.021858,0.239484,0.098533,-0.001881,-0.131771,0.196199,0.030203,0.008277,0.020154,0.053817,0.035912,0.011231,0.046546) * L5_15 + vec4(-0.705860,-1.994061,-0.005176,0.627683)));\nvec4 L6_3 = sin((mat4(-0.011344,0.005378,-0.013609,-0.117985,0.015326,-0.022620,-0.013801,-0.003301,-0.000329,0.029823,-0.031565,0.014637,0.009308,-0.029554,-0.023548,0.022194) * L5_0 + mat4(-0.022594,0.062642,-0.069596,0.112181,-0.013304,-0.046037,0.067284,-0.212608,0.000077,0.052726,0.008619,0.271055,-0.003108,-0.224659,-0.011666,0.219417) * L5_1 + mat4(0.005045,0.112617,-0.041562,-0.336050,0.003440,0.009227,-0.047709,0.265735,-0.011713,0.082145,0.014119,0.237673,0.006940,-0.002391,-0.021501,-0.018922) * L5_2 + mat4(-0.007768,-0.005741,-0.022060,0.073859,0.002744,-0.055291,1.572541,0.546404,0.000556,0.016021,0.004448,0.038455,0.008554,-0.341592,-0.049559,-0.161680) * L5_3 + mat4(0.018525,0.004997,0.051288,-0.099550,-0.009213,0.011781,-0.036647,0.111238,0.014022,0.005842,-0.044520,0.014852,0.006447,0.027669,0.034050,-0.000234) * L5_4 + mat4(0.005906,0.019995,0.010557,0.026799,0.004156,-0.062125,0.029131,0.010527,-0.002046,0.048467,-0.122200,-0.377845,-0.003229,-0.044223,-0.029232,0.002392) * L5_5 + mat4(-0.000244,-0.178796,0.030146,0.080066,-0.000018,-0.078043,-0.009851,-0.083961,0.004796,-0.036785,0.006792,-0.085187,0.003294,0.012213,-0.110649,-0.067531) * L5_6 + mat4(0.007424,0.017886,0.009956,0.028494,0.008796,0.078658,-0.003852,-0.147471,-0.005970,-0.099289,-0.011606,-0.192941,0.003375,0.081402,-0.042172,-0.011556) * L5_7 + mat4(-0.009793,-0.025682,-0.086442,-0.477686,-0.008271,-0.077513,0.015173,-0.163642,0.012763,0.351227,-0.090490,0.258608,0.010130,-0.007032,0.001174,-0.078564) * L5_8 + mat4(0.007557,0.349847,0.046918,-0.031430,-0.003166,0.053732,0.022819,-0.017178,0.012650,-0.063517,-0.013866,0.207062,0.004355,0.037221,0.019502,0.137999) * L5_9 + mat4(0.004052,0.177875,-0.019805,-0.141327,0.004578,0.049756,-0.026195,-0.015785,0.001387,-0.020194,0.022295,0.026617,-0.021368,0.029769,-0.022275,0.246634) * L5_10 + mat4(0.019263,0.001383,-0.050756,0.245781,0.002721,0.000701,-0.001038,-0.025368,0.000593,-0.072093,-0.012130,0.126118,-0.003292,-0.018185,-0.013636,-0.018585) * L5_11 + mat4(-0.000762,0.031622,-0.006060,-0.101525,-0.002895,-0.003100,-0.023663,-0.008028,0.000469,-0.056991,-0.012161,-0.084608,-0.012661,0.036806,-0.016605,-0.206794) * L5_12 + mat4(0.005227,-0.026702,0.043050,-0.013768,-0.003125,0.046295,0.002359,-0.125213,0.009698,-0.005625,0.001460,-0.001836,0.014177,0.015482,-0.031604,-0.208099) * L5_13 + mat4(0.006374,-0.017313,-0.003736,-0.015640,0.007327,-0.253737,0.030719,0.040038,-0.002005,0.079828,0.005962,-0.074848,0.003270,0.021352,0.015228,0.035289) * L5_14 + mat4(-0.005104,0.046377,-0.021648,-0.216236,-0.014199,-0.083715,0.001256,0.213552,-0.007875,0.015112,0.018840,-0.018853,0.009154,0.141078,0.073001,0.082951) * L5_15 + vec4(-0.002091,-0.292038,1.475418,0.329258)));\nvec4 L6_4 = sin((mat4(-0.250008,0.066527,0.008642,0.120969,0.100697,0.057977,0.000809,-0.007072,-0.018409,-0.112775,-0.003734,-0.028505,0.015766,0.281061,0.003846,-0.195015) * L5_0 + mat4(-0.241795,-0.003105,-0.009828,-0.352100,0.059429,-0.186582,-0.004184,-0.085631,-0.107817,0.213031,0.000911,-0.959492,0.001637,-0.260633,-0.001881,-0.025531) * L5_1 + mat4(-0.164996,-0.250816,-0.015449,0.493971,0.064224,-0.036382,-0.009982,-0.168438,-0.130870,0.205785,-0.002244,-0.270155,0.026905,0.094438,-0.013500,-0.185930) * L5_2 + mat4(-0.076697,0.135339,-0.002726,0.065662,-0.301107,-0.561309,-0.014348,0.279550,0.096953,0.050257,-0.015617,0.132148,0.214783,0.413867,-0.000874,-0.643735) * L5_3 + mat4(-0.038391,-0.089211,0.028020,-0.124891,-0.162136,0.174614,-0.015535,-0.157352,-0.264431,0.055680,0.005972,0.070241,0.011068,0.029703,-0.003035,0.115917) * L5_4 + mat4(0.051218,0.064630,0.004114,-0.043478,0.133511,0.062389,-0.002737,-0.014632,-0.296897,0.144628,-0.024425,0.211374,0.201797,0.034956,-0.002165,0.156939) * L5_5 + mat4(0.144691,-0.032267,-0.010764,0.066984,0.022160,0.051707,-0.003287,0.136600,-0.245091,-0.000421,-0.014003,-0.018170,-0.009550,0.325580,-0.006263,0.056951) * L5_6 + mat4(0.087047,-0.167801,0.009681,0.173158,-0.022412,-0.156269,-0.011376,-0.726547,-0.341054,-0.158483,-0.014266,0.098292,0.048823,-0.187925,0.004055,0.265469) * L5_7 + mat4(-0.226274,0.085490,0.010585,-0.038257,-0.109220,-0.073658,-0.007464,0.163912,1.072415,-1.153169,-0.007519,-1.041886,0.086117,0.162492,-0.004164,-0.075299) * L5_8 + mat4(-0.196924,0.065117,0.012289,0.267684,-0.129565,-0.068516,-0.004883,0.069859,-0.011106,0.145543,0.012696,0.004606,0.209614,-0.021080,-0.000552,-0.108231) * L5_9 + mat4(0.282307,-0.353451,-0.004808,1.219151,-1.056622,0.469797,-0.001812,-1.112531,-0.122194,0.006883,0.008468,0.063244,-0.281733,-0.162602,-0.008629,-0.004739) * L5_10 + mat4(0.016420,0.230184,-0.015725,0.186802,-0.027440,0.014955,-0.002267,-0.026417,0.117436,0.160445,-0.004364,-0.069183,-0.092929,0.006947,0.009141,-0.016791) * L5_11 + mat4(0.126922,0.016616,0.001668,-0.097626,-0.019119,-0.135407,0.008632,0.054231,0.388694,-0.281234,0.002974,-0.013518,-0.048765,-0.025538,-0.003003,0.126076) * L5_12 + mat4(-0.235633,-0.343573,0.013345,-0.238015,-0.216302,0.019638,-0.004704,0.285089,-0.068060,0.028135,-0.009056,0.053485,-0.315387,0.299733,0.016028,0.134965) * L5_13 + mat4(0.162400,-0.140797,-0.002457,-0.076822,-0.152831,-0.135376,-0.005653,-0.252089,-0.115271,-0.044994,-0.014201,-0.046740,0.005298,-0.076063,0.006517,-0.009198) * L5_14 + mat4(0.011211,0.077529,-0.003904,-0.247501,0.179789,0.709145,0.001411,-0.255344,0.212432,-0.070820,-0.005903,-0.038114,-0.095490,0.282898,-0.014393,0.341452) * L5_15 + vec4(0.142820,0.460514,-0.011164,0.293693)));\nvec4 L6_5 = sin((mat4(0.007633,0.020005,0.164333,0.049715,-0.040321,-0.065302,-0.064441,-0.018417,0.196417,-0.013139,0.068520,-0.031660,0.231782,0.093947,0.323688,-0.042261) * L5_0 + mat4(0.008498,-0.055329,0.051484,0.056686,0.276888,-0.068733,-0.130516,0.099947,-0.171921,-0.002264,0.142890,0.078030,-0.107210,-0.023885,-0.422498,-0.277435) * L5_1 + mat4(-0.403526,0.148133,0.045734,0.289448,-0.265211,0.062606,-0.029764,0.055476,-0.059343,-0.034720,0.066951,0.331157,0.047398,-0.108359,0.051130,-0.003313) * L5_2 + mat4(-0.082622,0.047757,-0.027528,-0.122123,0.051943,0.086699,-0.638342,0.302727,-0.080624,-0.086303,-0.097245,0.119849,-0.000745,-0.067480,-0.200830,-0.351944) * L5_3 + mat4(-0.141082,0.130895,-0.258530,-0.105666,0.044481,0.090123,0.144869,-0.042112,0.035574,-0.062322,0.042364,0.057082,0.052953,0.007025,0.055213,-0.038180) * L5_4 + mat4(0.007918,0.026387,-0.044936,-0.112318,0.008860,-0.006771,-0.052874,-0.027056,-0.172472,0.078235,0.237598,-0.328982,0.037187,0.097552,-0.175689,-0.076303) * L5_5 + mat4(0.093361,-0.135546,-0.135951,0.002954,-0.024940,-0.060288,-0.002604,-0.038857,-0.006787,0.029205,-0.066662,0.003254,-0.023656,-0.093279,0.244273,-0.086864) * L5_6 + mat4(-0.036408,0.035528,0.140451,-0.089737,0.024406,0.051855,-1.112880,-0.110565,0.054008,-0.105674,0.186736,0.111596,0.078026,0.007520,-0.196621,0.029850) * L5_7 + mat4(-0.199589,0.537382,-0.169768,0.144035,0.197044,0.179758,-0.321445,-0.316619,-0.340608,-0.037245,-0.623268,0.018635,-0.145260,-0.045833,0.131096,-0.093422) * L5_8 + mat4(-0.045650,-0.070698,0.335322,0.350428,-0.060610,0.004543,0.009143,0.022698,-0.076343,0.006651,0.095177,-0.060936,0.193377,-0.037788,0.067276,0.033584) * L5_9 + mat4(0.192221,-0.001392,1.178203,0.058173,0.263637,0.062084,0.568019,0.854367,0.143856,0.020667,-0.002789,-0.075779,0.163561,0.107165,-0.082319,0.064756) * L5_10 + mat4(0.185613,-0.312061,0.397465,-0.092591,-0.014906,0.008273,0.042525,-0.010248,-0.043041,0.049644,0.153601,-0.085654,-0.017686,0.016221,0.005474,-0.040648) * L5_11 + mat4(0.004377,-0.012993,0.177371,0.014742,-0.053222,-0.025476,-0.028301,0.020140,-0.075596,0.030608,-0.071287,-0.036424,-0.173291,-0.075972,0.015275,-0.032668) * L5_12 + mat4(-0.001519,-0.165831,0.089144,0.302085,-0.144173,0.013840,-0.180836,0.038202,-0.067074,-0.049532,0.056596,-0.008687,0.195372,-0.055334,-0.113627,0.033909) * L5_13 + mat4(0.100172,0.054478,-0.098478,-0.060480,0.080550,0.213009,0.287600,-0.429372,-0.001554,0.055054,0.335994,0.004832,-0.074674,0.032162,-0.008638,0.007067) * L5_14 + mat4(0.185181,-0.036763,0.033181,-0.004434,0.012289,-0.057110,0.303959,-0.246915,-0.025466,0.040725,0.002542,-0.070576,0.102273,0.020213,0.388131,0.172169) * L5_15 + vec4(0.803770,-0.146557,0.222925,0.970091)));\nvec4 L6_6 = sin((mat4(-0.064656,-0.019110,0.073435,-0.061618,-0.003394,0.059371,-0.015905,0.062617,0.052252,-0.046297,0.002803,0.010131,-0.259475,0.055063,0.039411,0.007961) * L5_0 + mat4(0.049591,-0.112065,-0.081059,0.013040,-0.037426,0.026840,0.062768,-0.011810,-0.114283,-0.048585,-0.055269,-0.134132,0.302156,0.021251,-0.050585,0.191744) * L5_1 + mat4(-0.184394,0.119754,0.192204,0.001263,-0.056275,0.062439,0.014328,-0.045709,-0.161716,0.107713,0.198539,0.123661,0.151703,-0.024446,0.019474,0.081453) * L5_2 + mat4(-0.160968,0.084903,-0.061097,-0.065712,0.451289,-0.027976,0.098759,0.214655,-0.121383,0.110119,0.017343,-0.029058,0.317183,0.051434,-0.445073,-0.027706) * L5_3 + mat4(0.088743,-0.085425,-0.026355,-0.147671,0.012810,0.058056,-0.043735,-0.068385,-0.009853,-0.030656,0.008606,-0.002160,-0.088588,-0.010144,-0.024361,0.044957) * L5_4 + mat4(0.084704,0.023079,0.014853,0.033344,0.108752,-0.013436,0.141797,0.049993,-0.063538,-0.132402,-0.603804,-0.167076,0.048818,-0.004228,-0.198837,-0.139215) * L5_5 + mat4(0.210644,-0.126013,0.123773,0.193980,0.129639,-0.012057,0.027760,0.015005,-0.023422,-0.021265,0.058608,-0.031773,0.136082,-0.027691,-0.092753,0.063033) * L5_6 + mat4(0.120496,-0.148227,-0.020199,-0.074375,0.369850,-0.066252,-0.314873,0.008063,-0.032887,0.022050,0.111250,0.068806,-0.082429,0.032112,-0.100044,-0.012156) * L5_7 + mat4(0.293624,-0.153996,-0.047979,-0.366982,0.106965,-0.024181,-0.038323,-0.153484,0.539630,-0.058311,-0.654979,-0.042587,-0.043394,0.082171,-0.007184,0.027560) * L5_8 + mat4(-0.441464,0.012837,0.117570,0.129611,-0.228759,-0.046722,-0.055078,-0.043631,0.117291,0.018090,-0.055389,-0.008619,0.069893,-0.071354,-0.137165,0.010839) * L5_9 + mat4(-0.225564,0.106621,-0.318407,0.165174,-0.282229,-0.156480,0.688039,0.093811,-0.109527,-0.009028,0.022584,-0.020605,-0.024645,0.108679,0.040559,0.039695) * L5_10 + mat4(-0.514867,0.327134,-0.119779,-0.083812,0.058593,-0.025880,0.006835,-0.008884,0.201123,-0.090019,0.014976,-0.004986,0.073597,0.014489,0.008189,0.027789) * L5_11 + mat4(-0.021678,0.038486,-0.046723,0.060950,-0.096332,0.039315,0.011822,-0.056465,0.104399,0.012478,-0.030618,0.026710,0.010390,0.016498,-0.077173,0.007840) * L5_12 + mat4(-0.139056,0.196988,-0.079622,0.092350,-0.400977,-0.007493,-0.009657,-0.069479,-0.035433,-0.046943,-0.019346,0.026259,-0.159977,-0.120337,0.022348,-0.040559) * L5_13 + mat4(-0.031160,0.000217,-0.057408,-0.060827,-0.023321,0.013405,-0.088449,-0.042157,-0.119396,-0.038085,-0.093472,-0.109158,0.090330,0.053891,-0.013159,0.006873) * L5_14 + mat4(-0.093171,0.030119,-0.015658,0.090727,0.116529,0.000172,0.038812,-0.081062,-0.055667,-0.017562,-0.010735,0.015168,0.057619,0.049497,-0.146364,0.053313) * L5_15 + vec4(-0.584293,0.815132,-1.891414,0.924093)));\nvec4 L6_7 = sin((mat4(0.010310,-0.302539,-0.162963,-0.003739,0.010113,0.064548,-0.016706,-0.007584,0.005431,-0.035681,0.017582,-0.005300,0.011837,-0.264210,0.157409,-0.005857) * L5_0 + mat4(-0.013590,0.345465,0.033628,-0.011940,0.007334,-0.551054,-0.010586,0.016885,-0.004922,-0.410403,0.104502,-0.001441,-0.012752,0.451896,0.110454,0.015331) * L5_1 + mat4(-0.008523,0.171829,-0.000517,-0.003923,0.018304,-0.221371,-0.164044,0.002102,0.004909,-0.130422,-0.010862,0.000895,-0.006706,0.234100,-0.071834,-0.002150) * L5_2 + mat4(-0.011069,0.164837,-0.066542,-0.015399,-0.004313,0.259109,-0.209025,-0.011513,-0.010405,0.142949,-0.240827,-0.006212,0.006380,0.204120,0.107682,0.004732) * L5_3 + mat4(0.033673,0.059021,0.098825,-0.001044,-0.017251,0.297656,0.229404,0.007135,0.007537,-0.083204,-0.113137,0.009726,0.007492,0.071847,0.010458,-0.009117) * L5_4 + mat4(0.001353,0.115951,0.051777,0.002996,0.003567,-0.247526,0.028664,0.004617,0.009646,0.043417,0.071357,0.012765,-0.002147,0.012774,0.063412,-0.011644) * L5_5 + mat4(-0.004334,-0.690807,-0.177140,0.007777,0.004195,-0.188998,-0.036622,0.001285,0.000603,-0.208209,0.018861,0.011600,-0.007190,-0.052388,-0.060931,0.004599) * L5_6 + mat4(-0.007307,0.162316,0.101054,-0.004862,0.001956,0.156861,-0.184666,0.000073,0.004992,-0.159223,-0.139411,0.007279,-0.000362,0.281031,0.069536,-0.001635) * L5_7 + mat4(0.000986,0.257930,0.237730,-0.014260,-0.012513,-0.047016,0.170917,-0.009873,-0.001216,0.004055,-0.035206,-0.004092,-0.010853,0.274168,-0.146089,0.005758) * L5_8 + mat4(0.007222,-0.105902,0.024472,-0.009917,-0.011332,0.110989,0.059721,0.012997,-0.006349,0.056259,-0.063017,-0.010696,0.002435,0.303834,0.026528,-0.002763) * L5_9 + mat4(0.029152,0.584364,0.162626,0.018909,-0.013622,0.290230,0.159650,-0.006605,-0.013898,-0.251907,0.189471,-0.013712,-0.000279,-0.005389,0.153841,0.009169) * L5_10 + mat4(0.009635,-0.755351,-0.088957,0.008692,0.001923,-0.068316,-0.004391,-0.004917,0.012453,0.196553,0.039832,0.010587,0.008826,-0.002191,0.019844,-0.004377) * L5_11 + mat4(0.008566,-0.051411,0.136339,0.000528,-0.007491,-0.168396,0.021544,0.004238,-0.004853,-0.168004,0.068962,0.003525,0.005873,0.221198,-0.090616,0.001382) * L5_12 + mat4(0.000694,-0.241949,-0.024486,0.008815,0.008563,-0.115023,-0.167073,-0.005194,0.010866,0.027577,0.044289,-0.000041,-0.009565,-0.295320,0.223447,-0.024479) * L5_13 + mat4(0.003715,-0.050120,0.037635,0.006148,0.003664,0.048954,-0.057919,0.003709,0.004416,0.260963,0.056911,0.015523,0.003353,0.043337,0.023395,0.004032) * L5_14 + mat4(-0.023189,0.354848,-0.173936,-0.001736,-0.004717,0.094733,0.013819,-0.017400,-0.006509,-0.118623,0.020897,-0.004619,-0.001721,0.070350,-0.082807,0.022192) * L5_15 + vec4(-0.003448,-0.237199,-0.399582,0.011651)));\nvec4 L6_8 = sin((mat4(-0.003526,0.050480,-0.007507,-0.027833,-0.013994,-0.010376,0.001464,-0.016236,0.007088,0.008665,-0.040116,-0.028676,0.004656,0.090900,0.042754,-0.027785) * L5_0 + mat4(0.018054,-0.040388,0.007080,-0.027689,0.007129,0.147286,-0.142299,-0.014723,0.020955,-0.130275,0.169370,0.043626,0.008462,0.134126,0.168288,-0.052572) * L5_1 + mat4(-0.009333,-0.138748,0.320480,-0.073479,0.010892,-0.260983,0.162724,0.088287,-0.006961,0.172586,0.160833,0.090546,-0.015574,0.064636,-0.018939,0.011370) * L5_2 + mat4(-0.001723,-0.168529,0.046976,-0.034784,-0.006263,-0.414277,-0.165068,-0.075533,0.002562,-0.068189,0.062959,-0.006116,-0.021744,0.012338,0.020441,0.024212) * L5_3 + mat4(-0.001796,-0.021947,-0.002896,0.022909,-0.005716,-0.027921,-0.020691,0.023883,0.012366,-0.027513,-0.011883,-0.025787,-0.007207,0.073024,-0.082290,0.008647) * L5_4 + mat4(-0.015629,-0.046947,0.032910,-0.004069,0.014361,-0.044177,0.059397,0.016141,0.000091,0.079633,-0.070885,-0.208487,-0.003878,-0.020983,0.004868,-0.043552) * L5_5 + mat4(0.000985,0.031635,0.050045,-0.053215,-0.003839,0.076254,0.050653,-0.026205,-0.004989,0.072138,-0.003678,0.009258,-0.019465,0.035337,0.028187,-0.005127) * L5_6 + mat4(-0.005125,-0.085759,-0.048979,-0.013443,0.014206,-0.095859,0.040654,1.538702,-0.008600,-0.047743,0.032357,0.048539,-0.013719,0.043778,-0.057955,0.070423) * L5_7 + mat4(0.008163,0.253954,-0.042142,0.161481,0.015384,0.180009,-0.098770,-0.074082,-0.004723,0.298079,-0.007779,-0.006941,-0.006252,-0.063841,0.046912,-0.007374) * L5_8 + mat4(0.013967,-0.077862,0.098583,0.079815,0.004682,-0.009974,-0.077194,-0.043806,0.011833,0.024655,0.046303,-0.021582,-0.005105,0.138889,-0.068243,-0.038653) * L5_9 + mat4(-0.016335,-0.013365,-0.498434,0.152053,-0.006474,-0.091751,0.047993,-0.103959,0.017181,0.082645,-0.155419,-0.050658,-0.008841,-0.008481,0.045920,-0.007475) * L5_10 + mat4(-0.019396,0.068892,-0.074198,0.007229,0.005131,0.028465,0.011905,-0.009723,-0.014058,-0.067510,0.035492,-0.032869,0.012922,0.016734,-0.003783,-0.004926) * L5_11 + mat4(0.003224,0.079084,0.046635,-0.022533,0.006443,0.004846,-0.042747,-0.009716,0.002884,0.051682,0.068142,0.024629,-0.022418,0.005163,0.080365,-0.023057) * L5_12 + mat4(0.020269,0.213264,-0.013756,-0.046204,-0.008945,0.096595,0.088449,0.062401,-0.007220,-0.045843,-0.009071,-0.007681,0.019809,0.199343,-0.209773,0.021148) * L5_13 + mat4(-0.010711,0.046375,-0.033170,0.012235,-0.002154,-0.143101,0.086674,-0.007641,-0.009450,-0.026155,-0.006492,0.016572,-0.000423,-0.074118,0.026824,0.073576) * L5_14 + mat4(-0.010217,-0.120839,0.136677,-0.046102,-0.005740,-0.037280,0.015651,0.106292,-0.001992,0.047648,-0.022627,0.013731,-0.018218,0.061804,0.122554,0.006312) * L5_15 + vec4(-0.003034,0.203679,0.527962,-1.574040)));\nvec4 L6_9 = sin((mat4(0.069197,0.055774,0.010731,-0.010848,-0.013178,-0.037803,-0.002144,0.015829,-0.001320,0.008393,-0.004201,0.008036,-0.076545,-0.021721,-0.009304,0.000743) * L5_0 + mat4(0.000427,-0.070826,0.010883,-0.013190,-0.011996,-0.125028,-0.012636,-0.007067,0.157667,0.044461,-0.019703,0.004199,-0.097343,0.000462,-0.004243,-0.008965) * L5_1 + mat4(-0.275051,0.312768,-0.008791,-0.000833,-0.050403,0.020448,-0.011832,0.012086,-0.025894,0.003117,0.014694,-0.014068,0.010180,0.033678,-0.012047,0.009242) * L5_2 + mat4(0.024222,-0.032785,0.010912,0.004189,-0.224827,-0.685058,-0.020859,0.017853,0.013285,-0.056268,0.001536,0.010674,0.004042,0.011377,-0.010401,0.018052) * L5_3 + mat4(-0.059611,-0.103801,-0.004631,-0.022690,0.003410,0.030059,0.007054,-0.004080,0.021204,-0.002378,-0.006951,-0.006702,-0.015525,0.030507,0.001235,0.022367) * L5_4 + mat4(0.002548,-0.015703,0.001255,-0.005779,0.030600,0.029514,0.001659,0.006801,0.163014,0.059961,-0.019707,0.015547,-0.072185,-0.019999,-0.005364,0.008076) * L5_5 + mat4(-0.029837,0.030957,-0.004999,0.004665,0.042324,-0.005769,0.009276,-0.014556,-0.024825,0.050239,-0.012709,0.010865,-0.060296,-0.129798,0.000756,0.007160) * L5_6 + mat4(0.042619,0.057303,-0.006069,0.003722,-0.173494,-0.039613,-0.013276,0.004692,0.090141,-0.086690,-0.000662,-0.008295,0.030925,-0.005203,0.006027,-0.001203) * L5_7 + mat4(-0.238467,0.154335,0.009182,-0.005345,0.011941,0.083138,0.003520,0.010142,-0.077921,0.142533,-0.011331,0.004165,-0.023785,0.057472,0.007800,-0.008860) * L5_8 + mat4(-0.069975,0.026540,-0.017761,0.004903,0.027117,-0.034937,-0.019866,0.000913,-0.005998,-0.020011,0.015738,-0.007474,0.042387,-0.004198,-0.010525,0.003974) * L5_9 + mat4(-0.083848,0.008817,-0.017123,0.004874,-0.070250,-0.274853,-0.005982,0.022330,0.051890,0.001886,0.007473,-0.000250,0.050775,-0.051713,0.022920,-0.004646) * L5_10 + mat4(0.540377,-0.018300,-0.011875,-0.007580,-0.019717,0.034468,-0.004310,0.002851,-0.006913,0.033645,0.003397,-0.016103,-0.032682,0.030780,0.006983,-0.005857) * L5_11 + mat4(-0.001668,0.010911,0.025238,-0.008563,0.042052,-0.027626,-0.006948,-0.001025,-0.013233,0.028909,-0.005637,0.007308,-0.005338,-0.005178,0.014588,0.008680) * L5_12 + mat4(-0.006359,-0.109325,0.011402,-0.005841,0.063058,-0.012878,-0.012374,0.012769,0.017102,-0.024193,0.004449,0.010818,0.133974,-0.055954,0.007615,-0.005793) * L5_13 + mat4(-0.010021,-0.021257,-0.006483,0.003710,-0.115029,0.020751,-0.010761,0.005838,-0.010493,0.002528,-0.001436,0.002176,-0.031975,-0.007164,0.004910,-0.005472) * L5_14 + mat4(-0.013840,0.064093,0.015292,0.003149,0.110760,-0.066899,0.010769,0.003279,-0.008447,-0.023067,-0.004817,0.001305,-0.035900,0.005897,-0.013790,0.008979) * L5_15 + vec4(-0.641499,0.648561,-0.011413,0.011150)));\nvec4 L6_10 = sin((mat4(0.028037,-0.000203,-0.000623,0.008111,-0.003410,0.010257,0.005508,-0.011158,-0.040503,0.012388,-0.010122,-0.004050,-0.020398,0.001911,0.061246,-0.000038) * L5_0 + mat4(-0.016762,-0.027375,0.016286,0.021774,-0.047754,0.008013,0.033264,-0.009640,0.017503,-0.013474,-0.049223,0.001814,-0.055775,0.011801,0.129243,0.008482) * L5_1 + mat4(-0.015808,-0.000272,0.539128,0.012968,-0.000595,0.009670,-0.013439,0.019712,0.020335,-0.000656,0.079847,-0.001071,0.044353,0.000849,-0.025555,-0.001578) * L5_2 + mat4(-0.012692,-0.010995,0.023917,0.004807,0.041394,-0.006489,0.703290,0.003235,-0.001828,-0.023487,0.041914,0.000636,-0.001488,0.026987,-0.276742,-0.016137) * L5_3 + mat4(-0.021284,0.009946,-0.045081,-0.008056,0.016192,-0.009043,0.001488,-0.003138,0.018224,0.003102,0.034765,0.001060,-0.021047,-0.002490,-0.005574,-0.016384) * L5_4 + mat4(0.011524,0.010835,0.011596,-0.022237,0.048113,0.003662,0.001949,0.009734,0.098062,0.009705,-0.018675,0.004796,-0.002179,0.001667,0.036075,-0.026196) * L5_5 + mat4(0.021124,-0.002998,0.105611,0.000663,0.029996,0.002634,-0.033077,0.020246,0.001849,0.004102,0.033769,0.003952,0.089416,0.000029,-0.038613,0.008658) * L5_6 + mat4(-0.004775,-0.004542,-0.009916,-0.004499,0.021884,0.002668,0.063624,0.001356,0.019299,0.004954,-0.193541,0.008709,-0.038289,-0.013903,-0.113663,-0.001602) * L5_7 + mat4(0.158650,-0.012198,0.018982,0.007856,-0.004126,-0.016542,0.039850,0.011330,-0.124947,0.012275,-0.325684,-0.011018,0.004438,-0.003924,0.035419,0.003159) * L5_8 + mat4(-0.022716,0.008489,-0.036331,-0.012076,-0.024131,0.002307,-0.063694,0.002908,0.053915,-0.009133,0.065337,0.003811,0.024064,-0.006390,-0.135911,0.002460) * L5_9 + mat4(-0.124766,0.025356,-0.064775,-0.007081,0.129804,0.017340,0.629839,-0.014077,-0.026949,-0.002389,0.029528,-0.002793,-0.049861,-0.005068,-0.048834,0.007271) * L5_10 + mat4(0.037006,0.008888,-0.545382,0.003239,0.019332,-0.003395,0.022839,0.005573,0.059538,0.003231,0.030218,0.001062,0.014095,0.004540,-0.017841,-0.005336) * L5_11 + mat4(-0.012368,0.005558,0.045264,0.016077,-0.040477,-0.011926,-0.013673,-0.008793,-0.050758,-0.009284,0.069208,-0.003002,0.017184,0.000230,-0.029897,-0.022145) * L5_12 + mat4(-0.108753,0.000413,0.015893,0.015135,-0.048426,0.008075,-0.065727,-0.019384,0.021702,-0.002643,-0.034006,-0.005513,0.049656,-0.007505,-0.127956,0.006722) * L5_13 + mat4(-0.069492,-0.002654,0.048104,0.008949,-0.090872,0.002930,0.073010,0.000609,-0.045935,0.013355,-0.033454,-0.001521,0.004411,-0.007261,-0.003571,-0.000995) * L5_14 + mat4(-0.089193,-0.005088,0.026822,-0.002739,0.155753,-0.004487,-0.167424,0.002105,-0.017416,-0.005058,0.018240,-0.000059,0.191616,0.015478,-0.015352,-0.003984) * L5_15 + vec4(0.044593,3.148004,-0.532736,-0.000851)));\nvec4 L6_11 = sin((mat4(-0.003946,0.063862,-0.002957,0.012190,-0.001247,0.031634,-0.022155,0.014736,-0.002581,0.173473,-0.014747,-0.012641,-0.002511,0.294533,-0.007167,-0.000286) * L5_0 + mat4(-0.000529,0.004539,0.004744,0.001040,0.000677,0.116685,-0.001955,-0.007197,-0.017307,0.533498,-0.010429,-0.018998,-0.005502,-0.005793,-0.015438,0.001948) * L5_1 + mat4(-0.006793,-0.633361,0.004927,-0.009680,-0.005491,0.183660,-0.001016,-0.020221,0.006963,-0.016389,0.007056,0.001382,-0.017203,0.020674,0.000403,-0.011734) * L5_2 + mat4(0.000049,0.168034,0.000374,-0.004014,-0.026522,-0.022670,0.001313,-0.003931,-0.014133,0.103310,0.004511,0.007255,-0.003717,0.453939,-0.021550,0.011403) * L5_3 + mat4(-0.001574,-0.204509,-0.007541,0.001168,0.005456,-0.095675,-0.002325,-0.004946,0.000613,0.001644,-0.000887,-0.007221,-0.003458,-0.004625,-0.012866,0.019887) * L5_4 + mat4(0.005425,-0.096472,0.000536,-0.012768,-0.004436,-0.026876,-0.012266,0.006367,-0.029431,0.124009,-0.002892,-0.018851,0.013614,-0.133938,-0.006790,-0.012226) * L5_5 + mat4(-0.004396,0.195522,0.004927,-0.005225,0.011254,0.089090,0.012341,0.000467,-0.003213,-0.021591,-0.000903,0.004833,-0.015066,0.113225,0.010917,-0.004395) * L5_6 + mat4(-0.000844,-0.047959,-0.002551,0.004947,0.006132,0.104408,-0.005405,-0.009661,0.007585,0.078200,-0.016383,0.005601,-0.017502,-0.171755,0.004639,-0.001503) * L5_7 + mat4(-0.012473,-0.376886,-0.006272,-0.000125,0.002089,0.050892,0.002213,-0.003614,0.008467,0.192123,-0.001649,0.019457,0.010464,-0.082439,0.005556,0.011871) * L5_8 + mat4(0.000040,-0.459445,-0.009949,-0.000863,-0.006417,0.000822,-0.007556,-0.009602,0.000142,0.075495,-0.000324,-0.009018,-0.006914,-0.076010,0.014959,-0.005442) * L5_9 + mat4(-0.022385,1.189124,-0.022496,0.015704,0.006826,-0.345776,-0.007013,0.017032,0.015543,0.070001,-0.010219,-0.010930,0.007031,-0.164347,0.009631,0.009545) * L5_10 + mat4(-0.026209,0.624304,-0.008794,0.012033,-0.000495,0.051192,0.006375,-0.000618,0.002429,0.261455,0.015346,-0.004744,-0.000043,-0.060936,-0.005799,-0.016332) * L5_11 + mat4(-0.000826,0.013478,0.001885,0.017086,-0.013201,0.091720,0.008087,-0.011205,-0.010773,0.058258,0.002778,-0.012842,0.003420,-0.156738,-0.005537,0.013196) * L5_12 + mat4(0.001046,-0.083761,0.012870,-0.000533,0.001372,-0.082281,-0.006149,0.022554,0.001633,0.032261,-0.001543,0.017930,-0.003311,-0.123508,0.002742,-0.015540) * L5_13 + mat4(0.001251,0.031088,0.007752,0.011460,-0.021569,0.476409,-0.015920,0.019146,0.003827,-0.135386,0.009324,-0.001037,-0.007467,-0.058108,0.005533,0.001701) * L5_14 + mat4(0.007396,-0.193683,0.022572,0.010114,0.012319,0.709994,0.010851,0.001688,0.002386,0.051350,-0.005271,0.014475,-0.006815,0.041947,-0.014225,0.013480) * L5_15 + vec4(-0.005873,-0.445841,0.007942,-0.007450)));\nvec4 L6_12 = sin((mat4(0.039485,-0.001706,-0.027907,0.140543,-0.019598,-0.010678,-0.091577,0.060785,0.050574,-0.007349,0.103857,-0.014117,-0.065495,0.000200,-0.099900,-0.076707) * L5_0 + mat4(0.035454,0.011811,0.139529,-0.044756,0.027854,-0.006068,0.142956,-0.072272,0.113314,-0.004126,-0.125097,0.199492,-0.022237,-0.003280,-0.633163,-0.214881) * L5_1 + mat4(0.222581,0.007238,0.131761,0.030205,-0.133057,0.005108,0.796420,0.120560,0.019172,-0.003724,0.204484,0.212387,0.017780,-0.010877,-0.151796,-0.036596) * L5_2 + mat4(0.024648,0.000632,0.283303,-0.019693,0.373514,0.001227,-0.320303,0.551869,0.003641,0.002727,0.149667,0.051574,-0.291642,-0.017285,0.122198,0.842003) * L5_3 + mat4(-0.052535,-0.009834,0.144786,0.025001,-0.049217,-0.000908,0.081411,0.142934,0.028938,0.001244,0.120315,0.022163,-0.010058,-0.009327,-0.019313,0.063382) * L5_4 + mat4(0.032114,-0.013516,0.077526,-0.000672,0.030392,0.013728,-0.002417,-0.071541,0.036842,0.000623,0.496868,-0.208104,-0.085397,-0.000995,0.027324,-0.041209) * L5_5 + mat4(0.070085,-0.002168,-0.097469,0.134638,0.015618,0.003461,0.036467,0.043092,-0.006213,0.005737,0.088440,0.096022,-0.077930,0.007062,0.446011,-0.224221) * L5_6 + mat4(0.067530,0.004860,-0.161968,-0.019250,-0.104978,0.000796,0.326355,-0.351284,-0.035073,-0.010075,0.074435,-0.264908,-0.078122,0.000180,0.150101,-0.221351) * L5_7 + mat4(-0.155477,-0.009706,0.457763,-0.099938,0.026230,-0.000278,-0.207106,0.066546,1.030759,0.000993,-0.449631,0.238235,-0.023321,0.009653,0.136041,0.005146) * L5_8 + mat4(-0.085866,-0.012428,0.260056,-0.067841,-0.034546,-0.007212,0.074428,0.021723,0.041802,0.008115,-0.238462,0.025107,-0.105544,0.007685,-0.056395,-0.179126) * L5_9 + mat4(-0.145756,-0.012658,-0.057695,-0.224073,0.405292,-0.001859,0.415902,0.206152,0.038100,-0.000251,-0.116310,-0.013219,0.076161,0.012703,-0.147489,0.190109) * L5_10 + mat4(-0.016168,-0.012620,-0.089170,-0.026666,0.047150,-0.004973,-0.090116,0.010009,0.007001,-0.005844,-0.236310,0.059812,-0.040745,0.000958,0.114246,-0.095073) * L5_11 + mat4(0.006150,0.010275,-0.071913,-0.026949,0.001794,-0.006340,-0.087260,0.086918,0.066964,0.003261,-0.052665,0.069388,-0.005969,-0.008289,-0.264475,-0.018521) * L5_12 + mat4(-0.026715,0.003771,0.212844,0.219272,-0.069741,-0.002138,0.150568,-0.130624,0.003846,-0.011640,-0.021696,0.007435,-0.074429,0.014476,-0.205397,0.031935) * L5_13 + mat4(0.040907,0.000274,0.112397,-0.086977,-0.093364,-0.021207,-0.135921,-0.390170,-0.095479,-0.002261,-0.029382,-0.331722,0.009909,-0.005276,0.340920,-0.044585) * L5_14 + mat4(-0.047244,0.011653,0.249199,-0.079194,0.006835,0.013183,-0.201478,0.214826,0.016631,0.001337,-0.015257,-0.093845,0.013168,-0.008412,-0.265408,-0.058322) * L5_15 + vec4(0.445648,0.011474,0.556906,0.679385)));\nvec4 L6_13 = sin((mat4(0.002449,0.006729,-0.070587,-0.009010,0.004504,-0.005216,0.069383,-0.000997,0.000766,-0.009590,-0.015243,0.007459,0.008524,0.002008,-0.003508,0.007033) * L5_0 + mat4(-0.018991,0.023111,-0.017054,-0.017641,0.001074,-0.002620,0.004210,-0.007109,-0.015437,0.005346,-0.211498,0.002878,-0.003421,-0.017580,0.117619,-0.006531) * L5_1 + mat4(-0.004419,-0.009606,-0.417442,0.006458,0.022219,-0.004889,0.097543,-0.013014,0.005480,0.002650,-0.079864,-0.001986,-0.007903,-0.009402,-0.039628,0.000142) * L5_2 + mat4(-0.007321,-0.005937,0.121939,-0.011446,-0.002533,0.002242,0.734793,0.016714,0.000268,0.008651,0.040709,0.007630,-0.002899,-0.007565,0.383623,0.001417) * L5_3 + mat4(0.015578,0.014842,0.048803,0.007380,-0.009290,-0.000738,-0.076752,0.002222,-0.000308,0.007762,-0.053778,0.007833,-0.004385,-0.010162,0.015501,-0.006590) * L5_4 + mat4(-0.012644,-0.009096,-0.003487,-0.005394,0.010445,-0.001188,-0.039183,0.005066,-0.011316,-0.001825,-0.202050,0.018179,-0.001891,-0.016786,0.142310,0.001241) * L5_5 + mat4(-0.000373,-0.008897,-0.104736,0.008257,0.004316,0.005578,-0.014584,0.002953,-0.005294,-0.001015,-0.024364,-0.010972,-0.013819,0.006131,0.125595,-0.010010) * L5_6 + mat4(0.004504,-0.009824,-0.101086,-0.019871,0.006335,-0.020096,0.231758,0.007057,0.005104,-0.011564,0.181987,0.012432,0.002036,-0.000824,0.066718,-0.003756) * L5_7 + mat4(0.003710,0.017499,0.365424,0.002772,0.003032,-0.001455,0.041942,-0.014309,0.007575,-0.007909,0.611610,0.014879,0.004141,-0.007455,-0.008124,-0.008638) * L5_8 + mat4(0.009697,0.010451,0.055224,0.001635,-0.012099,-0.011450,-0.000604,0.002219,-0.006889,0.007987,0.001752,-0.009944,0.005258,-0.008771,0.158024,0.002459) * L5_9 + mat4(-0.001103,0.008006,0.160043,0.009009,-0.003492,-0.021043,-1.481602,-0.009863,0.004106,-0.010600,0.034605,-0.008800,-0.007667,0.011743,-0.030375,-0.008908) * L5_10 + mat4(0.013224,-0.003095,0.138124,0.007483,-0.004148,0.005524,-0.028392,-0.005059,-0.008256,0.006051,-0.050744,0.014728,-0.005453,0.010306,0.018588,0.002716) * L5_11 + mat4(0.016242,0.018510,0.042466,-0.010941,-0.000055,0.002335,-0.006992,0.001145,-0.001429,-0.000684,-0.083847,0.007787,-0.008627,-0.008290,-0.001528,-0.006937) * L5_12 + mat4(0.012693,0.000156,0.281347,-0.001258,-0.007286,-0.003525,0.067036,0.003787,0.021144,-0.006415,0.026042,0.009829,0.006979,0.023682,0.047558,0.007945) * L5_13 + mat4(0.007290,0.000706,0.005815,-0.004963,0.010309,-0.002277,0.119882,-0.003457,-0.004136,-0.010094,0.007319,0.015562,-0.004230,0.000706,0.002915,0.014070) * L5_14 + mat4(-0.018006,0.001834,0.109707,-0.005655,-0.006646,0.004927,0.057204,-0.016538,-0.002472,0.002056,0.074678,-0.011941,0.005112,-0.011041,0.081798,0.001304) * L5_15 + vec4(-0.009733,0.005257,0.523454,0.017486)));\nvec4 L6_14 = sin((mat4(-0.009703,-0.037353,-0.078461,0.026240,0.003017,-0.013238,0.004057,-0.014619,0.012271,0.002208,-0.025191,0.039593,0.013455,0.017848,-0.120315,0.081656) * L5_0 + mat4(0.001615,0.012347,0.120731,-0.187153,0.009740,0.059340,-0.183836,-0.028792,0.014584,0.173991,0.055997,0.193534,-0.014027,-0.109280,-0.130188,-0.193929) * L5_1 + mat4(-0.006541,-0.285139,-0.104980,0.439900,-0.011571,-0.130568,-0.072463,0.119130,-0.001114,-0.227591,0.193019,0.095873,0.004018,-0.021532,-0.060956,-0.115137) * L5_2 + mat4(-0.005659,0.014466,0.074838,-0.126096,0.004278,-0.337133,-0.391482,-0.077295,0.011509,-0.041164,0.003420,0.026265,0.002699,0.109123,-0.073043,-0.566126) * L5_3 + mat4(0.006025,0.056955,-0.002926,0.079603,-0.009520,0.082863,-0.087659,-0.066750,-0.015805,-0.000934,0.039965,0.165093,0.007308,0.019231,-0.035467,0.006512) * L5_4 + mat4(-0.003799,-0.022229,-0.027655,0.000674,0.011719,-0.042079,-0.049137,0.008906,0.001376,0.263207,0.080273,-0.388256,0.011531,0.070204,0.079764,0.031944) * L5_5 + mat4(0.004392,-0.150405,-0.113411,0.099739,-0.006997,0.019130,-0.032523,-0.036566,0.014918,-0.022028,-0.026629,0.016349,-0.007753,-0.069003,0.155851,0.001359) * L5_6 + mat4(-0.006272,0.102954,-0.033263,-0.021103,-0.000310,-0.132150,-0.028733,0.681112,0.007209,-0.083686,-0.006212,0.141285,0.005151,0.044231,0.072496,0.397834) * L5_7 + mat4(0.009346,-0.046033,-0.050647,0.067558,-0.003714,0.079069,-0.188568,-0.205191,0.000292,0.220754,0.126870,-0.806828,-0.007690,-0.086957,-0.160991,-0.032087) * L5_8 + mat4(0.013425,-0.058708,0.331076,0.318378,-0.002568,0.088820,0.075420,-0.077198,-0.008072,-0.009662,0.040764,-0.066678,0.001507,0.027221,-0.065102,-0.048748) * L5_9 + mat4(0.025703,-0.088429,0.109103,-0.760422,-0.003707,-0.119382,0.235620,0.100735,-0.004441,0.132737,0.094603,0.027886,-0.004144,-0.039500,0.091894,-0.066875) * L5_10 + mat4(-0.018791,0.357447,0.089506,-0.234045,-0.005416,-0.005022,-0.061045,-0.011293,-0.011925,0.000545,0.003031,-0.206573,0.009672,-0.063909,-0.006069,0.124230) * L5_11 + mat4(-0.005115,-0.036742,0.045107,-0.057414,-0.014112,0.093287,0.029739,-0.000732,-0.022341,-0.053378,0.035595,0.018728,-0.003252,0.014201,-0.209430,-0.031599) * L5_12 + mat4(-0.006123,-0.017531,0.218619,-0.024182,0.019251,0.076075,0.079527,0.340719,0.012989,0.017445,0.024655,-0.036849,-0.001110,0.189712,0.160972,0.089878) * L5_13 + mat4(-0.011240,0.049638,0.022904,0.006244,-0.003354,-0.064753,-0.475121,-0.228427,0.002077,0.073182,0.030971,0.058751,0.002053,-0.042239,0.076225,-0.032259) * L5_14 + mat4(-0.002301,-0.114336,-0.144171,-0.009373,0.018285,0.101950,-0.235690,-0.092395,0.006145,0.010056,0.016429,-0.046059,-0.000863,-0.105290,0.259983,0.209217) * L5_15 + vec4(0.012380,-1.317309,0.082385,0.701256)));\nvec4 L6_15 = sin((mat4(0.053146,0.005691,-0.015928,0.108866,-0.029683,-0.009254,0.013156,-0.097962,-0.142302,0.001997,-0.002220,-0.003456,0.051492,0.004642,0.005989,-0.357586) * L5_0 + mat4(0.119865,0.012173,-0.004267,0.187575,-0.169557,0.000454,0.001732,-0.204375,-0.088410,0.000923,0.017832,-0.136752,-0.238061,-0.008244,-0.001527,-0.212346) * L5_1 + mat4(-0.417881,0.006150,0.003886,0.350242,0.004319,-0.009545,0.012113,-0.174526,0.073262,-0.006367,-0.011240,-0.079798,-0.021646,-0.008777,0.010869,-0.066233) * L5_2 + mat4(-0.048681,0.016344,0.005424,-0.002639,-0.505356,-0.017376,0.011851,0.387527,-0.067704,-0.001211,-0.000747,-0.134281,-0.007372,-0.016799,-0.006305,-0.001686) * L5_3 + mat4(-0.083035,0.002274,-0.001690,0.021770,-0.142789,0.008014,-0.012963,0.062488,-0.031226,0.001388,-0.008282,0.005643,0.013481,-0.007682,0.014608,-0.025973) * L5_4 + mat4(-0.018654,0.016773,-0.015017,-0.041339,-0.108055,-0.007911,0.001329,0.002539,0.234764,0.002145,0.013378,0.137208,-0.031537,-0.008366,0.006391,-0.031691) * L5_5 + mat4(0.049719,-0.006594,-0.003577,-0.033323,0.061799,0.003405,-0.014094,0.067550,0.028663,-0.014115,-0.002832,0.056694,0.145880,-0.006151,0.004684,0.047908) * L5_6 + mat4(-0.096220,0.007675,0.011644,0.112851,0.229990,-0.006899,0.016310,0.066615,-0.012798,-0.012234,0.014930,0.030361,-0.191367,0.004754,0.002669,0.068580) * L5_7 + mat4(0.544756,-0.011810,0.001959,0.215522,0.114810,0.005283,0.008390,0.152344,0.513273,-0.008747,-0.014002,0.233582,0.131743,-0.024785,-0.013949,-0.038534) * L5_8 + mat4(-0.017762,-0.018422,0.008536,0.270447,0.045626,-0.005088,-0.002297,0.125972,0.058372,0.013914,-0.006247,0.003257,-0.071850,-0.011141,0.024615,0.038976) * L5_9 + mat4(0.110377,0.010019,0.007321,-0.123738,0.238646,-0.002838,-0.002465,-0.762599,-0.057808,0.004980,0.004198,0.124957,-0.081967,0.009111,-0.003934,-0.077741) * L5_10 + mat4(-0.102224,0.004316,-0.008470,-0.031774,0.034069,-0.001588,0.007314,-0.031031,-0.025769,-0.002271,-0.016601,-0.028163,0.071728,0.018377,0.006082,0.052898) * L5_11 + mat4(0.153074,0.012718,-0.021039,-0.007756,0.061598,-0.007179,0.003323,0.026554,0.198581,-0.001507,0.004767,-0.033950,0.098784,0.011424,-0.000135,0.042048) * L5_12 + mat4(0.115586,-0.006478,-0.017727,-0.004162,-0.105831,0.003146,0.003085,-0.147278,-0.006757,0.009789,-0.004253,0.124183,0.086129,-0.008372,-0.011652,0.089400) * L5_13 + mat4(0.005822,-0.001864,0.000616,-0.028170,0.052305,0.001182,-0.007306,-0.210256,0.008157,-0.012786,-0.015119,0.015841,-0.034869,0.010134,-0.003479,0.037861) * L5_14 + mat4(-0.187479,-0.005892,-0.004286,0.424870,0.314478,0.009646,0.010613,-0.011941,0.039838,0.000683,-0.009877,0.109537,0.087706,-0.007186,-0.007393,-0.048995) * L5_15 + vec4(-0.548702,-0.005922,0.013945,-0.224158)));\nvec3 F_0 = (mat4x3(-0.050535,-0.082284,-0.004164,-0.001882,-0.001069,-0.000694,0.000296,0.000253,0.000477,0.020655,0.022944,0.018785) * L6_0 + mat4x3(0.000156,-0.000014,0.000587,-0.033545,-0.024448,-0.020245,0.066703,0.002646,-0.001433,-0.000053,-0.001857,-0.001182) * L6_1 + mat4x3(0.014974,0.011566,0.009727,0.001657,-0.000894,0.002260,0.000423,-0.000349,0.000300,0.000339,0.001233,-0.000737) * L6_2 + mat4x3(-0.000131,-0.001275,-0.001236,-0.000509,-0.001610,0.000152,-0.000863,-0.000432,0.001188,0.008350,-0.043814,-0.006368) * L6_3 + mat4x3(0.008423,0.014296,0.012682,0.001201,-0.008230,0.007920,0.000336,-0.000390,0.000179,0.000359,-0.002487,-0.007246) * L6_4 + mat4x3(0.002370,0.023515,0.022971,-0.058527,0.079215,0.077928,-0.001745,-0.002456,-0.000131,-0.001119,0.006413,-0.005151) * L6_5 + mat4x3(-0.002111,0.010148,-0.003516,-0.092600,-0.084882,-0.068046,0.002575,-0.000558,0.001131,-0.141211,0.021440,0.017831) * L6_6 + mat4x3(-0.000623,-0.001211,-0.000060,0.000281,0.001329,0.001736,0.050364,-0.008278,-0.007040,-0.000151,-0.000299,0.000411) * L6_7 + mat4x3(-0.000071,-0.000464,0.000453,0.097829,0.038580,0.032941,-0.083085,0.025909,0.030248,0.001519,0.000722,0.000760) * L6_8 + mat4x3(-0.000746,-0.001439,0.001226,0.178259,0.187013,0.166716,0.001811,0.000489,0.000285,-0.000786,0.000291,-0.001493) * L6_9 + mat4x3(-0.003101,0.041172,-0.024604,0.000199,-0.000459,0.000238,-0.001186,0.000934,-0.001896,0.000156,0.000098,0.000546) * L6_10 + mat4x3(0.000974,0.001089,-0.000055,0.001241,0.001156,-0.001035,0.000321,0.000141,0.000056,0.000727,-0.000533,-0.001078) * L6_11 + mat4x3(0.000074,-0.003070,0.001484,0.000351,0.000546,0.000057,-0.007496,-0.001260,-0.002715,0.000903,0.003748,-0.000915) * L6_12 + mat4x3(0.000507,-0.000635,-0.001098,0.000061,-0.000839,-0.000085,0.000511,0.000500,0.000390,0.000058,0.000089,0.000869) * L6_13 + mat4x3(-0.000091,0.000648,0.000266,-0.079323,0.078758,0.068576,0.005793,0.002415,-0.041360,0.001413,0.001686,-0.001550) * L6_14 + mat4x3(0.021359,0.011440,0.060961,0.001542,0.000274,0.001013,-0.000939,0.000214,0.000264,-0.011827,-0.004761,0.048384) * L6_15 + vec3(-0.297091,-0.347549,-0.393614));\nreturn F_0;\n}\n\n#pragma optimize(on)\n\n\n#pragma optimize(off)\nvec3 Lightmap_Render_Floor(const vec3 view_0, const Hidden hidden)\n{\nvec4 L3_0 = hidden.H_0;\nvec4 L3_1 = hidden.H_1;\nvec4 L3_2 = hidden.H_2;\nvec4 L3_3 = hidden.H_3;\nvec4 L3_4 = hidden.H_4;\nvec4 L3_5 = hidden.H_5;\nvec4 L3_6 = hidden.H_6;\nvec4 L3_7 = hidden.H_7;\nvec4 L3_8 = sin(60.000000 * (mat3x4(-0.557366,0.001606,0.005639,-0.003925,0.082048,-0.009651,-0.021051,-0.006960,-0.145771,-0.061522,-0.105722,-0.072543) * view_0 + vec4(-0.077437,-0.033951,-0.158701,0.240558)));\nvec4 L3_9 = sin(60.000000 * (mat3x4(0.518283,-0.221484,-0.224154,-0.473139,0.118386,0.115286,0.304988,-0.177106,-0.279711,0.376640,-0.015553,0.173265) * view_0 + vec4(0.166862,-0.059847,0.093552,0.206641)));\nvec4 L3_10 = sin(60.000000 * (mat3x4(0.560785,0.865692,0.789723,-0.020277,0.403476,0.028820,0.146414,-0.069042,0.191249,0.136033,-0.141862,-0.281956) * view_0 + vec4(-0.372860,0.185215,-0.117378,-0.180266)));\nvec4 L3_11 = sin(60.000000 * (mat3x4(-0.565932,-0.761267,-0.304976,-0.004036,-0.169161,-0.189902,-0.036622,-0.020012,0.068491,-0.195130,-0.250707,-0.112909) * view_0 + vec4(0.329514,0.223788,0.023003,0.299487)));\nvec4 L3_12 = sin(60.000000 * (mat3x4(0.749649,-0.016442,-0.213504,0.682010,-0.010038,0.264151,-0.232490,0.077377,0.225025,-0.208934,0.282137,0.026721) * view_0 + vec4(0.347493,-0.145449,0.186046,-0.218902)));\nvec4 L3_13 = sin(60.000000 * (mat3x4(0.907145,0.224008,-0.569701,0.717586,-0.003940,-0.303347,0.126742,-0.046292,-0.119820,-0.021542,0.097744,0.085215) * view_0 + vec4(0.324858,0.368472,0.143421,0.185014)));\nvec4 L3_14 = sin(60.000000 * (mat3x4(0.001374,0.336960,-0.719216,0.768157,0.030913,0.053373,-0.188134,-0.088705,0.155690,0.235544,-0.318009,-0.047864) * view_0 + vec4(0.259492,-0.002828,-0.068973,0.142165)));\nvec4 L3_15 = sin(60.000000 * (mat3x4(0.008773,-0.212907,-0.011984,-0.011590,-0.005770,-0.401271,-0.851151,-0.044085,-0.008444,0.004789,-0.234110,-0.195585) * view_0 + vec4(-0.036824,0.273616,-0.255730,0.221593)));\nvec4 L4_0 = sin((mat4(0.151153,0.301680,0.056123,0.052622,0.468979,0.150769,0.046161,0.011565,-0.185399,-0.120228,-0.243103,-0.303978,-0.184231,0.366397,-0.364406,-0.341525) * L3_0 + mat4(-0.130027,-0.100660,0.150691,-0.150414,0.442317,-0.333520,-0.454243,0.110394,-0.016825,-0.069549,0.550248,-0.587567,0.067342,-0.956425,-0.419592,0.153549) * L3_1 + mat4(-0.305418,-0.216897,0.325508,-0.061775,-0.023555,-0.393292,0.254786,-0.008823,0.027722,-0.274268,-0.012451,-0.124592,0.535043,-0.180876,0.201868,-0.066014) * L3_2 + mat4(0.010635,-0.416414,-0.046400,-0.164851,-0.180237,0.242293,-0.131700,-0.104168,-0.090769,-0.257024,-0.584974,-0.286282,0.244313,-0.175107,0.067868,0.031800) * L3_3 + mat4(0.108539,-0.204163,-0.056706,0.024463,0.062212,-0.057179,-0.198612,-0.391340,-0.331143,0.536181,0.215413,-0.413063,-0.256338,-0.128231,-0.101684,0.349124) * L3_4 + mat4(0.247637,0.424067,0.085643,0.252845,-0.046791,-0.218488,0.000994,-0.098730,0.436628,0.524610,0.285713,0.087355,-0.164659,-0.343685,0.366460,-0.025651) * L3_5 + mat4(0.122376,0.075092,0.180160,-0.208877,-0.021315,-0.565238,0.228723,-0.070082,-0.145407,-0.354016,0.062059,-0.615346,-0.287989,-0.208149,0.138692,-0.390117) * L3_6 + mat4(-0.080436,0.170778,-0.128402,-0.128329,-0.148692,0.268288,0.123034,-0.164954,-0.200475,0.166853,0.315052,-0.230748,0.183974,0.283105,-0.105587,-0.009068) * L3_7 + mat4(-0.181432,-0.380690,0.041604,0.050789,0.041559,-0.312255,-0.101816,0.139446,-0.016513,0.002430,-0.017225,0.042066,0.000823,-0.016557,-0.012396,-0.000866) * L3_8 + mat4(-0.080752,-0.219958,0.095333,0.040391,-0.017132,0.016866,-0.010348,-0.003238,0.006332,-0.018852,-0.004303,0.030525,-0.049876,-0.091361,0.037607,-0.140891) * L3_9 + mat4(-0.033095,0.052254,-0.027177,-0.043160,-0.480360,0.370516,-0.138028,-0.390992,0.096046,0.125889,-0.020535,-0.144520,-0.020106,0.007740,-0.008992,0.011217) * L3_10 + mat4(0.005184,0.160599,-0.004614,-0.192511,-0.133746,-0.083638,0.033555,0.075569,-0.027105,0.054423,-0.016408,-0.014551,-0.001459,0.017564,-0.026331,-0.028313) * L3_11 + mat4(-0.210769,-0.253861,0.106791,0.109920,-0.011351,0.008768,-0.175076,0.075015,0.066854,0.056619,0.013336,0.008319,0.193484,0.085256,0.073252,0.172131) * L3_12 + mat4(0.340888,0.370641,0.011860,0.178007,-0.040083,-0.111536,0.022396,0.136667,0.006747,-0.163829,-0.065438,0.445860,-0.195198,-0.190807,0.015988,-0.084059) * L3_13 + mat4(-0.021928,-0.004951,-0.024969,0.013048,0.135917,0.238061,0.218244,-0.353621,0.048853,0.116948,-0.042001,-0.117818,0.047953,-0.042629,-0.013138,0.022860) * L3_14 + mat4(0.000078,0.359816,0.094574,-0.087602,0.001171,-0.034081,-0.005739,-0.089986,0.049971,-0.012830,0.008700,-0.025267,-0.021872,-0.019096,0.019246,0.011343) * L3_15 + vec4(0.291798,-1.126274,-0.123771,0.772939)));\nvec4 L4_1 = sin((mat4(-0.219889,-0.359221,-0.111083,0.049393,0.414855,-0.422020,-0.127544,0.487390,-0.053191,0.231919,-0.042996,0.176026,0.198404,-0.214190,-0.284738,0.039732) * L3_0 + mat4(0.019565,-0.345796,0.562659,0.055672,0.534645,0.016858,0.084972,-0.281137,0.144392,0.339437,0.697385,0.515877,0.343439,0.017667,0.102577,0.048416) * L3_1 + mat4(-0.052421,0.213330,-0.140137,-0.420806,0.385051,0.016363,0.009086,0.024185,0.398182,0.167105,0.234078,-0.194727,0.278187,0.254171,0.247881,-0.055078) * L3_2 + mat4(-0.134732,-0.504833,-0.212440,-0.224213,-0.050517,0.033824,0.166859,-0.244301,-0.253499,-0.029927,-0.574218,-0.048108,0.188789,0.200168,0.227496,-0.034144) * L3_3 + mat4(-0.063845,0.303853,0.476385,-0.065646,0.224204,0.316563,-0.356333,0.399272,0.083124,0.492848,-0.213462,0.540476,-0.066637,0.032202,-0.224490,-0.295556) * L3_4 + mat4(0.221204,0.387129,0.068193,0.318207,0.327818,-0.234016,-0.358691,0.796250,0.296118,0.130873,-0.058580,-0.353700,-0.036856,0.190607,0.261589,0.029817) * L3_5 + mat4(0.439102,-0.558505,0.237678,0.842346,0.103351,-0.121172,-0.117637,-0.045227,0.537151,0.373014,-0.080444,-0.111427,-0.024863,0.359902,0.022421,-0.209771) * L3_6 + mat4(-0.388838,-0.261236,0.064986,-0.159066,0.251550,0.124323,-0.086996,-0.059408,0.050312,0.279617,-0.149598,0.056690,-0.213439,-0.351106,0.457702,0.277482) * L3_7 + mat4(-0.125410,0.093628,-0.043203,0.376233,0.026846,-0.108820,0.060323,0.299124,-0.005848,0.006536,-0.024172,-0.001324,0.003146,0.028545,0.023785,0.006157) * L3_8 + mat4(-0.121702,0.105645,0.124782,0.130253,0.001690,0.003248,-0.017840,0.009580,0.201674,-0.086722,-0.012341,-0.003117,-0.036458,0.079225,0.175268,0.015470) * L3_9 + mat4(-0.037217,-0.013338,0.030980,-0.017786,-0.071014,0.012727,-0.091982,-0.217869,0.038101,-0.085985,0.023287,0.185780,-0.034875,-0.001310,-0.032363,0.033169) * L3_10 + mat4(0.058100,-0.037195,0.029739,0.014082,-0.010872,0.137444,0.029592,-0.154775,0.013834,0.019618,-0.057516,0.025890,-0.008300,-0.023753,0.021214,-0.010596) * L3_11 + mat4(0.037742,0.068337,0.054152,-0.537608,-0.043683,-0.001020,0.034509,-0.067774,-0.170650,-0.056901,0.109544,-0.109011,-0.025978,-0.062372,-0.108687,0.087282) * L3_12 + mat4(-0.061183,-0.067765,0.032609,0.177207,-0.047229,-0.085335,0.217177,0.021279,-0.039049,0.106466,-0.079867,-0.183632,-0.002752,-0.019665,0.096520,-0.041957) * L3_13 + mat4(-0.002865,0.009395,-0.014094,-0.013496,-0.114526,0.344270,-0.016589,-0.414287,0.057732,-0.004259,0.006945,0.041644,-0.039904,-0.049456,-0.002841,0.057210) * L3_14 + mat4(-0.021140,0.051511,-0.061374,-0.279153,0.013086,-0.062299,0.007890,0.072332,0.023036,-0.008192,0.018125,-0.006273,-0.003306,-0.004012,-0.036215,0.001045) * L3_15 + vec4(0.223636,-0.276315,-0.166776,0.997412)));\nvec4 L4_2 = sin((mat4(0.011574,0.093700,0.065656,0.070292,0.462744,0.129771,-0.561523,-0.155243,-0.175708,0.177672,-0.072531,-0.157566,0.303848,0.656200,0.392334,0.524974) * L3_0 + mat4(-0.148014,0.183566,-0.365552,-0.239685,-0.297625,-0.155106,0.033400,0.623922,-0.258031,-0.202276,0.126902,-0.128064,-0.014037,-0.361676,-0.105640,0.196490) * L3_1 + mat4(-0.070876,0.244761,-0.179311,-0.137214,-0.149594,-0.024253,0.024801,0.178515,-0.286465,0.418724,-0.280975,-0.068115,-0.244933,0.146750,-0.426429,0.128967) * L3_2 + mat4(-0.104753,-0.181030,0.433413,0.046392,-0.037392,0.485563,-0.004155,0.031319,-0.203504,0.102761,-0.081061,-0.509656,0.087712,0.230379,-0.086718,0.229981) * L3_3 + mat4(-0.093065,-0.284637,0.073901,-0.127541,-0.391303,-0.335308,0.139723,-0.390389,-0.122257,-0.093768,0.346694,-0.132205,-0.048363,-0.166512,0.123096,0.223386) * L3_4 + mat4(-0.133347,-0.219959,0.082728,-0.003649,-0.239228,0.470527,-0.562117,0.044998,0.094903,0.160840,0.001493,0.664242,-0.013166,0.032202,-0.040219,-0.058630) * L3_5 + mat4(-0.431079,-0.126011,-0.036962,0.042327,-0.110183,-0.181219,-0.032802,-0.036499,0.209546,0.173106,-0.308729,-0.271716,-0.055738,-0.036649,-0.279990,-0.179367) * L3_6 + mat4(0.046762,0.197882,-0.251554,0.000275,0.124304,0.140893,-0.004940,0.246367,-0.403211,0.024656,-0.497524,-0.593609,0.271833,-0.177716,0.289169,-0.093015) * L3_7 + mat4(-0.007861,0.142707,-0.078269,-0.043949,-0.078547,0.017711,0.103395,0.012650,0.021112,0.003749,-0.004130,0.017833,-0.005564,-0.016144,-0.009035,0.012807) * L3_8 + mat4(-0.023510,-0.029775,0.031774,0.009616,-0.003788,0.008526,-0.012632,0.018326,0.015418,-0.070420,-0.012092,-0.120678,-0.005764,0.025646,0.068271,-0.023315) * L3_9 + mat4(-0.013105,-0.008027,-0.017288,-0.004502,0.022710,0.151930,-0.178780,-0.103488,0.009212,0.182366,0.029624,0.023352,-0.001810,-0.002510,0.004391,0.021020) * L3_10 + mat4(0.016508,0.018290,0.008175,0.029112,-0.021277,0.309503,-0.106598,-0.062926,-0.031648,-0.011709,0.055283,-0.045273,0.010192,0.007163,-0.007591,0.006027) * L3_11 + mat4(-0.030418,0.276153,-0.016962,0.042583,-0.267855,0.041704,-0.118021,-0.307610,-0.117766,-0.116524,-0.002076,-0.012391,-0.020356,-0.277559,0.117642,0.067091) * L3_12 + mat4(0.076585,0.675725,-0.027460,0.074759,0.030700,-0.088035,-0.102834,0.189725,0.068321,-0.027631,0.018685,-0.083174,0.009574,0.159126,-0.134018,0.060260) * L3_13 + mat4(-0.009351,0.007535,0.003854,0.011629,-0.057798,-0.053176,0.013078,0.000538,0.029962,0.069422,-0.039452,-0.003358,0.031438,0.055623,0.002737,-0.009222) * L3_14 + mat4(0.046731,0.037932,-0.143010,-0.029053,0.043459,0.036247,0.027660,-0.071865,0.042869,0.014635,0.017888,0.048227,0.006776,0.003005,0.006118,-0.018074) * L3_15 + vec4(0.005279,-0.332762,0.844646,0.060436)));\nvec4 L4_3 = sin((mat4(0.215948,-0.171778,0.220237,0.247624,0.697679,0.395245,0.157180,0.469449,-0.540928,0.170497,-0.239562,0.197162,0.205640,0.094750,-0.329543,-0.143741) * L3_0 + mat4(-0.018838,-0.089925,0.045693,0.505046,-0.280077,0.157663,0.255279,0.189186,-0.160371,0.136797,0.244888,-0.176471,-0.426822,0.129559,-0.458850,0.177388) * L3_1 + mat4(0.301996,0.129383,-0.021608,-0.098239,-0.044331,-0.305743,0.218654,0.188936,-0.181375,-0.286414,0.140450,0.179038,-0.341321,0.241369,0.120833,-0.309888) * L3_2 + mat4(0.162010,-0.057912,0.178286,0.221738,-0.003036,-0.144435,0.024414,0.046916,0.165268,0.637620,0.518052,0.012061,-0.450566,-0.006688,-0.334559,-0.041711) * L3_3 + mat4(0.062574,0.279801,0.163715,-0.090069,-0.526210,-0.135351,0.122537,-0.170858,0.039256,-0.194882,-0.120350,-0.215844,0.123583,-0.337144,-0.185932,-0.058885) * L3_4 + mat4(-0.748072,-0.214770,0.473209,0.308473,0.273403,0.541469,0.198745,0.295122,0.174695,-0.351751,0.244316,-0.452445,-0.121607,-0.233141,0.190737,0.280910) * L3_5 + mat4(-0.258880,0.332698,0.283933,0.786953,-0.030493,0.174584,-0.575337,-0.121236,0.235613,0.288138,-0.572507,-0.271164,-0.000560,-0.062296,-0.034978,-0.163841) * L3_6 + mat4(0.375391,-0.211998,0.123512,0.092752,0.690926,0.116720,0.216732,-0.257224,-0.447336,-0.259097,0.137252,-0.013882,-0.296987,-0.124018,-0.192461,-0.551124) * L3_7 + mat4(-0.024965,0.293959,0.164519,-0.138383,-0.061958,0.006939,0.212247,0.011432,0.014757,0.007298,-0.012302,-0.007690,0.010635,0.010453,-0.003316,-0.000346) * L3_8 + mat4(-0.041447,0.211038,0.223118,0.005509,-0.008899,0.040868,0.022521,0.005088,0.063242,-0.146898,0.041847,0.009100,0.018020,0.025168,0.048616,0.008994) * L3_9 + mat4(0.009085,0.028157,0.007756,0.015914,0.205598,0.377563,-0.389423,-0.019204,-0.081694,-0.147671,0.230175,-0.020083,-0.008418,-0.029183,-0.003863,-0.006770) * L3_10 + mat4(0.044879,-0.108932,-0.048819,-0.036635,0.017562,-0.072490,0.022412,-0.007149,0.045361,0.081455,0.044904,-0.008273,-0.028639,-0.006171,0.010595,0.003935) * L3_11 + mat4(-0.135455,-0.002351,0.176505,-0.033343,-0.044222,0.250743,-0.023693,0.046998,0.058428,0.343799,0.094187,-0.161681,-0.021530,-0.169158,-0.061837,-0.058036) * L3_12 + mat4(-0.020944,-0.261190,0.354205,-0.111870,-0.091919,0.117457,0.323807,-0.072376,-0.077637,0.101741,0.010201,-0.000998,-0.070402,0.118799,0.168934,0.050035) * L3_13 + mat4(0.001277,0.033381,0.034498,-0.012383,0.120689,0.149553,-0.357070,-0.157775,0.010622,-0.057382,0.109513,-0.015291,-0.036602,-0.054599,0.127083,0.018792) * L3_14 + mat4(0.045555,-0.014282,-0.160658,-0.027108,-0.080681,0.014103,0.147986,0.016825,0.017870,0.050041,0.002050,-0.010585,0.021939,0.016525,0.035829,-0.015815) * L3_15 + vec4(-0.601792,0.119407,0.730214,-0.097553)));\nvec4 L4_4 = sin((mat4(-0.037871,0.501864,-0.104904,0.043579,-0.188273,0.642865,-0.052364,-0.442303,-0.199776,0.151559,-0.292272,0.045302,0.510641,0.475945,-0.405940,0.167135) * L3_0 + mat4(-0.051118,0.447822,0.015477,-0.561138,0.147686,-0.650431,0.810144,0.165529,0.164725,-0.309769,-0.501111,-0.143473,0.073992,-0.246385,0.152347,-0.156429) * L3_1 + mat4(0.139183,-0.129928,-0.034262,-0.009046,-0.127861,-0.153559,0.185014,-0.263344,-0.150472,0.034314,-0.020327,-0.172331,0.202342,-0.120169,-0.122157,0.401738) * L3_2 + mat4(-0.358824,0.018699,-0.055235,-0.284949,0.207657,0.189507,-0.073039,-0.165020,0.199656,0.203664,0.324123,-0.368449,0.161341,-0.016218,-0.104014,0.448529) * L3_3 + mat4(0.264731,-0.184515,-0.088570,0.203166,-0.091332,-0.008133,-0.588174,0.137140,-0.293900,0.109192,0.135310,-0.738342,-0.015967,-0.237540,-0.165491,-0.158546) * L3_4 + mat4(0.180811,-0.070651,0.429651,0.063193,0.052368,0.247078,-0.102194,-0.535943,0.014836,-0.192511,0.229747,-0.004263,-0.502786,0.137141,-0.023607,-0.042069) * L3_5 + mat4(0.090181,0.438075,0.140523,-0.039181,0.086565,-0.391715,0.052621,0.245480,-0.173937,0.093254,-0.248505,-0.378214,-0.184783,-0.378102,0.049567,0.005882) * L3_6 + mat4(0.002880,0.522937,0.270360,0.039437,-0.422203,0.033607,-0.295239,-0.107676,-0.436298,0.070162,0.176925,-0.514062,-0.305171,-0.021004,-0.204395,0.278457) * L3_7 + mat4(-0.299183,-0.137152,-0.089357,0.067930,0.134032,0.142897,0.073393,0.033283,-0.003540,0.001302,-0.008100,0.011048,0.001622,-0.004385,0.002593,-0.028446) * L3_8 + mat4(-0.173920,-0.013511,-0.062241,-0.048279,0.002107,0.020237,0.004261,0.007369,0.051279,-0.126962,0.002597,0.052848,0.171157,-0.041666,-0.012414,-0.049245) * L3_9 + mat4(0.005964,0.012637,-0.005741,0.007411,0.056709,-0.017825,0.074737,-0.051765,0.075458,-0.029791,-0.027067,0.066067,0.003890,0.016167,0.008679,0.005128) * L3_10 + mat4(0.281335,-0.020149,0.034347,0.034472,-0.143009,0.042782,-0.026104,-0.096367,0.011158,0.031880,0.011658,0.019274,0.007528,0.008860,-0.004114,0.020387) * L3_11 + mat4(-0.358898,0.154529,-0.003286,-0.061098,-0.133379,-0.182095,0.063724,0.116153,-0.012752,0.075032,-0.018534,0.114650,-0.150745,0.088280,-0.020741,-0.009993) * L3_12 + mat4(0.036524,-0.147078,-0.061989,-0.057936,0.245575,0.058749,0.044124,0.064876,-0.518929,-0.047719,-0.002982,0.012456,0.358008,-0.042460,-0.032261,0.052598) * L3_13 + mat4(0.045863,0.013846,-0.017119,0.007833,0.560846,-0.248103,-0.161242,-0.061026,0.032791,-0.041237,0.010616,-0.005352,0.081591,0.011489,0.013564,-0.031059) * L3_14 + mat4(-0.152180,-0.109702,-0.091346,-0.058574,0.132667,-0.078256,0.049721,0.043225,0.001212,0.036241,-0.021705,0.001846,0.014961,0.033926,0.004267,0.030883) * L3_15 + vec4(0.419663,0.777063,-0.013672,-0.165849)));\nvec4 L4_5 = sin((mat4(0.028532,-0.114838,0.026198,0.174165,-0.032893,-0.471658,-0.092852,-0.105412,-0.044328,0.261323,0.100510,0.201390,0.202062,-0.256369,-0.003973,0.015311) * L3_0 + mat4(-0.495077,-0.038442,-0.319426,0.031840,0.068052,0.187181,-0.060610,0.125089,0.389360,-0.045769,0.128088,-0.220927,0.170627,0.067452,-0.321370,-0.124341) * L3_1 + mat4(0.282280,-0.135637,-0.216172,-0.161261,0.018258,0.239281,-0.137378,-0.026914,-0.146890,0.123958,-0.018575,0.315375,0.129418,-0.039308,0.200633,-0.070849) * L3_2 + mat4(-0.293308,0.101137,-0.083699,-0.401215,0.008231,0.077184,0.079892,0.215324,0.115760,-0.049772,-0.077483,0.161198,0.155045,-0.144731,-0.135949,-0.073297) * L3_3 + mat4(0.151953,-0.186307,0.014986,-0.133188,-0.050621,0.032212,-0.164228,0.206691,0.127195,0.089597,-0.472514,-0.179863,-0.204860,0.151412,-0.205609,-0.300484) * L3_4 + mat4(0.339176,0.224213,-0.276099,0.275486,0.242674,0.326228,-0.752929,-0.238068,-0.155297,0.207590,0.158442,0.288601,-0.081579,-0.187925,0.312029,0.012592) * L3_5 + mat4(0.234769,-0.057456,0.176185,0.043200,0.211310,-0.142063,0.046839,-0.361041,-0.077434,-0.196019,0.251957,-0.724330,-0.165318,-0.008341,0.048394,0.068354) * L3_6 + mat4(-0.149600,-0.488313,0.195808,0.632119,-0.291723,-0.239036,-0.083036,0.148946,0.084151,-0.005506,-0.240928,0.217151,0.434001,0.182542,0.221492,-0.106440) * L3_7 + mat4(0.110806,0.023730,0.145292,-0.084330,0.113033,-0.159192,0.037094,-0.165283,-0.006639,-0.002383,0.002639,-0.003849,-0.020454,0.009659,-0.005242,0.002707) * L3_8 + mat4(0.063362,-0.017418,0.056023,-0.159638,-0.000215,0.014466,0.001337,-0.018726,-0.199181,-0.059140,0.007123,0.035580,0.037378,-0.014470,-0.055648,0.011453) * L3_9 + mat4(0.031346,0.014929,-0.057564,-0.057548,0.088533,0.030904,-0.308980,-0.220609,-0.040832,-0.006551,0.095870,0.072405,0.002478,0.005425,0.004474,-0.011511) * L3_10 + mat4(-0.014107,-0.007127,-0.045362,0.052820,-0.055159,-0.040682,-0.137297,0.143952,0.014375,-0.051997,0.032082,0.006018,0.003597,0.006485,0.013699,-0.014173) * L3_11 + mat4(0.041013,-0.064146,-0.036470,-0.222550,-0.328893,-0.044731,-0.021251,-0.181171,-0.036904,0.001551,0.085282,-0.163385,-0.056365,-0.015689,0.219829,-0.106519) * L3_12 + mat4(0.026501,-0.011338,0.080338,0.340162,-0.141108,0.006353,0.186308,-0.042613,-0.022590,0.002038,0.069403,-0.213135,-0.071015,-0.011885,-0.077010,0.148643) * L3_13 + mat4(0.011991,-0.002277,-0.009742,0.000366,0.129857,0.233983,-0.213954,-0.198672,-0.031128,0.035480,-0.003837,0.081709,-0.048120,0.035724,-0.050038,0.100803) * L3_14 + mat4(-0.081663,0.143690,-0.088403,0.107726,-0.161865,-0.016327,0.035689,-0.050307,0.064182,0.004929,0.004946,0.020708,0.000398,0.009186,0.031781,0.006906) * L3_15 + vec4(0.616178,-0.294205,0.091362,-0.891397)));\nvec4 L4_6 = sin((mat4(0.023562,-0.067839,-0.149043,-0.015424,0.376301,0.412042,0.145489,-0.034473,-0.071264,0.200790,-0.061103,0.224980,0.011234,0.409525,-0.174763,0.561593) * L3_0 + mat4(0.063277,-0.193923,0.136802,0.116058,-0.510509,-0.064102,-0.101319,0.005744,0.004332,-0.278871,-0.126531,0.072722,-0.082782,-0.195328,0.128815,0.070381) * L3_1 + mat4(0.098407,-0.077860,0.026386,-0.343185,-0.325273,-0.313496,-0.051115,-0.104084,-0.426297,-0.165359,0.050201,0.023172,-0.158634,0.321544,0.124021,0.118095) * L3_2 + mat4(0.387973,0.012631,-0.130063,-0.038548,-0.163016,-0.405655,-0.106543,0.288334,-0.028986,0.278046,-0.007584,0.015412,0.139374,0.130553,0.129265,-0.125482) * L3_3 + mat4(-0.275614,0.577610,0.023226,0.008895,0.232403,-0.189894,-0.108596,0.379499,-0.000489,-0.278503,-0.158844,0.226859,-0.165049,-0.288088,-0.255195,-0.182371) * L3_4 + mat4(-0.056240,-0.003761,-0.107979,-0.125583,0.349741,0.715557,0.636115,0.228959,-0.342666,-0.181591,-0.156956,-0.178904,-0.145351,-0.290604,-0.038109,-0.108807) * L3_5 + mat4(0.025884,-0.115357,-0.357787,-0.019627,-0.041412,0.114345,0.170808,0.213282,0.276718,0.332148,0.417915,0.680718,0.240183,0.070998,0.426600,-0.046095) * L3_6 + mat4(0.201710,0.718000,0.095250,0.557692,0.026036,0.181485,0.010630,0.418463,-0.265644,-0.631110,0.007029,-0.208058,0.328609,0.007761,-0.477480,0.037989) * L3_7 + mat4(0.161357,0.055645,0.077051,0.065267,-0.064357,0.098093,-0.100634,-0.024353,0.000527,0.011558,-0.002654,-0.000498,-0.005113,-0.003228,0.031640,-0.023970) * L3_8 + mat4(0.002299,-0.025709,0.043317,0.028802,0.000744,0.013856,0.009947,0.012138,-0.008167,0.015366,0.103957,0.008777,-0.057600,-0.096070,-0.013958,0.046744) * L3_9 + mat4(0.022096,-0.000221,0.008476,-0.007911,-0.393473,-0.133616,-0.247826,-0.210059,0.092944,0.050035,0.090455,0.009191,-0.003604,0.040139,-0.002001,0.006835) * L3_10 + mat4(-0.119916,-0.030832,0.015624,0.018779,0.085153,-0.141642,0.043998,0.048000,0.036767,0.026100,0.085335,-0.016359,0.005310,0.006264,0.007192,0.004480) * L3_11 + mat4(-0.048434,-0.200075,0.053034,-0.131376,-0.087348,-0.119810,0.043767,-0.061920,0.119837,-0.027831,-0.151148,0.067644,-0.214844,0.168025,0.272540,-0.071519) * L3_12 + mat4(-0.100140,0.018482,-0.213137,0.205905,-0.006262,-0.043666,-0.045333,-0.033805,0.110993,0.075352,0.041751,0.004770,0.237868,-0.117899,-0.232095,-0.021296) * L3_13 + mat4(-0.013306,0.025069,-0.003592,-0.022501,0.156470,-0.319742,-0.193365,-0.086210,0.023450,-0.023317,-0.040362,0.027609,0.169006,0.003151,-0.109345,0.013804) * L3_14 + mat4(0.080042,-0.027743,0.110153,0.053817,0.006273,0.037250,0.026022,-0.022148,0.008389,0.020493,0.011676,-0.001819,-0.012995,0.007007,-0.001132,0.000504) * L3_15 + vec4(-0.172154,0.133064,-0.557891,-0.190767)));\nvec4 L4_7 = sin((mat4(-0.135084,0.136049,-0.366874,-0.134239,0.102026,0.235346,0.265724,0.008301,0.033190,-0.223686,0.012450,0.108984,0.147415,0.184466,0.092398,0.117750) * L3_0 + mat4(-0.238517,0.072862,-0.217801,-0.399298,-0.179142,-0.095468,-0.076800,0.098524,0.355218,0.174384,0.330291,-0.048364,-0.233400,-0.458595,-0.139014,0.232239) * L3_1 + mat4(0.084782,0.161291,-0.178793,0.085036,-0.294633,0.118121,-0.084614,-0.171555,0.344225,-0.389349,-0.137585,-0.209070,0.232604,-0.009147,0.108117,-0.187974) * L3_2 + mat4(-0.139408,0.003280,-0.059383,-0.010120,-0.134982,0.085160,-0.285975,0.030200,0.582306,0.139537,0.314036,0.446310,0.155033,-0.155232,0.212018,-0.030718) * L3_3 + mat4(0.272407,-0.244094,0.371739,-0.050347,0.193280,0.130448,0.196475,-0.374019,-0.346344,0.460036,0.320481,-0.188491,0.013306,0.061687,0.279331,-0.014093) * L3_4 + mat4(0.058085,0.354268,-0.397824,-0.232974,0.203878,0.488289,0.076428,-0.008640,-0.002228,-0.195815,0.085782,0.005410,-0.036061,0.084464,-0.372201,-0.057418) * L3_5 + mat4(0.138888,0.392024,0.130110,-0.018624,-0.292711,-0.086761,-0.078090,0.538984,-0.926637,0.340587,0.463153,0.415216,-0.240850,-0.148266,0.155988,0.198856) * L3_6 + mat4(0.003862,-0.584969,0.013383,-0.290471,-0.033145,0.283231,0.270556,-0.354874,-0.012822,-0.166198,-0.238600,-0.133017,-0.442091,-0.424864,0.057263,0.065753) * L3_7 + mat4(0.018732,0.093657,0.091944,-0.208402,-0.109061,0.022192,-0.179629,0.059259,0.012298,-0.010257,-0.013972,-0.003895,0.020771,0.000103,-0.023268,-0.013181) * L3_8 + mat4(-0.025901,0.082157,0.135328,0.058631,-0.005040,0.010870,-0.000907,-0.004270,0.012649,0.101409,-0.027886,-0.010088,-0.016137,-0.015086,0.045048,-0.053392) * L3_9 + mat4(-0.022115,-0.025166,0.007790,-0.011115,0.131832,0.027668,0.343824,-0.173535,-0.023320,-0.041221,-0.062401,-0.061753,-0.018052,-0.011140,0.018581,0.017396) * L3_10 + mat4(-0.045680,-0.049940,-0.040188,-0.076109,0.034016,-0.052990,0.141162,-0.043833,-0.026199,0.015819,0.006848,-0.007355,-0.003108,-0.014260,0.016968,0.014552) * L3_11 + mat4(0.037321,-0.009894,0.359484,-0.062875,0.136555,0.086978,-0.271412,-0.253354,0.024012,0.074499,0.016464,-0.112489,-0.137446,-0.087594,-0.136427,0.024158) * L3_12 + mat4(0.037176,-0.108189,-0.104358,-0.142358,0.078030,-0.096008,0.119795,0.040144,0.098449,0.003950,-0.131540,-0.219444,0.017026,-0.041346,0.127998,-0.035308) * L3_13 + mat4(-0.016118,0.004792,-0.038610,-0.008153,-0.101309,-0.012975,0.200694,-0.213276,0.013507,-0.004876,-0.065772,-0.042152,0.009013,-0.025564,-0.045647,-0.023388) * L3_14 + mat4(0.112224,-0.028637,0.163518,-0.034856,-0.028104,0.010884,0.084091,0.001309,-0.019138,0.001464,0.102967,0.071831,0.016278,-0.011565,0.012331,-0.001272) * L3_15 + vec4(-0.645816,-0.072764,-0.408752,0.202656)));\nvec4 L4_8 = sin((mat4(0.250128,-0.041243,-0.154427,-0.196325,0.670372,-0.010795,0.166523,0.114430,-0.020915,-0.057708,0.379636,-0.073052,0.074931,-0.292578,0.216982,0.012221) * L3_0 + mat4(-0.067036,0.124665,0.544525,0.081736,-0.103997,0.010307,-0.882507,0.290125,-0.134939,0.022512,0.123994,0.206015,-0.174057,-0.064588,-0.015139,0.535593) * L3_1 + mat4(-0.193218,-0.224641,-0.045639,-0.071202,0.219980,0.296506,-0.458164,0.352837,0.305541,0.003883,-0.083392,0.046459,-0.480696,-0.052405,0.332718,-0.362250) * L3_2 + mat4(-0.104861,0.310263,0.088484,0.270403,-0.041180,-0.129626,0.078521,0.185126,-0.005856,0.155439,0.047082,-0.021946,-0.018904,-0.555951,0.172676,-0.024718) * L3_3 + mat4(-0.165454,0.083498,0.090888,0.548722,-0.373604,-0.298674,-0.240282,-0.312476,0.144702,0.109831,-0.113001,-0.306277,0.158575,0.238773,-0.130624,-0.218815) * L3_4 + mat4(0.128544,0.208699,0.032486,0.318193,0.751374,0.266037,0.482956,0.017357,0.309830,0.193899,-0.305083,-0.025037,0.180573,-0.070280,-0.017245,-0.035530) * L3_5 + mat4(-0.245827,-0.039859,0.001569,-0.108860,-0.497361,0.144320,-0.035200,-0.056885,-0.732384,-0.136696,0.052626,-1.022745,-0.316955,0.025223,0.050831,-0.238221) * L3_6 + mat4(0.012647,0.228424,0.319495,0.029708,0.190093,-0.124325,-0.094696,-0.092025,0.149958,0.204638,-0.386315,0.134908,0.278513,0.051236,-0.206557,-0.159922) * L3_7 + mat4(-0.017658,0.056016,-0.080592,-0.161632,0.205195,0.163187,-0.060153,-0.082744,-0.001425,0.026876,-0.020996,-0.010578,0.007537,0.002771,-0.003770,0.015284) * L3_8 + mat4(0.010073,0.014755,-0.081439,-0.269462,-0.023970,-0.010836,-0.021024,-0.019791,-0.084553,-0.066115,0.020238,0.003287,-0.048913,0.058664,0.020803,0.004099) * L3_9 + mat4(0.036017,-0.021953,-0.037047,0.008917,-0.151542,0.110884,-0.062438,-0.340106,-0.035114,-0.013995,0.060118,-0.147512,-0.001904,0.015595,0.016148,0.009824) * L3_10 + mat4(-0.051169,-0.011929,-0.006475,0.082277,0.071015,0.002713,-0.131584,0.244764,-0.060093,-0.045214,0.002812,-0.078692,0.001180,-0.011597,0.024986,0.035343) * L3_11 + mat4(0.097003,0.074911,0.103257,0.163631,0.035443,-0.447795,0.100702,0.099579,-0.122356,-0.021163,0.066403,-0.073458,0.105784,0.094633,0.393065,-0.458461) * L3_12 + mat4(-0.075797,-0.079538,-0.002700,0.458985,0.030727,0.141361,0.073199,0.067838,0.181307,-0.023051,0.204056,0.203171,0.027334,-0.116532,-0.083241,0.422505) * L3_13 + mat4(-0.004350,-0.013467,0.040982,0.021454,0.089146,0.079726,0.048628,-0.370076,-0.009028,-0.044484,-0.063746,-0.055813,0.029534,-0.046103,-0.013483,0.221976) * L3_14 + mat4(-0.170985,-0.169197,0.049089,0.070244,-0.007100,-0.122743,0.043592,-0.071707,-0.026794,0.076710,-0.003210,0.034020,-0.003478,0.009129,-0.033693,-0.017306) * L3_15 + vec4(0.838688,0.332035,0.044126,-0.298005)));\nvec4 L4_9 = sin((mat4(-0.290878,0.084114,0.301040,0.286105,0.148245,0.388489,0.184253,0.199460,-0.223662,0.183052,-0.013694,0.032945,0.115908,0.291675,-0.339956,0.048917) * L3_0 + mat4(0.173967,0.262207,-0.157303,-0.103401,0.122626,0.021588,-0.428911,-0.253541,-0.265050,0.070122,-0.014917,0.181248,0.105507,0.044247,-0.428943,-0.203421) * L3_1 + mat4(-0.948061,-0.104443,-0.115178,0.074064,-0.076704,-0.126466,-0.202632,0.102891,0.035762,0.052748,-0.035379,0.252700,-0.642627,0.128833,-0.018745,0.082479) * L3_2 + mat4(0.425915,0.288571,0.254332,0.051629,-0.168829,0.107086,0.374429,-0.019397,0.706800,0.552863,-0.017973,0.241572,0.118989,0.137427,-0.381793,0.016540) * L3_3 + mat4(0.477267,-0.300438,-0.113387,-0.496678,-0.330348,0.384272,-0.008412,-0.236827,-0.167124,0.253308,0.519799,-0.425381,-0.208734,-0.356006,0.011035,0.135829) * L3_4 + mat4(-0.283468,0.389761,-0.176799,-0.009727,-0.289816,0.627803,0.208764,-0.098575,-0.227392,-0.363040,-0.077767,0.398305,0.036872,-0.405208,0.107868,0.013710) * L3_5 + mat4(0.185518,-0.176098,-0.016702,0.684289,-0.248959,0.011527,-0.174339,-0.176948,-0.946062,-0.012877,-0.024788,-0.795446,-0.140979,-0.218118,0.011894,-0.363758) * L3_6 + mat4(0.255281,0.175254,0.613177,-0.145483,-0.336400,-0.102984,0.094630,0.309249,0.047338,0.071760,0.094395,0.096817,-0.323751,0.547941,0.090331,0.169524) * L3_7 + mat4(-0.200093,-0.017869,0.056996,-0.040088,0.342744,-0.295020,-0.032100,-0.104222,-0.005760,0.004595,0.006940,-0.007263,0.001102,-0.005860,0.016010,0.002990) * L3_8 + mat4(-0.068631,-0.047024,0.056706,0.142799,-0.082867,0.002348,0.004042,0.008942,-0.007197,0.075161,0.018117,-0.016041,-0.063184,-0.101462,0.049119,0.016491) * L3_9 + mat4(-0.001626,-0.016925,-0.005202,0.001794,0.085542,0.152734,0.041221,-0.091605,0.032156,0.038917,-0.000343,-0.034896,0.007456,-0.012010,-0.010249,-0.002452) * L3_10 + mat4(-0.041315,-0.001312,0.005623,-0.093219,-0.080255,-0.053798,0.032257,-0.040116,-0.070488,0.017020,-0.014556,0.017817,0.043640,-0.016419,0.009553,0.013804) * L3_11 + mat4(-0.108853,-0.078064,0.028095,-0.044138,0.084407,0.009233,0.097201,0.040134,-0.105119,0.047871,-0.061483,0.007750,-0.009953,-0.071158,0.071971,0.080550) * L3_12 + mat4(-0.077846,0.032940,0.096167,0.066139,0.004567,0.048324,0.020018,-0.073912,0.013361,0.084078,-0.008990,0.128338,-0.047289,0.057369,-0.106433,-0.087227) * L3_13 + mat4(-0.014197,-0.003458,0.005997,0.002471,-0.000999,-0.164696,-0.002337,-0.229124,0.007817,0.039758,0.022995,-0.052378,-0.010806,0.016476,-0.014301,0.049386) * L3_14 + mat4(-0.338581,0.234046,0.020697,0.072340,-0.011344,0.097139,0.006117,0.007943,0.002425,-0.005500,-0.035807,-0.017888,0.024299,0.003744,-0.008266,-0.006397) * L3_15 + vec4(0.511335,-0.676418,-0.072850,0.095382)));\nvec4 L4_10 = sin((mat4(-0.070069,-0.307482,0.013023,0.050436,0.444214,0.304122,-0.311255,0.321059,0.295496,-0.281633,-0.046513,0.000561,0.244525,-0.783994,-0.033570,0.108634) * L3_0 + mat4(0.358575,-0.097655,-0.057020,0.198613,0.078911,0.177902,0.372178,-0.359810,-0.020354,0.123859,-0.207685,0.205257,0.454010,0.027624,0.225469,0.369856) * L3_1 + mat4(0.100468,-0.156450,-0.145519,0.124860,0.120734,0.206921,0.139983,0.294309,0.289841,-0.445344,0.034624,0.175379,-0.426441,0.426200,-0.005123,-0.144586) * L3_2 + mat4(-0.155948,-0.249682,0.123317,0.313394,-0.015439,0.184404,-0.025018,-0.117309,0.397083,-0.770583,-0.014066,0.224598,0.170530,0.050821,-0.223520,0.033850) * L3_3 + mat4(0.166426,0.704929,-0.395041,-0.099187,-0.533998,0.492127,0.157798,-0.081836,-0.193563,0.047967,0.497757,0.174189,0.096307,0.109819,0.065432,-0.380038) * L3_4 + mat4(-0.043101,0.357905,0.283612,-0.031174,0.704993,-0.091297,-0.207294,0.855769,0.184001,0.192786,0.220794,-0.436588,-0.057099,0.207100,-0.073518,0.091328) * L3_5 + mat4(-0.127769,-0.132676,0.110887,0.066068,-0.061889,0.286529,-0.148724,0.122885,-0.103056,-0.055373,-0.163154,0.386671,-0.232992,0.231004,-0.211778,-0.234450) * L3_6 + mat4(-0.359575,-0.057728,-0.106198,-0.267576,-0.072011,0.170801,-0.071566,0.009867,0.176752,0.053296,0.124519,-0.650108,-0.239833,-0.382040,0.080412,0.113708) * L3_7 + mat4(-0.131408,0.094075,0.075532,0.123085,0.000520,0.015990,0.130603,-0.084048,0.007185,0.009045,0.024971,0.015300,-0.002216,-0.000466,0.016970,-0.015473) * L3_8 + mat4(0.101372,0.091301,-0.033716,0.004972,0.022712,0.027895,0.019756,-0.000948,0.024910,-0.002812,0.165364,0.002297,0.169180,0.002258,-0.044220,-0.037232) * L3_9 + mat4(-0.006141,-0.019590,0.004791,0.045211,0.105765,-0.055392,0.076221,-0.225882,0.101775,0.055075,0.044356,0.086421,-0.008412,0.031801,0.016562,-0.003324) * L3_10 + mat4(-0.000460,-0.021144,-0.075834,-0.057777,0.123856,-0.010011,0.018234,-0.024660,0.031548,0.052845,0.005208,-0.017553,-0.003244,-0.010273,0.001484,-0.029081) * L3_11 + mat4(-0.113475,-0.097533,-0.060445,-0.234884,0.354987,-0.028896,-0.275559,0.095198,-0.015355,0.061690,-0.458546,-0.036709,0.043783,0.047813,0.050988,-0.242405) * L3_12 + mat4(0.216448,0.059959,-0.004153,-0.336906,-0.045433,-0.050114,-0.214720,-0.139193,-0.103549,-0.033670,0.218101,0.144107,0.045985,-0.058644,-0.010093,0.200213) * L3_13 + mat4(-0.008418,0.015692,-0.012709,0.011803,-0.022761,0.146479,-0.010225,0.148952,-0.012098,-0.020563,-0.035744,0.111548,0.043738,-0.040200,0.008957,0.142052) * L3_14 + mat4(-0.026703,-0.026305,-0.082189,0.066827,0.076193,0.054313,0.250259,-0.019604,-0.041283,0.013612,0.045738,-0.000845,0.019899,-0.023681,0.022558,0.018222) * L3_15 + vec4(0.081112,-0.012914,0.310541,-0.275027)));\nvec4 L4_11 = sin((mat4(0.448422,-0.065377,-0.214326,-0.201927,-0.170919,-0.264325,0.089107,0.054632,0.120071,-0.241151,-0.139473,-0.060530,-0.249323,-0.234724,-0.189735,0.601600) * L3_0 + mat4(0.231724,-0.055402,-0.235601,-0.006368,-0.233033,0.105501,0.489545,0.497502,-0.537932,-0.038355,0.233412,0.277300,0.147089,-0.119909,0.011576,-0.253530) * L3_1 + mat4(0.031440,0.046393,0.096176,0.621517,-0.105992,0.199690,0.290681,0.004101,-0.056828,-0.441329,0.200068,0.221524,-0.433187,-0.046318,-0.054915,-0.047818) * L3_2 + mat4(0.112105,0.123617,-0.059845,-0.164167,-0.023789,0.035728,-0.217758,0.154876,0.075490,-0.248868,0.003631,0.776683,-0.031143,-0.243543,0.035215,-0.171179) * L3_3 + mat4(-0.247615,-0.250472,0.090368,0.037099,-0.274723,-0.308260,0.053617,0.368609,0.181227,0.407397,0.223432,-0.093032,0.484967,0.268935,-0.262323,-0.384540) * L3_4 + mat4(0.070997,-0.079893,0.258834,0.001361,-0.196862,0.085386,0.247433,0.258626,-0.195217,0.074665,-0.129918,0.103465,0.155104,-0.176635,-0.029514,0.119942) * L3_5 + mat4(0.143985,-0.278364,-0.333202,-0.038683,-0.147531,0.305465,0.742205,0.070821,-0.820042,0.224283,0.373407,0.126656,-0.333623,0.138514,0.138684,0.105596) * L3_6 + mat4(0.634353,0.006779,-0.773513,-0.306001,-0.110496,0.315995,-0.261239,-0.181881,0.203322,0.504851,0.149185,-0.089498,-0.137490,0.029832,0.264951,-0.398572) * L3_7 + mat4(0.219186,0.201332,-0.059928,0.338909,-0.237658,-0.139693,-0.360840,-0.143723,-0.012174,0.037591,-0.034707,-0.001070,-0.003866,-0.033089,0.019754,-0.006756) * L3_8 + mat4(0.095867,0.128763,-0.011989,0.071063,0.009441,-0.014718,-0.006978,0.009795,0.002302,-0.052892,-0.019875,-0.044122,-0.049381,0.031923,0.089434,0.244855) * L3_9 + mat4(-0.055636,-0.049712,0.027923,0.080190,0.145371,0.711673,-0.143490,-0.252769,-0.101575,-0.166498,0.047675,0.015698,0.015579,0.007597,-0.002319,0.004285) * L3_10 + mat4(-0.146246,-0.029732,-0.016824,0.143123,0.203281,0.103830,-0.059019,-0.082505,0.035359,0.016461,-0.037632,0.037781,0.023175,-0.009068,0.006453,-0.001391) * L3_11 + mat4(0.346212,0.312543,-0.098580,0.091634,0.064944,-0.061370,0.132445,0.692984,0.084901,0.047491,-0.010919,-0.073186,-0.157135,0.036918,0.153793,-0.076886) * L3_12 + mat4(0.248995,-0.105733,0.226509,-0.229734,0.061669,0.099816,-0.032670,-0.003794,0.271680,-0.258476,0.065747,-0.030635,0.099497,0.011771,-0.027783,0.125243) * L3_13 + mat4(0.023474,-0.020389,-0.014295,-0.040604,-0.503466,0.192975,0.308900,0.035904,-0.087765,-0.110139,-0.022441,0.042564,-0.080327,-0.083861,0.044666,0.099794) * L3_14 + mat4(0.213198,0.118951,0.316036,0.173270,-0.031447,-0.059847,-0.042771,0.003122,-0.016020,0.002573,-0.005493,-0.120440,0.003557,0.016211,-0.019199,0.003452) * L3_15 + vec4(-0.164742,-0.748327,-1.072984,-0.512655)));\nvec4 L4_12 = sin((mat4(0.249447,-0.165512,0.206101,-0.153084,-0.157367,-0.143563,-0.346501,-0.454566,0.078322,-0.050318,0.026601,0.331934,0.288248,0.260131,-0.233041,0.217886) * L3_0 + mat4(-0.201080,0.062700,0.162666,-0.152992,0.388681,0.319239,0.004302,-0.095518,-0.010292,-0.234281,-0.015976,-0.424067,-0.154026,0.118114,0.180388,0.495191) * L3_1 + mat4(-0.012178,0.255386,-0.083484,0.113949,0.116175,-0.135475,0.120256,0.039143,0.319073,0.010884,0.002712,0.023313,0.038962,0.435168,-0.379654,-0.214485) * L3_2 + mat4(0.442745,-0.084158,0.060245,-0.015144,0.054408,-0.372322,-0.108953,0.076116,-0.310645,0.092420,-0.113255,0.291054,0.332875,0.123738,-0.066859,-0.092020) * L3_3 + mat4(-0.420530,0.199220,0.282824,0.218350,-0.165419,0.026409,0.015871,0.228641,-0.186743,-0.243023,-0.106704,-0.106796,-0.163830,-0.059132,-0.193639,-0.212503) * L3_4 + mat4(0.141786,0.037485,0.284478,0.293117,-0.463676,-0.120038,-0.210898,-0.301733,-0.032055,0.024973,-0.227111,-0.188640,0.026667,-0.378339,0.172873,-0.166553) * L3_5 + mat4(0.298431,-0.243982,-0.034064,-0.306926,0.135751,0.207954,-0.275553,-0.144984,-0.955097,0.324515,-0.748007,-0.100303,-0.230064,0.130248,-0.245071,0.046966) * L3_6 + mat4(0.282916,0.311511,0.172282,-0.140161,-0.351681,0.129513,-0.018112,-0.397765,0.457956,-0.032866,-0.016263,0.200347,0.385895,0.211501,0.076292,-0.425637) * L3_7 + mat4(-0.000723,-0.029194,-0.167436,-0.089686,0.474488,-0.053478,0.086575,-0.172333,0.001667,0.020626,-0.001162,0.045613,0.005630,-0.000882,0.021851,0.052950) * L3_8 + mat4(-0.098911,-0.008285,-0.106465,0.061176,0.023168,0.001980,0.008488,-0.027362,0.118499,-0.003909,0.009812,0.047523,-0.052210,0.015918,0.032376,0.166534) * L3_9 + mat4(0.001435,-0.010496,0.030086,0.058083,0.006150,0.016297,-0.632457,0.119940,-0.027506,-0.004105,0.260540,0.011154,0.008011,0.011711,-0.001526,0.014990) * L3_10 + mat4(0.039231,0.013863,0.238972,0.228650,0.034488,0.038928,-0.081066,0.038517,0.071407,0.013988,-0.001110,-0.006594,-0.030332,0.003908,-0.007821,-0.020794) * L3_11 + mat4(-0.020972,-0.048554,-0.426271,-0.313632,0.037100,-0.117660,-0.023292,0.073877,-0.107404,0.016847,0.131025,-0.053059,0.030376,0.008288,0.032986,-0.294657) * L3_12 + mat4(0.174258,0.078443,-0.700607,0.451829,-0.058455,-0.066241,0.022993,-0.042517,-0.077709,0.006051,-0.449916,-0.596127,0.038726,-0.001154,-0.059443,0.133800) * L3_13 + mat4(0.020582,0.011485,0.011213,0.017296,-0.339345,0.088698,0.892581,-0.117247,0.050057,0.006348,0.150489,0.107193,-0.011767,0.005380,0.021093,0.037513) * L3_14 + mat4(-0.424816,0.026229,-0.100605,0.160825,0.102424,-0.074989,0.020364,0.048341,-0.019794,0.030771,0.017601,-0.034192,0.014549,0.007583,-0.015836,0.020601) * L3_15 + vec4(0.552057,-0.128613,0.352152,-0.628208)));\nvec4 L4_13 = sin((mat4(0.032419,0.332190,-0.181038,0.189144,0.184267,0.361331,-0.257074,0.281607,0.181026,0.046626,0.169213,-0.020863,0.252398,-0.338018,0.114224,0.068530) * L3_0 + mat4(0.045707,0.666856,-0.062391,0.111766,0.100883,-0.414556,0.059371,-0.390731,-0.110621,-0.507478,0.239422,0.388008,0.042339,-0.074211,-0.134910,-0.170755) * L3_1 + mat4(0.322020,0.138484,-0.073072,0.001683,-0.196350,-0.009988,-0.043465,-0.079378,0.184528,0.016320,-0.212489,0.176051,0.141984,-0.271339,0.468385,-0.143153) * L3_2 + mat4(-0.363743,0.261117,0.193987,-0.035755,-0.169574,-0.144080,-0.008479,0.341378,0.397639,-0.248868,0.606434,-0.270810,0.132642,-0.123515,0.080568,0.163794) * L3_3 + mat4(-0.122859,-0.761014,-0.179152,0.260275,0.123627,-0.271253,-0.104847,-0.319873,-0.515486,0.261348,-0.082872,0.009992,0.189514,-0.137639,0.029783,0.100528) * L3_4 + mat4(-0.007202,0.044325,-0.390700,-0.028890,-0.303897,-0.150988,0.576056,-0.007525,0.624985,-0.343382,0.089175,0.219676,-0.342831,-0.132379,-0.536611,0.435142) * L3_5 + mat4(-0.416844,-0.143309,-0.006422,-0.094249,0.126251,0.171349,-0.026375,-0.366005,0.199639,-0.064593,-0.274179,-0.445921,-0.130747,-0.448080,0.035757,-0.003476) * L3_6 + mat4(-0.709209,-0.165965,0.067017,0.583370,0.128544,-0.016734,-0.102670,-0.558131,0.031918,0.056918,0.120886,0.359364,0.239398,0.371407,-0.158703,0.429659) * L3_7 + mat4(-0.089237,-0.017872,0.329274,0.080405,0.197189,0.196859,0.176130,0.272622,0.005601,-0.013260,0.028898,0.010929,0.023873,0.000167,-0.030243,0.018433) * L3_8 + mat4(-0.013386,0.067353,0.120321,0.083539,0.013294,-0.004475,0.029009,0.005089,-0.094933,-0.035679,-0.120021,0.007302,0.002088,0.081802,-0.047856,0.022733) * L3_9 + mat4(-0.009608,0.017741,0.012174,-0.067687,0.104765,0.165236,0.053028,0.249722,-0.040254,-0.054188,-0.148562,-0.105851,-0.023492,0.022140,-0.028577,0.006646) * L3_10 + mat4(0.006965,0.053283,-0.090646,-0.004888,0.021884,0.097211,-0.098127,0.015622,0.015585,-0.011278,0.050861,0.007824,0.014644,0.001540,0.015923,-0.021828) * L3_11 + mat4(0.096375,0.054527,0.322396,0.092801,-0.163119,0.127336,0.092539,0.021743,0.135002,0.017535,0.064508,-0.084204,0.165031,-0.106025,-0.003430,0.075537) * L3_12 + mat4(-0.001625,-0.006591,-0.454937,0.018880,0.092110,-0.006211,-0.373379,0.031366,0.138500,-0.204815,0.110193,-0.199170,-0.140268,0.063082,-0.023236,0.051045) * L3_13 + mat4(-0.014545,-0.003166,0.006455,0.026902,0.122909,0.079212,0.459177,0.134702,-0.033283,0.023952,-0.069075,0.056937,-0.054503,-0.004339,-0.086431,-0.016384) * L3_14 + mat4(-0.151466,-0.127991,-0.181796,-0.231174,-0.011184,-0.075515,-0.118653,0.036701,0.032715,-0.009583,0.010141,-0.027103,-0.024936,0.006929,0.002586,0.006071) * L3_15 + vec4(0.668657,0.274714,0.372960,0.635158)));\nvec4 L4_14 = sin((mat4(-0.128012,-0.251696,-0.158815,0.132751,0.116742,-0.113996,0.161841,-0.197430,0.051655,0.239646,0.003882,-0.099888,-0.087761,0.168808,0.277573,0.217954) * L3_0 + mat4(0.136580,-0.601140,-0.401845,0.068903,-0.075608,0.372828,0.323705,-0.085228,0.012851,-0.063931,0.301271,0.002517,-0.303753,-0.059703,0.082185,-0.457577) * L3_1 + mat4(-0.079141,-0.363362,-0.139629,0.067509,-0.051504,-0.393580,-0.107461,-0.005576,0.186349,-0.268593,0.068149,0.081362,-0.277219,0.334572,0.274110,0.299989) * L3_2 + mat4(-0.067911,-0.470717,-0.198179,0.203799,-0.013507,-0.376084,-0.011072,-0.093552,-0.035659,-0.122833,-0.204481,-0.176003,-0.183448,0.143510,-0.020081,0.253784) * L3_3 + mat4(-0.147343,-0.116185,0.267991,0.064892,-0.272359,0.092378,-0.138292,0.002527,0.409830,0.182497,-0.592903,-0.138075,-0.039822,0.122355,0.081093,0.476795) * L3_4 + mat4(-0.114975,-0.202225,0.041779,-0.005366,-0.141215,-0.638537,0.470822,-0.394557,-0.023318,0.093110,0.083776,-0.354684,-0.123934,-0.250408,-0.268434,-0.060045) * L3_5 + mat4(-0.263018,0.389707,-0.371620,0.068037,0.063801,0.093240,0.065762,-0.303215,0.346180,0.202099,0.290235,0.143112,0.211347,0.070231,0.118217,-0.249703) * L3_6 + mat4(-0.063976,-0.535547,-0.056120,-0.159197,0.079047,-0.068112,0.002549,0.031020,-0.111579,0.154511,-0.178332,-0.071454,0.081280,0.247607,0.174289,0.245037) * L3_7 + mat4(-0.144112,0.111606,-0.044210,0.075814,-0.119723,0.144068,-0.041240,-0.098301,0.005374,-0.011678,0.011420,-0.027879,-0.017453,0.008468,0.005424,-0.018165) * L3_8 + mat4(-0.036592,-0.011617,-0.000373,-0.019328,-0.004541,0.008650,0.004727,-0.034501,-0.143824,-0.008241,0.013421,0.061884,0.079125,-0.081555,-0.028010,0.052887) * L3_9 + mat4(-0.007966,0.008737,-0.033769,-0.003296,-0.043146,-0.120768,-0.136004,-0.157074,0.022944,-0.017116,0.033158,-0.043918,0.009470,0.005728,-0.010555,-0.001832) * L3_10 + mat4(0.050544,0.018337,-0.051268,-0.017468,-0.022325,0.062690,0.155910,0.007502,-0.026569,0.018124,0.032606,-0.046762,0.015934,-0.015873,0.009461,0.020341) * L3_11 + mat4(0.088287,0.010983,0.422478,0.030184,0.673605,0.151711,-0.034444,-0.059247,-0.046052,-0.145418,0.074911,-0.216737,-0.007181,-0.102674,0.070978,-0.100356) * L3_12 + mat4(-0.199641,-0.014024,0.448809,0.008752,-0.163675,-0.025505,0.171554,-0.035257,0.108748,0.002476,-0.046826,-0.085959,-0.006268,0.043561,0.066311,0.060736) * L3_13 + mat4(-0.003748,-0.001379,0.002748,-0.000273,0.092019,-0.106368,0.052771,-0.307309,-0.024000,0.035312,-0.111775,0.027862,-0.026094,0.022620,-0.039195,0.009917) * L3_14 + mat4(0.065578,-0.112841,0.008496,0.112451,-0.019851,0.025990,0.080163,-0.060730,-0.080564,-0.026687,0.011184,-0.005868,0.003690,0.018040,-0.009854,-0.000819) * L3_15 + vec4(-0.155731,0.300218,0.163008,-0.241533)));\nvec4 L4_15 = sin((mat4(-0.043571,0.013975,0.078468,0.012879,0.348283,0.353901,-0.060659,-0.148090,-0.054233,-0.377412,-0.036206,0.502125,-0.346886,0.035355,0.075267,-0.425153) * L3_0 + mat4(0.289391,-0.702490,-0.167078,-0.368642,0.042038,-0.270928,-0.112419,0.486353,-0.140422,0.072269,0.223323,0.242084,0.200409,-0.227261,-0.169906,0.606168) * L3_1 + mat4(-0.186179,0.167372,-0.143704,-0.007369,0.141582,0.207717,-0.203080,-0.059522,-0.219475,-0.170741,-0.281798,0.053021,0.049533,0.060975,0.002448,0.425934) * L3_2 + mat4(0.191098,-0.036052,0.229423,-0.404975,0.011558,-0.052612,-0.085332,-0.106533,0.067062,0.082163,0.157110,-0.000122,0.017071,0.031179,-0.041312,-0.349490) * L3_3 + mat4(0.020687,0.102491,0.476356,0.471530,-0.220539,-0.136031,0.369838,0.467458,0.246372,-0.145760,0.013111,-0.417042,0.079360,-0.292019,0.079070,0.231804) * L3_4 + mat4(0.060049,0.386335,0.084454,0.163934,0.298504,0.958915,-0.391025,-0.012476,0.239276,0.177509,0.038697,0.040178,-0.003875,0.030854,-0.263625,-0.215922) * L3_5 + mat4(0.278467,-0.495542,-0.018119,0.633382,0.101162,-0.012836,0.027393,-0.270244,0.312450,-0.541039,-0.052887,0.600742,-0.057534,-0.113130,-0.139928,0.117664) * L3_6 + mat4(-0.035551,0.301912,0.217938,-0.111315,0.052465,0.226599,0.162779,-0.557471,0.096449,-0.141283,0.032059,0.246368,-0.171875,0.042586,0.013693,0.047403) * L3_7 + mat4(-0.093006,-0.042683,-0.159860,-0.382312,0.033173,-0.225791,0.064442,-0.211088,0.020554,-0.003865,-0.016216,0.014088,0.011790,0.010844,-0.012726,-0.028492) * L3_8 + mat4(-0.068597,-0.049044,-0.139650,-0.120615,-0.013464,0.026177,0.014585,0.006434,-0.096060,0.075319,0.060594,0.031329,0.042782,0.029038,0.011768,-0.150092) * L3_9 + mat4(0.016403,-0.090654,-0.000014,-0.067349,0.031184,-0.031532,-0.032164,0.121535,-0.011069,-0.016755,-0.051454,0.011632,0.002079,0.010645,-0.015686,0.029104) * L3_10 + mat4(0.073800,0.047681,0.094365,-0.149805,0.070792,-0.144329,-0.340808,0.007337,-0.000294,0.034976,0.015976,0.000092,-0.006992,0.005840,-0.016438,0.031921) * L3_11 + mat4(-0.030152,-0.144138,-0.580978,0.188755,0.501722,0.157966,-0.101156,0.013174,-0.138360,0.019573,0.153672,-0.010758,0.079233,0.158584,0.376676,0.117453) * L3_12 + mat4(0.382221,0.094298,-0.365653,0.126748,-0.072224,-0.198307,-0.035141,-0.134415,-0.074282,-0.177853,-0.108198,0.361211,-0.102069,-0.102331,-0.246195,0.000389) * L3_13 + mat4(0.001411,0.010130,0.006719,-0.011780,-0.159952,0.300197,0.120574,-0.102955,-0.002547,-0.009409,0.007056,-0.047242,0.000296,0.023297,0.004596,0.001617) * L3_14 + mat4(0.006848,0.198674,-0.044756,0.168655,-0.042061,-0.038163,0.028506,0.023493,-0.082464,-0.035906,0.005554,-0.024464,-0.002508,0.004815,-0.022948,0.005733) * L3_15 + vec4(0.276326,-0.560050,0.695667,-0.387805)));\nvec4 L5_0 = sin((mat4(-0.018449,0.147474,-0.460990,0.042317,-0.118675,0.211031,-0.070496,0.356044,-0.145347,-0.162159,0.171983,-0.519200,-0.189975,0.254926,0.030611,0.080878) * L4_0 + mat4(0.194396,-0.234473,0.278385,-0.307391,0.066925,0.039375,0.383263,0.266153,-0.018806,-0.066333,0.045315,-0.015352,0.090415,0.004951,0.069152,-0.123878) * L4_1 + mat4(-0.251181,0.215072,-0.094445,0.435032,-0.128873,0.167238,-0.209580,0.153542,0.205575,-0.668595,-0.004716,-0.192813,0.217392,0.141440,-0.116615,0.302265) * L4_2 + mat4(0.551283,0.219849,-0.090402,-0.173095,-0.229017,-0.068567,-0.187015,-0.011096,-0.113406,0.194870,0.067696,0.070750,-0.026248,-0.412582,0.204814,-0.186152) * L4_3 + mat4(0.116519,0.151985,-0.129427,-0.258285,-0.141900,0.031213,-0.077249,0.232453,-0.654685,-0.811882,-0.160011,0.507513,-0.137655,0.018446,0.529226,-0.001244) * L4_4 + mat4(0.378505,0.298349,-0.050842,0.067548,0.353273,-0.552079,0.050402,0.453808,-0.174013,-0.277050,-0.107116,-0.030071,0.224614,0.095540,-0.078037,-0.045319) * L4_5 + mat4(-0.042197,-0.057229,-0.068173,-0.428225,0.240930,0.020223,0.224932,0.032896,-0.077164,-0.213034,0.189890,-0.095766,0.204142,0.308076,-0.170739,-0.188841) * L4_6 + mat4(0.061311,0.170179,-0.488783,-0.148180,0.393484,0.064268,-0.664369,-0.306906,-0.123312,-0.261346,-0.179519,-0.034320,0.092464,-0.252590,-0.020548,-0.133604) * L4_7 + mat4(0.212666,0.104056,-0.169216,-0.161061,0.149640,-0.288449,0.223946,0.103190,-0.063607,0.352686,-0.069988,0.032162,0.158104,-0.035225,0.070381,0.020342) * L4_8 + mat4(0.084662,-0.184296,-0.142085,-0.207282,0.583625,-0.062124,0.174518,0.422366,0.419876,0.420222,-0.154172,-0.477835,-0.163522,0.303583,-0.095651,-0.140446) * L4_9 + mat4(0.208209,-0.150778,0.225343,-0.102215,0.042636,-0.071134,0.100312,-0.267862,0.091623,0.232760,0.086119,0.049402,0.021812,-0.057906,0.056990,0.207082) * L4_10 + mat4(-0.030647,0.085868,0.030748,0.261884,-0.081508,0.185259,-0.024964,0.071271,-0.050657,0.120849,0.110816,0.483035,-0.058875,0.079447,0.048528,-0.040407) * L4_11 + mat4(-0.191973,0.445474,-0.079265,-0.036043,0.099359,-0.015399,-0.396474,0.419691,-0.064173,-0.041292,0.067254,0.157298,-0.014216,-0.041615,-0.079923,-0.140205) * L4_12 + mat4(-0.383536,0.172407,0.051126,0.253993,-0.026529,0.237156,-0.034765,0.148114,0.144532,-0.059560,-0.034646,0.442026,-0.382993,-0.373863,0.187461,0.067366) * L4_13 + mat4(-0.368152,0.080350,-0.022246,-0.040757,0.020955,-0.163616,0.128873,-0.103701,0.076446,0.020924,-0.111503,-0.043412,-0.104549,-0.007144,0.299921,-0.437007) * L4_14 + mat4(-0.091546,0.010917,0.421838,0.058106,0.064392,0.374051,-0.054967,-0.224326,-0.117209,0.120822,-0.248396,-0.055219,-0.210843,-0.255586,0.054346,-0.103456) * L4_15 + vec4(0.207913,-0.366291,0.040479,0.067036)));\nvec4 L5_1 = sin((mat4(0.108457,-0.222025,-0.143037,0.137529,-0.005232,-0.040708,-0.160732,0.249522,-0.125019,-0.023776,0.486727,0.404645,0.037731,0.171912,0.289436,-0.150712) * L4_0 + mat4(-0.129235,-0.032178,-0.080838,0.187080,-0.145947,-0.195926,-0.109294,-0.016544,0.177437,0.055294,0.073567,0.146723,0.022179,0.029721,0.274968,-0.187010) * L4_1 + mat4(-0.223916,-0.320990,-0.244135,-0.203926,-0.177449,-0.136652,-0.125731,0.234640,0.090541,-0.131005,-0.162254,-0.108654,-0.036428,0.007864,-0.283897,0.015809) * L4_2 + mat4(-0.135072,0.143204,0.074845,0.142334,-0.124907,-0.185513,0.126817,0.134101,0.049150,-0.021063,0.233237,-0.035668,0.023711,0.210148,0.656951,-0.355068) * L4_3 + mat4(-0.201821,-0.048653,-0.046040,0.028326,-0.194099,0.149418,0.187527,-0.272700,-0.010832,0.163749,0.145378,-0.062606,0.021482,0.097333,0.036858,0.052257) * L4_4 + mat4(-0.109551,-0.373949,-0.473676,0.115878,0.344637,0.461360,0.132613,0.527192,0.012904,0.203205,-0.249202,0.057324,-0.264927,0.111106,-0.109445,-0.089217) * L4_5 + mat4(0.035237,0.046984,-0.121248,-0.113812,0.123357,0.039604,0.075971,-0.254585,-0.202505,-0.294308,0.161181,0.166616,-0.108717,-0.202178,0.127577,0.365989) * L4_6 + mat4(0.128389,0.032997,0.176716,-0.023924,-0.354070,0.138141,0.027997,-0.322510,0.110486,-0.108614,0.128254,0.284771,-0.110309,0.331862,0.109785,0.176236) * L4_7 + mat4(-0.095689,-0.087207,-0.095213,-0.232885,0.218349,-0.378736,0.052804,0.152831,-0.013125,0.079267,0.365493,0.042201,-0.032114,0.013384,-0.046935,0.121051) * L4_8 + mat4(0.194993,-0.098513,0.366264,0.048097,-0.171372,0.209624,-0.821349,0.520438,0.062593,0.152954,-0.583681,-0.351098,0.201742,-0.168337,0.615002,0.128494) * L4_9 + mat4(-0.080601,0.041822,0.220882,-0.119626,-0.126115,-0.048211,-0.333412,0.068805,0.040736,0.345820,-0.027495,-0.102029,-0.104263,-0.056833,-0.025714,0.043355) * L4_10 + mat4(0.113713,0.095597,0.187602,-0.197396,-0.045127,-0.248166,-0.055323,-0.077371,0.149115,-0.181229,-0.436250,-0.170401,-0.003385,-0.054291,-0.223993,0.110695) * L4_11 + mat4(0.009666,0.042137,-0.246559,0.142817,-0.350767,-0.340208,-0.390130,-0.283482,0.064652,0.087996,0.022657,-0.059203,-0.068953,-0.014654,0.287913,-0.078492) * L4_12 + mat4(0.055273,-0.139270,-0.002446,0.034571,0.207562,-0.126704,0.258582,-0.084226,0.028890,0.214941,0.064736,-0.036363,0.090792,0.191254,-0.210571,-0.072065) * L4_13 + mat4(0.059140,0.335803,-0.002607,0.008475,0.031911,-0.111996,-0.155943,0.070943,0.039170,-0.102770,-0.051822,0.217872,0.274542,-0.010753,0.435648,-0.207771) * L4_14 + mat4(-0.166949,0.266127,-0.282335,0.001403,0.055712,0.188332,-0.458359,-0.088703,-0.148015,-0.266186,-0.028916,0.260290,0.111516,-0.051806,0.068174,-0.014291) * L4_15 + vec4(0.550455,0.151353,0.509236,0.806846)));\nvec4 L5_2 = sin((mat4(-0.485386,-0.053765,-0.165151,-0.193564,0.036728,-0.007423,0.170802,-0.028280,0.070308,0.064036,-0.283235,-0.110053,0.229356,0.148026,-0.183803,-0.126006) * L4_0 + mat4(-0.343933,-0.147824,-0.215765,-0.048206,0.555862,0.089531,0.029995,0.069199,-0.128581,0.027608,-0.519615,0.016475,-0.245563,0.141632,-0.206390,0.152641) * L4_1 + mat4(1.190876,-0.360196,0.425942,-0.360141,0.047378,-0.034142,0.216990,0.190519,-0.091504,0.023228,-0.186286,-0.028245,0.254360,-0.155328,-0.102886,-0.045801) * L4_2 + mat4(0.306715,-0.082195,0.000590,0.178549,-0.135702,0.073539,-0.009735,-0.091030,0.046508,0.123249,-0.075087,-0.145012,0.187119,0.097140,-0.110900,0.452976) * L4_3 + mat4(-0.270325,0.080052,0.053401,0.052915,-0.876041,-0.072855,-0.169408,0.216148,-0.633536,-0.201682,-0.402398,0.024577,0.288195,0.065927,-0.018148,-0.182396) * L4_4 + mat4(-0.003528,-0.074180,-0.232526,0.000426,-0.930539,0.640412,-0.458331,-0.219562,0.075655,-0.339663,0.021491,-0.217274,-0.126230,-0.167040,0.209974,-0.063170) * L4_5 + mat4(0.086258,-0.170106,-0.070210,0.177433,0.158393,0.184092,0.081372,-0.042081,-0.059923,0.171335,-0.403213,0.348060,0.396698,-0.071696,-0.115692,-0.164634) * L4_6 + mat4(-0.681783,0.069728,-0.197577,-0.374965,-0.094829,0.003461,-0.125125,0.637211,0.259933,-0.032060,-0.150948,-0.190979,0.399739,-0.044463,0.020304,-0.045580) * L4_7 + mat4(-0.323667,0.098621,-0.080580,-0.089885,-0.081375,0.040784,-0.281675,-0.209681,0.195710,0.081127,0.109646,-0.017980,-0.117927,-0.061782,0.116377,0.022956) * L4_8 + mat4(0.054412,0.032241,-0.037225,-0.030908,0.124529,-0.180895,-0.117387,-0.166718,0.582391,0.358252,-0.295376,0.446868,0.202259,0.002929,-0.013265,-0.552275) * L4_9 + mat4(-0.428799,0.078423,-0.216941,0.072784,-0.119962,-0.000893,0.201922,0.229727,0.202361,-0.068324,0.065230,-0.326870,0.025830,0.128588,-0.182331,-0.172493) * L4_10 + mat4(0.087286,0.149336,-0.162180,-0.001485,0.085391,-0.016213,-0.122949,-0.003811,0.445025,0.088989,0.313550,0.000766,-0.013149,-0.165237,0.021798,0.192990) * L4_11 + mat4(0.224112,0.173818,-0.047477,0.302067,-0.588841,-0.079891,0.178000,-0.064152,0.309857,0.166472,0.044283,-0.108233,-0.101802,0.161171,0.105051,0.027223) * L4_12 + mat4(-0.152566,-0.160680,-0.205526,-0.162924,-0.161328,0.165478,-0.235395,-0.316364,0.228033,0.108229,-0.097551,0.018296,0.197083,-0.073455,0.083566,0.106686) * L4_13 + mat4(-0.338648,-0.109108,-0.083163,-0.193757,-0.467306,0.025740,-0.035371,-0.162688,-0.282674,-0.010429,-0.057726,-0.247746,0.400817,-0.128172,0.198905,-0.259169) * L4_14 + mat4(0.597888,0.032144,0.147065,-0.095470,0.057221,0.278230,-0.090204,-0.036922,-0.170046,-0.303230,0.116563,0.212996,0.113605,0.124450,0.020141,0.169388) * L4_15 + vec4(0.665045,0.426892,0.441660,-0.793612)));\nvec4 L5_3 = sin((mat4(-0.272372,-0.105341,0.251229,0.407495,-0.011554,-0.012746,-0.125493,0.139498,0.082337,0.192203,-0.084132,-0.349481,-0.067762,-0.096612,0.137615,-0.128557) * L4_0 + mat4(-0.069393,0.223512,-0.282588,0.159580,0.177869,-0.096355,0.101225,-0.279330,0.060937,-0.156666,-0.279611,0.111594,0.141167,-0.022694,-0.010273,-0.046848) * L4_1 + mat4(-0.491823,0.081817,0.417511,0.286151,0.047310,-0.153749,-0.240586,-0.156454,-0.212813,0.207981,-0.231408,0.327271,-0.265892,-0.119881,0.131333,0.309010) * L4_2 + mat4(-0.032856,0.030952,0.377147,0.046819,-0.187974,0.062965,0.217358,-0.014296,0.023627,0.056585,-0.219240,0.006753,0.387726,0.443024,-0.294413,0.356224) * L4_3 + mat4(0.003636,-0.105808,0.070816,-0.062236,0.197705,0.371825,-0.296555,-0.211080,0.299885,0.451742,0.770723,-0.063424,-0.043042,0.044320,-0.721612,-0.242423) * L4_4 + mat4(-0.098788,-0.317201,0.259565,-0.120775,0.284631,-0.195505,-0.312658,-0.342099,-0.183674,0.245322,-0.071403,0.113216,0.014578,-0.201395,-0.421997,0.004276) * L4_5 + mat4(0.513450,0.094822,-0.519705,0.164110,0.023023,-0.131861,0.187675,0.082673,0.269761,-0.315132,-0.086703,-0.058118,0.221331,0.000630,0.273777,-0.248242) * L4_6 + mat4(-0.106919,-0.064876,-0.089035,0.187050,-0.372661,0.023790,0.832651,0.012074,-0.222135,0.096830,-0.056598,0.084484,-0.228781,-0.242257,0.414748,-0.227858) * L4_7 + mat4(-0.285153,0.051724,-0.119300,0.180146,0.111285,0.045799,-0.163288,0.091096,0.137287,0.146070,0.130680,-0.168307,-0.100205,-0.050495,-0.145668,-0.095131) * L4_8 + mat4(0.415821,0.156455,0.369524,0.021781,-0.244796,-0.227107,-0.555012,0.309867,0.136499,0.171476,0.485695,-0.176643,0.143826,-0.128054,-0.472362,-0.120448) * L4_9 + mat4(-0.119462,0.152012,0.068454,0.225759,0.400987,-0.076914,-0.524945,0.386576,0.088284,-0.199452,-0.043444,-0.099388,-0.027811,-0.077248,0.295183,0.132672) * L4_10 + mat4(-0.180816,0.017357,0.340273,0.001722,0.116621,-0.057770,0.152036,0.091689,-0.045675,-0.066455,0.051374,0.073330,-0.085110,0.030118,-0.128015,-0.040003) * L4_11 + mat4(0.220575,-0.203394,-0.210707,0.054644,0.071531,-0.236060,0.270614,-0.100813,-0.011490,0.011562,0.107064,0.004054,0.059237,-0.093796,0.294301,-0.141118) * L4_12 + mat4(0.118132,-0.453071,0.063554,-0.144598,-0.235596,0.029730,0.388416,0.418470,0.252925,-0.189663,0.197855,-0.213288,-0.176691,0.309228,-0.453237,-0.131107) * L4_13 + mat4(-0.055720,0.025200,-0.021388,0.009371,-0.279544,0.118269,0.524927,0.167762,-0.076767,-0.153725,0.106398,-0.026983,0.034584,-0.099925,0.240033,0.277007) * L4_14 + mat4(0.080738,0.144087,-0.042465,0.306321,0.193000,0.016895,-0.428116,0.427256,-0.049414,-0.021983,-0.095518,0.007752,0.099677,0.064562,0.177634,0.232454) * L4_15 + vec4(-0.652506,0.329714,0.143263,0.467181)));\nvec4 L5_4 = sin((mat4(0.127806,-0.232229,0.033420,0.033266,-0.202867,0.147336,-0.107864,-0.028995,-0.314109,-0.303465,0.097042,0.268508,0.020660,-0.127115,-0.044517,-0.030146) * L4_0 + mat4(-0.104561,-0.290898,0.070537,-0.302267,0.071122,0.017738,0.400840,-0.326483,-0.092918,-0.136910,0.226115,-0.046894,0.092339,0.148180,-0.048516,0.087105) * L4_1 + mat4(-0.538943,0.125407,-0.230743,0.042154,-0.278098,-0.233950,0.056461,-0.034795,0.254977,-0.067532,0.193435,-0.083038,-0.021870,-0.068323,-0.075855,0.423194) * L4_2 + mat4(0.035787,0.099465,-0.251938,-0.263617,0.065170,-0.288219,0.055058,0.147627,0.070815,0.012881,0.048115,0.117173,-0.331546,0.032040,0.018085,-0.247715) * L4_3 + mat4(0.073608,-0.230254,0.090162,0.130464,0.332048,-0.035585,-0.114084,-0.419092,-0.283832,0.157930,-0.003213,-1.027502,0.181507,0.021500,0.129337,-0.215820) * L4_4 + mat4(-0.190479,-0.017827,0.190300,-0.357046,0.189348,-0.207896,0.179253,-0.907449,0.164888,-0.063809,0.103520,-0.106266,-0.127091,-0.224719,0.144378,0.112730) * L4_5 + mat4(0.202356,0.594334,-0.115830,0.205913,-0.268712,0.197580,-0.066112,0.120456,-0.055883,-0.324993,0.075785,-0.086570,-0.154284,0.398232,-0.481313,0.143501) * L4_6 + mat4(0.479774,-0.433740,0.181244,0.139458,0.188853,0.084557,-0.666019,0.344659,-0.034733,-0.190154,-0.084285,-0.029574,-0.142347,0.004531,-0.146368,0.214901) * L4_7 + mat4(0.287414,-0.282289,0.076461,-0.443562,-0.094915,0.322086,0.103031,-0.078162,-0.518097,0.076521,0.035119,-0.120020,0.055490,-0.184548,0.058932,-0.246451) * L4_8 + mat4(-0.112367,0.166209,0.100992,0.163658,0.343836,0.093928,0.174352,-0.063672,0.074768,0.770359,-0.249325,0.019780,0.098573,-0.125979,-0.196821,-0.063232) * L4_9 + mat4(-0.110520,-0.259389,0.149866,0.101993,0.337835,-0.292940,0.491805,-0.116609,0.080426,0.019520,-0.110899,-0.172509,-0.208426,-0.335957,0.034054,-0.132693) * L4_10 + mat4(0.113054,0.035803,-0.044386,-0.027307,0.080882,0.137374,0.174315,-0.319763,0.211749,0.267797,-0.116329,0.622799,-0.056196,-0.107862,0.018744,-0.027151) * L4_11 + mat4(0.340484,0.054690,-0.308370,0.150752,1.026148,0.067537,-0.122427,0.368140,-0.029799,-0.021784,0.076774,0.122978,0.020723,0.008850,0.208733,0.170292) * L4_12 + mat4(0.156760,-0.291142,-0.258493,0.171440,0.058017,-0.070362,-0.249827,-0.214244,0.267516,0.337563,-0.068649,0.055176,-0.400998,-0.097670,0.113992,0.300596) * L4_13 + mat4(0.382473,0.149257,-0.183868,-0.033068,-0.071403,0.067125,-0.212548,-0.512713,0.032847,-0.321751,0.004400,-0.288252,0.043072,-0.133168,0.117812,0.029479) * L4_14 + mat4(-0.001887,-0.137861,0.080249,-0.352098,0.035477,-0.209235,0.121118,-0.196060,-0.007108,-0.078878,0.007761,0.060869,-0.141585,0.330562,0.143668,0.115020) * L4_15 + vec4(-0.753576,-1.052040,0.614714,-0.176978)));\nvec4 L5_5 = sin((mat4(-0.011305,0.105951,0.384925,-0.045629,0.188365,0.056670,0.072374,0.338064,0.030847,0.125358,0.345551,0.202312,0.062573,-0.140970,-0.155597,0.367268) * L4_0 + mat4(-0.062040,-0.092960,-0.014997,0.083369,-0.086234,0.166006,-0.098759,-0.056090,0.125298,0.169495,-0.458573,0.092821,-0.132853,0.082071,-0.143188,0.120934) * L4_1 + mat4(-0.241901,-0.573671,-0.089632,0.808268,0.051675,0.208334,0.153883,0.230631,0.181814,0.137660,-0.273488,-0.434193,-0.056530,0.150712,0.093198,-0.093049) * L4_2 + mat4(0.107650,-0.275189,0.035116,-0.027828,-0.063540,-0.058062,0.195908,0.010293,0.064847,-0.091607,-0.190613,0.126692,0.322244,0.141658,-0.113749,-0.112672) * L4_3 + mat4(0.023660,0.133054,0.051886,0.073207,0.117365,0.088554,-0.127845,-0.082290,0.637283,0.123590,-0.038006,-0.083388,0.178640,0.402138,0.220043,0.156862) * L4_4 + mat4(-0.084452,0.270303,0.172579,0.111290,-0.036135,-0.415397,0.248601,-0.228645,0.441232,0.375729,-0.358212,0.080556,-0.149288,0.353256,-0.038292,0.032072) * L4_5 + mat4(-0.192158,-0.002991,-0.282777,-0.252648,0.029320,0.114304,-0.013642,0.068089,-0.095378,0.018677,0.243260,0.406418,-0.194130,0.070199,-0.386291,-0.384725) * L4_6 + mat4(-0.288429,0.191527,0.276790,0.476257,-0.166041,-0.242868,0.068827,0.394097,-0.078366,-0.099606,0.002641,0.104208,0.016909,0.156689,-0.346951,0.341336) * L4_7 + mat4(0.054300,-0.024893,0.005356,-0.422413,0.046480,-0.255708,0.192230,0.323173,0.086800,-0.106090,0.057548,0.081114,0.126079,0.103235,0.085454,-0.026107) * L4_8 + mat4(0.117491,-0.029911,0.134050,-0.434983,-0.169021,0.099345,-0.126594,-0.155116,-0.294165,-0.037224,-0.231013,-0.260619,0.392457,0.509701,-0.023379,-0.129610) * L4_9 + mat4(0.038558,0.093407,0.625849,0.174273,0.123851,0.229241,0.013080,0.163177,0.012899,0.172662,0.268258,0.177326,0.054033,-0.085761,0.258884,0.162668) * L4_10 + mat4(0.007759,-0.241849,-0.145254,0.008810,0.130173,0.013544,0.133126,-0.028024,0.123647,-0.159110,-0.130260,-0.433027,0.046555,0.252739,-0.076081,0.036593) * L4_11 + mat4(-0.405918,-0.159804,-0.016651,0.265689,-0.288751,-0.109386,0.369359,-0.591394,-0.047589,-0.115604,-0.129729,-0.029656,-0.069687,-0.036113,0.239018,0.340031) * L4_12 + mat4(0.125252,0.144461,0.015859,0.163853,0.037233,0.134812,-0.180267,-0.088878,-0.068801,-0.095258,0.379702,-0.169599,0.142665,0.038825,0.080569,-0.357583) * L4_13 + mat4(-0.167103,-0.321215,0.111459,-0.114639,0.079233,0.089500,-0.016652,0.140253,0.114779,-0.031501,0.094511,-0.225474,0.285138,-0.253666,0.093992,-0.413823) * L4_14 + mat4(0.170243,-0.101158,0.287027,-0.320624,-0.015097,-0.083370,-0.097929,0.115460,0.121991,0.081499,0.437555,0.206441,-0.032281,0.019642,-0.181770,0.036452) * L4_15 + vec4(1.298188,0.676724,-0.327853,-0.980433)));\nvec4 L5_6 = sin((mat4(0.065232,0.047333,-0.089230,0.026859,0.107208,-0.022426,-0.050202,0.155848,0.126190,0.011664,-0.221746,0.135387,-0.268117,-0.014322,0.071713,-0.219094) * L4_0 + mat4(0.245078,-0.197387,-0.117519,-0.006615,-0.016248,0.070303,0.251191,0.005002,0.351463,0.124118,-0.172648,0.214063,0.215986,-0.051943,0.096972,-0.296626) * L4_1 + mat4(-0.507588,0.593692,-0.107673,-0.076880,-0.068041,0.074721,-0.123825,0.205168,0.142297,0.083090,0.179160,0.315248,0.030624,-0.177057,0.180726,0.068743) * L4_2 + mat4(0.072258,0.112870,-0.109633,-0.005173,0.022481,-0.021029,-0.162098,0.356241,0.016308,0.044576,-0.136407,-0.035098,0.261827,-0.150619,-0.113382,-0.064471) * L4_3 + mat4(-0.136542,-0.073838,-0.127942,0.291810,0.386842,0.001137,-0.293315,-0.093159,0.304552,-0.075255,0.073661,0.152145,0.435884,-0.152573,-0.026881,0.010434) * L4_4 + mat4(0.178930,-0.260860,0.323952,-0.203130,-0.147220,-0.127814,0.573110,0.192761,0.301189,0.133333,-0.149047,0.457979,0.046020,-0.004221,-0.180563,-0.046948) * L4_5 + mat4(0.018097,0.104464,0.179536,-0.221818,0.340977,-0.126661,-0.019235,-0.001690,-0.022623,-0.175531,-0.275835,0.078119,-0.076891,-0.219812,-0.027272,0.066904) * L4_6 + mat4(-0.074506,-0.443856,0.087786,0.131130,0.198827,0.056358,0.380887,-0.033748,-0.405108,0.007064,-0.198407,0.032202,-0.479621,-0.093896,-0.193839,-0.091086) * L4_7 + mat4(-0.006306,-0.118205,-0.195181,0.437151,0.054240,-0.069426,-0.006848,0.038977,-0.412059,-0.276967,-0.063911,0.016413,0.183561,-0.116115,-0.066209,0.187739) * L4_8 + mat4(0.142138,-0.120372,-0.192894,-0.017204,-0.036288,0.449293,-0.286489,0.153257,0.102023,0.163614,0.519898,-0.172381,0.452498,-0.182609,-0.041679,0.286754) * L4_9 + mat4(0.147375,-0.120968,0.060836,0.019293,-0.023041,0.212317,-0.020596,0.117507,0.224432,-0.197755,0.223005,-0.105185,-0.500297,-0.100014,-0.125276,-0.006534) * L4_10 + mat4(-0.133442,-0.024811,0.241628,-0.103901,0.161609,-0.039381,0.000465,0.162554,-0.144432,0.270477,0.146077,0.010610,0.104488,0.052023,-0.073043,0.113683) * L4_11 + mat4(-0.282544,-0.069805,0.150436,-0.161721,-0.191114,-0.394503,-0.157418,0.154793,-0.116155,0.128190,0.049808,-0.110684,-0.093156,-0.009804,0.059286,-0.023416) * L4_12 + mat4(0.133750,-0.219643,-0.044672,-0.189285,0.361290,-0.075875,-0.210886,0.124673,0.052596,-0.090967,0.323909,-0.281331,-0.107072,0.196591,-0.060743,-0.162177) * L4_13 + mat4(-0.118119,0.124842,-0.125534,0.095407,-0.306998,-0.302079,0.357844,0.055788,-0.246119,-0.093168,-0.306638,0.227697,0.587013,0.086429,-0.036765,-0.178025) * L4_14 + mat4(0.084110,-0.135527,-0.479216,0.018920,-0.294215,0.223173,0.160136,-0.147583,0.119697,-0.070493,-0.214071,0.283200,-0.083581,0.105344,0.033516,-0.119707) * L4_15 + vec4(-0.323067,-0.071393,-0.362663,0.078340)));\nvec4 L5_7 = sin((mat4(0.014048,0.293222,-0.191799,-0.052715,-0.114997,0.223746,0.009352,-0.035012,-0.134244,0.113487,0.078293,-0.233118,-0.054076,-0.075266,0.293136,0.080151) * L4_0 + mat4(-0.001645,0.066294,0.297389,-0.102879,0.080230,0.060332,0.389041,-0.079769,0.229201,0.047416,0.238380,-0.006878,-0.117541,0.117694,-0.004449,0.010099) * L4_1 + mat4(-0.722825,0.098519,0.221516,0.053028,0.067470,0.439639,0.105041,-0.086367,0.199849,-0.263673,-0.052114,-0.152019,0.007924,0.083952,0.008043,0.082578) * L4_2 + mat4(0.313296,0.273756,-0.094594,-0.262401,0.058004,0.476605,-0.228967,-0.170011,-0.153514,-0.178189,-0.046807,-0.216805,-0.368280,0.388684,-0.332456,-0.033738) * L4_3 + mat4(0.026383,0.263910,-0.221139,-0.120010,-0.270099,-0.251320,-0.374668,-0.083994,0.177340,0.077054,-0.538265,-0.202874,-0.118833,0.227594,0.044278,-0.245464) * L4_4 + mat4(-0.271353,0.446671,-0.073646,-0.118017,0.490026,0.162310,0.325470,-0.100027,0.156067,0.125607,-0.248421,-0.001656,-0.008312,-0.160498,-0.135794,0.183723) * L4_5 + mat4(-0.412551,-0.411501,-0.149466,0.094083,0.312884,0.276874,0.440730,-0.284403,-0.285547,0.335535,-0.136189,-0.020993,-0.306135,-0.395025,0.237905,-0.077110) * L4_6 + mat4(-0.204936,0.196179,-0.092354,-0.437188,-0.148326,0.569148,-0.098216,0.263509,-0.099220,0.049123,0.129934,0.070224,0.338748,0.005380,-0.265618,0.231045) * L4_7 + mat4(0.399674,-0.146626,-0.111713,0.061624,-0.404268,0.111258,-0.030717,-0.075051,-0.030161,-0.068375,-0.092581,-0.198908,0.090252,0.102657,-0.169149,0.104839) * L4_8 + mat4(0.105121,0.033581,-0.023208,-0.081225,-0.013554,-0.235886,0.072657,0.128431,-0.429950,-0.028750,-0.061711,0.180566,0.493732,0.138850,0.282031,-0.646182) * L4_9 + mat4(-0.013433,0.309582,-0.294658,-0.106329,-0.086721,-0.189840,-0.221134,0.443251,0.155222,-0.225201,-0.050719,0.051393,0.087105,0.268427,0.054327,0.072788) * L4_10 + mat4(0.162216,-0.233160,0.106662,0.167478,-0.155128,-0.082036,0.096715,-0.123649,-0.009141,-0.087105,-0.282167,-0.259372,0.118384,0.298957,-0.000505,0.003437) * L4_11 + mat4(-0.346444,-0.051998,0.311969,0.149780,-0.262680,0.492804,-0.330979,-0.160334,-0.176727,-0.229908,0.275152,0.014874,-0.197430,0.134729,-0.354108,-0.152261) * L4_12 + mat4(-0.121280,0.073154,0.165692,0.178677,-0.081972,0.098124,0.242314,-0.121660,0.067190,-0.224808,0.217091,0.077631,-0.101617,-0.282489,-0.110721,0.140225) * L4_13 + mat4(-0.352262,-0.192958,-0.256093,0.080169,0.287678,0.119940,-0.067821,-0.143690,0.044402,0.144437,0.186959,-0.192629,0.324509,0.090828,0.310933,0.245617) * L4_14 + mat4(0.069905,-0.277432,-0.219974,0.417481,-0.336837,-0.051099,0.120636,0.056552,0.078765,0.486437,-0.204932,-0.082606,-0.042504,-0.185250,0.003515,0.080275) * L4_15 + vec4(0.317025,-1.457674,-1.174591,0.306935)));\nvec4 L5_8 = sin((mat4(0.013107,0.128126,-0.161179,-0.397809,0.104890,-0.107223,-0.071542,-0.013612,0.488165,-0.399744,0.449237,0.298833,0.019246,0.021806,0.149163,0.173651) * L4_0 + mat4(0.358422,-0.397512,0.164393,-0.118179,-0.059035,-0.111761,0.088964,0.234865,-0.089682,0.139539,0.167972,0.069131,0.017956,-0.180659,-0.100082,-0.063331) * L4_1 + mat4(0.184912,0.051461,0.485483,0.015043,0.042262,0.125400,-0.028507,-0.151278,0.054840,0.008308,0.216182,-0.030696,0.202255,-0.019407,-0.129161,-0.075654) * L4_2 + mat4(0.045298,0.265621,-0.021634,0.053900,-0.066657,-0.241464,-0.003526,0.065301,0.005016,-0.123570,0.047780,0.120596,0.128469,0.315204,0.289621,0.053215) * L4_3 + mat4(0.093806,0.111961,-0.039242,-0.141190,-0.073662,0.041102,-0.068843,-0.259502,0.156599,-0.064889,0.368421,-0.245005,-0.149521,-0.065736,-0.280791,0.030211) * L4_4 + mat4(0.052571,-0.024246,-0.152936,-0.011770,-0.104144,0.036438,0.075727,-0.304948,-0.168965,0.075285,0.128558,0.009078,0.036735,0.083645,-0.136753,-0.062225) * L4_5 + mat4(-0.020480,-0.242086,0.057749,0.284066,0.230346,0.283562,0.083804,-0.023272,0.149819,0.082280,-0.055561,-0.017459,0.030267,-0.191110,0.047957,0.143518) * L4_6 + mat4(-0.054595,-0.526098,-0.359918,-0.092931,-0.057697,0.180372,0.070956,-0.111093,0.038878,0.386092,-0.135323,-0.026514,0.180677,0.194069,-0.131060,-0.160199) * L4_7 + mat4(-0.095732,0.111562,-0.059874,-0.417309,-0.069928,0.080914,0.012943,-0.008429,-0.260403,-0.147004,0.076882,0.117404,0.084237,0.072778,-0.050231,-0.187768) * L4_8 + mat4(0.014104,-0.150108,0.011761,-0.129764,0.218096,0.173426,0.099176,0.337685,0.046716,-0.378458,-0.527109,0.252826,-0.376194,0.182074,-0.113881,-0.202292) * L4_9 + mat4(0.038138,0.003819,-0.125121,-0.208982,-0.128739,0.270733,-0.047409,0.027174,0.092385,0.207089,0.055496,-0.128586,-0.048632,-0.113141,0.001659,-0.181764) * L4_10 + mat4(-0.057444,-0.000419,0.180862,0.138791,-0.212859,-0.224528,0.136361,0.018723,0.306545,0.082696,-0.208206,-0.094574,0.111034,0.159758,-0.080359,-0.103106) * L4_11 + mat4(-0.074417,0.016016,-0.250962,0.295458,0.195484,0.344708,-0.123780,0.075379,-0.103627,-0.162257,0.089920,0.198167,0.009558,0.053636,-0.033652,-0.022247) * L4_12 + mat4(0.040108,0.268262,-0.073152,0.000940,-0.000490,-0.186258,0.033270,-0.057302,0.028697,-0.032054,-0.159235,0.080755,0.116714,-0.000345,0.054472,0.136565) * L4_13 + mat4(-0.318241,-0.188093,0.016661,0.000491,-0.267134,-0.242200,-0.278143,-0.150479,-0.138064,0.129032,0.316397,-0.173499,0.194303,0.105947,-0.118929,0.093985) * L4_14 + mat4(-0.145826,-0.580100,0.169877,0.181517,-0.060617,-0.198215,0.074192,0.104687,0.035665,0.017121,-0.145902,-0.230288,-0.045608,-0.000850,0.016133,0.145995) * L4_15 + vec4(0.302569,0.592537,0.163259,-0.444442)));\nvec4 L5_9 = sin((mat4(0.296028,-0.317464,-0.107532,0.057305,0.020109,-0.002813,-0.210286,0.000878,-0.107609,0.153290,-0.280403,0.106759,0.254903,-0.021550,0.018019,0.045734) * L4_0 + mat4(0.052533,-0.046007,-0.088822,-0.316490,-0.177678,0.260946,-0.175929,-0.096728,-0.224808,0.081877,0.036266,-0.120189,-0.137397,0.155578,0.152132,0.164532) * L4_1 + mat4(0.503229,-0.090294,0.083986,0.390880,-0.102245,-0.118142,-0.086344,0.086055,-0.176846,0.113171,0.154439,-0.283329,0.051333,-0.108343,0.360821,-0.070884) * L4_2 + mat4(0.104462,-0.019314,0.317507,0.051183,-0.066313,0.066492,-0.257966,0.399652,-0.020631,0.094459,-0.128547,0.158065,0.199939,-0.233855,0.098912,-0.200462) * L4_3 + mat4(-0.171730,-0.156083,-0.037982,0.036701,0.407577,0.046904,-0.332968,-0.106573,0.101457,-0.536032,0.622456,-0.131857,-0.161815,0.194141,-0.009129,0.016103) * L4_4 + mat4(0.251840,0.205369,0.445772,-0.325598,-0.352146,-0.429667,0.228372,-0.483519,-0.349576,0.118749,0.189682,-0.130196,-0.048858,0.020017,-0.066191,0.360613) * L4_5 + mat4(-0.324928,0.281032,0.035304,0.128867,0.128850,-0.072131,0.069717,-0.019655,-0.183441,-0.524128,0.122577,-0.226993,-0.309964,-0.248798,0.155457,-0.178007) * L4_6 + mat4(0.177218,0.063876,0.023345,0.072036,0.234227,-0.370245,0.182992,0.148652,0.051354,-0.041068,-0.027942,0.271995,-0.253955,0.328086,0.223397,0.289408) * L4_7 + mat4(-0.072975,-0.047523,0.059521,-0.231310,0.107093,0.150385,-0.098983,-0.094965,0.040949,-0.303071,-0.217759,-0.044491,-0.110507,-0.179321,0.066637,-0.063705) * L4_8 + mat4(-0.069541,-0.205642,0.149180,-0.130428,-0.239363,-0.044427,-0.338052,-0.142935,0.219021,0.116154,0.111326,0.501721,0.154372,0.150568,0.043674,0.074817) * L4_9 + mat4(0.102938,0.204888,0.085551,-0.264711,-0.320035,-0.060945,-0.121158,-0.005551,0.113937,0.243069,-0.220553,0.117136,0.406367,-0.138962,-0.094275,-0.068772) * L4_10 + mat4(0.185111,0.000984,-0.179526,0.001871,0.063459,-0.043559,-0.067917,-0.463029,0.013857,0.348852,-0.139793,0.125548,-0.322946,0.035021,0.222242,-0.161132) * L4_11 + mat4(0.109422,-0.020871,0.034639,0.095888,-0.193651,0.183179,-0.396403,0.010422,0.196992,0.025498,-0.092081,0.183456,0.305146,0.150286,-0.029160,0.177291) * L4_12 + mat4(0.197939,0.226360,0.300670,0.168085,-0.058805,-0.223158,-0.291907,0.076241,0.266642,0.346851,0.077353,0.016401,0.013148,0.006220,0.010320,0.085859) * L4_13 + mat4(0.413517,0.043790,-0.212986,0.018057,-0.097219,0.155781,0.226743,-0.018452,0.116631,-0.323699,0.226904,-0.202932,-0.122148,-0.056657,0.079969,0.183390) * L4_14 + mat4(0.222087,-0.358901,-0.121807,-0.000676,-0.073364,-0.195782,-0.296725,0.201444,-0.152892,-0.122302,0.046436,-0.342198,0.051747,0.053457,-0.063503,-0.073480) * L4_15 + vec4(0.583439,0.680255,1.468790,-0.774895)));\nvec4 L5_10 = sin((mat4(-0.059363,-0.300755,0.025555,0.027274,0.108033,0.162695,-0.233807,0.026930,-0.024940,-0.289909,-0.150943,0.288043,-0.259069,0.125987,0.245755,0.202605) * L4_0 + mat4(-0.230924,-0.059587,-0.278203,-0.171826,0.201732,-0.030395,0.135761,0.058546,-0.020399,-0.271328,-0.130408,0.240906,0.051149,-0.070292,0.015561,0.035433) * L4_1 + mat4(-0.207727,0.176899,0.078488,-0.080342,-0.002800,-0.047484,-0.196043,-0.151006,-0.059484,-0.165690,0.157015,-0.109087,-0.103293,-0.330800,-0.030660,0.123890) * L4_2 + mat4(-0.323343,0.099232,0.081538,-0.085607,-0.122561,0.010018,0.101745,0.168432,-0.169615,0.098620,0.006103,0.091385,0.127149,-0.106680,0.088986,0.022640) * L4_3 + mat4(0.163146,-0.006731,-0.094842,-0.005140,-0.282935,0.104129,-0.179135,-0.051821,-0.472411,-0.265470,-0.628412,-0.236003,0.060548,-0.101461,-0.124937,-0.157462) * L4_4 + mat4(0.656295,-0.089359,-0.334261,0.152402,0.574482,0.296001,-0.510391,-0.376626,0.294644,-0.429122,0.083404,-0.149287,0.119726,-0.256729,-0.205960,-0.132101) * L4_5 + mat4(0.450162,-0.060685,0.221385,-0.071153,-0.059120,0.110626,-0.263887,0.033266,-0.397475,0.147255,-0.354300,0.003498,0.061799,-0.341566,-0.135279,-0.113043) * L4_6 + mat4(0.194588,0.098209,-0.019847,0.137257,0.198637,0.095276,0.212579,0.045461,0.001290,-0.036632,0.140384,0.000495,-0.097013,-0.405013,0.103119,-0.069170) * L4_7 + mat4(-0.148890,0.141452,-0.250568,0.073043,-0.283650,0.043721,0.219404,-0.076750,0.199296,0.049963,0.034447,-0.121784,-0.081062,0.022886,-0.128985,-0.144603) * L4_8 + mat4(-0.047511,-0.096969,0.004887,0.038628,-0.252038,-0.434502,0.351940,0.105216,0.231738,0.021508,0.340270,0.046892,-0.155059,-0.028228,-0.494714,-0.008632) * L4_9 + mat4(0.268845,-0.236656,-0.209680,0.146131,0.104206,-0.025827,0.115269,0.152585,-0.032207,-0.052145,0.143673,-0.308166,-0.340405,0.102634,-0.060543,-0.015013) * L4_10 + mat4(-0.099877,0.020866,0.247206,0.136616,-0.021065,-0.149873,-0.123976,-0.067877,-0.128707,0.094995,-0.389535,0.091601,-0.038943,-0.179830,0.066794,-0.113476) * L4_11 + mat4(0.148482,-0.021323,0.509171,-0.032299,-0.305690,-0.327066,1.004982,-0.341522,0.023199,-0.015687,0.151864,0.195265,0.117502,0.142466,-0.120330,0.151912) * L4_12 + mat4(-0.147299,-0.195280,-0.514330,0.054499,0.002370,-0.174206,-0.345585,0.037670,-0.055708,-0.077270,0.051946,0.138327,-0.115361,0.180893,0.029753,0.107680) * L4_13 + mat4(0.405897,-0.018872,0.053983,0.000567,0.230815,-0.204339,-0.021464,-0.050629,-0.236650,-0.033551,-0.213161,-0.128252,0.145519,-0.001799,0.493014,-0.295053) * L4_14 + mat4(-0.285401,-0.054261,0.200570,-0.015341,0.331830,0.229682,0.073438,0.078365,0.196252,-0.191606,-0.161724,-0.266781,0.509590,0.045665,0.199969,0.075978) * L4_15 + vec4(0.598245,-0.227708,0.979135,0.006357)));\nvec4 L5_11 = sin((mat4(0.151214,-0.168542,0.081579,-0.021964,0.087492,-0.036411,0.139492,-0.030249,0.084164,-0.178697,0.162722,0.049076,0.203053,-0.122703,0.195550,-0.068038) * L4_0 + mat4(-0.114138,-0.084944,-0.398068,0.029180,0.061620,-0.068841,-0.027754,-0.057179,-0.105389,0.097932,0.059041,-0.026618,-0.088084,-0.043414,-0.179066,-0.024898) * L4_1 + mat4(0.180906,-0.275535,0.190864,0.181143,0.119657,0.215915,0.037457,-0.039876,-0.073613,-0.154566,-0.110060,0.085995,-0.065585,-0.082158,0.114138,0.081521) * L4_2 + mat4(-0.063547,-0.108240,0.271765,0.021690,0.093239,-0.293957,-0.170320,0.033474,-0.160537,-0.068047,0.006416,-0.029841,-0.083315,-0.237009,-0.016080,0.041623) * L4_3 + mat4(0.086281,0.063419,0.137600,-0.023931,-0.255415,-0.013239,-0.028557,0.102576,-0.086716,0.052099,0.075000,-0.264185,-0.325354,0.536832,-0.016589,0.025573) * L4_4 + mat4(0.199564,-0.118057,0.129230,-0.092289,0.192619,-0.361798,0.280809,-0.937519,-0.052623,-0.068084,-0.054652,0.042292,-0.152239,0.104285,0.033520,0.049847) * L4_5 + mat4(-0.262121,-0.069705,0.083790,0.032233,-0.135503,-0.307835,0.404650,0.014839,0.010595,-0.050578,0.135999,-0.170804,0.141906,-0.146751,-0.069385,0.208793) * L4_6 + mat4(0.001662,-0.088968,-0.087608,0.286790,0.127021,0.082070,0.006909,0.137425,-0.017654,-0.203803,-0.300542,-0.047106,0.426988,0.135645,-0.137424,-0.039920) * L4_7 + mat4(0.171959,0.056531,0.081992,0.061630,-0.076266,-0.119381,0.104117,-0.076493,0.180906,-0.009094,0.022996,0.025959,0.040740,0.114827,0.038553,-0.080318) * L4_8 + mat4(0.093578,-0.002221,0.034574,-0.043096,-0.007884,0.182440,-0.199010,0.104930,-0.049014,0.059087,0.864551,0.010605,-0.427388,0.252464,0.285158,-0.096232) * L4_9 + mat4(-0.068941,-0.044742,-0.181576,0.073072,0.006379,-0.063921,0.025945,-0.033984,0.003501,-0.079601,-0.112695,-0.032797,0.100180,-0.231876,0.028061,0.078404) * L4_10 + mat4(0.093646,-0.145481,0.171343,0.045191,0.049913,-0.125799,0.053185,-0.024741,-0.277362,0.380749,0.334571,0.073061,0.037412,0.273374,0.199104,0.020472) * L4_11 + mat4(0.061909,0.134372,-0.286319,0.081573,0.654611,-0.135634,-0.733289,0.214092,-0.049237,-0.234968,-0.138682,-0.009562,0.055156,-0.043019,0.046487,0.003701) * L4_12 + mat4(-0.147647,0.029290,-0.147222,0.096961,0.000926,-0.141265,0.062687,-0.108682,0.012912,-0.070972,0.392900,-0.017147,-0.066398,0.263660,-0.164195,0.060626) * L4_13 + mat4(0.093616,-0.096724,-0.076568,-0.007902,0.168827,0.225328,-0.148894,0.058863,0.232129,0.031448,0.089505,-0.063342,0.019202,-0.048212,0.109299,-0.063165) * L4_14 + mat4(-0.112394,-0.472634,0.141082,-0.030726,0.014808,-0.204991,-0.034022,-0.062552,0.216942,0.124340,0.042762,0.035487,0.117144,-0.113608,-0.064149,-0.086467) * L4_15 + vec4(-0.392713,0.237763,0.026822,0.487977)));\nvec4 L5_12 = sin((mat4(0.029166,0.037135,-0.012545,-0.190419,-0.104037,0.195036,-0.140939,0.057745,0.693171,0.109723,0.075723,0.176367,0.109599,0.104978,0.021530,0.150652) * L4_0 + mat4(0.157965,0.199750,-0.216441,0.033963,-0.006882,0.042353,-0.149158,0.313398,0.365479,-0.376599,-0.056308,0.315628,-0.100646,0.197337,-0.016927,-0.116158) * L4_1 + mat4(0.262112,-0.753741,0.645401,0.101136,0.127267,-0.175010,0.201089,-0.261967,-0.023165,0.053090,0.035761,0.217893,0.073655,0.205271,0.235854,-0.100523) * L4_2 + mat4(-0.180864,-0.013646,-0.119688,0.573070,-0.053423,-0.175525,0.137034,-0.137093,0.019978,-0.193521,-0.029253,-0.056028,0.029299,0.018147,-0.134502,-0.020639) * L4_3 + mat4(0.029289,-0.025074,-0.006341,-0.032219,-0.037099,0.172689,-0.208420,0.046139,-0.790719,0.121364,-0.195470,-0.086113,0.025956,0.096290,-0.147123,-0.035090) * L4_4 + mat4(0.146638,0.308337,0.013629,0.015937,0.109712,-0.063284,-0.009719,-0.363360,0.085902,-0.186646,0.110066,0.155651,0.417625,-0.167862,-0.014952,0.040210) * L4_5 + mat4(0.224510,0.027906,-0.014961,-0.184070,0.057090,-0.012983,0.061253,0.124170,0.171331,-0.124818,0.211774,0.117781,0.018252,0.029949,0.178976,-0.226878) * L4_6 + mat4(0.133743,0.185620,0.165247,-0.215267,-0.412604,0.118272,0.090570,0.477526,-0.162018,-0.208029,0.157058,-0.201187,-0.096463,0.316020,0.305964,-0.110031) * L4_7 + mat4(-0.124963,0.110292,0.138827,-0.162052,-0.194960,0.075502,-0.041319,0.140019,0.079416,0.191070,-0.043826,-0.194069,-0.089089,-0.033582,0.007568,0.165510) * L4_8 + mat4(0.092250,0.087175,-0.043122,-0.321624,0.553081,-0.158085,0.089521,-0.026824,0.097827,-0.162925,0.121381,0.224806,-0.227059,-0.251463,0.166066,-0.264467) * L4_9 + mat4(-0.238485,0.209809,-0.076399,0.255168,0.350314,0.086169,-0.406181,0.071412,-0.095862,-0.264538,-0.045111,-0.265809,-0.379806,0.146205,-0.098495,-0.092656) * L4_10 + mat4(0.082662,-0.110916,0.002944,0.204712,0.257655,0.104219,-0.100790,-0.018647,-0.306990,0.020690,-0.125789,-0.139043,0.049796,-0.064248,0.069939,-0.031106) * L4_11 + mat4(0.102804,-0.117510,-0.053065,-0.231020,-0.487263,0.380572,-0.300499,0.032158,0.258531,-0.080658,0.036786,0.029822,-0.144380,-0.187965,0.081488,-0.033201) * L4_12 + mat4(0.031255,-0.041968,-0.018565,-0.045606,0.011123,0.108846,0.084450,-0.143828,-0.121042,0.029845,0.119779,-0.105446,0.205575,-0.024599,-0.091083,0.270087) * L4_13 + mat4(-0.364610,-0.218027,-0.191545,0.035995,-0.130388,0.291828,0.126210,-0.192396,-0.094009,-0.043282,0.015709,-0.167031,0.197401,-0.420065,-0.182855,-0.120207) * L4_14 + mat4(-0.140852,0.100140,-0.325351,0.038115,-0.095950,0.065026,-0.263511,0.106287,-0.174804,0.101794,0.041159,-0.412746,0.153678,0.248972,0.034784,-0.148195) * L4_15 + vec4(1.150598,0.936831,-0.204286,-0.596304)));\nvec4 L5_13 = sin((mat4(-0.048664,0.023277,-0.320130,0.124940,-0.171686,-0.010572,0.156527,0.087061,-0.117352,0.252962,0.109421,0.059718,-0.045873,0.090106,0.364818,-0.191338) * L4_0 + mat4(0.181148,-0.175774,-0.510276,0.240748,-0.259774,0.055168,-0.149833,0.134842,0.014315,-0.052792,-0.040853,0.003049,0.123879,0.033396,0.076132,-0.082882) * L4_1 + mat4(0.031381,-0.093968,0.368420,-0.084786,-0.048011,0.065247,-0.116182,0.208332,0.147135,-0.014571,0.189271,-0.109069,-0.402083,-0.065273,-0.098608,0.110139) * L4_2 + mat4(-0.104632,-0.174434,0.099245,0.044343,0.130301,0.078137,0.219804,0.240438,0.039377,-0.017709,0.023680,-0.020396,0.665471,0.058174,0.430557,0.198400) * L4_3 + mat4(0.036020,0.080876,0.078323,-0.033405,0.046459,-0.225050,0.057607,0.148795,0.439025,-0.264961,-0.001572,-0.218951,-0.045661,-0.006262,-0.402110,0.133204) * L4_4 + mat4(-0.359275,0.261618,0.097973,-0.119803,0.387672,0.231368,0.097494,0.243890,-0.029548,-0.112541,0.416398,0.067408,-0.239172,0.032552,-0.387635,0.296355) * L4_5 + mat4(0.259712,-0.013325,-0.112061,-0.222168,0.056784,0.133104,-0.252657,0.048547,-0.089557,-0.097418,-0.037733,-0.192186,-0.186853,-0.040985,-0.236282,-0.192285) * L4_6 + mat4(0.146809,0.052117,-0.321406,-0.044220,0.155083,-0.037279,0.201323,0.028870,-0.051685,0.029492,0.001153,0.068445,-0.042930,0.325506,0.374719,-0.080651) * L4_7 + mat4(0.112760,0.008412,-0.310823,-0.073331,-0.091282,-0.446141,0.412664,0.166221,-0.046633,-0.040037,0.347470,-0.163053,-0.078745,-0.057422,-0.028954,0.113454) * L4_8 + mat4(0.162597,0.014598,-0.032270,-0.046527,-0.199843,-0.046520,-0.773844,-0.035043,-0.254690,-0.468107,0.106728,-0.004185,0.175679,0.035568,-0.048265,0.009875) * L4_9 + mat4(0.090342,0.107452,0.399984,0.033486,0.133454,-0.006837,-0.063986,0.015594,-0.008869,0.040306,-0.125830,-0.099308,-0.222604,-0.099620,0.104817,0.131123) * L4_10 + mat4(0.035654,0.125795,0.126605,-0.142358,-0.017444,0.021753,0.062166,-0.226016,0.163170,-0.253501,-0.115164,-0.136153,-0.116661,0.119657,-0.021433,0.152553) * L4_11 + mat4(-0.104937,-0.069749,-0.251834,-0.125156,-0.473924,0.100508,-0.107522,-0.292789,0.085590,0.036252,0.050325,-0.163503,0.067305,0.096695,0.236577,0.068037) * L4_12 + mat4(-0.246142,-0.015747,-0.311099,0.291992,0.140825,0.120854,0.342432,-0.207334,-0.127363,-0.122341,0.022362,-0.109380,0.098940,0.125188,0.232843,0.170594) * L4_13 + mat4(0.047650,-0.055614,-0.047226,0.014237,-0.026711,0.234852,0.005868,-0.043058,-0.249050,-0.049914,0.107952,-0.030321,0.232915,0.050531,-0.013527,0.020447) * L4_14 + mat4(-0.007636,-0.045748,0.441179,0.160280,0.057208,-0.205940,0.057290,-0.283775,-0.239005,0.090750,-0.031470,0.269685,0.227239,0.010068,0.044546,-0.370815) * L4_15 + vec4(-0.605923,-0.033465,0.378397,-0.065303)));\nvec4 L5_14 = sin((mat4(0.317613,-0.243374,-0.028071,0.067294,-0.068138,0.262095,0.142971,0.042715,0.074129,-0.164881,0.079274,0.073639,0.203489,0.090558,-0.030322,-0.027370) * L4_0 + mat4(-0.015367,0.311844,0.244259,-0.117824,-0.284761,0.226162,0.198682,-0.032383,0.058082,-0.011689,-0.115572,-0.017817,0.036513,-0.106666,-0.062919,-0.162237) * L4_1 + mat4(-0.199700,-0.711515,0.055369,-0.049366,0.076230,0.173633,0.047120,0.002667,0.275512,0.194952,0.273715,0.169783,0.220987,0.427630,0.042218,0.018340) * L4_2 + mat4(0.324408,0.110854,-0.022047,-0.005530,-0.023112,0.334656,0.114834,-0.104399,0.009178,0.282200,-0.043424,-0.053238,-0.153547,-0.169073,-0.022524,-0.104818) * L4_3 + mat4(0.132912,0.181497,-0.030483,-0.072722,-0.117965,0.089414,0.102727,-0.254469,0.419650,-0.117059,-0.366327,0.131678,-0.076854,-0.145600,-0.079176,0.235679) * L4_4 + mat4(0.048749,-0.128074,0.085740,0.051482,0.296178,0.564417,0.151809,0.114256,0.264638,-0.171197,0.243176,0.384978,0.139395,-0.136843,-0.161143,0.090456) * L4_5 + mat4(-0.207977,-0.194507,-0.083551,-0.105375,-0.285780,-0.050248,-0.390199,-0.065878,0.147637,0.274655,0.043721,-0.108686,0.007832,0.550454,-0.194555,-0.373912) * L4_6 + mat4(0.378708,-0.071593,0.102175,0.060180,0.129992,0.004648,0.015499,-0.223544,0.119068,-0.009893,0.069112,-0.106571,-0.023393,-0.087032,0.050970,0.013797) * L4_7 + mat4(0.100797,0.305056,-0.005976,-0.265669,-0.015767,0.061327,-0.084759,-0.007392,0.058923,0.398230,0.131755,-0.013503,0.322920,0.034810,-0.051138,0.121974) * L4_8 + mat4(0.179829,0.022404,0.021600,-0.132197,0.219138,-0.041061,0.322616,0.131073,-0.285892,0.204750,-0.376357,-0.610826,0.097138,0.066925,-0.189818,0.188796) * L4_9 + mat4(-0.074692,-0.125956,0.071002,-0.003457,-0.332944,0.133033,0.236706,0.034675,-0.068331,0.012914,-0.034763,0.050789,0.082096,0.282445,0.232421,-0.105690) * L4_10 + mat4(-0.064357,-0.008151,-0.119276,-0.160181,-0.014416,0.266568,0.065082,0.181426,-0.478272,-0.240534,-0.290652,-0.054666,0.074635,-0.086828,-0.042322,0.054751) * L4_11 + mat4(0.051147,0.065370,0.171584,-0.197895,0.128891,0.057109,0.435002,-0.007076,-0.125269,-0.076860,-0.047893,-0.035489,-0.113077,0.104633,0.011956,-0.160972) * L4_12 + mat4(0.209779,-0.100665,0.025949,-0.071603,0.264314,-0.012806,-0.169287,0.043549,0.023567,-0.205994,-0.056878,-0.031328,0.215080,-0.441977,-0.282241,0.089100) * L4_13 + mat4(-0.082585,-0.045885,0.285632,-0.222439,-0.029108,0.185725,-0.119569,0.157138,0.310884,0.299672,0.251292,0.124798,0.168047,-0.407343,-0.166396,0.109229) * L4_14 + mat4(0.275625,0.322503,0.050392,0.022092,-0.226091,0.180183,0.116248,-0.135014,0.220457,0.192838,0.153283,0.149247,-0.336981,-0.109698,-0.031613,-0.068653) * L4_15 + vec4(0.385724,-0.633915,-0.652196,-0.420591)));\nvec4 L5_15 = sin((mat4(0.417275,0.049329,0.082746,0.328281,0.028122,-0.028833,-0.123545,0.097476,-0.298469,-0.069666,0.234081,-0.099189,-0.432845,-0.320807,0.094872,-0.140700) * L4_0 + mat4(-0.059917,-0.138062,0.009413,0.152714,-0.411202,0.056322,0.002039,0.059355,0.039825,0.157701,-0.015656,-0.008800,0.120831,0.077769,-0.004974,-0.032635) * L4_1 + mat4(-0.015071,0.258165,0.037521,-0.029482,-0.059903,0.381590,-0.094852,0.109738,-0.035796,0.340396,-0.366889,0.015301,-0.179932,-0.097582,-0.097305,-0.100115) * L4_2 + mat4(0.094319,0.183921,-0.038130,-0.115483,-0.042280,0.147271,0.012705,0.065893,0.039872,0.104709,-0.085072,-0.084544,0.078504,-0.051109,-0.255052,0.023229) * L4_3 + mat4(0.113585,0.034361,-0.159720,0.071343,0.301278,0.037274,0.028087,-0.048536,0.764751,0.183310,0.468423,0.021424,0.276088,0.148024,0.010549,0.096581) * L4_4 + mat4(-0.133175,-0.166099,0.063683,0.142205,0.290012,0.161956,-0.273880,-0.128340,0.416227,0.127733,0.329050,0.063459,0.102592,0.058534,0.112546,-0.043391) * L4_5 + mat4(-0.045552,0.048726,-0.403653,-0.093690,-0.090490,0.197982,-0.019605,-0.154166,0.072230,0.317202,0.524970,0.027548,0.167616,0.170475,0.142088,-0.122140) * L4_6 + mat4(0.439279,0.309941,-0.111671,-0.016203,-0.210480,0.195748,-0.068515,0.031617,0.151966,0.387847,-0.087377,0.203343,0.005760,0.248261,0.234894,0.067707) * L4_7 + mat4(0.202415,-0.125095,0.073727,0.102330,-0.233556,-0.150508,0.205090,-0.050421,0.286114,-0.070135,-0.311532,-0.112955,0.074668,0.152367,0.168268,0.084274) * L4_8 + mat4(-0.002741,0.196313,0.095116,0.039022,0.187973,0.294411,-0.373600,0.038733,-0.375453,0.147176,-0.284265,-0.312769,0.068124,-0.247862,0.126919,-0.090336) * L4_9 + mat4(-0.515025,-0.072334,0.036048,-0.007628,0.036214,-0.298703,-0.130888,0.169213,0.138331,-0.029373,-0.070888,0.016699,0.103430,0.054619,0.157143,0.071517) * L4_10 + mat4(-0.262940,-0.161100,0.105139,-0.170922,-0.117533,0.044935,-0.073093,0.017260,-0.321162,0.273253,-0.252238,-0.108087,0.044395,0.202470,-0.101541,0.157598) * L4_11 + mat4(-0.122291,0.529578,-0.170224,-0.059390,0.004707,0.143970,0.470425,0.213477,-0.093482,-0.054158,-0.001201,-0.261382,0.010726,-0.099515,0.087663,-0.058132) * L4_12 + mat4(0.157296,0.006633,0.090178,0.053108,0.325403,-0.082070,-0.363795,-0.084660,-0.129800,-0.100353,-0.000799,-0.111207,0.186462,-0.239277,0.151635,-0.065738) * L4_13 + mat4(-0.276444,-0.149711,0.122066,0.018666,0.078457,0.021916,0.217400,-0.120281,0.035809,0.096186,0.070350,0.184830,-0.041848,-0.417276,0.328910,-0.007889) * L4_14 + mat4(0.074155,-0.256981,0.065899,-0.031860,-0.223167,0.330126,-0.034011,-0.083483,-0.051220,0.227419,0.027956,0.378822,-0.034711,0.035621,-0.075916,-0.031971) * L4_15 + vec4(0.441154,-0.744008,-0.014071,0.534773)));\nvec4 L6_0 = sin((mat4(-0.001472,-0.166732,-0.007457,0.056595,0.011674,0.083752,0.001942,0.218312,0.011382,-0.166940,-0.005083,-0.119430,0.005000,-0.083492,-0.005225,0.036409) * L5_0 + mat4(0.039893,-0.103960,0.006247,-0.231259,-0.014913,-0.274339,-0.016403,0.076168,-0.031199,0.211063,-0.007158,-0.026235,-0.006001,-0.489664,-0.003390,-0.008114) * L5_1 + mat4(0.015706,0.231916,-0.039771,0.003989,-0.004758,-0.120038,-0.012723,0.075403,-0.009254,0.325262,-0.003793,-0.062813,-0.014680,0.064339,0.033239,-0.009046) * L5_2 + mat4(0.024509,0.061058,-0.002830,-0.038247,-0.007135,-0.388112,-0.012285,-0.086755,0.016245,-0.167934,0.025189,-0.079469,-0.001095,0.106699,0.007662,-0.008941) * L5_3 + mat4(0.002571,0.022266,-0.013405,0.119195,-0.009337,0.143112,0.005066,0.150258,-0.015420,-0.005629,0.006916,-0.011877,-0.003898,-0.079426,0.014435,-0.055351) * L5_4 + mat4(-0.003192,0.086707,-0.005151,0.011729,-0.004376,-0.114037,0.016630,0.032542,0.002921,0.149497,-0.020381,-0.058803,-0.009910,0.112466,-0.005638,0.047124) * L5_5 + mat4(-0.001977,-0.005191,-0.002285,-0.052725,0.008973,-0.029109,-0.014554,0.074195,0.015182,0.217386,0.016885,-0.229679,0.012566,-0.098156,0.006020,-0.035117) * L5_6 + mat4(-0.024905,0.115589,0.018703,-0.045960,-0.015415,-0.201667,0.029636,0.066053,0.006258,-0.120121,0.004712,-0.035122,-0.009262,0.136472,0.018388,-0.074578) * L5_7 + mat4(-0.020009,-0.346432,-0.023268,-0.129466,0.016552,-0.118125,-0.020968,-0.064939,0.015133,0.314326,0.020221,-0.165343,-0.012191,0.531593,0.019520,0.023581) * L5_8 + mat4(-0.001672,-0.373792,-0.016242,0.044493,-0.010056,0.172314,-0.035485,0.081923,-0.000884,0.075051,0.004674,-0.012340,-0.016294,-0.149610,0.019591,0.126836) * L5_9 + mat4(-0.002094,0.174073,-0.013475,0.072335,0.023995,0.128589,-0.004152,0.072926,-0.003646,0.155110,-0.006384,-0.080498,-0.022364,-0.139021,0.015063,0.037256) * L5_10 + mat4(0.009731,-0.420254,-0.000257,-0.184095,-0.009563,-0.039053,-0.007731,-0.056703,0.018242,0.033071,-0.006856,0.079193,-0.009142,0.097240,-0.010863,0.309987) * L5_11 + mat4(-0.007383,-0.237077,-0.007452,0.017167,0.014802,0.171595,-0.004907,-0.044916,-0.012546,0.281366,0.006386,0.048769,0.008254,0.203728,0.020653,0.028846) * L5_12 + mat4(-0.003898,0.100838,-0.007987,-0.128066,0.005378,-0.228618,-0.024998,-0.253563,-0.002646,0.118948,-0.007105,-0.022263,0.013083,0.008369,-0.013118,-0.180097) * L5_13 + mat4(0.015406,-0.231244,-0.001798,-0.118306,-0.013045,-0.098920,0.019169,-0.089130,0.024238,-0.118929,-0.007735,0.043796,0.000024,-0.015654,-0.036840,-0.406788) * L5_14 + mat4(0.024190,0.133934,-0.022462,0.017694,0.006453,-0.101278,-0.013997,0.188498,-0.018543,0.221024,-0.001537,-0.045165,-0.001180,-0.631846,0.045023,-0.096700) * L5_15 + vec4(0.015844,-1.665011,0.004525,-0.015754)));\nvec4 L6_1 = sin((mat4(-0.007803,-0.011506,-0.088635,0.216948,0.005332,0.003964,-0.029283,0.019319,-0.015663,0.020322,0.174827,-0.086372,-0.019623,0.012843,-0.012794,-0.242064) * L5_0 + mat4(-0.008585,0.006049,-0.130612,0.039688,-0.016837,0.009682,0.230274,-0.243890,0.004513,0.025377,-0.064930,0.150153,-0.008458,0.007844,0.044626,-0.015181) * L5_1 + mat4(0.011918,0.014380,0.029297,-0.003498,0.031351,0.024277,0.098098,0.442746,-0.006254,-0.000726,-0.166272,-0.181405,-0.019414,-0.010845,0.073928,-0.128107) * L5_2 + mat4(-0.016005,-0.004981,-0.092289,0.103806,0.027417,0.005096,-0.080983,0.287482,0.013968,0.011022,0.080532,-0.144173,-0.025819,0.002695,-0.070190,0.230810) * L5_3 + mat4(-0.015194,0.033401,-0.077118,-0.195717,0.008832,0.004222,0.054896,0.073250,-0.018112,-0.012505,0.027624,0.008065,0.001691,-0.017627,0.038576,-0.144673) * L5_4 + mat4(0.012832,0.023396,-0.084063,0.064790,0.009638,-0.031569,-0.136624,0.306385,-0.015921,0.007907,-0.070887,0.245476,0.012523,0.004173,0.064814,0.109388) * L5_5 + mat4(-0.009509,0.007478,0.104497,-0.122734,-0.019928,-0.005893,0.042446,0.052131,-0.000298,-0.017889,0.025262,0.277042,-0.009664,-0.011610,-0.001321,-0.047252) * L5_6 + mat4(-0.012662,-0.005574,-0.008463,-0.250090,-0.004743,-0.004769,0.074905,0.039225,0.001026,0.002391,0.019418,0.081170,0.024413,0.008127,-0.097308,-0.096839) * L5_7 + mat4(0.025061,0.025544,-0.031020,0.260956,0.008753,-0.000295,0.046548,-0.134900,-0.022028,-0.036611,-0.005708,0.672133,0.012655,0.007189,-0.110333,0.163560) * L5_8 + mat4(0.008872,0.002073,-0.132913,0.112968,0.032210,0.037915,0.060195,-0.040563,-0.004658,-0.024235,-0.179965,0.136488,-0.008542,-0.012514,-0.001185,-0.003704) * L5_9 + mat4(-0.003031,0.018850,-0.016962,-0.044854,-0.001410,-0.027952,-0.184292,0.132958,0.004831,0.027644,0.107191,-0.013485,-0.007204,0.016122,0.230178,0.229877) * L5_10 + mat4(0.016457,0.011208,0.039142,-0.195708,0.000919,-0.002862,0.014278,0.072527,0.007924,0.024673,0.022386,0.038598,-0.031470,-0.000314,0.074852,-0.239135) * L5_11 + mat4(0.011003,0.013579,0.043052,0.233294,-0.015196,-0.003461,-0.017516,-0.051604,0.003351,-0.017761,-0.254057,0.035047,-0.021330,-0.023574,-0.117387,0.117324) * L5_12 + mat4(-0.000880,0.011189,0.179359,0.100185,0.019698,0.008484,-0.354303,-0.176978,0.008350,0.025283,-0.039982,0.222632,-0.003831,0.005285,-0.035207,-0.131668) * L5_13 + mat4(0.011165,0.025057,-0.000437,0.032928,0.004910,0.001650,0.132982,-0.178517,0.008205,0.001590,0.035738,-0.090746,0.045032,0.031515,-0.167293,-0.386913) * L5_14 + mat4(-0.017701,0.031017,0.068002,-0.121289,0.034204,-0.019135,0.138389,0.289008,-0.008640,-0.000005,-0.146480,-0.253957,-0.011160,-0.003296,0.016389,-0.359734) * L5_15 + vec4(-0.008835,0.004933,0.146598,-0.539610)));\nvec4 L6_2 = sin((mat4(-0.006579,0.004848,-0.104656,-0.052612,0.008738,-0.001276,-0.167897,-0.006567,-0.007409,0.002586,0.139195,0.015144,0.017407,-0.005958,0.178812,0.008315) * L5_0 + mat4(0.011343,0.007714,-0.328819,-0.121346,-0.021826,-0.001347,0.012131,-0.042223,-0.000536,-0.006384,-0.173767,-0.019788,-0.023650,-0.005816,0.004621,0.071487) * L5_1 + mat4(0.024128,-0.019934,0.065207,-0.019108,0.018521,0.003631,-0.020301,-0.026762,-0.000161,-0.005927,0.148723,-0.036474,-0.019794,0.000238,0.158738,-0.028825) * L5_2 + mat4(0.019084,-0.008228,0.160234,-0.050089,-0.009211,0.026208,-0.070079,-0.086042,-0.007667,0.042046,0.199010,-0.005944,0.001742,-0.028935,-0.188726,0.042826) * L5_3 + mat4(0.021717,-0.014133,-0.178420,0.063293,0.010226,-0.032270,0.064946,-0.022584,0.018736,0.002613,0.162554,0.133290,0.010506,0.008518,-0.140383,-0.075919) * L5_4 + mat4(-0.002588,0.005807,0.201451,-0.025858,-0.004724,0.003778,0.025177,-0.109735,0.001234,-0.005765,-0.221476,0.073016,-0.021163,0.007006,0.217116,-0.018352) * L5_5 + mat4(-0.000283,-0.024934,0.290691,-0.036901,0.008492,-0.013599,0.050293,-0.081856,0.006642,-0.018454,-0.073115,-0.079546,0.014494,-0.016772,0.312281,0.090941) * L5_6 + mat4(-0.024021,-0.009498,-0.035936,-0.046629,-0.017459,0.011019,0.497403,-0.014019,-0.002181,0.003744,0.060697,-0.025027,0.007650,0.025398,0.184778,0.000795) * L5_7 + mat4(0.013398,-0.002076,-0.330235,-0.056605,0.014040,-0.009765,0.094232,0.003887,-0.014926,-0.019546,-0.190094,0.057412,-0.025492,0.009601,-0.233592,-0.105757) * L5_8 + mat4(0.011079,0.014909,0.085800,-0.023679,0.020039,-0.001467,-0.021209,0.012992,-0.009261,-0.013246,-0.448465,0.001856,0.001594,0.017885,-0.033922,-0.206840) * L5_9 + mat4(0.024130,-0.002511,0.126939,0.020647,-0.007295,0.005305,0.214725,-0.026637,0.010131,-0.001502,-0.124490,0.019753,0.017651,-0.003166,0.113768,-0.090237) * L5_10 + mat4(-0.000532,0.010535,0.193882,0.256984,-0.001253,-0.008829,0.045844,0.199174,-0.000634,-0.000949,-0.116301,-0.120341,0.001931,0.000793,-0.250703,0.001939) * L5_11 + mat4(0.013724,0.007158,0.067556,-0.099359,0.016447,-0.015406,0.146978,-0.049561,0.003314,-0.006230,-0.905288,-0.083439,0.001334,-0.004000,0.250465,-0.101242) * L5_12 + mat4(0.010019,0.005409,0.074210,0.001221,0.017106,0.000547,-0.335437,0.096193,0.008415,0.018432,0.104234,0.001893,0.050248,-0.010821,-0.282735,0.041062) * L5_13 + mat4(0.009342,0.005690,0.060310,-0.054140,0.003123,-0.002408,0.154124,0.016364,0.017350,-0.004546,-0.105091,-0.005458,-0.016187,0.026512,-0.222507,0.133665) * L5_14 + mat4(0.023792,-0.015236,-0.262442,-0.002874,0.014938,0.026877,-0.043563,-0.055083,0.011288,-0.005391,0.027083,0.094989,-0.032418,0.028928,-0.338435,0.556212) * L5_15 + vec4(-0.006435,0.003763,-0.753158,0.278657)));\nvec4 L6_3 = sin((mat4(-0.001634,-0.007416,0.248149,-0.040607,0.002060,-0.047256,0.146728,-0.017827,-0.011616,-0.050514,-0.025842,0.155324,-0.003808,0.035510,0.040083,0.079349) * L5_0 + mat4(-0.009881,0.101665,0.186703,0.218576,-0.001542,-0.002599,-0.367666,-0.072641,0.036798,0.015788,-0.161998,-0.057739,-0.002332,-0.111048,-0.359169,-0.024855) * L5_1 + mat4(-0.025346,0.003897,0.120252,-0.014484,0.004382,-0.172282,-0.068450,-0.002097,0.006218,-0.010955,0.125381,-0.015251,-0.002884,0.043242,-0.005644,-0.199998) * L5_2 + mat4(0.005871,0.058533,-0.107032,-0.123193,0.031327,0.299848,-0.130620,-0.194315,-0.004622,-0.010051,-0.098897,0.093362,-0.039679,-0.032117,0.263194,-0.006652) * L5_3 + mat4(0.014391,0.058667,0.194375,0.080554,-0.007961,-0.044699,-0.116004,-0.063457,-0.005401,-0.136309,-0.245211,0.138540,0.003277,0.025400,0.168910,0.102706) * L5_4 + mat4(-0.001802,-0.368936,-0.211526,-0.237516,0.011554,-0.011972,-0.144241,-0.000689,0.002859,-0.086760,-0.302854,-0.098125,0.026966,-0.080408,0.011468,-0.031511) * L5_5 + mat4(-0.002528,0.122627,0.049314,0.054393,0.005033,-0.036409,-0.102139,-0.253561,-0.000539,-0.055972,0.270647,0.060118,0.010816,0.015327,-0.659414,0.158816) * L5_6 + mat4(-0.011997,-0.015023,-0.093014,0.096407,-0.011231,0.080111,-0.123959,-0.052794,0.010047,0.049505,-0.006340,-0.144221,-0.004544,-0.017637,0.159593,0.181204) * L5_7 + mat4(0.021454,0.166941,0.059602,0.051516,0.001860,0.049625,0.015421,-0.033365,-0.008727,-0.013324,0.174130,0.121273,0.007568,-0.151132,0.454661,0.098988) * L5_8 + mat4(-0.001996,0.134146,-0.107579,0.045470,-0.005524,-0.069079,0.209436,0.128682,-0.005207,-0.042870,0.116468,0.230310,0.008822,-0.004075,0.324269,0.088484) * L5_9 + mat4(-0.003473,-0.054514,0.169016,-0.020614,-0.005375,-0.121087,-0.350663,0.046895,-0.010652,0.039081,0.532753,-0.014781,0.006567,-0.305247,-0.027297,0.152448) * L5_10 + mat4(0.020619,0.211619,-0.148777,-0.044288,0.010757,-0.026474,-0.029287,-0.052610,-0.007686,0.017247,-0.034826,0.023872,-0.022144,-0.186983,-0.093731,-0.174524) * L5_11 + mat4(0.009115,-0.085429,0.063239,-0.009864,0.010213,0.058621,-0.003122,0.085259,0.007273,-0.004041,-0.070600,0.151260,0.006781,-0.011348,0.091554,-0.056776) * L5_12 + mat4(-0.005380,0.046329,-0.182630,0.025393,-0.000683,-0.047902,-0.051311,-0.140587,-0.004846,-0.051478,0.126860,-0.043174,-0.027906,0.008092,-0.393403,0.030135) * L5_13 + mat4(0.017946,0.047990,-0.050486,-0.104210,-0.005909,0.030660,0.069269,-0.185803,0.007008,-0.274533,0.159666,0.021712,0.022339,-0.250630,-0.467368,0.247289) * L5_14 + mat4(-0.024646,-0.019328,0.104987,-0.165762,0.008943,-0.109753,-0.226873,-0.065028,-0.010268,0.011663,0.012350,-0.126549,-0.009220,-0.054656,-1.181309,-0.242728) * L5_15 + vec4(0.005166,0.084824,-0.318050,-0.472580)));\nvec4 L6_4 = sin((mat4(-0.009564,0.111959,0.005927,0.018731,0.003802,0.205168,0.008569,0.034340,0.008656,-0.248773,0.002995,-0.151094,-0.009113,-0.091053,0.006905,0.086831) * L5_0 + mat4(0.008246,0.122968,0.009057,-0.238221,0.006384,-0.198395,0.002001,-0.009406,-0.012706,-0.068439,0.005074,-0.147774,0.004773,0.076086,-0.021264,0.053712) * L5_1 + mat4(-0.004070,-0.101653,0.011252,0.060450,0.000907,0.192249,-0.009441,-0.022434,-0.026195,-0.570035,-0.003825,0.235728,-0.004411,-0.531439,-0.011155,0.081336) * L5_2 + mat4(-0.004317,-0.197117,-0.006969,-0.034752,-0.002714,0.093271,-0.011243,-0.007811,-0.002608,0.192788,-0.006741,-0.002935,0.023711,0.103166,0.028779,0.095266) * L5_3 + mat4(-0.025773,0.300806,0.019573,-0.153699,-0.011732,0.206591,0.010472,0.030699,-0.008855,-0.185903,0.010287,-0.066935,0.014775,0.098156,-0.006194,0.175315) * L5_4 + mat4(0.001756,-0.013975,-0.008171,-0.677514,0.007217,0.135985,-0.013751,-0.080494,-0.014631,-0.086528,0.013890,0.021173,-0.003056,-0.067128,-0.013606,-0.102378) * L5_5 + mat4(-0.003086,-0.119139,0.010768,0.041344,0.048058,-0.408882,0.013983,-0.213377,0.005326,-0.138528,-0.001030,0.281323,0.020160,0.473055,-0.009649,-0.066652) * L5_6 + mat4(0.004219,-0.046491,0.009164,0.097126,-0.007339,0.014428,-0.028955,0.085727,-0.007832,-0.101591,0.005332,-0.148823,-0.013019,0.225514,-0.021352,-0.187849) * L5_7 + mat4(-0.032563,0.093261,0.006763,-0.027917,0.007605,0.233584,-0.019197,0.013384,-0.005803,0.062443,-0.005357,0.082004,-0.005183,-0.214068,-0.003992,-0.120383) * L5_8 + mat4(-0.023130,0.110165,-0.004624,-0.125759,-0.029200,0.034980,-0.006288,0.078951,-0.007154,0.094398,0.006985,-0.070356,-0.002633,-0.027713,-0.001362,-0.301110) * L5_9 + mat4(-0.013355,0.073919,0.027172,0.156149,0.032434,0.252859,-0.019946,0.007851,0.019190,0.045829,0.011062,0.120143,-0.038054,-0.075567,0.019793,-0.012295) * L5_10 + mat4(0.023958,0.056121,-0.013827,0.117272,-0.000468,0.209364,0.015904,0.037624,0.027012,0.032044,0.002054,0.054303,-0.003510,0.064947,-0.011200,0.159438) * L5_11 + mat4(-0.020044,0.134934,0.023559,-0.013974,0.003451,0.039928,0.003552,-0.057585,-0.015529,-0.052785,0.017402,0.009406,0.026014,0.111034,-0.008100,-0.082529) * L5_12 + mat4(0.009976,0.175890,0.006221,-0.116401,0.012456,-0.077944,-0.019434,0.496718,0.013891,-0.092388,-0.004948,-0.158358,-0.036772,0.187922,0.030487,-0.098493) * L5_13 + mat4(0.023245,-0.094118,0.012815,-0.040471,0.002700,-0.154278,0.015480,0.007008,-0.022700,-0.063493,0.029434,0.265176,-0.008319,0.277278,-0.023407,-0.589776) * L5_14 + mat4(-0.026821,0.082379,0.041030,-0.005337,0.028332,-0.117374,-0.027921,0.080923,0.001461,-0.134408,0.012126,-0.405892,0.009724,0.566635,0.014955,0.125804) * L5_15 + vec4(0.027732,0.596334,-0.012458,0.357755)));\nvec4 L6_5 = sin((mat4(0.049795,0.023381,-0.026376,-0.015468,-0.045045,-0.037221,0.368466,-0.119803,0.004872,0.048063,-0.266994,-0.138266,0.009601,0.121693,0.040215,-0.067214) * L5_0 + mat4(-0.036058,-0.050182,-0.164960,0.012026,-0.110095,0.083304,0.381060,0.150668,0.007418,0.036064,-0.354625,-0.068364,0.134321,0.023805,0.206382,0.160706) * L5_1 + mat4(0.064060,0.042830,0.131110,-0.038932,-0.013919,-0.217463,0.450023,0.004883,-0.090450,0.053317,0.345284,0.102956,-0.053099,-0.161411,0.282954,0.128994) * L5_2 + mat4(-0.040637,-0.085128,-0.210571,0.002887,-0.225341,0.030930,-0.065094,0.025280,-0.034282,-0.049119,0.118000,-0.017562,0.043751,-0.091270,0.223469,-0.052288) * L5_3 + mat4(0.018116,0.046341,-0.118529,-0.077280,-0.040633,0.089835,-0.110451,-0.006660,0.169551,-0.068575,-0.304925,-0.219518,-0.006222,-0.013238,-0.171291,-0.076763) * L5_4 + mat4(-0.092845,0.045636,-0.067842,0.203450,0.152234,0.044992,-0.045519,-0.014748,-0.088841,-0.046700,0.211841,0.089360,-0.025965,-0.094851,-0.118835,0.025443) * L5_5 + mat4(0.063863,0.094651,-0.374608,0.000851,-0.110225,0.128719,0.125421,0.144903,-0.019203,0.014842,0.377198,-0.054348,0.064187,0.450996,-0.485141,-0.012484) * L5_6 + mat4(0.019933,0.005112,0.395683,-0.018177,-0.039933,-0.043271,-0.212708,0.080987,-0.032896,-0.135078,0.044293,0.145793,-0.124574,0.123010,-0.411732,0.028543) * L5_7 + mat4(0.029954,0.045059,0.263410,0.109947,0.102324,0.173180,-0.348674,0.032459,-0.032126,-0.066094,-0.112549,-0.247886,-0.127515,-0.020616,0.370630,0.144952) * L5_8 + mat4(0.072476,-0.129485,0.023860,-0.156853,-0.137619,-0.092146,-0.000909,-0.052111,-0.018807,-0.122847,-0.061890,-0.073335,-0.008928,-0.074421,0.789435,0.027270) * L5_9 + mat4(-0.052833,-0.054341,-0.000964,-0.085136,-0.103395,-0.242987,-0.184925,-0.066989,-0.001847,0.056280,0.348480,-0.012334,-0.002129,-0.403348,-0.280157,0.236172) * L5_10 + mat4(-0.038988,-0.189041,0.395634,0.005495,-0.030905,0.157117,0.360051,-0.070807,-0.117538,0.113426,-0.207619,0.015391,0.132364,0.039181,0.805001,-0.226413) * L5_11 + mat4(-0.097686,-0.128486,-0.164887,0.090124,-0.000479,-0.092346,0.099034,0.155462,0.018250,0.158127,-0.380106,-0.133088,-0.075900,-0.141787,0.080094,-0.133953) * L5_12 + mat4(-0.100100,-0.063381,0.163861,0.244679,0.047510,-0.022190,0.694075,-0.178424,0.023696,0.058518,-0.288579,-0.006646,0.114456,-0.058619,-0.138666,-0.056370) * L5_13 + mat4(0.043193,0.078921,-0.097667,0.039160,0.071465,0.056297,0.106513,0.107806,0.001158,0.143745,0.423374,-0.064487,0.121085,0.389156,-0.533934,-0.090483) * L5_14 + mat4(0.018713,0.072906,0.179993,-0.105753,0.043838,0.067682,0.023780,-0.044137,0.134687,-0.082366,-0.259546,-0.039533,0.147810,0.020576,-0.605770,0.110230) * L5_15 + vec4(0.664626,0.407116,-0.001605,0.038688)));\nvec4 L6_6 = sin((mat4(0.144158,-0.035640,0.085950,0.000106,0.121431,0.009670,-0.088956,-0.042796,0.144649,-0.121399,-0.164027,-0.075416,-0.017034,-0.021925,0.050734,0.115792) * L5_0 + mat4(-0.056019,0.230406,0.315910,-0.227824,-0.300323,-0.116258,0.031894,-0.014354,-0.177306,-0.019111,0.099057,-0.069548,-0.071155,0.010494,0.025659,-0.062985) * L5_1 + mat4(-0.141207,-0.030088,-0.025162,-0.011629,0.046150,-0.335862,-0.258497,-0.394649,0.387946,-0.051507,-0.067957,0.072359,-0.049010,-0.042931,-0.172294,-0.122716) * L5_2 + mat4(0.013756,-0.009678,-0.095867,0.018937,-0.334090,0.037797,-0.106073,0.020041,0.151854,0.017471,-0.100480,0.068356,-0.166882,-0.119152,-0.034882,0.004607) * L5_3 + mat4(-0.041902,0.080172,-0.059261,-0.016528,-0.105801,-0.051964,0.003952,-0.063641,0.353065,0.039081,-0.084035,-0.080734,-0.161008,-0.014754,-0.120069,-0.021346) * L5_4 + mat4(0.702521,0.144433,0.445460,-0.036462,-0.000043,0.037750,-0.151718,-0.122053,0.066854,-0.104584,0.116963,-0.081602,0.123969,0.029307,-0.056654,-0.031358) * L5_5 + mat4(-0.249406,-0.049033,0.045099,-0.000124,0.334373,0.090787,0.054547,0.032631,-0.313524,-0.023866,0.257610,-0.088772,0.019117,0.005035,0.019392,0.125713) * L5_6 + mat4(-0.104658,0.039908,0.003109,0.074925,-0.113134,0.040495,0.034160,-0.062198,-0.210422,-0.003777,-0.008056,0.020754,0.416587,-0.086445,0.063048,0.080755) * L5_7 + mat4(-0.428381,-0.002661,-0.129715,0.056518,0.031653,0.133088,0.132725,-0.062655,0.005162,-0.206754,0.076710,-0.005218,0.110170,-0.079297,0.220105,0.090071) * L5_8 + mat4(-0.159928,0.072347,-0.134189,0.041005,0.093904,-0.030225,-0.057935,0.026762,0.406482,0.020574,0.024381,-0.031602,0.009903,-0.101598,0.128361,-0.101310) * L5_9 + mat4(0.084962,-0.000174,-0.096177,-0.025280,0.328063,-0.098215,-0.175599,-0.075225,-0.206074,0.029547,0.060143,-0.093486,0.023376,-0.093947,-0.022548,-0.124661) * L5_10 + mat4(-0.002634,0.207832,-0.101822,0.036553,0.045256,0.099648,-0.220652,-0.074722,-0.164141,-0.162566,0.055130,-0.063679,-0.567717,0.551272,-0.113104,0.525511) * L5_11 + mat4(-0.021174,0.103162,-0.140817,-0.056595,-0.014096,-0.151236,0.209702,0.103431,0.078727,0.148683,0.038012,0.041760,0.253341,-0.044007,-0.171239,0.023770) * L5_12 + mat4(-0.338987,-0.214802,0.283282,0.180704,0.507255,0.104812,-0.179848,-0.146442,-0.006583,0.037509,0.028446,-0.042228,0.086320,-0.010889,-0.043006,0.118696) * L5_13 + mat4(0.125713,0.098685,0.193583,0.137054,0.048633,-0.034018,-0.005853,0.076727,0.354108,0.099055,-0.150383,0.048375,0.615793,-0.004844,0.191231,0.229124) * L5_14 + mat4(-0.079654,-0.059775,-0.082651,-0.006711,-0.114387,-0.002994,0.011080,-0.026142,0.158744,0.019041,0.020158,0.045412,0.331108,0.168442,-0.022351,0.248282) * L5_15 + vec4(-1.693029,0.208620,-0.530807,-0.644310)));\nvec4 L6_7 = sin((mat4(0.078719,-0.343127,0.040065,-0.068246,0.142361,-0.156128,0.098321,0.005602,-0.075322,0.223274,0.118458,-0.014994,0.093172,0.064923,0.008874,0.009525) * L5_0 + mat4(-0.395805,0.052664,0.724089,0.248992,0.115228,0.384064,0.220926,-0.029869,0.049203,-0.133785,-0.057003,0.097905,-0.071845,-0.250186,0.366786,0.124970) * L5_1 + mat4(-0.017362,-0.032950,-0.241062,0.028964,0.092135,0.334033,-0.014802,0.277944,-0.403337,0.214867,0.031870,-0.041822,0.091575,0.016949,-0.084978,-0.124128) * L5_2 + mat4(0.070465,0.028912,-0.359186,0.205991,0.182540,-0.229395,-0.108340,0.319810,-0.032860,0.070020,0.211520,0.119491,-0.102746,-0.131793,0.088894,0.004286) * L5_3 + mat4(-0.069394,-0.126676,-0.248064,-0.031834,0.212994,-0.107594,-0.157388,0.110495,-0.005504,0.225278,-0.449437,-0.114111,0.031854,-0.016956,-0.350042,-0.084847) * L5_4 + mat4(-0.187787,0.098883,0.237590,-0.295182,0.188239,-0.207383,-0.373617,-0.226518,0.103307,0.315103,-0.039489,0.109498,-0.003983,-0.037624,0.313989,-0.063828) * L5_5 + mat4(0.058048,0.189785,0.191824,0.022268,0.015615,-0.074074,0.248954,0.063631,0.157345,-0.238365,0.190572,0.046429,0.182677,0.140064,-0.033653,0.140794) * L5_6 + mat4(-0.063978,0.138313,0.320242,0.003701,-0.099373,0.171417,0.137233,0.028178,0.091579,-0.141975,-0.035881,-0.008137,0.014461,0.348241,0.294683,0.019671) * L5_7 + mat4(0.044013,0.105944,-0.191248,-0.075156,-0.115997,-0.030038,0.249339,-0.080386,-0.085803,-0.074868,0.226944,-0.254856,0.023695,-0.128601,-0.260167,-0.395131) * L5_8 + mat4(-0.136852,0.255130,0.222737,0.129704,-0.156018,-0.068110,0.157881,-0.208250,-0.052455,-0.047003,0.305039,-0.100073,0.031497,-0.285563,-0.236221,0.023663) * L5_9 + mat4(0.098142,-0.003310,-0.194690,0.037731,-0.131297,0.281869,-0.437140,-0.277608,0.117440,-0.110770,0.256245,-0.042319,-0.236667,-0.098800,-0.626221,-0.199230) * L5_10 + mat4(-0.478077,-0.037299,0.365011,0.108213,0.126968,0.012559,0.114737,0.188674,0.119989,-0.368333,0.295999,-0.193837,0.523990,-0.473070,-0.031464,-0.164846) * L5_11 + mat4(0.026788,-0.324872,0.115572,0.086854,0.130351,-0.019142,0.025114,-0.071253,-0.149919,-0.260631,0.188532,0.086346,0.132218,0.114083,-0.324279,-0.033225) * L5_12 + mat4(0.215221,0.391981,0.106916,-0.020496,0.045239,0.734051,-0.483999,-0.238951,-0.054687,0.082459,-0.243284,0.037144,0.164201,0.751117,0.211780,-0.094832) * L5_13 + mat4(0.304262,0.078534,-0.139267,-0.032099,-0.063555,-0.074639,-0.299052,-0.075889,0.007874,0.339833,0.165462,-0.275213,0.019622,0.745092,0.226996,-0.063239) * L5_14 + mat4(-0.050388,0.099334,-0.055725,0.107524,0.295255,-0.273292,0.417553,0.013247,-0.090429,0.101177,-0.030049,-0.243541,-0.093351,0.957122,0.466175,-0.182959) * L5_15 + vec4(-0.220473,0.029384,0.181610,-0.359810)));\nvec4 L6_8 = sin((mat4(-0.010746,0.035781,0.295398,0.004100,-0.021445,0.033070,-0.047002,0.024363,0.016807,0.041655,-0.034800,-0.100509,-0.000894,-0.005262,0.065984,-0.022869) * L5_0 + mat4(-0.015002,0.023677,-0.460370,-0.198172,0.029414,-0.063277,-0.141422,-0.228822,0.021625,0.059895,0.032594,0.106098,0.026324,0.013478,0.152974,0.061441) * L5_1 + mat4(-0.011913,0.022380,-0.024540,0.088167,-0.008367,-0.092461,0.110077,-0.116900,0.006682,-0.020831,0.141998,0.062356,-0.005875,-0.027955,0.119431,0.088739) * L5_2 + mat4(-0.020410,0.037551,0.265739,-0.014334,-0.010530,0.000188,-0.072207,0.000445,0.009630,-0.069630,-0.030501,-0.140785,-0.032124,0.009408,-0.065246,0.149102) * L5_3 + mat4(0.008681,0.006818,-0.039234,-0.125065,-0.017304,-0.018633,-0.021631,-0.067762,-0.016949,-0.009383,-0.287427,-0.026307,-0.017945,-0.044833,0.106235,0.072551) * L5_4 + mat4(0.019904,0.257304,0.271977,0.171013,0.003222,0.000534,-0.162723,0.041271,0.007295,0.019338,0.088299,0.041551,0.002982,0.015385,-0.051942,0.037402) * L5_5 + mat4(-0.028173,-0.027181,-0.008401,-0.111939,0.003438,0.050210,0.043535,-0.157729,0.000833,-0.009482,0.156642,-0.085673,-0.021592,-0.038299,0.038403,-0.212646) * L5_6 + mat4(0.012499,-0.034166,-0.018590,-0.047424,0.005502,-0.061128,-0.048305,-0.041710,-0.016164,0.015534,0.044279,0.056629,-0.031123,-0.010908,0.213336,-0.264199) * L5_7 + mat4(0.006001,-0.045022,-0.179889,0.188470,0.005763,-0.010587,-0.103853,-0.086662,-0.004246,0.100508,-0.062092,0.190802,0.011934,0.046637,-0.216085,0.157631) * L5_8 + mat4(-0.003343,0.039393,-0.098676,0.044860,0.009049,-0.051020,-0.237681,-0.021362,-0.020428,0.001948,-0.127384,0.001675,0.030261,0.010028,-0.072005,-0.053650) * L5_9 + mat4(-0.007702,-0.029496,0.008352,-0.046140,0.033635,-0.064697,-0.134330,0.155978,-0.008154,-0.000385,0.148860,-0.016341,-0.023426,-0.101353,0.087036,-0.126255) * L5_10 + mat4(-0.004074,-0.039078,0.399790,-0.255314,0.011694,-0.010848,-0.081002,0.121512,-0.026417,0.010661,0.020714,0.210654,-0.007129,-0.350068,0.184584,-0.106591) * L5_11 + mat4(-0.004220,-0.093039,-0.140073,-0.048364,0.004240,-0.034969,0.120431,0.002153,-0.017007,0.068428,0.163525,0.126948,-0.026322,0.041520,0.100463,0.113238) * L5_12 + mat4(0.007627,-0.022169,-0.246834,-0.065512,0.007720,-0.092121,0.287350,0.192809,0.009537,0.107462,0.081115,0.070259,-0.031932,0.013433,-0.180397,-0.109801) * L5_13 + mat4(0.015548,0.049628,0.045851,-0.004298,-0.009478,0.085672,0.084847,0.114560,-0.012722,0.005965,0.317124,0.039311,0.026811,0.104188,-0.109982,-0.216985) * L5_14 + mat4(-0.006510,0.035626,-0.013507,0.156376,0.009804,-0.015631,0.101268,0.049100,-0.029224,0.184016,-0.057182,0.141323,0.003645,0.085758,-0.120810,0.060533) * L5_15 + vec4(0.019434,0.181403,-0.812998,-0.351593)));\nvec4 L6_9 = sin((mat4(-0.068285,-0.009013,0.155743,-0.089438,-0.065437,0.006914,0.364105,-0.066415,-0.046876,0.004742,-0.086084,0.056625,0.144902,-0.000157,0.146822,0.018480) * L5_0 + mat4(-0.225538,0.010731,-0.001621,0.519786,0.026486,0.016622,0.151304,0.078303,0.018607,0.005313,-0.055533,0.007053,-0.254805,0.017793,0.101050,0.087312) * L5_1 + mat4(0.076017,-0.011780,0.172272,-0.032537,-0.001263,-0.020876,-0.203529,0.003658,0.086783,-0.001717,0.218635,0.138338,0.156750,0.008124,0.123805,-0.143463) * L5_2 + mat4(0.130034,-0.015671,-0.167177,-0.134958,0.240090,-0.009273,-0.530060,-0.309176,-0.007154,0.019745,0.256041,0.100914,0.031700,-0.028492,0.447452,0.113398) * L5_3 + mat4(-0.098885,-0.003989,0.048455,-0.135686,-0.063443,-0.013599,-0.014287,-0.293245,-0.269715,0.001757,0.016708,0.046892,0.028043,-0.010635,-0.174946,0.020022) * L5_4 + mat4(-0.591967,0.018893,-0.357940,0.496578,0.003362,-0.011934,-0.470309,-0.059739,-0.083934,-0.013533,-0.184623,-0.102097,-0.113032,-0.019565,0.035362,0.006120) * L5_5 + mat4(0.098191,-0.034371,0.103863,0.053850,-0.005630,0.003324,0.316605,0.337997,-0.152150,-0.003221,-0.039114,-0.172385,0.123526,-0.011654,-0.209564,-0.294399) * L5_6 + mat4(-0.079940,0.028448,-0.134091,-0.107964,0.117750,0.012527,0.157133,0.264577,0.061994,0.012828,0.224752,0.006253,0.263795,-0.020931,0.035307,-0.085605) * L5_7 + mat4(-0.110243,0.002747,-0.226013,0.077411,0.077242,0.004604,0.390950,0.069985,-0.019698,0.010933,0.612194,0.365158,-0.224745,0.003303,0.518173,0.247317) * L5_8 + mat4(0.161383,-0.001364,-0.197314,0.027916,-0.022801,-0.005658,0.509042,-0.128987,-0.249847,-0.020092,-0.221680,-0.125719,-0.063835,0.036621,0.188489,0.199979) * L5_9 + mat4(0.011332,0.004487,0.414862,-0.147396,-0.257996,0.016754,-0.131374,-0.001197,0.041471,0.001762,0.072677,-0.133057,-0.315742,-0.001788,-0.100308,-0.091333) * L5_10 + mat4(0.277801,-0.004624,-0.020078,-0.184191,-0.068708,0.006462,-0.339542,-0.142443,0.033256,-0.020034,-0.168231,-0.096548,-2.137689,0.008433,0.124941,-0.137262) * L5_11 + mat4(0.011487,0.013259,-0.076391,-0.152062,0.151323,-0.012545,-0.169490,0.061589,-0.244346,0.001223,0.394516,0.046446,-0.091179,-0.019241,0.029206,0.266544) * L5_12 + mat4(0.181766,0.021325,-0.094557,-0.156971,-0.136301,0.004757,-0.275363,0.029892,-0.059434,0.014659,0.012194,-0.129446,-0.180019,-0.000029,-0.184973,0.324488) * L5_13 + mat4(0.172597,0.020561,-0.128663,0.196370,0.062342,-0.008092,-0.361790,0.115432,-0.455236,0.008718,-0.384508,0.223304,-0.115689,0.000215,0.123621,0.027058) * L5_14 + mat4(-0.178406,0.011403,0.154766,-0.062710,-0.123193,0.016354,-0.285720,-0.190153,0.117846,-0.012415,-0.262288,0.257488,0.181623,0.018698,-0.204495,-0.002342) * L5_15 + vec4(0.392869,0.000974,-0.808155,-0.381234)));\nvec4 L6_10 = sin((mat4(0.234669,0.057074,-0.024743,-0.312453,0.359394,0.032820,0.029663,0.078334,0.234287,-0.047915,0.039022,0.247976,0.237193,0.053456,-0.041884,-0.463391) * L5_0 + mat4(0.290975,-0.519679,0.297525,0.606982,-0.333203,0.077436,0.146433,0.088355,-0.100660,0.144733,-0.016871,0.231879,-0.532827,0.032433,-0.088949,0.229533) * L5_1 + mat4(0.152314,0.018769,0.019751,-0.004449,0.023928,0.006207,-0.051584,0.284699,0.073610,-0.115592,-0.189433,-0.031825,-0.149038,0.145760,-0.063391,-0.026364) * L5_2 + mat4(-0.309434,0.042867,-0.049643,-0.388601,-0.053043,0.051937,-0.023931,0.304061,0.420187,-0.177656,0.027990,0.136990,0.047741,-0.112112,-0.056525,-0.166920) * L5_3 + mat4(0.143298,-0.070640,0.028402,0.041842,0.094357,0.100708,0.057006,-0.130064,-0.295786,-0.110459,0.111404,-0.269028,-0.204446,0.189526,0.090708,-0.420480) * L5_4 + mat4(-0.545839,0.162862,-0.016106,0.047896,-0.044740,0.035745,-0.065076,-0.315606,-0.227023,0.110176,0.002291,0.121521,0.192688,-0.026141,0.046260,-0.276292) * L5_5 + mat4(-0.016678,-0.038183,0.136155,0.045142,0.140084,-0.336286,-0.171276,0.112050,0.080801,0.051242,-0.041291,0.429881,0.006929,0.083763,-0.038563,0.011621) * L5_6 + mat4(0.278908,-0.050759,-0.004672,0.014230,0.238039,-0.064137,0.003570,-0.325642,0.009895,-0.048890,0.023868,-0.355832,0.278875,-0.009057,-0.134005,-0.122828) * L5_7 + mat4(-0.302767,0.191502,-0.053334,0.496147,0.191790,-0.029621,0.110525,-0.150843,0.389525,-0.026276,-0.092943,-0.501433,-0.193117,0.208561,0.076045,0.030479) * L5_8 + mat4(-0.448083,0.068286,0.022746,0.165650,0.442970,-0.152013,-0.078375,-0.058144,-0.007127,-0.235933,-0.048853,0.188019,-0.065489,-0.138965,0.187231,-0.270127) * L5_9 + mat4(-0.144667,0.167117,-0.030067,0.046004,0.283431,0.015702,-0.006784,-0.040340,-0.027804,0.166838,-0.025030,0.287519,-0.322194,0.126061,0.080522,0.333169) * L5_10 + mat4(0.246155,-0.606789,-0.504499,0.044249,-0.084081,-0.098796,-0.010575,0.054036,-0.277982,0.318327,0.101150,0.041344,0.204281,0.181303,0.019072,-0.063814) * L5_11 + mat4(0.275273,-0.030927,0.155048,-0.170963,-0.185709,0.275083,0.154937,-0.121974,0.203505,0.384844,0.065341,0.669717,-0.412464,0.011810,-0.161788,-0.141550) * L5_12 + mat4(-0.111125,0.042395,0.103250,0.359378,-0.175085,0.418357,-0.046483,0.127550,-0.114834,0.042231,-0.065127,0.132542,-0.150727,-0.092547,0.023133,0.677951) * L5_13 + mat4(-0.674585,-0.001924,0.062883,-0.312436,-0.327736,-0.151813,-0.092186,-0.171188,-0.127107,0.017565,-0.137665,-1.008177,-1.011582,-0.322720,-0.006815,0.377572) * L5_14 + mat4(-0.283790,0.076188,0.006554,0.143398,-0.052131,0.105950,-0.006593,0.231264,-0.453699,0.114241,-0.116744,-0.037182,-0.523367,-0.033343,-0.237965,0.824722) * L5_15 + vec4(-0.462922,-0.748261,0.267589,0.301054)));\nvec4 L6_11 = sin((mat4(-0.198035,-0.268756,-0.000675,-0.027187,-0.098565,0.035520,0.004711,0.002616,0.267827,0.209399,-0.007713,0.019607,-0.036835,0.279996,0.020934,0.014590) * L5_0 + mat4(0.313150,0.047792,0.014123,0.006035,0.114889,0.034334,-0.005930,0.035294,-0.032929,0.036036,-0.030775,0.005924,-0.023575,0.119782,0.014395,0.022198) * L5_1 + mat4(-0.036252,-0.009069,-0.019535,0.014792,0.094904,0.515211,-0.014871,-0.004011,-0.116581,-0.537651,-0.006771,0.004322,-0.150767,-0.768587,0.032216,-0.015008) * L5_2 + mat4(-0.103937,-0.080955,0.001078,-0.017892,0.259965,0.497370,-0.015992,0.019975,0.346211,0.108434,0.022171,0.001781,-0.092043,0.060411,0.019758,-0.012718) * L5_3 + mat4(0.010617,-0.302939,0.004717,0.025333,-0.113144,0.172978,0.000300,-0.018843,-0.116879,0.367981,0.015292,-0.005565,-0.059193,0.068215,-0.001902,-0.041230) * L5_4 + mat4(-0.478660,-0.488128,-0.005308,0.017184,-0.218960,0.234801,0.003880,0.017097,-0.163422,-0.042595,0.009304,0.011011,-0.060507,-0.235153,-0.007925,0.007889) * L5_5 + mat4(0.407332,-0.390094,0.017505,0.004992,-0.167593,-0.407873,0.019861,0.002543,-0.002599,0.295022,-0.002856,-0.003385,0.042151,-0.170731,-0.008230,0.002185) * L5_6 + mat4(0.090622,0.202877,0.006484,0.000215,0.295710,-0.180467,0.013263,-0.025411,0.140391,0.012129,0.000809,0.002431,-0.108627,-0.242963,-0.005563,-0.034540) * L5_7 + mat4(0.198239,0.061209,-0.014924,0.005428,0.169575,0.250541,-0.012990,0.028265,-0.099022,0.089644,0.012583,-0.012344,-0.335733,0.084686,-0.000908,0.039954) * L5_8 + mat4(-0.231966,0.297133,0.006542,-0.018232,-0.032381,-0.304882,-0.031869,0.004495,0.196323,0.244604,0.005646,-0.041167,0.139129,0.670051,0.006126,0.015519) * L5_9 + mat4(-0.054757,-0.393744,0.009046,0.004943,-0.163233,-0.100465,-0.030961,0.009848,0.002437,0.305761,0.008352,0.025003,0.099364,0.309441,0.010812,-0.031189) * L5_10 + mat4(0.526326,-0.408100,-0.018882,0.006305,0.074163,-0.103914,0.004507,0.002130,0.089879,-0.371380,-0.001950,-0.016538,0.112374,-0.038823,0.007028,-0.006728) * L5_11 + mat4(0.164206,-0.223447,-0.014869,0.003807,-0.076261,0.340114,-0.001495,-0.001678,-0.371935,0.484407,-0.001460,0.002338,-0.122560,-0.213676,0.014938,-0.005975) * L5_12 + mat4(0.275343,-0.362882,0.002913,-0.007588,-0.430713,0.116307,-0.029141,0.011329,-0.218148,0.202470,-0.010844,-0.006029,-0.134099,-0.077947,0.000525,-0.017491) * L5_13 + mat4(-0.223954,0.070724,0.004169,0.020414,-0.029317,0.077950,0.005907,-0.011151,-0.437324,0.015145,0.003914,0.018591,-0.236007,0.275181,-0.017293,0.030804) * L5_14 + mat4(0.104307,0.397262,-0.009350,0.003507,0.094001,-0.013402,-0.028305,0.024763,-0.216984,-0.115504,0.004818,-0.015564,0.111710,-0.538910,0.019236,-0.026553) * L5_15 + vec4(-0.451457,1.233368,-0.002147,0.027722)));\nvec4 L6_12 = sin((mat4(0.171792,-0.164749,-0.013521,0.010499,-0.124741,0.005546,-0.005081,-0.080234,-0.093296,0.395597,0.001322,0.267955,-0.072329,-0.042547,-0.002542,-0.102250) * L5_0 + mat4(0.584021,-0.310387,0.010576,0.187956,0.446437,-0.101865,0.004887,0.007934,-0.151211,-0.106608,-0.003555,-0.066196,0.333619,0.040754,0.022289,0.081897) * L5_1 + mat4(-0.018206,0.050357,0.014884,-0.088531,-0.546054,0.107063,-0.023189,-0.019939,-0.298346,0.130016,0.006441,-0.106134,-0.391737,0.015602,-0.008495,-0.031134) * L5_2 + mat4(-0.115342,-0.126179,-0.022059,0.065599,-0.011007,0.095983,-0.006617,-0.157356,-0.208999,0.136691,0.007311,-0.023072,0.076604,0.116706,-0.023068,0.028142) * L5_3 + mat4(-0.083102,-0.008994,0.021125,-0.008710,0.056026,-0.079550,-0.025153,-0.059214,-0.221678,-0.046623,0.001660,0.156279,0.137337,0.098407,-0.032196,0.183762) * L5_4 + mat4(0.348831,0.098365,0.006467,-0.086691,0.019884,0.176404,-0.002320,-0.062242,0.147299,-0.103756,0.010136,-0.076561,-0.205111,0.016760,0.001596,0.056827) * L5_5 + mat4(0.283352,0.082914,-0.000143,0.017380,0.170808,-0.206589,0.002505,-0.270770,0.007395,-0.146652,0.002414,-0.030033,0.500691,-0.109140,-0.005755,0.081168) * L5_6 + mat4(0.291931,0.097607,0.009233,0.108689,0.025134,0.063860,-0.003876,-0.123778,0.082142,0.006642,0.029367,-0.006243,0.153470,0.058383,-0.022593,0.096363) * L5_7 + mat4(0.015616,0.348284,-0.007726,0.012750,0.022559,0.306325,0.010020,0.018444,-0.442701,0.019559,0.009885,0.214266,-0.069571,0.159630,0.004538,0.220120) * L5_8 + mat4(-0.056130,-0.369946,0.006170,-0.298636,-0.396529,0.159809,-0.020007,0.073759,-0.169848,0.176298,-0.012792,0.231176,-0.377697,-0.012652,0.005540,0.065722) * L5_9 + mat4(-0.259415,0.061891,0.010939,0.011856,-0.045606,0.080161,0.025985,-0.306396,-0.124059,-0.143238,0.012834,0.003576,-0.084709,0.382384,-0.013135,0.367303) * L5_10 + mat4(0.128007,0.493130,-0.019575,-0.778384,0.034534,-0.141966,0.024015,0.043183,0.049847,0.073954,0.015277,0.225781,0.143918,0.248715,0.004011,0.538709) * L5_11 + mat4(-0.083909,0.031110,-0.000678,0.012772,0.071491,-0.105743,0.001355,-0.053246,-0.079828,-0.108801,0.012759,0.048532,-0.183798,0.077613,-0.019087,0.053204) * L5_12 + mat4(0.138433,-0.114795,0.006156,0.009092,0.018870,0.004642,-0.009224,-0.199304,0.211110,0.036569,-0.017736,0.068463,0.178591,0.066744,-0.004728,0.336142) * L5_13 + mat4(0.219656,-0.109032,0.028601,-0.182085,0.322539,0.011652,-0.011381,0.041624,0.183457,0.045599,0.026006,0.220576,0.526693,0.069550,0.012942,0.370319) * L5_14 + mat4(0.001336,-0.264675,0.011124,-0.225650,-0.085988,-0.064653,-0.009066,-0.010310,-0.235033,0.125433,-0.014670,-0.061700,0.383727,0.218592,0.006265,-0.370344) * L5_15 + vec4(0.791870,0.252722,0.000578,-1.327955)));\nvec4 L6_13 = sin((mat4(-0.040621,0.086190,0.015237,0.002748,-0.133429,0.064460,0.037140,-0.012213,-0.045996,0.177014,-0.234625,-0.014212,-0.041312,0.062164,0.062187,0.007740) * L5_0 + mat4(0.020462,0.606024,-0.305912,0.002259,0.117200,0.038626,0.170793,0.007579,0.125666,-0.093153,0.032443,0.011398,-0.042204,-0.366868,0.092534,-0.013008) * L5_1 + mat4(-0.069877,-0.021824,-0.147231,-0.023703,0.046401,0.342010,-0.208977,0.004087,-0.064546,0.130120,-0.106807,-0.008086,0.006759,-0.165287,0.156717,-0.012149) * L5_2 + mat4(-0.029912,-0.048808,0.037051,-0.009929,-0.036094,-0.086397,0.079479,0.026631,0.024089,0.122238,-0.128294,0.009696,0.049092,-0.201203,-0.029161,-0.027824) * L5_3 + mat4(-0.046452,-0.020922,0.024418,0.039893,-0.036349,-0.015420,0.106705,-0.030536,0.078491,0.390728,-0.083441,-0.011328,-0.057043,0.105041,0.061507,0.016136) * L5_4 + mat4(0.316297,-0.074909,0.010825,0.010156,-0.081767,0.300960,0.234698,-0.018656,-0.074889,-0.135666,0.123790,0.016761,-0.010848,0.057307,-0.041471,-0.006157) * L5_5 + mat4(0.005472,-0.017924,0.048590,-0.004767,0.164822,0.127068,-0.023275,0.033571,-0.180676,-0.157697,-0.025393,-0.008803,-0.007837,-0.116501,0.025216,-0.004219) * L5_6 + mat4(-0.114826,0.074494,0.042233,0.019752,0.163573,0.063450,-0.096987,-0.032281,0.043144,-0.057862,0.060188,0.001646,-0.019397,0.087701,0.174898,-0.043646) * L5_7 + mat4(-0.068435,0.121018,0.108865,0.009956,0.137566,0.028373,-0.018016,0.006275,0.078055,-0.124673,-0.051531,0.007347,-0.030226,0.055798,0.211840,-0.007091) * L5_8 + mat4(0.044192,-0.101045,-0.028668,-0.008179,-0.058910,0.230089,-0.041525,-0.002894,-0.115662,0.168460,-0.201697,-0.018526,0.163496,-0.007955,-0.041577,0.021523) * L5_9 + mat4(-0.086293,0.160866,0.230840,-0.016809,0.044701,-0.045509,0.068330,-0.002007,-0.018312,-0.095055,-0.111193,0.000726,-0.053100,0.176881,0.227868,0.017235) * L5_10 + mat4(-0.057492,-0.473252,-0.200596,0.003188,-0.072295,0.037222,-0.076782,0.027832,0.004301,0.091379,0.192435,-0.022427,-0.107659,0.261901,0.125534,-0.033432) * L5_11 + mat4(0.047238,0.034112,0.032867,0.013223,0.104192,-0.099700,0.106781,-0.020504,-0.077553,-0.122140,0.220341,0.011890,0.077343,0.171767,0.066732,-0.009931) * L5_12 + mat4(0.028788,-0.130281,-0.080438,0.014419,-0.019201,0.540817,0.428922,-0.004214,-0.045807,0.010293,-0.184887,0.014868,0.050903,-0.020209,0.093056,0.003187) * L5_13 + mat4(0.070440,-0.134195,0.204321,0.045254,-0.022777,-0.141118,-0.267269,-0.014076,-0.133420,-0.259280,-0.040910,0.017759,0.059992,0.551264,-0.061678,-0.014368) * L5_14 + mat4(0.058310,0.005443,-0.018005,0.009189,-0.074442,0.049996,-0.003823,0.017373,0.062549,-0.110818,0.001862,0.000572,-0.145736,-0.069603,-0.234819,-0.003206) * L5_15 + vec4(-0.223179,1.833517,-0.067549,-0.007298)));\nvec4 L6_14 = sin((mat4(-0.003677,0.111224,-0.162971,0.000778,0.004826,0.287192,-0.025632,-0.012068,-0.020589,0.197723,-0.881868,-0.017283,-0.006221,-0.132822,-0.016724,-0.005436) * L5_0 + mat4(-0.011865,-0.293752,0.030897,-0.006116,0.005444,-0.113156,0.210772,0.014290,0.012612,-0.010489,0.222038,-0.011856,-0.046164,0.234850,0.315368,-0.013004) * L5_1 + mat4(-0.018890,0.221291,-0.023198,0.003857,0.049735,0.244167,0.104683,0.003883,0.002193,-0.349731,0.019885,0.010382,-0.001541,-0.332064,0.212156,-0.024588) * L5_2 + mat4(0.011446,0.081057,0.367443,-0.020054,-0.016023,-0.068577,0.169073,0.012504,0.018247,0.200539,-0.160268,0.003697,0.011179,-0.233349,-0.171215,-0.035044) * L5_3 + mat4(-0.013717,0.415683,0.174069,-0.008949,0.007120,-0.079219,-0.009441,-0.020037,0.000507,-0.409985,-0.138937,0.004305,0.021699,-0.348558,0.055138,-0.000629) * L5_4 + mat4(0.003340,0.111177,-0.280730,0.005257,0.015198,0.440738,-0.253103,0.005443,-0.005537,-0.051658,0.022256,0.009371,-0.004188,-0.410775,-0.068234,0.008750) * L5_5 + mat4(-0.004954,0.264273,0.152673,-0.018400,0.009586,0.894229,-0.204944,0.006146,-0.005208,0.825510,-0.054755,0.001782,0.008345,-0.142115,0.349877,0.002959) * L5_6 + mat4(-0.016082,-0.034503,-0.099459,-0.022585,-0.013442,0.336180,0.089943,0.004495,-0.003594,0.301711,0.049282,0.010228,-0.019582,0.461927,-0.138111,-0.012090) * L5_7 + mat4(0.005230,0.539918,-0.409986,-0.001819,0.001315,-0.412321,-0.084653,0.005716,0.001214,-0.252555,0.122370,0.001143,-0.010119,0.362875,-0.575451,-0.024432) * L5_8 + mat4(0.021246,0.366971,0.230220,0.028263,-0.009661,0.360854,-0.309368,0.024443,0.008587,0.183685,-0.586792,-0.006818,-0.003497,-0.054277,-0.282421,0.006444) * L5_9 + mat4(-0.014436,0.185072,-0.091255,-0.010651,0.007002,0.771598,-0.387875,-0.000729,0.024498,0.203417,-0.103201,-0.015105,-0.003186,-0.021514,-0.797162,0.012659) * L5_10 + mat4(0.008734,0.786866,-0.835394,-0.009640,0.016805,-0.202336,-0.076197,0.016025,-0.007711,-0.266526,0.242332,-0.000382,-0.018976,0.726778,-0.365339,0.011805) * L5_11 + mat4(0.013321,0.037005,-0.260214,-0.001433,-0.012612,-0.101659,0.047911,0.005774,0.025265,0.688609,-0.442744,-0.003164,-0.003046,-0.068635,-0.143255,-0.025190) * L5_12 + mat4(-0.001411,-0.249912,0.358658,0.018715,-0.007855,0.288761,0.226330,0.008459,0.008019,-0.036817,0.340657,-0.001667,0.024177,-0.636537,-0.171557,0.022770) * L5_13 + mat4(0.012590,0.374035,-0.167275,-0.016940,-0.011180,-0.337648,0.357453,0.004296,0.027529,-0.030770,-0.433962,0.019848,-0.006449,-0.050696,-0.230485,0.008824) * L5_14 + mat4(-0.014081,-0.394580,0.608040,0.037242,0.021650,0.047944,-0.151758,0.014055,-0.001018,-0.016510,0.363519,0.007915,0.003785,0.392424,0.576883,-0.027115) * L5_15 + vec4(-0.025264,0.159042,-0.234433,-0.006863)));\nvec4 L6_15 = sin((mat4(0.187068,0.032107,-0.138101,0.073484,-0.030331,-0.142180,-0.075147,0.077357,0.064586,0.292589,0.193310,-0.091039,0.058176,0.134753,0.019629,0.033746) * L5_0 + mat4(-0.303946,-0.040720,-0.194958,0.050056,0.311397,0.117415,-0.126234,0.007469,-0.016546,-0.250025,0.019791,0.017754,0.114518,-0.073934,-0.167186,0.231920) * L5_1 + mat4(0.034422,-0.037720,0.173293,0.054216,0.089654,-0.315280,0.130983,0.281623,0.149964,0.092626,-0.167950,-0.141285,0.124756,-0.638725,0.072687,0.006883) * L5_2 + mat4(-0.020435,-0.070200,-0.085771,-0.184983,0.172305,-0.379099,0.025331,-0.029167,-0.119444,0.176056,0.018419,0.041424,-0.048829,0.251008,-0.134158,-0.164950) * L5_3 + mat4(-0.052452,-0.039008,-0.230712,0.101557,0.059219,0.040358,0.003670,0.005309,0.032777,0.223870,0.030359,-0.125821,0.120696,-0.065102,0.210269,0.070917) * L5_4 + mat4(-0.185256,-0.349532,-0.015499,0.126754,0.325202,0.173213,-0.316024,-0.169271,-0.167781,-0.356102,0.012951,-0.028467,-0.073946,-0.084114,0.117183,-0.073269) * L5_5 + mat4(0.202530,-0.112849,-0.123155,0.000550,-0.041813,-0.165400,-0.280063,-0.050130,-0.001337,0.198891,-0.170564,0.155563,0.130771,0.167782,-0.033224,-0.156542) * L5_6 + mat4(-0.069195,0.362747,-0.092297,-0.164397,0.130833,0.120431,0.025940,-0.036734,0.033897,0.257276,-0.112513,0.163244,-0.212027,0.413709,-0.084407,-0.069599) * L5_7 + mat4(0.362466,-0.189233,0.251953,0.087575,-0.076069,-0.063416,0.016965,0.188682,0.295597,0.260422,-0.132349,-0.351771,0.200122,0.601144,-0.058505,-0.046759) * L5_8 + mat4(0.095622,-0.030093,-0.037105,0.082089,-0.023787,0.058682,0.039054,-0.202481,-0.019967,0.147573,-0.158874,0.173356,-0.051121,-0.238160,-0.033932,0.108384) * L5_9 + mat4(-0.047422,0.084096,-0.116046,-0.024918,-0.031981,-0.612484,-0.151107,0.119296,0.217254,-0.069056,0.163241,0.011045,-0.071746,0.287996,0.142237,-0.014032) * L5_10 + mat4(-0.408763,0.007321,-0.414258,0.068549,0.117325,0.257046,0.028042,-0.259757,0.318126,0.297516,0.137698,0.085861,-1.649611,-0.916138,-0.046555,0.312599) * L5_11 + mat4(-0.082017,0.049783,-0.037640,0.073923,0.221545,-0.080342,0.271117,0.097607,-0.085996,-0.516911,0.096315,0.129533,0.163624,0.063657,-0.138531,-0.200438) * L5_12 + mat4(0.156848,0.382011,0.226600,-0.248371,-0.030434,0.901126,-0.182281,-0.273199,0.181131,0.295649,0.116205,0.019459,-0.104109,-0.138442,-0.297411,-0.225165) * L5_13 + mat4(0.000875,0.054314,-0.102508,0.095797,0.204197,0.188928,0.174093,0.079440,-0.174778,-0.187291,-0.188381,0.327167,-0.069841,0.472468,-0.352085,-0.573988) * L5_14 + mat4(0.022829,-0.281281,0.049636,0.113610,-0.151792,-0.095954,0.175269,0.188108,-0.085092,0.046038,-0.124982,-0.001447,-0.006233,0.219726,-0.009616,-0.669910) * L5_15 + vec4(-1.639029,0.263486,-0.609612,-1.223745)));\nvec3 F_0 = (mat4x3(0.001065,0.000205,0.000747,0.009754,0.014561,0.013024,-0.000935,0.000942,0.001070,0.061864,0.063584,0.060094) * L6_0 + mat4x3(0.001609,0.000905,0.000847,0.000670,-0.001564,-0.001614,-0.051051,0.029504,0.030698,0.014533,0.018718,0.019758) * L6_1 + mat4x3(0.001065,0.000291,0.000071,-0.000402,0.001208,0.001232,0.010304,0.010630,0.011851,-0.105404,-0.117656,-0.121062) * L6_2 + mat4x3(-0.000023,0.002194,0.003707,-0.090000,-0.002248,0.014468,0.001631,0.003531,0.002634,-0.024781,-0.028418,0.044166) * L6_3 + mat4x3(0.001921,0.000138,0.002738,-0.011914,-0.012070,-0.012964,0.000711,-0.000796,-0.000854,0.010046,-0.030669,0.022478) * L6_4 + mat4x3(-0.102663,-0.106305,-0.109612,-0.029439,-0.032284,-0.031278,0.006506,0.006171,0.007610,-0.012605,-0.025995,0.045066) * L6_5 + mat4x3(0.016073,-0.004990,0.000060,-0.059780,-0.055419,-0.063534,-0.010042,0.028158,-0.015035,-0.098568,-0.095796,-0.110031) * L6_6 + mat4x3(-0.000021,-0.010279,0.012585,-0.005009,-0.005629,-0.006816,-0.006339,-0.005910,-0.006642,-0.019697,0.008125,0.005878) * L6_7 + mat4x3(-0.000565,-0.001729,-0.002462,0.032571,-0.126623,0.080380,-0.040112,-0.034079,-0.040235,-0.044386,0.018853,0.013772) * L6_8 + mat4x3(-0.013087,-0.006744,0.005786,-0.000532,-0.001994,-0.002454,0.004283,0.003743,0.004324,0.007056,0.006584,-0.012651) * L6_9 + mat4x3(0.005637,0.006921,0.006362,-0.029549,0.009981,0.008623,0.071032,0.086544,0.095335,-0.003816,-0.003376,-0.003384) * L6_10 + mat4x3(0.020121,-0.009092,-0.005407,-0.004572,-0.004687,-0.006594,-0.000345,-0.000030,0.000065,0.003278,-0.002117,-0.002133) * L6_11 + mat4x3(-0.008559,-0.008738,-0.009671,-0.011427,0.004272,0.001133,0.000957,-0.001230,-0.001448,0.002832,0.008661,-0.008128) * L6_12 + mat4x3(0.002698,-0.031402,0.037021,0.010207,0.005391,-0.012708,0.024694,-0.006983,-0.010273,0.000828,-0.000895,0.000501) * L6_13 + mat4x3(0.000430,0.002001,0.001864,-0.002741,-0.003082,-0.004806,-0.003643,-0.003800,-0.002567,0.000495,-0.000158,-0.000259) * L6_14 + mat4x3(-0.009517,-0.000708,0.019167,-0.006973,-0.007648,-0.006461,0.038559,-0.009137,-0.013750,-0.034836,-0.041827,-0.045657) * L6_15 + vec3(-0.183205,-0.203745,-0.154321));\nreturn F_0;\n}\n\n#pragma optimize(on)\n\n\n\n\n\n\n\n\n", "cube_a_code": "//YCZ:\n//Version2 - 2022.06.27(Tokyo time)\n\n//*************About Setting******************//\n//No need additional setting. Time axis is as same as the offical one\n\n//*************About Exposure******************//\n//Exposure is under Image\n\n//*************About Time******************//\n//If time shift is needed for measurement, plz replace all iTime variable with desired time value(included in Buffer A and Image)\n\n//*************About Measurement******************//\n//SSIM data example(under exposure of 2):\n//Frame0(t = 0.0) ssim 0.961\n//Frame1(t = 1.0) ssim 0.963\n//Frame2(t = 5.0) ssim 0.946\n\n//(idk how my render will be measured with gt.\n//And this Shader will take around 6 seconds to compile (gtx 2070, cpu i7 11xxxx)\n//In order to avoid problems such as graphics card model browser model conflict or sth.\n//if the value is significantly lower than this value means that this shader is not compiled correctly, \n//please change the browser, \n//thank you very much ^_^\nvec4 GetOneFace3(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(uv.x,uv.y)-1.0,1.0f).xzy);\n}\nvec4 GetOneFace4(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(1.0-uv.x,1.0-uv.y)-1.0,-1.0f));\n}\nvec4 GetOneFace5(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(uv.x,1.0-uv.y)-1.0,1.0f));\n}\nvec4 GetOneFace2(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(uv.x,1.0 - uv.y)-1.0,-1.0f).xzy);\n}\n\n/*\nvec4 gi(vec3 position, int matrixindex)\n{\nvec4 xx0 = ...\nvec4 xx1 = ...\n\nif(matrixindex == 0)\n{\n    return ...;\n}\nelse if()\n{\n    return ...;\n}\n...\n}\n*/\n#pragma optimize(off)\nvec4 Lightmap_Half_LRBU22(const vec3 uv_0, const vec3 uv_1, const int BlockIndex)\n{\nvec4 L0_0 = sin(20.000000 * (mat3x4(0.170390,-0.170097,0.164968,0.123155,-0.151278,-0.151455,0.134574,-0.067733,0.046621,0.127368,-0.121744,-0.194458) * uv_0 + mat3x4(-0.001888,-0.095432,0.149652,0.045661,-0.243498,-0.005227,0.323170,0.136361,-0.023419,-0.029139,-0.144466,-0.038378) * uv_1 + vec4(0.030905,-0.103096,0.094443,0.103860)));\nvec4 L0_1 = sin(20.000000 * (mat3x4(0.195213,-0.169588,-0.019275,-0.107222,0.242536,0.123477,-0.118290,-0.165524,0.175480,-0.052317,-0.112054,-0.239879) * uv_0 + mat3x4(0.030467,0.118639,0.008950,-0.101330,0.179717,0.018435,-0.001657,-0.147945,0.085572,0.052373,-0.043520,-0.222877) * uv_1 + vec4(0.095072,0.171369,-0.222436,-0.149277)));\nvec4 L0_2 = sin(20.000000 * (mat3x4(-0.185945,-0.159686,0.157336,-0.196850,0.007617,0.268310,0.119113,-0.127662,0.195616,-0.001572,-0.016136,0.076980) * uv_0 + mat3x4(-0.180099,0.014940,0.142872,0.073714,-0.153861,0.293912,0.207690,-0.120819,0.221173,-0.054235,-0.089350,-0.119928) * uv_1 + vec4(0.077187,0.057265,-0.137031,-0.123624)));\nvec4 L0_3 = sin(20.000000 * (mat3x4(0.044345,-0.047004,-0.304288,-0.154379,-0.121365,-0.275763,-0.028574,-0.258531,-0.162072,-0.027719,0.012664,-0.209332) * uv_0 + mat3x4(0.024651,0.039449,0.025414,0.086427,-0.008856,-0.320501,0.018626,-0.131113,-0.202037,-0.048811,0.162611,-0.115633) * uv_1 + vec4(-0.149455,0.009924,0.073473,-0.231831)));\nvec4 L0_4 = sin(20.000000 * (mat3x4(-0.101210,-0.092816,0.026578,-0.218016,0.004578,-0.285596,0.250638,0.172556,0.214613,-0.216567,-0.043705,-0.173211) * uv_0 + mat3x4(-0.121487,-0.086819,-0.003248,0.034438,0.065617,-0.237647,-0.087017,-0.070907,-0.046699,0.135844,0.088148,0.097045) * uv_1 + vec4(-0.030630,0.061283,-0.042724,-0.115797)));\nvec4 L0_5 = sin(20.000000 * (mat3x4(0.126018,-0.198735,-0.173211,-0.158614,0.244065,-0.014585,0.019402,0.055723,-0.132648,-0.176362,-0.099171,-0.221049) * uv_0 + mat3x4(-0.011693,0.098070,-0.093099,0.048539,0.230221,-0.043356,0.072681,-0.117443,-0.044536,0.024465,0.083038,-0.143385) * uv_1 + vec4(0.019187,0.066200,-0.059012,0.091947)));\nvec4 L0_6 = sin(20.000000 * (mat3x4(0.000947,0.006200,0.053766,0.201405,0.000109,-0.119247,0.071087,-0.198424,-0.000109,-0.001258,-0.018427,0.137926) * uv_0 + mat3x4(0.080425,-0.192247,-0.164902,-0.108350,0.079008,-0.079160,0.171418,-0.165810,0.078307,-0.123942,-0.153628,-0.050664) * uv_1 + vec4(-0.157564,-0.196127,-0.035073,-0.097626)));\nvec4 L0_7 = sin(20.000000 * (mat3x4(0.098519,0.204170,0.026257,0.051425,0.195831,0.136695,0.129334,-0.151348,0.148729,0.195663,0.233894,-0.205229) * uv_0 + mat3x4(-0.127000,0.115016,0.119035,-0.136133,0.213383,-0.046283,0.023012,-0.186885,-0.157653,0.035738,0.213261,0.107116) * uv_1 + vec4(-0.013796,0.003580,-0.123000,-0.026820)));\nvec4 L0_8 = sin(20.000000 * (mat3x4(0.184678,-0.109078,-0.025816,-0.056688,0.003230,-0.023314,-0.202885,-0.121293,-0.002689,-0.117527,-0.002012,-0.117256) * uv_0 + mat3x4(0.180818,-0.028864,-0.106805,0.001355,0.103611,-0.024321,-0.084209,-0.076692,-0.013792,-0.029515,0.217967,-0.159831) * uv_1 + vec4(-0.075764,0.098253,-0.099583,0.060998)));\nvec4 L0_9 = sin(20.000000 * (mat3x4(-0.055956,-0.002890,0.091932,-0.249722,-0.119846,-0.000961,0.106380,0.128589,0.141507,-0.002166,-0.173333,-0.025571) * uv_0 + mat3x4(-0.207579,0.077747,-0.088497,-0.114388,0.001187,0.239636,0.158462,-0.011200,0.162315,0.077937,-0.017165,0.180163) * uv_1 + vec4(0.159488,0.156349,-0.037214,0.172900)));\nvec4 L0_10 = sin(20.000000 * (mat3x4(-0.148213,-0.096727,0.006985,0.068197,0.191422,0.076569,-0.004260,0.184093,0.041384,0.089330,0.097835,-0.115919) * uv_0 + mat3x4(-0.150702,-0.103426,-0.145726,0.058515,0.042812,0.184117,-0.161015,0.103164,-0.145928,0.131830,-0.148514,-0.135043) * uv_1 + vec4(0.130579,0.001407,-0.144605,0.074704)));\nvec4 L0_11 = sin(20.000000 * (mat3x4(0.000612,0.113222,0.086301,-0.032925,-0.001116,0.067637,-0.197740,0.181771,-0.002476,-0.218756,-0.009886,0.047604) * uv_0 + mat3x4(-0.076601,0.203553,-0.022517,-0.138578,-0.084096,0.057312,-0.080890,0.292170,0.074699,0.073428,0.062234,-0.073212) * uv_1 + vec4(-0.156612,0.143751,0.114131,0.041613)));\nvec4 L0_12 = sin(20.000000 * (mat3x4(-0.251344,-0.000816,-0.244488,-0.127603,-0.010343,-0.002663,0.098176,0.237592,-0.020221,-0.000492,0.111868,0.184670) * uv_0 + mat3x4(0.056868,0.001042,-0.045721,-0.137891,-0.045115,-0.159223,-0.171031,0.196998,0.204866,-0.002764,0.019703,-0.096577) * uv_1 + vec4(0.082655,-0.080911,0.106027,-0.094619)));\nvec4 L0_13 = sin(20.000000 * (mat3x4(0.125271,-0.339833,-0.061831,0.084067,0.097058,0.085038,0.276494,0.123861,0.102099,0.033677,0.064027,-0.213449) * uv_0 + mat3x4(-0.017268,-0.023077,0.044061,-0.052985,0.173684,-0.048148,0.098418,0.111715,0.023393,0.271065,-0.117630,-0.110109) * uv_1 + vec4(0.019981,-0.117696,-0.054067,0.036313)));\nvec4 L0_14 = sin(20.000000 * (mat3x4(0.070279,0.257631,-0.089865,-0.173890,-0.141870,-0.218386,0.221467,0.027216,0.235858,0.114582,-0.167326,0.210380) * uv_0 + mat3x4(0.119359,-0.031048,-0.023316,-0.094195,-0.000459,-0.070755,0.164348,0.167177,0.052177,0.078329,0.115278,0.013936) * uv_1 + vec4(-0.153495,0.159279,0.082483,0.127064)));\nvec4 L0_15 = sin(20.000000 * (mat3x4(-0.197466,-0.095298,0.116362,-0.130035,-0.187493,-0.038129,0.154328,0.122619,-0.233400,0.196591,0.119898,-0.049663) * uv_0 + mat3x4(-0.028561,0.143687,-0.034126,0.104543,-0.050200,-0.177418,0.129677,0.266691,0.103820,0.034532,0.039856,0.179836) * uv_1 + vec4(-0.252911,0.162327,0.050984,-0.145000)));\nvec4 L1_0 = sin((mat4(0.074764,-0.363615,0.450081,0.014266,-0.100304,0.434897,-0.047290,-0.294204,-0.506972,0.128365,-0.025602,0.294140,0.171873,-0.176339,-0.023875,-0.049834) * L0_0 + mat4(-0.505707,-0.864250,0.317939,-0.199966,-0.229814,-0.438403,0.336358,0.499905,-0.070169,-0.079849,0.100362,-0.204470,-0.334719,0.005488,0.101882,-0.330911) * L0_1 + mat4(0.250110,-0.280905,-0.445357,-0.345163,0.107269,0.302849,-0.693834,0.734530,0.196764,-0.036331,0.041262,-0.076817,0.084798,0.008281,0.462651,0.361920) * L0_2 + mat4(-0.114585,0.241599,0.023919,-0.032992,0.184482,0.044081,0.138100,-0.212247,-0.487289,-0.150074,-0.328240,-0.670800,-0.251331,0.214233,0.172562,0.096093) * L0_3 + mat4(-0.175333,0.026352,-0.024204,0.131367,-0.187724,-0.088188,0.056112,-0.596133,-0.490149,-0.455132,0.225102,-0.086164,-0.283548,0.197985,0.436815,-0.061727) * L0_4 + mat4(0.555001,-0.337615,0.891231,-0.328081,0.164394,-0.136831,0.278808,-0.092418,0.413669,0.007743,0.088593,-0.133347,-0.411617,-0.190742,0.161151,0.254311) * L0_5 + mat4(0.172732,0.454871,-0.208344,-0.610772,-0.075276,-0.280457,0.121371,-0.016637,-0.034953,-0.060588,0.037912,-0.025147,0.109613,0.234150,-0.502654,-0.418959) * L0_6 + mat4(-0.275049,-0.087526,0.214266,-0.242185,0.362088,0.127312,0.207893,0.153619,-0.135894,-0.147167,0.075833,0.156178,0.127227,0.218918,0.096358,0.006164) * L0_7 + mat4(0.405116,-0.183529,0.283587,-0.044289,0.023166,0.002685,0.162748,0.120536,0.056011,0.111520,-0.146715,-0.173678,-0.048303,-0.176054,0.075965,-0.037497) * L0_8 + mat4(-0.050411,-0.049206,-0.085054,-0.117004,-0.114065,0.136319,-0.114664,-0.136504,-0.196099,0.091724,0.211618,0.238036,-0.197211,0.265158,-0.288795,0.080653) * L0_9 + mat4(0.410608,-0.215142,0.130606,-0.104407,-0.316041,0.136687,-0.190299,0.131935,-0.272978,0.262749,0.037755,0.182176,0.226844,0.069267,-0.093790,-0.445055) * L0_10 + mat4(0.192760,-0.108145,0.185724,-0.642330,-0.117454,0.258500,-0.170974,0.185717,0.089538,0.361128,-0.032046,0.072338,-0.008315,-0.291919,-0.118066,-0.076640) * L0_11 + mat4(-0.210143,-0.145375,0.286685,0.158379,-0.185640,-0.221010,0.320780,-0.354908,-0.122904,-0.303859,-0.219937,0.204711,0.268902,-0.071248,0.373123,0.384430) * L0_12 + mat4(-0.258417,-0.065346,-0.059212,-0.320121,0.305224,0.387492,0.018412,0.344409,0.087562,0.020997,-0.096626,0.022883,-0.541565,0.176494,-0.019593,0.008896) * L0_13 + mat4(-0.182738,-0.182180,0.486032,-0.072810,0.733685,-0.281556,-0.539548,0.005944,-0.073282,-0.105711,-0.189210,0.322017,0.019224,-0.504387,-0.194306,-0.091422) * L0_14 + mat4(0.323416,0.123081,-0.088364,-0.206221,-0.367536,0.346790,0.217141,0.217174,-0.211516,0.084350,-0.170551,0.033735,0.197993,-0.046665,0.084366,-0.196240) * L0_15 + vec4(0.504366,-0.513739,-0.244393,0.032375)));\nvec4 L1_1 = sin((mat4(0.054449,-0.046839,-0.138730,-0.179360,0.660020,0.189719,-0.255492,0.416913,0.207090,0.282337,0.146758,0.296988,-0.298667,0.285042,-0.194367,-0.098667) * L0_0 + mat4(0.059894,0.427492,-0.546023,-0.172676,-0.135532,0.312672,-0.164207,0.500376,-0.088322,0.005872,0.078408,-0.174744,-0.527285,-0.132893,-0.142156,-0.428116) * L0_1 + mat4(-0.003358,-0.025995,-0.485844,-0.047650,0.162023,0.007881,0.430590,-0.070802,0.120537,-0.140015,-0.193264,0.101517,-0.206946,0.056724,0.324909,-0.459506) * L0_2 + mat4(0.127497,-0.227790,0.298145,-0.100741,-0.340687,-0.104879,-0.006265,0.391779,-0.773910,-0.095513,-0.835551,-0.396786,0.034775,-0.117947,0.261733,-0.380781) * L0_3 + mat4(0.123271,-0.440127,0.061429,0.210301,-0.114920,-0.265181,-0.220678,-0.355060,0.557373,-0.479923,-0.055185,-0.023603,0.403796,-0.000686,-0.026223,-0.306141) * L0_4 + mat4(0.279107,0.435262,0.498029,0.402681,-0.085408,0.163380,-0.034636,0.171401,0.001596,0.244548,-0.092570,0.048703,-0.107012,-0.149176,-0.371051,-0.150389) * L0_5 + mat4(-0.144136,0.321872,-0.271063,-0.324555,-0.061347,-0.264057,-0.143900,-0.054857,-0.006099,-0.047690,-0.044737,0.047902,0.230777,0.326851,-0.479872,0.070714) * L0_6 + mat4(-0.152288,0.003271,0.125428,-0.155061,-0.111722,0.072982,0.060887,0.015852,0.111948,-0.430659,0.130035,0.090869,0.481453,-0.241231,0.276005,-0.115616) * L0_7 + mat4(-0.175319,0.299586,-0.093676,0.178941,-0.247771,-0.354723,-0.075220,-0.091481,-0.154336,-0.102104,-0.060462,-0.119303,0.030443,-0.112422,0.023003,0.085427) * L0_8 + mat4(0.044116,0.062224,-0.013685,-0.162500,0.081598,0.473975,0.183297,0.156622,0.396723,-0.054311,-0.145491,-0.104702,0.424020,0.097041,0.169219,-0.042814) * L0_9 + mat4(0.120107,-0.019070,0.255942,0.074855,0.237654,0.028605,0.078935,-0.057540,0.166327,-0.209839,-0.018884,0.160688,-0.158356,-0.010119,0.062865,0.118717) * L0_10 + mat4(-0.295046,-0.507931,0.177801,0.420282,-0.135615,-0.235502,-0.193682,0.176714,-0.499610,0.405790,-0.140194,0.133713,-0.068807,0.226447,-0.229265,-0.435179) * L0_11 + mat4(0.089655,0.166008,0.059040,0.147990,-0.201407,0.158223,-0.133807,-0.496233,0.007940,-0.080557,0.380682,0.168990,0.329792,0.119609,0.036407,-0.114351) * L0_12 + mat4(-0.174712,0.178209,-0.258917,-0.080764,0.481857,0.107805,0.202413,0.118638,0.089964,-0.122052,-0.174003,0.042414,0.152374,-0.401135,-0.290165,0.334357) * L0_13 + mat4(-0.000086,-0.305644,-0.307723,0.250844,-0.476009,0.011789,-0.356186,-0.108491,0.082512,0.416421,0.133162,-0.354368,-0.379743,-0.266056,0.086665,-0.180357) * L0_14 + mat4(-0.021609,0.300748,-0.233138,0.371467,0.528052,0.392642,0.007188,-0.019251,-0.087090,0.212152,-0.195209,-0.100772,-0.045017,0.151896,-0.099074,0.197108) * L0_15 + vec4(-0.636943,0.299380,0.086392,0.046181)));\nvec4 L1_2 = sin((mat4(-0.240874,-0.037042,0.152067,0.187585,-0.369315,0.106592,0.030235,0.171824,0.206972,-0.181325,0.322564,0.236464,-0.312446,0.140619,-0.012037,0.150598) * L0_0 + mat4(0.597818,-0.311901,0.341179,0.394968,-0.003632,-0.181472,0.312398,0.398522,0.100210,-0.218724,-0.061336,-0.018350,0.461433,0.057348,-0.167585,-0.086833) * L0_1 + mat4(0.225047,-0.216199,0.106428,0.412256,-0.270564,-0.967479,0.180489,-0.152664,0.082829,0.359289,-0.022031,0.216415,-0.561493,0.195185,-0.263590,-0.204359) * L0_2 + mat4(0.276745,-0.160817,-0.200127,-0.230136,-0.154767,0.199258,-0.148321,-0.161206,-0.107868,-0.382507,0.254461,0.699311,0.073756,-0.464417,0.235653,-0.279447) * L0_3 + mat4(0.355156,-0.102334,-0.075123,-0.173526,0.079725,0.040322,0.036400,-0.110344,0.200025,-0.046102,0.241001,0.369063,0.026370,-0.069326,-0.010715,0.294186) * L0_4 + mat4(0.453176,0.098114,0.319217,0.239023,-0.205745,-0.089353,0.036845,0.094365,-0.098069,-0.204787,0.193378,0.015931,0.255296,0.126627,-0.044109,0.124494) * L0_5 + mat4(0.565532,0.017238,0.034400,-0.450412,-0.093552,0.125470,0.274469,0.071487,0.001800,-0.018755,0.098237,-0.115336,0.185643,0.003978,-0.337237,0.353875) * L0_6 + mat4(0.215003,-0.416485,0.096116,0.019698,-0.260101,0.041453,-0.225763,0.188673,-0.339641,0.232791,0.308553,-0.286288,-0.386871,-0.066135,0.088221,-0.337516) * L0_7 + mat4(0.273776,-0.029474,0.026691,0.207554,0.007912,-0.000349,0.019426,0.095092,0.099403,0.046381,-0.051254,0.088141,-0.098650,-0.068328,0.011230,0.027178) * L0_8 + mat4(-0.201239,-0.042032,-0.040360,0.068341,0.055736,-0.191506,-0.084059,-0.121626,-0.191588,-0.191667,0.145805,0.173956,0.143694,-0.207363,-0.177107,-0.488231) * L0_9 + mat4(-0.656607,-0.590700,-0.017792,-0.161827,0.002989,-0.021912,-0.104301,-0.270912,-0.216606,0.009230,-0.026107,0.060868,0.252478,-0.103488,-0.310465,0.177516) * L0_10 + mat4(0.174917,-0.226856,-0.132179,0.041902,0.112571,-0.285712,-0.107626,-0.129820,-0.138221,-0.222481,0.500883,0.098323,0.008666,0.173802,0.083986,0.154632) * L0_11 + mat4(-0.143575,0.166173,-0.120022,-0.368496,-0.326297,0.345559,0.321820,0.090349,0.019715,0.214544,0.058322,-0.132896,-0.007471,-0.016945,-0.087341,-0.169841) * L0_12 + mat4(0.318221,0.018982,0.158766,-0.087076,0.348273,0.486788,-0.045046,-0.226305,-0.203012,0.443277,-0.289560,-0.038113,-0.085509,0.012283,-0.003726,0.177098) * L0_13 + mat4(-0.663670,0.028737,0.175346,0.016428,-0.375824,-0.066114,-0.145359,-0.430684,-0.110398,-0.175524,0.109897,0.295917,-0.284053,0.289000,0.071239,-0.098423) * L0_14 + mat4(-0.336603,0.317036,0.247860,0.221386,0.010883,-0.056343,0.077849,-0.101320,0.270836,-0.132664,0.096380,0.056215,0.220215,-0.120666,-0.171983,-0.060849) * L0_15 + vec4(-0.722091,-0.733743,-0.842933,0.238769)));\nvec4 L1_3 = sin((mat4(-0.096499,0.128115,0.312457,0.178415,0.165906,0.139559,-0.321827,0.027428,0.128691,0.275632,-0.199523,-0.081349,0.123978,-0.225880,0.152246,0.171959) * L0_0 + mat4(-0.069713,-0.217651,-0.040917,0.290203,-0.150784,0.190833,0.000357,-0.032116,0.009011,-0.066107,-0.078176,0.064585,0.156923,0.243058,0.295772,-0.276243) * L0_1 + mat4(0.036325,-0.033270,0.174683,-0.143579,-0.123572,-0.655669,-0.543225,-0.629812,0.031138,0.238947,0.257624,-0.227236,-0.119466,0.462556,0.000484,-0.160543) * L0_2 + mat4(-0.031426,0.063416,-0.171299,-0.141766,0.312839,-0.237935,0.109581,-0.252720,-0.399934,0.132361,0.242976,-0.306373,0.204524,-0.015362,0.379599,0.022657) * L0_3 + mat4(0.242489,0.279307,-0.181838,-0.237597,-0.335486,-0.111009,-0.050710,-0.191788,-0.497939,0.408735,-0.118986,0.130466,-0.130220,0.282986,-0.102873,-0.241273) * L0_4 + mat4(0.230487,0.390901,-0.700234,-0.314855,0.247112,0.432724,-0.213936,-0.056166,-0.268985,0.278870,0.192815,0.312917,0.121536,-0.300360,0.225591,-0.344026) * L0_5 + mat4(-0.246903,-0.425200,-0.032384,0.220457,0.355437,-0.063143,0.067543,0.025009,0.022731,0.097886,0.013427,-0.171664,-0.543658,0.277903,0.273981,0.190081) * L0_6 + mat4(0.272334,0.149013,-0.046993,-0.088354,0.133248,0.321520,-0.294849,-0.371254,0.016103,-0.342933,-0.144663,0.140472,-0.129156,0.001411,-0.107527,-0.100994) * L0_7 + mat4(0.202106,0.033612,-0.016462,0.007453,-0.087458,-0.143700,0.081757,0.019407,0.125251,-0.193315,0.123420,-0.064367,0.030770,-0.049809,-0.094709,-0.027735) * L0_8 + mat4(-0.140472,-0.120835,0.148587,0.333424,-0.122554,0.076181,0.017668,-0.208448,-0.069260,0.299871,-0.127343,-0.147120,-0.001744,-0.075233,-0.088575,0.128954) * L0_9 + mat4(0.149073,-0.236510,0.009443,-0.342778,0.093944,0.039829,-0.183638,-0.045034,0.108478,-0.096129,0.061094,-0.030268,0.063120,0.086930,0.301261,-0.554966) * L0_10 + mat4(-0.399220,0.724890,0.177207,0.158269,0.089939,0.377663,0.089479,-0.257688,-0.135129,-0.040254,-0.179477,-0.043874,0.281174,0.158894,-0.151497,0.234240) * L0_11 + mat4(-0.262799,-0.337633,-0.094473,-0.015078,-0.046218,-0.222378,0.542681,0.836810,-0.058741,-0.120600,0.051871,-0.156812,-0.223126,-0.163513,-0.422786,0.109880) * L0_12 + mat4(0.132627,-0.078912,0.067284,-0.165478,0.186441,-0.020155,0.098419,0.234610,-0.036395,-0.007921,-0.061910,0.000696,0.193869,0.522786,-0.173789,-0.141294) * L0_13 + mat4(0.160414,-0.102754,-0.098725,-0.235619,0.019836,-0.472263,-0.533687,0.368103,-0.288570,-0.079845,-0.054936,0.206223,0.211016,-0.330717,0.061999,-0.004819) * L0_14 + mat4(-0.118051,-0.095153,0.076489,0.171025,0.349690,0.375422,-0.441642,-0.473404,0.116476,-0.091912,0.231749,0.093884,-0.197589,0.016058,0.077210,0.254896) * L0_15 + vec4(0.012854,-0.395972,-0.192286,0.630055)));\nvec4 L1_4 = sin((mat4(0.221979,0.088544,0.100442,0.061673,0.022439,-0.138929,-0.821689,0.706279,0.486951,0.160505,-0.150932,-0.061024,-0.077841,-0.093000,0.024279,0.094669) * L0_0 + mat4(0.082337,0.239126,0.171559,-0.129233,-0.438453,0.167445,0.135642,-0.062512,0.077030,0.097337,-0.161792,-0.100542,0.163245,0.492498,-0.079789,0.092281) * L0_1 + mat4(0.207650,0.066022,-0.064131,0.121302,0.860257,-0.521121,0.507708,0.230242,-0.489834,-0.045292,0.183730,-0.159947,-0.044268,0.010244,0.350248,-0.115026) * L0_2 + mat4(-0.093428,0.054067,0.014244,-0.152346,-0.150537,-0.077093,-0.108547,0.109261,0.038989,-0.081913,-0.026690,-0.411050,0.163755,0.148452,0.692035,-0.005822) * L0_3 + mat4(-0.084660,0.245389,-0.179632,0.049076,-0.300701,0.366906,0.179474,0.150801,0.007944,-0.214337,0.676403,0.376020,0.111533,-0.133235,0.097754,-0.136042) * L0_4 + mat4(0.053810,-0.119293,-0.438450,0.180760,0.035607,-0.165122,0.067652,-0.054954,0.462459,0.060932,-0.067615,0.383570,-0.029645,0.053480,-0.032093,-0.222356) * L0_5 + mat4(0.256250,0.317637,-0.265867,0.269347,-0.011161,0.110794,0.130931,0.214006,-0.033813,-0.110562,0.123004,0.068772,-0.345337,-0.307007,-0.473817,0.153235) * L0_6 + mat4(-0.129525,0.216852,-0.347538,0.089150,0.122501,-0.072634,-0.120160,0.035076,-0.414981,0.036504,0.026465,-0.094100,-0.326421,-0.036462,0.235303,0.124374) * L0_7 + mat4(0.132898,0.084948,-0.045344,0.073497,0.000873,0.012577,-0.185523,-0.173458,0.017765,0.032649,0.063600,0.080332,-0.004627,-0.031181,0.017737,0.061899) * L0_8 + mat4(-0.153582,-0.142574,-0.024649,0.137859,-0.213737,0.308974,0.441328,-0.095870,-0.132900,-0.015862,0.433256,-0.174183,-0.073056,-0.041783,-0.114058,-0.076414) * L0_9 + mat4(0.246328,-0.176437,0.225998,-0.231705,0.160916,0.231390,-0.180415,0.107680,-0.245105,0.133480,-0.291736,-0.067446,-0.013774,0.159245,-0.145412,0.099738) * L0_10 + mat4(-0.109748,-0.109982,-0.607607,0.309844,-0.311099,-0.049443,0.160919,0.116451,-0.129610,-0.224617,0.608127,-0.347859,-0.158474,0.227840,-0.196031,0.114336) * L0_11 + mat4(-0.290626,-0.386414,-0.179884,0.130061,-0.125758,-0.310271,-0.558284,0.531280,-0.211098,-0.216212,0.051773,-0.133587,-0.215847,-0.467397,-0.307811,0.040378) * L0_12 + mat4(-0.076843,-0.112455,0.117588,-0.028792,-0.088430,-0.102266,-0.031497,-0.057115,0.065396,0.311179,-0.195712,-0.354839,-0.215423,-0.308552,-0.197989,0.168379) * L0_13 + mat4(0.009159,0.132019,-0.190021,0.474533,-0.277302,0.077475,0.224331,-0.024416,-0.300004,0.321505,0.181669,-0.408409,0.059681,-0.164706,-0.113088,-0.362798) * L0_14 + mat4(0.043573,-0.010175,-0.078606,-0.178168,-0.244907,0.072688,0.284535,0.150085,0.173644,-0.016252,0.032584,0.154571,0.063078,-0.221974,0.148775,0.497441) * L0_15 + vec4(0.576370,-0.366148,0.126863,-0.020868)));\nvec4 L1_5 = sin((mat4(-0.229227,-0.318931,0.197553,-0.310381,-0.208026,-0.455647,-0.200409,-0.339677,0.028645,-0.172654,-0.271110,-0.175053,-0.334489,-0.112284,-0.100012,0.281322) * L0_0 + mat4(0.120805,0.121239,0.484063,-0.061958,-0.152671,0.024652,-0.253861,0.136857,0.141716,0.062877,-0.289962,0.069072,-0.139393,-0.046970,-0.089092,-0.065183) * L0_1 + mat4(0.101496,-0.080532,0.138479,-0.171901,-0.108367,0.387168,-0.426929,0.380256,0.071824,-0.178648,-0.031472,0.090416,-0.070152,0.275967,-0.325433,-0.313830) * L0_2 + mat4(0.049930,-0.219798,0.115545,0.018087,0.079557,-0.178962,0.287234,0.180864,-0.247320,-0.758269,-0.057799,0.414539,0.049280,-0.057320,0.125133,0.360899) * L0_3 + mat4(0.117861,-0.200680,0.036187,0.100087,-0.135486,-0.197078,-0.077215,-0.025192,-0.032687,-0.433522,0.190929,-0.588391,0.088746,-0.085123,0.034890,-0.081097) * L0_4 + mat4(0.251842,0.352010,-0.824287,-0.491942,0.206684,0.235273,0.329759,0.270641,-0.062231,0.298465,0.039793,0.231911,-0.068667,-0.044392,-0.363025,-0.439367) * L0_5 + mat4(0.031289,-0.490826,-0.394520,0.663385,-0.021375,-0.050865,-0.055130,0.141954,-0.102453,-0.078181,0.079420,0.017426,0.205526,-0.185914,0.495547,0.206194) * L0_6 + mat4(0.263580,0.055683,0.084994,-0.110689,0.090819,0.087559,0.040178,-0.224541,-0.135127,-0.272357,-0.061707,-0.117177,-0.094354,-0.356468,-0.245427,0.292679) * L0_7 + mat4(-0.007824,0.259287,-0.126832,0.089032,-0.056194,-0.156783,-0.146879,-0.164349,0.025341,-0.059652,0.000057,0.163233,0.003998,-0.017537,-0.157855,-0.170780) * L0_8 + mat4(0.001176,-0.090679,0.236086,0.116840,0.292978,0.010848,-0.145253,-0.021974,-0.068899,-0.081891,0.001124,0.361402,-0.003973,0.347702,0.064022,-0.010992) * L0_9 + mat4(-0.349085,-0.026720,-0.217358,0.071801,-0.062283,0.065899,0.014638,-0.025372,-0.375528,-0.029029,-0.053155,0.357107,-0.084281,0.188967,0.435305,-0.345348) * L0_10 + mat4(-0.558695,-0.105893,-0.025715,0.147983,0.115358,-0.002070,-0.291304,-0.089598,0.253799,-0.031593,0.127842,-0.020555,-0.106185,0.234865,-0.188282,0.236154) * L0_11 + mat4(-0.288916,0.455074,0.034746,0.278251,0.197506,0.115244,-0.123221,0.293268,0.169241,-0.102143,0.141370,-0.258397,-0.091607,-0.228689,-0.252006,0.238257) * L0_12 + mat4(0.240318,-0.095716,0.439393,0.164826,0.127791,0.594173,-0.045356,-0.374978,0.081598,-0.062738,0.030269,0.137096,-0.146899,-0.031055,-0.107897,0.479564) * L0_13 + mat4(-0.198498,0.094575,-0.267044,0.492150,-0.046319,-1.126338,-0.194539,0.442084,-0.271813,0.149235,0.414970,-0.700226,0.044701,0.039314,0.093767,-0.365007) * L0_14 + mat4(-0.170240,-0.264025,-0.020304,-0.152603,0.055432,0.225667,0.122702,0.388934,-0.100049,-0.033829,0.248567,-0.004671,-0.076176,-0.135682,0.400606,-0.199022) * L0_15 + vec4(0.247570,0.193523,-0.510125,0.266714)));\nvec4 L1_6 = sin((mat4(0.042069,-0.000394,0.071358,-0.167934,-0.115796,0.449018,0.004457,0.014429,-0.221460,0.051036,0.164717,0.050620,0.045411,0.097145,0.198278,-0.233015) * L0_0 + mat4(0.002006,-0.360777,-0.191078,0.402005,-0.128037,0.369332,-0.038457,0.252689,0.122159,-0.103468,0.131118,-0.196897,0.054472,0.149999,-0.209878,0.054936) * L0_1 + mat4(-0.157773,-0.208914,0.343162,-0.102046,0.050274,0.057874,-0.271990,0.355596,0.020376,-0.013391,-0.015004,-0.054622,0.362262,-0.502853,-0.072236,-0.208491) * L0_2 + mat4(0.111326,-0.025893,0.024014,0.115308,-0.842635,0.076778,-0.290807,-0.043641,-0.143354,-0.227574,0.043546,0.035981,0.019796,-0.327996,0.283985,0.200741) * L0_3 + mat4(0.027755,0.077436,-0.239214,-0.204055,0.069511,-0.120790,-0.403656,0.119491,0.620366,0.242739,0.459639,0.212842,0.429459,-0.763085,0.069769,-0.486006) * L0_4 + mat4(0.402837,-0.669815,0.472920,-0.662931,-0.079875,0.100749,0.094884,0.268061,-0.065231,-0.059407,-0.045992,0.139772,0.040042,0.143786,-0.849589,-0.215835) * L0_5 + mat4(-0.459058,0.022472,0.392469,-0.031792,0.032527,-0.131819,-0.178276,-0.205446,0.088154,0.052010,0.116351,0.063383,0.200701,0.193963,-0.135943,0.106545) * L0_6 + mat4(0.039263,-0.208724,-0.284092,-0.007483,-0.067175,0.061119,-0.132158,-0.195820,-0.109030,0.239890,-0.141107,0.086714,0.009688,-0.139019,-0.222772,0.000980) * L0_7 + mat4(0.011660,0.059115,-0.041128,0.035933,0.019765,-0.066765,0.021154,-0.154701,0.054295,-0.123517,-0.024518,-0.240066,-0.055417,0.072097,0.005570,-0.036291) * L0_8 + mat4(0.345054,-0.088207,0.147032,0.180230,-0.036841,-0.000288,-0.281255,-0.071148,-0.096511,-0.025422,0.313964,0.066347,-0.051277,-0.072797,0.240424,-0.194427) * L0_9 + mat4(0.148102,-0.155554,0.077121,0.191023,0.176520,-0.052178,0.090226,0.012103,0.153054,0.136448,0.063130,-0.162582,0.121839,0.012519,0.233861,-0.392578) * L0_10 + mat4(0.205228,0.641322,-0.004568,-0.282128,0.141548,0.186494,-0.276312,0.035401,0.096824,0.162457,0.308920,-0.185747,-0.261368,-0.258060,0.159237,-0.149246) * L0_11 + mat4(0.042792,-0.014346,0.071069,-0.367206,0.172356,0.517605,-0.194612,-0.130686,0.229189,0.058395,0.004385,0.251717,0.017654,-0.396690,0.068402,-0.105703) * L0_12 + mat4(-0.021606,-0.011159,0.079517,0.006514,0.144258,0.032693,0.353860,-0.266464,-0.360075,0.481303,0.277853,-0.075951,-0.359824,0.152151,0.380155,0.107989) * L0_13 + mat4(0.006818,-0.023581,-0.131342,0.066460,0.096269,0.092849,-0.065595,0.480693,0.618510,-0.045366,0.381929,-0.576371,0.255900,-0.055120,0.002934,-0.024608) * L0_14 + mat4(0.257108,0.198201,-0.064667,0.083191,-0.016145,0.041949,0.285072,0.163260,0.010378,-0.054788,0.176611,-0.005718,0.215826,0.072390,-0.114808,0.072655) * L0_15 + vec4(-0.146452,0.369553,0.047661,-0.531944)));\nvec4 L1_7 = sin((mat4(0.129427,0.530589,0.299964,0.245476,0.278880,-0.155466,0.173582,0.272766,0.191739,0.406903,0.096161,0.084553,0.068124,-0.150651,0.200983,0.040098) * L0_0 + mat4(-0.231169,0.317031,0.091139,-0.021075,0.303614,0.064588,0.519898,0.181603,0.048565,-0.027232,-0.181628,-0.175570,0.271921,0.151465,-0.400090,-0.270153) * L0_1 + mat4(0.177109,0.171867,0.321425,-0.119473,0.054477,-0.675361,-0.028740,-0.813645,0.042285,0.429079,0.203496,-0.166208,-0.124290,-0.171668,0.321791,0.053571) * L0_2 + mat4(0.006535,-0.114138,-0.185952,-0.094411,-0.470658,-0.500616,0.341814,-0.500986,-0.194072,0.245630,-0.386764,0.372051,-0.118814,0.186787,-0.407371,-0.017558) * L0_3 + mat4(0.052170,-0.019488,-0.161932,-0.550619,0.116247,0.176354,-0.098927,0.080661,0.235252,-0.275836,0.165289,-0.515501,0.024713,0.384445,0.583217,-0.090559) * L0_4 + mat4(-0.409714,-0.164329,0.010602,-0.208550,-0.185653,0.107391,-0.281106,-0.608742,-0.027689,-0.260415,0.175498,0.199219,-0.148271,0.141648,-0.051407,0.469036) * L0_5 + mat4(-0.334044,0.129292,0.200499,-0.052615,0.081843,0.462327,0.226375,-0.040738,0.143034,-0.069812,0.062855,-0.017018,0.088088,-0.465683,0.045395,-0.322464) * L0_6 + mat4(0.574523,0.096313,-0.423535,-0.141092,0.146205,-0.029490,0.301937,-0.411096,0.243931,0.173833,0.148434,0.425318,0.016384,0.164290,0.246115,0.109006) * L0_7 + mat4(-0.009408,0.242403,0.134884,-0.012175,0.002689,0.259753,0.091749,-0.012296,0.035367,-0.000927,-0.076192,-0.212658,0.069446,0.159993,0.154414,0.128912) * L0_8 + mat4(0.070563,-0.240836,-0.138551,-0.062524,-0.062005,-0.198871,0.219457,0.245435,0.129464,0.168251,0.203978,-0.009131,-0.084414,-0.375844,-0.188342,-0.091314) * L0_9 + mat4(0.193658,0.040561,0.248880,0.021458,-0.053645,-0.102271,-0.246971,-0.153299,-0.013365,-0.016455,0.202775,-0.070702,-0.259179,-0.210133,-0.182284,-0.037323) * L0_10 + mat4(0.615545,-0.516703,0.162664,0.166277,-0.012177,0.292955,-0.136520,0.094269,0.596618,-0.490063,-0.045771,0.360891,-0.062618,-0.056478,0.145724,-0.042392) * L0_11 + mat4(-0.032858,0.109880,0.136552,0.217829,0.030061,0.137763,0.073092,0.246210,0.247000,0.221208,-0.029264,0.051057,-0.188508,0.079045,-0.145869,-0.127636) * L0_12 + mat4(-0.083201,-0.325169,-0.406131,-0.222397,0.090709,-0.468507,0.305582,-0.129950,-0.399901,0.062032,0.023052,-0.096865,0.134867,-0.142806,0.157030,-0.061152) * L0_13 + mat4(0.028292,-0.017478,-0.066873,0.030862,0.403763,0.087307,0.146857,-0.022928,-0.417188,-0.180947,-0.055039,0.306252,0.234929,0.190459,-0.124733,0.195126) * L0_14 + mat4(0.220104,0.053935,0.436615,0.253266,-0.088963,-0.207257,-0.129544,-0.129227,-0.028278,0.121007,-0.066868,-0.209906,-0.074242,-0.276283,-0.032655,-0.018775) * L0_15 + vec4(0.040574,-0.501092,-0.455965,0.119170)));\nvec4 L1_8 = sin((mat4(-0.227326,0.134341,0.129226,0.078021,-0.051958,0.235080,0.660056,0.005136,0.191073,-0.241113,-0.260412,-0.024744,-0.070200,0.124909,0.059337,0.177232) * L0_0 + mat4(-0.177618,-0.446872,-0.542049,-0.280186,-0.116832,0.091229,0.268133,0.246355,0.230860,0.184205,-0.174618,0.029320,0.328681,0.206481,0.109201,0.325785) * L0_1 + mat4(0.098945,-0.029842,0.017443,0.301192,0.182261,-0.078488,-0.024338,-0.235178,-0.221177,0.321646,0.302010,0.155739,-0.113049,0.457538,0.033622,-0.028764) * L0_2 + mat4(-0.004779,0.109439,-0.074335,0.065390,-0.736610,0.483358,0.651508,-0.198032,-0.591829,0.160724,0.141865,-0.389917,0.419418,-0.060194,0.157155,-0.114592) * L0_3 + mat4(0.063645,0.372312,0.139022,-0.144739,0.356718,-0.012140,-0.053743,0.217638,-0.140250,-0.049483,0.105323,0.340826,0.138074,0.279430,0.047269,0.209523) * L0_4 + mat4(-0.032265,0.386494,-0.269357,-0.415693,0.121769,-0.653770,-0.355769,0.337798,-0.295277,0.148802,0.025268,0.142014,-0.176847,0.476467,0.257237,-0.131450) * L0_5 + mat4(0.115646,0.177553,0.054230,0.574991,-0.191313,0.321549,0.013976,0.077368,-0.123823,-0.038817,-0.043312,-0.043791,0.532526,-0.006158,0.142160,0.035869) * L0_6 + mat4(0.405722,-0.244806,-0.063058,-0.051823,-0.086840,-0.042674,0.306693,0.281146,-0.108042,0.062733,-0.024491,-0.026505,0.203712,0.285464,0.017148,-0.383583) * L0_7 + mat4(0.046016,-0.033462,0.140036,0.209596,0.073208,-0.032598,0.080207,0.039621,-0.069751,0.079652,-0.070832,0.144458,0.019320,0.033979,-0.059215,-0.025910) * L0_8 + mat4(0.241922,-0.041807,-0.088251,0.237957,0.398931,-0.712397,-0.644721,0.133323,-0.048178,0.014949,-0.079403,-0.075979,0.344036,-0.355570,-0.066999,0.012978) * L0_9 + mat4(-0.044108,-0.047176,-0.180601,-0.148209,0.336006,0.200004,-0.330924,-0.131352,0.015814,0.499736,-0.140973,-0.019778,-0.165387,-0.028731,-0.291606,-0.113661) * L0_10 + mat4(-0.038940,-0.085823,0.382496,0.181465,-0.254026,0.145709,-0.036046,-0.160172,0.236620,-0.226456,0.369666,0.247679,0.123052,-0.049417,-0.135386,-0.006906) * L0_11 + mat4(0.043917,-0.406738,-0.261375,0.046866,-0.061685,0.207933,0.548314,0.377194,0.150115,-0.061833,-0.093813,0.128108,-0.209910,0.186626,0.402909,-0.181156) * L0_12 + mat4(0.039678,-0.379121,0.031502,0.172806,0.330929,0.145662,-0.149091,0.428761,-0.025751,-0.168132,-0.917380,0.048174,-0.185883,-0.167041,0.198123,0.471057) * L0_13 + mat4(0.015613,-0.295086,0.827160,0.166872,0.290797,-0.053455,0.062623,0.042338,0.049498,0.112642,-0.450372,-0.427611,0.133801,-0.132000,-0.217590,0.271595) * L0_14 + mat4(0.052198,-0.088977,-0.615629,0.078566,-0.019786,0.395188,0.191639,-0.110546,-0.001490,-0.372596,0.005656,-0.008877,0.116871,-0.082064,-0.118659,0.012688) * L0_15 + vec4(0.059462,-0.620754,0.225859,0.204874)));\nvec4 L1_9 = sin((mat4(-0.040413,0.143396,-0.141521,-0.156858,-0.010751,0.262429,-0.114072,0.251302,-0.364605,0.050903,0.265035,0.177826,-0.030974,-0.089035,0.068876,-0.066187) * L0_0 + mat4(0.141630,0.332274,-0.317208,-0.044322,0.188451,0.201094,0.458749,-0.233258,0.147464,0.260953,0.083610,0.144194,0.059208,0.038840,0.412239,0.132764) * L0_1 + mat4(-0.027115,0.001800,-0.202582,0.190048,0.010277,-0.119804,-0.099862,0.803465,-0.238159,-0.219546,-0.118929,-0.070990,0.110571,0.208101,-0.129503,0.082006) * L0_2 + mat4(0.086194,0.027926,-0.009012,0.090288,-0.407619,-0.120314,-0.747605,0.210879,0.265039,-0.159687,0.128041,0.034255,-0.073761,-0.383540,-0.511612,0.000898) * L0_3 + mat4(0.324354,0.279001,-0.115753,-0.055578,-0.319022,-0.129148,-0.157597,-0.221709,0.150394,0.610302,0.216558,-0.204391,-0.178230,0.238309,-0.272005,0.269924) * L0_4 + mat4(-0.742062,-0.072032,0.594520,0.555345,0.230892,0.285251,-0.152948,-0.182960,-0.045263,-0.050200,-0.063216,-0.167631,0.010255,0.019986,0.365643,0.057889) * L0_5 + mat4(-0.634413,-0.089282,0.183379,0.207072,0.037906,0.227042,0.257154,-0.038707,0.039627,0.073143,0.015028,-0.009818,-0.034604,-0.142148,-0.396030,0.181741) * L0_6 + mat4(-0.041267,0.179698,-0.171782,0.202922,-0.032118,0.666530,0.180542,0.093543,-0.366951,-0.219514,-0.351135,-0.238552,-0.340073,-0.500552,-0.421809,-0.366012) * L0_7 + mat4(-0.038262,0.249545,-0.135532,-0.267336,-0.021256,-0.092949,0.129965,0.211179,0.030660,0.122775,-0.051686,0.047767,0.023563,-0.044479,-0.142578,0.035096) * L0_8 + mat4(-0.046805,0.042085,-0.162897,0.202812,0.197512,0.789998,0.056597,0.014943,0.070256,0.260608,0.363259,0.091101,-0.242879,0.111658,-0.027000,0.061519) * L0_9 + mat4(-0.174057,-0.171654,-0.066244,0.199902,0.372612,0.522403,0.201178,0.106869,0.201823,-0.040537,0.261134,0.133186,-0.023706,-0.462738,-0.236130,0.080652) * L0_10 + mat4(-0.071142,0.344539,-0.181555,-0.223713,0.188613,-0.055310,0.278380,0.197061,-0.029384,-0.110616,-0.204628,-0.133186,-0.260881,0.066082,-0.068434,-0.054968) * L0_11 + mat4(0.170077,0.298892,-0.151678,-0.144562,-0.250371,-0.380841,0.268323,0.068815,-0.059387,0.036027,0.050397,0.086802,-0.267986,-0.229639,-0.361041,-0.155815) * L0_12 + mat4(0.078706,0.042017,-0.009946,-0.024184,-0.058586,-0.144362,0.088684,-0.049080,-0.451129,0.153877,0.204494,-0.296063,0.496752,0.253113,0.237027,-0.122650) * L0_13 + mat4(0.408107,0.317727,0.468331,0.111196,0.346622,0.443810,0.600643,-0.172675,-0.587129,-0.219114,-0.049621,-0.533633,-0.158855,0.191812,-0.044845,-0.012221) * L0_14 + mat4(0.080683,0.184761,0.511049,0.047949,0.269565,0.544215,0.133870,-0.143742,0.056443,0.046420,0.113045,-0.022421,0.072396,0.013302,-0.485181,-0.101402) * L0_15 + vec4(-0.051217,0.658820,-0.001578,0.565073)));\nvec4 L1_10 = sin((mat4(0.368252,0.095617,-0.048302,0.146785,-0.006345,0.129505,-0.285614,-0.524580,-0.232455,0.142937,0.253146,0.238964,0.018273,0.325300,0.140374,-0.064970) * L0_0 + mat4(-0.194922,-0.149160,0.489966,0.062534,0.132675,-0.421292,-0.113150,-0.326860,0.284795,-0.015070,-0.153986,-0.221977,0.283733,0.174852,-0.223344,-0.044639) * L0_1 + mat4(-0.234995,-0.082331,-0.269423,0.199034,0.037808,-0.574828,0.023098,-0.585124,-0.234890,-0.125613,-0.252362,0.000621,0.148438,0.054206,-0.297211,0.242509) * L0_2 + mat4(0.159644,0.031407,-0.093868,-0.191414,0.323766,-0.040426,0.072245,0.524563,0.001802,0.185094,-0.074626,0.218236,0.001900,-0.124084,0.073099,0.481710) * L0_3 + mat4(-0.013931,-0.161302,-0.321224,-0.123222,-0.123847,0.336282,-0.301928,-0.016234,0.146062,0.034845,-0.109082,0.225522,-0.107338,-0.053897,0.163506,0.569071) * L0_4 + mat4(0.798000,0.244365,0.915333,-0.017989,0.103839,0.024837,-0.033976,0.133653,0.045509,0.237029,0.073220,0.053634,0.257775,-0.047556,0.319681,-0.043682) * L0_5 + mat4(-0.448695,-0.562448,0.010403,-0.288119,-0.107357,-0.124000,0.107696,0.081144,-0.191930,0.041409,-0.010518,-0.083190,-0.274939,-0.061626,-0.140693,0.116598) * L0_6 + mat4(0.203334,-0.003816,-0.065400,0.264761,0.262531,0.134892,-0.205394,-0.061583,-0.194372,0.059195,-0.174795,-0.099735,-0.171649,-0.009973,0.076125,-0.126930) * L0_7 + mat4(0.090464,0.336479,0.269390,-0.129237,0.100573,-0.031836,0.245496,0.126421,0.136963,-0.082650,0.143580,0.127701,-0.018030,-0.106011,-0.077827,0.046169) * L0_8 + mat4(-0.114376,0.211244,0.023977,0.074209,-0.013234,0.617071,0.144325,0.818216,0.113722,-0.085335,0.031035,0.276603,-0.028501,-0.185191,-0.255588,-0.067396) * L0_9 + mat4(0.082032,0.100759,-0.235888,-0.528932,0.289264,0.000352,-0.299122,-0.287386,0.266763,-0.211225,0.039906,-0.245361,0.315251,0.182563,0.238837,0.187516) * L0_10 + mat4(-0.203508,-0.081893,-0.427869,-0.608083,-0.113918,-0.341136,0.061680,-0.016140,0.047112,-0.090884,0.103817,-0.269951,0.054740,-0.231817,-0.551508,-0.237499) * L0_11 + mat4(0.389313,-0.186748,-0.184421,-0.227626,0.757616,0.129940,0.649206,-0.047101,0.078487,-0.091153,0.040742,-0.045233,-0.018465,-0.050529,-0.006165,-0.042796) * L0_12 + mat4(-0.206607,-0.018514,0.276895,-0.011782,-0.317320,-0.143459,0.064223,0.201906,0.231458,-0.258260,-0.015838,0.388825,-0.049968,0.107408,-0.319991,0.030414) * L0_13 + mat4(0.028548,0.062997,0.305298,0.423705,0.106308,0.129794,-0.312904,-0.362903,-0.521569,-0.609221,0.125545,-0.302674,0.167226,0.107879,-0.072092,-0.128867) * L0_14 + mat4(-0.115589,0.297068,0.093811,0.052253,0.000452,0.004883,0.004884,-0.142350,-0.122867,-0.010604,0.197759,0.464210,-0.288198,0.323854,-0.036646,0.184097) * L0_15 + vec4(0.495117,-0.196929,0.326311,-0.009601)));\nvec4 L1_11 = sin((mat4(-0.028366,0.188545,0.209602,0.200983,0.333096,0.731999,-0.173436,0.089198,0.095632,-0.069059,-0.019198,0.319851,0.122176,0.057744,-0.032192,-0.178042) * L0_0 + mat4(-0.403611,0.101882,-0.231095,-0.000193,-0.287947,-0.098349,0.053754,-0.067050,-0.174466,0.116803,-0.227661,0.153694,-0.192938,-0.062893,-0.002098,0.192023) * L0_1 + mat4(-0.003993,0.339643,0.070702,-0.058435,0.312140,-0.169070,-0.110880,0.342616,-0.202059,0.129756,-0.278197,0.044727,-0.506803,0.215849,0.464672,-0.206477) * L0_2 + mat4(0.012436,-0.067837,0.232149,-0.242617,0.513408,0.138490,-0.132285,0.207888,0.584751,-0.557051,-0.030888,-0.025277,-0.090857,0.217646,-0.136831,-0.234634) * L0_3 + mat4(-0.135936,-0.142979,-0.232250,0.154074,0.342223,-0.310737,-0.020722,0.346750,-0.217669,0.610177,-0.678941,0.199167,0.264636,0.142760,-0.229641,-0.012765) * L0_4 + mat4(0.944990,-0.328964,-0.365556,-0.166102,0.195151,0.035218,0.065913,-0.036598,0.109943,0.210030,0.062899,-0.006119,0.225298,-0.023063,-0.193020,0.040630) * L0_5 + mat4(-0.111031,-0.336454,-0.271235,-0.170009,0.010728,-0.170843,-0.129095,-0.168557,0.010179,-0.052254,0.112160,0.011108,0.396180,-0.329167,-0.156313,0.556304) * L0_6 + mat4(-0.567514,0.041601,-0.024778,0.345536,0.017188,-0.148177,0.272754,-0.347335,0.465103,-0.351849,0.134146,0.527904,0.003723,-0.056008,-0.083322,0.173877) * L0_7 + mat4(0.009371,-0.000888,0.088255,-0.256784,-0.163822,0.008030,-0.008726,-0.014972,0.064701,0.063153,-0.010317,0.074262,-0.101719,-0.021503,-0.044444,0.032746) * L0_8 + mat4(0.178222,-0.165699,-0.131640,0.230835,0.042834,-0.173286,-0.228109,-0.036373,0.089998,0.017452,0.204982,-0.079362,-0.165228,0.005673,0.174568,0.268591) * L0_9 + mat4(0.301997,0.099475,-0.014293,0.357003,0.457230,-0.135312,-0.193662,-0.034745,-0.150309,-0.028241,-0.162218,-0.232444,0.009295,-0.046163,0.341365,0.591001) * L0_10 + mat4(-0.012080,0.657116,-0.134867,-0.284904,0.154401,0.038769,-0.044056,-0.202510,-0.270816,0.220373,-0.341666,-0.500661,-0.110052,0.039089,-0.155358,0.368627) * L0_11 + mat4(-0.090382,-0.003600,0.220472,0.064795,-0.080787,0.173945,0.262089,0.440764,-0.028497,0.041270,0.028173,0.209520,0.062310,-0.126630,0.008389,0.145523) * L0_12 + mat4(0.013759,0.176277,0.095655,-0.301590,-0.874605,0.849309,0.120083,0.229097,0.013927,0.029314,0.152290,-0.024976,-0.178593,-0.491903,-0.010245,0.116584) * L0_13 + mat4(0.101763,0.060516,-0.457257,-0.075820,0.157300,0.233152,0.475924,-0.131770,-0.100923,0.302602,0.822143,0.093194,0.440332,-0.372247,0.032514,0.165968) * L0_14 + mat4(0.288698,-0.405056,0.005097,0.152428,-0.239152,-0.028364,-0.003276,-0.291680,0.136191,0.274817,-0.066896,-0.074406,0.468050,0.026103,-0.096472,-0.018508) * L0_15 + vec4(0.523357,0.036290,-0.225121,0.095308)));\nvec4 L1_12 = sin((mat4(-0.007705,-0.086299,0.113164,-0.112443,-0.136198,-0.011260,0.159065,0.266495,0.116000,0.531110,0.233787,-0.098776,-0.350827,-0.028093,-0.064238,0.095904) * L0_0 + mat4(0.065940,-0.376462,0.048823,0.223021,-0.169810,-0.101779,0.460820,-0.001453,0.104569,0.108258,-0.320852,0.057152,-0.163068,0.039802,0.143754,0.218904) * L0_1 + mat4(-0.010388,-0.137191,0.103119,-0.062382,0.266591,-0.513024,0.073390,0.550500,0.312922,-0.113382,-0.007870,0.033590,0.336951,0.041502,-0.121567,0.049347) * L0_2 + mat4(0.131707,-0.051164,-0.001156,-0.108891,0.409499,0.395608,-0.451846,-0.196942,-0.113188,0.165132,-0.159945,0.111800,0.289106,-0.071749,0.604073,-0.114010) * L0_3 + mat4(-0.003811,-0.068974,0.165548,-0.000347,-0.009033,0.039581,-0.118594,0.220188,0.176099,-0.357849,-0.112978,0.265384,-0.154472,0.222021,-0.085574,-0.569045) * L0_4 + mat4(0.692807,0.453145,1.054158,-0.451312,-0.277871,-0.022104,0.179189,0.180631,-0.164419,-0.084920,-0.302517,-0.075984,0.247677,0.041684,0.096065,0.021165) * L0_5 + mat4(-0.670924,0.502690,-0.016072,0.248625,0.014997,-0.013788,0.008130,0.053602,0.019960,0.085882,-0.110600,-0.056549,-0.165093,0.232838,-0.573463,-0.084618) * L0_6 + mat4(-0.110806,-0.377048,0.080256,0.179470,-0.205014,0.120537,0.000768,0.016516,-0.469342,-0.161362,-0.399192,-0.027095,0.330575,-0.031932,0.266411,-0.102808) * L0_7 + mat4(-0.106629,-0.118724,-0.122622,-0.079840,-0.032692,0.075968,0.172409,0.132652,0.063507,0.044420,0.005864,-0.047870,-0.072814,0.079904,-0.090898,0.043821) * L0_8 + mat4(-0.054498,0.141013,0.024463,0.064934,0.118491,0.081059,-0.112563,0.615900,0.043960,0.230271,0.212433,-0.062361,0.063772,0.252780,-0.003366,0.032398) * L0_9 + mat4(0.035493,0.065341,0.215057,0.076417,0.047061,0.088793,-0.098340,-0.237105,0.002104,0.017860,0.022203,-0.043776,-0.151209,-0.452238,0.414532,0.138485) * L0_10 + mat4(0.278977,0.217943,-0.133291,0.575165,0.740764,-0.149709,0.176782,-0.075758,0.273075,-0.209642,-0.052004,0.196279,0.076121,0.204891,0.092222,0.113710) * L0_11 + mat4(0.238970,0.227771,-0.058830,0.214860,-0.244114,-0.106165,0.037853,-0.008529,0.130388,-0.009792,0.327536,-0.153369,0.383181,0.015411,0.357533,0.070433) * L0_12 + mat4(-0.090700,0.188320,0.244170,0.127069,0.120722,0.047084,0.092634,0.101346,-0.188504,-0.047899,-0.028002,-0.101131,-0.052882,-0.233096,0.022511,0.188967) * L0_13 + mat4(-0.078849,-0.136438,0.171929,0.037199,0.440914,0.241872,0.447310,-0.012566,-0.016616,0.220616,-0.220461,-0.117080,-0.119786,0.074124,-0.063934,0.052887) * L0_14 + mat4(-0.320764,0.226205,-0.324950,-0.163694,-0.032909,-0.108615,-0.238322,0.030775,0.014343,0.262623,0.399304,0.124269,-0.225529,0.300847,-0.002583,-0.118705) * L0_15 + vec4(-0.294408,0.336264,-0.027303,0.122164)));\nvec4 L1_13 = sin((mat4(-0.063728,0.264203,0.143961,0.030574,-0.284259,0.357695,-0.012184,0.516727,0.211184,0.148396,0.134097,0.056605,-0.040533,0.004237,0.052654,-0.028925) * L0_0 + mat4(0.103012,0.428510,-0.523986,0.818517,-0.598776,-0.335231,0.118335,-0.358166,-0.116180,0.068259,-0.061455,-0.018986,0.023850,-0.254600,-0.108162,-0.231237) * L0_1 + mat4(-0.137926,0.135421,0.211197,0.411904,-0.134654,0.223060,0.453778,-0.038763,-0.213232,0.131981,0.443034,0.041598,-0.406582,0.105835,-0.080165,-0.273776) * L0_2 + mat4(0.093081,-0.113555,0.119258,0.023610,-0.562811,0.289776,-0.107866,-0.183163,-0.115628,-0.389735,-0.084998,1.050996,-0.017886,-0.155969,-0.455712,-0.017639) * L0_3 + mat4(-0.022314,0.155947,-0.239301,0.272125,0.031828,0.258962,-0.045097,0.154093,-0.718890,-0.170538,-0.155733,-0.108114,0.649821,-0.197173,-0.012700,0.424770) * L0_4 + mat4(0.453615,0.909809,0.924792,0.406413,-0.068962,0.136508,-0.310936,-0.381815,-0.234057,-0.042288,0.136053,0.135928,0.065684,0.175429,0.255358,0.074172) * L0_5 + mat4(0.603304,0.041145,-0.415521,-0.236400,-0.114544,0.091831,0.041787,-0.047487,0.007465,-0.030295,-0.014359,-0.052283,-0.098281,-0.459435,-0.318579,0.047224) * L0_6 + mat4(-0.133058,0.032854,-0.479843,-0.058852,0.242312,-0.247881,-0.221890,-0.214023,-0.215280,0.166660,0.082556,-0.070246,-0.238858,0.090583,0.382196,-0.095660) * L0_7 + mat4(0.387033,-0.256328,0.034788,-0.071482,0.048239,0.025683,0.056070,-0.089409,0.063572,0.088305,-0.085311,0.004928,-0.113110,0.014859,-0.125739,0.021399) * L0_8 + mat4(-0.048107,-0.055983,0.065924,-0.183780,0.384162,0.042393,-0.405605,-0.098699,-0.146154,0.301130,-0.139889,-0.080813,-0.054447,-0.095371,0.097596,-0.115867) * L0_9 + mat4(-0.408693,0.060616,-0.031002,-0.154078,-0.068068,-0.056302,-0.201808,0.061284,-0.121016,0.125238,-0.272491,-0.067135,0.181573,0.209648,0.243094,0.240081) * L0_10 + mat4(0.569865,-0.664296,0.421625,-0.478217,0.020880,0.071312,-0.319505,-0.022934,-0.628761,-0.520869,0.549621,0.277042,-0.044739,0.075280,0.087316,0.025407) * L0_11 + mat4(-0.370366,-0.070409,0.109625,-0.616718,-0.204229,-0.326686,0.115965,0.199702,-0.019401,-0.013841,0.209490,-0.314992,-0.142196,0.216471,0.092391,-0.057200) * L0_12 + mat4(0.329613,-0.179697,-0.002492,-0.171776,-0.078544,0.013813,-0.055320,-0.714398,0.659950,0.070310,0.301384,-0.033742,-0.290649,0.449331,-0.578453,0.095120) * L0_13 + mat4(0.163001,0.366351,-0.207771,-0.087925,-0.739317,-0.036420,-0.151384,-0.314607,0.185942,-0.283292,0.500439,0.156529,-0.137088,0.122250,-0.141550,-0.350003) * L0_14 + mat4(0.101356,0.390883,0.058122,0.148997,0.253642,0.207730,-0.221306,0.261231,0.376986,-0.120957,-0.225667,-0.108893,0.054961,-0.340978,0.194347,0.071488) * L0_15 + vec4(-0.405581,0.014123,-0.822084,-0.615410)));\nvec4 L1_14 = sin((mat4(-0.040999,-0.105519,0.220396,-0.011623,0.162149,-0.301055,0.219844,-0.240560,-0.090949,0.431492,0.171225,0.293208,-0.094494,-0.171719,0.333731,0.213256) * L0_0 + mat4(0.147681,-0.077053,-0.448769,0.695480,-0.207771,0.000029,-0.099877,0.169423,-0.018885,-0.107707,-0.079857,-0.203492,0.085308,-0.287448,-0.043816,-0.325048) * L0_1 + mat4(0.242935,0.132036,0.182656,0.165011,0.179105,0.901322,-0.039753,-0.461615,0.016937,0.141575,-0.049507,-0.125457,0.220861,-0.027281,0.394835,0.239593) * L0_2 + mat4(0.079446,-0.035238,0.199463,0.063703,-0.025960,0.799276,-0.045612,0.791870,-0.468261,-0.016391,-0.337736,0.168087,-0.506988,-0.440458,0.296335,-0.043765) * L0_3 + mat4(0.182831,-0.101990,0.002759,-0.035580,-0.163092,-0.251333,-0.020874,-0.226229,-0.634971,-0.421356,-0.118671,0.390006,-0.307706,-0.203789,0.286129,-0.135674) * L0_4 + mat4(-0.234646,0.192811,0.188958,0.630536,-0.472048,0.010123,-0.238710,0.354250,0.133847,-0.136999,0.243878,0.037613,-0.426369,-0.070297,-0.519374,-0.285774) * L0_5 + mat4(0.574778,0.198403,-0.207876,-0.028437,0.011332,-0.077681,-0.018133,0.267253,0.002177,-0.084640,-0.189457,0.176268,-0.210806,-0.028649,-0.570820,-0.389538) * L0_6 + mat4(-0.219244,-0.136232,-0.411807,-0.194731,0.108539,-0.006552,0.116038,-0.079433,0.042447,0.314449,0.073396,-0.148114,-0.220129,0.081264,0.071918,-0.131638) * L0_7 + mat4(-0.348132,-0.181085,-0.150687,-0.156400,-0.143417,-0.041596,-0.274301,-0.155121,0.125105,-0.120707,0.064832,0.239369,0.069759,0.020927,-0.151637,0.006661) * L0_8 + mat4(-0.173904,0.037991,-0.166292,-0.155439,0.127378,-0.640001,-0.146593,-0.308232,-0.095643,-0.014149,0.304795,0.396269,0.146383,0.060913,0.069012,0.204754) * L0_9 + mat4(-0.091999,0.285056,0.296844,-0.254037,0.278673,-0.109288,0.138176,-0.080392,-0.149657,-0.249594,-0.222550,0.048908,-0.098171,-0.286954,-0.394903,0.514078) * L0_10 + mat4(0.049912,-1.187760,0.472910,-0.580187,0.135120,0.065463,0.140361,0.127381,0.048961,0.531508,-0.050011,-0.026378,0.305193,0.312955,-0.085626,-0.140556) * L0_11 + mat4(0.105915,-0.199781,0.174767,-0.067407,0.312373,0.083219,-0.199757,-0.482125,-0.008125,0.177715,-0.095976,0.011502,-0.024704,0.110083,0.112861,-0.658464) * L0_12 + mat4(0.076043,0.272848,-0.331423,0.015239,0.530302,-0.214772,-0.075558,0.056106,0.572231,-0.630872,0.209942,0.219706,0.056701,-0.063602,0.547786,0.367097) * L0_13 + mat4(-0.050057,-0.177152,0.076982,-0.202438,0.284809,0.290693,-0.285524,-0.010924,-0.151313,0.163256,-0.842688,0.202280,-0.049107,-0.035991,-0.379075,-0.068262) * L0_14 + mat4(-0.113141,0.338202,0.173697,0.072954,-0.061016,-0.260542,0.371019,0.410070,0.028971,0.142079,-0.154930,0.072155,0.098452,0.147187,-0.212749,-0.190379) * L0_15 + vec4(-0.032458,-0.277747,0.365592,-0.632397)));\nvec4 L1_15 = sin((mat4(-0.027047,0.220694,-0.016901,0.118527,-0.111508,0.505441,-0.668715,-0.391189,0.456865,0.001409,-0.112174,-0.325814,0.349363,0.015656,0.188574,-0.091121) * L0_0 + mat4(0.177556,-0.058820,0.065709,0.134922,0.069680,-0.197394,0.063648,-0.375232,-0.178948,0.195741,-0.101638,-0.013958,-0.445162,0.103141,0.318184,-0.110929) * L0_1 + mat4(-0.378227,-0.117274,-0.113952,-0.347639,0.152103,-0.409078,-0.182996,-0.881759,-0.275266,-0.113928,0.033938,-0.058380,0.213346,0.394438,0.352538,0.196689) * L0_2 + mat4(-0.069654,0.102505,-0.206787,-0.042501,0.743080,0.325057,0.149232,0.412390,0.536735,0.450245,0.074429,0.218849,-0.177362,0.302885,0.045263,-0.267315) * L0_3 + mat4(-0.265150,-0.007921,0.007561,-0.156063,-0.267253,-0.277497,0.423419,0.034301,0.328823,0.068031,-0.365306,0.202405,0.074306,0.251169,0.082437,0.202837) * L0_4 + mat4(0.842443,-0.537413,0.600767,-0.428905,-0.246428,-0.319033,0.315629,0.006946,0.119621,0.488040,0.270376,-0.059302,-0.008047,0.111796,-0.365527,0.160617) * L0_5 + mat4(0.156979,-0.002792,0.409926,-0.328622,0.057672,-0.110881,0.223416,-0.033747,0.083006,0.008846,0.037539,-0.126826,-0.052924,-0.239782,0.293947,0.127981) * L0_6 + mat4(-0.456947,0.146484,0.231563,-0.242356,-0.183587,0.181440,-0.009058,0.109765,0.071156,-0.127240,0.459138,0.021848,0.208154,0.025597,0.249940,0.163037) * L0_7 + mat4(0.036424,-0.149095,-0.140282,0.042470,-0.125181,-0.235186,-0.240994,-0.045973,0.012326,0.077928,0.149113,-0.052378,-0.030011,0.027833,-0.008305,-0.130647) * L0_8 + mat4(0.196480,-0.221893,-0.173781,0.119361,0.711078,-0.026233,0.028145,0.463827,0.188895,0.028982,-0.069696,0.008435,-0.031053,-0.138292,-0.077331,0.191317) * L0_9 + mat4(0.165609,0.131117,-0.122259,-0.315846,-0.232379,0.302045,-0.096947,0.183322,-0.271440,-0.039998,0.127543,-0.137425,-0.113793,0.168242,-0.095964,0.111770) * L0_10 + mat4(0.141979,-0.196748,0.681383,-1.103454,-0.030161,0.095274,-0.091491,-0.127042,-0.116276,0.391236,0.113168,0.347189,0.266678,-0.153723,0.041008,0.056530) * L0_11 + mat4(0.009989,-0.227550,0.029629,0.302018,-0.260001,-0.208037,0.112202,-0.006524,0.150839,0.055012,0.172200,0.035947,0.415550,-0.006898,0.264114,-0.152702) * L0_12 + mat4(0.157117,-0.257834,-0.072677,0.033573,-0.345265,-0.232007,0.158952,0.047806,-0.140175,-0.089647,-0.317085,-0.113653,-0.117433,-0.412981,-0.364419,-0.395336) * L0_13 + mat4(-0.039318,-0.208825,-0.384529,0.193019,-0.207743,0.224728,-0.216771,-0.041243,0.278474,0.587328,0.324841,-0.214525,0.263122,-0.133758,-0.014336,0.328712) * L0_14 + mat4(-0.105414,-0.319498,0.251992,0.280263,0.203964,0.015219,0.176165,-0.076753,-0.002725,0.161294,0.138848,0.161006,-0.183915,0.088492,0.140623,-0.132515) * L0_15 + vec4(0.266298,0.646348,0.244896,-0.799372)));\nvec4 L2_0 = sin((mat4(-0.799884,0.291882,0.277979,-0.026676,0.075683,-0.225309,-0.350309,0.060183,-0.128483,-0.395559,-0.217079,-0.108060,0.209128,-0.140514,0.419112,0.152830) * L1_0 + mat4(0.098326,-0.195196,0.022281,-0.162351,-0.000909,0.097222,0.050151,-0.066556,-0.176062,0.307562,0.189591,-0.268382,-0.093290,-0.154381,0.124107,0.019971) * L1_1 + mat4(0.212532,-0.478355,0.074177,-0.157110,0.265206,0.176512,-0.054458,0.054104,-0.498866,-0.277205,0.066528,0.292660,0.019923,-0.121066,0.086350,0.162966) * L1_2 + mat4(-0.246073,-0.280805,0.014026,0.275088,0.091562,-0.240573,-0.084450,-0.160398,0.242298,0.020763,-0.316870,-0.041575,0.055363,0.275542,0.143667,0.039472) * L1_3 + mat4(-0.282608,-0.421917,-0.551646,0.040077,-0.310140,-0.161498,0.234068,0.198777,-0.127709,0.179918,0.153302,-0.100565,0.113204,0.420512,0.363761,0.164564) * L1_4 + mat4(0.106353,-0.213706,-0.265216,-0.079555,0.689959,0.225517,0.314932,-0.144114,0.111667,-0.100442,-0.151427,-0.338260,0.541412,-0.239675,-0.110042,-0.356440) * L1_5 + mat4(0.605426,0.054515,0.053537,-0.122546,0.049850,0.061052,0.048322,-0.249908,-0.136498,0.534766,-0.203309,-0.177674,0.275870,0.007254,-0.062232,0.435291) * L1_6 + mat4(-0.462646,-0.085566,0.118265,0.294403,-0.130797,-0.076388,0.218769,0.189312,-0.257621,0.163758,-0.089303,0.329493,-0.344918,-0.122449,0.077538,-0.020247) * L1_7 + mat4(-0.242228,-0.099653,0.281141,-0.387743,-0.017388,-0.216421,-0.187880,0.143097,-0.664993,0.268602,-0.024501,0.061993,-0.014543,0.103831,0.517444,0.426110) * L1_8 + mat4(-0.155017,0.208073,-0.007667,-0.096739,-0.046625,0.238168,0.073861,-0.280664,-0.039256,-0.060387,0.065993,-0.048133,0.143885,0.393392,-0.287262,0.411150) * L1_9 + mat4(-0.076283,-0.055604,0.186332,0.217701,0.225706,-0.517426,-0.280707,-0.265373,-0.308097,0.093931,-0.240273,0.160323,0.070131,-0.150214,-0.093826,-0.199744) * L1_10 + mat4(0.220832,-0.201196,-0.173187,-0.092571,0.117201,0.225090,0.097642,-0.390578,-0.047784,0.012955,0.344875,0.100548,0.174198,0.187650,-0.403431,-0.407946) * L1_11 + mat4(-0.033632,-0.108917,-0.073192,-0.123730,0.205912,-0.029052,0.278552,-0.021896,0.760806,-0.235798,-0.076563,-0.020086,0.211061,-0.003058,0.094649,-0.183109) * L1_12 + mat4(0.063028,0.206070,0.005398,0.157938,0.071592,0.041007,0.086203,0.120973,-0.342356,-0.084168,0.337819,0.155655,-0.289200,-0.220111,0.353382,-0.057685) * L1_13 + mat4(0.152915,-0.445639,-0.044594,-0.466108,-0.398143,-0.183457,0.367325,0.203260,-0.015945,-0.293785,0.185941,-0.151575,-0.382100,-0.158306,-0.036480,0.087834) * L1_14 + mat4(-0.150590,-0.019448,-0.063336,-0.155520,-0.158850,0.016282,-0.236285,-0.445620,0.234732,-0.411270,-0.055877,0.545134,-0.097208,-0.173807,-0.128704,0.289292) * L1_15 + vec4(0.257432,0.336903,-0.467734,-0.159689)));\nvec4 L2_1 = sin((mat4(0.371941,0.083275,0.073519,-0.294061,0.249211,-0.205228,0.012841,0.224145,0.288451,-0.238713,0.123314,0.136949,-0.157237,-0.024974,0.077084,0.171150) * L1_0 + mat4(-0.104565,-0.066566,0.042452,0.085845,0.115670,-0.246429,-0.397556,-0.133922,-0.051699,0.234606,0.128200,-0.033557,-0.263267,-0.174842,-0.340153,-0.189225) * L1_1 + mat4(0.018753,-0.363997,-0.507194,0.267135,-0.201080,-0.132666,-0.015387,0.108355,-0.347076,0.186725,0.428169,0.423847,0.099860,0.009195,-0.058546,0.126948) * L1_2 + mat4(-0.001472,0.508522,0.382715,0.145359,-0.098669,-0.093077,-0.862562,0.175376,0.230492,0.290498,-0.102100,0.293327,0.136869,-0.176524,-0.013499,0.158467) * L1_3 + mat4(0.346032,-0.029883,-0.772291,0.266282,-0.086585,0.079776,-0.613977,0.134367,-0.048574,-0.248238,0.179384,0.240191,-0.201639,0.025929,-0.074103,-0.063891) * L1_4 + mat4(-0.156738,-0.275841,-0.850126,0.318444,-0.023141,0.146142,-0.222244,0.171873,-0.122306,-0.328761,-0.560534,0.041290,-0.222313,-0.099698,-0.142349,-0.007382) * L1_5 + mat4(-0.008584,-0.414463,-0.337891,-0.066070,0.036661,0.197948,0.264653,0.071507,-0.032974,0.150845,0.043776,-0.037205,0.257745,-0.333247,0.043836,0.220055) * L1_6 + mat4(-0.126777,0.026214,-0.157583,-0.468407,-0.114517,0.196659,0.032513,0.135507,-0.093153,-0.109016,0.017653,-0.088923,0.165638,-0.198904,-0.024843,-0.312617) * L1_7 + mat4(0.172149,-0.085022,-0.210508,-0.113533,0.006149,0.234681,-0.072138,0.074921,0.044714,0.552212,0.258447,-0.072581,0.076024,0.190487,-0.456945,0.287245) * L1_8 + mat4(0.074328,0.083933,0.149717,-0.411795,-0.032905,-0.240095,-0.410363,0.085089,0.030369,0.037116,-0.213439,-0.221864,0.407886,0.068581,-0.100552,-0.061069) * L1_9 + mat4(0.328867,-0.165090,0.426671,-0.232592,-0.133494,-0.333453,-0.021585,0.173575,0.138713,-0.040265,-0.045061,0.102231,0.273129,0.196260,0.114615,-0.053826) * L1_10 + mat4(-0.017473,0.076396,0.031095,-0.016197,-0.210678,-0.276238,0.181697,-0.310255,0.196535,-0.024743,0.247260,0.168855,0.171940,0.194283,-0.021059,0.122494) * L1_11 + mat4(0.099002,-0.126535,0.136695,0.437136,0.153082,-0.221879,-0.413551,-0.439255,-0.074357,-0.395523,-0.594875,0.058083,-0.423243,0.165112,0.307301,-0.606512) * L1_12 + mat4(-0.173802,-0.164498,-0.003509,-0.178425,0.054642,0.166742,-0.264800,0.234817,0.108999,-0.048088,0.166243,0.217589,0.120235,0.062439,0.069747,-0.167706) * L1_13 + mat4(-0.092968,-0.327533,0.208142,-0.065558,-0.149888,-0.037274,0.203879,0.182698,-0.038191,-0.203367,-0.555507,0.112339,0.078107,0.044386,-0.466891,-0.005743) * L1_14 + mat4(0.381929,-0.278373,-0.286352,-0.156499,-0.130373,-0.087503,0.020514,0.220678,-0.186787,0.190823,-0.282393,-0.384381,-0.000064,-0.373724,-0.770037,0.145281) * L1_15 + vec4(0.119295,0.440877,0.099042,0.388032)));\nvec4 L2_2 = sin((mat4(-0.146968,0.019049,0.340311,0.281571,0.200063,-0.064326,-0.019946,-0.289114,0.237279,-0.079938,-0.125136,-0.014858,0.017215,-0.062984,0.146449,-0.143082) * L1_0 + mat4(0.112623,0.037561,0.242803,-0.054938,0.061401,0.107507,-0.163030,-0.016422,0.247219,-0.298161,-0.081166,-0.073265,0.189923,0.024802,0.445169,0.127650) * L1_1 + mat4(0.134461,-0.001707,-0.098510,-0.244427,0.079853,0.025952,0.241304,-0.193793,-0.232934,0.002100,-0.058722,0.058433,-0.363461,-0.227076,-0.066148,0.665089) * L1_2 + mat4(0.102120,0.248915,0.171991,-0.639562,0.112125,-0.117504,0.147563,-0.144198,-0.009915,-0.376219,0.186128,0.147194,0.125921,0.108906,-0.050919,0.511264) * L1_3 + mat4(0.394338,0.110443,0.197514,-0.323063,0.275560,0.100573,-0.122365,0.106127,-0.008676,-0.046535,-0.062053,0.395540,-0.029228,0.078437,0.284545,-0.431989) * L1_4 + mat4(0.745744,0.006646,-1.016205,-0.140934,-0.209098,-0.160822,0.245769,0.193788,-0.255631,-0.205702,-0.196659,-0.023495,0.045201,0.141375,-0.154390,-0.158483) * L1_5 + mat4(0.025730,-0.068028,-0.330679,-0.060121,-0.271334,0.211418,-0.198865,-0.018969,0.075102,-0.088710,-0.324441,-0.268605,0.264467,0.122193,0.121540,-0.305779) * L1_6 + mat4(-0.121957,-0.109087,0.202465,0.113833,-0.038202,0.049416,-0.063165,-0.283470,-0.099470,0.018619,0.079596,-0.503594,-0.116624,-0.285706,-0.099606,0.259260) * L1_7 + mat4(0.111651,0.042289,0.186121,0.095971,0.046704,-0.118837,0.046659,-0.496939,0.043962,0.062707,0.033459,-0.052122,-0.009107,0.093657,0.190852,0.159494) * L1_8 + mat4(-0.064333,-0.325432,-0.344304,-0.090373,0.255567,-0.019610,-0.242104,0.480581,-0.031818,0.127856,0.010723,0.406345,-0.291046,-0.076719,0.053806,0.058297) * L1_9 + mat4(-0.139317,-0.018036,-0.323013,0.006651,0.637039,-0.351556,0.094210,-0.152332,-0.144470,-0.285629,0.077866,0.308228,0.331627,0.292328,0.209772,-0.021942) * L1_10 + mat4(-0.008881,-0.013882,-0.148941,-0.071824,-0.244026,-0.127594,0.289867,-0.242562,0.059659,-0.090623,0.435616,-0.256663,0.184335,-0.200321,-0.116934,-0.285743) * L1_11 + mat4(-0.094681,-0.575541,0.052964,-0.060632,-0.102558,0.043474,0.064402,-0.137150,0.076512,0.187970,-0.021864,-0.193094,-0.252667,0.214216,0.001713,0.612499) * L1_12 + mat4(0.019799,0.061462,-0.042722,0.066638,0.047646,0.058543,-0.101427,-0.019602,0.012392,-0.109395,-0.075284,-0.376989,0.053569,0.088215,0.365264,-0.420774) * L1_13 + mat4(0.129065,0.218000,0.006508,-0.029476,0.156041,-0.029838,0.282173,-0.389853,-0.026643,0.037704,-0.081163,0.139174,-0.049401,0.002530,0.199544,0.159398) * L1_14 + mat4(0.123744,-0.046273,0.242313,-0.060911,-0.283790,-0.260145,-0.244329,0.082051,-0.183475,0.038312,-0.180280,-0.208718,0.009114,-0.038268,-0.108048,0.076050) * L1_15 + vec4(0.467341,-0.178704,-0.426258,0.489824)));\nvec4 L2_3 = sin((mat4(0.043795,0.363375,-0.178767,0.278697,-0.096041,0.152247,-0.418011,-0.110888,-0.024599,-0.059685,0.019744,0.130627,0.273589,0.071344,0.037545,0.120205) * L1_0 + mat4(-0.521077,0.054288,-0.009366,-0.071441,0.050167,-0.239172,-0.095574,-0.283652,-0.301519,-0.014899,0.123458,-0.096695,0.012245,0.247309,-0.124166,0.191662) * L1_1 + mat4(-0.283401,-0.169826,0.096954,0.183525,-0.207295,-0.099903,0.305994,0.416126,-0.266950,0.118154,-0.068646,-0.342003,-0.229426,0.215752,-0.093999,0.456698) * L1_2 + mat4(0.523348,0.064676,0.082485,0.208025,-0.249820,-0.286489,0.027611,-0.098865,-0.297363,-0.283997,-0.010388,-0.444425,-0.032747,-0.001404,0.185830,-0.361137) * L1_3 + mat4(0.036697,-0.292195,0.200100,0.197405,0.205119,-0.212460,-0.109031,-0.112486,0.232505,-0.191706,0.112329,-0.005671,-0.198684,0.057761,-0.200560,-0.204235) * L1_4 + mat4(0.260891,-0.453973,0.041684,0.569572,-0.055341,0.069788,0.464273,0.165743,-0.202316,-0.179485,-0.134469,0.075623,0.219402,0.146797,-0.168429,-0.153340) * L1_5 + mat4(-0.035184,-0.382998,0.452790,-0.030339,-0.254982,0.390478,0.141212,0.046684,0.024719,0.208741,-0.179658,-0.244126,-0.162434,0.052009,-0.130007,0.434971) * L1_6 + mat4(-0.185556,0.098120,0.139359,-0.147741,0.118371,0.510750,-0.125348,-0.268231,0.162515,-0.106317,0.211202,0.246889,-0.044981,-0.045157,-0.270467,-0.214036) * L1_7 + mat4(0.068871,0.262156,-0.137661,-0.377875,0.218427,0.032152,-0.260657,-0.170840,-0.100348,0.076205,0.165317,-0.166143,-0.035743,-0.505591,-0.506902,-0.161707) * L1_8 + mat4(0.532278,-0.092519,-0.092361,-0.235476,0.070830,-0.246745,0.261772,0.360340,0.209590,0.012407,0.130174,-0.261294,-0.153485,0.143455,-0.206733,-0.360695) * L1_9 + mat4(0.304714,-0.029396,-0.141067,0.155811,-0.029419,-0.014783,-0.171107,0.329895,0.040019,-0.451303,0.393265,-0.047552,0.078010,-0.078453,0.050370,-0.220973) * L1_10 + mat4(0.007674,-0.013275,0.055933,-0.039895,-0.255876,0.098387,-0.045105,-0.108984,0.069255,0.407409,0.134216,0.030802,0.043784,0.193492,0.040512,0.109274) * L1_11 + mat4(0.232292,0.383814,-0.222100,0.146898,0.048119,0.096058,-0.114216,-0.110428,0.058632,0.215191,-0.083710,0.289822,-0.007850,0.078714,-0.554228,-0.418477) * L1_12 + mat4(0.252689,0.252649,-0.015515,0.062765,-0.444149,0.037301,-0.037182,-0.153119,0.080084,0.398149,0.247394,0.150688,0.155148,0.131989,0.122384,-0.226954) * L1_13 + mat4(0.079389,-0.084507,0.043301,-0.077929,0.271124,0.251770,0.124634,0.381798,-0.083576,0.086486,-0.051783,0.067809,-0.171601,-0.234240,-0.255883,-0.179577) * L1_14 + mat4(0.125456,-0.160921,0.010271,0.125601,-0.124593,0.163709,-0.082528,0.075078,-0.195694,-0.220333,-0.244482,-0.041377,-0.357563,-0.190052,0.060743,-0.246543) * L1_15 + vec4(0.094283,0.392224,-0.827864,0.255251)));\nvec4 L2_4 = sin((mat4(0.292321,-0.165734,0.077619,0.075947,-0.119423,-0.557319,0.020742,0.244852,0.331017,0.247758,0.128026,-0.081215,0.008202,-0.410766,-0.044534,0.036316) * L1_0 + mat4(-0.055196,-0.132757,-0.317592,0.223663,0.155369,-0.105983,-0.117766,0.284519,0.144858,-0.256791,0.222833,0.012585,0.013671,0.219684,-0.164110,0.221121) * L1_1 + mat4(-0.175218,0.061482,0.086400,-0.157963,0.510929,-0.088537,-0.054296,0.091118,-0.157439,0.041755,0.152247,0.109222,-0.648998,-0.032642,0.124016,0.136970) * L1_2 + mat4(0.298988,-0.480186,0.161814,0.038473,0.115642,0.125700,0.289888,0.219716,0.016717,0.126892,0.238510,-0.171989,0.282864,-0.193179,-0.114312,-0.001414) * L1_3 + mat4(-0.318396,0.428807,-0.177169,-0.216401,-0.224410,-0.195181,0.148842,-0.059869,-0.222034,-0.055506,-0.040244,0.039610,-0.270935,0.587164,0.151702,-0.080351) * L1_4 + mat4(0.393485,0.059382,-0.024506,0.453013,0.105364,-0.167347,-0.409575,0.028803,-0.156692,0.095175,0.114000,-0.235579,0.297520,-0.021024,0.013559,0.261555) * L1_5 + mat4(-0.181339,-0.007406,0.351606,0.216942,0.250724,0.136770,0.101119,0.458613,0.080312,0.066037,0.278460,0.366343,0.276002,-0.092561,0.164695,-0.136949) * L1_6 + mat4(0.470956,0.253781,0.018730,0.342199,-0.002820,0.028001,0.224277,0.096774,-0.477649,0.025789,-0.153547,0.489825,0.263045,0.141666,0.121545,-0.060765) * L1_7 + mat4(0.501692,-0.337075,-0.425941,0.270778,0.121742,-0.104278,0.216411,-0.143043,0.137674,-0.105051,0.001648,-0.022961,-0.015376,-0.002781,0.135871,-0.158685) * L1_8 + mat4(-0.288071,0.159604,-0.642292,0.405022,-0.128584,-0.457360,0.022486,-0.071993,-0.546134,-0.268372,-0.172252,-0.084715,-0.579114,-0.316417,-0.681710,0.106323) * L1_9 + mat4(0.091633,-0.108540,-0.125051,-0.419658,0.027666,0.047798,-0.037567,0.018282,-0.121786,0.009878,0.032397,0.068643,0.325439,-0.201125,-0.015939,-0.086764) * L1_10 + mat4(0.074740,0.345264,0.007638,-0.064024,0.307844,-0.180607,-0.302830,-0.151950,-0.190047,0.114135,-0.508799,0.218913,-0.270628,0.383867,0.144821,0.282040) * L1_11 + mat4(-0.094849,0.219733,-0.158558,0.156256,0.404866,0.244288,0.180697,-0.216125,-0.093291,0.199824,0.426185,0.317154,0.273258,-0.101977,0.476217,-0.140014) * L1_12 + mat4(0.079503,-0.181284,0.171668,0.024806,-0.237453,-0.016308,0.225026,-0.046407,0.054029,-0.229350,0.195661,0.149388,0.594942,-0.378638,-0.008746,0.102928) * L1_13 + mat4(0.046726,-0.302833,-0.359486,-0.404707,0.112526,-0.138210,-0.010303,0.111660,-0.272575,0.089509,-0.231015,0.123531,-0.258562,-0.089646,0.188111,0.059676) * L1_14 + mat4(-0.090607,0.231567,0.114778,-0.085550,-0.109371,0.026892,-0.074410,-0.219776,0.150202,0.267164,-0.096706,0.223622,0.018698,0.339822,-0.094384,0.114891) * L1_15 + vec4(0.464807,0.084960,-0.309495,-0.531887)));\nvec4 L2_5 = sin((mat4(-0.144887,-0.265257,-0.147157,0.106561,-0.072360,-0.212443,0.031038,0.030989,-0.160422,-0.371837,-0.349082,0.168856,-0.026582,-0.190694,0.030832,-0.426229) * L1_0 + mat4(0.038068,-0.068687,0.383634,-0.069888,-0.062275,-0.308243,-0.168182,-0.230543,0.339635,0.014034,0.216727,-0.248768,0.119746,0.166537,0.369842,0.254782) * L1_1 + mat4(0.056708,-0.040157,-0.132194,-0.024106,0.000815,-0.065699,-0.277872,-0.057684,-0.024936,0.015414,-0.199524,-0.005467,-0.153640,0.120428,-0.107923,-0.192996) * L1_2 + mat4(-0.256149,0.007459,-0.022583,0.098390,-0.108052,0.247875,0.025075,0.282159,-0.238413,0.174997,-0.234303,-0.124962,0.436940,0.131541,-0.395193,0.129271) * L1_3 + mat4(0.244758,-0.023343,0.355373,0.336985,-0.114048,-0.101814,0.283295,0.220195,-0.059361,0.311791,0.237247,0.030471,0.207790,0.525901,-0.482338,-0.097528) * L1_4 + mat4(0.301987,-0.018684,0.068403,-0.063898,0.013868,-0.230468,0.225413,0.153212,-0.186469,0.367128,0.091477,0.073300,-0.045295,0.003779,-0.216936,0.034673) * L1_5 + mat4(-0.102138,0.268918,0.124606,-0.069538,0.169491,-0.021403,-0.179899,-0.331756,0.031607,0.170839,0.118067,-0.159212,0.132257,0.676871,-0.105822,0.215338) * L1_6 + mat4(0.017823,0.002720,0.117443,0.053237,0.084765,0.036075,0.009913,-0.067701,-0.042297,-0.328926,0.110433,0.441650,0.304489,0.033259,-0.078157,-0.026253) * L1_7 + mat4(0.383058,-0.159770,0.108747,-0.065330,-0.117201,-0.122440,-0.021936,-0.004964,-0.075423,0.319427,0.054716,-0.005058,0.408619,-0.248636,-0.041812,0.119519) * L1_8 + mat4(0.136984,0.140463,0.258058,-0.044293,0.355133,0.443419,0.399112,-0.134924,0.112185,0.279925,0.048836,0.229128,-0.160235,0.682946,-0.117961,-0.072580) * L1_9 + mat4(0.354581,-0.449131,-0.033323,0.185502,0.148981,0.430063,0.266938,-0.007126,0.062333,-0.261646,-0.069005,-0.010667,-0.017313,-0.253966,0.075344,-0.184386) * L1_10 + mat4(0.036488,0.227529,0.181832,0.102965,-0.142173,0.248750,0.125067,0.105615,0.088840,-0.357808,0.137244,0.334073,-0.195385,-0.184115,0.004741,0.284027) * L1_11 + mat4(0.125834,0.130611,0.083882,-0.164669,0.311083,-0.580294,0.362012,0.017095,-0.022716,0.139730,-0.117166,-0.003001,0.007940,0.038574,0.198735,0.001503) * L1_12 + mat4(-0.036260,-0.059650,0.010588,0.129695,0.029159,0.267747,0.220627,-0.093928,0.200185,-0.200695,0.120882,-0.151361,0.190586,-0.245340,0.243028,0.189932) * L1_13 + mat4(-0.210302,-0.042822,-0.026325,-0.015015,0.319247,0.074938,0.188652,-0.072905,0.139636,0.068740,-0.236740,-0.068241,0.266363,0.075731,-0.345991,0.353443) * L1_14 + mat4(0.303589,-0.374034,-0.165385,0.251834,-0.078786,0.045042,0.173811,0.203684,0.242000,-0.044011,0.167543,0.233870,-0.131549,0.175050,-0.387027,-0.400077) * L1_15 + vec4(0.142705,0.770081,0.168994,0.048500)));\nvec4 L2_6 = sin((mat4(0.018734,-0.192971,0.144140,-0.063774,-0.166597,-0.058675,0.371960,-0.470485,-0.113860,-0.032012,0.171509,-0.298466,-0.039281,0.112258,-0.376012,0.048768) * L1_0 + mat4(-0.094875,0.158963,0.255102,0.010971,-0.102085,0.029290,-0.328730,0.292066,-0.005612,-0.048239,0.178225,0.326910,-0.019320,0.073099,-0.415321,0.113717) * L1_1 + mat4(0.053048,0.013864,-0.167441,0.197508,0.147354,-0.459551,0.031751,-0.021513,-0.304433,-0.283811,0.071935,-0.215717,0.375576,-0.169695,-0.080853,-0.134896) * L1_2 + mat4(0.528818,-0.360685,-0.038093,-0.244192,0.069082,0.280540,0.002744,-0.051100,0.468887,-0.048677,0.200154,-0.063554,0.447196,-0.164146,-0.323019,0.311013) * L1_3 + mat4(-0.020637,0.334509,0.033855,-0.389114,0.304037,0.020102,-0.198188,0.232721,0.200834,0.390047,-0.250431,-0.204940,0.053567,-0.195675,0.458420,0.331405) * L1_4 + mat4(0.238625,-0.317999,-0.263784,0.191013,-0.206849,0.100066,-0.051554,0.229890,0.369632,-0.024315,0.086816,0.306049,-0.085842,0.264670,-0.165347,-0.081434) * L1_5 + mat4(0.114954,0.246977,0.066467,0.118861,-0.118167,-0.094678,0.094570,0.214053,-0.131681,0.086621,0.237650,-0.211622,-0.250642,0.012981,-0.123440,0.206849) * L1_6 + mat4(-0.265162,-0.626220,-0.240613,0.064825,0.011542,-0.070001,0.179920,-0.134525,0.331052,0.194029,-0.300463,-0.200525,-0.181221,-0.213907,0.057172,-0.095248) * L1_7 + mat4(-0.125442,-0.287728,-0.116643,0.170987,-0.142503,0.038669,-0.083943,-0.084132,0.035990,0.020613,-0.119819,-0.265250,-0.046890,-0.180135,0.466603,0.312337) * L1_8 + mat4(0.085102,-0.072564,0.224552,-0.261628,-0.134104,-0.241161,0.383742,-0.329742,0.066159,-0.448305,0.022735,-0.009145,-0.234048,-0.037656,0.409293,0.034561) * L1_9 + mat4(-0.291820,-0.024321,0.171139,0.112266,0.185432,0.222623,-0.134558,0.411009,0.123683,-0.192291,-0.020162,-0.101293,-0.042941,-0.165294,0.057550,-0.221901) * L1_10 + mat4(0.284607,-0.078086,-0.072092,0.085551,-0.129272,-0.059872,-0.348755,0.141385,0.407046,-0.096857,-0.196179,0.289394,-0.179466,0.148740,-0.173378,-0.081427) * L1_11 + mat4(-0.242103,-0.026037,0.042048,-0.206119,-0.289400,-0.186034,-0.416165,0.463570,-0.229056,0.043114,0.164981,0.173328,-0.362260,0.211918,0.254579,-0.251266) * L1_12 + mat4(0.022852,0.089868,-0.022772,0.186068,0.102971,-0.076866,-0.082588,0.308741,0.220118,0.036491,-0.095769,-0.091794,0.209545,-0.075002,0.190343,0.061139) * L1_13 + mat4(0.414039,0.100766,0.156257,-0.130382,-0.150668,0.030754,0.032139,-0.447317,0.254607,-0.191115,-0.111478,0.080146,0.011398,-0.322058,-0.036776,-0.203694) * L1_14 + mat4(-0.215893,-0.102350,0.227141,-0.094134,-0.009060,0.231438,0.063536,-0.229540,-0.088720,-0.314663,-0.301821,-0.198985,-0.157348,0.114257,0.078573,-0.248709) * L1_15 + vec4(-0.189407,0.710205,0.188498,-0.560535)));\nvec4 L2_7 = sin((mat4(0.034654,0.023131,0.262962,-0.131589,-0.274217,0.206761,0.175940,-0.116543,0.130996,0.419445,0.369503,0.091831,-0.225570,0.107489,0.029956,-0.332211) * L1_0 + mat4(0.061512,-0.319164,-0.151188,0.341578,-0.304244,0.274387,0.075479,-0.200949,0.012084,0.039233,-0.066042,0.152042,0.052677,0.022118,0.219649,0.210020) * L1_1 + mat4(-0.012691,0.079741,0.145154,0.183627,-0.150790,0.016733,0.140447,-0.169728,0.485961,-0.083945,0.037476,0.244422,-0.195264,0.060173,-0.080921,0.049593) * L1_2 + mat4(-0.292012,0.085132,0.079684,-0.421096,0.097975,-0.090969,-0.073248,0.135398,-0.514593,-0.091921,-0.184953,-0.140229,-0.265618,-0.162515,0.265766,-0.302018) * L1_3 + mat4(-0.041565,-0.367545,0.417522,-0.082235,-0.370626,-0.147889,-0.202161,0.262919,-0.011281,0.028650,0.128636,-0.006335,-0.192343,0.320459,-0.069586,0.663509) * L1_4 + mat4(-0.343187,-0.306999,-0.197421,-0.036454,-0.205212,-0.337452,-0.079755,0.229889,0.049580,-0.272343,-0.042018,0.358525,0.194794,-0.203406,0.036786,0.004331) * L1_5 + mat4(-0.185835,-0.155518,0.033475,0.239985,0.220275,0.088857,0.181127,0.096966,0.246629,0.105521,-0.044080,0.186432,-0.036842,0.400786,0.060499,0.047050) * L1_6 + mat4(-0.190856,0.234975,-0.124539,0.177978,-0.095102,-0.274902,0.150506,-0.369971,-0.003211,0.095143,-0.401647,-0.022959,0.017770,0.178332,0.437982,-0.137716) * L1_7 + mat4(0.109208,0.077358,0.151487,-0.284291,-0.156665,-0.003735,-0.133618,-0.140912,0.058028,0.029093,0.211549,0.635089,0.364675,0.031653,-0.317637,0.351440) * L1_8 + mat4(-0.127365,0.340876,-0.307266,-0.194182,-0.048819,-0.014129,-0.341968,0.314620,0.190439,0.138237,-0.250591,0.359623,-0.163480,0.130059,0.312728,0.112037) * L1_9 + mat4(0.014217,0.228584,0.189282,0.027325,-0.326473,-0.289403,0.133950,0.009953,-0.018094,-0.292180,0.062755,-0.110630,0.018019,0.204412,0.261667,-0.117936) * L1_10 + mat4(0.104293,-0.060420,-0.209366,0.403950,-0.183570,0.137642,0.040651,0.060669,-0.007341,-0.288659,0.016729,0.011248,0.036931,0.275306,0.220821,-0.450576) * L1_11 + mat4(0.090630,0.272162,0.064341,0.103780,0.337637,-0.206873,-0.105514,0.114541,-0.042931,0.409005,0.050158,-0.383304,0.444018,-0.114532,0.205496,-0.434110) * L1_12 + mat4(-0.105020,-0.266882,0.072427,-0.069692,0.000386,-0.393141,-0.178944,0.420262,0.140791,-0.112158,0.044334,0.138096,0.086382,-0.144620,0.141655,-0.406254) * L1_13 + mat4(-0.077832,0.321022,0.079331,-0.002739,0.460238,-0.188649,-0.138761,0.231978,0.019659,-0.078995,-0.069869,0.450390,0.043287,-0.160468,0.013340,0.004316) * L1_14 + mat4(0.101417,0.469970,-0.006099,-0.023723,-0.104052,-0.029583,0.165089,-0.205794,0.199942,0.074334,-0.213034,0.459656,0.092928,-0.347861,-0.124716,-0.282242) * L1_15 + vec4(0.449651,-0.804114,0.678605,-0.246061)));\nvec4 L2_8 = sin((mat4(0.063006,0.118604,-0.112948,0.102672,0.108612,0.207377,0.072362,0.193967,-0.109685,0.065826,-0.076174,0.087385,0.291479,-0.157726,0.020133,0.037049) * L1_0 + mat4(0.059057,-0.042842,-0.104210,0.068625,-0.646719,-0.127238,0.200804,0.241248,0.363591,0.411266,-0.092463,-0.099538,-0.244867,0.151231,-0.110140,0.257614) * L1_1 + mat4(-0.217855,0.033212,-0.327169,0.082933,-0.046675,0.260710,-0.059495,0.205139,0.111956,0.001340,0.187477,-0.191083,0.191197,0.304061,-0.094770,0.069229) * L1_2 + mat4(0.276350,-0.438910,-0.158483,-0.056319,-0.166589,-0.078256,-0.104277,-0.241576,0.136308,-0.069064,0.190903,0.082254,-0.248549,-0.335505,0.503605,0.002864) * L1_3 + mat4(-0.389230,-0.168294,0.505070,-0.023605,-0.327724,-0.018652,-0.391438,0.141768,0.007816,-0.167988,0.265738,-0.418544,0.394659,-0.049298,-0.123861,0.279332) * L1_4 + mat4(-0.306098,0.371308,0.387431,-0.156690,0.055229,-0.079035,0.004831,0.105494,-0.227716,0.334487,-0.174176,-0.019575,-0.273501,0.196813,0.092414,-0.168606) * L1_5 + mat4(-0.380206,-0.104128,0.163636,-0.059897,0.104236,0.197609,0.137412,0.022782,0.371948,0.135349,-0.030875,0.368687,0.197883,0.297435,-0.269028,-0.162690) * L1_6 + mat4(-0.714032,-0.075173,-0.519918,0.081607,-0.035829,-0.359368,0.002656,-0.206435,-0.044979,0.234489,-0.226919,0.112523,-0.420212,-0.120753,0.211415,0.541302) * L1_7 + mat4(0.097657,-0.304873,-0.081605,0.334443,-0.091891,0.093392,0.094258,-0.071109,-0.291583,-0.104472,0.143556,-0.002565,-0.486022,-0.040115,0.023384,0.161350) * L1_8 + mat4(0.223538,0.126520,-0.400053,-0.497386,0.259374,-0.281238,-0.485117,-0.403295,0.235752,-0.012735,-0.092945,-0.305981,-0.021107,0.010450,-0.226504,-0.214704) * L1_9 + mat4(0.198298,0.019552,0.288846,-0.091503,-0.254787,-0.126864,0.031942,0.222284,-0.114082,-0.179274,0.118944,-0.313185,0.164111,0.297345,0.080637,-0.186488) * L1_10 + mat4(0.054970,0.074938,-0.224531,-0.254679,0.083926,-0.031887,0.022126,-0.014237,-0.415319,0.423512,-0.168757,-0.005613,0.254796,-0.541688,0.105905,-0.231498) * L1_11 + mat4(0.490251,-0.141514,-0.067593,-0.257834,0.124249,-0.023852,-0.168461,0.224459,-0.003417,0.135493,-0.190467,0.081877,0.210276,0.197442,0.509435,0.175653) * L1_12 + mat4(-0.089212,0.031638,0.008026,-0.242287,0.113422,0.025443,0.023109,-0.376690,-0.213046,-0.071696,0.237271,0.073602,0.034162,0.273147,-0.017570,-0.124953) * L1_13 + mat4(-0.103776,-0.089922,0.328380,0.149447,0.044481,0.136849,0.061834,-0.257286,0.265659,0.108922,-0.067841,0.235617,0.007367,0.292323,-0.225496,0.026826) * L1_14 + mat4(-0.214259,0.179160,-0.185176,-0.177104,-0.096829,-0.121051,0.111188,-0.225010,0.243597,-0.009765,-0.324033,0.194188,0.021570,0.324590,0.151259,0.155099) * L1_15 + vec4(0.145487,-0.207262,-0.245522,-0.380178)));\nvec4 L2_9 = sin((mat4(-0.260968,0.258941,-0.169252,-0.087146,0.104444,0.055597,0.019494,0.139880,0.142217,-0.033321,0.108219,-0.176693,0.067110,0.010693,-0.269978,0.134150) * L1_0 + mat4(0.420313,-0.068398,0.173150,0.032049,0.349744,0.147549,-0.049024,0.093297,-0.361005,0.185577,0.254291,0.266941,0.043139,0.153404,-0.154019,-0.236035) * L1_1 + mat4(0.343957,0.022728,-0.312915,0.057711,0.026836,-0.071015,-0.236312,0.230676,-0.248714,0.304190,0.187750,-0.044287,-0.233432,-0.068424,0.464881,0.277614) * L1_2 + mat4(-0.095616,0.012528,0.894151,0.074763,-0.123937,0.274321,0.189350,0.373548,0.099424,-0.366814,-0.502118,0.000085,0.277776,0.245494,-0.044686,-0.198431) * L1_3 + mat4(0.357477,-0.007410,0.015786,-0.393545,0.444970,-0.361122,0.316077,-0.120914,0.054036,0.033801,0.161325,0.083439,-0.243051,0.142264,0.343820,-0.005194) * L1_4 + mat4(0.263762,-0.409705,0.031448,0.393186,-0.178663,0.022421,0.045360,0.014918,0.231872,0.043760,-0.014796,-0.137304,0.217081,-0.034062,-0.326035,0.264240) * L1_5 + mat4(0.139107,-0.004218,0.211323,-0.230684,-0.173227,0.362870,-0.251972,-0.031698,-0.045005,-0.107250,0.101012,0.386050,-0.024262,0.163513,0.451171,0.221384) * L1_6 + mat4(0.196425,0.261607,-0.037231,0.239261,0.168624,-0.258115,-0.230138,0.077609,-0.389847,0.161534,-0.003667,-0.189143,-0.663268,-0.244797,0.283724,0.038186) * L1_7 + mat4(-0.251311,-0.304041,0.239613,-0.097792,-0.111486,0.176614,-0.329745,0.163473,0.205496,0.069651,0.003174,0.132787,0.179015,0.118063,0.105341,0.155745) * L1_8 + mat4(0.043597,0.339429,-0.042794,0.001311,-0.203213,0.087629,-0.030907,-0.210218,-0.130490,0.020626,0.048475,-0.122273,-0.049312,-0.632239,-0.676047,0.397941) * L1_9 + mat4(-0.238563,-0.033951,0.312137,0.286021,-0.142261,-0.060369,0.203222,-0.630856,-0.345649,-0.212965,-0.214110,-0.073156,-0.058301,0.063859,0.001958,0.085358) * L1_10 + mat4(0.082688,0.104205,0.159147,0.215613,0.102770,0.023081,0.074222,-0.225248,0.200527,0.184253,0.127026,0.032575,0.074186,0.042959,0.246075,0.295456) * L1_11 + mat4(-0.233711,-0.017559,0.243436,0.137841,0.013419,0.110857,0.016895,0.099150,0.049167,-0.180515,0.139953,0.225201,-0.503599,0.237441,0.115677,-0.208968) * L1_12 + mat4(-0.019589,-0.164534,0.158024,-0.144248,0.086881,-0.278561,0.428187,-0.066145,-0.100553,-0.050643,-0.164357,0.127991,-0.005102,0.483607,-0.026070,-0.268533) * L1_13 + mat4(-0.018219,-0.316482,0.198383,0.218982,0.043881,-0.044545,0.404617,-0.038843,0.210878,0.376825,-0.197741,-0.150106,0.066075,0.074643,-0.084632,0.427231) * L1_14 + mat4(-0.040320,-0.084373,0.245855,0.154937,0.283145,0.081512,-0.051595,-0.053360,-0.109201,-0.233277,0.183946,0.166200,-0.060239,-0.069856,-0.100613,-0.178919) * L1_15 + vec4(0.721770,0.379825,-0.691074,-0.348572)));\nvec4 L2_10 = sin((mat4(0.163461,-0.087914,0.194196,-0.163538,-0.179067,0.307793,-0.130416,0.021676,-0.052278,0.349518,-0.001255,-0.250251,0.455477,0.054497,-0.050302,-0.320533) * L1_0 + mat4(0.044580,-0.343053,-0.037955,-0.136108,0.284539,0.474417,0.184508,0.169548,0.455573,0.085371,0.117410,-0.122180,-0.001254,0.022811,-0.073639,-0.185303) * L1_1 + mat4(-0.121498,-0.096732,-0.124223,0.328048,0.244778,0.017844,0.135215,-0.115133,-0.518512,0.134922,0.069875,-0.262191,-0.114695,0.047223,0.239262,-0.244788) * L1_2 + mat4(0.083367,0.253628,0.476840,0.034165,0.209623,-0.659856,0.026474,-0.270962,0.074422,-0.058048,0.106915,-0.088801,-0.493740,-0.108612,-0.092071,-0.282023) * L1_3 + mat4(-0.253422,0.007614,-0.339637,-0.293480,-0.323280,0.042859,-0.472904,0.019296,-0.189182,0.266302,-0.138721,0.041310,-0.039336,-0.334667,0.230768,-0.142458) * L1_4 + mat4(-0.616618,0.462102,-0.502663,-0.129252,-0.011382,0.229330,0.211564,0.180326,-0.156253,0.132287,-0.021470,0.029963,-0.133603,-0.192491,-0.343283,-0.108871) * L1_5 + mat4(-0.119720,-0.448408,-0.530219,-0.211411,0.015008,0.131023,0.029379,-0.294866,-0.283226,-0.369329,0.060162,-0.213445,-0.024189,0.245888,0.240797,0.250848) * L1_6 + mat4(-0.441201,0.141934,-0.133343,-0.121708,-0.102468,-0.148076,0.218228,0.301971,0.382224,-0.040053,0.216179,0.179485,-0.251805,-0.110341,-0.092427,0.083386) * L1_7 + mat4(-0.264302,-0.127215,-0.145018,-0.239327,0.076540,-0.331859,-0.157137,0.025047,0.264065,-0.113411,-0.063836,-0.176708,0.532951,0.238526,0.290703,-0.440314) * L1_8 + mat4(-0.105444,0.039619,-0.099571,0.202784,0.176465,0.126199,0.063238,0.036365,0.374646,-0.186181,0.069662,0.091056,0.276261,-0.297045,0.120945,0.200782) * L1_9 + mat4(-0.176467,0.555757,-0.016813,-0.325173,-0.179147,-0.119305,-0.195831,-0.095326,-0.075398,0.288869,-0.463296,0.083407,-0.461330,0.330566,-0.162015,0.036553) * L1_10 + mat4(-0.247521,0.219947,-0.291949,0.188104,0.273333,-0.367351,-0.184234,-0.217450,-0.403249,0.199397,-0.064862,-0.025746,-0.396750,0.416047,0.236234,0.525417) * L1_11 + mat4(0.184452,0.186475,-0.024480,0.157005,-0.154056,0.168910,0.118152,0.289844,-0.214832,0.296478,0.039388,-0.214657,0.767205,-0.570358,-0.306242,-0.176955) * L1_12 + mat4(-0.298609,0.053662,-0.271848,0.001381,-0.640505,0.119597,0.225836,0.078020,0.080660,0.243346,0.474880,-0.156738,0.395583,-0.110776,-0.501421,-0.373746) * L1_13 + mat4(-0.458799,0.262240,0.206617,-0.315324,0.310561,0.305803,0.198426,0.139379,0.345296,-0.348433,-0.244042,-0.171715,0.028786,-0.056852,-0.092384,0.231829) * L1_14 + mat4(-0.047781,-0.065258,0.225455,0.240699,0.058034,-0.259070,0.176361,0.163543,0.261384,0.138997,-0.324957,-0.292771,-0.665793,0.291425,-0.294540,0.072615) * L1_15 + vec4(-0.666404,-0.635879,-0.249307,-0.090406)));\nvec4 L2_11 = sin((mat4(-0.092708,-0.080640,-0.058987,0.064440,-0.035935,0.265131,0.022318,0.223599,-0.154620,-0.035569,0.007523,-0.075108,0.073983,-0.027023,0.026576,-0.233870) * L1_0 + mat4(-0.022339,-0.420267,-0.137006,0.169619,0.091378,-0.177080,-0.367825,-0.413362,0.125060,-0.109407,-0.052759,0.056882,-0.212341,-0.145545,-0.378031,0.018685) * L1_1 + mat4(-0.197638,0.120116,0.027836,-0.217827,0.024796,-0.364255,0.348434,0.090716,-0.375573,0.038091,0.394625,-0.331133,-0.021083,0.555512,0.329568,-0.050164) * L1_2 + mat4(-0.391070,0.008960,0.117516,-0.028740,0.049765,-0.187241,0.240134,0.311416,0.115723,-0.118038,0.084476,0.251248,0.184505,-0.016603,0.106558,0.212276) * L1_3 + mat4(0.078396,-0.528271,-0.388867,-0.012054,0.219422,-0.186441,0.386523,0.085012,-0.081469,0.250065,-0.438607,-0.036271,-0.006061,-0.426495,0.344871,0.045549) * L1_4 + mat4(0.225464,0.507023,0.839726,0.439757,0.004656,0.155620,-0.086473,0.348983,0.089114,-0.275514,-0.148264,0.173399,0.019776,-0.229056,0.027290,-0.050113) * L1_5 + mat4(0.104020,-0.011744,-0.109180,0.298116,0.408051,-0.014939,0.043827,0.221237,0.110104,0.139692,-0.083664,0.170073,-0.094333,0.046574,0.492597,0.130538) * L1_6 + mat4(-0.477331,-0.099626,-0.136279,0.206071,-0.176347,-0.341847,0.176115,-0.066515,0.043368,-0.264571,0.540631,0.132562,-0.256226,-0.218937,-0.172481,0.047979) * L1_7 + mat4(-0.126768,0.229292,0.429584,0.322988,-0.138512,-0.259234,-0.190774,-0.077056,0.064258,0.151285,-0.129949,-0.004451,0.254396,-0.299684,0.505553,0.032974) * L1_8 + mat4(0.243324,0.147121,-0.062210,-0.401853,0.023219,-0.180515,0.073966,-0.236966,-0.017197,-0.162875,0.052728,-0.152465,0.094712,-0.216536,-0.100311,-0.149163) * L1_9 + mat4(0.578413,-0.055933,-0.075054,0.583436,-0.119893,-0.322094,-0.045969,0.411130,-0.177469,-0.026188,-0.397278,0.437090,-0.082939,0.197241,0.121909,0.045869) * L1_10 + mat4(0.051336,-0.245042,0.271304,-0.021061,0.043763,-0.362009,0.455547,0.603832,0.218874,0.123407,-0.440864,0.133602,-0.324311,0.009465,-0.153544,-0.144830) * L1_11 + mat4(-0.200572,-0.100698,-0.665785,-0.102204,-0.341907,-0.301474,0.377475,-0.046224,0.014890,0.257363,-0.202458,-0.184299,-0.087674,-0.103402,-0.038015,-0.255994) * L1_12 + mat4(-0.224386,0.148613,0.231802,0.535844,0.097959,0.037745,-0.031888,0.263656,-0.304894,-0.173841,-0.402413,0.041892,0.070243,-0.415680,0.341667,0.221888) * L1_13 + mat4(0.049990,0.173716,0.145477,0.039941,-0.373354,-0.083675,-0.495610,-0.316151,0.024102,-0.139254,-0.048504,-0.345471,-0.052502,0.145370,-0.303991,-0.153725) * L1_14 + mat4(-0.313620,0.102852,-0.436954,-0.258021,0.018437,-0.134429,0.416906,0.235631,-0.061029,-0.394717,-0.372250,-0.054822,-0.178449,0.190305,0.000131,0.060296) * L1_15 + vec4(0.444040,-0.291094,0.609378,-0.547882)));\nvec4 L2_12 = sin((mat4(0.398632,0.075289,0.269026,0.237104,-0.017516,-0.022267,-0.272035,0.012741,0.011036,0.026409,0.058417,0.142735,0.465631,-0.128877,0.192899,-0.108003) * L1_0 + mat4(-0.072737,-0.229063,-0.156586,0.152566,0.282269,-0.035627,0.148339,0.295809,-0.021081,0.144020,-0.324715,-0.130906,-0.095441,-0.274482,-0.265668,-0.161473) * L1_1 + mat4(0.009035,0.096751,-0.001650,0.307365,-0.174823,0.142497,-0.095843,-0.049371,0.596856,-0.055386,-0.337423,0.351644,-0.293781,0.126950,0.109132,-0.147662) * L1_2 + mat4(-0.005601,0.142913,0.204169,-0.010422,-0.056072,0.047878,0.319614,0.100970,-0.447686,0.218550,-0.069032,-0.208771,0.041367,-0.005355,0.267581,0.260674) * L1_3 + mat4(0.006287,0.008352,-0.241058,0.237811,-0.965687,0.001757,0.033367,0.356573,-0.382033,-0.094557,-0.146436,0.261869,-0.069351,-0.208241,0.530668,-0.115010) * L1_4 + mat4(-0.421413,-0.367402,0.977301,0.744359,0.196103,-0.244434,0.060133,-0.293244,0.114297,0.507978,0.081203,-0.024912,0.177855,-0.117585,-0.093608,0.405825) * L1_5 + mat4(-0.365484,0.086221,-0.132974,-0.192940,0.434988,0.023691,0.382900,0.120739,-0.421102,0.016406,0.238106,0.239139,0.013075,0.309411,0.232403,0.098348) * L1_6 + mat4(0.219313,-0.198775,0.247353,-0.106294,-0.072996,-0.069869,0.104433,0.126212,-0.110143,0.132258,-0.014577,-0.137051,0.063453,-0.073616,-0.210635,-0.326688) * L1_7 + mat4(-0.137932,-0.381539,-0.381538,-0.225715,0.016882,0.056055,0.130562,0.158868,0.145096,0.186548,-0.247573,-0.064378,-0.054635,0.140301,0.195168,0.239205) * L1_8 + mat4(0.193982,-0.031757,-0.072563,-0.307644,-0.349229,0.299276,0.010222,0.012648,-0.128473,0.305253,0.111087,0.191270,0.394687,0.096091,0.107035,0.346993) * L1_9 + mat4(0.073308,-0.037589,-0.001218,-0.515883,-0.009354,0.065160,0.055826,-0.089743,0.035061,-0.388278,0.168697,0.224846,0.009501,0.102131,0.146622,-0.124861) * L1_10 + mat4(-0.344573,-0.483911,-0.214603,0.110307,-0.160487,-0.036590,0.008342,-0.099982,0.298054,0.340063,0.081596,-0.409810,0.065285,-0.163952,0.127910,-0.077671) * L1_11 + mat4(-0.074933,0.133076,0.284458,0.054023,0.426994,0.451527,0.074037,0.159526,-0.141397,0.040681,0.317661,-0.216700,0.368721,0.365292,-0.475033,0.140678) * L1_12 + mat4(-0.102246,-0.001080,0.060100,0.420690,0.385291,0.325631,-0.196191,0.120479,0.072444,-0.079519,-0.046151,0.135807,0.177435,-0.072084,-0.013954,0.065000) * L1_13 + mat4(-0.231299,-0.004815,-0.196822,0.162548,0.180149,-0.143895,0.255649,0.137023,0.334623,-0.126831,0.020150,-0.144741,-0.298631,-0.266051,0.160739,0.134375) * L1_14 + mat4(0.147201,0.166495,0.489011,0.072543,0.006292,0.017592,0.342849,0.187052,-0.480999,0.376030,-0.358340,0.047115,0.042445,0.372197,0.018997,-0.075440) * L1_15 + vec4(-0.074182,0.046963,-0.386270,1.063388)));\nvec4 L2_13 = sin((mat4(0.033623,0.165194,-0.012112,-0.112971,0.138348,0.121017,-0.352723,0.045604,0.015491,-0.189862,0.019086,-0.170459,0.034437,0.237931,0.048899,0.375153) * L1_0 + mat4(-0.090719,0.170332,0.677425,0.038061,-0.459265,0.123694,0.024302,-0.320591,-0.148799,0.320924,0.137972,0.018519,0.001438,0.023558,0.167479,-0.804021) * L1_1 + mat4(-0.337456,0.067549,-0.509145,0.056492,0.097984,0.140843,0.195483,0.091567,-0.053536,-0.127911,-0.428353,-0.359755,-0.192958,-0.321373,-0.263139,-0.118654) * L1_2 + mat4(0.186293,0.195655,-0.023243,0.239377,0.357953,0.433857,0.226147,-0.316736,-0.015802,-0.316704,0.121642,-0.119686,0.193230,0.046713,-0.029907,-0.156976) * L1_3 + mat4(0.137075,0.274526,-0.002379,0.138182,-0.082337,0.029207,0.163593,0.208241,-0.129372,-0.156050,0.036929,0.214084,0.486249,-0.063105,-0.036824,0.397771) * L1_4 + mat4(0.058255,-0.087420,0.227616,0.022793,0.178082,0.313766,0.086796,0.379744,-0.303653,0.202213,0.206171,0.052223,0.001728,0.106231,0.082582,-0.328337) * L1_5 + mat4(-0.068802,0.099053,-0.098103,0.215485,0.359099,0.426655,0.002014,0.055705,-0.138949,0.043528,0.197994,0.255645,-0.097413,0.018913,-0.356180,0.584638) * L1_6 + mat4(0.293685,0.331108,-0.186439,-0.138687,0.283911,-0.243817,0.092312,-0.272315,0.480832,-0.013967,-0.183660,-0.286722,-0.210806,-0.157865,0.121527,-0.168048) * L1_7 + mat4(-0.186437,-0.086342,0.168640,0.124240,-0.136800,-0.095096,-0.003906,-0.246243,-0.009622,-0.306890,0.133902,-0.222822,-0.167731,-0.300896,-0.110328,-0.076248) * L1_8 + mat4(-0.187000,0.114792,-0.155925,-0.402595,0.427542,0.492434,0.197629,0.396142,0.111838,-0.137995,0.065702,0.163540,-0.326342,-0.138814,0.708570,-0.773455) * L1_9 + mat4(0.036232,0.048530,-0.144951,0.227759,0.177454,0.145822,-0.079139,-0.046198,0.226513,-0.343848,-0.277420,-0.214801,0.179487,0.232615,-0.103168,0.105810) * L1_10 + mat4(-0.232830,0.230377,-0.263142,-0.204077,0.037497,0.302655,0.203527,-0.107873,-0.100122,0.205853,0.072641,-0.160559,0.293777,-0.035875,-0.040294,-0.159623) * L1_11 + mat4(-0.054702,0.101893,0.441639,0.127202,-0.089836,-0.061360,0.140355,0.039577,0.023839,0.195204,-0.129459,-0.036739,-0.263659,-0.455167,0.346754,-0.338470) * L1_12 + mat4(0.189909,-0.429658,0.079351,-0.038701,-0.686411,-0.129777,-0.338280,0.488755,-0.386478,-0.114209,0.088203,0.194857,-0.109343,0.535321,0.172485,0.273173) * L1_13 + mat4(0.104231,0.006602,-0.493932,0.152421,-0.004945,0.038693,-0.289158,-0.259188,0.238126,0.039965,0.269444,0.135345,0.591079,-0.061756,-0.130544,-0.159482) * L1_14 + mat4(0.291566,-0.167477,0.008312,0.374170,-0.318471,-0.037197,0.055984,0.249173,0.186082,0.219537,-0.148890,-0.758275,0.022326,0.128499,-0.468631,-0.094344) * L1_15 + vec4(0.092629,-0.217709,-0.271320,0.133472)));\nvec4 L2_14 = sin((mat4(0.219931,0.254805,-0.329837,-0.302083,-0.361060,0.020754,0.016705,0.576500,0.163389,0.318452,0.082958,-0.258348,0.293482,-0.111647,0.352213,-0.008125) * L1_0 + mat4(0.316967,-0.065853,-0.056676,0.477752,-0.358445,-0.105685,-0.453092,-0.071722,-0.493015,-0.156509,0.201770,0.088824,0.124488,0.168992,-0.156223,0.206991) * L1_1 + mat4(-0.228527,0.107716,-0.042747,0.087487,-0.325614,0.074652,-0.259381,-0.497926,0.193863,0.336666,-0.118330,0.464180,0.209919,0.096452,-0.195484,0.737205) * L1_2 + mat4(-0.112404,0.720547,-0.379697,0.024215,-0.261966,0.429871,0.429795,-0.324247,0.545122,-0.267512,0.005269,0.215654,0.167541,-0.167509,-0.458005,0.211480) * L1_3 + mat4(0.135107,0.193067,0.129029,-0.096742,-0.359169,0.032265,-0.297865,0.225762,-0.105872,0.093933,-0.044523,0.097917,-0.114589,0.266657,0.222439,-0.101579) * L1_4 + mat4(-0.021931,0.623523,0.422335,0.268574,-0.010589,-0.005080,0.516203,0.049497,0.384944,0.071064,0.350935,0.061323,-0.207486,0.238914,-0.059333,-0.272066) * L1_5 + mat4(-0.667682,0.108453,0.476888,-0.013206,-0.603677,0.079328,0.048408,0.776169,0.320503,-0.058291,0.106755,0.117261,-0.195293,0.334412,0.275690,-0.177487) * L1_6 + mat4(0.182594,-0.220904,0.283833,-0.255413,0.334131,-0.084744,0.110787,-0.029427,-0.321984,0.137454,-0.210995,0.192676,-0.230709,0.254342,0.005228,-0.220057) * L1_7 + mat4(0.002362,0.019067,0.541087,-0.207450,-0.325754,0.253762,-0.027205,0.128556,-0.130411,0.042984,-0.078494,0.104054,-0.499833,-0.128183,0.099780,-0.233020) * L1_8 + mat4(-0.177816,-0.176559,0.170553,-0.347527,0.290086,-0.026358,-0.109369,-0.025234,-0.171453,0.153097,-0.238794,0.161843,-0.241842,0.324181,-0.130807,0.420746) * L1_9 + mat4(0.001788,0.059996,-0.033130,-0.089583,0.143734,-0.166027,0.302848,-0.285027,-0.088985,0.083524,-0.197831,0.058519,0.061926,0.257309,0.161210,-0.103310) * L1_10 + mat4(0.256508,0.074912,0.151214,0.204710,0.273959,-0.320958,-0.028577,0.105808,-0.142196,0.189976,-0.032951,0.183565,0.149810,-0.117884,-0.149218,-0.026748) * L1_11 + mat4(-0.517610,-0.018071,-0.101054,-0.208210,0.136427,-0.006779,0.391602,-0.266386,0.090168,0.039934,-0.318480,-0.097805,-0.301118,-0.052915,-0.117115,-0.066712) * L1_12 + mat4(-0.261955,0.248822,0.387043,-0.308348,0.347738,-0.113558,0.155317,0.310161,-0.061802,0.329832,0.250288,-0.277594,-0.369034,0.305595,0.280394,-0.525757) * L1_13 + mat4(0.368377,0.325740,-0.018532,0.283228,0.041904,0.308908,-0.138608,-0.210112,-0.080519,0.048094,-0.216831,0.313943,0.160371,-0.097977,-0.052687,0.150718) * L1_14 + mat4(-0.051325,0.179120,-0.108011,-0.054581,0.230517,0.272500,0.378706,-0.306814,-0.225084,-0.025061,0.110842,-0.167220,0.408499,0.029437,0.381499,0.156105) * L1_15 + vec4(0.091570,-0.694385,0.759971,0.188084)));\nvec4 L2_15 = sin((mat4(0.013945,-0.037588,0.172939,-0.124175,-0.212484,-0.001470,0.176651,0.151971,-0.314847,-0.032561,0.179824,0.095979,-0.217575,0.233908,0.186578,0.008070) * L1_0 + mat4(-0.044213,0.134315,-0.251570,0.055626,0.165319,-0.133685,0.007512,-0.006996,0.467773,-0.070129,-0.067439,0.285524,-0.001522,0.032283,-0.244621,-0.205465) * L1_1 + mat4(0.072376,-0.026118,-0.257998,-0.331884,-0.106885,-0.107614,-0.290310,-0.054737,-0.182136,0.293838,0.133789,0.556970,0.427661,-0.190628,-0.211328,0.087762) * L1_2 + mat4(-0.504109,0.125255,-0.230668,-0.207095,-0.355286,0.109200,-0.505839,-0.216069,-0.249316,0.330904,-0.045394,0.035701,0.168538,0.236606,0.259973,0.120742) * L1_3 + mat4(-0.102503,-0.342249,-0.033090,-0.270808,0.229398,-0.235690,-0.288878,-0.068379,-0.116611,-0.174684,0.160652,-0.018163,0.119540,-0.102828,0.126613,-0.375620) * L1_4 + mat4(-0.225348,-0.186876,-0.562697,-0.489732,-0.586373,0.172438,-0.208368,0.096032,-0.060412,0.374722,0.181731,0.183431,0.178730,0.052703,-0.150342,-0.022123) * L1_5 + mat4(0.128591,-0.213480,-0.128576,-0.090734,0.102693,-0.015399,0.017648,-0.542376,0.354298,0.035283,-0.307325,-0.016372,0.121116,0.278193,0.519154,0.252370) * L1_6 + mat4(-0.021081,0.086809,0.023722,-0.079375,-0.126732,0.154587,0.022143,-0.240380,0.446464,0.289333,0.097826,0.031943,0.087796,-0.086787,-0.034395,0.025159) * L1_7 + mat4(-0.006300,0.115117,0.129487,0.152094,-0.202446,0.044323,0.008254,-0.408871,-0.120209,0.124488,0.075856,0.031306,-0.570668,0.530417,0.213292,0.647880) * L1_8 + mat4(-0.042481,-0.043381,0.169464,0.299008,0.191563,0.094019,-0.114705,-0.165086,-0.227318,0.108391,0.219527,-0.054590,0.122025,-0.157344,0.115612,0.151430) * L1_9 + mat4(-0.153108,-0.440842,0.150352,0.277110,0.159024,0.098750,-0.318801,-0.114946,-0.133022,-0.026123,-0.241187,0.045588,0.029317,0.051087,0.200369,-0.167389) * L1_10 + mat4(0.364832,-0.278511,-0.179340,0.134836,-0.020924,0.093503,0.226243,0.294790,-0.013263,-0.083164,-0.464268,0.132052,0.210627,-0.048283,0.274556,-0.332586) * L1_11 + mat4(0.410496,0.111427,-0.263208,-0.052679,0.088044,-0.260455,-0.461303,0.143510,0.037830,0.269143,0.461019,0.174228,0.187747,0.194954,-0.502790,0.645149) * L1_12 + mat4(-0.144395,-0.063199,-0.158434,-0.414974,0.551670,-0.161873,-0.341060,-0.299349,0.000168,-0.284582,-0.280918,0.205439,-0.472565,0.505366,-0.002374,0.223796) * L1_13 + mat4(0.202151,-0.094167,0.398891,0.163770,0.170734,0.043556,0.332421,0.018975,0.383426,-0.100825,-0.342567,0.221825,-0.112413,-0.184824,0.167981,-0.058454) * L1_14 + mat4(-0.347536,-0.104051,0.095683,0.428533,0.004342,0.257286,-0.239567,-0.601737,-0.292474,0.337548,0.174355,0.209714,-0.140458,-0.070376,0.143729,0.425678) * L1_15 + vec4(0.907670,0.054541,0.197693,0.528471)));\nif(BlockIndex == 0)\n{\nvec4 L3_0 = sin((mat4(0.208186,-0.093340,-0.035042,-0.024864,0.070134,0.054724,-0.007995,-0.004282,0.191161,-0.097823,-0.216718,0.204088,-0.164099,0.050077,0.123616,-0.263004) * L2_0 + mat4(0.283700,0.215760,0.142549,0.052861,-0.218573,-0.158782,0.094905,0.128776,-0.132518,0.003114,-0.209900,-0.125898,-0.181770,0.096448,-0.049558,-0.612544) * L2_1 + mat4(0.086744,-0.157963,-0.090781,-0.098244,-0.443197,0.466186,0.377698,-0.159384,-0.291582,-0.204458,-0.190966,-0.040133,-0.063611,0.074569,0.050339,-0.014500) * L2_2 + mat4(-0.061817,0.114347,-0.053924,-0.071899,0.038061,-0.128467,0.268085,0.141626,0.105232,0.034758,-0.017485,-0.132064,0.126079,-0.085126,0.119795,-0.092557) * L2_3 + mat4(-0.048588,0.026090,0.064580,0.038035,-0.151884,-0.009749,-0.042810,-0.182879,0.126098,0.041812,-0.102577,-0.033953,0.046450,-0.308538,0.135196,-0.153088) * L2_4 + mat4(-0.108399,-0.239046,-0.009508,-0.261241,0.109245,-0.196767,0.063388,-0.109914,0.430009,-0.010779,0.076881,-0.196207,0.075535,-0.010259,-0.106008,-0.236361) * L2_5 + mat4(-0.113175,0.055892,-0.044711,-0.129864,0.055668,0.202084,-0.121332,0.186060,-0.023115,0.002982,0.014954,0.235476,-0.056277,-0.130300,0.030578,-0.018842) * L2_6 + mat4(-0.203639,0.420976,-0.207490,0.240769,-0.287800,-0.562954,-0.180472,0.039619,0.216516,0.274566,0.199077,-0.187594,0.143098,0.000683,0.152281,-0.015370) * L2_7 + mat4(-0.248433,0.076449,-0.068106,0.023887,-0.198387,-0.155991,-0.114279,0.015547,0.126236,0.087074,0.120554,0.093370,-0.015308,-0.255576,0.137593,0.044228) * L2_8 + mat4(-0.029408,0.146272,-0.195559,-0.065121,-0.079004,-0.076214,0.028110,0.055303,0.005053,0.011558,0.240379,-0.013832,-0.063099,0.185531,0.260192,-0.366207) * L2_9 + mat4(0.189839,-0.035113,0.072567,0.111343,-0.132986,0.196833,-0.243532,-0.093263,-0.213671,-0.205099,-0.073423,0.041631,-0.105367,0.067173,-0.195280,-0.126393) * L2_10 + mat4(-0.000744,-0.158829,-0.081484,-0.259994,-0.063448,0.310198,0.236438,0.007256,0.007673,0.218933,-0.005543,0.010890,0.066755,-0.425466,-0.003306,-0.203925) * L2_11 + mat4(-0.167105,0.122579,-0.144243,-0.003306,0.093302,-0.271141,-0.377122,-0.244590,0.216627,0.021075,0.238866,-0.169409,-0.011797,0.041488,-0.161199,0.204349) * L2_12 + mat4(0.080557,-0.112894,-0.277821,-0.001812,0.117860,-0.344246,0.037229,-0.097996,0.119863,0.230682,-0.000533,-0.012364,0.221753,-0.139317,0.034640,0.264111) * L2_13 + mat4(-0.049532,0.123050,-0.159710,0.092038,-0.003471,-0.433093,0.242533,0.107497,0.236838,0.216985,-0.034368,-0.235917,-0.068073,-0.229352,0.110425,-0.052435) * L2_14 + mat4(0.047785,0.130763,0.030092,-0.096283,-0.327585,0.102529,-0.102417,0.078627,0.005535,-0.011166,-0.067501,0.235722,-0.163520,-0.023407,-0.195988,0.078977) * L2_15 + vec4(-0.208984,0.329128,-0.127720,0.153183)));\n    return L3_0;\n}\nelse if(BlockIndex == 1)\n{\nvec4 L3_1 = sin((mat4(0.071825,0.012333,-0.099651,0.021390,-0.128473,0.102985,0.102167,-0.019490,-0.063953,0.205425,-0.022910,-0.167356,-0.062431,0.047805,-0.015011,-0.064023) * L2_0 + mat4(-0.301506,-0.064869,-0.115432,-0.322071,0.068674,-0.011395,0.181178,0.460062,0.032672,0.043937,0.327441,-0.086035,0.016659,-0.288084,0.221320,-0.109267) * L2_1 + mat4(-0.386632,-0.193176,-0.150313,0.375617,0.313370,0.154169,0.125274,-0.029478,0.028172,-0.070901,-0.100543,-0.000785,-0.106016,-0.055131,0.048347,-0.070646) * L2_2 + mat4(0.447958,0.077021,0.080614,0.145807,-0.064808,0.081719,-0.208135,0.253862,0.086400,0.079522,-0.004573,0.366743,0.117743,-0.166978,0.167483,0.307285) * L2_3 + mat4(0.055791,0.206844,0.032023,0.136281,-0.137428,0.401990,0.041692,0.017414,-0.035521,0.047070,-0.047683,-0.191713,0.180704,0.024971,0.273182,0.109435) * L2_4 + mat4(0.042973,0.204006,0.040270,0.088643,0.113606,0.215705,0.139214,0.018039,-0.129421,-0.208404,0.053690,0.272189,-0.497877,-0.355054,0.107096,-0.001002) * L2_5 + mat4(-0.089385,-0.413568,-0.158084,0.065216,0.090703,0.069984,0.050278,0.022357,0.347031,0.119709,0.193306,0.102682,-0.154351,0.301864,0.022427,-0.013945) * L2_6 + mat4(0.312020,-0.032159,0.190165,0.326861,0.314047,0.244874,-0.162914,0.297489,-0.266006,-0.291571,-0.631476,-0.266970,0.168991,-0.151763,-0.300687,0.005864) * L2_7 + mat4(-0.101505,0.158791,-0.174498,0.037348,0.179571,-0.062785,0.031347,-0.286809,-0.192877,0.197758,0.174644,-0.034316,-0.065919,0.131329,-0.110143,-0.299925) * L2_8 + mat4(0.047521,0.049068,-0.079543,0.355010,0.213545,-0.288582,0.126821,0.025870,0.128217,-0.003083,0.184346,-0.031364,-0.128161,-0.118798,0.103572,-0.096192) * L2_9 + mat4(-0.300683,0.177410,0.091756,0.098030,0.148306,-0.036029,-0.228551,0.241088,-0.058192,-0.039021,0.284680,-0.004545,0.252347,-0.105920,0.007140,-0.054838) * L2_10 + mat4(-0.519384,-0.146727,-0.375637,-0.236415,-0.316492,0.194322,0.083176,0.382557,0.081721,-0.006117,-0.157863,-0.027378,0.061740,-0.300000,-0.242124,-0.179674) * L2_11 + mat4(-0.406964,-0.101153,0.026307,0.249495,0.241798,0.099671,0.076273,0.097903,0.325426,0.052895,-0.012171,0.025691,0.162078,0.245235,0.358665,0.314555) * L2_12 + mat4(0.007689,-0.093402,0.091315,0.046423,0.203452,0.153046,0.280472,0.114369,0.051704,0.132544,-0.010033,0.113258,0.018901,-0.040777,-0.039026,0.107550) * L2_13 + mat4(-0.148678,-0.108186,0.124593,0.021641,-0.071329,-0.118859,0.082961,-0.002133,-0.054315,0.157170,0.117199,0.004761,-0.094915,-0.241700,-0.106742,-0.113169) * L2_14 + mat4(0.224975,0.227829,-0.010433,0.196603,0.082132,-0.300896,-0.141607,0.281654,-0.039642,0.124537,-0.181964,-0.045486,0.214878,0.125775,-0.313342,-0.070887) * L2_15 + vec4(-0.534099,-0.402043,-0.349792,0.451931)));\n    return L3_1;\n}\nelse if(BlockIndex == 2)\n{\nvec4 L3_2 = sin((mat4(0.093877,0.091926,0.169172,-0.054637,0.146010,0.003199,0.204714,-0.011641,0.040825,0.245436,0.079164,0.127557,-0.258298,0.170271,-0.026875,-0.230479) * L2_0 + mat4(-0.206465,-0.030862,-0.045786,-0.176476,-0.152090,0.032583,0.191094,0.025635,0.056955,-0.117672,-0.018259,0.034714,0.087320,0.147578,0.095968,-0.183831) * L2_1 + mat4(-0.055255,-0.125070,-0.106863,-0.392101,-0.209277,-0.033519,0.162075,-0.159073,-0.028674,-0.160603,-0.156223,0.142976,-0.108297,-0.019754,-0.048884,0.039730) * L2_2 + mat4(-0.293102,0.045874,-0.230183,-0.271827,0.193640,0.092374,0.006578,0.135302,0.460088,0.035361,-0.033387,-0.036127,-0.007648,0.034223,0.000227,-0.172593) * L2_3 + mat4(-0.082856,-0.358802,0.174016,-0.009654,0.168977,0.114970,-0.037417,0.079610,-0.207704,0.018305,0.033551,0.023098,-0.109233,0.361880,0.031150,0.079293) * L2_4 + mat4(0.038390,-0.161189,0.291113,0.171465,0.017136,0.019708,-0.252947,0.036437,0.104102,0.126405,0.070059,-0.139209,0.037099,0.143351,-0.379391,-0.033100) * L2_5 + mat4(0.208407,0.038886,-0.133697,-0.041335,0.144734,0.040700,0.152047,-0.001880,0.152499,-0.103859,-0.446887,0.063038,0.149635,-0.153795,-0.000351,-0.009486) * L2_6 + mat4(-0.174855,-0.236458,0.030948,-0.061452,0.332152,0.087649,0.169075,0.032091,-0.029313,-0.120991,-0.400379,-0.052798,-0.089368,-0.010501,-0.230050,0.202845) * L2_7 + mat4(-0.056077,0.209845,0.189314,-0.066067,-0.108863,0.022885,0.095125,-0.089030,-0.048998,-0.234211,0.047018,0.033956,-0.130631,0.102324,0.125444,0.182270) * L2_8 + mat4(0.068309,0.179160,0.114447,-0.049387,-0.292987,-0.201678,0.138986,0.177332,0.060073,0.034820,-0.039409,-0.125430,0.153557,-0.210877,0.103612,0.116307) * L2_9 + mat4(0.143157,0.019190,-0.034715,0.066185,0.045382,0.248271,0.084793,-0.128959,0.143459,0.003596,0.105357,-0.249098,0.050924,0.204481,-0.243264,-0.095474) * L2_10 + mat4(-0.017304,-0.122751,-0.096569,0.199436,-0.062435,0.252985,0.128294,0.182350,0.051878,0.128734,-0.017962,-0.010533,0.056691,-0.006830,-0.144802,0.005479) * L2_11 + mat4(0.062282,-0.074748,-0.402822,-0.008141,-0.207946,-0.119813,0.211058,0.042892,0.219521,0.106073,0.185215,-0.100695,-0.121477,-0.093287,-0.203803,-0.288464) * L2_12 + mat4(-0.218829,-0.078643,0.026625,0.200787,-0.189559,-0.004969,-0.169106,0.125598,-0.183595,0.066876,-0.139967,-0.082745,-0.007472,0.229582,-0.070922,0.091444) * L2_13 + mat4(0.098946,-0.204469,-0.042221,-0.093244,0.094233,-0.391063,-0.029312,-0.160969,0.181932,-0.047717,-0.140350,-0.028345,-0.082952,0.179532,0.181436,-0.251242) * L2_14 + mat4(-0.027478,0.002094,-0.217603,-0.058802,0.073405,-0.308345,-0.239378,0.183078,0.058458,0.095214,-0.114877,0.207782,-0.253905,0.103548,0.212482,0.061262) * L2_15 + vec4(0.569106,-0.275418,-0.181169,-0.002569)));\n    return L3_2;\n}\nelse if(BlockIndex == 3)\n{\nvec4 L3_3 = sin((mat4(-0.139804,-0.216212,-0.154788,0.084155,-0.153753,0.063013,-0.166395,-0.167149,0.230512,0.130981,0.080924,0.034000,0.016075,-0.072099,-0.171724,0.135418) * L2_0 + mat4(-0.320190,-0.003469,-0.249308,-0.154224,-0.068145,0.121116,0.021715,0.047177,-0.131616,0.083334,0.216935,0.070835,0.041504,0.160819,-0.077447,-0.118017) * L2_1 + mat4(-0.018836,-0.088997,-0.163120,-0.152546,-0.025302,0.243715,0.033935,0.211549,0.222098,0.153276,-0.036936,0.172570,0.346876,0.202560,-0.352693,-0.044430) * L2_2 + mat4(-0.036277,-0.380812,-0.103364,-0.148194,0.025002,0.237687,-0.075561,-0.050179,0.019396,0.051292,-0.055548,0.098214,0.139301,-0.149028,0.219882,0.026945) * L2_3 + mat4(-0.120317,-0.003893,0.150328,0.004635,0.259167,0.098427,0.253815,0.050330,-0.037520,-0.280935,-0.032806,0.004423,0.122618,-0.136678,-0.015906,0.041411) * L2_4 + mat4(-0.237355,-0.190303,-0.075092,-0.064248,-0.092845,0.131275,0.153092,-0.034307,-0.206323,0.141331,-0.108422,0.019270,-0.019906,0.102179,0.072384,0.044753) * L2_5 + mat4(-0.179238,0.006529,0.219800,0.020791,-0.040375,0.049746,-0.035121,-0.244300,-0.143804,0.305103,0.216559,0.068120,0.163330,0.142161,0.002209,0.017625) * L2_6 + mat4(0.013750,0.294513,0.160424,0.119519,0.316074,-0.135423,-0.084964,-0.182344,-0.156257,-0.451351,0.081471,-0.068340,-0.027114,0.172716,0.308386,0.044979) * L2_7 + mat4(-0.026970,-0.071276,-0.050368,-0.091249,0.006384,0.142925,0.262338,0.226423,-0.031643,0.084902,0.133138,-0.225661,0.051352,0.138627,0.228307,0.183232) * L2_8 + mat4(0.135908,-0.044907,0.074471,0.029918,-0.044614,0.057384,0.185559,-0.079886,0.011528,-0.209347,0.230496,-0.141646,-0.224433,-0.055585,-0.349675,0.126990) * L2_9 + mat4(0.213062,0.052408,-0.257612,0.002371,0.136744,0.054831,0.125258,0.080804,-0.066331,-0.004964,0.125798,0.057274,0.026197,0.007539,-0.115111,-0.206600) * L2_10 + mat4(-0.068913,-0.204384,-0.055238,-0.362567,-0.190622,-0.017273,-0.320778,0.177373,0.128447,-0.130360,0.133447,0.118950,0.087550,-0.361842,0.143746,0.110824) * L2_11 + mat4(0.048565,-0.006442,0.108152,0.135105,-0.393902,0.090016,-0.036921,0.144651,0.002051,-0.039510,-0.003655,0.095851,-0.050573,-0.026940,-0.020649,0.037880) * L2_12 + mat4(0.053922,0.135215,0.132673,-0.086075,-0.318751,0.245931,0.356336,0.024726,-0.192663,0.567593,0.418604,-0.051657,-0.118298,-0.060706,-0.135067,-0.016457) * L2_13 + mat4(0.012932,0.147114,-0.127000,0.059912,0.107521,0.062857,0.117011,-0.132989,0.025379,0.059580,0.104236,0.041751,0.103038,0.004856,0.239243,0.037222) * L2_14 + mat4(0.113561,0.016878,0.060134,-0.156130,-0.033559,-0.116786,-0.009894,0.214643,0.264783,-0.255683,0.040039,-0.026305,-0.043118,0.145961,-0.048488,0.091848) * L2_15 + vec4(0.324755,-0.506015,0.148104,-0.171770)));\n    return L3_3;\n}\nelse if(BlockIndex == 4)\n{\nvec4 L3_4 = sin((mat4(0.007329,-0.097163,0.004440,-0.181073,-0.031064,-0.010230,-0.288809,-0.114571,-0.232924,-0.485134,0.180844,-0.059204,-0.013561,-0.103433,0.137933,-0.163198) * L2_0 + mat4(0.200911,-0.015740,-0.071367,0.119833,0.051326,0.262915,0.018132,-0.024023,0.076360,-0.044422,-0.076802,-0.004179,-0.128883,0.113664,-0.073614,0.037484) * L2_1 + mat4(0.371038,-0.169570,-0.075783,0.002111,-0.417147,-0.043319,0.355952,0.052224,-0.015230,0.052123,0.207221,-0.227155,0.061967,-0.029670,-0.059366,0.132698) * L2_2 + mat4(0.015255,0.153122,-0.325672,-0.031559,0.061757,0.070980,0.128729,-0.343298,0.254706,0.018187,-0.109620,-0.013261,0.086252,0.068400,0.328856,-0.093993) * L2_3 + mat4(0.035181,0.240273,0.062071,0.072063,-0.020096,-0.116712,0.017062,0.166688,-0.025303,-0.065882,-0.086901,-0.113816,-0.011567,-0.114053,0.194137,0.017666) * L2_4 + mat4(0.178602,-0.196250,0.101565,0.321040,-0.159216,-0.163302,0.009382,0.078501,0.088109,0.294015,0.241164,0.125451,-0.147184,0.097154,0.145620,0.084421) * L2_5 + mat4(-0.012488,-0.086836,0.001818,0.020751,-0.093920,0.424396,-0.212714,-0.186068,-0.093089,-0.008355,-0.081931,0.309669,-0.183058,0.111051,0.191452,0.119013) * L2_6 + mat4(0.291047,0.015211,0.237217,-0.158986,-0.061800,0.159603,0.081302,0.020919,-0.136907,-0.000482,-0.111995,-0.217464,0.000792,0.160348,0.037143,0.023987) * L2_7 + mat4(0.128184,0.120779,0.024303,0.069810,-0.016636,0.012454,-0.208316,0.034751,0.161869,-0.268762,-0.158913,-0.105521,-0.015774,-0.059464,0.122383,0.043433) * L2_8 + mat4(-0.157869,0.147589,0.078432,0.185564,0.163463,-0.086850,-0.042305,-0.346724,0.073068,-0.290473,0.043710,0.213508,0.248811,0.113433,-0.219665,-0.203048) * L2_9 + mat4(-0.080349,-0.132277,-0.119586,-0.045872,0.120055,-0.059612,-0.012333,0.140852,-0.184053,0.160312,0.009848,-0.072964,0.205972,-0.211766,-0.137757,-0.122839) * L2_10 + mat4(-0.085108,0.365452,-0.071077,0.131487,-0.028466,0.020622,-0.230900,-0.311013,0.129224,0.035691,-0.045954,-0.007353,0.157623,-0.217046,-0.009554,0.103660) * L2_11 + mat4(0.024642,0.050339,-0.238955,0.068703,-0.095179,-0.122464,-0.057430,-0.132716,0.148592,-0.071685,0.047141,-0.039285,-0.277181,0.116041,-0.129901,0.108473) * L2_12 + mat4(-0.095033,-0.094612,0.035080,0.038744,-0.116324,-0.078268,0.413455,-0.026974,0.063884,-0.006569,-0.095508,-0.197808,0.068468,0.013028,-0.003233,0.114799) * L2_13 + mat4(0.192155,-0.132934,-0.113892,-0.070284,-0.132091,-0.040958,0.198664,-0.096870,0.184766,-0.179485,0.196784,0.010466,-0.077743,-0.104330,-0.182172,0.057171) * L2_14 + mat4(-0.113657,-0.130328,0.096004,-0.057957,-0.152119,-0.163589,0.175502,0.040160,-0.057764,0.401490,0.044890,0.181402,0.135048,0.079082,-0.009198,0.143927) * L2_15 + vec4(0.343298,0.374396,-0.204895,0.005217)));\n    return L3_4;\n}\nelse if(BlockIndex == 5)\n{\nvec4 L3_5 = sin((mat4(-0.196756,0.099772,-0.121354,-0.030159,-0.260757,-0.356733,-0.053284,-0.017192,-0.025250,-0.015674,-0.394154,-0.297519,0.178830,-0.100427,0.093745,0.019735) * L2_0 + mat4(-0.249535,-0.106720,0.071817,-0.119827,0.063273,0.324521,0.226252,0.152072,0.050951,-0.067530,-0.052293,0.023926,0.309546,0.028740,-0.108145,-0.289435) * L2_1 + mat4(0.297889,-0.093155,-0.393970,-0.509839,0.128782,0.193767,0.258224,-0.008037,-0.035238,-0.067830,0.251804,-0.229943,-0.079104,0.110068,-0.227113,0.097678) * L2_2 + mat4(0.064474,0.154442,0.301767,0.129403,0.086363,-0.051684,0.185353,-0.217510,-0.072568,-0.391379,0.014044,0.196950,-0.006752,-0.026924,0.207228,0.020244) * L2_3 + mat4(0.000715,-0.154634,0.038837,0.028033,0.120000,-0.079924,0.059765,0.120724,0.044782,-0.216164,-0.334158,0.186889,-0.460023,-0.323240,-0.027709,-0.009130) * L2_4 + mat4(-0.177938,-0.114589,0.164304,0.140230,-0.011287,0.125817,0.134276,0.084186,-0.061687,0.064707,-0.198106,-0.030211,-0.080044,0.033059,-0.031647,0.016977) * L2_5 + mat4(0.177756,0.083044,0.027497,-0.091087,-0.115562,0.108544,0.086032,0.080067,-0.035395,0.115819,-0.124650,-0.166277,0.096544,-0.100150,0.154511,-0.169168) * L2_6 + mat4(0.178052,0.020556,0.091542,0.214143,0.078139,-0.204102,-0.136894,-0.015071,-0.132991,-0.136745,0.077256,-0.022243,0.042240,-0.027068,0.023373,0.183183) * L2_7 + mat4(0.078894,0.043984,0.276273,-0.025143,0.006442,0.018855,-0.004481,-0.026438,-0.233238,0.162199,-0.374015,-0.136606,0.099068,0.126820,0.289458,-0.066744) * L2_8 + mat4(-0.051356,0.191046,-0.343705,0.071290,0.087710,-0.125523,0.381658,0.067425,0.136928,0.039034,0.130035,0.112732,-0.063530,0.063313,0.105852,-0.144247) * L2_9 + mat4(-0.051026,-0.000984,-0.177332,0.142766,0.011165,0.136625,0.057085,-0.240141,-0.001315,0.176930,0.070211,-0.016126,-0.113675,0.128502,-0.286555,0.031516) * L2_10 + mat4(-0.010618,0.115969,0.141565,-0.202772,0.087683,-0.111185,-0.032436,0.111472,-0.021027,0.042054,-0.181381,-0.127608,0.029360,0.084638,-0.338415,-0.049186) * L2_11 + mat4(0.178780,0.126468,0.104153,-0.093882,-0.036661,-0.117328,-0.062494,0.032944,0.140927,0.080718,0.341396,-0.136816,0.075468,-0.272071,0.039262,-0.125294) * L2_12 + mat4(0.363931,0.037831,-0.046567,-0.128676,-0.220295,-0.043811,0.218839,-0.084406,-0.201381,0.295046,0.064681,-0.292069,0.004177,0.128301,0.058848,0.011409) * L2_13 + mat4(-0.085815,0.083521,0.062801,-0.117969,0.110510,0.213351,0.094908,-0.002403,-0.100066,0.062538,0.062725,0.092933,-0.038209,0.004112,-0.158853,0.000163) * L2_14 + mat4(-0.101438,0.113245,-0.119096,0.248553,-0.300144,0.094284,-0.113001,-0.104703,-0.184616,0.061872,-0.247585,-0.196945,-0.213953,-0.011911,0.031493,-0.020270) * L2_15 + vec4(-0.101304,0.274061,-0.084703,-0.161950)));\n    return L3_5;\n}\nelse if(BlockIndex == 6)\n{\nvec4 L3_6 = sin((mat4(-0.135774,-0.119451,0.086384,-0.029564,0.198589,0.111393,0.182761,-0.015770,-0.037966,0.075732,0.198230,0.006111,0.307551,-0.131689,-0.159588,-0.064317) * L2_0 + mat4(-0.013148,0.056639,-0.129722,0.458303,0.088492,0.362251,-0.211294,-0.143281,-0.032499,-0.200126,0.097084,-0.113519,-0.059620,0.198746,0.004882,-0.032105) * L2_1 + mat4(-0.166387,0.059564,0.102087,0.050646,0.067731,0.275550,0.160250,-0.390908,0.171814,-0.106161,-0.046878,-0.040707,0.092378,0.075042,-0.054260,-0.030137) * L2_2 + mat4(0.011842,-0.213216,0.164117,0.067942,0.144000,0.157247,-0.174566,0.061446,0.071356,-0.080471,0.456228,-0.162633,-0.185307,0.119071,0.185309,0.212702) * L2_3 + mat4(0.056977,0.336161,0.044214,0.083095,0.115576,-0.145765,-0.271179,-0.112677,0.335469,0.200867,-0.146283,-0.024551,0.157416,0.146185,-0.119450,-0.367404) * L2_4 + mat4(0.280166,-0.120483,-0.012605,0.001667,-0.059770,0.051495,-0.118263,-0.097766,-0.376707,0.039869,-0.018098,0.201351,-0.189186,-0.430755,0.058404,-0.172894) * L2_5 + mat4(0.144936,0.292510,0.308688,-0.176671,-0.248456,-0.044275,-0.114862,0.474861,-0.202055,-0.178991,0.006779,0.334531,0.096393,-0.328001,-0.160509,0.086178) * L2_6 + mat4(-0.122048,-0.041063,-0.229740,-0.491314,-0.020335,0.158050,-0.032219,0.016808,-0.029184,-0.122719,0.253805,0.175033,0.003822,0.044139,0.106222,-0.040829) * L2_7 + mat4(0.014872,0.098493,-0.087258,-0.019315,0.054233,0.467056,-0.119709,-0.018134,0.007253,-0.457230,0.253721,-0.088213,0.035226,0.084861,-0.071137,0.083965) * L2_8 + mat4(0.229580,0.316151,0.196348,0.146923,-0.204167,0.308332,0.098625,0.129147,-0.013474,-0.204824,-0.058928,-0.018478,0.136580,-0.054298,-0.294231,-0.219438) * L2_9 + mat4(-0.046030,-0.063689,0.131136,0.040583,0.102532,-0.566173,-0.010320,-0.226786,0.066633,-0.296012,-0.266065,0.273541,-0.116339,-0.035263,-0.361001,-0.175518) * L2_10 + mat4(-0.086278,-0.007484,0.127030,0.199326,-0.259743,0.181557,-0.149764,-0.001746,-0.104412,-0.257988,0.077335,-0.005483,-0.149676,-0.189112,0.022958,0.024479) * L2_11 + mat4(0.083027,-0.149590,0.076478,-0.042436,0.105228,-0.138647,0.057873,0.193910,0.051583,0.137753,0.076840,-0.047908,-0.268264,0.108018,0.057443,-0.093357) * L2_12 + mat4(-0.038523,-0.071143,0.142845,-0.094820,-0.056420,0.392166,-0.123422,0.048552,-0.128642,-0.605662,-0.112999,0.073274,0.014786,0.185012,0.140942,-0.022678) * L2_13 + mat4(0.000313,0.089373,0.247029,0.118129,0.021773,-0.272958,-0.144245,0.084895,-0.210210,0.027288,-0.187983,0.163993,-0.061260,-0.035979,0.122559,0.087031) * L2_14 + mat4(0.052055,-0.255171,-0.089697,-0.174656,0.043742,0.303310,0.183014,0.190303,0.161442,0.522259,-0.009770,-0.120123,-0.228330,-0.287086,0.212181,0.020314) * L2_15 + vec4(-0.306837,1.221379,0.525131,-0.303931)));\n    return L3_6;\n}\nelse\n{\nvec4 L3_7 = sin((mat4(-0.016501,0.051261,0.060908,0.013292,0.085128,0.298267,-0.148945,0.141288,-0.046030,-0.177776,0.206404,-0.115457,0.230070,0.100032,0.042138,-0.047113) * L2_0 + mat4(0.029479,-0.328907,-0.096919,0.175155,0.095538,-0.122242,0.070966,0.243415,-0.098931,0.017417,-0.073173,0.097323,0.088062,-0.364642,0.043213,0.063007) * L2_1 + mat4(0.006069,-0.283652,-0.047404,0.002484,0.035109,0.302602,-0.356909,0.210263,0.062591,0.199215,0.030865,0.191767,0.097086,0.073098,0.104248,-0.215332) * L2_2 + mat4(0.032978,0.137582,0.001606,-0.009655,0.080158,0.038109,0.111122,-0.050287,0.017320,-0.097548,-0.315356,-0.003839,-0.096581,-0.246979,0.059847,0.200609) * L2_3 + mat4(0.018180,0.306402,0.165533,0.075642,-0.049926,-0.088486,-0.035612,0.033033,-0.181797,-0.012642,0.225681,0.141319,-0.117391,-0.259124,0.022701,-0.023472) * L2_4 + mat4(-0.081538,0.139298,-0.191634,-0.200236,-0.027552,-0.251621,0.123363,-0.093059,0.036073,0.321610,-0.020561,-0.062422,0.303115,-0.550867,0.351394,0.313416) * L2_5 + mat4(-0.116049,0.025490,0.164132,-0.173703,0.115699,0.074549,-0.240268,-0.027937,0.177120,0.213394,-0.111859,0.166723,-0.232197,0.339860,-0.129789,0.143121) * L2_6 + mat4(0.241968,-0.186731,-0.014303,-0.064519,-0.274131,0.241194,0.156297,-0.212777,-0.321427,-0.511864,0.214146,-0.027115,-0.046021,0.068931,-0.027493,0.056596) * L2_7 + mat4(0.129873,0.085587,-0.060611,0.029654,0.029976,0.221523,0.075340,-0.189198,-0.142435,0.023815,0.209501,-0.043509,0.112373,-0.148418,0.210870,0.018628) * L2_8 + mat4(0.238988,0.111439,0.028668,-0.169126,0.141929,0.050083,-0.166237,-0.268449,-0.025813,0.107356,0.159951,0.094102,0.222960,0.030809,0.040872,0.002404) * L2_9 + mat4(-0.099831,-0.108412,-0.065420,-0.064669,-0.096494,-0.043832,0.063888,-0.018530,-0.089733,-0.143148,-0.100731,0.099548,0.049647,-0.031775,-0.003703,0.087785) * L2_10 + mat4(-0.260010,0.466166,-0.374143,-0.200514,-0.286095,0.127049,-0.080010,-0.093462,0.040699,0.004501,-0.053754,0.149936,-0.082569,0.078959,-0.274519,-0.084204) * L2_11 + mat4(-0.032509,0.021425,-0.105678,-0.104854,-0.004983,-0.129218,0.129688,0.177446,0.014187,-0.171684,-0.181769,-0.103089,0.168489,0.083225,-0.087339,0.077146) * L2_12 + mat4(-0.025264,-0.181479,-0.113729,0.150187,0.211835,0.461516,-0.195638,-0.172235,-0.126347,-0.302755,-0.107999,-0.053761,-0.160485,-0.087751,-0.082598,-0.021325) * L2_13 + mat4(-0.003126,-0.048788,-0.241461,0.125587,0.057319,0.262459,0.031640,0.222781,-0.039011,-0.045528,-0.026854,-0.165731,0.100473,0.000988,0.019006,-0.018228) * L2_14 + mat4(-0.119000,0.006597,-0.140217,-0.089943,-0.118058,0.118339,0.182392,0.061244,0.083752,-0.149113,-0.033120,0.071885,-0.172609,-0.060926,0.209207,0.140148) * L2_15 + vec4(0.468767,-0.510674,-0.331171,0.062408)));\n    return L3_7;\n}\n}\n\n#pragma optimize(on)\n\n#pragma optimize(off)\nvec4 Lightmap_Half_HPG(const vec3 uv_0, const vec3 uv_1, const int BlockIndex)\n{\nvec4 L0_0 = sin(20.000000 * (mat3x4(-0.135437,0.175335,-0.037203,0.393368,0.075809,0.156102,-0.882747,0.620394,0.077964,-0.091778,0.189230,0.119891) * uv_0 + mat3x4(0.095590,0.038956,0.018343,-0.043401,0.257205,-0.090515,-0.192575,0.195200,0.190756,0.251773,-0.724223,0.017533) * uv_1 + vec4(0.066143,-0.055214,-0.303167,0.262886)));\nvec4 L0_1 = sin(20.000000 * (mat3x4(0.350488,-0.359452,-0.287682,-0.459463,0.373711,-0.621243,0.256753,-0.315499,0.183359,-0.244316,-0.248316,-0.055140) * uv_0 + mat3x4(0.091928,0.097185,0.211824,0.199961,-0.014879,-0.037405,0.095865,-0.064793,0.326197,-0.113874,0.002512,-0.072609) * uv_1 + vec4(-0.022023,-0.286229,-0.038530,0.058641)));\nvec4 L0_2 = sin(20.000000 * (mat3x4(0.034157,0.053843,0.005591,0.329028,0.460839,0.416268,0.013206,0.162244,-0.181814,0.181380,-0.008145,0.486769) * uv_0 + mat3x4(0.063481,0.070110,0.088452,0.019104,0.066690,-0.015126,-0.095975,-0.158485,0.242089,-0.062418,-0.069063,-0.135708) * uv_1 + vec4(0.170477,0.209796,0.190352,0.256814)));\nvec4 L0_3 = sin(20.000000 * (mat3x4(0.017010,-0.123458,0.023429,-0.110280,-0.795084,-0.359094,-0.547488,-0.011487,0.533564,-0.046659,-0.087290,0.079145) * uv_0 + mat3x4(-0.190277,-0.067300,-0.267150,0.095151,-0.017624,0.132024,0.129375,-0.104242,-0.368069,-0.086474,-0.101677,-0.096816) * uv_1 + vec4(-0.284228,-0.003680,-0.183995,-0.070034)));\nvec4 L0_4 = sin(20.000000 * (mat3x4(-0.161422,-0.006673,0.266700,0.052865,0.409540,0.826395,0.201487,-0.203415,-0.591681,-0.230301,-0.197811,0.114327) * uv_0 + mat3x4(0.015638,0.207665,0.036902,-0.028895,-0.004092,0.163977,-0.042301,-0.134758,0.075671,0.419332,0.218819,-0.361746) * uv_1 + vec4(0.326089,0.326305,-0.128531,-0.011421)));\nvec4 L0_5 = sin(20.000000 * (mat3x4(-0.387549,-0.296831,0.429326,-0.102954,-0.499542,-0.067479,0.066221,0.749767,0.023750,-0.174282,-0.018143,-0.032650) * uv_0 + mat3x4(0.105251,-0.062738,-0.152061,0.063919,-0.136342,0.263734,-0.011737,0.192286,-0.175620,0.076963,0.100677,0.190018) * uv_1 + vec4(-0.229323,0.036357,-0.022156,0.238503)));\nvec4 L0_6 = sin(20.000000 * (mat3x4(0.252264,0.175200,0.055197,-0.165891,0.116723,-0.365256,-0.678344,-0.024617,0.549099,0.394746,0.135978,-0.420545) * uv_0 + mat3x4(-0.090120,-0.116031,-0.041765,0.048519,0.001458,0.105260,-0.064533,0.143000,-0.013608,-0.062355,-0.052052,0.143538) * uv_1 + vec4(-0.046046,-0.184384,-0.383875,-0.107337)));\nvec4 L0_7 = sin(20.000000 * (mat3x4(0.183708,0.209966,-0.001894,0.437314,-0.273028,-0.480794,-0.001564,0.230693,0.842470,-0.080731,0.004321,-0.150022) * uv_0 + mat3x4(-0.083025,0.049781,-0.001037,-0.137080,-0.179412,-0.234548,-0.164990,-0.115371,-0.148888,-0.178880,-0.004395,0.088028) * uv_1 + vec4(0.082729,-0.145967,0.237020,0.059807)));\nvec4 L1_0 = sin((mat4(-0.693141,0.198091,-0.252359,-0.001794,-0.270113,0.021719,-0.112029,0.128367,0.027852,-0.374848,0.386460,-1.155436,0.030905,1.004440,-0.075232,1.318025) * L0_0 + mat4(0.392756,-0.318331,0.135392,-0.167773,-0.535783,-0.900310,0.236000,-0.594835,-0.117446,-0.756461,-0.353998,0.186839,-0.056282,-0.776871,-0.794301,0.961523) * L0_1 + mat4(0.558550,0.895311,-0.082950,-0.361868,0.438233,0.470161,-0.263797,0.093319,0.583373,0.374591,-0.210658,0.589651,0.773827,0.256110,0.115726,0.530570) * L0_2 + mat4(0.078204,0.328201,-0.082222,1.051334,0.103238,-0.060958,-0.353448,-0.157455,-0.139631,-0.040661,0.278678,0.390700,1.016721,0.044355,0.253101,0.201402) * L0_3 + mat4(0.297791,-0.139312,-0.036523,0.006180,-0.126484,-1.360991,0.326614,-2.544309,0.485664,-0.305900,0.180351,0.399254,0.517996,0.202295,-0.175309,0.099917) * L0_4 + mat4(-0.488311,-0.180566,-0.096346,0.012026,0.627391,-0.070099,0.176754,0.679811,-1.327541,-0.957728,-0.272023,-0.395953,0.329116,0.022031,0.109571,-0.572802) * L0_5 + mat4(0.898086,0.065272,0.324279,-0.175650,-0.489682,0.197487,0.009461,-0.247464,0.453557,-0.081673,0.267141,-0.579832,0.411279,0.224291,0.289736,0.008095) * L0_6 + mat4(0.012166,0.045058,-0.088206,-0.177255,-0.840475,-0.860723,-0.156567,0.852001,-0.376434,-0.712906,0.178347,0.161750,1.444664,0.700166,1.093910,0.059272) * L0_7 + vec4(-0.192089,-1.027344,-0.009283,0.309698)));\nvec4 L1_1 = sin((mat4(-0.332106,0.009508,-0.180150,-0.030107,0.563696,-0.557009,0.065605,-0.328698,1.043159,-1.495147,-1.078832,-0.445424,-0.855020,0.205252,1.373763,0.456515) * L0_0 + mat4(0.725135,-0.430944,0.122019,-0.112982,0.611843,-0.463062,-0.446602,-1.034939,-0.752939,0.294421,0.400781,0.294426,0.395014,0.529671,0.920368,0.809704) * L0_1 + mat4(-0.188472,0.465256,-0.641460,-0.130408,-0.178522,-0.021867,-0.169117,0.396366,-0.051785,-0.112960,0.405599,-0.177140,0.309165,0.234958,0.359152,-0.251932) * L0_2 + mat4(-0.208961,0.206236,1.150642,0.119207,0.357816,-0.345604,0.140062,-0.122324,-0.172271,0.006682,0.582442,0.354848,0.078955,-0.510548,-0.134209,-0.192431) * L0_3 + mat4(0.010882,0.158839,-0.140755,-0.136574,1.228806,-1.278061,-2.712656,-0.334609,0.785006,-0.511575,0.435898,-0.064508,0.416384,-0.355182,-0.012944,-0.320789) * L0_4 + mat4(-0.746547,-0.107693,-0.057811,0.190059,0.336658,1.267903,0.361505,0.508593,0.235089,-0.748742,-0.160905,0.436442,0.155452,-0.876510,-0.430115,-0.239226) * L0_5 + mat4(-0.404909,0.014046,-0.104382,0.516950,-0.599860,-0.107278,0.267648,-0.084153,0.271921,-0.305370,-0.665559,-0.227115,0.266762,0.122334,-0.015551,0.026508) * L0_6 + mat4(0.347835,0.104066,-0.289811,0.283044,-0.145526,-0.127505,1.007628,-0.188236,-0.089127,-0.197415,0.479588,-0.277759,0.217948,0.604004,-0.092399,-0.560153) * L0_7 + vec4(0.635611,0.242034,0.921342,-0.128157)));\nvec4 L1_2 = sin((mat4(0.084243,0.214540,-0.155990,0.055656,0.225301,0.089245,-0.229751,-0.036953,-0.184119,-0.118921,0.768978,-1.167031,0.480916,0.017273,-0.814921,1.923899) * L0_0 + mat4(0.300395,-0.253083,0.301247,0.654751,-0.168470,-0.044366,0.425302,-0.740967,-0.136307,0.156329,0.225131,-0.439030,0.670174,-0.104910,-0.732530,0.519178) * L0_1 + mat4(0.342080,0.066444,-0.305098,0.477824,-0.158685,-0.071495,0.106886,0.232084,0.587225,0.146504,-0.362784,-0.515684,0.031740,0.252965,-0.094752,0.139957) * L0_2 + mat4(-0.542008,-0.177901,-0.135948,0.506766,0.227751,0.052058,-0.126756,-0.034657,-0.015911,-0.004213,-0.026686,0.144063,0.113234,0.272449,-0.551082,0.459309) * L0_3 + mat4(0.068646,-0.055024,-0.063289,-0.054629,0.647108,0.077469,0.702414,-1.652617,0.406887,0.266246,-0.325613,0.428701,0.211365,0.058035,-0.290318,-0.030766) * L0_4 + mat4(-0.750901,0.124434,-0.174067,-0.597288,0.225354,0.091622,0.011821,-0.289813,0.467806,0.501027,-0.674133,-0.038258,0.157877,-0.308932,0.124058,-0.186918) * L0_5 + mat4(-0.322844,0.735700,0.296641,0.157647,-0.400402,-0.134564,0.062120,0.075052,0.327081,-0.117369,-0.000918,-0.244312,0.012874,0.127884,-0.066956,0.091688) * L0_6 + mat4(0.117447,-0.116534,-0.091286,0.145190,-0.641477,-0.179636,0.320515,-0.911524,0.057303,-0.995227,-0.727779,-0.829536,-0.593003,0.124216,0.732103,-0.243690) * L0_7 + vec4(0.120636,-0.457481,-0.187006,-0.072452)));\nvec4 L1_3 = sin((mat4(-0.396362,0.693238,-0.191740,-0.224501,-0.093402,0.310025,0.410490,-0.037208,-0.595456,0.368652,0.790187,-0.120339,0.795418,-0.797415,-1.458435,-0.053252) * L0_0 + mat4(0.354030,-0.106578,-0.106416,0.197079,-0.012657,0.593555,1.285749,-0.388044,0.307029,0.511558,0.416663,0.054009,0.309456,-0.193915,-0.495687,-0.863484) * L0_1 + mat4(-0.712809,-0.433657,-0.261048,0.255509,-0.027269,-0.137936,-0.104296,-0.084066,-0.462835,1.246909,-0.970470,-0.826777,-0.221241,-0.311144,-0.332063,-0.382250) * L0_2 + mat4(0.057383,0.587052,0.252917,-0.175362,0.305788,0.576916,0.304157,0.061311,0.455656,-0.020648,0.298966,-0.102968,0.420327,-0.080845,-0.194909,0.336989) * L0_3 + mat4(-0.263071,-0.067769,-0.345024,0.062919,-0.500397,0.096436,1.202581,-0.164789,-0.061452,-0.064565,-0.321200,-0.215026,0.273623,0.252950,0.155191,-0.031015) * L0_4 + mat4(-0.152140,1.154366,0.355711,0.217690,-0.105879,-0.683223,-0.587835,0.202301,0.659270,1.231803,-0.967162,0.193152,0.080431,0.322728,-0.046588,-0.112774) * L0_5 + mat4(0.040581,-0.489867,0.076204,0.187738,-0.094278,0.031472,0.166485,0.016493,0.076320,0.435344,-0.395209,0.347077,-0.104768,-0.030706,-0.280548,-0.090952) * L0_6 + mat4(-0.127418,-0.209978,-0.071775,0.067544,0.109622,0.815005,-0.129221,-0.155472,0.370280,-0.129068,-0.328303,-0.310362,-0.482733,-0.111388,0.738390,0.092406) * L0_7 + vec4(0.296789,1.526737,0.044560,-0.471803)));\nvec4 L1_4 = sin((mat4(-0.124758,0.354951,0.149926,-0.393862,0.008862,0.712014,0.329081,-0.123388,0.203855,-0.088666,1.072006,0.412937,0.001877,-0.081738,-0.077720,-0.046205) * L0_0 + mat4(0.037370,0.266935,0.237598,0.363925,0.110594,-0.333112,0.239747,0.391052,-0.169722,0.296712,-0.519847,0.113033,-0.444202,0.029500,0.104005,-0.063712) * L0_1 + mat4(0.377516,-0.521591,0.379730,0.344449,0.143311,-0.153123,0.215430,-0.069144,-0.398368,-0.365449,-0.589467,-0.998910,-0.391081,-0.281920,0.588237,0.091638) * L0_2 + mat4(-0.574685,0.025904,0.433772,-1.344552,0.029904,0.045678,-0.062698,0.016221,-0.358716,0.056528,0.620964,-0.363286,-0.427101,-0.076794,0.496731,-0.260089) * L0_3 + mat4(-0.024299,0.096230,0.044876,-0.119336,0.905436,0.029627,-0.612684,1.920325,-0.458973,0.170847,0.356301,0.382978,-0.118659,0.226406,-0.470173,-0.031245) * L0_4 + mat4(0.006485,0.208658,-1.016496,-0.138738,0.155729,-0.390818,0.136116,-0.225523,0.072198,-0.000576,0.128269,0.358990,-0.035536,0.109404,1.313602,-0.087478) * L0_5 + mat4(0.089180,-0.050736,-0.046302,0.055481,-0.028242,-0.208711,0.461444,-0.202382,0.175475,-0.097968,0.829261,-0.182156,-0.040713,0.065936,0.007306,-0.007418) * L0_6 + mat4(0.070502,-0.072332,0.008982,0.065201,-0.906345,-0.352855,-0.438491,-0.005712,-0.871213,0.518061,-0.586279,0.433859,0.645385,-0.287215,-0.087198,-0.768194) * L0_7 + vec4(-0.520985,0.195013,0.266960,0.522833)));\nvec4 L1_5 = sin((mat4(-0.195293,-0.373020,-0.345718,-0.459306,-0.151424,-0.514284,-0.121656,-0.093875,-0.066079,0.245986,0.311295,-1.021066,-0.135034,0.101250,-0.239717,0.416673) * L0_0 + mat4(0.076243,0.172304,0.082435,0.103209,-0.008805,0.380510,0.214678,-0.970412,-0.063571,0.230826,-0.037949,-0.384562,-0.722360,0.391967,0.322667,-0.678294) * L0_1 + mat4(0.163138,0.327888,-0.371132,-0.142196,-0.087402,0.266170,-0.074319,-0.020267,-0.004702,-0.158961,-0.042578,0.071710,-0.233800,0.049421,0.061592,0.055079) * L0_2 + mat4(-0.131276,-0.131094,0.556672,-0.206565,-0.325830,-0.234999,0.145944,0.319530,0.271992,-0.428350,0.549593,0.149809,0.198019,-0.816144,-0.875172,-0.067316) * L0_3 + mat4(-0.044575,0.017406,0.041994,-0.239834,-0.137215,0.377845,-0.542768,-0.757685,-0.210443,0.009908,0.216298,0.202371,-0.236231,-0.318687,0.250012,0.424167) * L0_4 + mat4(-0.002394,-0.459200,0.066711,0.148303,0.789227,-0.069521,0.067929,0.210954,-1.161279,0.003296,0.334422,-0.877755,-0.325308,0.017419,0.157518,-0.115733) * L0_5 + mat4(-0.500370,-0.245690,0.337363,0.052018,0.199210,-0.084527,-0.252069,-0.180607,0.223983,-0.030733,0.356093,-0.372842,-0.332951,-0.072855,-0.219623,0.031557) * L0_6 + mat4(0.026775,-0.022291,-0.069615,0.169178,-0.098717,-0.000333,0.500718,-0.338868,-0.355495,-1.043917,0.561574,-0.226685,0.759628,-0.399614,-0.153144,0.418804) * L0_7 + vec4(-0.927039,-0.704882,0.458867,-0.309612)));\nvec4 L1_6 = sin((mat4(0.354206,-0.116590,-0.246823,0.185818,0.098717,0.285889,-0.191124,0.134093,0.851146,-0.410669,-0.132999,0.706778,-0.614269,0.377456,0.173358,-0.412471) * L0_0 + mat4(-0.245784,-0.279228,0.025072,-0.020278,0.290416,0.112696,0.114585,0.074564,-0.112846,0.427706,0.035193,-0.145020,0.084878,1.239484,-0.266674,-1.110903) * L0_1 + mat4(-0.140048,0.189507,-0.222719,-0.185873,-0.545201,-0.161999,0.078828,-0.271047,-1.008502,-0.262872,-0.407168,-0.173089,0.048940,-0.019787,-0.038892,-0.412301) * L0_2 + mat4(0.528897,0.141324,-0.051755,0.285025,0.002684,0.359700,0.351667,0.101189,0.166221,0.335519,0.008750,-0.187778,0.217617,0.515194,-0.359137,0.106039) * L0_3 + mat4(0.005325,-0.168011,0.116923,0.081087,0.014261,-0.181981,-0.061617,0.305714,-0.239726,-0.532015,0.353462,-0.009848,0.109309,0.108601,0.725611,0.209398) * L0_4 + mat4(-0.389915,-0.218554,-0.372744,0.400776,-0.470180,0.275335,-0.691822,-0.372283,0.325467,0.473238,-0.150946,-0.426015,0.894783,-0.113295,0.070752,0.408304) * L0_5 + mat4(0.337313,-0.160294,-0.441316,-0.476432,0.548425,0.027223,0.135755,-0.134094,0.634035,0.211198,0.112222,0.089179,0.116867,-0.223741,-0.025024,-0.172402) * L0_6 + mat4(-0.243630,0.043659,-0.000147,0.075752,-0.658657,-0.052852,0.188445,-0.034495,-0.734062,0.533043,-0.808710,-0.332692,0.139091,-0.807795,-0.735977,0.331003) * L0_7 + vec4(-0.981861,0.503969,0.073963,0.229546)));\nvec4 L1_7 = sin((mat4(0.250069,-0.303887,-0.094152,-0.145528,0.484494,-0.365594,0.338337,-0.109948,0.060010,-0.146457,-0.648982,0.456001,-0.520504,0.244519,0.826709,0.423114) * L0_0 + mat4(-0.320708,-0.104971,-0.181456,0.128048,-0.046909,-0.111739,0.099528,0.605961,0.216254,0.500694,-0.334579,-0.210985,0.065260,0.266234,0.406511,0.541646) * L0_1 + mat4(-0.018310,0.025549,0.052709,0.074943,-0.210263,-0.209338,-0.001097,-0.247018,0.456383,0.718610,0.243092,-0.198025,-0.713692,0.197754,0.199676,0.073311) * L0_2 + mat4(-0.118326,-0.073578,0.436958,0.556683,-0.254883,-0.362318,-0.121326,0.121296,0.286824,0.065989,0.107120,-0.324248,-0.097976,-0.041738,-0.131677,-0.143649) * L0_3 + mat4(-0.055477,0.112683,-0.034670,-0.038712,-0.010696,-0.099064,-0.691081,-0.259841,-0.966077,0.046634,0.123943,-0.479210,0.012202,-0.081994,0.271970,0.271093) * L0_4 + mat4(0.039008,-0.041600,0.275450,-0.667085,-0.281057,-0.200376,-0.359311,0.178203,-0.792633,0.269340,0.459847,0.137006,-0.124677,0.018252,-0.010222,0.432808) * L0_5 + mat4(-0.758973,0.391412,0.129099,-0.499953,0.080925,-0.082225,0.070126,-0.057308,0.001377,-0.032573,-0.155414,0.055720,-0.164031,0.199826,0.132161,0.005408) * L0_6 + mat4(-0.079597,-0.092951,0.218116,-0.255417,0.089671,-0.040181,0.207687,0.057640,0.410608,-0.001588,0.069536,-0.477054,0.228583,-0.406005,-1.134830,-0.100063) * L0_7 + vec4(-0.540181,0.436178,0.784731,0.172949)));\nvec4 L2_0 = sin((mat4(0.489360,0.052665,-0.025679,0.258054,-0.303579,-0.054813,0.527349,-0.321562,0.070155,0.283252,-0.150351,0.460618,-0.454535,0.387913,-0.047865,-0.377567) * L1_0 + mat4(0.203426,0.368695,0.050111,-0.414986,-0.468902,-0.037162,0.387727,-0.100184,0.713712,-0.387866,-0.004366,0.270256,-0.126410,0.139432,-0.203904,-0.389172) * L1_1 + mat4(0.797469,-0.170683,-0.247737,0.051237,-0.211944,0.257233,0.140701,-0.059027,-0.559725,-0.353196,0.346367,0.054990,-0.795634,0.325842,0.395677,-0.581147) * L1_2 + mat4(0.487585,-0.032031,-0.603642,0.503935,-0.102196,-0.411551,-0.118460,0.141862,0.552139,0.118702,-0.048316,0.003486,-1.022211,-0.476924,0.253518,0.478746) * L1_3 + mat4(-0.939484,0.015128,0.867863,0.041566,-0.973683,-1.057348,0.524857,-0.568385,-0.165732,0.007000,0.041435,-0.378384,-0.663476,0.389047,0.232579,-0.639716) * L1_4 + mat4(-0.580478,-0.012888,0.337472,-0.509322,0.396584,-0.085469,-0.480171,0.429299,-0.668229,-0.395438,0.767370,0.203290,0.968196,0.261595,-0.274284,0.018881) * L1_5 + mat4(0.548947,0.272314,-0.523553,0.266332,0.097851,0.255477,-0.494857,0.728509,-0.198028,-0.350727,0.251909,-0.055545,0.496007,0.411138,-0.896511,0.208367) * L1_6 + mat4(0.610307,-0.041805,-0.246548,0.337218,-1.187944,0.302178,0.687372,0.344469,0.262732,0.101485,-0.289259,0.426313,-0.701534,-0.163584,0.439053,-0.395238) * L1_7 + vec4(0.255977,-0.371533,-0.473024,-0.454593)));\nvec4 L2_1 = sin((mat4(0.127091,-0.005452,0.036846,0.433287,-0.862962,-0.111184,0.106848,-0.140778,0.782334,0.544995,-0.167878,0.016144,-0.509399,-0.078520,-0.050202,-0.870531) * L1_0 + mat4(0.281597,-0.020442,-0.197710,-0.167391,-0.508714,0.108780,-0.025935,-0.240867,0.463120,-0.027119,-0.043273,0.921401,0.806736,-0.212771,-0.463946,0.691952) * L1_1 + mat4(0.612741,0.105268,0.422518,-0.043667,0.945805,-0.550527,-0.625216,0.788337,-0.772360,-0.193722,-0.040333,-0.091834,-0.344060,-0.150519,-0.012957,-0.266440) * L1_2 + mat4(0.070561,-0.442676,0.204032,0.256387,-0.083997,-0.026652,-0.033612,0.239039,0.286161,0.077642,0.010122,0.278684,-0.538462,-0.410953,0.226098,0.635544) * L1_3 + mat4(-1.080100,-0.523596,0.165641,-0.418853,-0.700122,-0.198194,-0.124148,-0.654298,-0.238119,-0.009847,-0.024588,-0.049495,-0.784056,-0.276102,-0.074027,-0.503594) * L1_4 + mat4(-0.762406,-0.022257,0.263341,-0.576214,0.889562,0.594575,-0.189265,0.042071,-0.648663,0.196989,0.590003,-0.620795,0.806211,-0.183766,-0.073126,0.359584) * L1_5 + mat4(0.742385,-0.151288,-0.199077,0.237038,-0.285264,0.146614,-0.044844,0.023629,-0.870183,0.063693,-0.411290,-0.336468,0.956869,-0.181871,0.354996,0.468446) * L1_6 + mat4(0.107087,0.120990,0.105059,0.983995,-0.979963,0.422469,-0.174905,-0.556767,0.245658,0.129775,0.363632,-0.049803,-0.878353,-0.076039,-0.243042,0.072174) * L1_7 + vec4(0.183087,-0.384173,-0.164463,-0.718372)));\nvec4 L2_2 = sin((mat4(-0.072522,-0.081101,-0.080053,0.214032,0.093526,0.183793,0.143631,0.249863,-0.296580,-0.913854,-0.290075,-0.304172,-0.141842,0.816876,0.020306,0.162398) * L1_0 + mat4(-0.231826,-0.131413,0.026240,-0.120334,-0.012561,0.044819,0.150484,0.206683,0.056479,-0.720295,0.003139,-0.043702,0.188405,-0.151677,0.234651,-0.213446) * L1_1 + mat4(0.021911,0.215550,-0.140313,0.375764,-0.398245,0.842499,-0.068113,-0.812059,0.399990,0.743648,0.184646,0.805684,0.151065,0.599710,0.128160,-0.105228) * L1_2 + mat4(0.375213,-0.679238,-0.130421,0.093714,-0.140213,0.261646,-0.136265,-0.071543,-0.128170,-0.110241,0.105325,-0.207388,0.598327,-0.137138,-0.315025,0.157456) * L1_3 + mat4(0.028405,0.406497,0.378430,0.028229,-0.764978,0.565637,-0.359708,0.128523,0.179435,0.196043,0.067675,0.130629,0.217857,0.531704,0.141195,0.068240) * L1_4 + mat4(0.427299,1.068555,0.569272,-0.325271,-0.567760,-0.360171,-0.355348,-0.226804,-0.705717,0.110815,-0.041682,-0.182787,-0.255219,-0.520436,-0.051456,-0.246012) * L1_5 + mat4(0.331019,-0.186601,-0.003474,-0.322877,0.020604,-0.416814,-0.205071,0.073444,0.381223,0.077946,0.012033,0.284754,0.036648,0.127495,-0.006148,0.063585) * L1_6 + mat4(-0.371248,-0.023208,-0.323185,-0.576503,-0.237917,0.858356,0.808176,0.418974,0.121585,-0.275211,-0.076722,0.293498,0.540195,0.374479,0.134229,0.197592) * L1_7 + vec4(0.348935,-0.195174,0.834546,0.803527)));\nvec4 L2_3 = sin((mat4(0.353256,0.047983,0.060145,0.242192,-0.096122,0.263597,-0.228468,0.479282,0.162767,-0.535060,-0.059913,0.029695,-0.031737,-0.117462,0.008647,0.602674) * L1_0 + mat4(0.049201,-0.112253,-0.076315,0.050058,-0.154923,0.024116,-0.115594,0.818917,0.135710,0.090178,0.072217,-0.457561,0.768253,-0.177682,0.270949,-0.192062) * L1_1 + mat4(0.627126,-0.528949,0.553779,-0.972790,-0.400604,0.142494,-0.077154,-0.064892,0.151218,0.549292,-0.123925,0.109073,-0.324131,-0.132294,0.186675,0.469400) * L1_2 + mat4(0.583344,0.360306,-0.374715,-0.828139,0.014442,-0.221464,0.137543,-0.036418,0.380250,-0.123602,-0.114545,-0.443933,-0.184244,0.497942,0.488771,0.623129) * L1_3 + mat4(-0.098143,0.008903,-0.397108,0.076151,-0.685602,0.144466,-0.752961,0.594835,0.001187,0.024503,-0.044288,0.717063,-0.258100,0.108707,0.030864,1.211245) * L1_4 + mat4(-0.156833,0.411437,0.033686,0.504924,0.010758,-0.088539,0.131899,-0.260996,-0.336606,-0.455643,-0.326431,0.533635,0.615840,-0.377062,-0.301534,-1.260087) * L1_5 + mat4(0.305699,0.356120,-0.132915,-0.322792,0.436869,-0.902090,-0.433593,-0.545252,-0.845151,0.349720,-0.429577,0.762942,0.581423,-0.116434,0.727723,-0.701833) * L1_6 + mat4(0.250309,-0.434376,-0.058987,-0.751056,-0.567213,1.045830,-0.072263,0.640365,-0.167734,0.386480,-0.043008,-0.707125,-0.351149,0.191740,-0.318967,0.767588) * L1_7 + vec4(-0.441938,0.372111,0.712085,0.163793)));\nvec4 L2_4 = sin((mat4(0.246801,-0.355318,-0.137198,0.270886,-0.864972,0.068802,0.209751,-0.209375,0.803920,-0.006336,-0.348856,0.662019,0.208549,-0.144686,0.715263,-0.197437) * L1_0 + mat4(0.254053,-0.028127,0.183754,0.237500,-0.753829,-0.044383,0.352872,-0.009694,-0.293748,0.252011,-0.568982,0.224325,0.310865,0.291835,0.295789,0.073738) * L1_1 + mat4(0.740205,0.492083,-0.473019,0.081397,0.947101,0.068574,-0.549345,0.211839,-0.481491,-0.047486,0.170550,-0.033804,-0.126157,-0.215478,0.346216,-0.186766) * L1_2 + mat4(0.990263,0.084082,-0.016419,0.401209,-0.233669,-0.147205,-0.189388,0.212223,0.310983,-0.014517,-0.095239,0.147483,0.087874,-0.485221,0.881775,-0.017253) * L1_3 + mat4(-0.218331,0.271632,0.136596,0.143872,0.076876,-0.117420,0.064073,-0.002461,-0.803243,-0.536193,0.402518,-0.168221,-1.104208,-0.870113,0.653947,-0.202293) * L1_4 + mat4(-0.686933,0.384006,0.806857,-0.602151,1.279006,-0.011095,-0.665926,0.722438,-0.576914,-0.208101,0.278936,0.207617,1.000232,0.616811,-0.379509,0.652569) * L1_5 + mat4(0.265278,0.148465,0.231963,-0.139211,0.963477,-0.431232,-0.380875,0.275647,-1.095845,0.125684,-0.441420,0.306469,1.921711,0.276294,-0.216391,0.690558) * L1_6 + mat4(-0.181117,-0.053921,-0.023652,0.204880,0.355272,0.034168,0.140457,-1.016891,1.109991,0.253618,-0.363351,0.253470,-0.812389,-0.233460,0.341814,-0.368213) * L1_7 + vec4(0.777228,-0.322155,-0.049162,0.649126)));\nvec4 L2_5 = sin((mat4(-0.119267,0.070018,-0.009873,-0.184377,0.157359,-0.153102,-0.034946,0.054647,0.110551,0.154240,-0.345669,-0.692592,0.593656,-0.111515,0.134600,-0.146724) * L1_0 + mat4(-0.069751,-0.093001,0.036661,-0.181565,-0.025335,-0.232277,0.156549,0.050513,-0.529030,0.202700,0.006322,-0.083664,0.184120,-0.081816,-0.042978,0.298108) * L1_1 + mat4(-0.538013,0.186256,0.339168,0.034639,0.101722,0.847081,0.021957,0.118322,-0.760254,-0.248734,-0.016793,0.197341,0.194716,-0.165068,-0.182691,0.133520) * L1_2 + mat4(-0.251274,0.063749,0.203142,-0.375298,0.110468,-0.038509,-0.069082,0.064271,0.351702,-0.048003,-0.066417,-0.013676,-0.127798,0.160624,-0.690155,0.344830) * L1_3 + mat4(0.376805,-0.238088,0.447248,0.110678,-0.097599,-0.168737,-0.032541,-0.344317,-0.025586,-0.044779,0.125274,0.004971,0.564545,-0.121529,0.101254,-0.183991) * L1_4 + mat4(-0.273790,-0.654888,0.178073,0.187847,-0.302681,0.129215,0.447189,0.097294,0.205086,-0.403452,0.172133,0.309483,-0.077498,0.271420,0.211823,0.068346) * L1_5 + mat4(-0.177779,0.132950,-0.234057,-0.165188,0.247824,0.246840,0.115433,-0.138290,-0.524629,0.044762,0.322511,-0.262203,-0.032103,1.012659,0.515776,0.085523) * L1_6 + mat4(0.172307,0.015556,-0.485632,-0.168908,-0.257328,-0.485874,0.018032,-0.920403,-0.293761,0.132579,0.173582,-0.018065,0.012255,0.027002,-0.051554,0.465518) * L1_7 + vec4(-1.065990,0.129372,-0.281774,0.096446)));\nvec4 L2_6 = sin((mat4(-0.008446,0.319360,0.121374,0.189926,0.363514,0.107040,-0.605156,-0.834165,-0.515738,0.066251,0.079268,0.108688,0.242071,0.048051,0.171334,-0.293626) * L1_0 + mat4(-0.033318,-0.079426,0.371661,-0.083828,0.260230,0.241747,0.071562,-0.401206,-0.175652,-0.058995,-0.106658,0.291942,0.385570,-0.035919,0.207918,0.003248) * L1_1 + mat4(-0.549169,0.647837,-0.373416,0.618492,0.480143,0.364547,0.027731,1.009014,0.780035,0.087845,0.168446,0.214451,0.525914,-0.379158,0.208455,-0.620630) * L1_2 + mat4(-0.317807,0.013994,-0.322161,0.575884,-0.081116,-0.044619,-0.088986,0.019210,-0.461381,0.432183,0.139911,-0.111421,0.349470,-0.574000,-0.582105,-0.167285) * L1_3 + mat4(0.358775,0.146545,0.052059,-0.456951,-0.895964,-0.016587,0.530340,-0.568644,0.380531,-0.380867,0.285801,-0.399604,0.709720,-0.489705,0.134766,-0.585572) * L1_4 + mat4(0.174735,0.148899,-0.347339,-0.068375,-1.185807,-0.105382,0.532051,-0.208364,-0.353411,0.852001,-0.048821,0.264589,-0.495249,0.513937,0.393488,0.467790) * L1_5 + mat4(0.156946,-0.178567,0.169557,0.373923,-0.519799,0.173457,0.217566,0.365237,0.413920,-0.209027,-0.279296,-0.300183,-0.526259,-0.194645,0.196527,1.000078) * L1_6 + mat4(0.239786,-0.143795,0.181480,0.205108,0.345321,0.530326,0.018547,-0.327825,-0.410911,0.157487,-0.080424,0.644027,0.834696,-0.045272,-0.565190,-0.478427) * L1_7 + vec4(-0.904281,-0.704679,-0.767008,-0.174908)));\nvec4 L2_7 = sin((mat4(-0.105656,-0.200161,-0.063213,-0.106369,0.174908,0.239993,0.194780,0.148763,0.056684,-0.331473,-0.159025,-0.556901,0.468664,0.169148,-0.274899,-0.549220) * L1_0 + mat4(0.099540,-0.217087,0.009899,-0.284749,0.059004,-0.002343,0.101893,-0.338144,-0.488555,-0.219110,0.124666,0.352925,-0.036198,-0.284520,0.223223,-0.304085) * L1_1 + mat4(-0.613298,0.338073,-0.043428,0.332618,0.181799,0.434880,0.171750,-0.046241,0.010867,0.176982,-0.101375,0.448955,0.264919,0.108519,0.024619,-0.042448) * L1_2 + mat4(-0.024039,-0.296933,-0.246504,-0.124051,-0.107936,-0.163648,0.088657,0.472395,-0.355462,-0.197719,-0.106082,-0.089911,0.407717,0.010260,0.233583,-0.086769) * L1_3 + mat4(-0.198698,-0.165964,0.294279,-0.319380,0.016847,0.159144,0.452236,-0.237316,0.049616,0.023836,0.202346,-0.126748,0.100659,-0.028421,-0.088053,-0.417044) * L1_4 + mat4(0.070579,1.225354,0.016078,-0.060429,0.413522,-0.186623,-0.964562,-0.854264,0.404163,0.530383,0.488395,-0.190921,-0.017734,-0.511401,-0.124966,-0.260384) * L1_5 + mat4(-0.027275,0.105477,0.037593,0.060258,-0.111604,-0.232249,-0.568536,0.061470,0.096704,-0.176964,-0.131435,0.488612,-0.422429,-0.176505,-0.755414,-0.057040) * L1_6 + mat4(-0.217390,-0.360330,0.472260,-0.067061,0.192871,-0.067162,-0.882545,0.392603,-0.612782,0.118587,-0.249685,-0.154980,-0.057584,0.214332,0.072382,0.022484) * L1_7 + vec4(-1.118909,0.701599,-0.042799,0.001229)));\nif(BlockIndex == 0)\n{\nvec4 L3_0 = sin((mat4(-0.287894,0.000743,0.032683,0.224582,0.862787,0.157716,0.223439,0.014547,0.382411,-0.036172,0.078211,0.218258,-0.115029,-0.087770,0.008363,-0.141794) * L2_0 + mat4(-0.041463,-0.012213,-0.047555,0.159229,0.403052,0.306106,-0.723725,-0.471328,0.348077,0.351693,-0.661211,-0.352164,-0.144957,0.076444,-0.118209,-0.097724) * L2_1 + mat4(0.074890,-0.125503,0.338162,0.190065,0.000440,-0.004034,0.157988,-0.090493,0.861919,-0.844863,0.506352,-0.524406,0.248498,-0.527692,0.181245,0.189542) * L2_2 + mat4(0.544104,-0.015081,-0.365077,0.006718,0.201703,0.030531,-0.429370,-0.196766,0.147615,-0.301998,-0.368076,-0.213777,-0.072401,0.040277,-0.118158,0.006649) * L2_3 + mat4(0.053442,-0.030267,0.044554,0.092317,0.096419,0.149546,0.036802,-0.235924,0.422956,0.059980,-0.157389,0.108837,-0.296017,0.063879,-0.305720,0.179961) * L2_4 + mat4(-0.481453,0.013678,-0.244334,0.165052,0.318444,-0.125799,-0.038956,-0.437985,-0.598333,0.006359,0.089577,-0.258370,0.211824,0.135591,-0.155584,0.303960) * L2_5 + mat4(-0.193605,0.085485,-0.025767,-0.365188,0.105555,-0.179858,0.041098,0.065192,0.095339,0.045215,0.030120,0.277060,0.172252,-0.063253,0.068519,0.022808) * L2_6 + mat4(-0.719410,0.509179,0.526195,0.448327,0.121750,0.020116,-0.084217,0.503508,-0.383971,-0.128513,0.331396,0.005969,-0.135795,-0.061577,0.366383,-0.112351) * L2_7 + vec4(-0.055347,0.376933,-0.642367,-0.214682)));\n    return L3_0;\n}\nelse if(BlockIndex == 1)\n{\nvec4 L3_1 = sin((mat4(0.025053,0.301245,-0.065117,-0.097063,-0.094689,0.069683,-0.348380,-0.077766,0.118164,0.101656,-0.080153,0.222694,0.076007,0.352710,-0.047492,0.224068) * L2_0 + mat4(-0.064554,0.316622,0.063129,0.012598,0.269082,-0.038636,0.012127,0.482087,0.268727,0.348318,-0.189679,0.846811,0.209241,-0.090858,-0.171174,0.164423) * L2_1 + mat4(-0.270231,-0.248647,-0.407866,0.325264,0.004882,0.239382,-0.137086,0.144591,-0.023502,0.223745,0.141778,0.203219,0.284749,-0.556318,-0.736086,-0.579507) * L2_2 + mat4(0.416251,0.132818,0.075324,0.143639,0.285522,-0.381144,-0.305860,-0.083652,0.027179,-0.135051,0.303027,-0.519602,0.013233,-0.068241,0.276888,0.080354) * L2_3 + mat4(0.033217,-0.091402,-0.042517,-0.051921,0.312047,-0.048247,-0.025060,-0.189308,0.137602,-0.204958,-0.480656,-0.032339,0.340467,-0.495385,-0.006507,-0.337886) * L2_4 + mat4(-0.531714,-0.196584,-0.233138,-0.031214,-0.502878,0.446713,-0.013640,0.163323,0.641075,0.194703,0.845438,0.032407,0.345826,-0.004398,-0.589127,-0.483243) * L2_5 + mat4(0.317806,-0.400753,0.305765,0.086058,0.420467,-0.361961,0.616727,0.285985,-0.024321,-0.698796,0.463217,0.031038,0.146851,-0.537526,0.109920,0.274915) * L2_6 + mat4(-0.074032,0.412428,0.194440,0.562324,-0.121933,-0.105637,0.106067,-0.361784,-0.026168,0.325406,-0.250632,-0.402419,-0.144068,-0.127714,0.193054,0.100718) * L2_7 + vec4(-0.693387,1.276879,-0.376902,-0.486344)));\n    return L3_1;\n}\nelse if(BlockIndex == 2)\n{\nvec4 L3_2 = sin((mat4(0.084733,0.101515,0.193967,0.135464,-0.733112,0.118730,0.466956,-0.665113,-0.553897,-0.011986,0.323973,0.259523,-0.377031,0.132215,0.191817,0.117691) * L2_0 + mat4(0.171264,0.077185,0.029906,-0.017422,0.259913,0.379252,-0.606365,-0.097465,-0.316132,-0.189582,0.140690,-0.076541,0.040718,-0.202341,0.013173,0.301719) * L2_1 + mat4(0.344495,0.350427,0.286740,0.090226,0.184585,-0.005961,0.159580,0.071284,0.351861,-0.904756,-0.339788,-0.452612,-0.629183,0.182853,-0.248262,-0.089241) * L2_2 + mat4(-0.119624,-0.203418,0.464627,-0.210390,0.211820,-0.156824,0.629251,-0.323086,-0.171631,0.045337,0.077582,-0.221839,0.264728,0.080254,-0.024421,0.043468) * L2_3 + mat4(0.026510,0.063825,0.132426,0.009026,-0.413661,0.392385,0.000338,-0.040342,0.520114,-0.384553,-0.138028,-0.088725,0.063942,0.656931,-0.101432,0.021850) * L2_4 + mat4(-0.116820,-0.257338,-0.051923,0.520423,-0.235324,0.273917,0.051913,-0.172552,0.284083,0.148482,-0.976706,0.283542,-0.439012,-0.036631,0.324565,-0.192597) * L2_5 + mat4(-0.546998,0.262878,-0.431288,0.189591,-0.133775,0.477262,-0.056898,-0.205224,-0.356213,0.520439,0.283356,0.064640,0.232120,-0.259055,-0.037068,0.231313) * L2_6 + mat4(0.404244,-0.166743,-0.341454,-0.173368,0.740004,-0.170552,0.478334,0.137966,0.113213,-0.043876,-0.226497,-0.194198,0.234751,0.135744,-0.426518,-0.717066) * L2_7 + vec4(0.419014,0.265348,-0.668673,0.080425)));\n    return L3_2;\n}\nelse if(BlockIndex == 3)\n{\nvec4 L3_3 = sin((mat4(-0.110442,0.176405,-0.060765,-0.055879,-0.548307,-0.640867,-0.218740,0.047838,-0.180914,0.229156,-0.016469,0.055506,0.495823,-0.503453,-0.067661,-0.432622) * L2_0 + mat4(-0.031930,0.024888,0.046841,-0.028711,0.043420,-0.228852,0.446779,0.177200,-0.331172,-0.178514,0.187293,-0.136679,0.225205,-0.204922,-0.145464,-0.200512) * L2_1 + mat4(0.450294,0.151933,-0.512712,-0.136738,-0.022505,0.110264,0.007280,0.086193,-0.308030,0.474066,0.370981,0.228094,-0.238399,0.125276,-0.261764,0.401375) * L2_2 + mat4(0.231287,-0.493622,0.206130,-0.401296,0.189368,-0.112130,0.082820,-0.110594,-0.105191,0.728474,0.089156,0.369196,0.005414,0.031977,0.024481,0.180892) * L2_3 + mat4(-0.076451,0.039974,0.013906,-0.082929,0.078087,0.327298,0.080604,-0.040339,-0.427603,-0.052711,0.139276,0.074567,-0.017026,0.142517,-0.093692,-0.125550) * L2_4 + mat4(-0.069671,-0.326448,0.027577,0.083579,0.266653,0.232785,-0.097510,0.217033,-0.326451,-0.035274,0.077653,0.354416,-0.212085,-0.136727,-0.101879,0.612801) * L2_5 + mat4(0.217845,-0.007252,0.287886,-0.254383,0.157292,0.135765,0.720710,0.040094,-0.121399,-0.152738,0.322400,-0.165653,-0.048366,-0.326505,0.142916,0.133545) * L2_6 + mat4(-0.163684,-0.313008,0.015532,-0.112544,-0.460503,-0.471828,-0.165732,-0.046334,-0.169900,0.506216,-0.072116,0.143281,0.201780,0.408135,-0.062637,0.059992) * L2_7 + vec4(1.118431,-0.155144,0.059495,-0.479478)));\n    return L3_3;\n}\nelse if(BlockIndex == 4)\n{\nvec4 L3_4 = sin((mat4(0.237653,0.212186,0.041648,0.136404,0.305372,0.229558,0.351834,0.395192,0.245046,0.226581,-0.165207,0.070866,-0.235954,0.072931,0.134003,-0.019215) * L2_0 + mat4(-0.062443,0.018674,0.036203,0.023851,0.120267,-0.015897,-0.237319,0.480193,0.912578,-0.274819,-0.493546,1.054535,-0.008906,0.034043,0.283059,-0.126425) * L2_1 + mat4(0.515240,0.417944,-0.274206,0.156355,0.326175,0.185535,0.031120,0.099302,0.569609,0.004966,0.713566,0.144586,0.303082,-0.154893,0.200733,-0.542664) * L2_2 + mat4(0.378799,0.236168,-0.083461,0.227929,-0.234693,0.134856,-0.490962,-0.020135,-0.039452,-0.060411,0.677204,-0.024788,-0.077082,-0.059447,-0.031659,0.106686) * L2_3 + mat4(0.151513,0.043717,-0.130758,0.017517,0.024120,0.117669,0.316383,-0.255548,-0.177479,0.022006,-0.263786,-0.081179,-0.182774,-0.086220,0.358024,-0.390084) * L2_4 + mat4(0.175941,-0.515193,0.117721,-0.062858,0.441087,-0.191226,0.356437,0.313178,0.095928,0.931575,0.397995,0.175770,-0.290016,0.294545,-0.283503,-0.267645) * L2_5 + mat4(0.334028,0.018774,0.725169,-0.203057,0.298975,0.437497,-0.106200,0.154826,0.694549,0.086864,-0.420859,0.088437,0.082911,-0.162394,0.321163,-0.128803) * L2_6 + mat4(0.015456,0.029113,0.497117,0.047662,0.069172,-0.029020,-0.177494,0.047440,-0.206307,-0.164251,-0.184165,-0.154766,0.553355,0.291579,0.306331,0.070396) * L2_7 + vec4(-0.256580,0.655973,0.676752,1.005033)));\n    return L3_4;\n}\nelse if(BlockIndex == 5)\n{\nvec4 L3_5 = sin((mat4(-0.093209,-0.040833,-0.113276,-0.077134,0.282922,-0.391030,0.364724,0.508481,0.396988,-0.090072,0.306837,0.036673,0.178973,-0.525736,0.034518,-0.240066) * L2_0 + mat4(-0.154565,-0.070313,0.151149,0.036575,-0.188554,-0.153016,0.225194,-0.213839,-0.287858,0.659674,0.143201,0.173169,0.194309,-0.124565,0.257829,-0.328046) * L2_1 + mat4(-0.616458,-0.006216,0.285876,0.203833,-0.238977,-0.176688,-0.397896,-0.120621,-0.276121,-0.242755,0.010270,0.027823,-0.222686,0.105206,-0.173670,-0.571903) * L2_2 + mat4(0.140980,-0.130734,-0.012745,-0.184083,0.096163,0.200044,-0.195242,-0.075045,0.281535,0.136122,0.044403,-0.105396,-0.189421,0.042896,-0.130820,-0.279202) * L2_3 + mat4(0.052018,-0.059776,-0.013687,0.066318,-0.148129,-0.282006,-0.008141,0.271001,-0.325732,0.032268,0.342963,-0.144497,0.198602,-0.356711,0.230881,0.168334) * L2_4 + mat4(0.093966,0.015436,-0.225223,0.513755,0.294227,-0.160243,-0.381112,-0.445246,0.091055,0.068767,-0.630504,-0.192011,0.338368,-0.075820,0.104941,-0.126563) * L2_5 + mat4(0.349165,-0.142229,-0.362007,0.068738,-0.135279,-0.131503,-0.198919,0.259692,0.064408,0.179270,0.320600,-0.131985,0.285880,0.116146,-0.185655,-0.059655) * L2_6 + mat4(-0.014178,-0.681395,0.096050,0.377724,0.468322,0.015576,0.350127,-0.304654,0.295745,0.063743,0.373106,-0.123289,-0.119879,0.280378,0.305010,0.049566) * L2_7 + vec4(-0.266083,0.302699,-0.044043,-0.473977)));\n    return L3_5;\n}\nelse if(BlockIndex == 6)\n{\nvec4 L3_6 = sin((mat4(0.124130,-0.161653,-0.048383,0.012256,0.827143,0.147619,-0.335049,0.168173,0.174807,0.458806,0.287677,0.113521,-0.370288,0.490887,-0.306368,0.107196) * L2_0 + mat4(0.136943,-0.268731,0.139588,0.247760,-0.984747,-0.289381,-0.246338,0.360274,-0.109123,-0.278310,0.117044,-0.029934,-0.170460,0.144616,-0.044750,-0.135690) * L2_1 + mat4(-0.805512,0.221679,-0.306290,-0.037761,-0.139832,0.182505,0.114879,-0.119753,0.646951,0.037943,0.459837,-1.010655,0.306851,-0.440566,0.080316,0.273941) * L2_2 + mat4(-0.620345,0.013163,-0.166349,-0.156312,-0.527295,-0.201984,0.052754,0.149794,-0.186177,-0.386024,-0.475622,0.345457,-0.114665,-0.079470,-0.150276,0.095914) * L2_3 + mat4(0.123104,0.302625,0.010862,-0.114164,-0.372925,0.044662,0.108703,0.089459,-0.122549,-0.272054,-0.026686,-0.141945,-0.246745,0.063847,-0.603413,0.094602) * L2_4 + mat4(0.249720,0.389488,0.166944,-0.351268,0.229836,0.664044,0.463001,0.564076,-0.872674,-0.331717,0.584715,-0.883203,0.436764,0.088716,-0.355535,-0.131283) * L2_5 + mat4(-0.065675,0.193124,0.313851,-0.232675,0.340027,0.214593,0.134204,0.023416,0.611618,-0.384412,0.418336,0.476773,0.172810,0.048210,0.205503,-0.284322) * L2_6 + mat4(0.093814,0.604582,-0.240016,-0.404668,0.247758,-0.472042,0.118528,0.518221,-0.105411,-0.274826,0.060538,0.083262,0.920520,-0.249353,0.155837,0.322798) * L2_7 + vec4(-0.330389,0.075966,0.158152,0.340625)));\n    return L3_6;\n}\nelse\n{\nvec4 L3_7 = sin((mat4(0.031071,-0.272675,-0.206473,-0.005688,-0.171251,-0.387975,0.001927,-0.425193,-0.283599,-0.003183,-0.407157,-0.087126,-0.213536,-0.310846,-0.334776,0.139513) * L2_0 + mat4(-0.071482,-0.153005,0.021227,0.214444,0.057390,-0.256645,-0.068439,-0.059819,0.140305,-0.130256,0.371726,0.533822,-0.101099,0.008176,-0.183471,0.188184) * L2_1 + mat4(-0.081525,-0.203962,0.207975,0.195264,-0.152119,-0.283410,-0.279357,0.188602,0.703545,-0.475745,0.231305,-0.071403,-0.307925,0.000213,-0.120634,0.275966) * L2_2 + mat4(0.084950,-0.546217,-0.148849,-0.044890,-0.150809,0.424334,-0.395986,-0.154156,0.423962,0.027862,0.230642,-0.144863,0.034176,0.018680,0.073992,-0.250168) * L2_3 + mat4(0.021604,0.026204,0.010289,0.067789,0.225368,-0.156390,0.034564,0.335769,0.140448,0.007466,0.062046,0.153205,-0.298656,0.084622,-0.269393,-0.347111) * L2_4 + mat4(-0.034590,-0.385484,-0.225728,-0.332112,-0.274849,0.705110,0.534363,0.061767,0.488152,0.454128,0.453290,0.189526,-0.192003,-0.030490,-0.117019,0.321908) * L2_5 + mat4(0.230776,-0.014666,0.112355,0.264311,0.300915,-0.208086,0.140934,0.225867,0.553601,0.078822,0.257316,0.652844,0.060736,0.168767,0.178144,-0.327484) * L2_6 + mat4(-0.709750,-0.753566,0.084356,-0.316727,0.463189,0.030614,0.687246,-0.280158,0.198259,0.135085,-0.217384,0.949007,-0.090735,-0.573644,-0.424227,0.331248) * L2_7 + vec4(0.688277,0.445378,0.186506,0.641371)));\n    return L3_7;\n}\n}\n\n#pragma optimize(on)\n\n\n\n#pragma optimize(off)\nvec4 Lightmap_Half_Floor(const vec3 uv_0, const vec3 uv_1, const int BlockIndex)\n{\nvec4 L0_0 = sin(20.000000 * (mat3x4(-0.109306,0.146146,0.086112,0.204166,-0.088388,-0.058846,-0.172151,0.222555,-0.142687,0.016285,-0.227816,-0.695618) * uv_0 + mat3x4(0.045841,-0.080829,0.046751,-0.082878,-0.003002,-0.094157,-0.041087,0.051161,0.009927,0.015609,-0.022649,0.082471) * uv_1 + vec4(0.108172,-0.016388,0.174256,-0.211940)));\nvec4 L0_1 = sin(20.000000 * (mat3x4(0.001994,-0.155335,-0.206147,-0.391819,0.166622,-0.126319,-0.031150,-0.177656,-0.005467,0.058544,-0.056370,0.363143) * uv_0 + mat3x4(-0.033660,-0.045822,0.135098,-0.101275,0.143666,0.036147,0.033357,0.157014,-0.132148,0.098585,0.098026,0.106806) * uv_1 + vec4(-0.134216,0.023654,0.113637,0.018758)));\nvec4 L0_2 = sin(20.000000 * (mat3x4(0.194020,-0.165239,-0.225718,-0.028077,0.108659,0.073169,0.236927,-0.106659,-0.062008,-0.004309,-0.341766,0.654674) * uv_0 + mat3x4(0.068969,-0.110519,-0.030110,0.076480,-0.124692,-0.000626,-0.208144,0.144312,-0.119095,0.003773,0.033798,-0.053694) * uv_1 + vec4(0.072932,-0.049672,0.003068,0.123620)));\nvec4 L0_3 = sin(20.000000 * (mat3x4(-0.262859,0.220461,-0.143712,-0.289029,0.007735,-0.152427,-0.068362,-0.004869,-0.427808,0.072963,0.154230,-0.134024) * uv_0 + mat3x4(0.156095,-0.020642,0.157789,-0.140084,-0.236019,0.053866,0.084771,-0.043741,-0.150011,-0.125235,-0.124040,-0.080967) * uv_1 + vec4(-0.258634,0.111145,-0.094152,-0.162164)));\nvec4 L0_4 = sin(20.000000 * (mat3x4(-0.001945,-0.149367,0.001189,0.331875,0.168978,-0.136097,0.138521,0.016588,-0.001600,-0.026543,-0.001327,-0.584644) * uv_0 + mat3x4(0.044595,-0.091582,0.086292,-0.163096,0.053346,-0.025810,0.058524,-0.169820,0.091024,-0.063060,-0.123284,0.094565) * uv_1 + vec4(-0.121251,-0.062693,0.079448,-0.017053)));\nvec4 L0_5 = sin(20.000000 * (mat3x4(-0.001319,0.148162,-0.121642,0.148111,0.079828,-0.174796,-0.206574,-0.029551,-0.002990,0.028574,1.204054,0.025817) * uv_0 + mat3x4(0.138735,0.154972,0.101217,-0.156575,0.113906,-0.048570,0.208933,0.117058,0.045527,-0.033766,0.083483,-0.091052) * uv_1 + vec4(-0.193035,-0.021113,0.035530,0.111936)));\nvec4 L0_6 = sin(20.000000 * (mat3x4(-0.181259,-0.162658,0.196817,-0.003617,-0.076935,-0.132728,0.081107,0.092653,0.029456,-0.024932,-0.052521,0.005480) * uv_0 + mat3x4(-0.005299,-0.145586,0.030144,0.122350,0.168239,-0.143262,-0.043176,-0.084884,-0.157997,0.142327,-0.152279,0.164897) * uv_1 + vec4(-0.066041,0.055115,-0.037690,-0.063590)));\nvec4 L0_7 = sin(20.000000 * (mat3x4(-0.172744,-0.000929,0.155495,-0.149529,-0.046498,-0.163539,-0.151681,-0.018704,-0.136503,-0.001186,0.533257,-0.026485) * uv_0 + mat3x4(-0.074682,-0.122338,0.107533,0.159413,0.145278,0.149649,0.200083,-0.166345,-0.019045,0.130873,-0.066875,-0.103932) * uv_1 + vec4(0.021289,0.163360,-0.035550,-0.118676)));\nvec4 L0_8 = sin(20.000000 * (mat3x4(-0.149704,0.147853,0.019939,0.064547,0.012680,0.118139,0.041593,-0.140833,-0.026446,0.028220,0.107287,0.263217) * uv_0 + mat3x4(0.011361,0.005823,0.122585,0.058941,-0.051241,-0.097735,-0.011309,0.126272,-0.065230,-0.133980,0.089110,-0.001920) * uv_1 + vec4(-0.045017,0.162373,0.056140,-0.078323)));\nvec4 L0_9 = sin(20.000000 * (mat3x4(0.178728,0.149844,-0.187792,0.001557,-0.054258,0.105071,0.078464,-0.056046,0.068294,0.026218,0.046497,-0.000557) * uv_0 + mat3x4(-0.156669,0.097887,-0.135820,-0.119450,-0.094701,-0.140026,0.151286,-0.063970,-0.145543,-0.043200,-0.051654,-0.124151) * uv_1 + vec4(0.155721,0.039042,0.100028,0.087577)));\nvec4 L0_10 = sin(20.000000 * (mat3x4(-0.149323,-0.214751,0.149308,-0.336351,0.142536,0.034350,-0.048074,-0.107533,-0.026462,-0.021626,0.025779,0.349668) * uv_0 + mat3x4(-0.110017,0.059187,0.118840,-0.163119,-0.038146,0.156160,-0.101619,0.052078,0.162010,-0.015552,0.162487,-0.146644) * uv_1 + vec4(0.071176,0.047551,0.003145,-0.138852)));\nvec4 L0_11 = sin(20.000000 * (mat3x4(-0.307020,0.148929,0.149368,-0.149683,0.022796,0.123622,-0.133355,0.174316,-0.019087,-0.630866,0.026591,-0.025948) * uv_0 + mat3x4(-0.117841,0.087204,-0.162909,-0.031332,-0.043503,0.014756,-0.004411,-0.072994,0.157795,-0.054874,0.063883,-0.160815) * uv_1 + vec4(-0.002162,-0.067643,0.137610,0.139755)));\nvec4 L0_12 = sin(20.000000 * (mat3x4(0.168793,-0.070793,-0.149769,0.001824,0.047192,-0.075792,-0.013835,-0.130445,-0.958767,-0.356770,-0.026257,-0.002834) * uv_0 + mat3x4(-0.102460,0.051360,0.123442,0.052695,-0.033437,0.008697,-0.097573,-0.145373,-0.076577,-0.068833,-0.066470,0.072601) * uv_1 + vec4(0.054967,-0.029504,-0.024394,0.012810)));\nvec4 L0_13 = sin(20.000000 * (mat3x4(0.021806,0.150791,-0.149352,-0.147447,0.114505,0.044802,-0.067900,-0.069649,-0.363482,0.046963,-0.026483,-0.021359) * uv_0 + mat3x4(-0.156001,0.052194,-0.093389,0.031225,-0.125806,0.131517,0.152273,-0.048273,0.166340,0.028162,-0.068971,0.028162) * uv_1 + vec4(-0.015734,-0.140566,-0.015491,0.183737)));\nvec4 L0_14 = sin(20.000000 * (mat3x4(0.002288,0.062441,0.205284,-0.296985,0.041672,0.034033,0.021677,-0.048851,0.002424,0.578969,-0.018633,0.499596) * uv_0 + mat3x4(-0.022594,0.080016,-0.038636,-0.022976,-0.156132,0.035825,-0.083756,0.114749,-0.121822,0.014745,-0.097640,0.148553) * uv_1 + vec4(-0.037350,0.037447,-0.058192,0.030806)));\nvec4 L0_15 = sin(20.000000 * (mat3x4(0.210608,-0.006812,0.133717,0.020696,0.102814,-0.075679,-0.157408,-0.202710,-0.426786,0.007322,0.002113,0.662791) * uv_0 + mat3x4(-0.089330,0.030067,-0.078414,0.018881,-0.077630,-0.073374,0.171198,0.288938,-0.003034,-0.147496,0.109274,-0.113671) * uv_1 + vec4(0.018831,0.000799,-0.131221,0.245841)));\nvec4 L1_0 = sin((mat4(0.158525,0.063818,-0.194332,-0.297824,0.003830,-0.005438,0.203439,0.006744,0.212466,-0.002844,-0.003575,-0.014768,0.046003,-0.021541,-0.003400,-0.017324) * L0_0 + mat4(0.022698,0.024146,-0.026077,-0.009541,-0.154123,-0.222978,0.090125,0.437152,-0.496386,-0.078063,0.499044,0.079943,-0.308496,-0.077080,0.032154,0.746451) * L0_1 + mat4(0.568722,0.493496,-0.101984,-0.346091,-0.207215,-0.012382,0.317363,0.254446,0.203201,-0.323016,0.164377,-0.009799,0.014115,-0.009056,-0.181012,0.043986) * L0_2 + mat4(0.235760,0.338913,-0.513518,-0.090750,-0.270515,0.025582,0.100372,-0.285405,0.201467,-0.097093,-0.308016,0.274894,-0.096745,0.264853,-0.226055,-0.311129) * L0_3 + mat4(-0.175924,-0.046000,-0.637075,-0.336775,-0.006667,-0.002678,-0.026043,-0.016875,0.021361,0.014726,-0.008950,-0.009483,0.191631,-0.088811,0.135052,0.012952) * L0_4 + mat4(-0.019174,0.018720,0.020917,-0.042832,-0.033032,0.000248,-0.079459,-0.071655,-0.004755,-0.015289,0.172880,-0.005223,-0.081569,-0.012629,0.151358,0.092552) * L0_5 + mat4(-0.376031,-0.228091,0.209431,0.168314,0.143024,-0.091748,-0.275024,-0.268205,0.545538,0.554588,0.007002,-0.478392,-0.111909,-0.283180,-0.315245,-0.312679) * L0_6 + mat4(-0.447441,0.036421,-0.074705,-0.270137,-0.054241,0.024528,0.003621,-0.026697,-0.148315,0.036238,0.221217,-0.223616,-0.006939,-0.002137,-0.028330,-0.016482) * L0_7 + mat4(0.010307,0.003656,0.032992,0.015164,-0.032387,-0.010279,0.061289,0.091481,0.122948,-0.010649,-0.067967,-0.244389,0.119613,-0.036512,0.029151,-0.215385) * L0_8 + mat4(0.147559,-0.117825,-0.252099,0.046599,-0.007566,-0.000317,-0.038173,-0.018156,-0.499563,-0.384767,0.175738,0.179115,-0.004733,-0.306477,-0.439090,-0.112518) * L0_9 + mat4(0.006436,0.002796,0.025911,0.017301,-0.539699,-0.311877,0.540404,0.037758,0.002284,-0.003936,0.043703,0.027136,-0.494099,0.377995,1.018068,-0.162480) * L0_10 + mat4(1.394897,0.457654,-0.319698,0.103973,0.014215,0.014509,0.099575,0.018319,0.007354,0.002874,0.027025,0.016625,0.004247,-0.001259,0.040868,0.020459) * L0_11 + mat4(-0.007032,0.004718,0.159616,0.068533,0.200048,0.021280,0.191806,-0.265460,0.008390,0.000886,0.038984,0.017008,0.021120,-0.005582,0.036590,-0.006451) * L0_12 + mat4(0.140657,0.029318,-0.077063,0.105004,0.072774,0.023698,0.198386,0.234442,0.006812,0.002798,0.027038,0.017228,-0.031600,0.051092,0.027434,0.092316) * L0_13 + mat4(-0.159028,-0.119908,-0.220238,0.091891,0.194154,0.064874,-0.313867,0.029716,0.595422,0.329394,-0.321713,-0.106338,0.147464,-0.215524,-0.701774,-0.143680) * L0_14 + mat4(0.594663,-0.145350,-0.024539,0.016645,-0.006426,0.047382,-0.049457,-0.009919,0.448539,0.356887,0.394146,0.595351,-0.045388,-0.001848,-0.199095,-0.071964) * L0_15 + vec4(0.738041,0.022455,-0.764934,-0.788592)));\nvec4 L1_1 = sin((mat4(-0.122954,0.118594,-0.138986,-0.147012,-0.071467,-0.156445,-0.047941,-0.148993,-0.279516,0.294897,0.370281,-0.050121,-0.014649,0.006090,0.001699,-0.180396) * L0_0 + mat4(0.024675,-0.001491,0.010205,-0.005763,-0.325110,-0.457059,0.232363,0.225757,-0.668732,0.105577,0.287346,0.034948,0.677300,-0.195921,-0.274519,0.038301) * L0_1 + mat4(0.469269,0.399548,-0.226381,-0.291975,-0.177559,-0.189568,0.231519,0.011239,-0.062024,-0.159261,-0.313467,-0.025532,-0.016596,-0.061246,0.025920,0.005798) * L0_2 + mat4(-0.050909,-0.433582,-0.047812,0.084134,-0.608950,0.177779,0.076915,0.039708,0.361915,-0.028644,-0.415125,-0.302463,0.911499,-0.977574,-0.492667,0.701304) * L0_3 + mat4(0.249614,0.218369,0.106613,-0.442196,0.018224,0.013107,0.017367,0.030598,0.012685,0.002153,0.010809,0.010158,-0.260264,0.151182,-0.268378,0.138506) * L0_4 + mat4(0.031330,-0.004556,-0.019186,-0.016820,0.004405,0.043701,0.075866,0.104361,-0.011792,0.041194,-0.062283,0.005505,-0.048580,-0.064369,-0.092390,-0.132675) * L0_5 + mat4(-0.342956,-0.268599,0.272050,0.173440,0.511887,0.026846,-0.063064,0.109712,0.432825,0.335124,-0.509503,-0.229504,0.230463,0.247578,-0.223305,-0.485088) * L0_6 + mat4(-0.166374,0.103786,-0.285560,-0.157968,0.048647,0.013905,-0.002276,-0.012356,0.080250,-0.190001,0.107318,-0.001603,0.018116,0.013594,0.017056,0.030881) * L0_7 + mat4(-0.016829,-0.015633,-0.016138,-0.032070,-0.030940,-0.021175,-0.075490,-0.081614,-0.013506,0.201678,0.349872,0.156871,0.006093,0.103363,0.045256,0.021755) * L0_8 + mat4(0.490430,-0.138660,0.067133,0.451444,0.021458,0.016410,0.018478,0.032414,-0.609058,-0.503226,0.524213,0.200769,0.642807,0.017058,-0.026082,-0.130270) * L0_9 + mat4(-0.018752,-0.012621,-0.017792,-0.030475,-0.760282,-0.152062,0.459963,0.202328,-0.021876,-0.019782,-0.025642,-0.033875,0.138477,0.175489,-0.153966,-0.654351) * L0_10 + mat4(0.620139,-1.601903,-2.541593,-2.037174,0.311840,-0.086097,-0.115688,-0.100705,-0.018111,-0.013157,-0.017329,-0.030858,-0.021077,-0.018017,-0.020389,-0.032351) * L0_11 + mat4(-0.007559,0.019473,-0.032768,-0.035636,0.370567,-0.229838,0.167624,0.045235,-0.020202,-0.017209,-0.018470,-0.032815,-0.002714,0.013672,0.012568,0.056642) * L0_12 + mat4(0.013106,0.042299,-0.097609,-0.038057,-0.501383,0.105675,-0.182679,-0.360636,-0.018618,-0.012646,-0.017770,-0.030510,-0.152089,-0.137545,0.008794,-0.160826) * L0_13 + mat4(0.515122,0.115228,0.192407,-0.008139,0.240550,-0.078974,0.001210,0.000669,0.658305,0.272976,-0.351671,-0.273342,-0.371222,0.321049,0.209043,0.131780) * L0_14 + mat4(0.162114,-0.222975,-0.228583,-0.147994,-0.033638,-0.013750,-0.011283,-0.025324,-0.057259,-0.452687,0.550175,-0.346094,0.092659,-0.057722,0.046696,0.000191) * L0_15 + vec4(0.640719,0.302098,-0.324578,-0.789523)));\nvec4 L1_2 = sin((mat4(-0.363009,0.182360,0.056514,-0.091945,0.131122,0.006091,0.010853,0.173814,0.297922,0.220093,0.223628,-0.082565,0.116485,-0.014969,0.045070,-0.065467) * L0_0 + mat4(-0.008245,0.003785,-0.016986,0.005275,0.109216,0.214574,0.205968,0.392178,0.062947,-0.034634,0.168320,0.210361,1.472259,0.445931,-0.939333,0.180041) * L0_1 + mat4(-0.229640,-0.257927,-0.611263,-0.493080,0.098618,0.119337,0.187201,0.366524,-0.010277,0.011492,0.112112,0.066543,-0.008467,-0.000393,0.065607,0.030473) * L0_2 + mat4(-0.423352,-0.081988,-0.119525,-0.071998,-0.281741,0.050128,0.091158,0.134599,-0.471653,0.375172,0.139787,0.158920,-1.034961,0.521010,0.304694,-0.480014) * L0_3 + mat4(-0.518055,0.073660,-0.313071,0.055258,-0.009343,-0.000049,-0.023349,-0.019282,0.008743,0.000704,0.001351,-0.024550,-0.215543,0.037808,-0.215780,0.071706) * L0_4 + mat4(-0.014256,-0.005854,0.006036,-0.052030,-0.055804,0.008986,-0.018025,-0.061054,-0.042344,0.017607,-0.042400,0.073183,0.078778,0.000760,0.012392,0.091773) * L0_5 + mat4(0.199396,0.243106,0.304259,0.361071,-0.243695,-0.049064,-0.175901,-0.270476,-0.221974,-0.257096,-0.497382,-0.426413,0.043561,0.100773,-0.485706,0.161878) * L0_6 + mat4(-0.441695,0.002571,0.164397,0.067379,0.000749,-0.015791,-0.007878,0.000070,0.097804,0.033908,0.054925,0.063653,-0.010847,0.000339,-0.023436,-0.020055) * L0_7 + mat4(0.013190,-0.000298,0.023325,0.020931,0.057445,-0.006241,0.045347,0.034965,-0.317213,0.065775,-0.005909,-0.091156,0.155647,-0.026483,-0.051378,-0.032845) * L0_8 + mat4(0.113580,0.055426,-0.246260,-0.099673,-0.015876,0.001533,-0.021694,-0.020543,0.326397,0.155500,0.297537,0.404122,-0.281232,-0.076653,-0.217475,0.158727) * L0_9 + mat4(0.009611,0.000056,0.023112,0.019151,0.351432,0.174608,0.043310,0.363721,0.019428,-0.002898,0.022367,0.019469,-0.646640,0.363584,0.877078,-0.250437) * L0_10 + mat4(2.786094,-3.501186,-0.798594,-0.676580,0.038065,0.038049,0.114008,-0.053254,0.009853,-0.000106,0.023086,0.019549,0.018066,-0.002198,0.021796,0.020222) * L0_11 + mat4(0.061478,-0.022844,0.009326,0.021690,0.065238,-0.189816,-0.063047,0.019594,0.016451,-0.001493,0.022011,0.021015,-0.004104,0.003786,-0.012658,0.042255) * L0_12 + mat4(0.025361,0.070664,-0.023974,0.044443,0.101452,-0.074107,0.275923,0.186199,0.009657,-0.000131,0.023174,0.019127,0.039552,0.023333,-0.044770,0.157208) * L0_13 + mat4(-0.268337,0.085664,-0.050157,0.140778,-0.225126,-0.034441,0.006507,0.014417,-0.336736,-0.160363,-0.304903,-0.378942,-0.288699,-0.033449,-0.416971,0.008770) * L0_14 + mat4(-0.211960,0.026775,-0.125148,0.051911,0.009907,0.002239,-0.011855,-0.034862,0.695742,-0.622494,0.398761,0.037221,0.020176,-0.035428,-0.059729,0.017067) * L0_15 + vec4(0.003776,-0.736578,-0.692550,-0.729763)));\nvec4 L1_3 = sin((mat4(0.012415,-0.197027,-0.038272,0.203616,0.004885,0.289843,-0.202360,-0.071789,-0.364969,-0.571411,-0.050995,0.080521,0.218885,0.178298,0.244025,0.145902) * L0_0 + mat4(0.014169,0.006982,-0.006379,-0.011930,0.106082,0.235176,-0.151389,0.175428,0.464449,0.010914,0.540370,0.074715,-0.560543,-0.566774,0.094756,-0.519982) * L0_1 + mat4(-0.353135,-0.220986,0.146492,-0.340400,0.228706,0.310596,0.117097,0.327710,-0.511336,-0.023616,-0.014656,0.131079,0.072701,0.197464,-0.126975,0.074381) * L0_2 + mat4(-0.375162,0.185828,-0.059231,-0.228184,0.612461,0.000326,0.454039,0.304015,0.568869,0.357219,0.007066,-0.108336,0.070767,0.362547,-0.200055,-0.200584) * L0_3 + mat4(-0.260405,-0.175670,-0.410019,-0.438386,-0.007682,-0.033925,0.004012,-0.000213,0.003714,0.045291,0.011158,-0.009406,-0.017806,-0.242715,-0.018589,-0.136689) * L0_4 + mat4(0.019229,-0.050176,-0.000452,-0.002885,-0.082105,-0.108837,0.029263,0.004819,0.077566,-0.098168,-0.037568,-0.034088,0.085917,0.166290,-0.125974,0.004731) * L0_5 + mat4(0.364375,0.022873,-0.018969,0.272815,-0.163798,-0.474837,-0.120053,-0.075367,-0.265060,0.051958,0.055685,-0.126080,-0.043791,-0.323539,-0.282454,-0.035202) * L0_6 + mat4(0.059656,0.203222,0.280189,0.015596,0.023903,0.092427,0.009869,0.007032,-0.498453,0.089532,0.000057,0.169520,-0.007853,-0.034671,0.002689,0.001294) * L0_7 + mat4(0.007542,0.036077,-0.004548,-0.002859,0.058495,0.100328,-0.034377,0.002463,-0.026903,-0.215242,-0.177774,-0.005677,-0.080652,-0.078404,0.258148,-0.218979) * L0_8 + mat4(-0.105011,-0.174500,-0.507133,-0.090998,-0.007881,-0.037193,0.004509,0.004311,0.540674,0.130510,0.101888,0.077860,-0.208597,0.181263,-0.051371,-0.317139) * L0_9 + mat4(0.008151,0.032964,-0.003217,0.000275,0.221848,0.033020,0.427525,0.076412,0.018165,0.042558,-0.006664,-0.007699,0.474212,0.827005,0.064281,-1.317964) * L0_10 + mat4(1.337682,-1.024109,0.775560,0.217022,-0.262292,0.367557,-0.030051,0.043481,0.008016,0.033657,-0.003549,-0.000522,0.011118,0.038247,-0.003470,-0.006043) * L0_11 + mat4(0.156601,-0.209287,0.078169,0.000855,-0.221042,-0.136978,0.293094,-0.226859,0.008501,0.036771,-0.003996,-0.004882,0.006121,0.022584,-0.018177,0.013028) * L0_12 + mat4(-0.298776,0.155326,0.010113,0.117195,0.304674,0.184100,0.038900,-0.000276,0.007817,0.033407,-0.002730,0.000331,0.122611,0.178729,-0.073808,0.116005) * L0_13 + mat4(-0.224915,-0.034076,0.050552,0.036414,0.181469,-0.335590,0.085961,0.199353,-0.251981,-0.204586,-0.050423,-0.193373,0.346074,0.003959,0.101899,0.283158) * L0_14 + mat4(-0.088713,0.491372,0.143895,-0.257818,0.009135,0.017259,0.026595,-0.035383,0.114387,0.324129,0.441282,-0.093953,0.010839,0.332048,0.009067,-0.032720) * L0_15 + vec4(-0.376841,-0.460174,-0.056460,-0.080922)));\nvec4 L1_4 = sin((mat4(-0.745887,0.030288,-0.104148,-0.269654,0.152798,-0.129881,-0.047803,-0.094749,0.289816,0.152952,0.186744,0.275609,-0.003521,-0.110307,0.114132,0.282269) * L0_0 + mat4(0.010746,-0.013853,-0.020257,-0.025159,0.245554,-0.111181,0.407559,0.110259,-0.490945,0.064626,-0.074063,-0.284709,-1.671258,-0.570977,-0.038107,1.194248) * L0_1 + mat4(-0.151058,-0.262574,-0.439179,-0.210064,-0.112843,0.128600,0.285986,-0.065244,-0.101934,0.381707,0.254930,-0.180142,0.008960,0.092849,0.021435,0.013120) * L0_2 + mat4(-0.115921,-0.218864,-0.406997,-0.273395,-0.529370,0.157568,-0.173945,-0.160264,-0.813444,0.250886,-0.546052,-0.427697,-0.275720,0.237508,0.113957,-0.496925) * L0_3 + mat4(0.518491,0.373780,0.157837,0.293440,0.008978,0.003738,-0.000660,0.032197,-0.025078,0.026931,-0.011536,0.014631,-0.378100,0.010465,0.107284,-0.061410) * L0_4 + mat4(0.003824,-0.007275,0.004189,-0.025360,0.084680,0.055360,0.056312,0.137228,-0.058249,-0.067420,-0.007188,0.191685,-0.045238,-0.053652,-0.055294,-0.146349) * L0_5 + mat4(0.216201,0.124929,0.367332,0.079582,0.105472,-0.067344,-0.052097,0.183678,-0.120385,-0.178553,-0.456602,-0.131670,0.174516,-0.049990,0.017535,0.244675) * L0_6 + mat4(-0.703449,0.125991,-0.041133,-0.261486,-0.024350,0.015426,-0.006725,-0.012119,0.030716,0.100836,0.054092,0.126980,0.009158,0.004205,0.000735,0.033570) * L0_7 + mat4(-0.010059,-0.003316,-0.005478,-0.035899,-0.064914,-0.039186,-0.025383,-0.119155,0.278450,-0.286388,-0.279060,0.361323,-0.087611,0.042365,-0.101841,0.129335) * L0_8 + mat4(0.598399,0.036769,0.250431,0.399175,0.009056,0.003994,0.007031,0.040037,0.222409,0.045980,0.401603,0.121606,0.242873,0.061218,-0.171163,0.359187) * L0_9 + mat4(-0.008716,-0.003593,0.000279,-0.031781,-0.001798,0.057865,0.165868,-0.079475,-0.011339,-0.010512,-0.010423,-0.049583,-1.452335,0.037728,0.870471,0.506657) * L0_10 + mat4(1.574884,2.356840,-1.609002,2.438494,0.071986,0.198752,0.035187,-0.152991,-0.009075,-0.003720,-0.000012,-0.032465,-0.009735,-0.006210,-0.008952,-0.043576) * L0_11 + mat4(-0.106066,-0.183449,-0.104951,0.112548,0.307631,0.064292,0.081537,0.440650,-0.009680,-0.003799,-0.008583,-0.040388,-0.019968,0.004728,0.016768,0.019917) * L0_12 + mat4(0.024919,0.076402,0.110395,-0.099691,-0.510693,0.098902,-0.166916,-0.374179,-0.008928,-0.004068,0.000292,-0.032298,0.091587,-0.080176,0.112562,-0.100789) * L0_13 + mat4(0.201018,0.125540,0.098353,0.197619,0.111002,0.023320,0.089059,0.182935,0.140689,-0.296834,-0.401389,-0.086885,0.643817,0.367327,0.063947,0.061725) * L0_14 + mat4(-0.319567,0.151346,0.112844,-0.403693,0.015392,-0.009574,-0.015608,-0.010877,0.563508,-0.351551,0.615555,0.389457,0.028075,0.082517,0.008920,-0.151472) * L0_15 + vec4(0.726295,0.208369,-0.456061,0.739179)));\nvec4 L1_5 = sin((mat4(-0.456796,0.085163,-0.122092,-0.116568,-0.273243,-0.018517,0.043412,-0.140100,0.159179,0.020239,-0.020680,0.284071,-0.062907,0.094804,0.130684,-0.080774) * L0_0 + mat4(-0.018006,0.022501,-0.023465,0.000370,-0.326697,0.109341,-0.386262,-0.007327,-0.454651,-0.094004,0.560728,0.186971,0.265163,0.006674,-0.660472,0.323913) * L0_1 + mat4(0.330370,0.142404,-0.142329,-0.255480,-0.521658,-0.116992,0.263101,0.012177,-0.247749,0.103545,-0.382156,0.218974,0.025454,-0.028192,0.103680,-0.033330) * L0_2 + mat4(0.339793,0.003641,0.866432,0.253056,-0.307570,0.196875,0.144709,-0.071876,-0.037543,0.270097,0.612605,-0.373587,1.642167,0.512031,-0.657097,-0.430929) * L0_3 + mat4(0.110794,0.138963,-0.275643,0.079485,0.035838,0.004901,-0.024049,0.004853,-0.002123,-0.019400,-0.008973,-0.000558,0.122766,0.208196,-0.185863,0.158213) * L0_4 + mat4(-0.011093,0.004106,0.047974,0.006221,0.130090,0.014749,-0.208026,0.064736,-0.057104,-0.019616,-0.015700,0.003985,-0.188298,-0.005740,0.232681,-0.071178) * L0_5 + mat4(-0.373233,-0.219777,0.175295,0.161636,0.458085,0.184169,-0.447879,-0.068752,0.354926,0.276800,-0.204373,-0.049332,0.229663,0.477926,-0.170927,-0.008898) * L0_6 + mat4(-0.365670,0.097126,-0.323367,-0.196442,-0.001391,-0.009008,0.014148,0.002389,0.043485,0.133128,0.136494,-0.106139,0.035809,0.005444,-0.026251,0.005438) * L0_7 + mat4(-0.038097,-0.007714,0.032374,-0.007627,-0.107857,-0.015002,0.179873,-0.031632,-0.027135,0.012872,0.404905,0.059134,-0.008947,-0.166869,-0.481530,0.052889) * L0_8 + mat4(0.506180,0.116632,-0.340023,0.164191,0.040018,0.007768,-0.039689,0.008894,-0.281794,-0.074901,0.112800,0.244222,0.297772,0.563041,0.184078,-0.173997) * L0_9 + mat4(-0.035142,-0.004408,0.022338,-0.004561,-0.369469,-0.179111,0.642970,0.217429,-0.048041,-0.009772,0.065264,-0.014261,0.131694,1.148283,-0.140893,-0.104215) * L0_10 + mat4(-1.800708,-1.960645,-1.176811,-1.980583,0.064777,0.177148,-0.688406,0.085231,-0.035744,-0.004898,0.024569,-0.005019,-0.042313,-0.009073,0.049835,-0.010990) * L0_11 + mat4(-0.144472,0.076524,-0.511633,-0.021121,0.042820,-0.125937,0.113913,0.161056,-0.040541,-0.008531,0.040189,-0.009588,-0.005951,-0.023092,-0.021900,-0.012875) * L0_12 + mat4(0.082207,0.130312,-0.180729,-0.051261,-0.468045,-0.156711,0.417921,-0.120598,-0.035531,-0.004559,0.023510,-0.004467,-0.255723,0.003140,0.077671,0.061215) * L0_13 + mat4(0.307636,0.197324,-0.267103,0.059403,0.007044,-0.006696,-0.404064,0.022957,0.455149,0.288287,-0.266383,-0.211679,0.025121,-0.142111,0.580724,-0.168442) * L0_14 + mat4(0.086629,0.271508,-0.376208,-0.108186,0.011151,0.018404,0.039720,0.010073,-0.296166,-0.087694,-0.857427,0.380204,-0.038710,0.009142,0.287246,0.004168) * L0_15 + vec4(0.315876,0.172312,-0.706036,-0.255485)));\nvec4 L1_6 = sin((mat4(-0.170972,0.000715,-0.566305,0.248885,-0.274468,-0.005628,-0.131101,0.162827,-0.021265,0.305305,0.190431,0.011765,-0.152778,0.088080,-0.042868,-0.069613) * L0_0 + mat4(-0.017860,-0.009596,0.012028,0.025152,-0.021316,0.082235,0.244175,0.023547,0.216019,0.021807,0.047327,0.023617,-0.619134,-0.414418,-0.505514,0.087567) * L0_1 + mat4(-0.301701,0.561777,-0.189458,0.314115,-0.061344,-0.319271,-0.048960,0.096344,-0.096976,-0.010769,-0.159452,-0.035696,0.087006,-0.146446,0.083314,-0.006891) * L0_2 + mat4(0.161123,0.065181,0.707852,0.327230,0.050963,0.087437,-0.138965,-0.015488,0.500097,-0.216248,-0.189422,0.170840,-0.281172,0.303445,-0.185971,0.697757) * L0_3 + mat4(-0.366124,0.017973,-0.123619,-0.168167,0.011446,0.021364,0.004555,-0.007772,-0.000265,0.024601,-0.031405,0.002034,0.027188,0.201314,-0.093723,0.073752) * L0_4 + mat4(-0.017397,0.009328,-0.025965,-0.028228,0.014155,0.075748,0.079913,-0.035890,-0.092563,-0.069734,-0.025361,-0.017419,-0.029685,-0.056672,-0.098864,0.050610) * L0_5 + mat4(0.036429,-0.162853,0.080772,0.114201,0.085672,0.303808,0.105347,-0.043530,-0.344015,0.462074,0.081127,0.220304,-0.077646,0.213059,0.138958,0.243313) * L0_6 + mat4(-0.319368,-0.140646,-0.611492,-0.134087,-0.026184,0.024104,-0.010525,0.008164,-0.016095,0.227053,0.029069,0.032924,0.010454,0.020937,0.004624,-0.006685) * L0_7 + mat4(-0.010114,-0.018351,-0.000780,0.004011,0.001016,-0.102652,-0.062121,0.033716,-0.427708,0.086746,-0.218748,0.236969,0.217513,-0.266755,-0.006668,-0.019464) * L0_8 + mat4(0.141267,0.275986,0.574819,-0.118796,0.011017,0.019133,0.001086,-0.001893,0.330794,-0.399334,0.116084,-0.278157,0.188024,0.302612,0.114561,0.208186) * L0_9 + mat4(-0.011595,-0.021461,-0.005098,0.008831,0.530688,-0.238983,0.144670,0.202369,-0.011382,-0.029791,-0.012593,0.002686,0.106095,0.691402,0.491847,-0.327413) * L0_10 + mat4(0.636924,1.306638,0.998239,-0.016569,-0.165177,0.228963,0.231282,0.037973,-0.011271,-0.020824,-0.004420,0.007474,-0.011281,-0.021884,-0.004614,0.001278) * L0_11 + mat4(-0.170850,-0.209108,-0.106457,-0.042868,0.147576,-0.039701,-0.203537,-0.216981,-0.010189,-0.019158,-0.001302,0.002278,0.007933,0.026583,0.003245,-0.000747) * L0_12 + mat4(-0.012947,-0.114722,0.369615,0.008827,0.048543,-0.311883,-0.383421,0.175587,-0.011418,-0.021824,-0.005089,0.008279,-0.203148,-0.028992,-0.053509,0.020677) * L0_13 + mat4(-0.359625,0.031241,0.104055,0.077240,-0.009101,-0.045292,0.163828,0.004011,-0.390002,0.461005,0.082345,-0.127833,0.301991,-0.169993,-0.197588,-0.102052) * L0_14 + mat4(-0.114444,0.089753,-0.095706,-0.039854,-0.038626,-0.006250,-0.026935,-0.005911,-0.406512,-0.025379,0.717528,-1.053485,0.108817,-0.134545,0.004544,0.021092) * L0_15 + vec4(-0.063639,0.895235,0.130841,-0.041390)));\nvec4 L1_7 = sin((mat4(0.063112,0.530353,-0.153639,0.547635,-0.223786,-0.094238,-0.365808,0.038675,0.316195,0.011838,-0.002164,0.014601,-0.068079,0.040917,-0.022692,-0.290724) * L0_0 + mat4(0.029374,-0.043679,-0.030380,-0.019857,-0.170790,-0.421007,-0.753245,-0.263930,-0.037267,0.547580,0.230225,0.280020,0.515061,0.477018,-0.403769,-1.164747) * L0_1 + mat4(-0.184676,0.435376,0.529219,0.052538,-0.189540,-0.189527,-0.125232,0.099890,0.007030,0.088877,0.069174,0.131026,-0.059465,-0.065580,0.025297,0.004261) * L0_2 + mat4(-0.094334,0.154855,0.639896,0.216134,0.080517,0.530581,0.186390,0.367414,0.208637,0.384672,0.187050,0.477976,-0.440900,0.801029,0.642565,0.450347) * L0_3 + mat4(-0.184510,-0.217043,0.105780,-0.440229,0.030084,0.003831,0.019318,-0.018209,0.001897,0.004635,0.015976,-0.016005,0.000731,-0.119395,0.034798,0.427438) * L0_4 + mat4(0.018591,0.009856,-0.009180,-0.019063,0.064762,0.038803,0.035857,-0.130079,0.003789,-0.015632,-0.024593,0.036521,-0.132911,-0.091420,-0.129027,0.091844) * L0_5 + mat4(-0.098273,-0.255882,-0.338973,-0.077949,0.308784,-0.024104,0.245796,-0.185223,-0.001648,0.274161,0.417523,0.153162,-0.017023,-0.179021,0.383245,-0.380433) * L0_6 + mat4(-0.126130,0.676297,0.135587,0.475318,-0.012448,-0.010743,0.018733,-0.013622,-0.072448,-0.013010,-0.195166,-0.018609,0.029178,0.004086,0.019394,-0.018875) * L0_7 + mat4(-0.027680,-0.002709,-0.018886,0.021188,-0.081126,-0.058054,-0.029501,0.073710,0.180375,0.210158,-0.096512,-0.135610,0.043745,-0.023504,0.125220,0.149017) * L0_8 + mat4(0.195041,-0.480309,-0.179709,-0.548574,0.027954,0.005634,0.020796,-0.021062,0.121631,-0.282609,-0.480522,-0.146256,0.199370,-0.256696,0.373907,-0.277061) * L0_9 + mat4(-0.029947,-0.004639,-0.019240,0.017877,0.115980,0.256894,-0.097602,0.007755,-0.032292,-0.015215,-0.025528,0.030984,-0.673813,-1.286199,0.323016,1.405158) * L0_10 + mat4(0.800699,-2.860538,2.522786,-2.345660,-0.068099,0.014121,-0.215091,0.126383,-0.029954,-0.003634,-0.019323,0.018601,-0.027925,-0.009102,-0.020719,0.024291) * L0_11 + mat4(0.050674,0.053293,-0.161998,-0.110850,0.216651,-0.194550,0.221353,-0.163095,-0.027665,-0.005844,-0.020699,0.022011,-0.027730,-0.016947,0.023824,-0.006609) * L0_12 + mat4(0.060616,-0.085760,0.093499,0.093774,-0.303137,0.190250,-0.017117,0.490882,-0.030216,-0.004572,-0.019836,0.017494,-0.132922,-0.072903,-0.243248,0.062415) * L0_13 + mat4(-0.017171,-0.176132,0.278345,-0.630932,0.113223,-0.057733,0.005888,-0.053788,-0.069069,-0.020630,0.111733,-0.098995,-0.110450,0.031354,0.322553,0.028603) * L0_14 + mat4(-0.008951,0.244886,-0.118179,0.321191,0.045532,0.024752,0.000148,-0.023980,-0.768881,-0.839761,-0.039511,-0.615004,-0.006526,-0.105880,0.040008,-0.000637) * L0_15 + vec4(0.444820,-0.331171,0.941534,-1.096868)));\nvec4 L1_8 = sin((mat4(0.322315,0.119188,-0.107054,-0.126280,0.108368,-0.256295,0.021056,0.283956,-0.311878,-0.254241,-0.421400,0.098167,-0.001903,0.046768,0.058068,-0.103748) * L0_0 + mat4(-0.027650,0.020598,0.035948,0.018270,-0.054752,-0.543305,-0.231806,0.533446,-0.202633,-0.162325,0.323326,0.015431,-0.019249,-0.385201,1.097614,0.301204) * L0_1 + mat4(0.624396,0.571987,0.184194,-0.443895,-0.073130,-0.488478,0.077983,0.267388,0.225429,-0.082629,0.178468,0.201825,-0.063809,-0.087569,-0.075562,0.039367) * L0_2 + mat4(0.224179,-0.130365,-0.087456,0.337802,-0.163267,-0.019407,0.303118,-0.207414,0.021525,0.496870,0.470721,0.022401,0.027134,-1.080927,0.213677,-0.770067) * L0_3 + mat4(-0.132809,0.507420,0.406794,0.008986,-0.003525,0.017537,-0.009009,-0.025845,0.008857,-0.005144,-0.000986,-0.009598,0.030359,0.064704,0.049641,-0.009065) * L0_4 + mat4(-0.002684,-0.004882,0.014318,-0.003023,-0.070630,0.088121,-0.070302,-0.098959,-0.012002,-0.017754,-0.021033,-0.019902,0.090811,-0.137492,0.059807,0.130510) * L0_5 + mat4(-0.249686,-0.484068,-0.003468,0.267867,0.121776,0.561251,-0.203135,-0.225783,0.739797,0.508952,-0.141604,-0.398394,-0.009957,0.654464,0.228118,0.025832) * L0_6 + mat4(0.241977,-0.052576,-0.130931,-0.213218,0.015422,-0.009193,0.007546,0.001694,0.070217,0.051006,-0.078814,0.028529,-0.005401,0.018298,-0.008961,-0.027106) * L0_7 + mat4(0.007114,-0.018083,0.010286,0.029103,0.037609,-0.090929,0.044201,0.072261,-0.046412,0.000555,-0.088634,-0.115684,-0.299846,0.127482,0.073120,0.057425) * L0_8 + mat4(0.107025,0.277564,-0.368582,-0.088087,-0.006698,0.022799,-0.010643,-0.030237,-0.457671,-0.520875,-0.233885,0.329228,-0.063563,0.772252,0.303820,0.183228) * L0_9 + mat4(0.003806,-0.017472,0.009053,0.026248,-0.300187,-0.269435,0.133488,0.073568,0.007366,-0.035284,0.012850,0.036305,-0.020810,0.661047,0.316281,-0.839882) * L0_10 + mat4(1.384150,1.556086,0.926889,-1.434679,-0.017229,0.154434,0.005885,0.030620,0.004222,-0.017599,0.009075,0.026313,0.008518,-0.027144,0.011226,0.032844) * L0_11 + mat4(-0.063902,-0.000252,0.113077,-0.059628,-0.166869,0.011907,-0.036560,-0.032552,0.008184,-0.022771,0.010857,0.031325,-0.025678,-0.008332,-0.006814,-0.012210) * L0_12 + mat4(-0.104913,-0.138351,-0.134368,0.204397,0.163697,-0.232821,0.358212,0.057432,0.003903,-0.017853,0.008733,0.025989,0.062470,-0.237658,0.041406,0.087391) * L0_13 + mat4(0.211428,0.558974,0.187348,0.195279,-0.026991,-0.167670,-0.121178,0.192123,0.664253,0.366049,-0.058119,-0.194120,0.022910,-0.172260,-0.330687,0.100252) * L0_14 + mat4(0.051221,0.331151,0.113237,-0.236199,-0.003543,0.018377,0.013539,0.004644,0.166647,-0.091484,0.017172,0.592474,-0.033552,-0.075470,-0.038620,0.001178) * L0_15 + vec4(0.551949,1.402720,0.577353,-0.862106)));\nvec4 L1_9 = sin((mat4(0.072253,-0.155916,0.068630,0.064324,0.013134,-0.187010,0.045880,-0.262149,-0.271008,-0.510342,0.355593,-0.227659,-0.135152,-0.031137,-0.080727,-0.017993) * L0_0 + mat4(-0.023818,0.007864,0.010630,-0.005853,0.137256,-0.313735,-0.023082,-0.618823,-0.361095,-0.384309,0.171434,-0.124975,-0.365737,-0.318144,-0.484060,-0.158583) * L0_1 + mat4(-0.053083,0.101251,0.030682,0.715237,-0.026709,0.006141,0.343989,-0.395627,0.092392,-0.295984,0.461709,0.073421,-0.043104,-0.007662,-0.044481,0.006116) * L0_2 + mat4(0.045655,0.476640,0.133623,0.231570,-0.301222,-0.260105,-0.018477,0.011048,0.753646,0.170640,0.142998,0.135591,-0.982119,0.486947,1.026014,0.590837) * L0_3 + mat4(0.241791,0.153350,-0.271032,0.047589,-0.007007,0.020729,-0.017500,0.033045,0.019941,0.024891,0.027335,-0.007480,0.118199,-0.216901,0.023882,0.155454) * L0_4 + mat4(0.025230,-0.002722,-0.005846,0.007847,-0.035081,-0.002789,-0.028722,0.089879,0.079929,0.010980,-0.108023,0.058526,-0.009971,-0.026706,0.038540,-0.162911) * L0_5 + mat4(-0.022594,-0.224560,0.170169,-0.452734,0.129332,0.188714,-0.256252,0.273684,-0.114635,0.202651,0.053811,0.548989,0.106963,0.188063,0.035821,0.060111) * L0_6 + mat4(-0.135788,-0.296814,-0.225565,0.002724,0.019989,-0.010041,0.000889,0.008870,0.052047,0.125503,-0.006037,-0.006841,-0.006209,0.019389,-0.018111,0.032522) * L0_7 + mat4(0.005246,-0.014993,0.019793,-0.033011,0.020053,-0.008361,0.025519,-0.079483,-0.322091,-0.002619,-0.390789,0.097529,-0.034589,-0.279663,0.421625,-0.106495) * L0_8 + mat4(0.109019,0.122254,-0.121059,0.069095,-0.003037,0.010363,-0.021137,0.033980,0.143581,-0.082509,-0.081969,-0.688447,-0.203325,0.244284,-0.220648,0.083257) * L0_9 + mat4(0.007375,-0.021457,0.017696,-0.032908,-0.330478,-0.110546,0.390838,-0.336700,0.003198,-0.009553,0.022936,-0.039777,-0.428036,-0.204068,0.571433,0.397850) * L0_10 + mat4(-0.847337,-0.860525,-0.818784,-2.402725,-0.029742,-0.238552,0.029290,0.066850,0.006798,-0.021094,0.017677,-0.032865,0.003169,-0.010278,0.022123,-0.035192) * L0_11 + mat4(0.001496,0.070220,-0.027952,0.049922,-0.029858,0.189313,-0.005736,-0.052219,0.003380,-0.010411,0.021742,-0.034209,-0.015930,-0.012722,-0.007511,0.003715) * L0_12 + mat4(0.019524,0.098298,0.082163,-0.065062,-0.030421,-0.029707,-0.027866,-0.180320,0.007065,-0.020683,0.017612,-0.032946,-0.050608,-0.192545,0.060885,-0.207559) * L0_13 + mat4(0.303750,-0.107784,0.124559,0.411480,0.048353,0.114889,-0.285993,0.009976,0.224290,0.220086,-0.407999,0.442572,-0.098089,0.019695,-0.182119,-0.011092) * L0_14 + mat4(0.071089,-0.147492,0.018910,0.094042,-0.005619,0.018270,0.014369,0.001663,0.008957,-0.023580,0.348052,-0.132562,-0.143321,0.011904,0.091762,-0.065637) * L0_15 + vec4(-0.379484,0.282234,0.075205,0.131147)));\nvec4 L1_10 = sin((mat4(0.121924,0.086633,-0.261059,-0.210389,0.195172,0.338770,-0.046503,-0.303006,-0.191741,0.077713,-0.243915,-0.238992,0.051821,-0.070890,0.112154,-0.129087) * L0_0 + mat4(-0.004797,0.001048,-0.027893,-0.007445,0.368673,0.562684,-0.260769,-0.357869,-0.467326,-0.074886,0.056709,0.219046,-0.103287,0.238407,-0.916688,0.082645) * L0_1 + mat4(0.144568,-0.217605,0.376574,0.236934,0.357486,0.378267,-0.233114,0.032043,-0.087289,0.371428,-0.281632,-0.110100,0.048655,0.034482,0.023281,0.004398) * L0_2 + mat4(-0.074428,-0.350800,-0.384415,0.287507,-0.315946,0.096895,-0.126083,0.264313,-0.196320,0.076817,-0.312053,0.224603,0.134949,-0.212570,0.476239,-0.166788) * L0_3 + mat4(-0.111695,-0.070502,0.295673,0.005559,-0.009911,-0.025593,-0.007013,0.016411,0.039783,0.022014,0.000036,-0.008550,-0.065908,0.081178,-0.255684,0.068984) * L0_4 + mat4(0.010286,0.001762,-0.022644,0.000958,-0.067599,-0.077997,0.012182,0.116759,-0.026755,-0.000607,-0.135736,-0.023971,0.090832,0.180334,-0.005090,-0.113001) * L0_5 + mat4(0.154179,0.442483,-0.337767,-0.055407,-0.415423,-0.325010,-0.018618,0.066321,0.060838,-0.445582,0.130642,0.223252,-0.241614,-0.347967,-0.069826,-0.131386) * L0_6 + mat4(-0.151117,-0.099192,0.122594,0.002952,0.036376,0.004511,0.004756,-0.024862,0.002286,0.129387,-0.014901,-0.007873,-0.009612,-0.026334,-0.005626,0.018058) * L0_7 + mat4(0.011073,0.026745,0.002705,-0.024734,0.053487,0.091363,0.010441,-0.049848,-0.273399,-0.178609,-0.228414,-0.505064,0.049015,0.130103,0.077123,-0.073091) * L0_8 + mat4(-0.006234,0.068215,-0.101786,0.036330,-0.011754,-0.030135,0.000233,0.026177,-0.047386,0.416664,-0.332122,-0.344178,-0.161995,0.061958,0.199397,-0.463893) * L0_9 + mat4(0.009653,0.025791,0.007246,-0.016093,-0.399877,0.138729,-0.125614,0.106738,0.018466,0.041036,0.000315,-0.029817,0.011861,-0.525250,-0.408769,-0.492969) * L0_10 + mat4(-0.253519,3.124545,1.064916,2.048577,-0.020911,-0.054287,0.048022,0.144837,0.009540,0.025559,0.006728,-0.017004,0.013568,0.033381,-0.001022,-0.028365) * L0_11 + mat4(0.012032,0.034705,0.025520,-0.028648,-0.075147,-0.189689,0.478078,0.035961,0.012169,0.030331,-0.000636,-0.028396,0.014505,-0.000179,0.017336,0.005730) * L0_12 + mat4(0.136848,0.050359,0.003873,0.046688,0.141622,0.237532,0.000152,-0.117203,0.009470,0.025859,0.006948,-0.016151,0.150664,0.176414,-0.102899,0.025679) * L0_13 + mat4(-0.015651,-0.018543,0.320558,-0.149301,-0.045863,-0.046301,0.129236,0.065013,0.215788,-0.146455,0.233532,-0.249714,0.014693,-0.147492,0.416150,-0.177595) * L0_14 + mat4(-0.058836,-0.230558,-0.127893,0.214122,0.022321,0.002565,-0.027113,-0.000613,-0.634775,0.018998,0.108461,-0.467997,-0.026954,0.016006,0.040291,0.055718) * L0_15 + vec4(-0.285069,-0.192878,0.757357,0.277977)));\nvec4 L1_11 = sin((mat4(0.077150,0.002731,0.197751,-0.053031,0.158283,-0.062867,0.034877,-0.063209,-0.207803,-0.117908,-0.416328,0.298352,-0.208007,0.087721,-0.018309,0.170244) * L0_0 + mat4(-0.002029,0.001524,-0.006739,-0.019614,-0.108109,-0.039228,-0.252494,-0.243211,0.426746,-0.157668,0.131360,0.015353,1.016403,0.050328,1.320395,-0.696897) * L0_1 + mat4(0.253240,0.022287,0.178214,0.292726,-0.010268,-0.032357,-0.018711,-0.052403,0.089896,0.127827,0.156992,0.263137,-0.014936,0.009796,0.000903,-0.045679) * L0_2 + mat4(-0.519644,-0.106020,-0.121289,-0.176973,0.364497,-0.050895,0.129572,0.062922,-0.378591,0.259671,0.319279,-0.266312,0.632495,0.044763,0.018445,-0.779285) * L0_3 + mat4(-0.335227,-0.171780,0.061157,-0.015405,-0.026383,0.001865,-0.020962,0.009480,-0.004832,-0.000143,-0.004185,0.002294,-0.025698,-0.140458,0.147159,0.014309) * L0_4 + mat4(0.013681,0.005387,0.004005,-0.009581,-0.035442,0.001500,-0.056600,0.043869,-0.099746,-0.008379,0.032394,0.076604,0.040108,-0.007723,0.068524,-0.081178) * L0_5 + mat4(-0.091314,-0.047061,-0.102828,-0.192676,-0.239215,0.062037,-0.026690,0.131690,0.218200,0.047437,0.142442,0.401529,-0.157462,-0.141418,-0.288026,-0.116150) * L0_6 + mat4(0.316699,-0.019745,0.261922,-0.125410,0.002659,0.007769,-0.011234,-0.020113,-0.139860,0.038023,-0.047064,0.101904,-0.026467,0.001733,-0.020792,0.008014) * L0_7 + mat4(0.028897,-0.001327,0.019322,-0.007964,0.026096,-0.004172,0.055898,-0.025814,0.149415,-0.097502,-0.195751,0.025565,-0.232179,0.039903,0.078674,-0.089444) * L0_8 + mat4(-0.520306,0.040583,-0.226646,-0.131136,-0.031331,0.001457,-0.019517,0.006968,-0.154178,-0.109093,-0.222527,-0.342231,-0.182250,-0.012389,-0.164425,0.157468) * L0_9 + mat4(0.026280,-0.001760,0.021167,-0.009809,0.154761,-0.214270,-0.102085,0.073688,0.032512,-0.002361,0.024315,-0.008612,0.532380,-0.262712,-0.676638,0.365968) * L0_10 + mat4(-1.169889,-3.359652,-2.807212,0.171563,0.055967,0.047219,-0.142254,0.081519,0.026510,-0.001745,0.021049,-0.009833,0.031479,-0.001515,0.020657,-0.006730) * L0_11 + mat4(-0.148113,0.016257,0.087402,0.165069,-0.161603,0.058098,0.109579,0.020508,0.031716,-0.001213,0.019432,-0.006940,-0.010336,-0.009439,0.004130,-0.030075) * L0_12 + mat4(0.082065,0.059033,-0.035821,-0.056179,0.282106,-0.021212,0.275581,0.038799,0.026684,-0.001848,0.021081,-0.009497,0.025672,-0.027465,0.038500,-0.096832) * L0_13 + mat4(-0.091545,-0.229556,-0.069430,-0.090686,0.235519,0.012118,0.147091,-0.045072,-0.005958,0.054185,0.007117,0.176032,-0.235412,0.070320,0.027620,0.121933) * L0_14 + mat4(0.189214,0.079849,-0.170412,0.012201,-0.011257,-0.003736,-0.000649,-0.001184,0.575415,-0.057453,-0.285812,0.034791,0.044065,-0.009408,0.039431,0.045638) * L0_15 + vec4(-0.411265,-0.279259,-0.832251,0.372173)));\nvec4 L1_12 = sin((mat4(-0.337156,0.528591,-0.237957,-0.252584,-0.130101,0.267681,-0.236609,-0.129247,-0.246726,-0.329086,0.260363,-0.069154,0.041486,0.217545,0.095548,-0.026482) * L0_0 + mat4(0.001753,0.011156,-0.008699,0.039209,-0.390731,0.252091,-0.240624,-0.284868,-0.218821,0.330813,-0.230319,-0.369886,-0.870088,-0.340008,0.021538,1.372034) * L0_1 + mat4(0.564100,-0.191626,0.483392,0.378303,-0.330824,0.321416,-0.081011,-0.256730,-0.084046,0.621068,0.082304,-0.303015,-0.054643,-0.027390,0.054265,-0.001842) * L0_2 + mat4(0.039334,-0.132416,-0.092975,-0.054523,0.213165,0.495953,-0.100975,-0.198433,0.050050,0.814623,0.030533,-0.422757,-0.652147,1.200754,0.184742,-0.543957) * L0_3 + mat4(0.259993,-0.325995,0.393614,0.619165,0.006758,-0.034837,0.029726,0.018260,-0.009270,0.051112,0.005388,-0.035287,0.087887,-0.073711,-0.475513,0.539204) * L0_4 + mat4(-0.008023,-0.003294,0.001498,-0.032152,0.050808,-0.106033,0.119405,0.048465,0.064218,0.132336,-0.064332,0.268956,-0.048949,0.216701,-0.136479,-0.120564) * L0_5 + mat4(-0.514561,0.408624,-0.264414,-0.433582,0.185385,-0.191170,0.197088,0.256424,0.470534,-0.183271,0.336931,0.095466,0.511579,-0.449028,-0.034568,0.799797) * L0_6 + mat4(-0.111145,0.619353,-0.258391,-0.058251,-0.009761,0.025726,-0.003817,0.003736,-0.021428,-0.101697,0.068502,-0.185728,0.007135,-0.034146,0.029240,0.017595) * L0_7 + mat4(-0.009597,0.033876,-0.030463,-0.016241,-0.022539,0.103846,-0.098370,-0.062992,-0.334435,-0.082817,-0.123148,0.066164,-0.142152,-0.042077,-0.051021,0.170381) * L0_8 + mat4(0.120271,-0.280912,0.247918,0.107222,0.009919,-0.036390,0.033739,0.018945,-0.507363,0.394388,-0.432636,-0.414588,0.116602,-0.413005,0.425660,0.533478) * L0_9 + mat4(-0.006423,0.034129,-0.029357,-0.019288,-0.211549,0.276114,-0.039550,-0.544629,-0.010880,0.043500,-0.041529,-0.023528,0.630915,-0.203071,-0.385168,-0.995191) * L0_10 + mat4(2.800735,-2.498921,-2.801781,0.836995,0.077918,0.163921,-0.105270,0.118033,-0.006704,0.034059,-0.029357,-0.017842,-0.010626,0.038216,-0.035087,-0.020513) * L0_11 + mat4(0.086655,0.186816,-0.031138,0.253595,-0.099883,-0.494851,0.101353,0.375135,-0.010229,0.036850,-0.033320,-0.018416,-0.002682,-0.012335,0.009474,-0.017978) * L0_12 + mat4(0.059578,-0.019709,-0.094449,-0.028759,-0.161118,0.395540,-0.287936,-0.208048,-0.006528,0.034375,-0.029393,-0.019096,-0.184696,0.286494,-0.313222,-0.181601) * L0_13 + mat4(0.418428,-0.165255,0.336020,0.775628,-0.016749,0.019056,-0.053706,-0.037887,0.420659,-0.216479,0.237483,0.260281,0.153713,0.599638,0.022016,0.067519) * L0_14 + mat4(0.189034,-0.349849,-0.153316,0.123195,-0.000190,0.008655,-0.005488,0.015180,0.526427,-1.230642,-0.274343,0.624500,-0.085318,-0.142088,-0.039831,-0.021174) * L0_15 + vec4(1.056908,-0.797074,-0.015662,1.051477)));\nvec4 L1_13 = sin((mat4(0.458539,-0.355284,0.332383,0.049932,0.187058,0.204771,-0.111107,0.139452,0.618842,-0.013319,-0.294712,-0.471268,-0.162854,0.045372,0.194536,0.027941) * L0_0 + mat4(0.003223,0.000490,0.021502,-0.005004,0.351315,0.249456,-0.503414,-0.170211,0.025913,-0.313520,0.219719,-0.311998,1.350938,-0.585235,-1.684183,1.058186) * L0_1 + mat4(0.404262,-0.282137,0.392597,0.385999,0.213657,0.001791,-0.139918,-0.111713,0.030441,-0.290349,0.102003,0.406145,0.014561,-0.014621,-0.068726,-0.021460) * L0_2 + mat4(0.329788,-0.059061,-0.873598,-0.139924,0.440548,-0.424008,0.303321,-0.310639,-0.058753,-0.320620,0.025958,0.323368,1.203416,-0.819997,0.539301,0.136644) * L0_3 + mat4(0.119701,0.118032,0.259848,0.441995,-0.005735,-0.007332,0.004326,-0.005967,-0.001799,-0.000818,-0.017192,-0.022560,-0.022892,-0.141660,-0.415998,0.074627) * L0_4 + mat4(-0.030426,-0.004565,-0.002865,-0.001162,-0.011194,-0.012524,0.019123,-0.036931,0.038610,0.015549,0.069045,0.010555,0.114060,0.070003,-0.085548,0.038505) * L0_5 + mat4(0.054461,0.048697,-0.223581,-0.425652,0.078618,0.061013,0.135010,0.124697,0.190998,-0.219447,0.453135,0.420289,0.048732,0.151495,0.000702,0.121864) * L0_6 + mat4(0.305292,-0.244963,0.313182,0.016208,0.020082,0.012212,-0.018698,0.008670,0.421431,-0.084012,-0.122313,-0.188918,-0.008443,-0.007539,0.004457,-0.006556) * L0_7 + mat4(0.013741,0.006789,-0.005127,0.008212,-0.010793,0.013726,-0.032364,0.012111,-0.029319,-0.038298,0.094109,-0.194467,-0.090095,0.057205,0.101160,0.065704) * L0_8 + mat4(0.072594,0.218584,0.003636,0.167653,-0.014518,-0.008483,0.009638,-0.007048,-0.070558,0.091346,-0.067269,-0.243322,0.033751,-0.012755,0.077625,0.419213) * L0_9 + mat4(0.005858,0.007708,-0.004296,0.006149,-0.005899,-0.092920,-0.039326,-0.352906,0.005458,0.010642,-0.012897,0.012171,0.614741,0.138069,0.546632,-0.341389) * L0_10 + mat4(-0.779669,-2.769209,-0.963248,2.321473,-0.094489,-0.059688,-0.099580,-0.003219,0.006716,0.007446,-0.003939,0.006410,0.012862,0.009466,-0.010914,0.008979) * L0_11 + mat4(-0.034898,0.084862,0.134656,0.097495,-0.377284,0.148756,0.289997,-0.106582,0.015496,0.008458,-0.009060,0.007853,-0.008295,-0.000113,0.005253,-0.029654) * L0_12 + mat4(0.412580,0.005995,-0.179836,-0.002029,0.030062,-0.205993,0.242762,0.047376,0.006209,0.007793,-0.004301,0.006039,0.086221,0.073003,0.025920,0.004549) * L0_13 + mat4(-0.300620,-0.216462,0.145551,0.025249,-0.103021,-0.022752,0.208107,-0.072012,0.274911,-0.049784,0.018259,0.432893,-0.695685,0.002374,0.218402,-0.217148) * L0_14 + mat4(0.139536,-0.090980,0.041643,0.082638,-0.013377,0.006790,-0.008094,0.005991,-1.055945,0.733135,-0.438030,0.312451,-0.182534,0.024599,0.069464,0.000035) * L0_15 + vec4(0.269801,-0.880268,-0.299202,0.765400)));\nvec4 L1_14 = sin((mat4(0.171566,-0.036387,0.262600,0.372610,-0.100963,0.081330,0.094638,0.234703,0.206710,0.140095,0.268651,-0.229008,0.038118,-0.033214,-0.112205,-0.012861) * L0_0 + mat4(0.003564,-0.009459,0.002424,-0.005400,0.170292,0.271198,0.207510,0.271170,0.290713,-0.460634,-0.601372,-0.230890,-0.156655,-0.607695,0.164938,-0.802401) * L0_1 + mat4(-0.392506,-0.367180,0.122097,0.158967,0.186245,0.050547,-0.027239,0.036945,-0.133813,0.148423,0.365806,0.162991,-0.009661,-0.034782,-0.010339,0.031998) * L0_2 + mat4(0.023924,0.221256,0.033802,-0.108467,-0.000856,-0.411099,-0.432029,-0.339974,0.177211,-0.201611,0.451116,0.391710,-0.523061,0.473660,-0.211325,-1.114704) * L0_3 + mat4(-0.009191,-0.335808,-0.085355,-0.324463,0.009391,-0.009025,0.001121,-0.012531,-0.012390,0.006410,0.013186,0.005309,-0.118406,-0.171214,0.285537,0.196176) * L0_4 + mat4(-0.003705,0.001130,-0.004672,-0.003002,0.025227,-0.010410,0.013669,-0.057201,0.000013,-0.037907,-0.033187,-0.036746,-0.056249,0.052322,0.026271,0.108207) * L0_5 + mat4(0.254650,0.245296,-0.029099,0.153250,-0.102412,0.017818,0.073639,-0.007296,-0.332991,-0.396306,-0.040702,0.080499,-0.318194,0.192330,0.201496,0.005824) * L0_6 + mat4(0.129627,-0.156043,-0.303847,0.052995,0.000388,0.004228,-0.007662,0.005728,-0.038197,0.057255,0.165248,0.105334,0.009351,-0.009387,0.001379,-0.013364) * L0_7 + mat4(-0.008562,0.008587,-0.000789,0.016514,-0.037205,0.008989,-0.011838,0.023381,0.236748,0.054748,0.187879,0.138552,-0.057235,0.077853,-0.095227,0.082689) * L0_8 + mat4(-0.214181,0.267568,0.434320,0.065780,0.010512,-0.008847,0.001157,-0.017788,0.158215,0.119847,0.095180,-0.138958,-0.224728,-0.284964,-0.235412,-0.199198) * L0_9 + mat4(-0.009514,0.009300,-0.001297,0.012813,0.359749,-0.149557,-0.418479,-0.335461,-0.016276,0.009337,-0.004367,0.020698,-0.500941,0.695931,-1.684075,0.098664) * L0_10 + mat4(3.278734,2.102475,1.476909,0.915738,-0.076545,0.014595,0.043430,-0.059976,-0.009317,0.009455,-0.001086,0.013205,-0.012247,0.009339,-0.002530,0.019252) * L0_11 + mat4(0.030689,-0.072092,-0.125004,-0.071145,-0.059520,-0.085495,-0.371633,0.173858,-0.010339,0.008826,-0.001502,0.018477,-0.001715,-0.014265,0.012401,-0.006614) * L0_12 + mat4(0.083570,0.120112,0.052065,0.015465,-0.065347,-0.183257,-0.206191,-0.028215,-0.009641,0.009215,-0.001056,0.012546,-0.026657,0.093443,0.052109,0.112524) * L0_13 + mat4(-0.248594,-0.026591,0.324825,0.188105,0.037663,-0.020629,-0.074145,0.177284,-0.339799,-0.321851,0.270837,0.128654,0.114419,-0.119878,0.350823,0.198651) * L0_14 + mat4(0.078788,-0.168677,-0.156488,-0.030438,-0.000478,-0.006517,-0.003553,0.031363,0.145261,0.087374,-0.181115,-0.551194,-0.041106,-0.031427,-0.057331,-0.020453) * L0_15 + vec4(0.035728,0.314999,0.044959,0.052725)));\nvec4 L1_15 = sin((mat4(-0.325932,0.365992,-0.450477,-0.027328,0.085152,-0.044197,-0.060099,0.063101,-0.009929,-0.099057,-0.035651,-0.385198,0.087015,-0.253143,-0.322231,-0.064229) * L0_0 + mat4(0.004948,-0.016610,-0.018680,0.002719,-0.093427,0.259453,-0.541042,0.013958,0.585260,-0.679541,0.123252,0.462972,-1.270008,0.426420,0.686279,1.131736) * L0_1 + mat4(0.354767,0.067718,0.600394,0.122343,0.127654,0.041613,-0.349972,0.230245,0.142959,0.239036,-0.462125,-0.139745,0.083919,-0.034268,0.001326,-0.089808) * L0_2 + mat4(-0.555918,-0.617546,0.337082,-0.111021,0.302851,-0.525494,0.060453,0.170512,0.306727,0.271351,-0.365844,0.106083,0.106371,0.045388,-0.771160,-1.278132) * L0_3 + mat4(-0.063387,-0.027363,-0.029932,-0.342231,-0.004862,0.010909,0.004354,-0.015211,0.014953,0.016262,0.015554,0.024205,-0.034986,0.447140,0.320480,-0.064987) * L0_4 + mat4(-0.005320,-0.006041,0.002057,0.005322,-0.008262,-0.005025,0.026353,-0.061577,-0.080507,0.010756,-0.109705,-0.035620,0.028949,-0.050626,-0.056837,0.088029) * L0_5 + mat4(-0.040025,-0.308635,-0.552631,0.251465,-0.238532,0.082356,0.265546,-0.287207,0.112521,0.086925,0.558549,0.158535,-0.203424,-0.028984,0.201020,-0.167092) * L0_6 + mat4(0.133628,0.243712,-0.011896,0.240016,0.018031,0.027985,-0.033932,0.018996,0.255694,-0.247377,0.093611,-0.017507,-0.004153,0.010426,0.003854,-0.014873) * L0_7 + mat4(0.005585,-0.011212,-0.004130,0.015164,0.016354,-0.009365,-0.015864,0.056295,-0.233365,-0.059492,0.045729,-0.303323,0.014071,0.105663,-0.348162,-0.069683) * L0_8 + mat4(-0.309714,0.295515,-0.184572,-0.373701,-0.004745,0.011061,0.007235,-0.015764,-0.233190,-0.098800,-0.696978,-0.145337,-0.161552,0.164056,-0.023159,-0.166362) * L0_9 + mat4(0.005105,-0.010501,-0.004400,0.015316,0.499905,-0.704765,-0.079176,0.255149,0.002317,-0.012503,-0.002448,0.020464,0.365606,0.014411,-1.299029,-0.448849) * L0_10 + mat4(-1.662151,1.837390,-0.129439,-1.424389,0.226899,-0.172721,0.161971,0.019925,0.004808,-0.010891,-0.003702,0.014877,0.003413,-0.010831,-0.007418,0.016887) * L0_11 + mat4(-0.118899,0.029633,-0.284228,0.082755,-0.134043,-0.015622,0.550442,0.047119,0.004545,-0.010830,-0.006867,0.015837,-0.000958,-0.001488,0.010340,-0.014418) * L0_12 + mat4(0.080862,0.024723,0.066468,0.074074,0.240646,-0.219644,0.116357,0.304789,0.004873,-0.010383,-0.004741,0.014996,0.035550,-0.046977,-0.174632,0.131451) * L0_13 + mat4(-0.189690,-0.188481,-0.162583,-0.303223,-0.217033,-0.117177,0.437150,-0.004821,-0.082685,0.313246,0.301290,-0.131505,0.208546,0.140913,0.149085,-0.586588) * L0_14 + mat4(0.235093,-0.249683,-0.160624,0.058441,-0.001295,0.021526,0.000659,0.022206,0.379018,0.107367,0.497211,-0.363661,0.124786,-0.173246,0.226005,-0.029355) * L0_15 + vec4(-0.467347,0.228130,-0.053512,-0.646791)));\nvec4 L2_0 = sin((mat4(0.104922,-0.027519,-0.224573,-0.015465,0.667901,-0.504599,-0.057951,0.259052,-0.171781,0.031017,-0.165212,0.142089,-0.561398,0.145027,-0.025992,-0.069561) * L1_0 + mat4(0.163107,-0.175838,0.019203,0.017202,0.054372,-0.015564,-0.163455,-0.022338,0.493305,-0.169162,0.305395,0.130814,0.103894,0.086006,0.789065,-0.089324) * L1_1 + mat4(-0.184085,-0.206410,0.038554,0.118022,-0.393308,-0.167883,-0.940022,0.417973,0.366152,0.034383,0.119946,-0.000399,-0.150461,0.002234,0.125515,0.024744) * L1_2 + mat4(0.022403,0.225125,-0.037151,-0.029781,0.027108,0.056193,-0.096344,-0.055512,-0.028325,0.261725,-0.221123,-0.138872,0.201749,0.396740,0.229968,0.100351) * L1_3 + mat4(0.125708,-0.216865,0.175427,-0.002316,0.012343,-0.010490,0.013852,0.124668,-0.165662,-0.349726,0.293759,0.151426,-0.390995,0.062469,-0.101176,-0.041640) * L1_4 + mat4(-0.225378,0.128507,-0.206877,-0.111986,0.729497,-0.021880,-0.306342,0.058861,-0.054423,0.023774,0.059639,-0.025168,0.069240,-0.014156,0.259138,0.164618) * L1_5 + mat4(0.475578,0.195361,0.366637,-0.079672,0.230449,-0.023783,0.087643,-0.106995,0.467618,-0.235921,0.099589,0.238385,0.213325,0.092591,0.092953,-0.203160) * L1_6 + mat4(0.310014,-0.916402,-0.865084,0.810547,0.574840,-0.291261,0.212868,-0.105405,0.563964,-0.251544,0.051156,0.002480,0.201026,-0.044605,0.226207,0.019603) * L1_7 + mat4(0.205064,-0.370822,-0.518919,-0.108494,0.003547,-0.058381,0.176612,-0.004024,0.276955,-0.210512,-0.067110,0.050075,0.879614,-0.115843,0.639216,-0.103740) * L1_8 + mat4(0.141999,-0.401456,0.180463,0.195822,-0.256063,-0.279067,-0.144791,0.151478,0.253653,0.120040,0.326057,-0.093819,-0.450192,-0.412598,-0.245653,0.181682) * L1_9 + mat4(0.501085,0.314059,0.079716,-0.419373,-0.240356,0.185236,0.046508,0.147244,-0.353326,-0.309472,-0.084002,0.069290,0.458583,0.447664,-0.259751,-0.235233) * L1_10 + mat4(0.337449,0.233441,0.283279,0.041915,-0.409785,0.320150,-1.399712,-0.558856,0.240435,-0.484389,0.662717,0.168025,-0.352875,-0.211759,-0.408088,0.245492) * L1_11 + mat4(0.432695,-0.069675,0.361147,-0.144474,-0.198369,0.084250,-0.001951,-0.131698,-0.417324,-0.132278,0.034536,0.045053,0.081048,0.300150,-0.146889,-0.031323) * L1_12 + mat4(0.197930,-0.083857,0.107384,0.070473,0.175805,-0.346892,0.575386,0.002364,0.100485,-0.104401,-0.009690,-0.036131,-0.887979,0.202857,-0.065973,-0.049526) * L1_13 + mat4(0.769167,0.355992,0.091424,0.496711,-0.061424,0.225656,0.619844,-0.018523,-0.387421,-0.070287,-0.209810,-0.170864,0.087229,0.226959,0.258375,-0.310151) * L1_14 + mat4(0.172714,0.387597,-0.085439,-0.032233,0.357817,-0.089448,-0.135163,-0.074702,-0.297410,-0.116722,-0.039221,0.096194,-0.303509,0.254909,0.232679,0.136711) * L1_15 + vec4(-0.218764,-0.437516,0.797542,-0.162262)));\nvec4 L2_1 = sin((mat4(0.302836,-0.011816,-0.028205,-0.107226,0.096496,-0.053959,0.619634,-0.206559,0.224620,-0.071686,-0.425156,-0.088105,-0.128698,-0.190760,0.142738,-0.611620) * L1_0 + mat4(-0.028121,-0.053918,0.396272,-0.064589,0.263247,0.035035,0.154820,0.168880,0.292725,-0.476098,-0.378790,-0.418576,-0.304536,0.351762,0.277464,0.326383) * L1_1 + mat4(0.867297,0.068647,-1.064721,0.000769,-1.541374,1.065888,0.942185,0.353954,-0.203596,-0.441962,-0.022131,-0.135387,0.449813,-0.089963,-1.133798,0.336148) * L1_2 + mat4(-0.109908,-0.112268,0.072491,-0.101640,0.022543,0.053153,-0.039643,-0.386212,-0.304864,0.144667,-0.296845,-0.089718,-0.577904,-0.042310,-0.521894,0.036378) * L1_3 + mat4(0.320419,-0.278041,-0.216960,0.146190,-0.146715,0.036712,-0.376818,-0.250014,0.250306,-0.179478,-0.756525,0.293730,-0.242695,-0.066030,-0.013096,-0.249529) * L1_4 + mat4(0.563061,-0.190252,0.774459,-0.008215,0.377433,-0.100736,0.469797,0.344575,0.165220,-0.060825,-0.271779,-0.143555,0.738688,-0.363270,-1.018710,0.123372) * L1_5 + mat4(-0.247632,-0.094374,-0.380244,0.020440,-0.038932,0.274470,0.586839,0.188150,0.031371,0.222087,0.130728,0.193015,-0.795990,0.032730,-0.102774,-0.785857) * L1_6 + mat4(-0.372272,0.116300,1.182081,-0.611538,-0.103556,-0.206925,-0.361618,-0.062449,-0.061294,0.040604,0.050324,-0.263960,0.195426,0.040925,-0.600743,0.379354) * L1_7 + mat4(-0.533825,0.338220,0.983857,-0.202336,-0.062455,0.156542,-0.989796,-0.087648,0.222421,0.196756,-0.412016,-0.394391,-0.135891,-0.140705,-0.747982,-0.485560) * L1_8 + mat4(-0.098914,-0.198461,0.212665,0.324186,0.279930,0.221287,0.486855,0.183049,-0.307859,0.165573,-0.020433,0.160004,0.322467,0.102207,0.228500,0.203945) * L1_9 + mat4(-1.058645,0.047330,-0.469685,-0.400089,-0.431458,0.061869,0.520888,-0.431553,0.559554,0.073334,0.180944,0.304794,-0.457806,0.351703,0.676330,0.094295) * L1_10 + mat4(0.149621,-0.010216,-0.402720,0.043466,0.317042,0.450067,-0.099602,-0.792034,0.818439,-0.825589,-0.820703,-0.588471,0.438345,-0.075018,0.032476,-0.063828) * L1_11 + mat4(0.278003,-0.298291,-0.026815,0.094345,-0.067188,-0.034861,0.343218,-0.226015,0.452832,0.069527,0.455655,-0.321309,-0.297742,-0.159302,0.329831,0.006160) * L1_12 + mat4(-0.348469,-0.016525,0.340093,0.114679,0.635538,-0.268814,-0.161145,1.284855,-0.466880,0.133006,0.229476,0.049589,0.300818,-0.217248,-0.358978,0.160311) * L1_13 + mat4(-1.192909,-0.004530,1.075559,0.204647,0.183296,-0.242634,-0.233358,-0.007205,-0.151373,0.409815,-0.389498,-0.337515,-0.197246,-0.015477,-0.288285,-0.433882) * L1_14 + mat4(-0.161783,0.184577,-0.002405,-0.087742,0.237775,0.126889,0.221750,0.106342,0.061946,-0.117574,0.307765,0.302472,0.062447,-0.482129,0.073113,-0.467105) * L1_15 + vec4(1.351771,-0.686487,-0.530075,0.808211)));\nvec4 L2_2 = sin((mat4(-0.048348,-0.087299,0.060209,-0.032735,-0.067616,-0.668063,0.215040,-0.465675,0.090036,0.036884,0.004513,-0.319359,0.124355,-0.109375,-0.030665,0.189739) * L1_0 + mat4(0.040180,0.421593,0.363270,-0.442899,-0.117602,-0.051435,0.188090,0.541402,-0.095807,0.533011,0.121405,0.333201,-0.032864,-0.494163,-0.213113,-0.084126) * L1_1 + mat4(0.020900,-0.029896,-0.242860,-0.228102,-0.629568,-1.352556,0.760634,-1.568805,0.317161,-0.508363,0.221437,0.262802,0.131418,1.089809,-0.437073,0.966326) * L1_2 + mat4(0.063830,0.122716,-0.022853,-0.078995,0.243117,0.007106,0.027320,-0.024864,-0.200887,-0.426937,-0.055392,0.147247,0.117529,-0.451814,0.240221,0.297474) * L1_3 + mat4(0.317880,0.217666,-0.165370,0.688464,-0.108607,0.181596,-0.015245,0.028581,0.241635,-0.303576,-0.078278,0.429628,-0.076182,-0.262869,-0.064986,0.008712) * L1_4 + mat4(0.463026,-0.432971,0.504934,-0.139193,0.498391,0.439618,0.090269,0.348378,-0.017341,-0.039379,-0.042066,0.044258,0.935493,0.214287,0.077611,0.975433) * L1_5 + mat4(0.239566,0.143270,-0.090306,-0.012740,-0.124451,0.178959,-0.049734,-0.614700,0.468567,0.274633,-0.163000,-0.200601,-0.521201,-0.846256,0.106225,-0.390215) * L1_6 + mat4(-0.351012,-0.285696,-0.206937,-0.218880,-0.089034,0.167347,0.009351,0.348850,0.150043,0.576939,0.093537,-0.091475,-0.331893,0.277845,-0.031855,-0.081840) * L1_7 + mat4(-0.233654,-0.438388,0.396112,-0.666744,-0.157114,0.396492,-0.034825,0.070852,-0.363697,-0.044629,-0.366290,-0.066625,0.638031,0.548446,0.200522,0.416061) * L1_8 + mat4(0.001994,0.249693,0.190172,-0.018675,0.239510,-0.293937,0.190401,0.127016,0.124217,0.060471,-0.250415,-0.047668,-0.075523,-0.718362,0.043317,0.554080) * L1_9 + mat4(-0.702631,-0.486401,0.069182,-0.766132,-0.570368,0.237662,-0.136735,0.126354,-0.102963,0.565208,0.038607,0.577371,0.146781,-0.250700,0.369827,-0.236869) * L1_10 + mat4(-0.132304,0.145516,-0.068402,0.210380,0.161443,0.290537,0.132849,-0.780778,0.347457,0.749771,-0.229184,1.321056,-0.223556,0.458092,0.037346,0.163663) * L1_11 + mat4(-0.266270,0.085363,-0.538809,0.720871,0.154951,-0.080770,-0.077843,0.041387,0.049751,0.137896,-0.126582,-0.140115,-0.083357,0.060303,0.277371,0.432922) * L1_12 + mat4(0.005819,-0.207329,0.157600,-0.257023,0.293990,0.137064,-0.094871,0.213092,-0.194269,0.018464,-0.033517,0.126406,-0.106827,0.158326,0.463968,-0.248046) * L1_13 + mat4(-1.100701,-0.111216,0.679574,-0.307026,-0.321108,0.151251,-0.078092,-0.334532,-0.358832,-0.290962,0.227885,-0.434151,-0.198757,-0.060095,0.061131,0.011300) * L1_14 + mat4(0.167593,-0.069553,-0.004329,-0.276774,0.247171,-0.058070,0.166651,-0.146346,-0.226059,-0.147758,0.197303,-0.116166,-0.158459,0.154959,-0.105636,0.312941) * L1_15 + vec4(0.534832,0.509610,-0.003464,1.048331)));\nvec4 L2_3 = sin((mat4(0.010645,0.165316,-0.180236,-0.005793,-0.021039,-0.001671,-0.312630,0.334658,-0.193986,-0.140130,-0.014653,0.224936,0.226248,-0.222757,0.111100,-0.079074) * L1_0 + mat4(-0.015467,-0.063447,0.108570,0.068505,-0.245965,-0.075508,0.204103,0.001563,-0.054112,-0.246197,0.234889,0.155688,-0.661656,-0.192850,-0.169349,-0.330425) * L1_1 + mat4(0.333914,-0.103856,0.089572,0.042923,0.064334,0.760569,0.081313,0.206063,-0.072956,0.122317,0.408910,0.265170,-0.435938,-0.029484,-0.491478,-0.097975) * L1_2 + mat4(-0.482260,0.081970,-0.182330,-0.123116,0.161953,-0.058270,0.050212,-0.155407,-0.051566,-0.105142,-0.142179,0.337067,-0.474049,0.055774,-0.089716,0.420464) * L1_3 + mat4(0.129310,-0.186241,0.063684,-0.249841,-0.104239,0.462995,-0.031293,-0.328105,0.752707,-0.158299,-0.137218,0.188111,-0.017329,0.207538,0.064284,0.256703) * L1_4 + mat4(0.647432,0.107312,0.025322,-0.262687,0.275606,-0.285311,0.208078,0.218276,-0.126302,0.132255,0.100538,0.027151,0.531509,0.294267,-0.097002,0.359763) * L1_5 + mat4(-0.229795,-0.027033,-0.581659,0.070453,0.008944,-0.086226,-0.185134,-0.155946,0.225028,0.449518,-0.121073,-0.372305,-0.827149,-0.099184,-0.470004,0.170224) * L1_6 + mat4(-0.583366,-0.021835,-0.145778,0.275898,-0.597310,0.104241,0.160237,0.291579,-0.663522,0.077221,-0.048765,0.200550,-0.134943,-0.254946,0.088433,0.167394) * L1_7 + mat4(0.013682,-0.327320,0.061074,0.135930,-0.382303,-0.205392,0.062841,0.318253,-0.023199,0.107535,0.152292,-0.046912,-0.168853,0.040599,0.335165,0.084635) * L1_8 + mat4(0.005221,0.172182,0.223786,0.059422,0.762626,-0.344325,0.001733,-0.501171,0.260354,0.429672,0.069229,-0.189596,0.785672,-0.082574,0.259308,-0.430761) * L1_9 + mat4(-0.685171,-0.582831,0.332594,-0.266860,-0.397826,0.375176,-0.032398,0.281555,0.169511,-0.088395,-0.257205,-0.073734,-0.310314,0.196261,0.239140,-0.199421) * L1_10 + mat4(-0.008698,-0.051662,0.097022,-0.343489,-0.666251,-0.333721,-0.192168,-0.953042,0.164152,-0.370533,0.034319,0.111745,0.664919,-0.003504,-0.274734,-0.064401) * L1_11 + mat4(-0.570739,0.014774,-0.179385,0.254930,0.091656,0.094124,0.032201,-0.045076,0.090780,-0.159915,0.007732,-0.312044,-0.210380,-0.085598,-0.033215,-0.128973) * L1_12 + mat4(0.096438,0.068130,0.063131,0.024087,0.741006,-0.482679,-0.043069,0.279448,-0.436760,0.197020,-0.169714,0.113959,0.328480,-0.898276,-0.343395,0.188125) * L1_13 + mat4(-0.485589,1.922711,0.051505,1.114830,0.080846,-0.008248,0.007195,-0.102613,0.234517,0.162395,0.061331,0.199373,-0.277939,-0.021388,0.189704,-0.301049) * L1_14 + mat4(-0.553776,0.278178,-0.404326,-0.490771,0.256775,0.013197,0.291475,-0.605617,0.255690,0.129677,0.086776,0.116263,-0.031879,-0.205943,0.111949,0.697859) * L1_15 + vec4(0.944662,0.083756,-0.170618,0.067500)));\nvec4 L2_4 = sin((mat4(-0.485023,0.172509,-0.118188,0.163083,-0.353019,0.008665,0.421634,0.089226,0.101707,0.315887,0.160077,0.096386,0.102458,-0.132010,0.058134,-0.436657) * L1_0 + mat4(0.273622,-0.078783,-0.135600,0.056964,-0.036485,0.335649,0.058700,-0.467793,-0.162195,-0.118527,0.060708,-0.262060,-0.079979,-0.321206,0.134373,-0.644970) * L1_1 + mat4(0.672193,-0.407481,0.447488,0.095288,0.905035,1.443233,-0.039715,-0.222009,0.200376,0.326087,-0.045721,0.248665,-0.387297,-0.814217,-0.591743,-0.007384) * L1_2 + mat4(0.056196,0.100684,0.048789,-0.085996,-0.183493,0.028884,0.178799,0.125031,-0.383713,-0.040066,0.263115,0.190199,-0.867595,-0.284408,-0.012655,-0.034063) * L1_3 + mat4(-0.060428,-0.132013,-0.240832,0.102345,0.040139,-0.541817,0.120039,0.149158,-0.663481,-0.230255,-0.758911,0.228589,-0.091389,0.412313,-0.337363,-0.081048) * L1_4 + mat4(0.047196,-0.468902,0.224117,-0.163385,0.226561,0.689071,-0.678767,0.252374,0.116977,-0.136644,0.009209,-0.008945,-0.403523,-0.611179,0.134512,-0.037969) * L1_5 + mat4(-0.777237,-0.310256,-0.078523,-0.228468,-0.452818,0.386743,0.029389,0.431596,0.386308,-0.013316,0.065796,-0.082665,-0.725912,-0.075795,0.253630,-0.196498) * L1_6 + mat4(0.885684,0.201225,-0.080691,-0.532531,-0.238982,-0.019274,0.235786,0.087370,0.242290,-0.179492,0.082384,-0.140079,-0.298274,0.017747,0.590854,0.387761) * L1_7 + mat4(0.370061,0.430679,0.066822,-0.129816,-0.188976,0.107581,0.288261,0.012250,0.535161,0.322509,-0.246395,0.186838,0.037321,0.402206,-0.261849,-0.243231) * L1_8 + mat4(0.518322,-0.191554,0.255933,0.046565,0.447534,-0.043917,-0.328273,0.301096,-0.314229,0.312012,0.253337,0.034914,0.777469,-0.786912,-0.102177,0.175784) * L1_9 + mat4(-0.234841,0.011332,0.147645,0.522006,0.300616,0.579223,-0.081809,-0.116113,-0.242671,-0.496743,-0.072115,-0.204644,0.137860,0.274818,0.512185,0.033115) * L1_10 + mat4(-0.507901,-0.156046,-0.100349,-0.073248,1.625523,-0.083212,-0.662347,-0.778983,0.028580,-0.250156,-0.103618,-0.105794,0.234950,0.059245,0.296370,-0.034235) * L1_11 + mat4(-0.362476,-0.039206,-0.197291,0.296405,-0.139313,0.185299,-0.011954,0.082102,0.625011,-0.003145,-0.340903,-0.392425,-0.375991,0.150712,-0.167272,-0.068066) * L1_12 + mat4(-0.147405,0.140983,-0.135998,0.177136,-0.537657,-0.291222,1.101845,0.443395,0.367359,0.118227,0.186018,-0.186149,-0.682684,-0.100452,0.559251,-0.120185) * L1_13 + mat4(-0.699197,0.215226,0.498675,0.235891,-0.685287,-0.211606,1.058925,-0.068954,0.417129,0.349179,0.066605,-0.290683,-0.310555,-0.113636,0.197963,-0.129727) * L1_14 + mat4(0.106556,0.025449,0.032096,-0.178787,0.091321,-0.004841,0.276510,0.074612,0.401467,-0.004282,-0.046803,0.165533,0.153115,0.239023,0.050599,0.004833) * L1_15 + vec4(-0.830459,0.150265,-0.251387,-0.193338)));\nvec4 L2_5 = sin((mat4(-0.058417,0.038356,0.064924,-0.037306,0.123450,-0.527362,-0.367758,-0.220087,-0.062816,-0.054240,0.422239,-0.129067,-0.244041,0.061371,-0.304434,0.279332) * L1_0 + mat4(-0.026725,0.150589,-0.204616,-0.157734,0.110219,-0.086520,0.269655,0.024456,0.141597,0.173966,-0.125883,-0.662086,-0.132541,-0.306880,-0.842905,0.189360) * L1_1 + mat4(-0.293219,0.029579,0.247031,-0.013594,-0.139386,-0.622145,-0.823330,0.098797,-0.172541,0.414897,0.060013,0.288655,-0.078805,0.170440,0.159259,0.719143) * L1_2 + mat4(0.056538,0.101189,0.049291,-0.069242,0.119525,0.104819,0.154686,-0.194997,-0.031309,-0.581946,0.116945,0.652321,0.016208,-0.042165,-0.030824,0.071942) * L1_3 + mat4(0.177271,0.085958,-0.117095,-0.024760,0.426381,0.500491,0.443191,0.066144,-0.005686,-0.175753,-0.343080,0.282565,0.065180,-0.224713,0.257182,0.310080) * L1_4 + mat4(-0.214816,-0.523860,-0.071472,-0.602233,-0.001863,-0.360967,0.112849,0.049862,0.028499,0.073719,0.015393,-0.051622,0.107197,0.162387,-0.662501,0.838914) * L1_5 + mat4(0.088438,-0.084759,-0.359581,0.212006,0.094691,-0.388530,0.158279,0.266646,-0.067577,-0.098051,-0.180043,0.159455,0.051588,-0.137978,0.039147,0.301166) * L1_6 + mat4(0.279991,-0.137578,0.561122,-0.087229,0.266527,0.377821,0.252667,-0.217710,0.131810,-0.506171,0.079416,-0.196046,-0.131638,0.061935,-0.346106,-0.117404) * L1_7 + mat4(-0.243595,0.058135,0.367237,-0.633081,0.139244,0.246403,0.028504,-0.200570,-0.039309,-0.239038,-0.104111,-0.406304,-0.124890,0.692830,-0.600764,-0.693000) * L1_8 + mat4(-0.132017,0.086092,0.051935,-0.401896,0.081114,-0.002548,0.028942,-0.163384,-0.024708,-0.097220,-0.188168,0.219062,-0.112389,-1.019868,-0.055611,0.293195) * L1_9 + mat4(-0.545008,0.208341,-0.028763,-0.006444,0.247115,-0.393030,-0.053227,0.361652,0.177680,0.249289,0.012975,-0.320285,0.019730,0.406027,0.487745,-0.272694) * L1_10 + mat4(0.304288,-0.016452,-0.043480,-0.305103,-0.867079,1.063777,0.591210,-0.088085,0.206918,0.657967,0.120148,-0.224146,0.030230,0.292123,0.154664,-0.300492) * L1_11 + mat4(0.135323,0.099437,0.368048,0.618789,0.182578,-0.013858,0.102974,-0.009491,-0.269905,-0.655874,0.184314,-0.180482,0.070387,0.116239,0.106572,0.344657) * L1_12 + mat4(0.073869,0.038835,0.121657,-0.088737,-0.151881,-0.725584,0.268883,0.196329,0.184343,-0.185594,-0.077193,0.291567,-0.189062,-0.202800,0.263167,0.100415) * L1_13 + mat4(0.759722,0.616772,0.088463,0.099277,-0.122224,-0.121547,0.334614,-0.527642,-0.282265,0.318876,-0.016685,0.317273,-0.039388,0.200416,0.215053,-0.172606) * L1_14 + mat4(0.237006,-0.004800,0.177446,0.191688,0.003200,-0.138846,0.176141,-0.263777,-0.011636,-0.277925,0.193685,-0.163172,0.149607,0.116509,-0.101942,-0.074563) * L1_15 + vec4(0.381593,-0.184609,-1.017992,-0.067598)));\nvec4 L2_6 = sin((mat4(-0.072025,-0.123739,0.026333,0.067553,0.440336,0.347946,-0.387672,0.192364,0.035260,-0.165529,0.119553,-0.365182,0.033654,0.448943,-0.249869,0.065507) * L1_0 + mat4(-0.130542,-0.122093,-0.294735,-0.092351,-0.524160,0.142814,0.035422,-0.152704,-0.028781,-0.107499,0.237822,-0.372885,0.310564,-0.013201,-0.269444,0.223988) * L1_1 + mat4(0.240497,-0.231804,0.226341,-0.114755,-1.080456,0.211307,-0.203019,0.084626,-0.030291,0.049329,0.245199,0.326380,0.227295,-0.195915,0.527278,0.409721) * L1_2 + mat4(0.077798,-0.063882,-0.061485,0.118188,0.057440,-0.019679,0.021662,-0.076120,-0.051383,-0.245913,-0.098636,0.087267,-0.202052,-0.142720,0.190959,-0.029167) * L1_3 + mat4(0.226839,0.021587,0.323500,-0.060427,-0.128556,-0.156845,0.446470,-0.220798,0.385660,0.025597,0.618652,-0.498169,-0.001024,0.048830,-0.428962,-0.045196) * L1_4 + mat4(0.339127,-0.139750,-0.291765,0.008933,-0.141134,-0.303913,0.393737,0.163069,0.131302,0.097581,0.028989,0.090731,0.412537,-0.515985,0.516361,-0.442349) * L1_5 + mat4(0.176279,0.048664,-0.093173,0.314923,0.023266,-0.172349,0.107118,-0.089132,0.006993,-0.138918,0.103473,0.239771,-0.044548,-0.011912,-0.483566,-0.065348) * L1_6 + mat4(0.478220,0.181498,-0.639356,-0.264665,-0.217666,0.250267,0.220825,0.017894,-0.128639,-0.093250,0.124830,-0.155300,-0.394645,-0.007247,0.336298,0.140555) * L1_7 + mat4(0.171303,0.191576,-0.482954,-0.131874,0.381024,-0.104018,0.734717,-0.503934,-0.039837,0.035253,0.166557,-0.092367,-0.140068,-0.122476,0.211089,-0.099632) * L1_8 + mat4(-0.003909,0.160813,-0.157076,-0.103127,-0.004494,-0.135772,-0.075970,-0.148219,-0.246733,-0.198679,-0.055342,0.160356,-0.062853,-0.034514,-0.060254,0.160358) * L1_9 + mat4(-0.081031,-0.576347,-0.868104,0.633537,-0.181193,-0.148301,0.333081,-0.165720,0.068417,0.065334,0.215607,-0.164924,-0.257614,0.048319,-0.504058,0.855833) * L1_10 + mat4(0.141383,0.114470,0.450353,-0.138666,1.850965,-0.590921,-1.358892,0.990631,0.258363,0.104905,0.715673,-0.481860,0.107219,0.130358,0.290567,0.135501) * L1_11 + mat4(0.050789,-0.070758,0.136070,0.346618,-0.055001,-0.018992,-0.232169,-0.125107,-0.059382,0.110617,-0.450939,-0.025442,-0.038738,0.030446,0.058808,0.102607) * L1_12 + mat4(-0.054717,0.030962,0.094588,-0.040310,-0.636483,-0.091923,-0.147739,0.237061,0.189202,0.072774,-0.222700,-0.025058,-0.321893,0.273741,-0.341457,0.165713) * L1_13 + mat4(-0.498716,0.118294,1.178168,-0.100946,0.268640,0.201060,0.128213,-0.037665,0.151990,-0.037214,-0.587060,-0.032016,0.112503,0.285707,-0.284634,0.142308) * L1_14 + mat4(0.422249,-0.189746,-0.211842,0.629750,-0.008993,0.201327,-0.089930,0.114598,-0.120883,0.056354,-0.184480,0.002368,0.072396,0.211952,0.175883,-0.287897) * L1_15 + vec4(-0.896999,0.167214,1.197187,-1.231713)));\nvec4 L2_7 = sin((mat4(0.043201,0.125364,0.067831,-0.084575,0.176793,-0.154818,0.437769,0.652996,-0.109620,0.144915,-0.348569,-0.007223,-0.222563,-0.365137,-0.472666,0.096884) * L1_0 + mat4(0.225565,0.092034,0.142761,-0.180190,-0.256175,0.215498,-0.033969,-0.009334,0.004469,0.450286,0.506578,0.612303,-0.185962,-0.001513,-0.168067,0.184727) * L1_1 + mat4(-0.069964,-0.012746,-0.311710,-0.023236,-1.248455,-0.214823,0.208549,-1.260375,-0.273251,-0.120054,-0.162654,-0.006748,0.145601,-0.282449,0.653600,-0.065459) * L1_2 + mat4(-0.189290,-0.501039,0.135390,0.147416,-0.350242,0.110348,-0.266419,0.147066,-0.336222,0.040640,0.045234,0.481102,-0.006382,-0.112139,0.133834,0.161417) * L1_3 + mat4(-0.059723,-0.345043,-0.225361,-0.064347,0.069191,0.402127,0.093684,0.171019,0.343770,-0.719529,-0.501054,-0.379425,-0.093763,-0.174559,-0.253508,-0.123613) * L1_4 + mat4(0.307354,-0.477621,0.587733,0.493660,-0.756299,0.083292,-0.207868,0.162402,-0.070391,0.049573,-0.151863,-0.070878,-0.129306,-0.077227,1.084873,-0.107950) * L1_5 + mat4(0.108095,0.115722,0.111624,0.445622,0.412372,0.691015,0.574479,-0.134467,0.252594,0.051118,0.435481,-0.062517,-0.014673,-0.297380,-0.380178,0.262203) * L1_6 + mat4(0.450388,0.646349,-0.155248,-0.276044,0.198998,0.053301,0.106851,0.225319,-0.014944,0.124029,0.117524,-0.001303,-0.076719,0.368106,0.030633,0.018453) * L1_7 + mat4(-0.637698,0.224784,-0.131287,0.135760,0.258279,0.667552,0.590309,0.060339,-0.060127,-0.537502,-0.061452,0.025129,-0.185917,-0.242651,-0.162711,0.006803) * L1_8 + mat4(0.317826,0.068138,-0.096865,0.162595,-0.092270,0.148295,0.185910,-0.134374,-0.605556,0.208272,0.419129,0.574707,0.726210,-0.266940,0.323129,-0.269522) * L1_9 + mat4(-0.341548,0.072796,-0.097756,0.686938,0.210540,-0.497668,-0.261642,-0.382408,0.116736,0.238002,-0.013310,-0.032782,-0.356918,0.446931,0.274086,0.229780) * L1_10 + mat4(0.304403,0.174872,0.201952,-0.049373,-0.241890,1.388899,0.149296,1.190187,0.311462,-0.037583,0.516118,0.733992,-0.047832,0.321687,0.379452,-0.892844) * L1_11 + mat4(-0.099902,0.395013,-0.178225,0.022765,-0.039571,-0.148803,-0.224887,-0.003963,0.227366,0.399689,0.103461,0.063943,-0.241596,-0.019300,-0.044739,-0.053161) * L1_12 + mat4(0.083618,0.221587,0.272363,0.178523,0.806193,-0.190806,0.426759,-0.147912,0.310655,0.105231,0.039386,0.165098,0.333644,-0.067792,-0.382377,-0.011201) * L1_13 + mat4(-0.209674,-0.259495,0.268481,-0.803340,0.161357,-0.098023,0.338945,0.071678,-0.335353,-0.021107,0.222710,-0.226348,0.408710,0.028858,0.231946,0.588397) * L1_14 + mat4(-0.450793,0.160866,0.427638,0.034923,-0.140211,0.535851,0.140350,-0.136709,0.022422,0.379974,-0.269441,0.162973,0.469497,-0.513437,-0.163509,0.150634) * L1_15 + vec4(0.157130,-0.336359,-0.528474,-1.070896)));\nvec4 L2_8 = sin((mat4(-0.041122,0.181979,-0.057567,-0.100751,0.067372,-0.039850,-0.143027,0.094886,-0.002316,-0.184179,-0.162528,0.043104,0.323585,0.408265,-0.214277,-0.069082) * L1_0 + mat4(0.362922,-0.120014,0.221992,0.047373,-0.375050,-0.671556,-0.121268,0.218826,0.037976,0.212277,0.056176,0.334628,-0.104128,0.409068,0.591078,0.050750) * L1_1 + mat4(0.014278,0.751494,0.188980,-0.429449,0.110408,-0.714428,-0.578697,-0.194183,0.491784,-0.121548,0.092419,-0.033070,0.187951,0.677485,-0.208534,0.172053) * L1_2 + mat4(0.160424,0.148423,0.122435,-0.228715,0.059399,-0.130539,-0.032953,0.056300,0.133784,0.185112,-0.535506,0.259130,0.119498,0.708232,-0.048806,-0.058842) * L1_3 + mat4(-0.039543,0.145695,0.106977,-0.057403,0.012651,0.466283,0.112641,0.524479,0.016459,0.081002,0.034554,-0.056818,0.100182,0.132501,-0.199393,0.168352) * L1_4 + mat4(-0.459025,0.102001,0.215405,-0.115602,-0.067863,-0.207667,-0.242219,0.111449,0.016700,0.055379,-0.006940,-0.097250,0.360727,0.953395,-0.047601,-0.155048) * L1_5 + mat4(-0.027410,0.189541,0.256873,-0.228540,-0.238419,0.238183,-0.090772,0.018483,0.139580,-0.022599,0.172465,-0.009582,-0.242606,0.841100,-0.040695,-0.193529) * L1_6 + mat4(-0.335457,-0.028774,0.418214,-0.368061,-0.009847,0.287372,0.073633,0.300805,-0.105916,-0.138075,0.280192,-0.019904,0.051346,-0.332718,0.106084,-0.047103) * L1_7 + mat4(-0.633716,-0.186369,-0.101337,0.067581,0.298096,0.227492,-0.244837,0.014745,-0.213746,-0.562364,0.257388,0.116996,0.270968,-0.159583,0.260845,-0.154156) * L1_8 + mat4(-0.020050,-0.172697,0.639735,0.031182,0.008893,-0.137074,0.061115,0.143125,0.075482,-0.327038,-0.022945,0.172516,-0.341720,0.362800,0.344040,-0.107268) * L1_9 + mat4(-0.106876,0.004384,0.093939,0.626240,0.656978,0.427356,-0.404033,-0.055659,-0.592533,-0.122114,-0.129675,-0.186038,-0.738577,-0.489356,0.077234,0.286675) * L1_10 + mat4(0.033810,0.405514,-0.178068,0.019254,-1.289880,0.204519,1.175736,-0.094505,0.119855,-0.311267,-0.033462,0.398380,-0.403438,-0.305088,-0.375902,0.246005) * L1_11 + mat4(0.386108,0.369331,0.248170,0.526722,0.060067,-0.110163,0.030621,0.102120,-0.043722,-0.541588,0.321976,0.084935,0.100112,0.200864,-0.088098,0.075948) * L1_12 + mat4(0.059845,0.096154,-0.143711,0.093800,0.792292,0.310339,-0.071290,-0.195531,-0.045017,-0.196893,0.021381,0.215109,-0.016200,0.070794,0.138028,0.278293) * L1_13 + mat4(0.709840,0.926935,-0.683235,0.161558,0.056352,0.208087,-0.155345,-0.456783,0.143059,-0.268041,-0.011536,-0.148962,0.009768,-0.010913,-0.161043,0.001050) * L1_14 + mat4(-0.312210,-0.131269,-0.147954,-0.067812,-0.019319,-0.106475,-0.181575,0.025430,-0.186184,0.149956,-0.013759,0.090698,0.326702,-0.302979,-0.326505,-0.148472) * L1_15 + vec4(0.055188,-0.667185,-0.315633,-0.193473)));\nvec4 L2_9 = sin((mat4(0.113321,-0.383393,-0.087909,-0.127939,-0.113182,0.379223,-0.273225,0.020233,0.077760,0.089775,-0.081290,0.003409,-0.033289,0.137004,0.229770,0.296913) * L1_0 + mat4(0.165032,0.165696,0.049686,0.241489,0.111976,-0.177334,0.001754,-0.345948,0.304210,-0.420295,-0.003305,0.026375,0.192764,0.626388,-0.093015,-0.382585) * L1_1 + mat4(0.075270,0.447700,-0.068277,-0.009083,-0.270237,1.114838,0.368710,-0.062293,-0.396275,0.208938,0.079874,0.218388,-0.397216,-0.608849,-0.262612,0.189067) * L1_2 + mat4(0.047186,-0.015821,-0.134876,-0.051461,-0.182812,0.121567,-0.091896,-0.266728,-0.081899,-0.268311,-0.010982,-0.278684,0.227506,0.069689,0.009888,-0.185038) * L1_3 + mat4(-0.053806,-0.227346,-0.191787,-0.189449,0.147890,-0.329187,0.089971,-0.074032,0.122413,-0.003610,0.014808,0.266434,-0.117981,-0.053026,0.036075,0.077266) * L1_4 + mat4(0.113675,0.058113,0.049189,-0.215970,0.120205,-0.135942,0.092989,-0.107708,0.022841,0.134603,-0.008646,-0.132910,0.757913,0.183791,-0.016909,-0.204764) * L1_5 + mat4(0.118620,-0.170635,-0.059398,-0.214172,0.221113,-0.313329,-0.078931,0.095257,0.141105,0.339036,-0.215506,0.207236,0.156014,-0.127454,-0.142844,-0.202183) * L1_6 + mat4(-0.359775,0.171570,-0.015720,0.268807,-0.242176,-0.396228,-0.021451,-0.278751,0.049318,-0.129425,0.037201,-0.207309,0.074375,0.209895,0.017316,-0.083584) * L1_7 + mat4(0.006189,0.081471,0.010792,-0.062164,-0.012489,-0.431864,0.122501,-0.367912,-0.265438,-0.127118,0.075876,-0.332132,-0.208840,-0.128082,-0.410847,0.098291) * L1_8 + mat4(-0.060811,0.252317,0.198701,-0.295344,0.000654,-0.216893,-0.113169,0.332162,0.108693,0.405677,0.097005,-0.137949,-0.083002,0.330385,0.193415,0.489035) * L1_9 + mat4(-0.356900,0.017550,-0.475918,0.051979,-0.275385,0.010309,-0.078799,0.134731,0.182791,-0.144299,0.004334,-0.112697,-0.435835,0.105562,-0.091465,-0.406093) * L1_10 + mat4(0.281945,-0.543369,-0.089611,-0.138213,0.599076,0.433957,0.745773,0.567341,0.161323,-0.768287,-0.050195,-0.006449,0.014426,-0.123788,-0.048626,0.151381) * L1_11 + mat4(-0.052814,-0.346154,-0.350753,0.058167,0.001245,-0.100302,-0.014548,0.097350,0.050542,0.681308,0.341813,-0.068574,-0.085519,-0.206955,-0.138914,-0.079256) * L1_12 + mat4(0.054729,-0.208971,0.132971,-0.144283,-0.029510,0.161999,-0.650321,0.074216,-0.110316,0.156487,0.197007,-0.000495,-0.195646,-0.049313,-0.303557,0.208624) * L1_13 + mat4(-0.203248,-0.654181,-0.157334,-0.504327,-0.359413,0.274921,-0.337893,-0.374143,0.027510,0.455567,0.057505,0.342305,-0.317091,-0.440896,-0.347062,-0.360897) * L1_14 + mat4(0.302415,0.205703,0.119825,-0.044172,0.046332,-0.056128,0.002248,-0.309342,0.083187,0.014989,0.045065,0.102208,-0.157994,-0.317562,-0.062151,-0.166214) * L1_15 + vec4(0.474414,-0.111019,-0.798623,-0.413470)));\nvec4 L2_10 = sin((mat4(-0.038691,-0.028400,-0.111951,0.380939,-0.370472,-0.221783,-0.071779,0.247267,-0.268301,0.149407,0.091561,0.111949,-0.002728,0.209053,-0.074528,0.169841) * L1_0 + mat4(-0.050976,0.126123,-0.086270,-0.221915,0.443089,0.030988,0.060604,-0.196091,-0.066882,0.548912,-0.001946,-0.662441,0.171485,-0.318190,0.399972,0.049915) * L1_1 + mat4(-0.122460,0.260116,-0.459019,0.314613,-1.026963,-0.830495,1.212402,-0.473772,0.425808,-0.238547,-0.062302,0.135081,-0.457069,0.115399,0.725912,-0.286787) * L1_2 + mat4(0.214636,0.223786,0.148686,0.036450,0.089551,-0.094417,-0.014669,-0.387662,0.451795,-0.137218,-0.123043,0.060577,-0.042424,0.383918,0.383862,-0.105295) * L1_3 + mat4(0.238407,0.328038,-0.193743,0.381424,0.092120,-0.095300,0.268972,-0.248276,-0.298566,0.350111,-0.283900,-0.074189,-0.108540,-0.386421,0.067481,0.453260) * L1_4 + mat4(-0.285499,0.567206,-0.260089,-0.812626,-0.491893,0.353659,-0.003854,0.791642,-0.067550,-0.043556,-0.112686,-0.123546,-0.015806,0.747855,0.174449,-0.518362) * L1_5 + mat4(-0.137744,-0.130532,0.257700,0.358316,-0.194835,-0.064269,0.212262,0.426826,-0.049029,-0.091551,0.329770,-0.100007,0.158326,-0.824165,0.132889,0.610751) * L1_6 + mat4(0.034897,-0.469320,0.202380,-0.114436,0.057714,0.334868,0.219173,0.141084,0.526490,0.211238,0.081941,0.158837,-0.197068,0.268785,-0.345540,0.060000) * L1_7 + mat4(0.025577,-0.605683,-0.392057,-0.318636,-0.339778,0.281933,0.273441,0.253967,-0.239356,-0.423789,0.005741,-0.464951,0.016380,0.272339,0.630270,-0.063352) * L1_8 + mat4(-0.197349,0.248235,0.070051,-0.119498,0.145147,0.031777,-0.366826,-0.446526,0.029576,-0.471969,0.185943,0.214671,0.832909,-0.175707,-0.274451,-0.446180) * L1_9 + mat4(0.268692,-1.099030,-0.455639,0.331009,-0.174639,-0.183452,1.021178,0.248696,0.373377,0.407592,-0.255254,-0.042431,0.352156,-0.593348,0.049823,0.601978) * L1_10 + mat4(0.179857,0.366671,-0.053325,-0.146451,-0.789395,-0.955202,-0.627042,-0.249121,0.356217,0.644629,-0.175548,-0.341118,-0.027764,0.005690,-0.139206,-0.046439) * L1_11 + mat4(0.270111,-0.122243,-0.331773,1.318913,0.183702,-0.051611,0.034172,0.060925,-0.078319,0.105548,-0.255921,-0.840030,0.124389,-0.030422,0.115160,0.394208) * L1_12 + mat4(-0.010634,-0.008375,0.130343,0.027104,0.045409,0.740530,-0.086743,-0.103192,-0.195384,-0.470743,0.331748,-0.119364,-0.445929,0.465376,-0.105000,0.630065) * L1_13 + mat4(-0.238894,0.242803,1.148172,0.691318,-0.155405,-0.137685,-0.402818,0.276444,0.003790,-0.697803,-0.029967,-0.155870,0.102099,-0.091652,-0.356653,-0.038082) * L1_14 + mat4(-0.001594,-0.065969,-0.069315,0.024429,0.198272,-0.183096,-0.365276,-0.221129,0.010663,0.248232,-0.077992,-0.073980,-0.224470,0.476640,0.361264,-0.714278) * L1_15 + vec4(-0.171939,0.674906,-0.116404,-0.478062)));\nvec4 L2_11 = sin((mat4(0.070132,-0.261741,-0.215164,0.245607,-0.274836,0.320069,0.261863,-0.098120,-0.219898,0.142436,-0.009726,0.032664,-0.101305,-0.072560,-0.438982,0.221851) * L1_0 + mat4(-0.074439,-0.107682,-0.090559,-0.028079,0.327900,-0.212940,-0.496474,-0.155198,-0.124797,0.419247,-0.418069,-0.041797,-0.008452,0.127985,0.239161,-0.154632) * L1_1 + mat4(-0.021058,-0.296594,0.056082,0.141369,-0.252365,-1.074304,-0.047111,-0.757572,0.016944,0.170481,-0.262134,0.204181,-0.111288,-0.343151,-0.637916,0.036728) * L1_2 + mat4(-0.018497,-0.184412,0.168738,-0.028452,-0.063507,-0.174350,-0.201987,-0.046153,-0.288932,-0.119071,-0.503607,0.203964,0.042111,0.014472,-0.032539,-0.014929) * L1_3 + mat4(0.007091,0.076468,-0.051686,-0.036691,0.007692,0.167386,-0.499082,0.073029,0.098929,0.143422,0.411746,-0.653024,-0.085311,0.023227,0.200611,-0.276121) * L1_4 + mat4(-0.166211,-0.021459,0.146067,0.064243,0.047410,0.382949,-0.139341,-0.114837,0.022940,-0.081231,-0.035349,-0.047534,0.867607,0.183432,-0.994136,-0.182386) * L1_5 + mat4(-0.304958,-0.034029,0.323503,-0.132277,0.277052,-0.131121,0.311455,0.140317,0.091623,0.118268,-0.390473,-0.137128,-0.641611,0.228667,0.555616,0.449054) * L1_6 + mat4(-0.135873,-0.004102,0.404299,0.170401,-0.236721,-0.100711,-0.463225,-0.043459,0.125146,0.336016,-0.009656,0.355061,-0.036906,-0.255987,-0.422147,0.032082) * L1_7 + mat4(0.214847,0.367863,0.446497,0.118680,0.391238,0.029429,-0.428324,-0.106271,-0.424308,-0.346419,-0.136702,0.064087,-0.165560,0.072277,-0.572499,-0.143390) * L1_8 + mat4(0.301842,0.108710,0.022082,0.096796,0.115654,0.207830,-0.229857,-0.145602,0.087306,0.281408,-0.027372,0.184916,0.652873,-0.411865,-0.453874,-0.055200) * L1_9 + mat4(-0.348769,0.610802,1.226824,0.315908,0.188796,-0.419030,-0.198484,-0.120249,0.354980,-0.308190,0.042658,0.177451,-0.299589,0.045443,0.382343,0.204123) * L1_10 + mat4(0.262909,0.288311,0.000197,0.141576,-0.777113,1.101804,0.135763,1.458721,0.591788,0.614676,-1.289171,0.283600,0.026356,-0.116624,-0.330485,0.348575) * L1_11 + mat4(-0.517997,0.523639,0.031516,0.115868,-0.275817,-0.171478,-0.050364,-0.068075,0.254818,0.286561,-0.359653,0.026375,0.262012,0.370460,0.475096,0.012398) * L1_12 + mat4(0.019871,0.085678,-0.173384,-0.041489,0.245817,0.043254,0.645727,-0.110146,-0.216364,0.066852,-0.031055,-0.010306,-0.075390,0.184296,0.362684,0.439700) * L1_13 + mat4(0.721365,-0.484956,-0.715779,-0.211286,0.435491,-0.330055,0.841944,-0.266604,-0.045100,-0.195607,-0.139520,-0.284354,0.062723,0.235902,0.490584,-0.015187) * L1_14 + mat4(0.034625,0.039383,-0.043042,-0.006719,0.226297,-0.073572,0.159455,-0.037896,-0.046602,0.144807,0.257506,-0.020201,0.152446,0.539700,-0.472156,0.229067) * L1_15 + vec4(1.340557,-0.486294,-0.930841,-0.661098)));\nvec4 L2_12 = sin((mat4(0.170136,0.030097,0.100021,-0.034307,-0.141107,0.060563,-0.055831,0.025395,-0.098238,0.335885,0.042644,-0.124081,-0.400783,-0.043592,0.100266,0.179045) * L1_0 + mat4(-0.201601,0.157366,0.007841,-0.117932,0.583940,0.145359,0.137327,0.039208,0.213130,0.979739,0.182132,0.384643,0.076749,-0.239858,0.661775,0.064315) * L1_1 + mat4(-0.142815,0.212128,-0.213816,0.148768,0.181847,-1.704463,-0.876375,0.098160,-0.155469,-0.003879,0.043940,0.227086,0.271997,-0.985220,-0.643828,0.025212) * L1_2 + mat4(-0.039634,0.250989,-0.191495,-0.077273,0.002880,0.188058,0.172822,-0.002290,0.436445,-0.036684,-0.302989,-0.023665,0.243991,-0.068446,-0.084949,0.321331) * L1_3 + mat4(-0.422520,0.095367,0.027600,-0.098563,0.247212,0.277787,0.328694,0.133781,-0.519293,-0.264075,-0.366573,0.103187,0.372961,-0.383775,0.114389,-0.232151) * L1_4 + mat4(0.176723,0.423969,0.443678,0.143252,-0.093542,0.180120,-0.517265,0.025974,-0.101182,-0.026993,-0.122317,0.064007,-0.067574,0.081594,-0.363187,0.831534) * L1_5 + mat4(-0.057092,-0.073381,-0.189392,0.005446,-0.004440,0.115221,0.174975,-0.069197,-0.312641,0.013250,0.168196,0.175649,0.082051,-0.110508,-0.051323,-0.616246) * L1_6 + mat4(0.054601,-0.334181,-0.071571,-0.551384,-0.174710,0.033552,-0.017813,0.341461,-0.332502,0.378690,0.253449,0.021227,-0.363545,0.088143,-0.294249,0.326303) * L1_7 + mat4(-0.693579,0.550333,0.892325,-0.455625,-0.138051,0.093298,0.122714,0.074106,-0.012656,-0.193251,0.155165,0.072784,-0.524272,0.218386,-0.220086,-0.171042) * L1_8 + mat4(-0.320047,0.060020,0.010360,0.276132,-0.096543,0.066379,-0.209957,0.140278,0.379488,0.169043,0.428560,0.322143,0.369243,0.131295,0.080493,0.111983) * L1_9 + mat4(-1.102012,-0.296814,-0.002217,-0.275347,-0.176449,-0.608940,0.176336,-0.015643,0.658441,0.045164,0.271230,0.065475,0.473210,0.342955,0.491945,-0.554214) * L1_10 + mat4(0.006456,0.310644,-0.139750,0.268866,0.999873,0.708307,0.554271,-0.523893,0.207204,0.672607,0.793274,0.371636,-0.110247,0.285866,0.631789,-0.160173) * L1_11 + mat4(-0.628026,0.235580,0.366783,-0.227528,0.037065,-0.106603,0.411589,-0.061563,0.093745,0.502938,-0.049618,0.062453,0.027709,-0.238233,-0.080116,0.059694) * L1_12 + mat4(0.088740,0.036807,0.185548,0.125691,-0.646245,0.038492,-1.229921,-0.165370,-0.085362,-0.166483,-0.326422,-0.255554,-0.122635,-0.012715,0.053785,-0.051580) * L1_13 + mat4(-1.130989,-0.883445,-0.106467,0.857890,-0.034401,-0.054071,-0.181885,0.004633,-0.049647,-0.359953,-0.018371,-0.235128,0.088324,0.349911,0.238201,-0.080243) * L1_14 + mat4(0.535821,0.535255,0.232051,0.056484,0.032550,-0.028659,0.532927,0.138804,0.092912,0.083857,-0.245958,0.072735,0.182970,0.281571,0.238302,-0.013696) * L1_15 + vec4(-0.058028,-0.822998,0.493001,0.457790)));\nvec4 L2_13 = sin((mat4(0.014445,0.049942,-0.146404,-0.173135,0.173435,-0.646389,0.283499,0.320261,-0.179855,-0.075531,-0.150619,0.174684,-0.159951,0.570268,0.259812,0.003856) * L1_0 + mat4(0.252178,-0.340696,0.087704,-0.309637,0.120509,0.119181,-0.393253,-0.083698,-0.136063,-0.392091,-0.411534,0.744088,-0.054942,0.015310,0.106191,-0.273684) * L1_1 + mat4(-0.299835,-0.179968,-0.116802,0.173319,0.478047,1.859479,0.921879,-0.453067,-0.237977,0.043473,0.075509,-0.101605,-0.469461,0.101761,0.050725,0.384633) * L1_2 + mat4(-0.245517,0.305557,0.120098,0.081346,-0.268884,-0.100832,-0.110069,0.018171,-0.031828,-0.327180,0.440193,0.209053,-0.365327,0.201945,0.064028,0.567257) * L1_3 + mat4(-0.008243,0.006370,-0.008415,-0.067232,-0.644439,-0.258115,-0.360702,-0.099752,0.428950,0.616521,0.118555,0.148879,-0.236759,0.183865,0.159333,-0.456364) * L1_4 + mat4(0.041638,-0.216468,0.017175,-0.287280,0.312628,0.134180,-0.083174,0.130253,-0.037132,0.251543,0.014107,-0.105571,0.519592,0.318931,-0.463983,0.360382) * L1_5 + mat4(-0.029445,0.004279,0.267319,0.125674,0.190649,-0.197394,-0.076678,0.118473,-0.109329,-0.323265,-0.179095,-0.346020,-0.158198,-0.146622,0.938111,0.044349) * L1_6 + mat4(-0.154892,-0.638402,0.338964,-0.020683,-0.014467,-0.113295,-0.011176,0.413572,-0.189995,-0.303732,0.079082,-0.212342,0.333224,-0.453691,-0.260779,0.298051) * L1_7 + mat4(0.312288,-1.043865,0.119352,-0.546896,0.535907,0.012918,-0.115310,0.303822,0.556046,-0.083373,0.221168,-0.107254,-0.096973,-0.252975,0.284845,0.234367) * L1_8 + mat4(0.138207,-0.015163,-0.163008,-0.438954,0.138615,-0.298661,-0.251577,-0.160614,0.009102,0.044192,0.029247,0.042010,0.377445,-0.457643,0.033020,-0.191839) * L1_9 + mat4(-0.626874,-0.489098,0.532753,-0.512425,0.492362,0.039133,0.193986,0.142945,0.034741,-0.037814,-0.042106,-0.122422,-0.519058,-0.524112,0.127887,-0.198178) * L1_10 + mat4(-0.179618,0.028052,-0.340226,0.297382,-1.476581,-0.745846,-0.116110,-0.866465,-0.581349,-0.476835,-0.604727,-0.212361,-0.193300,-0.022433,-0.517428,-0.208065) * L1_11 + mat4(0.398796,-1.195498,-0.294082,0.161749,0.175958,0.217410,0.013749,0.146923,-0.071744,0.293330,-0.388489,-0.075603,-0.549067,0.012194,-0.044095,-0.093737) * L1_12 + mat4(-0.023559,-0.407030,-0.067410,-0.099793,0.752803,-0.581298,-0.109901,0.364863,0.001962,0.302889,0.240430,-0.128571,0.015336,0.155784,-0.044034,0.729986) * L1_13 + mat4(-0.169695,0.336147,0.147896,0.107090,-0.090951,-0.411468,-0.049052,0.331953,0.083097,0.310413,0.301559,-0.003940,-0.370511,0.069835,-0.118515,-0.176503) * L1_14 + mat4(-0.006426,0.119709,-0.154443,0.436603,0.152119,0.025845,-0.189113,-0.136691,-0.108017,-0.079327,-0.108724,0.097775,-0.179672,0.022900,-0.165349,-0.204119) * L1_15 + vec4(0.392719,0.269190,-0.325709,1.387539)));\nvec4 L2_14 = sin((mat4(-0.029811,0.111939,0.116614,-0.026952,-0.182807,0.448993,-0.210746,-0.057456,-0.034172,-0.041500,0.102417,0.052087,0.151640,0.133066,0.106578,-0.033796) * L1_0 + mat4(0.067687,-0.030006,0.016318,0.142745,0.059276,0.309426,0.050789,-0.054537,0.005505,-0.395231,-0.485244,-0.342290,0.090749,0.590693,0.485078,0.133625) * L1_1 + mat4(-0.210327,0.197884,0.272181,-0.234009,0.559652,0.103321,0.639133,0.355615,-0.249447,-0.167754,-0.189701,-0.244442,-0.246430,0.605209,0.447876,-0.201021) * L1_2 + mat4(-0.079946,0.050836,0.148736,0.014453,-0.267063,-0.010430,-0.217404,0.000859,-0.285149,-0.133505,0.086093,-0.122827,-0.088519,-0.117292,0.063599,0.066420) * L1_3 + mat4(-0.183506,-0.026630,-0.334754,-0.120446,0.212807,-0.186059,0.029414,0.330259,-0.001880,0.061808,-0.353044,0.067755,0.046620,0.237324,0.124340,0.070022) * L1_4 + mat4(-0.102380,0.328125,0.171674,-0.037667,-0.140471,-0.338438,-0.365686,-0.294665,-0.108411,0.101293,-0.007651,0.016998,0.012969,-0.420398,-0.815406,0.076674) * L1_5 + mat4(-0.075648,0.253651,-0.119852,0.292804,-0.257219,-0.305330,0.242754,-0.002845,0.102659,0.162594,-0.001371,-0.005242,-0.337629,0.014346,0.029913,0.490792) * L1_6 + mat4(0.254324,-0.469778,-0.579123,0.555365,-0.101835,0.045792,0.099267,0.034770,0.098905,-0.374720,-0.282027,0.204622,0.135951,-0.392582,0.061898,0.045057) * L1_7 + mat4(0.033484,-0.108948,0.045816,0.232914,0.011907,-0.145752,-0.284330,-0.318323,0.184308,-0.359122,0.394496,-0.299116,-0.043377,-0.157245,0.030489,-0.140241) * L1_8 + mat4(0.175750,-0.314793,0.058545,0.125581,-0.062625,0.070425,-0.493334,-0.180955,0.127579,0.257626,0.579211,0.049833,-0.336100,0.615394,-0.189484,0.438684) * L1_9 + mat4(-1.121856,0.858258,0.136393,0.538446,0.329494,0.190181,0.288706,0.272035,-0.071540,-0.017044,-0.223179,-0.023706,-0.386880,0.430350,0.601097,-0.101788) * L1_10 + mat4(0.059435,-0.121853,-0.210215,-0.211332,-0.310625,0.616962,-0.994675,-0.877043,-0.162466,-0.433928,-0.561439,-0.201791,-0.049268,0.152871,0.367405,0.089711) * L1_11 + mat4(0.039007,0.065213,0.197602,0.162003,0.003622,0.179648,-0.042201,-0.135670,-0.020021,-0.741463,-0.318093,-0.044761,-0.179426,-0.113076,-0.277926,0.181315) * L1_12 + mat4(0.000295,-0.044522,-0.042973,0.057148,-0.163501,0.243420,-0.051121,0.791889,0.269467,0.067380,-0.183913,0.022469,-0.161882,-0.046137,0.158974,0.201575) * L1_13 + mat4(0.009255,-0.114062,0.049427,0.793072,-0.411546,0.098245,-0.188918,0.501117,0.092231,0.153400,0.138573,0.101376,-0.483443,0.087867,0.154059,0.439271) * L1_14 + mat4(-0.057206,-0.253576,0.018025,-0.013254,-0.092590,-0.065381,-0.047153,-0.084528,0.135234,0.108177,0.084202,0.047328,-0.012394,0.006659,-0.202460,0.255453) * L1_15 + vec4(0.367962,-0.604185,0.345193,-0.539029)));\nvec4 L2_15 = sin((mat4(0.160842,-0.164056,0.048946,-0.111715,-0.056862,-0.184104,-0.166457,0.172534,0.029231,-0.185675,0.206097,-0.017341,-0.432428,0.585564,-0.266084,0.213299) * L1_0 + mat4(0.204703,0.199342,0.004740,-0.015753,0.388738,-0.239873,0.277676,-0.175902,-0.287550,0.397543,0.433579,-0.094505,-0.318598,0.134710,-0.386829,-0.083717) * L1_1 + mat4(-0.424167,0.085563,-0.311275,0.196334,0.889544,-0.321034,0.754072,0.443746,-0.776278,-0.252640,0.150167,-0.228538,-0.692623,-0.288304,0.063406,-0.013619) * L1_2 + mat4(0.016430,-0.118824,-0.116774,0.071167,0.002205,0.103369,0.264084,-0.141064,0.026546,-0.104559,0.175578,0.112133,-0.233893,-0.048778,0.003052,0.012631) * L1_3 + mat4(0.000518,-0.029425,-0.219010,-0.096573,0.269623,0.000359,-0.078789,-0.046823,-0.141856,0.100257,-0.097064,0.216577,0.239542,0.006558,0.127167,0.010072) * L1_4 + mat4(-0.237177,-0.176192,0.106829,0.408568,0.078987,-0.321399,0.019162,-0.002825,-0.030228,0.073624,0.024537,-0.010711,-0.585762,0.542349,0.171489,-0.009208) * L1_5 + mat4(0.081838,0.078290,0.076100,-0.236007,0.152923,-0.483371,0.243711,-0.058362,0.226757,-0.100659,0.193099,0.199315,0.070118,-0.345724,0.143058,0.660734) * L1_6 + mat4(-0.179068,-0.331281,-0.423217,0.803218,-0.070913,-0.158488,0.347028,0.053084,-0.097969,-0.334845,-0.079647,0.009074,-0.225447,-0.053821,0.106991,0.090172) * L1_7 + mat4(0.423103,-0.226256,-0.599136,-0.114455,-0.121939,-0.230187,-0.007771,-0.168973,0.166830,-0.245695,-0.136348,0.297854,-0.172786,0.409549,0.464614,-0.019246) * L1_8 + mat4(0.254666,-0.076225,-0.054668,0.035842,-0.035202,0.190618,-0.198197,0.179641,-0.328842,-0.228267,0.389184,0.082191,-0.506415,0.045472,-0.885946,0.260870) * L1_9 + mat4(0.106380,0.222885,0.897500,-0.795026,0.153621,-0.145666,0.031482,0.287751,0.396159,0.191061,-0.084505,-0.061635,0.533600,-0.191550,0.303380,-0.030561) * L1_10 + mat4(-0.123376,0.027615,-0.000008,0.001845,-0.583191,-0.652591,-1.308626,0.929975,-0.502407,0.089259,0.379919,-0.249748,-0.136513,-0.067752,-0.534052,0.043136) * L1_11 + mat4(-0.088618,-0.066332,0.330990,-0.053693,0.043071,-0.136535,0.242922,-0.114636,-0.061102,0.114844,-0.280782,0.039083,0.037537,0.169206,-0.075025,-0.040897) * L1_12 + mat4(0.010017,-0.134935,0.299725,0.053277,-0.057944,0.370383,0.584482,-0.308525,0.262310,-0.127001,0.172998,0.203424,0.212208,-0.043048,0.148176,0.049628) * L1_13 + mat4(1.118173,-0.806761,0.392511,0.128843,-0.538043,0.261885,0.207890,-0.316656,-0.213198,0.271978,0.266055,-0.075173,0.118776,0.146888,0.075683,-0.435461) * L1_14 + mat4(-0.169248,-0.121506,-0.308320,0.017238,0.034415,-0.033694,-0.025075,0.001269,0.261524,-0.057422,-0.010151,0.077598,0.027534,-0.148689,0.104810,-0.153340) * L1_15 + vec4(-0.480976,-0.117166,0.038012,0.424760)));\nif(BlockIndex == 0)\n{\nvec4 L3_0 = sin((mat4(-0.199929,0.186741,0.006323,-0.058333,-0.102147,0.011342,0.208961,-0.242790,-0.046459,0.150534,0.225199,0.167305,0.834323,-0.123323,-0.312301,0.347885) * L2_0 + mat4(0.091600,0.079029,-0.104960,0.031165,0.031184,0.258802,0.096782,-0.098808,-0.020058,0.005637,0.106286,0.001277,-0.215289,0.189975,0.218774,0.010409) * L2_1 + mat4(-0.019181,0.102640,0.056332,-0.224497,-0.025373,-0.036375,-0.071945,0.092487,0.019964,-0.281540,0.097383,-0.626700,-0.240918,0.055659,0.157880,-0.104663) * L2_2 + mat4(0.097504,0.055489,-0.053950,0.055435,0.093805,-0.003492,-0.005156,-0.185713,0.056306,0.337055,0.081200,0.142318,0.046815,0.068512,-0.190870,-0.060854) * L2_3 + mat4(0.024996,-0.005622,-0.076852,0.023607,-0.230076,-0.132211,0.121502,-0.156668,0.159062,-0.021212,0.051097,0.076614,0.455283,-0.119597,0.008246,-0.267499) * L2_4 + mat4(0.427493,-0.058654,-0.368378,0.056308,0.042683,-0.122592,-0.057163,0.023910,0.067301,-0.109600,-0.225875,-0.064909,-0.073738,0.162219,-0.296500,-0.059971) * L2_5 + mat4(-0.651832,-0.067180,0.409658,-0.091444,0.401837,-0.607061,0.444771,0.026789,-0.474904,0.088547,0.085742,-0.006557,0.380165,0.037791,0.041178,-0.012855) * L2_6 + mat4(-0.205250,-0.100810,0.103651,0.127284,-0.094289,0.014383,0.244050,0.057139,0.001906,0.105330,0.050248,0.434450,-0.044825,-0.221259,0.104751,-0.041216) * L2_7 + mat4(0.037813,0.086546,-0.164403,-0.055020,-0.170367,-0.051573,0.126633,0.107557,-0.126472,0.287037,0.012202,-0.127676,-0.334792,-0.237451,0.089818,0.241375) * L2_8 + mat4(0.626934,-0.306294,-0.331596,-0.277519,0.008870,-0.000841,0.168690,0.026752,-0.380042,-0.158388,-0.343901,-0.327800,-0.077720,-0.043140,-0.441591,0.156372) * L2_9 + mat4(-0.188468,0.138281,0.270841,0.041730,-0.056855,-0.059492,0.141639,-0.358727,0.158731,0.100084,-0.458477,-0.052654,0.163904,0.000359,-0.010744,-0.011890) * L2_10 + mat4(-0.144464,0.157212,-0.246657,0.032213,0.241949,0.208037,0.219930,0.071943,0.134246,0.003216,0.032617,-0.148746,-0.215906,0.005574,0.088646,-0.128544) * L2_11 + mat4(0.020188,-0.149242,0.269584,-0.178041,-0.317560,-0.135393,-0.136931,-0.063157,0.029800,0.057623,-0.196402,-0.199945,-0.295354,0.430792,-0.105171,0.030615) * L2_12 + mat4(0.049627,0.000244,-0.016753,-0.253236,0.021464,-0.000590,-0.073895,-0.069524,0.164825,0.211313,0.153023,0.094532,-0.158512,-0.019156,0.057322,0.206532) * L2_13 + mat4(0.340332,-0.304089,-0.388468,0.095697,0.120314,0.222403,0.014666,0.185183,-0.162597,-0.044403,0.152716,-0.063766,0.032140,-0.364109,0.271160,0.009724) * L2_14 + mat4(-0.008009,-0.208990,0.322258,-0.204313,0.251572,0.067891,-0.112948,-0.034255,0.075294,-0.004033,-0.011702,0.185075,-0.150258,-0.251159,0.503821,-0.320382) * L2_15 + vec4(0.808054,0.451058,0.074470,0.765204)));\n    return L3_0;\n}\nelse if(BlockIndex == 1)\n{\nvec4 L3_1 = sin((mat4(-0.228074,0.129610,-0.032989,0.060543,-0.081712,-0.184217,0.049905,-0.064081,-0.033615,0.137669,0.095816,0.122311,0.278794,0.145603,0.219602,-0.237605) * L2_0 + mat4(-0.152263,0.031062,0.020327,-0.092674,-0.031043,0.385165,0.129069,0.209239,0.153237,-0.074263,-0.006017,-0.027504,0.113617,0.069741,0.147976,-0.181326) * L2_1 + mat4(0.123344,0.232108,-0.028746,0.045582,-0.082097,-0.199922,-0.147287,0.055866,0.527397,-0.170034,0.005185,0.480174,0.038036,0.089520,0.003841,0.038761) * L2_2 + mat4(-0.077564,-0.012088,0.044680,0.065917,0.313111,-0.042187,-0.109042,0.186783,0.145723,0.074702,0.036103,0.172765,-0.011992,0.139156,0.150788,-0.475639) * L2_3 + mat4(-0.000385,-0.110441,-0.032511,0.072949,0.106993,-0.073679,-0.230484,0.175666,-0.049074,0.033815,-0.061328,-0.066101,0.189832,-0.254938,-0.027175,-0.102574) * L2_4 + mat4(-0.214669,0.033285,0.069659,0.387080,-0.230510,-0.112835,0.004136,0.106022,-0.136904,-0.211102,0.107267,-0.076068,-0.201760,0.032487,0.189579,-0.155428) * L2_5 + mat4(0.197071,-0.100977,-0.132966,0.065767,0.443092,0.372607,-0.097147,-0.458228,-0.159430,0.161843,-0.185799,0.134566,-0.260412,-0.032031,-0.019077,0.197226) * L2_6 + mat4(0.090126,-0.229185,-0.194043,-0.073863,-0.085325,-0.132374,-0.154765,0.117991,0.027536,0.065291,0.056465,0.158503,-0.039958,-0.091137,-0.077922,0.025775) * L2_7 + mat4(0.245022,0.122202,0.179093,-0.237012,0.029087,-0.014642,-0.022198,0.018039,0.047991,0.207345,0.000533,-0.053857,-0.327195,-0.397820,-0.255713,0.065126) * L2_8 + mat4(-0.122499,-0.251001,0.678877,-0.324038,-0.111962,-0.105037,-0.098697,-0.126625,-0.087499,0.236480,0.170918,-0.050257,-0.174309,0.209736,-0.022244,0.052378) * L2_9 + mat4(-0.034541,0.100193,-0.107713,-0.154157,0.095809,0.031605,-0.113107,0.037952,-0.012846,0.015912,0.047831,0.015850,0.113886,-0.173303,-0.132080,-0.035268) * L2_10 + mat4(-0.072344,0.126235,0.018663,0.160665,0.152997,0.324405,0.300108,-0.150023,-0.104720,-0.123361,-0.193569,0.100104,0.060770,0.064050,-0.452555,0.212614) * L2_11 + mat4(0.033357,-0.240897,-0.038892,0.083759,-0.080347,-0.314639,-0.132480,-0.263488,-0.029030,0.050608,0.120600,-0.051367,-0.287736,0.385332,0.184914,-0.491999) * L2_12 + mat4(0.285385,0.086331,0.104188,0.248649,0.075490,0.099310,0.216109,0.132072,0.223621,0.230087,0.130272,-0.736612,-0.100898,-0.175086,-0.413743,0.145723) * L2_13 + mat4(-0.136897,-0.231596,-0.245557,0.169919,-0.056430,-0.141932,-0.052900,-0.086451,0.143766,0.104184,0.011191,-0.017382,-0.164617,-0.730258,-0.186068,-0.237669) * L2_14 + mat4(0.093937,-0.246792,-0.126416,-0.022491,0.142147,0.017155,0.388689,-0.082826,-0.046660,-0.063092,-0.013358,0.241772,-0.368053,0.238928,0.257976,-0.334867) * L2_15 + vec4(-0.394243,0.475935,0.002481,1.024777)));\n    return L3_1;\n}\nelse if(BlockIndex == 2)\n{\nvec4 L3_2 = sin((mat4(-0.042849,0.222329,0.100400,-0.170969,0.026460,0.208533,-0.020407,0.058111,0.092474,0.327498,0.194515,-0.022331,-0.113366,-0.491970,-0.602128,-0.444737) * L2_0 + mat4(-0.066057,-0.217340,-0.068889,0.131573,0.083779,0.458377,-0.086092,-0.180774,0.015613,-0.040687,-0.027134,-0.117456,0.105913,0.365232,0.015924,-0.095191) * L2_1 + mat4(-0.026317,-0.046131,0.169781,-0.112701,-0.099766,-0.107358,0.098909,0.100018,-0.235598,0.192723,0.157654,-0.191013,-0.013076,0.118494,0.081792,-0.128452) * L2_2 + mat4(-0.032090,-0.061462,0.021395,0.054084,-0.182774,0.112393,-0.046710,-0.302732,-0.088186,0.001631,0.045329,-0.085344,-0.037488,-0.116744,-0.022326,-0.034451) * L2_3 + mat4(-0.068124,-0.012316,-0.251003,-0.150226,-0.242984,0.264294,-0.007971,-0.157139,0.249538,-0.040374,-0.137889,0.151691,0.240350,0.234191,-0.057606,0.156082) * L2_4 + mat4(0.074907,0.447710,0.884156,0.346312,0.236719,-0.214410,-0.038853,0.087218,0.093632,0.218969,-0.098984,-0.014264,-0.147426,-0.203168,-0.259981,0.030775) * L2_5 + mat4(-0.218073,0.263061,0.136457,-0.057976,-0.748780,-0.125400,-0.053015,0.408266,-0.024082,0.030667,-0.142479,-0.074302,0.112460,0.014166,0.070793,0.109467) * L2_6 + mat4(-0.112390,-0.124195,-0.182772,-0.027115,0.113462,0.113506,0.063699,0.197360,0.098495,0.097245,0.095426,-0.035147,0.036182,-0.042476,-0.088789,0.293408) * L2_7 + mat4(0.100130,0.117487,-0.091175,-0.207891,-0.017292,-0.041865,0.023944,0.007723,-0.046410,-0.107918,-0.006184,-0.131943,-0.082612,0.177734,-0.006875,-0.028768) * L2_8 + mat4(0.428918,0.173108,-0.383291,0.455827,-0.009026,-0.126473,0.141809,0.124810,0.059435,0.534482,-0.072552,-0.068511,0.312875,-0.367428,-0.163790,0.100183) * L2_9 + mat4(0.064148,0.326524,-0.218905,0.058291,-0.020801,0.451291,-0.045850,-0.067034,-0.031251,-0.180849,-0.145014,-0.022673,-0.027665,-0.092699,0.006147,0.136608) * L2_10 + mat4(0.224428,0.189806,0.145735,-0.276202,0.113842,0.094635,-0.092267,-0.071519,0.011853,0.067494,0.028836,0.029303,-0.212326,-0.217413,0.196859,0.396748) * L2_11 + mat4(-0.080871,0.022402,-0.047082,0.044876,-0.028729,-0.159403,-0.224402,0.304431,-0.217921,0.039338,-0.230816,-0.051817,-0.259772,-0.257289,-0.168958,0.071896) * L2_12 + mat4(0.111071,0.093069,0.119091,-0.005383,0.030966,0.199126,-0.046433,-0.233688,0.096887,-0.255316,-0.287614,-0.272802,0.218528,-0.192513,0.106483,0.173177) * L2_13 + mat4(0.049996,-0.352688,-0.073106,-0.004487,0.034625,-0.010802,-0.136118,0.218498,-0.243368,0.138085,0.017992,-0.307913,-0.422817,-0.331482,-0.355985,0.306349) * L2_14 + mat4(-0.164450,0.262754,-0.227390,-0.203510,0.028476,-0.218837,-0.219530,0.000737,-0.005137,-0.057943,0.067849,-0.131423,-0.287257,0.638784,-0.428636,-0.087278) * L2_15 + vec4(0.399780,-1.054311,0.371708,-0.596810)));\n    return L3_2;\n}\nelse if(BlockIndex == 3)\n{\nvec4 L3_3 = sin((mat4(-0.106301,-0.001095,-0.058422,0.087458,-0.145676,0.023547,0.022458,-0.455467,0.394441,0.079491,0.069260,0.123592,-0.179452,0.723758,-0.597262,0.508074) * L2_0 + mat4(-0.232262,0.017938,-0.157937,-0.139753,0.101726,0.331944,-0.057276,0.682883,0.070506,-0.100740,0.062554,-0.130898,-0.004695,0.105886,0.010592,-0.148630) * L2_1 + mat4(-0.135806,-0.088279,0.052228,0.170859,-0.192142,0.034914,0.041880,-0.238867,0.055685,0.197795,0.424554,0.331747,0.185409,-0.150949,0.038328,0.076548) * L2_2 + mat4(0.108737,0.011523,-0.182731,0.111780,0.264966,0.050451,0.088643,0.317874,0.110819,-0.357431,0.334323,0.190985,0.076275,0.232812,-0.106268,-0.036428) * L2_3 + mat4(-0.147083,0.092097,0.032956,-0.055453,0.110593,0.109079,0.208308,-0.010044,-0.123888,-0.183382,-0.079182,-0.108026,-0.230515,-0.446645,-0.101140,-0.158282) * L2_4 + mat4(0.427083,0.426566,-0.375543,0.603913,-0.153977,-0.004987,0.099936,-0.019630,0.369581,0.138366,-0.218182,-0.153745,-0.109879,0.348722,-0.082763,0.076344) * L2_5 + mat4(0.397040,-0.442207,0.307045,-0.248222,0.717275,0.058749,0.301864,0.256686,0.131963,0.099169,0.077742,-0.035334,-0.375329,-0.534863,0.160640,0.013947) * L2_6 + mat4(-0.061521,0.097898,-0.091270,-0.148859,0.105242,0.129193,0.057156,0.073537,0.047649,0.040988,0.113104,0.030323,-0.162662,0.085804,0.292588,-0.014919) * L2_7 + mat4(0.034036,0.327007,-0.107124,-0.138408,0.132264,0.177432,-0.016189,-0.131294,-0.068895,-0.141538,0.151513,0.110051,0.562467,-0.211440,0.095873,-0.142870) * L2_8 + mat4(-0.417055,0.125092,-0.185035,0.586341,-0.004411,-0.366245,0.112664,-0.056965,-0.071760,0.214954,-0.325519,-0.025047,0.111003,0.082907,-0.056844,0.051806) * L2_9 + mat4(0.160257,-0.057994,-0.037217,-0.241380,0.065771,-0.038157,-0.072667,0.023326,-0.034824,0.190294,-0.188358,0.132043,-0.186902,-0.182867,0.066119,-0.150045) * L2_10 + mat4(-0.102570,0.033129,-0.163157,0.262990,-0.077329,-0.098459,-0.054431,0.668537,0.056798,0.042586,0.000752,-0.167635,-0.441808,-0.258732,0.131924,-0.343766) * L2_11 + mat4(0.043876,-0.090687,0.216201,-0.156205,-0.271826,0.006357,0.220324,-0.285323,0.110429,0.456371,-0.048358,0.172854,-0.285658,0.069808,-0.008153,0.160677) * L2_12 + mat4(0.042045,0.014839,-0.028930,0.130864,0.097336,0.063424,-0.096025,0.169220,-0.272559,0.523536,0.009379,-0.024693,-0.191635,-0.026178,-0.067869,-0.245103) * L2_13 + mat4(-0.118674,0.080236,-0.188964,-0.088387,-0.014606,-0.054917,-0.119620,0.098907,0.218099,-0.223581,0.030355,0.156724,-0.305861,-0.377267,0.224086,-0.776637) * L2_14 + mat4(0.288845,-0.212571,0.008904,-0.059709,0.100058,-0.101712,-0.094294,0.037156,0.013628,-0.024146,-0.107784,-0.135468,0.267446,0.210915,-0.028824,-0.075414) * L2_15 + vec4(0.202178,1.040747,-1.022517,0.738953)));\n    return L3_3;\n}\nelse if(BlockIndex == 4)\n{\nvec4 L3_4 = sin((mat4(0.017223,-0.037766,-0.206047,-0.110636,0.180426,0.368524,0.148123,0.264856,-0.042011,-0.074933,-0.094277,-0.092049,-0.305360,-0.239889,0.120491,0.025663) * L2_0 + mat4(0.056245,-0.034255,-0.195371,0.019755,-0.456288,-0.044919,0.157659,-0.080809,-0.032735,0.118172,0.070061,-0.003033,-0.230925,0.189728,0.169166,0.112797) * L2_1 + mat4(-0.029814,0.056517,0.177095,-0.354267,0.238315,0.000855,-0.015271,-0.127168,-0.335310,0.331880,0.000150,-0.012293,-0.062329,-0.030200,0.009230,-0.073042) * L2_2 + mat4(0.031057,-0.061188,-0.075398,0.110297,-0.183967,0.184429,0.220142,0.087155,-0.264923,-0.105763,-0.133886,0.272284,-0.120958,-0.188281,0.017880,-0.061642) * L2_3 + mat4(-0.043465,0.187663,-0.063532,0.071210,-0.067418,0.221875,0.140221,-0.040321,-0.040501,0.144108,-0.132121,-0.283568,0.066107,0.193573,0.304573,-0.000965) * L2_4 + mat4(-0.202114,-0.497701,-0.242985,0.054021,0.166863,0.019368,-0.147815,-0.175896,-0.092210,0.203398,0.251137,0.197170,-0.000623,0.006301,0.034199,0.231174) * L2_5 + mat4(-0.051382,-0.055640,0.175841,-0.146259,0.226676,-0.255391,0.022690,0.373920,0.124850,0.199375,-0.053446,-0.018167,0.142367,0.110792,-0.094474,-0.137113) * L2_6 + mat4(0.226931,0.045715,-0.163027,-0.019181,-0.100302,-0.169849,0.031387,-0.296429,-0.179641,-0.122642,-0.039561,-0.297928,0.001421,-0.016994,0.034859,-0.196820) * L2_7 + mat4(-0.086814,-0.023404,0.095782,0.240789,0.267480,-0.167217,0.087913,-0.135027,0.024990,0.208270,-0.029752,-0.258992,-0.398716,0.596183,0.170022,-0.558038) * L2_8 + mat4(-0.252176,0.005058,-0.142106,0.287699,0.133169,-0.280875,0.018838,-0.065681,-0.173861,-0.223481,0.045463,0.210130,-0.175982,0.014752,0.295853,-0.169618) * L2_9 + mat4(-0.250475,-0.037985,0.311783,0.063605,0.110973,0.114519,0.008221,-0.042391,0.036116,-0.191514,-0.276462,0.253290,0.187735,-0.016140,0.084918,-0.057252) * L2_10 + mat4(-0.459492,0.115028,-0.221068,0.031426,-0.415206,-0.060876,0.044288,0.048754,0.026388,-0.045852,-0.032356,0.370789,0.399441,0.020559,-0.034568,-0.264428) * L2_11 + mat4(0.012133,0.065196,0.002925,-0.099805,0.135539,-0.114608,0.019680,-0.212946,-0.076631,0.037763,0.064654,0.353101,-0.053980,-0.047757,0.223111,-0.004894) * L2_12 + mat4(-0.256210,0.152597,0.133436,0.044524,-0.174289,0.051470,0.107200,0.087407,-0.044604,0.120839,0.106984,0.341143,0.043854,-0.015054,0.028880,-0.064291) * L2_13 + mat4(0.100288,0.044080,-0.384251,-0.197819,0.001187,0.035346,0.078339,0.224890,-0.054402,0.011184,0.142220,-0.089500,0.596489,-0.037111,-0.027050,-0.425458) * L2_14 + mat4(0.130574,-0.007075,0.080169,0.289282,-0.181516,-0.329553,0.085166,-0.019797,-0.038316,0.168137,0.000992,0.086018,-0.222222,0.162575,0.227338,-0.420537) * L2_15 + vec4(0.555731,-0.496630,-0.439655,-0.160315)));\n    return L3_4;\n}\nelse if(BlockIndex == 5)\n{\nvec4 L3_5 = sin((mat4(0.174089,0.016206,-0.090273,-0.181798,-0.303723,-0.149637,0.105523,-0.063905,0.020473,-0.037096,-0.078959,-0.025714,0.128634,-0.588767,0.285449,0.662793) * L2_0 + mat4(-0.072150,0.007429,-0.009683,-0.169840,0.219153,0.283092,-0.375559,0.098649,-0.033844,0.014145,0.111043,0.036095,0.063476,0.072650,-0.184327,0.048252) * L2_1 + mat4(0.019379,0.195609,-0.160008,-0.193827,-0.000309,-0.041778,0.159063,-0.088367,0.065297,-0.031806,0.302269,-0.155543,0.215278,0.129177,0.038381,-0.016535) * L2_2 + mat4(-0.102052,0.002259,0.100046,0.122242,0.015005,-0.099727,0.255847,0.326477,0.014880,0.148611,-0.026034,-0.126513,-0.237168,0.127985,-0.076115,0.022461) * L2_3 + mat4(-0.081036,0.007737,-0.077558,0.054971,-0.042246,0.144255,0.100993,-0.215098,0.146532,0.142311,-0.101103,-0.046374,-0.161356,0.125543,0.040657,0.015803) * L2_4 + mat4(0.450342,-0.456314,0.157546,0.240400,-0.184850,-0.027519,0.000055,-0.199744,-0.129803,-0.066157,0.268694,0.200760,-0.092907,-0.145946,-0.128420,0.275396) * L2_5 + mat4(0.338187,0.109962,0.207282,-0.141854,-0.445242,0.106056,0.139073,-0.097976,0.111471,0.187893,-0.196257,-0.194607,0.167183,-0.029224,-0.211099,-0.251605) * L2_6 + mat4(-0.237182,-0.158650,0.189273,-0.024544,0.441450,0.070455,-0.145088,-0.058248,0.111395,-0.027961,0.028082,0.074563,0.032823,0.080814,0.025623,-0.369596) * L2_7 + mat4(-0.108545,0.055830,0.087980,0.111486,-0.033103,-0.112706,0.202003,0.024562,0.157513,0.056233,-0.503327,-0.213144,-0.054713,0.177801,0.096017,0.365755) * L2_8 + mat4(0.006175,0.010668,-0.212979,0.105346,0.089345,-0.147458,0.011266,-0.009764,-0.065095,0.130746,-0.235218,0.255605,-0.198267,-0.142533,-0.236716,0.091638) * L2_9 + mat4(0.123392,0.299254,-0.162687,0.195372,0.074736,-0.060764,0.036286,0.223786,-0.352371,-0.010734,0.048056,0.244374,-0.098440,-0.064119,0.169039,-0.197063) * L2_10 + mat4(0.062255,0.044364,-0.182815,0.352044,0.210225,0.118237,-0.362873,-0.071747,-0.041448,-0.054583,-0.059275,0.263214,0.105394,0.163785,-0.217042,0.139512) * L2_11 + mat4(0.062502,0.032538,0.117440,-0.088181,-0.063730,-0.047336,0.031645,-0.369104,-0.096940,0.067657,0.129734,-0.107269,0.064985,-0.040482,-0.480497,-0.649591) * L2_12 + mat4(0.028246,0.144361,-0.115185,-0.059674,-0.060331,-0.046781,-0.017916,0.014463,-0.326670,0.107456,-0.035956,0.095160,0.012925,0.077973,-0.141164,-0.186640) * L2_13 + mat4(0.040749,-0.612091,0.209670,0.327416,0.105868,0.002093,-0.249474,-0.046976,-0.034742,0.080527,0.257145,0.125076,-0.044574,-0.191638,0.468285,0.067956) * L2_14 + mat4(-0.050465,0.041831,-0.109584,0.167096,-0.310223,-0.084446,0.124844,-0.157063,0.082257,-0.195686,0.063036,0.081684,0.374967,0.105186,0.202704,0.092378) * L2_15 + vec4(0.052608,0.090136,0.529319,0.378364)));\n    return L3_5;\n}\nelse if(BlockIndex == 6)\n{\nvec4 L3_6 = sin((mat4(-0.030622,0.028669,-0.124783,-0.028364,-0.190404,0.112546,0.166360,0.367860,-0.047616,-0.222688,-0.237957,-0.190115,0.440694,-0.443997,-0.353554,-0.742938) * L2_0 + mat4(-0.145847,-0.056310,0.139555,0.335871,-0.129358,-0.171207,-0.206478,-0.184858,-0.035580,0.063606,0.030783,-0.127911,-0.076836,-0.062131,-0.105142,-0.103545) * L2_1 + mat4(0.152860,0.055121,-0.196465,-0.079501,0.047252,0.231345,0.007738,0.236499,0.149163,0.173540,-0.077546,-0.227411,0.120046,0.010065,-0.097680,-0.165826) * L2_2 + mat4(-0.088400,-0.089442,-0.066983,0.142225,0.208089,0.094023,-0.167893,-0.412164,-0.647266,-0.240483,-0.128000,0.610141,0.060859,0.041870,-0.115816,0.138440) * L2_3 + mat4(-0.126948,-0.005270,0.087836,0.101641,0.049533,0.070286,-0.059135,-0.019050,0.048172,0.040866,0.105977,0.266136,-0.305360,-0.117041,0.122743,0.216341) * L2_4 + mat4(0.410828,0.193416,-0.105439,-0.252189,0.031837,0.243204,0.154234,0.258853,0.288117,0.041329,-0.014136,-0.433452,-0.101052,0.040052,0.113837,0.349261) * L2_5 + mat4(0.228120,-0.075180,-0.146893,-0.487747,0.018121,-0.056371,-0.091997,0.002610,0.030067,-0.260819,0.022593,-0.084767,-0.150118,-0.189517,0.185988,0.182483) * L2_6 + mat4(0.031768,0.227462,-0.055275,0.178758,0.041647,-0.073265,-0.093005,-0.192108,-0.148941,0.126310,0.051994,-0.182094,-0.137218,0.016103,0.143586,0.065553) * L2_7 + mat4(-0.086945,-0.034651,0.148553,-0.095039,0.083051,0.177064,-0.042894,-0.220300,-0.252091,-0.277240,-0.120774,-0.196763,0.319285,0.138538,-0.065581,0.057388) * L2_8 + mat4(-0.607711,-0.146103,-0.013665,0.330637,0.145459,0.203186,-0.088336,0.079403,-0.238430,-0.568630,-0.485826,-0.512215,0.254266,-0.429587,-0.157867,-0.011435) * L2_9 + mat4(0.054898,-0.270967,-0.152676,-0.195228,0.160123,0.080434,-0.251677,-0.268867,0.021499,0.002863,0.139032,0.193346,0.027841,0.123362,-0.014168,0.067535) * L2_10 + mat4(0.269230,-0.209605,-0.165061,-0.408523,-0.136809,-0.157391,-0.104826,-0.233106,-0.085046,0.066648,-0.001708,0.107413,-0.071133,-0.163585,-0.146517,0.331051) * L2_11 + mat4(-0.046859,0.101818,0.041631,0.014230,-0.112609,0.181434,0.188338,0.491524,-0.034196,-0.073346,0.003140,-0.117688,-0.094591,-0.272003,0.069177,0.195247) * L2_12 + mat4(-0.094780,-0.193455,0.020993,-0.020397,0.021386,-0.028544,0.005572,-0.143756,-0.183336,0.134116,0.194190,0.453623,0.087177,0.142958,0.020902,0.372875) * L2_13 + mat4(0.086762,-0.137119,-0.239149,-0.188924,-0.203487,-0.157286,0.029784,0.413380,0.066515,0.010002,-0.020181,-0.385243,-0.363276,0.275080,0.108110,0.218106) * L2_14 + mat4(0.059443,0.057866,-0.068871,-0.273480,-0.128303,0.117925,0.506025,0.472609,0.188262,0.037881,-0.015088,-0.208461,0.374445,0.209265,-0.056832,-0.304751) * L2_15 + vec4(-0.091821,0.269127,-0.044955,-0.080693)));\n    return L3_6;\n}\nelse\n{\nvec4 L3_7 = sin((mat4(-0.023262,-0.015350,-0.074827,-0.101356,-0.089960,-0.210525,-0.070814,0.062834,-0.207325,-0.009180,-0.141600,0.151119,0.246056,-0.043862,-0.185636,0.094803) * L2_0 + mat4(0.124184,0.245162,0.272866,0.016635,-0.297121,-0.212283,-0.225450,0.190521,0.043784,0.036145,-0.064325,-0.003367,-0.116520,-0.276424,-0.074043,-0.053928) * L2_1 + mat4(-0.081708,0.026143,-0.035976,0.391928,0.028088,-0.066519,0.046295,0.100038,-0.349179,-0.244522,-0.319998,0.044027,-0.084653,0.174902,-0.128353,0.068988) * L2_2 + mat4(0.050057,-0.122807,0.063885,0.010216,-0.013415,-0.156748,-0.216472,0.109662,-0.412744,0.467096,-0.049536,0.382209,0.128387,0.241080,0.094293,0.036260) * L2_3 + mat4(0.072119,-0.018687,0.053848,-0.115412,-0.076312,-0.178738,-0.186431,0.000099,-0.000024,0.145130,0.216405,-0.020027,-0.230420,-0.067788,0.160714,-0.073273) * L2_4 + mat4(-0.371473,-0.815918,-0.110837,0.446340,-0.006931,0.079722,0.065915,-0.076551,-0.133782,-0.320932,0.035234,0.030249,0.119848,-0.184650,0.121724,0.029819) * L2_5 + mat4(-0.034644,0.107106,-0.520191,0.012739,0.612800,0.367143,-0.459583,-0.193591,0.089836,0.108865,-0.204065,-0.075426,-0.128301,-0.089130,0.056499,0.032646) * L2_6 + mat4(0.019864,-0.007383,-0.020950,-0.019031,-0.135553,-0.126663,-0.088611,0.024987,-0.070457,-0.081776,-0.084895,-0.088658,-0.235747,0.319540,-0.157345,0.014335) * L2_7 + mat4(0.030406,-0.175969,-0.066004,-0.248827,0.084359,-0.114910,-0.029051,0.169939,-0.114944,-0.023919,0.331477,-0.156582,-0.198473,-0.091025,0.141491,-0.018990) * L2_8 + mat4(-0.411565,0.117958,0.365664,-0.644243,-0.033532,0.049886,-0.121334,0.066709,-0.143582,0.121944,0.067567,0.087053,-0.197286,0.401302,-0.063955,0.019162) * L2_9 + mat4(-0.028509,0.051755,-0.146117,0.081735,-0.090288,-0.008463,-0.172701,0.081532,0.082280,-0.056299,0.386814,-0.135070,-0.011691,0.100345,-0.020078,-0.055002) * L2_10 + mat4(-0.032492,-0.063622,0.057687,-0.195496,-0.099932,-0.126510,-0.099614,0.121407,-0.064235,-0.033042,0.056315,-0.136143,0.179928,0.279876,0.457559,-0.104009) * L2_11 + mat4(-0.078529,-0.109152,-0.130424,-0.053401,-0.040921,0.170985,0.233299,-0.148779,0.056306,-0.057691,-0.072601,0.118868,-0.072153,0.119466,0.013644,0.169026) * L2_12 + mat4(-0.035099,-0.105598,-0.081921,0.007652,-0.033279,-0.282090,-0.124318,-0.065054,0.131202,0.232090,-0.005103,-0.273788,0.086145,0.045429,0.137137,0.150735) * L2_13 + mat4(-0.370941,-0.309744,0.027695,0.156420,0.013777,0.194617,0.031840,0.229452,-0.040817,-0.119403,-0.164825,-0.079511,-0.040857,0.401335,0.186291,-0.206802) * L2_14 + mat4(-0.011680,-0.053056,-0.023592,-0.033972,0.042658,0.029626,0.363072,-0.191829,0.062402,0.143423,-0.083962,-0.102121,-0.190078,-0.031622,-0.117921,0.426444) * L2_15 + vec4(-0.683855,0.250459,-0.559034,-0.023307)));\n    return L3_7;\n}\n}\n\n#pragma optimize(on)\n\n\n\n\n\n\n\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n//Credit : https://www.shadertoy.com/view/Wss3Ds\n    vec3 absRayDir = abs(rayDir);\n    rayDir /= max(absRayDir.x, max(absRayDir.y, absRayDir.z));\n    int faceIndex = 0;\n    if(absRayDir.y > absRayDir.x && absRayDir.y > absRayDir.z)\n    {\n        faceIndex = 2;\n    }\n    else if(absRayDir.z > absRayDir.x && absRayDir.z > absRayDir.y)\n    {\n        faceIndex = 4;\n    }\n\n    if(rayDir[faceIndex / 2] > 0.0)\n    {\n        faceIndex |= 1;\n    }\n    if(iFrame !=0)\n    {\n    \n        if(faceIndex == 5) //_ here\n        {\n            //fragColor = GetOneFace5(fragCoord/1024.0);\n        }\n        else if(faceIndex == 4)//Actually 2 here\n        {\n            //fragColor = GetOneFace4(fragCoord/1024.0);\n        }\n        else if(faceIndex == 3)//Actually 3 here\n        {\n            fragColor = GetOneFace3(fragCoord/1024.0);\n        }\n        else if(faceIndex == 2)//Actually 3 here\n        {\n            fragColor = GetOneFace2(fragCoord/1024.0);\n        }\n    }\n    else\n    {\n        if(faceIndex == 5) //_ here\n        {\n            //fragColor = vec4(fragCoord/1024.0,0.0,0.0);\n        }\n        else if(faceIndex == 4)//Actually 2 here\n        {\n\n        }\n        else if(faceIndex == 3)//Actually 3 here\n        {\n            Point CurrentPoint;\n            int SubIndex = CoordToIndex(fragCoord);\n            vec2 SubFragCoord = CoordToLocalCoord(fragCoord);\n            int objectindex = -1;\n            if(SubFragCoord.x > 0.0 && SubFragCoord.x < 256.0 && SubFragCoord.y > 0.0 && SubFragCoord.y < 128.0)\n            {\n                CurrentPoint = LightmapToPosition_H(SubFragCoord - vec2(0.0,0.0));\n                objectindex = 0;\n            }\n            else if(SubFragCoord.x > 256.0 && SubFragCoord.x < 512.0 && SubFragCoord.y > 0.0 && SubFragCoord.y < 128.0)\n            {\n                CurrentPoint = LightmapToPosition_P(SubFragCoord - vec2(256.0,0.0));\n                objectindex = 1;\n            }\n            else if(SubFragCoord.x > 0.0 && SubFragCoord.x < 256.0 && SubFragCoord.y > 128.0 && SubFragCoord.y < 256.0)\n            {\n                CurrentPoint = LightmapToPosition_G(SubFragCoord - vec2(0.0,128.0));\n                objectindex = 2;\n            }\n            else if(SubFragCoord.x > 256.0 && SubFragCoord.x < 384.0 && SubFragCoord.y > 128.0 && SubFragCoord.y < 256.0)\n            {\n                CurrentPoint = LightmapToPosition_21(SubFragCoord - vec2(256.0,128.0));\n                objectindex = 3;\n            }\n            else if(SubFragCoord.x > 384.0 && SubFragCoord.x < 512.0 && SubFragCoord.y > 128.0 && SubFragCoord.y < 256.0)\n            {\n                CurrentPoint = LightmapToPosition_22(SubFragCoord - vec2(384.0,128.0));\n                objectindex = 4;\n            }\n            else if(SubFragCoord.x > 0.0 && SubFragCoord.x < 64.0 && SubFragCoord.y > 256.0 && SubFragCoord.y < 384.0)\n            {\n                CurrentPoint = LightmapToPosition_L(SubFragCoord - vec2(0.0,256.0));\n                objectindex = 5;\n            }\n            else if(SubFragCoord.x > 64.0 && SubFragCoord.x < 128.0 && SubFragCoord.y > 256.0 && SubFragCoord.y < 384.0)\n            {\n                CurrentPoint = LightmapToPosition_R(SubFragCoord - vec2(64.0,256.0));\n                objectindex = 6;\n            }\n            else if(SubFragCoord.x > 256.0 && SubFragCoord.x < 512.0 && SubFragCoord.y > 256.0 && SubFragCoord.y < 512.0)\n            {\n                CurrentPoint = LightmapToPosition_B(SubFragCoord - vec2(256.0,256.0));\n                objectindex = 7;\n            }\n            else if(SubFragCoord.x > 128.0 && SubFragCoord.x < 256.0 && SubFragCoord.y > 256.0 && SubFragCoord.y < 384.0)\n            {\n                CurrentPoint = LightmapToPosition_U(SubFragCoord - vec2(128.0,256.0));\n                objectindex = 8;\n            }\n            else if(SubFragCoord.x > 0.0 && SubFragCoord.x < 256.0 && SubFragCoord.y > 384.0 && SubFragCoord.y < 512.0)\n            {\n                CurrentPoint = LightmapToPosition_D(SubFragCoord - vec2(0.0,384.0));\n                objectindex = 9;\n            }\n            if(CurrentPoint.Position.w > 0.0)\n            {\n                if(objectindex == 5 || objectindex == 6 || objectindex == 7 ||\n                objectindex == 8 ||objectindex == 3 || objectindex == 4)\n                {\n                    fragColor = Lightmap_Half_LRBU22(CurrentPoint.Position.xyz, CurrentPoint.Normal.xyz, SubIndex+4);//\n                }\n                else if(objectindex == 9)\n                {\n                    fragColor = Lightmap_Half_Floor(CurrentPoint.Position.xyz, CurrentPoint.Normal.xyz, SubIndex+4);//\n                }\n                else\n                {\n                    fragColor = Lightmap_Half_HPG(CurrentPoint.Position.xyz, CurrentPoint.Normal.xyz, SubIndex+4);//\n                }\n            }\n        }\n        else if(faceIndex == 2)//Actually 3 here\n        {\n            Point CurrentPoint;\n            int SubIndex = CoordToIndex(fragCoord);\n            vec2 SubFragCoord = CoordToLocalCoord(fragCoord);\n            int objectindex = -1;\n            if(SubFragCoord.x > 0.0 && SubFragCoord.x < 256.0 && SubFragCoord.y > 0.0 && SubFragCoord.y < 128.0)\n            {\n                CurrentPoint = LightmapToPosition_H(SubFragCoord - vec2(0.0,0.0));\n                objectindex = 0;\n            }\n            else if(SubFragCoord.x > 256.0 && SubFragCoord.x < 512.0 && SubFragCoord.y > 0.0 && SubFragCoord.y < 128.0)\n            {\n                CurrentPoint = LightmapToPosition_P(SubFragCoord - vec2(256.0,0.0));\n                objectindex = 1;\n            }\n            else if(SubFragCoord.x > 0.0 && SubFragCoord.x < 256.0 && SubFragCoord.y > 128.0 && SubFragCoord.y < 256.0)\n            {\n                CurrentPoint = LightmapToPosition_G(SubFragCoord - vec2(0.0,128.0));\n                objectindex = 2;\n            }\n            else if(SubFragCoord.x > 256.0 && SubFragCoord.x < 384.0 && SubFragCoord.y > 128.0 && SubFragCoord.y < 256.0)\n            {\n                CurrentPoint = LightmapToPosition_21(SubFragCoord - vec2(256.0,128.0));\n                objectindex = 3;\n            }\n            else if(SubFragCoord.x > 384.0 && SubFragCoord.x < 512.0 && SubFragCoord.y > 128.0 && SubFragCoord.y < 256.0)\n            {\n                CurrentPoint = LightmapToPosition_22(SubFragCoord - vec2(384.0,128.0));\n                objectindex = 4;\n            }\n            else if(SubFragCoord.x > 0.0 && SubFragCoord.x < 64.0 && SubFragCoord.y > 256.0 && SubFragCoord.y < 384.0)\n            {\n                CurrentPoint = LightmapToPosition_L(SubFragCoord - vec2(0.0,256.0));\n                objectindex = 5;\n            }\n            else if(SubFragCoord.x > 64.0 && SubFragCoord.x < 128.0 && SubFragCoord.y > 256.0 && SubFragCoord.y < 384.0)\n            {\n                CurrentPoint = LightmapToPosition_R(SubFragCoord - vec2(64.0,256.0));\n                objectindex = 6;\n            }\n            else if(SubFragCoord.x > 256.0 && SubFragCoord.x < 512.0 && SubFragCoord.y > 256.0 && SubFragCoord.y < 512.0)\n            {\n                CurrentPoint = LightmapToPosition_B(SubFragCoord - vec2(256.0,256.0));\n                objectindex = 7;\n            }\n            else if(SubFragCoord.x > 128.0 && SubFragCoord.x < 256.0 && SubFragCoord.y > 256.0 && SubFragCoord.y < 384.0)\n            {\n                CurrentPoint = LightmapToPosition_U(SubFragCoord - vec2(128.0,256.0));\n                objectindex = 8;\n            }\n            else if(SubFragCoord.x > 0.0 && SubFragCoord.x < 256.0 && SubFragCoord.y > 384.0 && SubFragCoord.y < 512.0)\n            {\n                CurrentPoint = LightmapToPosition_D(SubFragCoord - vec2(0.0,384.0));\n                objectindex = 9;\n            }\n            if(CurrentPoint.Position.w > 0.0)\n            {\n                if(objectindex == 5 || objectindex == 6 || objectindex == 7 ||\n                objectindex == 8 ||objectindex == 3 || objectindex == 4)\n                {\n                    fragColor = Lightmap_Half_LRBU22(CurrentPoint.Position.xyz, CurrentPoint.Normal.xyz, SubIndex);//\n                }\n                else if(objectindex == 9)\n                {\n                    fragColor = Lightmap_Half_Floor(CurrentPoint.Position.xyz, CurrentPoint.Normal.xyz, SubIndex);//\n                }\n                else\n                {\n                    fragColor = Lightmap_Half_HPG(CurrentPoint.Position.xyz, CurrentPoint.Normal.xyz, SubIndex);//\n            \n                }\n            }\n        }\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//YCZ:\n//Version2 - 2022.06.27(Tokyo time)\n\n//*************About Setting******************//\n//No need additional setting. Time axis is as same as the offical one\n\n//*************About Exposure******************//\n//Exposure is under Image\n\n//*************About Time******************//\n//If time shift is needed for measurement, plz replace all iTime variable with desired time value(included in Buffer A and Image)\n\n//*************About Measurement******************//\n//SSIM data example(under exposure of 2):\n//Frame0(t = 0.0) ssim 0.961\n//Frame1(t = 1.0) ssim 0.963\n//Frame2(t = 5.0) ssim 0.946\n\n//(idk how my render will be measured with gt.\n//And this Shader will take around 6 seconds to compile (gtx 2070, cpu i7 11xxxx)\n//In order to avoid problems such as graphics card model browser model conflict or sth.\n//if the value is significantly lower than this value means that this shader is not compiled correctly, \n//please change the browser, \n//thank you very much ^_^\nvec4 GetOneFace2(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(uv.x,1.0 - uv.y)-1.0,-1.0f).xzy);\n}\nvec4 GetOneFace3(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(uv.x,uv.y)-1.0,1.0f).xzy);\n}\nvec4 GetOneFace4(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(1.0-uv.x,1.0-uv.y)-1.0,-1.0f));\n}\nvec4 GetOneFace5(vec2 uv)\n{\n    return texture(iChannel0, vec3(2.0*vec2(uv.x,1.0-uv.y)-1.0,1.0f));\n}\nHidden GetHidden(vec2 FragCoord)\n{\n    Hidden R;\n    vec2 LocalUV = FragCoord / 1024.0;\n    R.H_0 = GetOneFace2(LocalUV);\n    R.H_1 = GetOneFace2(LocalUV + vec2(0.5,0.0));\n    R.H_2 = GetOneFace2(LocalUV + vec2(0.0,0.5));\n    R.H_3 = GetOneFace2(LocalUV + vec2(0.5,0.5));\n    R.H_4 = GetOneFace3(LocalUV);\n    R.H_5 = GetOneFace3(LocalUV + vec2(0.5,0.0));\n    R.H_6 = GetOneFace3(LocalUV + vec2(0.0,0.5));\n    R.H_7 = GetOneFace3(LocalUV + vec2(0.5,0.5));\n    return R;\n}\n\n#define FULL_SCENE\n#define NUM_SAMPLES 1\n\n\n#define INFINITY 9999999.0 // sorry, webgl doesn't allow to use proper float infinity :(\n#define PI 3.141592653589\n\n#ifdef FULL_SCENE\n#define NUM_BOUNCES 8\n#else\n#define NUM_BOUNCES 2\n#endif\n\n#define MAT_LEFT        0\n#define MAT_RIGHT       1\n#define MAT_CEILING     2\n#define MAT_FLOOR       3\n#define MAT_BACK        4\n#define MAT_H           5\n#define MAT_P           6\n#define MAT_G           7\n#define MAT_2           8\n#define MAT_LIGHT0      9\n#define MAT_LIGHT1      10\n#define MAT_LIGHT2      11\n#define MAT_LIGHT3      12\n#define MAT_LIGHT4      13\n#define MAT_LIGHT5      14\n#define MAT_LIGHT6      15\n#define MAT_LIGHT7      16\n#define MAT_LIGHT8      17\n\n#define USE_Bake\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\nstruct MaterialSample\n{\n\tvec3 color;\n\tfloat roughness;\n\tbool is_light;\n};\n\nint seed;\nint flat_idx;\n\nconst float cube_light_size = 0.08;\nconst vec4 cube_light_pos[4] = vec4[4](\n\t\tvec4(  -0.9, -1.0 + cube_light_size * 0.495,  0.6, 0.4),\n\t\tvec4(  0.3, -1.0 + cube_light_size * 0.495,  0.2, 0.8),\n\t\tvec4(  1.0 - 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -1.0 + 5.0 * cube_light_size, 0.0),\n\t\tvec4(  -1.0 + 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -0.6, 0.0)\n\t\t);\n\nconst vec3 light_color[4] = vec3[4](\n\t\tvec3(5),\n\t\tvec3(5),\n\t\tvec3(80.0, 50, 30),\n\t\tvec3(30, 30, 80.0)\n\t\t);\n\n\n// H\nconst vec4 coordinates_H[3] = vec4[3](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.427, 0.000, 0.627, 0.750),\nvec4(0.116, 0.310, 0.516, 0.450));\n// P\nconst vec4 coordinates_P[4] = vec4[4](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.400, 0.360, 0.540, 0.675),\nvec4(0.044, 0.288, 0.471, 0.428),\nvec4(0.000, 0.610, 0.471, 0.750));\n// G\nconst vec4 coordinates_G[6] = vec4[6](\nvec4(0.000, 0.060, 0.200, 0.670),\nvec4(0.425, 0.060, 0.625, 0.265),\nvec4(0.425, 0.520, 0.625, 0.670),\nvec4(0.100, 0.000, 0.625, 0.140),\nvec4(0.315, 0.265, 0.625, 0.405),\nvec4(0.077, 0.610, 0.550, 0.750));\n// 2\nconst vec4 coordinates_2[5] = vec4[5](\nvec4(0.000, 0.000, 0.140, 0.365) * 0.5,\nvec4(0.474, 0.365, 0.614, 0.680) * 0.5,\nvec4(0.044, 0.000, 0.614, 0.140) * 0.5,\nvec4(0.044, 0.288, 0.544, 0.428) * 0.5,\nvec4(0.044, 0.610, 0.544, 0.750) * 0.5);\n\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\nvoid\nencrypt_tea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\nvec2\nget_random()\n{\n  \tuvec2 arg = uvec2(flat_idx, seed++);\n  \tencrypt_tea(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\nmat4\nlook_at(vec3 eye, vec3 center, vec3 up)\n{\n\tmat4 ret;\n\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, normalize(up)));\n\tvec3 u = cross(s, f);\n\n\tret[0][0] = s[0];\n\tret[1][0] = s[1];\n\tret[2][0] = s[2];\n\n\tret[0][1] = u[0];\n\tret[1][1] = u[1];\n\tret[2][1] = u[2];\n\n\tret[0][2] = -f[0];\n\tret[1][2] = -f[1];\n\tret[2][2] = -f[2];\n\n\tret[0][3] = ret[1][3] = ret[2][3] = 0.0;\n\n\tret[3][0] = -dot(s, eye);\n\tret[3][1] = -dot(u, eye);\n\tret[3][2] =  dot(f, eye);\n\n\tret[3][3] = 1.0;\n\treturn ret;\n}\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) / denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\nfloat intersect_box(Ray ray, out vec3 normal, vec3 position_min, vec3 position_max)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(position_min, position_max), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\n\t\tvec3 center = (position_min + position_max) * 0.5;\n\n\t\tnormal = p - center;\n\n\t\tvec3 an = abs(normal) / (position_max - position_min);\n\n\t\tif(an.x > an.y && an.x > an.z) {\n\t\t\tnormal = vec3(normal.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t}\n\t\tif(an.y > an.x && an.y > an.z) {\n\t\t\tnormal = vec3(0, normal.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\tif(an.z > an.x && an.z > an.y) {\n\t\t\tnormal = vec3(0, 0, normal.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\nfloat intersect_simple(Ray ray, inout vec3 p, inout vec3 normal, inout vec3 color, inout int faceid)\n{\n\tfloat t_min = INFINITY;\n\n\tint material = -1;\n    int faceindex = -1;\n    vec2 CurrentHitHiddenUV = vec2(-1.0,0.0);\n\tfor(int i = 0; i < coordinates_H.length(); i++) \n    {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.35);\n\t\tray_tmp.origin -= vec3(-0.9, -1, 0.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_H[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_H[i].zw - coordinates_H[i].xy, 0.15);\n        //intersect_box(Ray ray, out vec3 normal, vec3 position_min, vec3 position_max)\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_H;\n            CurrentHitHiddenUV = PositionToLightmap_H(ray_tmp, t, normal_tmp, i);\n            faceindex = 0 + i * 6 + NormalToIndex(normal_tmp);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_P.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.75);\n\t\tray_tmp.origin -= vec3(-0.28, -1, 0.2);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_P[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_P[i].zw - coordinates_P[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_P;\n            CurrentHitHiddenUV = PositionToLightmap_P(ray_tmp, t, normal_tmp, i) + vec2(256.0,0.0);\n            faceindex = 3 * 6 + i * 6 + NormalToIndex(normal_tmp);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_G.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.4);\n\t\tray_tmp.origin -= vec3(0.35, -1, -0.20);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_G[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_G[i].zw - coordinates_G[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_G;\n            CurrentHitHiddenUV = PositionToLightmap_G(ray_tmp, t, normal_tmp, i) + vec2(0.0,128.0);\n            faceindex = 7 * 6 + i * 6 + NormalToIndex(normal_tmp);\n\t\t}\n\t}\n\n#ifdef FULL_SCENE\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.1, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n            CurrentHitHiddenUV = PositionToLightmap_21(ray_tmp, t, normal_tmp, i) + vec2(256.0,128.0);\n            faceindex = 13 * 6 + i * 6 + NormalToIndex(normal_tmp);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.45, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n            CurrentHitHiddenUV = PositionToLightmap_22(ray_tmp, t, normal_tmp, i) + vec2(384.0,128.0);\n            faceindex = 18 * 6 + i * 6 + NormalToIndex(normal_tmp);\n\t\t}\n\t}\n#endif\n\n\n\t// cube light sources\n\tfor(int i = 0; i < cube_light_pos.length(); i++) {\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\t//mat4 r = rotate_y(scene_time);\n\t\tmat4 r = rotate_y(-cube_light_pos[i].w);\n\t\tray_tmp.origin -= cube_light_pos[i].xyz;\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp,\n\t\t\t\tvec3(-cube_light_size * 0.5),\n\t\t\t\tvec3(cube_light_size * 0.5));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_LIGHT0 + i;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n            faceindex = 23 * 6 + i;\n            CurrentHitHiddenUV.x = 1.0;\n\t\t}\n\t}\n\t// left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n                faceindex = 23 * 6 + 4 + 0;\n\n\t\t\t\tmaterial = MAT_LEFT;\n                CurrentHitHiddenUV = PositionToLightmap_L(p) + vec2(0.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\t// right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n                faceindex = 23 * 6 + 4 + 1;\n\n\t\t\t\tmaterial = MAT_RIGHT;\n                CurrentHitHiddenUV = PositionToLightmap_R(p) + vec2(64.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\t// floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n                faceindex = 23 * 6 + 4 + 2;\n\t\t\t\tmaterial = MAT_FLOOR;\n                CurrentHitHiddenUV = PositionToLightmap_D(p) + vec2(0.0,384.0);\n\t\t\t}\n\t\t}\n\t}\n\t// ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_CEILING;\n\n\t\t\t\tt_min = t;\n                faceindex = 23 * 6 + 4 + 3;\n                CurrentHitHiddenUV = PositionToLightmap_U(p) + vec2(128.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\t// back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_BACK;\n\n\t\t\t\tt_min = t;\n                faceindex = 23 * 6 + 4 + 4;\n                CurrentHitHiddenUV = PositionToLightmap_B(p) + vec2(256.0,256.0);\n\t\t\t}\n\t\t}\n\t}\n\tnormal = normalize(normal);\n    if(CurrentHitHiddenUV.x > 0.0)\n    {\n        vec3 albedo;\n        switch(material) \n        {\n\tcase MAT_LEFT   : albedo = vec3(0.9, 0.1, 0.1); break;\n\tcase MAT_RIGHT  : albedo = vec3(0.1, 0.9, 0.1); break;\n\tcase MAT_CEILING: albedo = vec3(0.7, 0.7, 0.7); break;\n\tcase MAT_FLOOR  : albedo = vec3(0.7, 0.7, 0.7); break;\n\tcase MAT_BACK   : albedo = vec3(0.7, 0.7, 0.7); break;\n\tcase MAT_H      : albedo = vec3(1.0, 0.0, 0.0); break;\n\tcase MAT_P      : albedo = vec3(0.0, 0.7, 0.7); break;\n\tcase MAT_G      : albedo = vec3(0.1, 0.1, 0.7); break;\n\tcase MAT_2      : albedo = vec3(0.8, 0.8, 0.8); break;\n\tdefault         : albedo = light_color[material - MAT_LIGHT0];color = albedo;return t_min; break;\n\t    }\n        Hidden hidden = GetHidden(CurrentHitHiddenUV);\n        if(material == MAT_LEFT || material == MAT_RIGHT || \n        material == MAT_CEILING || material == MAT_BACK || material == MAT_2)\n        {\n            color = Lightmap_Render_LRBU22(ray.dir, hidden);\n            color = color + vec3(1.0,1.0,1.0);\n            color = exp(color * 3.3994);\n            color = color - vec3(1.0,1.0,1.0);\n            color = color / 10.0;\n            color = color * (albedo + vec3(0.5,0.5,0.5));\n        }\n        else if(material == MAT_FLOOR)\n        {\n            color = Lightmap_Render_Floor(ray.dir, hidden);\n            color = color + vec3(1.0,1.0,1.0);\n            color = exp(color * 3.71775);\n            color = color - vec3(1.0,1.0,1.0);\n            color = color / 10.0;\n            color = color * (albedo + vec3(0.5,0.5,0.5));\n        }\n        else\n        {\n            color = Lightmap_Render_HPG(ray.dir, hidden);\n            color = color + vec3(1.0,1.0,1.0);\n            color = exp(color * 4.636095);\n            color = color - vec3(1.0,1.0,1.0);\n            color = color / 10.0;\n            color = color * (albedo + vec3(0.5,0.5,0.5));\n        }\n    }\n    faceid = faceindex;\n\treturn t_min;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tseed = iFrame * NUM_SAMPLES;\n\tflat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n\n\tvec2 p = fragCoord.xy / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n\n\t//vec3 cam_center = vec3(0, 0, 3.0);\n\tvec3 cam_center = vec3(sin(iTime) * 0.25, sin(iTime * 0.7345) * 0.4 + 0.2, 6.0);\n\tvec3 cam_target = vec3(0, -0.1, 0);\n\n\tmat4 cam = transpose(look_at(cam_center, cam_target, vec3(0, 1, 0)));\n\n\tvec3 s = vec3(0);\n    float eigen = -100.0;\n    if(iFrame == 0)\n    {\n        return;\n    }\n    else\n    {\n\t\tRay ray;\n\t\tray.origin = cam_center;\n\t\tvec3 ray_dir = normalize(vec3(p, -2.5));\n\t\tray.dir = vec3(cam * vec4(ray_dir, 0.0));\n        vec3 c;\n        vec3 normal;\n        vec3 position;\n        int faceindex;\n        float depth = intersect_simple(ray, position, normal, c, faceindex);\n        //depth = depth * 0.1;//make sure 0~1\n        eigen = float(faceindex + 1)+0.1;//faceindex == -1 ? 0.999 : float(1 + faceindex) + depth;\n\t\ts = c;\n    }\n\tfragColor = vec4(s,eigen);\n}", "buffer_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scfR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1008, 1008, 1035, 1035, 1115], [1116, 1116, 1143, 1143, 1216], [1217, 1217, 1244, 1244, 1322], [1323, 1323, 1350, 1350, 1423], [1424, 1424, 1458, 1458, 1895], [4078, 4078, 4119, 4119, 4472], [4474, 4474, 4509, 4509, 4865], [4867, 4867, 4886, 4886, 4997], [4999, 4999, 5045, 5045, 5497], [5499, 5499, 5584, 5584, 5909], [5911, 5911, 5945, 5945, 5981], [5983, 5983, 6051, 6051, 6181], [6183, 6183, 6268, 6268, 6876], [6877, 6877, 6961, 6961, 15053], [15055, 15055, 15197, 15197, 23380], [23409, 23409, 23434, 23434, 23473], [23475, 23475, 23530, 23530, 28248]]}
{"id": "Nddfz7", "name": "Simple Voronoi shaded", "author": "marvpaul", "description": "Simple Voronoi shaded", "tags": ["voronoi"], "likes": 1, "viewed": 360, "published": 3, "date": "1656259722", "time_retrieved": "2024-07-30T16:43:01.449195", "image_code": "vec3 randColor(int number){\n    return fract(sin(vec3(number+1)*vec3(12.8787, 1.97, 20.73739)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0); \n    \n    int points_length = 6; \n    vec2 points_array[6] = vec2[6](\n        vec2(0.1+0.2*sin(iTime), 0.2), \n        vec2(0.3, 0.5+0.1*cos(iTime)),\n        vec2(0.9, 0.6),\n        vec2(0.7+0.1*sin(iTime), 0.1),        \n        vec2(0.2, 0.5),\n        vec2(0.1, 0.7)\n    ); \n    \n    float dmin = 1000.0; \n    int point = 0;\n    \n    for(int i = 0; i < points_length; i++){\n        vec2 uv_rounded = floor(uv*100.0)/100.0;\n        vec2 point_rounded = floor(points_array[i]*100.0)/100.0;\n        \n        if(uv_rounded == point_rounded){\n            col = vec3(1); \n        }\n        if(length(points_array[i] - uv) < dmin){\n            point = i; \n            dmin = length(points_array[i] - uv); \n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(randColor(point)-dmin+col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nddfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 98], [101, 101, 158, 208, 1068]]}
{"id": "Nstfz7", "name": "another way x-0002", "author": "jorge2017a2", "description": "another way x-0001", "tags": ["anotherwayx0001"], "likes": 12, "viewed": 254, "published": 3, "date": "1656258106", "time_retrieved": "2024-07-30T16:43:02.872390", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n///another way x-0001---\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n///Tunnel - exact   (https://www.shadertoy.com/view/flSSDy)\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{   p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\nfloat fun(float x, float z)\n{ return 7.0 * sin(z * 0.15);}\n//{ return 7.0 * sin(z * 0.15)+0.5*sin(z * 0.15*2.0);}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    vec3 p0=p;\n    p.z= opRep1D(p.z, 42.0 );\n    vec3 piso=tex3D(iChannel0, p/16., vec3(1.0,1.0,1.0))*0.5;\n    float f1=fun(p.x, p.z);\n    vec3 pos=vec3(0.0,f1,0.0);\n\n    float d1= sdBox( p-pos, vec3(10.0,5.0,30.0) ); //piso\n    vec3 pnew=p-pos;\n    p.x=abs(pnew.x)-12.0;\n    float d1a= sdBox(p-pos-vec3(0.0,5.0,0.0), vec3(0.5,15.0,30.0) ); //pared 1\n    \n    vec3 p2=pnew-vec3(0.0,10.0,0.0);\n    p2.x=abs(pnew.x)-10.0;\n    float d2= sdBox( p2, vec3(2.0,5.0,30.0) ); //pared 2\n    d2+=mod(piso.y+ piso.y* sin(piso.z),4.0);\n    d1+=1.5*sin(mod(piso.y,0.5))*piso.x;\n    \n    //p=p0;\n    vec2 p2n=p.yz-vec2(10.0,0.0)-pos.yz;\n    vec2 p3n=p.yz-vec2(10.0,-10.0)-pos.yz;\n    p2n=rotatev2(p2n, 1.57);\n    p3n=rotatev2(p3n, 1.57);\n    \n    float d3= sdTunnel(p2n, vec2(3.0,5.0) );\n    float d3b= sdTunnel(p3n, vec2(1.5,3.0) );\n     d2= Difference(d2, d3);\n     d2= Difference(d2, d3b);\n    \n    res =opU2(res, vec2(d1,101.0)); //piso\n    res =opU2(res, vec2(d2,8.0));\n    res =opU2(res, vec2(d1a,9.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a,b,c,d;\n    a = vec3(0.2); b = vec3(0.5);c = vec3(1.0);d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 ){ col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ){  col= pattern( p.xz );\n        return tex3D(iChannel0, p/32., nor)*3.0*col; \n    }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n    if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n    if (id_color==57) {return pattern( p.xz );}\n    if (id_color>=100 )\n    { return  getColorTextura( p, nor,id_color); }  \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;    \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\n//by Shane\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, 25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 )*(0.5+0.5*sin(t)) ; \n  \n  \n  vec3 ro=vec3(0.0,10.0,-25.0+t*1.2);\n   ro.z=opRep1D(ro.z, 30.5*10.0 );\n   float f1= fun(ro.x, ro.z);\n   vec3 pos=vec3(0.0,f1,0.0);\n   //vec3 pos=vec3(f1.x,f1.y,0.0);\n   ro.y+=pos.y; \n   \n   //------\n   ///Referencia Shane    \n   //https://www.shadertoy.com/view/MdVSDh\n   // Camera Setup.\n\tvec3 camPos = ro; // Camera position, doubling as the ray origin.\n\tvec3 lookAt = camPos + vec3(0.0, 0.0, +25.0);  // \"Look At\" position.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\t//lookAt.xy += path(lookAt.z);\n    lookAt.y += fun(lookAt.x,lookAt.z);\n\tcamPos.y += fun(camPos.x,camPos.z);\n\t\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/2.0; // FOV - Field of view.\n    \n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    \n    vec3 up = cross(forward, right);\n    \n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\t///rd.xy = rot2( path(lookAt.z).x/24. )*rd.xy;\n    \n    //------\n    /*\n   float dc=20.0*sin(t0*0.5); //cambio de camara\n   if( dc>0.0)\n     {   ro+=vec3(-4.0,0.0,0.0);\n         rd=rotate_y(rd, radians(90.0));\n     }\n     */\n   //else\n   //    rd.xy = rot2( fun(lookAt.x,lookAt.z)/24. )*rd.xy;\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n   vec3 col= Render( ro,  rd);\n   fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0)   //10\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nstfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[486, 486, 518, 518, 602], [603, 603, 647, 647, 674], [675, 675, 715, 715, 742], [743, 743, 788, 788, 816], [818, 818, 854, 854, 899], [901, 901, 935, 935, 1031], [1032, 1032, 1066, 1066, 1157], [1158, 1158, 1192, 1192, 1283], [1285, 1285, 1319, 1319, 1410], [1412, 1412, 1437, 1437, 1456], [1457, 1457, 1482, 1482, 1501], [1502, 1502, 1538, 1538, 1566], [1628, 1628, 1669, 1669, 1934], [1936, 1936, 1965, 1965, 1994], [2051, 2051, 2076, 2076, 3121], [3123, 3123, 3147, 3147, 3309], [3311, 3311, 3359, 3359, 3638], [3640, 3640, 3684, 3684, 4005], [4007, 4007, 4044, 4044, 4301], [4303, 4303, 4326, 4326, 4465], [4467, 4467, 4557, 4557, 5506], [5508, 5556, 5584, 5584, 5772], [5774, 5774, 5823, 5823, 6003], [6005, 6005, 6037, 6037, 6234], [6236, 6236, 6306, 6306, 6523], [6525, 6525, 6552, 6552, 6641], [6643, 6643, 6701, 6701, 6749], [6751, 6751, 6774, 6774, 6886], [6888, 6888, 6919, 6919, 7543], [7546, 7709, 7730, 7730, 7796], [7799, 7799, 7856, 7856, 9682]]}
{"id": "fstfRM", "name": "Quasicrystalline Fun", "author": "mla", "description": "Forked from original shader by @charmless. Mouse adds extra layer of waves.\n\n[url]http://mainisusuallyafunction.blogspot.ca/2011/10/quasicrystals-as-sums-of-waves-in-plane.html[/url]", "tags": ["quasicrystals"], "likes": 10, "viewed": 359, "published": 3, "date": "1656246779", "time_retrieved": "2024-07-30T16:43:03.799910", "image_code": "const float PI = 3.14159265359;\nint AA = 2;\nfloat zoom = 100.0;\nfloat cycle = 60.0;\nfloat maxlayers = 20.0;\nfloat time;\n\nfloat wave(float theta, vec2 p) {\n\treturn 0.5+0.5*cos(dot(p,vec2(cos(theta),sin(theta))));\n}\n\nvec3 quasicrystal(vec2 p, float layers) {\n    float sum = 0.;\n    for (float theta = 0.0; theta < PI; theta += PI/layers) {\n      float k = smoothstep(0.0,1.0,min((PI-theta)*layers/PI,1.0));\n      sum += k*wave(theta, p);\n    }\n    if (iMouse.z > 0.0) {\n      vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n      sum += length(m)*wave(atan(m.y,m.x),p);\n    }\n    vec3 t = (1.0+0.5*cos(0.5*time))*sum*vec3(2,3,5);\n    t /= layers;\n    // Sawtooth\n    return fract(t);\n    // Triangle wave alternative coloring\n    t *= 2.0;\n    t = mod(t,2.0);\n    t = min(t,2.0-t);\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec3 col = vec3(0);\n  time = iTime;\n  float t = mod(time/cycle,2.0);\n  t = min(t,2.0-t);\n  float layers = 3.0+(maxlayers-3.0)*smoothstep(0.0,1.0,t);\n  if (key(CHAR_X)) layers = floor(layers);\n  if (key(CHAR_Z)) zoom *= 2.0;\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord.xy+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      uv *= zoom;\n      col += quasicrystal(uv,layers);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.8));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 154, 154, 213], [215, 215, 256, 256, 803], [805, 805, 857, 857, 1384]]}
{"id": "fsdBzM", "name": "Bad stackblur on the GPU", "author": "LoganDark", "description": "Fragment shaders can't keep a running tally unfortunately! :(", "tags": ["blur", "stackblur"], "likes": 0, "viewed": 170, "published": 3, "date": "1656246336", "time_retrieved": "2024-07-30T16:43:04.875035", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uvec2 start = uvec2(iResolution.xy * vec2(1.0/8.0));\n    uvec2 end = uvec2(iResolution.xy * vec2(7.0/8.0));\n    uvec2 ufragCoord = uvec2(fragCoord);\n    vec2 frac = mod(fragCoord, vec2(1));\n\n    if (all(greaterThanEqual(ufragCoord, start)) && all(lessThan(ufragCoord, end))) {\n        uvec2 radius = RADIUS;\n        uvec2 leading = min(radius, ufragCoord - start);\n        uvec2 trailing = min(radius, end - ufragCoord);\n\n        vec4 sumy = vec4(0);\n        uint dnomy = 0u;\n\n        for (uint y = 0u; y < leading.y + 1u + trailing.y; y++) {\n            uint contribution = radius.y + 1u - udiff(y, leading.y);\n            sumy += texture(iChannel0, (vec2(ufragCoord - uvec2(0, leading.y) + uvec2(0, y)) + frac) / iResolution.xy) * vec4(contribution);\n            dnomy += contribution;\n        }\n        \n        fragColor = linearToSrgb(sumy / vec4(dnomy));\n        //fragColor = linearToSrgb(vec4(vec2(leading + trailing) / 16.0 - 1.0, 0, 1));\n    } else {\n        fragColor = texture(iChannel0, (vec2(ufragCoord) + frac) / iResolution.xy);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uvec2 start = uvec2(iResolution.xy * vec2(1.0/8.0));\n    uvec2 end = uvec2(iResolution.xy * vec2(7.0/8.0));\n    uvec2 ufragCoord = uvec2(fragCoord);\n    vec2 frac = mod(fragCoord, vec2(1));\n\n    if (all(greaterThanEqual(ufragCoord, start)) && all(lessThan(ufragCoord, end))) {\n        uvec2 radius = RADIUS;\n        uvec2 leading = min(radius, ufragCoord - start);\n        uvec2 trailing = min(radius, end - ufragCoord);\n\n        vec4 sumx = vec4(0);\n        uint dnomx = 0u;\n\n        for (uint x = 0u; x < leading.x + 1u + trailing.x; x++) {\n            uint contribution = radius.x + 1u - udiff(x, leading.x);\n            sumx += srgbToLinear(texture(iChannel0, (vec2(ufragCoord - uvec2(leading.x, 0) + uvec2(x, 0)) + frac) / iResolution.xy)) * vec4(contribution);\n            dnomx += contribution;\n        }\n        \n        fragColor = sumx / vec4(dnomx);\n        //fragColor = linearToSrgb(vec4(vec2(leading + trailing) / 16.0 - 1.0, 0, 1));\n    } else {\n        fragColor = texture(iChannel0, (vec2(ufragCoord) + frac) / iResolution.xy);\n    }\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define RADIUS uvec2(64u)\n\nvec4 srgbToLinear(vec4 col) {\n    vec3 linear = col.rgb / 12.9232102;\n    vec3 exp = pow((col.rgb + 0.055) / 1.055, vec3(2.4));\n    return vec4(mix(linear, exp, greaterThan(col.xyz, vec3(0.0392857))), col.a);\n}\n\nvec4 linearToSrgb(vec4 col) {\n    vec3 linear = col.rgb * 12.9232102;\n    vec3 exp = pow(col.rgb, vec3(1.0 / 2.4)) * 1.055 - 0.055;\n    return vec4(mix(linear, exp, greaterThan(col.xyz, vec3(0.003039933))), col.a);\n}\n\nuint udiff(uint a, uint b) {\n    return a > b ? a - b : b - a;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1112]]}
{"id": "NsdfRM", "name": "sphere test lines", "author": "JorgePlk", "description": "a sphere", "tags": ["sphere"], "likes": 4, "viewed": 242, "published": 3, "date": "1656244459", "time_retrieved": "2024-07-30T16:43:06.102753", "image_code": "#define pi 3.14159265\n\nmat2 rotMat(float rot) {\n    return mat2(cos(rot), -sin(rot),\n                sin(rot), cos(rot));\n}\n\nfloat line(vec2 p1, vec2 p2, vec2 frag_pos, float width) {\n    vec2 line_track = p2 - p1;\n    vec2 hip = frag_pos - p1;\n    float proj = clamp(dot(hip, line_track) / dot(line_track, line_track), 0.0, 1.0);\n    vec2 perp_pos = p1 + line_track * proj;\n    \n    \n    return (1.0 - step(width, distance(perp_pos, frag_pos))) ;\n}\n\nvoid transformSphere(in vec3 sphere[72], out vec3 transformed[72]) {\n    for(int i = 0; i < 72; ++i) {\n    \n        sphere[i].xz *= rotMat(iTime*3.);\n        sphere[i].xy *= rotMat(iTime*3.);\n        \n        sphere[i].xy /= sphere[i].z -4.0;\n        transformed[i] = sphere[i] * 250.0 + vec3(400.0, 225.0, 1.0);\n        \n    }\n}\n\nfloat sphereCalc(in vec3 cube[72], vec2 frag_pos) {\n    float is_sphere = 0.0;\n    \n    for(int i = 0; i < 64; ++i) {\n        if (i % 8 != 7)\n            is_sphere += line(cube[i].xy, cube[i + 1].xy, frag_pos, 1.0);\n        else \n            is_sphere += line(cube[i].xy, cube[i - 7].xy, frag_pos, 1.0);\n\n        is_sphere += line(cube[i].xy, cube[i + 8].xy, frag_pos, 1.0);\n    }\n    \n    return min(is_sphere, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 points[72];\n    float radious = 1.5;\n    for (float i = 0.; i < 9.; i++) {\n        float angle = i * pi / 8.;\n        float size = radious * sin(angle);\n        float alt = radious * cos(angle);\n        vec3 height = vec3(0, alt, 0);\n\n        int index = int(i) * 8;\n\n        points[index ] = height + vec3(sin(0.)           , 0, cos(0.))           * size;\n        points[index + 1] = height + vec3(sin(pi / 4.)      , 0, cos(pi / 4.))      * size;\n        points[index + 2] = height + vec3(sin(pi / 2.)      , 0, cos(pi / 2.))      * size;\n        points[index + 3] = height + vec3(sin(3. * pi / 4.)  , 0, cos(3. * pi / 4.))  * size;\n        points[index + 4] = height + vec3(sin(pi)          , 0, cos(pi))          * size;\n        points[index + 5] = height + vec3(sin(-3. * pi / 4.) , 0, cos(-3. * pi / 4.)) * size;\n        points[index + 6] = height + vec3(sin(-pi / 2.)     , 0, cos(-pi / 2.))     * size;\n        points[index + 7] = height + vec3(sin(-pi / 4.)     , 0, cos(-pi / 4.))     * size;\n    }\n\n\n    vec3 transformed[72];\n                                 \n    transformSphere(points, transformed);\n    float is_sphere = sphereCalc(transformed, fragCoord.xy);\n    \n    vec3 final_color = vec3(1.0 - is_sphere);\n    \n    fragColor = vec4(final_color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 47, 47, 123], [125, 125, 183, 183, 449], [451, 451, 519, 519, 780], [782, 782, 833, 833, 1201], [1203, 1203, 1260, 1260, 2541]]}
{"id": "ss3Bz7", "name": "Nocebo", "author": "blurryroots", "description": "Hubris. Aiming down. Unnecessary suffering. Bad karma. Punishment pending.", "tags": ["illusion", "perception", "goldenratio", "disease", "reality", "biology", "illness", "stress"], "likes": 3, "viewed": 229, "published": 3, "date": "1656238204", "time_retrieved": "2024-07-30T16:43:06.924555", "image_code": "// Perception != Realtiy != Truth.\n\n// Shadertoy Educational License\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n// You are free however, to incorporate this work within the Shadertoy\n// ecosystem, e.g. by forking.\n// This work may incorporate other permissivly shared, educational work,\n// which is attributed appropriatly. Please do so as well.\n// Thanks to https://www.shadertoy.com/user/iq for inspiring this license.\n\n#define SF_THRESHOLD 0.0000001\n\nconst float PI = 355./113.;\nconst float PHI = (1. + sqrt(5.)) / 2.;\nconst float PHI_ONE = PHI - 1.;\nconst float PHI_ONE_INV = 1. - PHI_ONE;\nconst float K = 3., KK = 333.;\nconst float SPEED = PHI_ONE*1., KSPEED = PHI_ONE_INV / 2.;\nconst float SAMPLE_RATE = PHI_ONE_INV;\nconst vec4 base_color = vec4(1. - PHI_ONE, 0., 0., 1.);\nconst vec4 high_color = vec4(PHI_ONE, 0.1, 0.03, 1.);\n\nfloat df_circle(vec3 circle, vec2 uv) {\n    vec2 p = vec2(circle.x, circle.y);\n    float r = circle.z - length(uv - p);\n    return r;\n}\n\nfloat psin(float x) {\n    return (sin(x) + 1.) / 2.;\n}\n\nfloat pcos(float x) {\n    return (cos(x) + 1.) / 2.;\n}\n\nvec2 weird(float time) {\n    float t = time * .1 * 2. * PI;\n    float k = .5 * (psin(t) + pcos(t));\n    float j = pow(PHI, pcos(time))*PHI*PHI_ONE - PHI/2.;\n    return vec2(k, j);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = iResolution.xy / 2.;\n    vec3 aspect = vec3(iResolution.x / iResolution.y, 1.0, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = vec4(0.);\n    float s = 0.003, S = 0.013;\n    \n    float k = mix(K, KK, psin(iTime*KSPEED));\n    float R = 0.;\n    for (float i = 0.; i < k; i += SAMPLE_RATE) {\n        float n = i / k;\n        float m = 1. - n;\n        float I = iTime * SPEED + i;\n        float size = mix(s, S, n);\n        vec3 circle = vec3(weird(I), size);\n        float r = df_circle(circle*aspect, uv*aspect.xy);\n        R = max(R, r);\n        if (R < SF_THRESHOLD) {\n            color += mix(base_color, high_color, n);\n            color.a = length(color.rgb);\n        }\n    }\n\n    if (R < SF_THRESHOLD) {\n        float d = (SF_THRESHOLD - R) / SF_THRESHOLD;\n        fragColor = vec4(1.-PHI_ONE, PHI_ONE, .5, 1. - d);\n    }\n    else {\n        fragColor = (color / k);\n    }\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Nocebo\",\n\t\"description\": \"Hubris. Aiming down. Unnecessary suffering. Bad karma. Punishment pending.\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3Bz7.jpg", "access": "api", "license": "proprietary-license", "functions": [[1327, 1327, 1366, 1366, 1462], [1464, 1464, 1485, 1485, 1518], [1520, 1520, 1541, 1541, 1574], [1576, 1576, 1600, 1600, 1757], [1759, 1759, 1814, 1814, 2727]]}
{"id": "fscBz7", "name": "Purple and Green", "author": "BigETI", "description": "Purple an Green joining to build something amazing.", "tags": ["colors"], "likes": 5, "viewed": 293, "published": 3, "date": "1656193172", "time_retrieved": "2024-07-30T16:43:07.845095", "image_code": "//#define SCREENSHOT_MODE\n\nconst float minimalGridAxisCellCount = 5.0;\n\nstruct Cell\n{\n    vec4 color;\n    float movementSpeedMultiplier;\n};\n\nconst Cell cells[] =\n    Cell[]\n    (\n        Cell(vec4(1.0, 0.0, 1.0, 1.5), 3.0),\n        Cell(vec4(0.0, 1.0, 0.0, 1.5), 4.0),\n        Cell(vec4(1.0, 0.0, 1.0, 1.5), 2.0),\n        Cell(vec4(0.0, 1.0, 0.0, 1.5), 5.0),\n        Cell(vec4(1.0, 0.0, 1.0, 1.5), 1.0)\n    );\n\nconst float cellGlowSize = 0.0625;\n\nconst float cellGlowBoost = 2.0;\n\nconst vec3 skyColor = vec3(0.5, 0.25, 0.5);\n\nconst float e = 0.577215664901532860606512090082402431042159335;\n\n#if defined SCREENSHOT_MODE\nconst float screenshotTime = e * 2.0;\n#endif\n\nvec4 AlphaBlendColors(const vec4 baseColor, const vec4 appendColor)\n{\n    vec3 color = mix(baseColor.rgb, appendColor.rgb, appendColor.a);\n    return vec4(color.x, color.y, color.z, baseColor.a + ((1.0 - baseColor.a) * appendColor.a));\n}\n\nvec3 EmissionToRGB(const vec3 emissiveColor)\n{\n    vec3 ret = emissiveColor;\n    if (emissiveColor.r > 1.0)\n    {\n        float distribution = (emissiveColor.r - 1.0) * 0.5;\n        ret.g += distribution;\n        ret.b += distribution;\n    }\n    if (emissiveColor.g > 1.0)\n    {\n        float distribution = (emissiveColor.g - 1.0) * 0.5;\n        ret.r += distribution;\n        ret.b += distribution;\n    }\n    if (emissiveColor.b > 1.0)\n    {\n        float distribution = (emissiveColor.b - 1.0) * 0.5;\n        ret.r += distribution;\n        ret.g += distribution;\n    }\n    ret /= max(max(ret.r, ret.g), ret.b);\n    return ret;\n}\n\n\nvec4 DrawCell(const vec2 uv, vec4 emissiveColor, float glowSize, float glowBoost)\n{\n    vec4 ret;\n    float left = uv.y * 0.25;\n    float right = 0.75 + (uv.y * 0.25);\n    if\n    (\n        (uv.x >= (left - glowSize)) &&\n        (uv.x <= (right + glowSize)) &&\n        (uv.y >= -glowSize) &&\n        (uv.y <= 1.0)\n    )\n    {\n        float intensity =\n            (\n                (uv.x < left) ?\n                    (1.0 - ((left - uv.x) / glowSize)) :\n                    (\n                        (uv.x > right) ?\n                            (1.0 - ((uv.x - right) / glowSize)) :\n                            1.0\n                    )\n            ) *\n            (\n                (uv.y < 0.0) ?\n                    (1.0 - (-uv.y / glowSize)) :\n                    (\n                        (uv.x < left) ?\n                            1.0 :\n                            (\n                                (uv.x > right) ?\n                                    1.0 :\n                                    (uv.y / glowBoost)\n                            )\n                    )\n            ) * glowBoost;\n        vec3 color = EmissionToRGB(emissiveColor.rgb * emissiveColor.a * intensity);\n        ret.rgba = vec4(color.r, color.g, color.b, intensity * emissiveColor.a * (1.0 - uv.y));\n    }\n    return ret;\n}\n\nvoid mainImage(out vec4 fragmentColor, in vec2 fragmentCoordinates)\n{\n    vec2 uv = (fragmentCoordinates.xy - (iResolution.xy * 0.5)) / ((iResolution.x > iResolution.y) ? iResolution.y : iResolution.x);\n    fragmentColor = vec4(clamp(skyColor.r * uv.y, 0.0, 1.0), clamp(skyColor.g * uv.y, 0.0, 1.0), clamp(skyColor.b * uv.y, 0.0, 1.0), 1.0);\n#if defined SCREENSHOT_MODE\n    float y_movement = mod(screenshotTime, 1.0);\n#else\n    float y_movement = mod(iTime * 0.5, 1.0);\n#endif\n    float x_movement = y_movement * 0.25;\n    for (int cell_index = 0, x; cell_index < cells.length(); cell_index++)\n    {\n        Cell cell = cells[cell_index];\n        for (x = 0; x < 6; x++)\n        {\n            fragmentColor = AlphaBlendColors(fragmentColor, DrawCell(vec2((uv.x + x_movement * cell.movementSpeedMultiplier) * minimalGridAxisCellCount + (4.0 - float(cell_index) * 2.0) + 0.75 * 0.5 - (minimalGridAxisCellCount * 0.25) * float(x), (uv.y + y_movement * cell.movementSpeedMultiplier) * minimalGridAxisCellCount + (-1.5 + float(cell_index)) - minimalGridAxisCellCount * float(x)), cell.color, cellGlowSize, cellGlowBoost));\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[666, 666, 735, 735, 903], [905, 905, 951, 951, 1536], [1539, 1539, 1622, 1622, 2841], [2843, 2843, 2912, 2912, 3979]]}
{"id": "Nd3fR7", "name": "Witcher Signs", "author": "ChutneyPot", "description": "Toss a coin to this shader, o valley of ShaderToy!\n\nMusic: Dan Vasc - Toss A Coin To Your Witcher (Metal Cover) [Bass Boosted]\nhttps://soundcloud.com/dailybassboost/dan-vasc-toss-a-coin-to-your-witcher-bass-boosted\n", "tags": ["neon", "witcher", "geralt", "signs"], "likes": 9, "viewed": 619, "published": 3, "date": "1656184252", "time_retrieved": "2024-07-30T16:43:09.031921", "image_code": "// Witcher Signs, June 2022\n// by ChutneyPot\n//https://www.shadertoy.com/view/Nd3fR7\n// soundcloud track: Dan Vasc - Toss A Coin To Your Witcher (Metal Cover) [Bass Boosted]\n// link: https://soundcloud.com/dailybassboost/dan-vasc-toss-a-coin-to-your-witcher-bass-boosted\n//--------------------------------------------------------------------------\n#define CORE 0.1\n#define GLOW 0.25\n\n#define PULSE 4.0\n\n#define BASE vec4(0.5, 0.5, 0.5, 1.0)\n#define YRDEN vec4(1.0, 0.0, 1.0, 1.0)\n#define QUEN vec4(1.0, 1.0, 0.0, 1.0)\n#define IGNI vec4(1.0, 0.0, 0.0, 1.0)\n#define AXII vec4(0.0, 1.0, 0.0, 1.0)\n#define AARD vec4(0.0, 1.0, 1.0, 1.0)\n\nconst float s = 2.5;\nconst vec2 o = vec2(1.6, 1.8);\n\nfloat Line(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    return length(pa - ba * h);\n}\n\nvoid Neon(in vec2 uv, in vec2 a, in vec2 b, inout float c, inout float g)\n{\n    c = max(c, 1.0 - smoothstep(Line(uv, a, b), 0.0, CORE));\n    g = max(g, 1.0 - smoothstep(Line(uv, a, b), 0.0, GLOW));\n}\n\nvec4 Flash(in vec4 sc, in float c, in float g, in float v, in float t)\n{    \n    vec4 gc = mix(vec4(0), sc, t);\n    vec4 cc = mix(BASE, vec4(1), t);\n    \n    vec4 col = mix(vec4(0), gc, max(g, v));\n    return mix(col, cc, c);\n}\n\nvec4 Yrden(in vec2 uv, in float v, in float t)\n{\n    uv.x += 14.0;\n    \n    float c = 0.0, g = 0.0;\n    Neon(uv, vec2(0.0 - o.x, s), vec2(0.0 + o.x, -s), c, g);\n    Neon(uv, vec2(0.0 + o.x, s), vec2(s - 2.1, s - o.y), c, g);\n    Neon(uv, vec2(0.0 - o.x, -s), vec2(-s + 2.1, -s + o.y), c, g);\n    Neon(uv, vec2(0.0 + o.x, s), vec2(0.0 - o.x, s), c, g);\n    Neon(uv, vec2(0.0 - o.x, -s), vec2(0.0 + o.x, -s), c, g);\n    \n    return Flash(YRDEN, c, g, v, t);\n}\n\nvec4 Quen(in vec2 uv, in float v, in float t)\n{\n    uv.x += 7.0;\n    \n    float c = 0.0, g = 0.0;\n    Neon(uv, vec2(-s, s), vec2(0.0, -s), c, g);\n    Neon(uv, vec2(0.0, -s), vec2(s - o.x, -s + o.y), c, g);\n    Neon(uv, vec2(s), vec2(0.0 + o.x, s - o.y), c, g);\n    Neon(uv, vec2(0.0 + o.x, s - o.y), vec2(0.0, s - o.y), c, g);\n    Neon(uv, vec2(-s, s), vec2(s), c, g);\n\n    return Flash(QUEN, c, g, v, t);\n}\n\nvec4 Igni(in vec2 uv, in float v, in float t)\n{    \n    uv.x += 0.5;\n    \n    float c = 0.0, g = 0.0;\n    Neon(uv, vec2(0.0, s), vec2(-s), c, g);\n    Neon(uv, vec2(s) - o, vec2(s, -s), c, g);\n    Neon(uv, vec2(-s), vec2(s, -s), c, g);\n\n    return Flash(IGNI, c, g, v, t);\n}\n\nvec4 Axii(in vec2 uv, in float v, in float t)\n{\n    uv.x -= 6.5;\n    \n    float c = 0.0, g = 0.0;\n    Neon(uv, vec2(-s, s), vec2(0.0, -s), c, g);\n    Neon(uv, vec2(0.0, -s), vec2(0.0 + o.x, s - o.y), c, g);\n    Neon(uv, vec2(-s, s), vec2(s), c, g);\n\n    return Flash(AXII, c, g, v, t);\n}\n\nvec4 Aard(in vec2 uv, in float v, in float t)\n{\n    uv.x -= 13.0;         \n        \n    float c = 0.0, g = 0.0;\n    Neon(uv, vec2(0.0, s), vec2(s, -s), c, g);\n    Neon(uv, vec2(0.0, s), vec2(-s + o.x, s - o.y), c, g);\n    Neon(uv, vec2(-s), vec2(0.0 - o.x, -s + o.y), c, g);\n    Neon(uv, vec2(0.0 - o.x, -s + o.y), vec2(0.0, -s + o.y), c, g);\n    Neon(uv, vec2(-s), vec2(s, -s), c, g);\n    \n    return Flash(AARD, c, g, v, t);\n}\n\nfloat Pulse(in float t)\n{\n    float p = PULSE * 0.5;\n    return clamp(min(t / p, p - t / p), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    vec2 st = fragCoord / iResolution.xy;\n    vec2 uv = st;\n    \n    st *= 1.0 - st;\n    float v = st.x * st.y * 15.0;\n    v = 1.0 - pow(v, 0.2);\n     \n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 20.0;  \n    \n    float t = mod(iTime, PULSE * 5.0);\n    vec4 yr = Yrden(uv, v, Pulse(t));\n    vec4 qu = Quen(uv, v, Pulse(t - PULSE));\n    vec4 ig = Igni(uv, v, Pulse(t - PULSE * 2.0));\n    vec4 ax = Axii(uv, v, Pulse(t - PULSE * 3.0));\n    vec4 aa = Aard(uv, v, Pulse(t - PULSE * 4.0));\n    \n    vec4 col = vec4(0.0);\n    col = mix(col, yr, yr.w);\n    col = mix(col, qu, qu.w);\n    col = mix(col, ig, ig.w);\n    col = mix(col, ax, ax.w);\n    col = mix(col, aa, aa.w);\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 29218, "src": "https://soundcloud.com/dailybassboost/dan-vasc-toss-a-coin-to-your-witcher-bass-boosted", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3fR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[686, 686, 731, 731, 861], [863, 863, 938, 938, 1062], [1064, 1064, 1136, 1136, 1291], [1293, 1293, 1341, 1341, 1750], [1752, 1752, 1799, 1799, 2159], [2161, 2161, 2208, 2208, 2434], [2436, 2436, 2483, 2483, 2723], [2725, 2725, 2772, 2772, 3153], [3155, 3155, 3180, 3180, 3260], [3262, 3262, 3317, 3317, 4036]]}
{"id": "sdGcDG", "name": "HUD_Heads_Up_Display", "author": "stevenschronk", "description": "Heads up display.", "tags": ["hud"], "likes": 1, "viewed": 243, "published": 3, "date": "1656176031", "time_retrieved": "2024-07-30T16:43:09.898604", "image_code": "#define M_PI 3.141592654\n\nuniform float u_time;\n\nfloat set_min_line_width(float in_width){\n    // if the width of or height of the window is too small\n    // increase the size of the lines to make them draw clearly\n    float max_screen_size;\n    if(iResolution.y > iResolution.x) { max_screen_size = iResolution.y; }\n    else {  max_screen_size = iResolution.x; }\n    float min_line_width = 38./max_screen_size;\n    if(in_width > min_line_width) {\n        min_line_width = in_width;\n    }\n    return min_line_width;\n}\n\nvoid circle(vec2 st, float radius, vec3 in_color, inout vec3 out_color){\n    vec2 dist = st-vec2(0.5);\n\tfloat inside_circle =  1.-smoothstep(radius-(radius*0.01),\n                         radius+(radius*0.01),\n                         dot(dist,dist)*4.0);           \n    if(inside_circle > 0.0) { out_color = in_color; }\n}\n\nfloat circle_antialiased(vec2 st, float radius){\n    vec2 dist = st-vec2(0.5);\n\treturn 1.-smoothstep(radius-(radius*0.01),\n                         radius+(radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\n// draws an aliased circle\nvoid circle_line(vec2 st, float radius, float thickness, vec3 in_color, inout vec3 out_color){\n    vec2 dist = st-vec2(0.5); // set center of circle\n    thickness /= 2.;\n\tfloat inside_circle = smoothstep( radius-thickness, radius, dot(dist,dist)*4.0) -\n          smoothstep( radius, radius+thickness, dot(dist,dist)*4.0);                     \n    if(inside_circle > 0.0) { out_color = in_color; }\n}\n\nfloat circle_line_antialiased(vec2 st, float radius, float thickness){\n    vec2 dist = st-vec2(0.5); // set center of circle\n    thickness /= 2.;\n\treturn smoothstep( radius-thickness, radius, dot(dist,dist)*4.0) -\n          smoothstep( radius, radius+thickness, dot(dist,dist)*4.0);\n}\n\nvoid rectangle(vec2 uv, vec2 point_1, vec2 point_2, vec3 color_in, inout vec3 color_out){\n    if(uv.x > point_1.x && uv.x < point_2.x && uv.y > point_1.y && uv.y < point_2.y){\n        color_out = color_in;\n    }\n}\n\nfloat edge_function(vec2 a, vec2 b, vec2 c){\n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x));\n}\n\nvoid draw_triangle(vec2 uv, vec2 a, vec2 b, vec2 c,\n    vec3 color_in, inout vec3 color_out) {\n    float a_inside = edge_function(a, b, uv);\n    float b_inside = edge_function(b, c, uv);\n    float c_inside = edge_function(c, a, uv);\n    \n    if( a_inside > .0 || b_inside > .0 || c_inside > .0 ) {\n        // TODO: Remove the else here.\n    } else {\n        color_out = color_in;\n    }\n}\n\nfloat radar_sweep(vec2 uv, float len){\n    uv.x -= 0.5; // TODO: this shouldn't be needed?\n    uv.y -= 0.5;\n    float theta0 = 120.0 * iTime; // 120.0 sets the speed of rotation\n    float theta = mod(180.0 * atan(uv.y,uv.x) / M_PI+theta0, 360.0);\n    float angle = iTime;\n    return smoothstep(2./M_PI, 1.999/M_PI, theta);\n}\n\nvec3 color_white = vec3(1.);\nvec3 color_hlt_blue = vec3(37.9/100.,76.5/100.,79.5/100.);\nvec3 color_lt_blue = vec3(70.7/100.0,90.8/100.,94.2/100.);\nvec3 color_orange = vec3(89.5/100.,34.2/100.,19.1/100.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    uv.y -= .25;\n    uv.x -= .45;\n    uv *= 15.80;\n\n    vec3 col = vec3(0.);\n    vec2 center_pos = vec2(15.)-uv;\n    \n    col += radar_sweep(uv, -4.26) * color_lt_blue;\n    \n    // Blue lines\n    //rectangle(uv, vec2(-4.26, 0.5), vec2(0.5, .56), color_hlt_blue, col);\n\n    col += circle_line_antialiased(uv, .18,  set_min_line_width(0.1)) * color_lt_blue;\n    col += circle_line_antialiased(uv, 15.7, set_min_line_width(2.)) * color_lt_blue;\n    col += circle_line_antialiased(uv, 43., set_min_line_width(2.)) * color_lt_blue;\n    col += circle_line_antialiased(uv, 90.5, set_min_line_width(2.)) *color_white;\n    col += circle_line_antialiased(uv, 155.5, set_min_line_width(5.)) * color_hlt_blue;\n    \n    // White triangles\n    // left\n    draw_triangle(uv, vec2(-5.6,0.32), vec2(-5.4,0.5), vec2(-5.6,0.65), color_white, col);\n    // right\n    draw_triangle(uv, vec2(6.6,0.32), vec2(6.6,0.65), vec2(6.4,0.5), color_white, col);\n    \n    // Red lines\n    uv.y -= 1.97;\n\n    col += circle_antialiased(uv, 0.05) * color_orange;\n    col += circle_line_antialiased(uv, 0.12, set_min_line_width(0.0001)) * color_orange;\n    col += circle_line_antialiased(uv, 8.6, set_min_line_width(0.8)) * color_orange;\n    \n    // White dots\n    uv.y += 0.5;\n    uv.x -= 0.15;\n    col += circle_antialiased(uv, 0.022) * color_white;\n    \n    uv.y -= 2.2;\n    uv.x += 0.8;\n    col += circle_antialiased(uv, 0.022) * color_white;    \n    \n    //fragColor = vec4(0., uv.y,0.,1.);\n    fragColor = vec4( col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGcDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 90, 214, 517], [519, 519, 591, 591, 841], [843, 843, 891, 891, 1060], [1062, 1089, 1183, 1183, 1487], [1489, 1489, 1559, 1559, 1773], [1775, 1775, 1864, 1864, 1988], [1990, 1990, 2034, 2034, 2104], [2106, 2106, 2200, 2200, 2493], [2495, 2495, 2533, 2533, 2819], [3026, 3026, 3082, 3082, 4656]]}
{"id": "NdcfRM", "name": "water blob", "author": "nikixd", "description": "...", "tags": ["noise", "water"], "likes": 5, "viewed": 300, "published": 3, "date": "1656173428", "time_retrieved": "2024-07-30T16:43:10.654583", "image_code": "const float PI = 3.14159;\n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) { \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zero in the center and closest edge is 1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    float ratio = iResolution.x / iResolution.y;\n    uv *= vec2(max(1.0, ratio), max(1.0, 1.0 / ratio));\n    \n    float ang = atan(uv.y, uv.x) + PI;\n    float dist = length(uv);\n    float radius = 0.9 + snoise(vec3(sin(ang), cos(ang), iTime)) * 0.1;\n    vec3 mask = smoothstep(0.01, 0.0, dist - radius) * vec3(1.0);\n    vec3 grad = vec3(0.1, 0.2, 0.5) + dist * vec3(0.05, 0.05, 0.3);\n    vec3 glow = mask * smoothstep(0.3, 0.0, abs(dist - radius)) * vec3(0.2);\n    vec3 color = mask * grad + glow;\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 48, 48, 99], [101, 101, 122, 122, 173], [175, 175, 197, 197, 237], [239, 239, 267, 267, 321], [323, 323, 345, 345, 2082], [2084, 2084, 2141, 2189, 2793]]}
{"id": "7sdfz4", "name": "Pythagoras tree (simple version)", "author": "afdw", "description": "An implementation of the Pythagoras tree fractal", "tags": ["fractal"], "likes": 8, "viewed": 275, "published": 3, "date": "1656167031", "time_retrieved": "2024-07-30T16:43:11.472396", "image_code": "float cross2(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nconst int n = 5;\n\nvec2 pts[n] = vec2[n](\n    vec2(-1.0, 1.0),\n    vec2(0.0, 2.0),\n    vec2(1.0, 1.0),\n    vec2(1.0, -1.0),\n    vec2(-1.0, -1.0)\n);\n\nconst int l = 8;\n\nvec2 trans(vec2 a1, vec2 a2, vec2 b1, vec2 b2, vec2 c) {\n    vec2 t = a2 - a1;\n    t /= dot(t, t);\n    vec2 s = b2 - b1;\n    return mat2(\n        -s.x, -s.y,\n        s.y, -s.x\n    ) * mat2(\n        t.x, -t.y,\n        t.y, t.x\n    ) * (c - a1) + b2;\n}\n\nbool checkIn(vec2 c) {\n    bool a = true;\n    for (int i = 0; i < n; i++) {\n        if (cross2(c - pts[i], pts[(i + 1) % n] - pts[i]) <= -0.000001) {\n            a = false;\n        }\n    }\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float x = iTime;\n    pts = vec2[n](\n        vec2(-1.0, 1.0),\n        vec2(cos(x), 1.0 + abs(sin(x))),\n        vec2(1.0, 1.0),\n        vec2(1.0, -1.0),\n        vec2(-1.0, -1.0)\n    );\n\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.0 * vec2(iResolution.x / iResolution.y, 1.0);\n\n    vec2 c = uv * 4.0 + vec2(0.0, 3.0);\n\n    vec4 o = vec4(0.0);\n    for (int j = 0; j < l; j++) {\n        for (int k = 0; k < (1 << j); k++) {\n            vec2 d = c;\n            for (int i = 0; i < j; i++) {\n                if ((k & (1 << i)) == 0) {\n                    d = trans(pts[0], pts[1], pts[3], pts[4], d);\n                } else {\n                    d = trans(pts[1], pts[2], pts[3], pts[4], d);\n                }\n            }\n            if (checkIn(d)) {\n                o += (0.3 + 0.7 * float(l - j - 1) / float(l - 1)) *\n                    vec4(1.0, (float(k) + 0.5) / float(1 << j), 0.4, 0.0);\n            }\n        }\n    }\n\n    fragColor = o;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdfz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 66], [234, 234, 290, 290, 484], [486, 486, 508, 508, 690]]}
{"id": "sddfR4", "name": "More Complex Atanh", "author": "mrange", "description": "License CC0: More Complex Atanh\nInspired by: Complex Atanh  - https://www.shadertoy.com/view/sl3XW7 \nI always thought Complex Atanh by mla was very cool\nI tinkered a bit with it on saturday morning and got something \nI think is differen", "tags": ["complex", "atanh", "domainmapping"], "likes": 11, "viewed": 312, "published": 3, "date": "1656159151", "time_retrieved": "2024-07-30T16:43:12.277244", "image_code": "// License CC0: More Complex Atanh\n//  Inspired by: Complex Atanh  - https://www.shadertoy.com/view/tsBXRW\n//  I always thought Complex Atanh by mla was very cool\n//  I tinkered a bit with it on saturday morning and got something \n//  I think is different enough to share\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat circle8(vec2 p, float r) {\n  p *= p;\n  p *= p;\n  return pow(dot(p, p),1.0/8.0)-r;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// Complex trig functions found at: Complex Atanh  - https://www.shadertoy.com/view/sl3XW7\n//  A very cool shader\nvec2 cmul(vec2 z, vec2 w) {\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// My own attempt at a ctanh\nvec2 cexp(vec2 z) {\n  float r = exp(z.x);\n  return r*vec2(cos(z.y), sin(z.y));\n}\n\nvec2 ctanh(vec2 z) {\n  z = cexp(2.0*z);\n  return cdiv(vec2(1,0)-z,vec2(1,0)+z);\n}\n\nvec2 transform(vec2 p) {\n  float a = 0.5*TIME;\n  p *= mix(2.0, 0.5, smoothstep(-0.85, 0.85, cos(0.5*a)));\n  p = ctanh(p);\n  p *= ROT(0.2*a);\n  p += 1.5*vec2(cos(0.3*a), sin(0.4*a));\n  p = catanh(p);\n  p.x -= 0.2*a;\n  return p;\n}\n\nvec3 effect(vec3 col, vec2 p_) {\n  const float scale = 1.0/PI;\n  const float cellw = 0.05;\n  p_ *= ROT(0.05*TIME);\n\n  float aaa = 2.0/RESOLUTION.y;\n  vec2 np_ = p_+aaa;\n  vec2 p   = transform(p_);\n  vec2 np  = transform(np_);\n  float aa = distance(p, np)*sqrt(0.5);\n\n  p *= scale;\n  aa *= scale;\n\n  vec2 n = floor(p/cellw);\n  p = mod(p, cellw);\n  p -= 0.5*cellw;\n  float fo = tanh_approx(aaa/(aa));\n  float d = circle8(p, 0.45*cellw);\n  col = mix(col, hsv2rgb(vec3(fract(0.1*n.y+0.05*n.x+0.05*TIME), mix(0., 0.95, fo), mix(0.9, 0.85, fo*fo))), smoothstep(aa, -aa, d)*step(aa, 0.7));\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = vec3(1.0);\n  col = effect(col, p);\n  col = mix(col, vec3(1.0), smoothstep(4.0, 0.0, TIME)),\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddfR4.jpg", "access": "api", "license": "cc0-1.0", "functions": [[603, 603, 625, 625, 771], [1066, 1152, 1188, 1188, 1282], [1284, 1284, 1316, 1316, 1373], [1375, 1435, 1463, 1529, 1605], [1607, 1721, 1748, 1748, 1779], [1781, 1781, 1800, 1800, 1851], [1853, 1853, 1880, 1880, 1908], [1910, 1910, 1929, 1929, 1991], [1993, 1993, 2014, 2014, 2066], [2068, 2097, 2116, 2116, 2177], [2179, 2179, 2199, 2199, 2260], [2262, 2262, 2286, 2286, 2490], [2492, 2492, 2524, 2524, 3091], [3093, 3093, 3148, 3148, 3439]]}
{"id": "fdcfR4", "name": "ray marching and phong", "author": "lanx06", "description": "Part 3 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/", "tags": ["raymarching", "phong"], "likes": 1, "viewed": 196, "published": 3, "date": "1656135517", "time_retrieved": "2024-07-30T16:43:13.415201", "image_code": "\n#ifdef GL_ES\n#define PI 3.1415926538\nprecision mediump float;\n#endif\n\nconst float EPSILON =.1;\nconst int max_step=255;\nconst float not_hit=10000.0;\nconst float max_len=100.;\n\nfloat sp(vec3 sample_point,vec3 center,float size){\n    return length(sample_point-center)-size;\n}\nfloat cube(vec3 sample_point,vec3 center,float size){\n    vec3 d=abs(sample_point-center)-vec3(size);\n    float in_d=min(max(d.x,max(d.y,d.z)),0.);\n    float out_d= length(max(d, 0.0));\n    //if(in_d==0.)return 0.0;\n\treturn out_d*(1.-in_d)+in_d;\n}\n\nfloat scene(vec3 sample_point){\n    float cube1=cube(sample_point,vec3(0.),.5);\n    float sp1=sp(sample_point,vec3(.5),.5);\n\tfloat dep=min(cube1,sp1);\n    //if(sp1<EPSILON)return not_hit;\n    return dep;\n    //return min(sp(sample_point,vec3(1.)),not_hit);\n}\nvec3 ray_d(float fov,vec2 size,vec2 fargcoord){\n    vec2 xy=fargcoord-size/2.;\n    float z=size.y/tan(radians(fov/2.));\n    //return normalize(vec3(-z,xy.x,xy.y));\n    return normalize(vec3(xy,-z));\n}\nfloat ray_march(vec3 eye, vec3 d){\n    float depth=0.;\n    for(int i=0;i<max_step;i++){\n        float dis=scene(eye+d*depth);\n        \n        if(dis<EPSILON)return depth;\n        \n        depth+=dis;\n        \n        if(depth>=not_hit)return not_hit;\n        \n    }\n    return not_hit;\n}\n\nvec3 culc_normal(vec3 p){\n        return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z  + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\nvec3 culc_light(vec3 diff_c,vec3 spec_c,float al, vec3 pos,vec3 eye,vec3 light_pos,vec3 power){\n\tvec3 n=culc_normal(pos);\n    //not right but look good\n    //vec3 l=culc_normal(light_pos-pos);\n    //vec3 v=culc_normal(eye-pos);\n    //vec3 r=culc_normal(reflect(-l,n));\n    //right one use normalize\n    vec3 l=normalize(light_pos-pos);\n    vec3 v=normalize(eye-pos);\n    vec3 r=normalize(reflect(-l,n));\n\tfloat dot_ln=dot(l,n);\n    float dot_rv=dot(r,v);\n    if(dot_ln<0.)return vec3(0.0, 0.0, 0.0);\n    \n    //use diff color\n    if(dot_rv<0.)return power*diff_c*dot_ln;\n    //reflection \n    return power*( diff_c*dot_ln + spec_c*pow(dot_rv,al));\n}\nvec3 phong_light(float al,vec3 light_pos,vec3 pos,vec3 eye,vec3 am_c,vec3 diff_c,vec3 spec_c){\n     vec3 amb_light=.5*am_c;\n    vec3 color=amb_light;\n    vec3 light_power=vec3(.4);\n    color+=culc_light(am_c,spec_c,al,pos,eye,light_pos,light_power);\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    vec2 ps= vec2(cos(iTime),sin(iTime))*10.;\n\t//vec3 eye_postion=vec3(10.,0.0,0.);\n    //vec3 eye_postion=vec3(ps,0.);\n    //vec3 eye_postion=vec3(1.,1.,+10.*abs(sin(iTime)));\n    vec3 eye_postion=vec3(0,0,+6.);\n    vec3 ray_di=ray_d(50., iResolution.xy,gl_FragCoord.xy);\n    float hit=ray_march(eye_postion,ray_di);\n    vec3 pos=eye_postion+ hit * ray_di;\n\tcolor=vec3(ray_di);\n    \n    if(hit!=not_hit){\n      //color=vec3(culc_normal(hit*ray_di));\n        vec3 light_pos =vec3(ps/1.,1);\n        //vec3 light_pos=vec3(2.950,3.689,4.000);\n        vec3 am_c=vec3(0.8353, 0.8275, 1.0);\n        vec3 diff_c=vec3(1.0, 0.0, 0.0);\n        vec3 spec_c=vec3(1.0, 1.0, 1.0);\n        float max_shine=100.0;\n\t\tcolor=phong_light(max_shine,light_pos,pos,eye_postion,am_c,diff_c,spec_c);\n        //color=vec3(1);\n    }\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 227, 227, 274], [275, 275, 328, 328, 522], [524, 524, 555, 555, 782], [783, 783, 830, 830, 983], [984, 984, 1018, 1018, 1272], [1274, 1274, 1299, 1299, 1595], [1596, 1596, 1691, 1691, 2245], [2246, 2246, 2340, 2340, 2515], [2516, 2516, 2572, 2572, 3484]]}
{"id": "7s3BzN", "name": "Mudcrack", "author": "davidar", "description": "A mass-spring network model for procedural surface crack / fracture simulation, loosely based on https://ima.udg.edu/~lmuguercia/survey.pdf and inspired by cornusammonis' work on nonlinear springs. Mouseable.", "tags": ["simulation", "spring", "fracture", "mass", "crack", "mud"], "likes": 29, "viewed": 393, "published": 3, "date": "1656133162", "time_retrieved": "2024-07-30T16:43:14.219052", "image_code": "// colour reference https://fineartamerica.com/featured/crack-aidong-ning.html\nconst vec4 yellow = vec4(0.96, 0.86, 0.59, 1);\nconst vec4 orange = vec4(0.86, 0.62, 0.45, 1);\nconst vec4 blue = vec4(0.41, 0.46, 0.55, 1);\nconst vec4 black = vec4(0.03, 0.05, 0.09, 1);\nconst vec4 brown = vec4(0.47, 0.26, 0.18, 1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 displacement = texture(iChannel0, uv).zw;\n    vec3 normal = normalize(vec3(-displacement/3., 1));\n    float lighting = dot(normal, normalize(vec3(1,1,0)));\n    \n    vec2 gradDisp = vec2(texGradX(iChannel0, uv).z, texGradY(iChannel0, uv).w);\n    float crackMask = length(max(gradDisp, vec2(0)));\n    \n    fragColor = yellow;\n    fragColor = mix(fragColor, orange, smoothstep(-1., 0., lighting));\n    fragColor = mix(fragColor, blue,   smoothstep( 0., 1., lighting));\n    fragColor = mix(fragColor, brown,  smoothstep( 0., .4, crackMask));\n    fragColor = mix(fragColor, black,  smoothstep( .4, .7, crackMask));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* Texture Stencil Library https://www.shadertoy.com/view/ssBczm\n\nThe MIT License\n\nCopyright (c) 2022 David A Roberts <https://davidar.io/>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nvec4 texStencil(sampler2D ch, vec2 uv, float coeff[9]) {\n    vec2 texel = 1. / vec2(textureSize(ch, 0));\n    const vec2 stencilOffset[9] = vec2[](\n        vec2(-1, 1), vec2( 0, 1), vec2( 1, 1),\n        vec2(-1, 0), vec2( 0, 0), vec2( 1, 0),\n        vec2(-1,-1), vec2( 0,-1), vec2( 1,-1)\n    );\n    vec4 r = vec4(0);\n    for (int i = 0; i < 9; i++)\n        r += coeff[i] * texture(ch, uv + texel * stencilOffset[i]);\n    return r;\n}\n\n// Gaussian/binomial blur\n// https://bartwronski.com/2021/10/31/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians/\nvec4 texBlur(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        .0625, .125, .0625,\n        .125,  .25,  .125,\n        .0625, .125, .0625\n    ));\n}\n\n// Laplacian, optimal 9-point stencil\n// https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1928&context=cstech\nvec4 texLapl(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        1.,   4., 1.,\n        4., -20., 4.,\n        1.,   4., 1.\n    )) / 6.;\n}\n\n// horizontal gradient (Sobel filter)\nvec4 texGradX(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        -1., 0., 1.,\n        -2., 0., 2.,\n        -1., 0., 1.\n    )) / 8.;\n}\n\n// vertical gradient (Sobel filter)\nvec4 texGradY(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n         1.,  2.,  1.,\n         0.,  0.,  0.,\n        -1., -2., -1.\n    )) / 8.;\n}\n\n\n\n\n\n/* https://www.shadertoy.com/view/XsX3zB\n *\n * The MIT License\n * Copyright © 2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https://www.shadertoy.com/view/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n * ~     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n * ~     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n * ~     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n * ~     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n * ~     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n * ~     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n * ~ \n *\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n", "buffer_a_code": "// location of mass in given cell\nvec2 location(vec2 cell) {\n    return cell + texture(iChannel0, cell / iResolution.xy).zw;\n}\n\n// spring fails when stretched too far\nfloat stiffness(float dist, vec2 uv) {\n    return mix(.05, .2, uv.x) * smoothstep(1.4, .6, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // init\n    if (iFrame < 10) {\n        fragColor = vec4(simplex3d(vec3(10.*uv, 1)), simplex3d(vec3(10.*uv, 2)), simplex3d(vec3(10.*uv, 3)), simplex3d(vec3(10.*uv, 4)));\n        return;\n    }\n    \n    // diffusion of internal stress\n    vec2 stress = texBlur(iChannel0, uv).xy;\n    \n    // spring forces from neighbouring cells\n    for (int i = -1; i <= 1; i++) for (int j = -1; j <= 1; j++) {\n        if (i == 0 && j == 0) continue;\n        vec2 offset = normalize(vec2(i,j));\n        vec2 disp = location(fragCoord + offset) - location(fragCoord);\n        vec2 force = stiffness(length(disp), uv) * disp; // Hooke's law\n        stress += force;\n    }\n    \n    // interaction\n    vec4 m = iMouse;\n    float t = float(iFrame) / 200.;\n    if (t < 1.) {\n        m.x = iResolution.x * t;\n        m.y = iResolution.y * (.5 + .25 * sin(10. * t));\n        m.zw = m.xy;\n    }\n    if (m.z > 0.) {\n        vec2 dx = (fragCoord.xy - m.xy) / iResolution.y;\n        dx *= 10.;\n        stress += dx * exp(-dot(dx,dx));\n    }\n    \n    // clamp stress\n    if (length(stress) > 1.) stress = normalize(stress);\n    \n    // update mass locations\n    vec2 displacement = texBlur(iChannel0, uv).zw; // diffusion\n    displacement *= 1. - .01 * length(displacement); // pull towards centre of cell\n    displacement += .1 * stress; // push by spring forces\n    \n    fragColor = vec4(stress, displacement);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3BzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 311, 368, 368, 1036]]}
{"id": "NddBR4", "name": "Fractal knots 18", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 6, "viewed": 234, "published": 3, "date": "1656131795", "time_retrieved": "2024-07-30T16:43:14.996972", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\n        float s1 = .75;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*4.*2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    for(int i=0;i<6;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){\n            uv += (t2.yx);\n            uv /= -scale;\n            t2 = triangle_wave(uv.yx-1.5,1.5);\n            t3 = -triangle_wave(uv-1.,1.5);\n            uv.yx = (t2+t3);\n        }\n        col.x = 1.-min(uv.y+uv.x+col.x,col.x)*s1;\n        col = abs(col.yzx-vec3(1.5-col.x))/s1;\n    }\n    fragColor = vec4(col*s1,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddBR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [140, 140, 197, 197, 836]]}
{"id": "7scfRN", "name": "another way x-0001", "author": "jorge2017a2", "description": "another way x-0001", "tags": ["anotherwayx0001"], "likes": 9, "viewed": 221, "published": 3, "date": "1656122228", "time_retrieved": "2024-07-30T16:43:15.989319", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n///another way x-0001---\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n///Tunnel - exact   (https://www.shadertoy.com/view/flSSDy)\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{   p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\nfloat fun(float x, float z)\n{ return 1.5 * sin(z * 0.2);}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    p.z= opRep1D(p.z, 30.5 );\n    vec3 p0=p;\n    vec3 piso=tex3D(iChannel0, p/16., vec3(1.0,1.0,1.0))*0.5;\n    float f1=fun(p.x, p.z);\n    vec3 pos=vec3(0.0,f1,0.0);\n    \n    float d1= sdBox( p-pos, vec3(10.0,5.0,30.0) ); //piso\n    vec3 pnew=p-pos;\n    p.x=abs(pnew.x)-12.0;\n    float d1a= sdBox(p-pos-vec3(0.0,5.0,0.0), vec3(1.0,15.0,30.0) );\n    \n    pnew.x=abs(pnew.x)-12.0;\n    float d2= sdBox( pnew, vec3(2.0,15.0,30.0) );\n    d2+=piso.y+piso.z;\n    \n    vec2 p2n=p.yz-vec2(10.0,0.0)-pos.yz;\n    vec2 p3n=p.yz-vec2(10.0,-10.0)-pos.yz;\n    p2n=rotatev2(p2n, 1.57);\n    p3n=rotatev2(p3n, 1.57);\n    \n    float d3= sdTunnel(p2n, vec2(3.0,5.0) );\n    float d3b= sdTunnel(p3n, vec2(1.5,3.0) );\n     d2= Difference(d2, d3);\n     d2= Difference(d2, d3b);\n    \n    res =opU2(res, vec2(d1,101.0));\n    res =opU2(res, vec2(d2,8.0));\n    res =opU2(res, vec2(d1a,9.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a,b,c,d;\n    a = vec3(0.2); b = vec3(0.5);c = vec3(1.0);d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 ){ col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ){  col= pattern( p.xz );\n        return tex3D(iChannel0, p/32., nor)*3.0*col; \n    }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n    if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n    if (id_color==57) {return pattern( p.xz );}\n    if (id_color>=100 )\n    { return  getColorTextura( p, nor,id_color); }  \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;    \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, 25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 )*(0.5+0.5*sin(t)) ; \n    vec3 ro=vec3(0.0,7.0,-25.0+t*1.2);\n   ro.z=opRep1D(ro.z, 30.5*10.0 );\n   ro.y+=1.5 * sin(ro.z * 0.2)+2.0;\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   \n   float dc=6.0*sin(t0); //cambio de camara\n   if( dc<0.0)\n     {   ro+=vec3(-3.0,0.0,0.0);\n         rd=rotate_y(rd, radians(90.0)); }\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n   vec3 col= Render( ro,  rd);\n   fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0)   //10\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scfRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[486, 486, 518, 518, 602], [603, 603, 647, 647, 674], [675, 675, 715, 715, 742], [743, 743, 788, 788, 816], [818, 818, 854, 854, 899], [901, 901, 935, 935, 1031], [1032, 1032, 1066, 1066, 1157], [1158, 1158, 1192, 1192, 1283], [1285, 1285, 1319, 1319, 1410], [1412, 1412, 1437, 1437, 1456], [1457, 1457, 1482, 1482, 1501], [1502, 1502, 1538, 1538, 1566], [1628, 1628, 1669, 1669, 1934], [1936, 1936, 1965, 1965, 1993], [1995, 1995, 2020, 2020, 2934], [2936, 2936, 2960, 2960, 3122], [3124, 3124, 3172, 3172, 3451], [3453, 3453, 3497, 3497, 3818], [3820, 3820, 3857, 3857, 4114], [4116, 4116, 4139, 4139, 4278], [4280, 4280, 4370, 4370, 5319], [5321, 5369, 5397, 5397, 5585], [5587, 5587, 5636, 5636, 5816], [5818, 5818, 5850, 5850, 6047], [6049, 6049, 6119, 6119, 6336], [6338, 6338, 6365, 6365, 6454], [6456, 6456, 6514, 6514, 6562], [6564, 6564, 6587, 6587, 6699], [6701, 6701, 6732, 6732, 7356], [7358, 7358, 7415, 7415, 8093]]}
{"id": "7s3fRN", "name": "Fractal knots 17", "author": "jarble", "description": "A fractal with knot-like patterns.", "tags": ["fractal", "knot"], "likes": 4, "viewed": 204, "published": 3, "date": "1656118357", "time_retrieved": "2024-07-30T16:43:16.762253", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*16.*1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/4.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    for(int i=0;i<6;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){\n            uv += (t2.yx);\n            uv /= scale;\n            //uv *= -sign(uv.x);\n            //uv.x += sign(uv.x)/2.;\n            //uv.y += sign(uv.y)/2.;\n            t2 = triangle_wave(uv.yx-.5,1.5);\n            t3 = -triangle_wave(uv,1.5);\n            uv.yx = (t2+t3);\n        } \n        col.x = min(uv.y+uv.x+col.x,col.x)/sqrt(2.);\n        col = abs(col.yzx-vec3(col.x)*sign(uv.x))/sqrt(2.);\n        uv.y *= -1.;\n    }\n    fragColor = vec4(col*4.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3fRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 953]]}
{"id": "Nddyz4", "name": "Old-School FPS Controller", "author": "cra_manning_w", "description": "Experiment based on Wolfenstein/Doom-style graphics, doing one raycast per column of pixels.", "tags": ["3d", "multipass"], "likes": 4, "viewed": 255, "published": 3, "date": "1656107482", "time_retrieved": "2024-07-30T16:43:17.786514", "image_code": "#define BUF_A iChannel0\n#define BUF_B iChannel1\n#define BUF_C iChannel2\n\n\nvec3 fogColor(vec3 viewDir)\n{\n    return mix(vec3(0.7, 0.7, 1.0),\n               vec3(0.4, 0.4, 1.0),\n               SATURATE(viewDir.z));\n}\n\nvec3 floorColor(vec2 horzPos)\n{\n    return vec3(0.0);\n}\nvec3 ceilingColor(vec2 horzPos)\n{\n    return vec3(0.5);\n}\n\nvec3 surfaceLighting(vec3 pos, vec2 normal2D, vec3 albedo)\n{\n    vec3 normal = vec3(normal2D, 0.0);\n    const vec3 LIGHT_DIR = normalize(vec3(1, 1, -1));\n    \n    float diffuse = max(0.1, dot(normal, -LIGHT_DIR));\n    \n    return diffuse * albedo;\n}\nvec3 materialColor1(vec3 surfacePos, vec2 surfaceNormal)\n{\n    return vec3(1, 0, 0);\n}\n\nfloat material2NoiseAxis(vec3 surfacePos, vec2 surfaceNormal, vec2 surfaceUV)\n{\n    const vec2 NOISE_SCALE = vec2(80, 200);\n    return perlinNoise(surfaceUV * NOISE_SCALE * 1.0, 5.423897);\n}\nvec3 materialColor2(vec3 surfacePos, vec2 surfaceNormal)\n{\n    //Use triplanar mapping, but optimize based on the fact\n    //    that surfaces always have a horizontal normal.\n    vec2 surfaceUvPlaneX = surfacePos.yz,\n         surfaceUVPlaneY = surfacePos.xz;\n    vec2 surfaceWeights = abs(surfaceNormal);\n    surfaceWeights = pow(surfaceWeights, vec2(10)); //Make a shorter transition between planes\n    surfaceWeights /= (surfaceWeights.x + surfaceWeights.y); //Normalize\n    \n    float noise = dot(surfaceWeights,\n                      vec2(material2NoiseAxis(surfacePos, surfaceNormal, surfaceUvPlaneX),\n                           material2NoiseAxis(surfacePos, surfaceNormal, surfaceUVPlaneY)));\n    \n    //Add a sort of cross-hatching effect.\n    vec2 crossHatchUV = vec2(dot(surfaceWeights, surfacePos.xy),\n                             surfacePos.z);\n    crossHatchUV *= vec2(30, 30) * 5.0;\n    float hatchStrength = max(OSCILLATE(crossHatchUV.x),\n                              OSCILLATE(crossHatchUV.y));\n    hatchStrength = pow(hatchStrength, 40.0);\n    return vec3(hatchStrength);\n}\n\nvec3 materialColor3(vec3 surfacePos, vec2 surfaceNormal)\n{\n    vec3 albedo1 = vec3(0, 0, 1),\n         albedo2 = vec3(1, 1, 0);\n         \n    vec2 surfaceUV1 = surfacePos.xz,\n         surfaceUV2 = surfacePos.yz;\n    \n    //Generate noise using that UV.\n    float noise1 = 0.5 * 2.0 * abs(perlinNoise(surfaceUV1 * vec2(100, 50), 1.2342) - 0.5),\n          noise2 = 0.5 * 2.0 * abs(perlinNoise(surfaceUV2 * vec2(50, 100), 5.3224) - 0.5);\n    float noiseFinal = min(noise1, noise2) / max(noise1, noise2);\n    \n    return mix(albedo1, albedo2, SHARPEN(SHARPEN(noiseFinal)));\n}\nvec3 materialColor(int id, vec3 surfacePos, vec2 surfaceNormal)\n{\n    vec3 albedo;\n    if (id == 0)\n        albedo = materialColor1(surfacePos, surfaceNormal);\n    else if (id == 1)\n        albedo = materialColor2(surfacePos, surfaceNormal);\n    else if (id == 2)\n        albedo = materialColor3(surfacePos, surfaceNormal);\n    else\n        albedo = vec3(1, 0, 1); //ERROR: Unknown material\n    \n    return albedo;//surfaceLighting(surfacePos, surfaceNormal, albedo);\n}\n\n\n\nvec3 sceneColor(Camera cam, ColumnCast surfaceHit, vec2 uv)\n{\n    //If nothing was hit, set the \"hit distance\" to the max value.\n    float hitMask = step(0.0, surfaceHit.hitDist);\n    bool hitNothing = (hitMask == 0.0);\n    surfaceHit.hitDist = TRY(surfaceHit.hitDist, MAX_DISTANCE, hitNothing);\n    \n    //Compute 2D ray/position data.\n    float camHeadingRadians = getPixelHeading(cam, uv.x);\n    vec2 viewDir = vec2(cos(camHeadingRadians),\n                        sin(camHeadingRadians));\n    vec2 surfacePos = cam.pos + (viewDir * surfaceHit.hitDist);\n    \n    //Compute 3D ray/position data.\n    float verticalFOVDegrees = CAM_HORIZONTAL_FOV_DEGREES * (iResolution.y / iResolution.x),\n          verticalFOVHalfRadians = verticalFOVDegrees / 360.0 * PI2 / 2.0,\n          pitch = mix(-verticalFOVHalfRadians,\n                      verticalFOVHalfRadians,\n                      uv.y),\n          camZPos = 0.0;\n    vec3 viewDir3D = rotateAround(vec3(viewDir, 0.0),\n                                  vec3(getPerpendicularRight(viewDir), 0.0),\n                                  pitch);\n    float hitDist3D = TRY((surfacePos.x - cam.pos.x) / viewDir.x,\n                          (surfacePos.y - cam.pos.y) / viewDir.y,\n                          viewDir.x == 0.0);\n    vec3 wallHitPos3D = vec3(cam.pos, camZPos) + (viewDir3D * hitDist3D);\n    \n\n    //Calculate the wall color.\n    vec3 wallColor = TRY(materialColor(surfaceHit.materialID, wallHitPos3D, surfaceHit.hitNormal),\n                         vec3(1, 0, 1), //No wall, so this color should be 100% obscured by fog\n                         hitNothing);\n\n    //Check for intersection with the floor or ceiling, occluding the wall intersection.\n    float floorIntersectionDist = TRY((MIN_POS_3D.z - camZPos) / viewDir3D.z,\n                                      999999.0,\n                                      viewDir3D.z == 0.0),\n          ceilingIntersectionDist = TRY((MAX_POS_3D.z - camZPos) / viewDir3D.z,\n                                        999999.0,\n                                        viewDir3D.z == 0.0);\n    float floorMask = step(floorIntersectionDist, hitDist3D) *\n                      step(0.0, floorIntersectionDist),\n          ceilingMask = step(ceilingIntersectionDist, hitDist3D) *\n                        step(0.0, ceilingIntersectionDist);\n    ceilingMask *= 1.0-step(ceilingIntersectionDist, floorIntersectionDist);\n    float wallMask = 1.0 - min(1.0, (floorMask + ceilingMask));\n    \n    //Recompute the ray length/hit pos, given the floor and ceiling intersections.\n    float hitDist = (floorMask * floorIntersectionDist) +\n                    (ceilingMask * ceilingIntersectionDist) +\n                    (wallMask * hitDist3D);\n    vec2 cutoffSurfacePos = cam.pos + (viewDir * hitDist);\n    \n    //Find the visible surface color.\n    vec3 hitColor = (floorMask * floorColor(cutoffSurfacePos)) +\n                    (ceilingMask * ceilingColor(cutoffSurfacePos)) +\n                    (wallMask * wallColor);\n    \n    //Apply fog.\n    vec3 foggedColor = mix(hitColor, fogColor(viewDir3D),\n                           pow(min(1.0, hitDist / MAX_DISTANCE_3D + 0.2),\n                               2.0));\n\n    return foggedColor;\n}\n\n\nvec4 minimapColor(Camera cam, vec2 pos)\n{\n    //Flip the Y position for the display.\n    //Not sure why this is needed.\n    pos = vec2(pos.x,\n               mix(MAX_POS.y, MIN_POS.y, INV_LERP(MIN_POS.y, MAX_POS.y, pos.y)));\n    \n    vec2 uv = posToUV(pos);\n    \n    //Add a circle to represent the camera.\n    float camCircleMask = step(distance(pos, cam.pos), CAM_RADIUS);\n    \n    //Add lines representing the view cone.\n    float viewLineMask = 0.0;\n    for (int i = 0; i < 2; ++i)\n    {\n        float heading = getPixelHeading(cam, float(i));\n        vec2 facingDir = vec2(cos(heading), sin(heading));\n        \n        float acrossLine = distToLine(cam.pos, facingDir, pos, true),\n              alongLine = dot(facingDir, (pos - cam.pos));\n        viewLineMask += border(acrossLine, 0.0,\n                               0.02, 12.0) *\n                        step(CAM_RADIUS, alongLine) *\n                        step(alongLine, 0.2);\n    }\n    viewLineMask = SATURATE(viewLineMask);\n                         \n    //Visualize the walls.\n    Surface surf = readSurfaceData(BUF_A, uv);\n    float surfMask = TRY(0.0, 1.0, surf.isSolid);\n    vec3 surfColor = materialColor(surf.materialID, vec3(pos, 0.0), surf.normal);\n\n    return vec4(SATURATE((camCircleMask * vec3(0, 0.3, 1.0)) +\n                         (viewLineMask * vec3(0.5, 0.75, 0.0)) +\n                         (surfMask * surfColor)),\n                mix(0.675, 1.0,\n                    max(camCircleMask,\n                        max(viewLineMask, surfMask * 0.75))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Compute screen coordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n    int pixelX = int(fragCoord.x - 0.49999);\n    vec2 pos = uvToPos(uv);\n    \n    Camera cam = readCamData(BUF_B);\n    \n    //Draw the minimap.\n    vec2 minimapUVMin = vec2(0.7),\n         minimapUVSize = vec2(0.27, 0.27),\n         minimapUVMax = minimapUVMin + minimapUVSize,\n         minimapUV = INV_LERP(minimapUVMin, minimapUVMax, uv);\n    float minimapMask = step(0.0, minimapUV.x) * step(0.0, minimapUV.y) *\n                        step(minimapUV.x, 1.0) * step(minimapUV.y, 1.0);\n    float minimapBorder = (1.0 / 4.0) *\n                          (border(minimapUV.x, 0.0, 1.0, 16.0) +\n                           border(minimapUV.y, 0.0, 0.05, 2.0) +\n                           border(minimapUV.x, 1.0, 1.0, 16.0) +\n                           border(minimapUV.y, 1.0, 0.05, 2.0));\n    vec4 cMinimap = minimapColor(cam, minimapUV); //TODO: Faster to skip the minimap if it's not covering this pixel?\n    cMinimap.rgb *= 1.0 - minimapBorder;\n\n    //Draw the world.\n    ColumnCast column = readColumnCast(BUF_C, pixelX);\n    vec3 cWorld = sceneColor(cam, column, uv);\n    \n    //Combine the various drawing layers.\n    fragColor = vec4(mix(cWorld, cMinimap.rgb, minimapMask * cMinimap.a),\n                     1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float wallThickness(vec2 pos)\n{\n    return 0.15;\n    return pow(fract(iTime), 5.0);\n    \n    //Below is a thickness value that decreases towards the edge of the screen.\n    vec2 uv = posToUV(pos);\n    \n    float edgeDist = min(uv.x, min(uv.y, min(1.0 - uv.x, 1.0 - uv.y)));\n    float edgeT = 2.0 * edgeDist;\n    edgeT = 1.0 - pow(edgeT, 0.42);\n    \n    return mix(0.15, 0.225, edgeT);\n}\nfloat wallNoise(vec2 pos)\n{\n    RUN_OCTAVE_NOISE(\n        octaved, vec2, pos * 2.0,\n        \n        //Normal octave noise:\n        //perlinNoise(p, floor(iTime)),\n        //Ridge noise:\n        abs(perlinNoise(p, 4.453) - 0.5),\n        \n        4,\n        noise = pow(noise, 1.0),\n        2.0\n    );\n    return octaved;\n}\nint wallBiome(vec2 pos)\n{\n    float noise = perlinNoise(pos * 4.0, 0.234);\n    \n    return int(mix(0.0, float(N_MATERIALS) - 0.0001, noise));\n}\n\nSurface getWall(vec2 pos)\n{\n    float fieldStrength = wallNoise(pos);\n    \n    //Sample the neighboring noise values, and use\n    //    finite differences to compute a normal.\n    const float EPSILON = 0.001;\n    float fieldMinX = wallNoise(vec2(pos.x - EPSILON, pos.y)),\n          fieldMinY = wallNoise(vec2(pos.x, pos.y - EPSILON));\n    vec2 normal = normalize(vec2(fieldMinX - fieldStrength,\n                                 fieldMinY - fieldStrength));\n    \n    int biome = wallBiome(pos);\n    \n    Surface surf;\n    surf.isSolid = (fieldStrength < wallThickness(pos));\n    surf.normal = normal;\n    surf.materialID = biome;\n    \n    return surf;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 worldPos = uvToPos(uv);\n    Surface surf = getWall(worldPos);\n    \n    fragColor = packSurfaceData(surf);\n}", "buffer_a_inputs": [], "common_code": "#define PI (3.14159265)\n#define PI2 (PI * 2.0)\n\n#define INV_LERP(a, b, x) ((x - a) / (b - a))\n\n#define SATURATE(x) (clamp(x, 0.0, 1.0))\n\n#define SHARPEN(t) (smoothstep(0.0, 1.0, t))\n#define SHARPEN2(t) (SHARPEN(SHARPEN(t))\n#define SHARPENER(t) (t * t * t * (t * (t * 6. - 15.) + 10.))\n\n#define OSCILLATE(t) (0.5 + (0.5 * sin((t) * PI2)))\n\n#define TRY(value, backup, useBackup) ((useBackup) ? (backup) : (value))\n\nvec2 getPerpendicularRight(vec2 dir)\n{\n    //OpenGL's screen is left-handed.\n    return vec2(dir.y, -dir.x);\n}\n\nfloat distToLine(vec2 lineStart, vec2 lineDir, vec2 point, bool isRay)\n{\n    float t = dot(point - lineStart, lineDir);\n    if (isRay)\n        t = max(0.0, t);\n    vec2 closestLinePoint = lineStart + (lineDir * t);\n    \n    return distance(point, closestLinePoint);\n}\n\nfloat border(float x, float target, float thickness, float dropoff)\n{\n    float dist = abs(x - target);\n    float closeness = 1.0 - min(1.0, dist / thickness);\n    return pow(closeness, dropoff);\n}\n\nvec3 rotateAround(vec3 p, vec3 rotAxis, float rotAngleRadians)\n{\n    //Reference: https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n    float aCos = cos(rotAngleRadians),\n          aSin = sin(rotAngleRadians),\n          aCos1 = 1.0 - aCos;\n    vec3 dirSine = rotAxis * aSin,\n         dirSqrCos1 = rotAxis * rotAxis * aCos1;\n    mat3 rotMat = mat3(\n        //Column 1:\n        aCos + dirSqrCos1.x,\n        (rotAxis.y * rotAxis.x * aCos1) + dirSine.z,\n        (rotAxis.z * rotAxis.x * aCos1) - dirSine.y,\n        //Column 2:\n        (rotAxis.x * rotAxis.y * aCos1) - dirSine.z,\n        aCos + dirSqrCos1.y,\n        (rotAxis.z * rotAxis.y * aCos1) + dirSine.x,\n        //Column 3:\n        (rotAxis.x * rotAxis.z * aCos1) + dirSine.y,\n        (rotAxis.y * rotAxis.z * aCos1) - dirSine.x,\n        aCos + dirSqrCos1.z\n    );\n    return rotMat * p;\n}\n\n\n//////////////////\n// World Bounds //\n//////////////////\n\n#define MIN_POS vec2(0)\n#define MAX_POS vec2(1)\n#define MAX_DISTANCE (distance(MIN_POS, MAX_POS))\n\n//Define the floor and ceiling height\n#define MIN_POS_3D vec3(MIN_POS, -0.05)\n#define MAX_POS_3D vec3(MAX_POS, 0.1)\n#define MAX_DISTANCE_3D (distance(MIN_POS_3D, MAX_POS_3D))\n\nvec2 posToUV(vec2 pos) { return INV_LERP(MIN_POS, MAX_POS, pos); }\nvec2 uvToPos(vec2 uv) { return mix(MIN_POS, MAX_POS, uv); }\n\n\n//////////////\n// Buffer A //\n//////////////\n\n//Buffer A contains the walls of the level, in a sort of top-down view.\n//Each pixel represents a space that may be solid or empty.\nstruct Surface\n{\n    bool isSolid;\n    vec2 normal; //NOT normalized, for performance/sampling\n    int materialID; // From 0 to (N_MATERIALS-1)\n};\n\n#define N_MATERIALS 3\n\nSurface readSurfaceData(sampler2D bufferA, vec2 pos)\n{\n    Surface surf;\n    vec4 pixel = texture(bufferA, posToUV(pos));\n    \n    surf.isSolid = pixel.r > 0.5;\n    surf.normal = -1.0 + (2.0 * pixel.gb);\n    surf.materialID = int(round(pixel.a * float(N_MATERIALS)));\n    \n    return surf;\n}\n\nvec4 packSurfaceData(Surface surf)\n{\n    return vec4(\n        surf.isSolid ? 1.0 : 0.0,\n        0.5 + (0.5 * surf.normal),\n        float(surf.materialID) / float(N_MATERIALS)\n    );\n}\n\n\n//////////////\n// Buffer B //\n//////////////\n\n//Buffer B contains the player camera data in a small number of pixels.\n//The rest of the buffer texture is unused.\n\nstruct Camera\n{\n    vec2 pos;\n    float headingRadians, speed;\n};\n\n#define MAX_SPEED 0.1\n#define CAM_RADIUS 0.01\n#define CAM_HORIZONTAL_FOV_DEGREES 110.0\n\n\n#define BUF_B_COORD ivec2(0)\n#define BUF_B_FRAGCOORD vec2(0.5)\n#define BUF_B_UV vec2(0)\n\nCamera readCamData(sampler2D bufferB)\n{\n    vec4 color = texelFetch(bufferB, BUF_B_COORD, 0);\n    return Camera(mix(MIN_POS, MAX_POS, color.rg),\n                  color.b * PI2,\n                  color.a * MAX_SPEED);\n}\nvec4 packCamData(Camera data)\n{\n    return vec4(INV_LERP(MIN_POS, MAX_POS, data.pos),\n                mod(data.headingRadians, PI2) / PI2,\n                clamp(data.speed / MAX_SPEED, 0.0, 1.0));\n}\n\n//Define the FOV math for the camera.\nfloat getPixelHeading(Camera cam, float uvX)\n{\n    float fovRad = (CAM_HORIZONTAL_FOV_DEGREES / 360.0) * PI2,\n          halfFovRad = fovRad / 2.0,\n          headingOffset = mix(-halfFovRad, halfFovRad, uvX),\n          heading = cam.headingRadians + headingOffset;\n    return mod(heading, PI2);\n}\n\n\n\n//////////////\n// Buffer C //\n//////////////\n\n//Buffer C contains a raycast for each column of the output image,\n//    stored in the first row of the buffer.\n//All other rows are unused.\n\nstruct ColumnCast\n{\n    float hitDist; //A negative value means \"no hit\".\n    int materialID;\n    vec2 hitNormal;\n};\n\nColumnCast readColumnCast(sampler2D bufferC, int pixelX) //Taken as int because\n                                                         //The width of this buffer matches\n                                                         //    the width of the screen,\n                                                         //    so no linear filtering is needed.\n{\n    vec4 pixel = texelFetch(bufferC, ivec2(pixelX, 0), 0);\n    return ColumnCast(mix(-1.0, MAX_DISTANCE, pixel.r),\n                      int(round(pixel.g * float(N_MATERIALS))),\n                      -1.0 + (2.0 * pixel.ba));\n}\nvec4 packColumnCast(ColumnCast cc)\n{\n    return vec4(INV_LERP(-1.0, MAX_DISTANCE, cc.hitDist),\n                INV_LERP(0.0, float(N_MATERIALS), float(cc.materialID)),\n                0.5 + (0.5 * cc.hitNormal));\n}\n\n\n\n////////////////////\n//    Hashing     //\n////////////////////\n\n//Source: https://stackoverflow.com/a/17479300\n\n//Hashes 1D-4D uints to 1 uint,\n//    or 1D-4D floats to 1 float.\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\nfloat hash( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat hash( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat hash( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat hash( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec2 randUnitVector(float uniformRandom)\n{\n    float theta = uniformRandom * PI2;\n    return vec2(cos(theta), sin(theta));\n}\n\n\n///////////////////////////////\n//    Value/Perlin Noise     //\n///////////////////////////////\n\nfloat valueNoise(float x, float seed)\n{\n    float xMin = floor(x),\n          xMax = ceil(x);\n\n    float noiseMin = hash(vec2(xMin, seed)),\n          noiseMax = hash(vec2(xMax, seed));\n\n    float t = x - xMin;\n    //t = SMOOTHERSTEP(t); //Actually gives worse results due to\n                           //  the dumb simplicity of the underlying noise\n    \n    return mix(noiseMin, noiseMax, t);\n}\nfloat valueNoise(vec2 x, float seed)\n{\n    vec2 xMin = floor(x),\n         xMax = ceil(x);\n    vec4 xMinMax = vec4(xMin, xMax);\n\n    vec2 t = x - xMin;\n    //t = SMOOTHERSTEP(t); //Actually gives worse results due to\n                           //  the dumb simplicity of the underlying noise\n    \n    #define VALUE_NOISE_2D(pos) hash(vec3(pos, seed))\n    return mix(mix(VALUE_NOISE_2D(xMinMax.xy),\n                   VALUE_NOISE_2D(xMinMax.zy),\n                   t.x),\n               mix(VALUE_NOISE_2D(xMinMax.xw),\n                   VALUE_NOISE_2D(xMinMax.zw),\n                   t.x),\n               t.y);\n}\n\n#define PERLIN_MAX(nDimensions) (sqrt(float(nDimensions)) / 2.0)\nfloat perlinNoise(float x, float seed)\n{\n    float xMin = floor(x),\n          xMax = ceil(x),\n          t = x - xMin;\n\n    float value = mix(t         * sign(hash(vec2(xMin, seed)) - 0.5),\n                      (1.0 - t) * sign(hash(vec2(xMax, seed)) - 0.5),\n                      SHARPENER(t));\n    return INV_LERP(-PERLIN_MAX(1), PERLIN_MAX(1), value);\n}\n\nvec2 perlinGradient2(float t)\n{\n    return randUnitVector(t);\n}\nfloat perlinNoise(vec2 p, float seed)\n{\n    vec2 pMin = floor(p),\n         pMax = pMin + 1.0,\n         t = p - pMin;\n    vec4 pMinMax = vec4(pMin, pMax),\n         tMinMax = vec4(t, t - 1.0);\n\n    float noiseMinXMinY = dot(tMinMax.xy,\n                              perlinGradient2(hash(vec3(pMinMax.xy, seed)))),\n          noiseMaxXMinY = dot(tMinMax.zy,\n                              perlinGradient2(hash(vec3(pMinMax.zy, seed)))),\n          noiseMinXMaxY = dot(tMinMax.xw,\n                              perlinGradient2(hash(vec3(pMinMax.xw, seed)))),\n          noiseMaxXMaxY = dot(tMinMax.zw,\n                              perlinGradient2(hash(vec3(pMinMax.zw, seed))));\n\n    t = SHARPENER(t);\n    float value = mix(mix(noiseMinXMinY, noiseMaxXMinY, t.x),\n                      mix(noiseMinXMaxY, noiseMaxXMaxY, t.x),\n                      t.y);\n    return INV_LERP(-PERLIN_MAX(2), PERLIN_MAX(2), value);\n}\n\n\n/////////////////////////\n//    Octave Noise     //\n/////////////////////////\n\n\n//Generates an implementation of octave noise.\n#define RUN_OCTAVE_NOISE(outputName, posType, inputPos, callNoiseOnP, \\\n                         nOctaves, modifyNoise, persistence) \\\nfloat outputName; { \\\n    float sum = 0.0, \\\n          scale = 1.0, \\\n          weight = 1.0, \\\n          totalWeight = 0.0; \\\n    for (int i = 0; i < nOctaves; ++i) { \\\n        posType p = inputPos * scale; \\\n        float noise = callNoiseOnP; \\\n        modifyNoise; \\\n        sum += weight * noise; \\\n        totalWeight += weight; \\\n        scale *= persistence; \\\n        weight /= persistence; \\\n    } \\\n    outputName = sum / totalWeight; \\\n}", "buffer_b_code": "#define BUF_A iChannel0\n#define BUF_B iChannel1\n\n\nCamera initializeCamera()\n{\n    //TODO: Implement something more clever,\n    //         such as picking random starting points until one is empty.\n    return Camera(mix(MIN_POS, MAX_POS, vec2(0.3, 0.5)),\n                  PI2 * 0.75, 0.0);\n}\nvoid updateCamera(inout Camera cam)\n{\n    //TODO: Let the user control it.\n    cam.headingRadians = mod(cam.headingRadians + 0.005, PI2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Only a few pixels are used in this buffer to store the camera state.\n    if (fragCoord != BUF_B_FRAGCOORD)\n    {\n        fragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    \n    //On the first frame, pick a good initial position.\n    if (iFrame == 0)\n    {\n        Camera firstState = initializeCamera();\n        fragColor = packCamData(firstState);\n    }\n    //On subsequent frames, run the camera's control logic.\n    else\n    {\n        Camera currentState = readCamData(BUF_B);\n        updateCamera(currentState);\n        fragColor = packCamData(currentState);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define BUF_A iChannel0\n#define BUF_B iChannel1\n\n\nColumnCast getRayHit(vec2 rayStart, vec2 rayDir)\n{\n    vec2 texel = uvToPos(1.0 / iResolution.xy);\n    for (int i = 0; i < 500; ++i) //TODO: Max raymarch iterations based on map size\n    {\n        vec2 rayStep = rayDir * (texel * float(i)),\n             rayPos = rayStart + rayStep;\n        Surface surf = readSurfaceData(BUF_A, rayPos);\n        if (surf.isSolid)\n            return ColumnCast(length(rayStep), surf.materialID,\n                              normalize(surf.normal)); //Used linear filtering on this buffer\n        else if ((rayPos.x > MAX_POS.x) || (rayPos.x < MIN_POS.x) ||\n                 (rayPos.y > MAX_POS.y) || (rayPos.y < MIN_POS.y))\n            return ColumnCast(-1.0, 0, vec2(1, 0));\n    }\n    \n    return ColumnCast(-1.0, 0, vec2(1, 0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y >= 1.0)\n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    float uvX = fragCoord.x / iResolution.x;\n    \n    Camera cam = readCamData(BUF_B);\n    cam.headingRadians = getPixelHeading(cam, uvX);\n    \n    //Raymarch from the camera into the world.\n    vec2 rayDir = vec2(cos(cam.headingRadians),\n                       sin(cam.headingRadians));\n    ColumnCast hit = getRayHit(cam.pos, rayDir);\n    \n    fragColor = packColumnCast(hit);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nddyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 103, 103, 214], [216, 216, 247, 247, 271], [272, 272, 305, 305, 329], [331, 331, 391, 391, 580], [581, 581, 639, 639, 667], [669, 669, 748, 748, 859], [860, 860, 918, 1035, 1952], [1954, 1954, 2012, 2012, 2524], [2525, 2525, 2590, 2590, 2994], [2998, 2998, 3059, 3126, 6208], [6211, 6211, 6252, 6330, 7743], [7746, 7746, 7803, 7837, 9097]]}
{"id": "7tlfD4", "name": "Detailed 2d Terrain", "author": "cra_manning_w", "description": "Releasing it half-finished, feel free to hack on the two unused biomes!", "tags": ["2d", "terrain"], "likes": 1, "viewed": 229, "published": 3, "date": "1656107428", "time_retrieved": "2024-07-30T16:43:19.021212", "image_code": "#define TEX_BUF_A iChannel1\n#define TEX_BUF_B iChannel2\n\n//TODO: Structs for each biome's pre-computed data that might be relevant around biome intersections.\n\n\nvec3 colorTerrain_Water(Camera cam, SunState sun,\n                        BufferA bufA, BufferB bufB,\n                        BufferA bufACloseNeighbors[4], BufferA bufAFarNeighbors[4],\n                        BufferB bufBCloseNeighbors[4], BufferB bufBFarNeighbors[4])\n{\n    return vec3(0.35, 0.55, 0.85);\n}\nvec3 colorTerrain_Plains(Camera cam, SunState sun,\n                         BufferA bufA, BufferB bufB,\n                         BufferA bufACloseNeighbors[4], BufferA bufAFarNeighbors[4],\n                         BufferB bufBCloseNeighbors[4], BufferB bufBFarNeighbors[4])\n{\n    vec3 plainsColor = mix(vec3(0.0, 0.3, 0.1),\n                           vec3(0.1, 0.97, 0.25),\n                           pow(cam.pixelWorld.y / bufA.terrHeight, 0.48));\n\n    //There may be some small caves coming from a nearby mountain biome.\n    float caveEdge = bufA.caveMask * (1.0 - BUF_PULL_MAXX(bufACloseNeighbors).caveMask);\n    vec3 caveColor = vec3(0.32, 0.19, 0.06),\n         caveBorderColor = vec3(0.5);\n    return mix(mix(plainsColor, caveColor, bufA.caveMask),\n               caveBorderColor,\n               caveEdge);\n}\n\nvec3 colorTerrain_Mountains(Camera cam, SunState sun,\n                            BufferA bufA, BufferB bufB,\n                            BufferA bufACloseNeighbors[4], BufferA bufAFarNeighbors[4],\n                            BufferB bufBCloseNeighbors[4], BufferB bufBFarNeighbors[4])\n{\n    vec2 pos = cam.pixelWorld;\n    \n    //Cave data:\n    float caveMask = bufA.caveMask,\n          caveEdgeMask = caveMask * (1.0 - BUF_PULL_MAXX(bufACloseNeighbors).caveMask);\n    //If on the floor of a cave, provide some noisy surface color.\n    float caveFloorMask = bufA.caveMask *\n                          SATURATE(\n                              //An adjacent empty space means this is definitely a floor pixel.\n                              (1.0 - BUF_PULL_MINY(bufACloseNeighbors).caveMask)\n                              //Empty space a bit further above has a weaker effect on the floor mask.\n                                + step(BUF_PULL_MINY(bufAFarNeighbors).caveMask,\n                                       hashT(pos * 2.234).a)\n                          ),\n          caveFloorNoise = mix(0.5, 1.0, hashT(pos.x * 1.2312).b) *\n                           octaveNoise(pos.x * 20.0, 2.22781, 3, 2.0),\n          caveFloorColorT = SHARPEN(SHARPEN(SHARPEN(0.1 + pos.y / bufA.terrHeight)));\n\n    //TODO: Raymarch to see if sunlight is visible from caves along the surface\n    //TODO: Remove 'iron ore' from Buffer B, add rock data to it, give rocks a better border\n                       \n    //Rocks:\n    float rockNoise = 1.0 - worley3(pos * 80.0,\n                                    mix(0.5, 0.0, pos.y / bufA.terrHeight),\n                                    1.2135);\n    rockNoise = pow(rockNoise * step(0.55, rockNoise), 0.75);\n    rockNoise *= 1.0 - step(0.75, worley1(pos * 20.0,\n                                          0.4,\n                                          1.61421));\n    float rockMask = step(0.5, rockNoise) *\n                     //Keep inside the mountain biome, but spread out in shallower ground.\n                     step(0.9 * (1.0 - pos.y), bufA.biome);\n    float rockValue = rockMask\n                        * SHARPEN(SHARPEN(SHARPEN(SHARPEN(pow(rockNoise, 1.5)))))\n                        * mix(0.625, 1.0, hashT(floor(pos * 500.0)).r),\n          rockBorderMask = border(rockNoise, 0.65, 0.55, 13.0);\n\n    //Check gold ore.\n    //TODO: Hiding this in a branch based on gold weight may speed things up, because most pixels have no gold.\n    float oreGoldNoise = bufferOreWeight(bufB.goldMask),\n          oreGoldMask = step(0.0001, bufB.goldMask),\n          oreGoldNeighborCount = bufferOreMask(bufBCloseNeighbors[0].goldMask) +\n                                 bufferOreMask(bufBCloseNeighbors[1].goldMask) +\n                                 bufferOreMask(bufBCloseNeighbors[2].goldMask) +\n                                 bufferOreMask(bufBCloseNeighbors[3].goldMask),\n          oreGoldBorder = oreGoldMask *\n                          pow(1.0 - (oreGoldNeighborCount / 4.0), 0.5);\n    //Interpret the gold noise value as a bumpmap,\n    //    and do pseudo-normal-mapping to make an interesting look.\n    #define GOLD_BUMP(pull_dir) (bufferOreMask(pull_dir(bufBCloseNeighbors).goldMask) *    \\\n                                 mix(0.5, 1.0, bufferOreWeight(pull_dir(bufBCloseNeighbors).goldMask)))\n    #define GOLD_LIGHTING_AMBIENT 0.475\n    vec2 normal = normalize(vec2(0.00001) +\n                            vec2(GOLD_BUMP(BUF_PULL_MINX) - GOLD_BUMP(BUF_PULL_MAXX),\n                                 GOLD_BUMP(BUF_PULL_MINY) - GOLD_BUMP(BUF_PULL_MAXY)));\n    float oreGoldBrightness = oreGoldMask *\n                              max(GOLD_LIGHTING_AMBIENT, dot(-normal, sun.dir)),\n          oreGoldSpecular = pow(oreGoldBrightness, 60.0);\n\n    //Compute the final color:\n    return mix(\n        mix(\n            mix(\n                mix(\n                    mix(\n                        //The mountain's base color:\n                        vec3(0.32, 0.19, 0.06),\n                        //Apply the gold ore:\n                        mix(\n                            oreGoldBrightness * sun.brightness *\n                              mix(mix(vec3(0.66, 0.62, 0.3),\n                                      vec3(0.86, 0.8, 0.35),\n                                      oreGoldNoise),\n                                  //Apply the gold ore's border:\n                                  vec3(1.0, 1.0, 0.3),\n                                  oreGoldBorder),\n                            //Apply specular color to the gold ore:\n                            sun.brightness,\n                            oreGoldSpecular\n                        ),\n                        oreGoldMask\n                    ),\n                    //Apply the rocks:\n                    mix(vec3(0.87, 0.82, 0.85),\n                        //Apply the rock border:\n                        vec3(0.55, 0.5, 0.6),\n                        rockBorderMask),\n                    rockValue\n                ),\n                //Apply the cave hole color:\n                vec3(0.032, 0.019, 0.006),\n                caveMask\n            ),\n            //Apply the cave border color:\n            pow(vec3(0.032, 0.019, 0.006), vec3(0.2)),\n            caveEdgeMask\n        ),\n        //Apply the floor color to cave floors:\n        mix(vec3(0.85, 0.35, 0.15),\n            vec3(0.3, 0.85, 0.45),\n            caveFloorColorT)\n          * caveFloorNoise,\n        caveFloorMask\n    );\n}\n\nvec3 colorTerrain(Camera cam, SunState sun, BufferA bufA)\n{\n    BufferB bufB = readBufferB(TEX_BUF_B, cam.screenUV);\n    \n    //Sample from neighbors to get more information.\n    vec2 closeRadius = vec2(1.0),\n         farRadius = vec2(2.0);\n    BUF_SAMPLE_AROUND_ME(BufferA, TEX_BUF_A, cam.screenUV, closeRadius, bufACloseNeighbors)\n    BUF_SAMPLE_AROUND_ME(BufferA, TEX_BUF_A, cam.screenUV, farRadius, bufAFarNeighbors)\n    BUF_SAMPLE_AROUND_ME(BufferB, TEX_BUF_B, cam.screenUV, closeRadius, bufBCloseNeighbors)\n    BUF_SAMPLE_AROUND_ME(BufferB, TEX_BUF_B, cam.screenUV, farRadius, bufBFarNeighbors)\n\n    //Use a branch to reduce the amount of coloring work per-pixel from 3 biomes to 2.\n    //The branch should be pretty coherent, because\n    //    biomes are large and don't change vertically.\n    #define COLORING_ARGS cam,sun,bufA,bufB,\\\n                          bufACloseNeighbors,bufAFarNeighbors,bufBCloseNeighbors,bufBFarNeighbors\n    if (bufA.biome < 0.5)\n        return mix(colorTerrain_Water(COLORING_ARGS),\n                   colorTerrain_Plains(COLORING_ARGS),\n                   SHARPEN(SHARPEN(smoothstep(0.0, 0.5, bufA.biome))));\n    else\n        return mix(colorTerrain_Plains(COLORING_ARGS),\n                   colorTerrain_Mountains(COLORING_ARGS),\n                   SHARPEN(SHARPEN(smoothstep(0.5, 1.0, bufA.biome))));\n}\n\n\nfloat raymarchedClouds(Camera cam, SunState sun, float time)\n{\n    float seed = 0.989;\n    float cloudStrength = 0.0;\n    //\"Raymarch\" through multiple parallax layers of clouds.\n    #define N_ITERATIONS 5\n    for (int i = 0; i < N_ITERATIONS; ++i)\n    {\n        float depthT = float(i) / float(N_ITERATIONS-1);\n        float iterSeed = seed + (10.0 * fract(100.0 * depthT));\n        \n        //Compute the world position of this layer of clouds under the pixel.\n        float cloudSpeed = 0.2 * mix(0.2, 0.01, depthT);\n        vec2 cloudPosParallax = vec2(\n            (iTime * cloudSpeed) + iterSeed,\n            0.0\n        );\n        float cloudScale = mix(1.0, 1.5, depthT);\n        #define CLOUD_NOISE_POS(scale) ((cam.pixelWorld * cloudScale * (scale)) + cloudPosParallax)\n        \n        float cloudMask = worley1(CLOUD_NOISE_POS(vec2(0.5, 2.0)),\n                                  iterSeed + 0.5721, 0.4);\n        cloudMask = 1.0 - cloudMask;\n        cloudMask *= pow(cam.pixelWorld.y, 1.21);\n        cloudMask = SHARPEN(SHARPEN(SHARPEN(cloudMask)));\n        cloudMask = pow(cloudMask, 0.65);\n        \n        float sunStrength = 1.0 - SATURATE(distance(cam.pixelWorld, sun.worldPos) - 0.04);\n        sunStrength = pow(sunStrength, 20.0);\n        \n        float cloudNoise = octaveWorley1Noise(CLOUD_NOISE_POS(2.0),\n                                              iterSeed + 8.3423,\n                                              4, 2.0,\n                                              1.0);\n        cloudNoise = pow(1.0 - cloudNoise, 0.9);\n        cloudNoise += sunStrength * pow(cloudNoise, 0.95);\n        cloudNoise = pow(SATURATE(cloudNoise), 0.75);\n        cloudNoise = SHARPEN(cloudNoise);\n        \n        float brightness = 1.5;\n        cloudStrength += cloudMask * cloudNoise * brightness;\n    }\n    \n    return SATURATE(cloudStrength / float(N_ITERATIONS));\n}\n//TODO: Try coarser clouds using a worley-esque approach.\n\nvec3 colorSky(Camera cam, SunState sun, BufferA bufA)\n{\n    //TODO: If near the terrain, output a \"shadow\" of it, based on sun direction.\n    \n    //Compute sun data.\n    float sunField = 1.0 - SATURATE(distance(cam.pixelWorld, sun.worldPos) - 0.04),\n          sunStrength = pow(sunField, 50.0);\n    \n    //Compute clouds.\n    float cloudStrength = raymarchedClouds(cam, sun, iTime);\n    //TODO: Color the clouds based on sun direction and distance\n    \n    return pow(\n        mix(\n            //Make the sky bluer near the zenith.\n            mix(vec3(0.5, 0.5, 1.0),\n                vec3(0.15, 0.15, 1.0),\n                cam.pixelWorld.y),\n            //Draw the sun:\n            vec3(1.0, 0.95, 0.45),\n            sunStrength    \n        ),\n        //Apply clouds:\n        vec3(1.0 - cloudStrength)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.a = 1.0;\n       \n    Camera cam = getCamera(fragCoord, iTime, iMouse.xy / iResolution.xy);\n    SunState sun = getSunData(cam, iTime);\n    \n    BufferA bufA = readBufferA(TEX_BUF_A, cam.screenUV);\n    \n    if (cam.pixelWorld.y > bufA.terrHeight)\n        fragColor.rgb = colorSky(cam, sun, bufA);\n    else\n        fragColor.rgb = colorTerrain(cam, sun, bufA);\n\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "                            // Header: Enable access to inputs from Common tab\n                            // See https://www.shadertoy.com/view/ttf3R4\n                                #if __LINE__<17          // Must be on line 3!\n                                #define _ST_TAB_COMMON\n                                #endif\n                                #if __LINE__<25\n                                #define _ST_TAB_SOUND\n                                uniform vec3 iResolution; // Sound tab\n                                uniform float iTime;  // never defines these\n                                #endif\n                                #ifdef _ST_TAB_COMMON\n                                #undef _ST_TAB_SOUND\n                                uniform float iTimeDelta;\n                                uniform int iFrame;\n                                uniform float iChannelTime[4];\n                                uniform vec3 iChannelResolution[4];\n                                uniform vec4 iMouse;\n                                // iDate and iSampleRate: Alread have them.\n                                uniform sampler2D iChannel0;\n                                uniform sampler2D iChannel1; // Change type to\n                                uniform sampler2D iChannel2; // samplerCube\n                                uniform sampler2D iChannel3; // if Cube input\n                                #endif\n                            // End header\n//Above header indented to separate it from the rest of the code.\n      \n      \n#define PI 3.1415926535898\n#define PI2 (2.0 * PI)\n\n#define PHI 1.618033988\n\n#define COMMA , /* Helps for more complex macros */\n                      \n\n///////////////////////\n//    Randomness     //\n///////////////////////\n\n//The texture that's sampled for randomness.\n//Note that it's not normally available within the Common tab;\n//    there is some hacky code at the top of this file to support this.\n#define RNG_TEX iChannel0\n\n//Meant for hashing small values.\nvec4 hashT(vec2 t) { return textureLod(RNG_TEX, t * PI * 5.0, 0.0); }\nvec4 hashT(float t) { return hashT(vec2(t)); }\nvec4 hashT(vec3 t) { return hashT(t.xy + t.z); }\nvec4 hashT(vec4 t) { return hashT(t.xy + t.zw); }\n\n\n//////////////////////\n//    Utilities     //\n//////////////////////\n\n#define OSCILLATE(a, b, input) (mix(a, b, 0.5 + (0.5 * sin(PI2 * (input)))))\n\n#define INV_LERP(a, b, x) ((x-a) / (b-a))\n#define SATURATE(x) clamp(x, 0.0, 1.0)\n#define SHARPEN(t) smoothstep(0.0, 1.0, t)\n\n#define RAND_IN_ARRAY(array, t) array[int(mix(0.0, float(array.length()) - 0.00001, t))]\n\n//A higher-quality smoothstep(), with a zero second-derivative at the edges.\n#define SMOOTHERSTEP(t) clamp(t * t * t * (t * (t*6.0 - 15.0) + 10.0), \\\n                              0.0, 1.0)\n\n//Returns a value that increases towards 1 as it gets closer to some target.\nfloat border(float x, float target, float thickness, float dropoff)\n{\n    float dist = abs(x - target);\n    float closeness = 1.0 - min(1.0, dist / thickness);\n    return pow(closeness, dropoff);\n}\n\n//Distance-squared is faster to compute in 2D+, but not in 1D.\n//Some noise is defined with the help of macros to work with any dimensionality,\n//    and so is agnostic to the dimensionality.\nfloat efficientDist(float a, float b) { return abs(b - a); }\nfloat efficientDist(vec2 a, vec2 b) { vec2 delta = b - a; return dot(delta, delta); }\nfloat efficientDist(vec3 a, vec3 b) { vec3 delta = b - a; return dot(delta, delta); }\nfloat efficientDist(vec4 a, vec4 b) { vec4 delta = b - a; return dot(delta, delta); }\nfloat realDist(float efficientDist, float posType) { return efficientDist; }\nfloat realDist(float efficientDist, vec2 posType) { return sqrt(efficientDist); }\nfloat realDist(float efficientDist, vec3 posType) { return sqrt(efficientDist); }\nfloat realDist(float efficientDist, vec4 posType) { return sqrt(efficientDist); }\n\nfloat sumComponents(float f) { return f; }\nfloat sumComponents(vec2 v) { return v.x + v.y; }\nfloat sumComponents(vec3 v) { return v.x + v.y + v.z; }\nfloat sumComponents(vec4 v) { return v.x + v.y + v.z + v.w; }\n\n//Gets the angle of the given vector, in the range 0-1.\nfloat angleT(vec2 dir) { return 0.5 + (0.5 * atan(dir.y, dir.x)/PI); }\n\n//Given a uniformly-distributed value, and another target value,\n//    biases the uniform value towards the target.\n//The \"biasStrength\" should be between 0 and 1.\nfloat applyBias(float x, float target, float biasStrength)\n{\n    //Degenerative case if x=0.\n    if (x == 0.0)\n        return mix(x, target, biasStrength);\n    \n    //Get the \"scale\" of the target relative to x.\n    //Multiplying x by this number would give exactly the target.\n    float scale = target / x;\n    \n    //Weaken the \"scale\" by pushing it towards 1.0, then apply it to 'x'.\n    //Make sure to respect the sign, in case 'x' or 'target' is negative.\n    return x * sign(scale) * pow(abs(scale), biasStrength);\n}\n\n//Linearly interpolates between a beginning, midpoint, and endpoint.\nfloat tripleLerp(float a, float b, float c, float t)\n{\n    vec3 lerpArgs = (t < 0.5) ?\n                        vec3(a, b, INV_LERP(0.0, 0.5, t)) :\n                        vec3(b, c, INV_LERP(0.5, 1.0, t));\n    return mix(lerpArgs.x, lerpArgs.y, lerpArgs.z);\n}\nvec3 tripleLerp(vec3 a, vec3 b, vec3 c, float t)\n{\n    bool isFirstHalf = (t < 0.5);\n    return isFirstHalf ?\n               mix(a, b, INV_LERP(0.0, 0.5, t)) :\n               mix(b, c, INV_LERP(0.5, 1.0, t));\n    \n}\n//Smoothly interpolates between a beginning, midpoint, and endpoint.\nfloat tripleSmoothstep(float a, float b, float c, float t)\n{\n    vec4 lerpArgs = (t < 0.5) ?\n                        vec4(a, b, 0.0, 0.5) :\n                        vec4(b, c, 0.5, 1.0);\n    return mix(lerpArgs.x, lerpArgs.y, smoothstep(lerpArgs.z, lerpArgs.w, t));\n}\n//Interpolates between a beginning, midpoint, and endpoint, with aggressive smoothing.\nfloat tripleSmoothSmoothstep(float a, float b, float c, float t)\n{\n    vec4 lerpArgs = (t < 0.5) ?\n                        vec4(a, b, 0.0, 0.5) :\n                        vec4(b, c, 0.5, 1.0);\n    return mix(lerpArgs.x, lerpArgs.y, smoothstep(0.0, 1.0, smoothstep(lerpArgs.z, lerpArgs.w, t)));\n}\n\nfloat distToLine(vec2 lineP, vec2 lineDir, vec2 pos)\n{\n    //Reference: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    \n    vec2 numerator2 = lineDir * (lineP - pos).yx;\n    return abs(numerator2.x - numerator2.y) / length(lineDir);\n}\n\n//RGB<=>HSV converter, from here: https://stackoverflow.com/a/17897228\nvec3 RGBtoHSV(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 HSVtoRGB(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n////////////////\n//   Ripple   //\n////////////////\n\n//An oscillating value, as a function of the angle around a circle.\nstruct Ripple\n{\n    float scale, speed;\n    int nSpikes;\n    bool canBeNegative;\n};\nfloat ripple(Ripple r, float angleT, float time)\n{\n    float inpt = (time * r.speed) +\n                  (angleT * float(r.nSpikes));\n    float minVal = (r.canBeNegative ? -r.scale : 0.0);\n    return OSCILLATE(minVal, r.scale, inpt);\n}\n\nvec2 rippleRange(Ripple r)\n{\n    return vec2(r.canBeNegative ? -r.scale : 0.0,\n                r.scale);\n}\n\n\n///////////////////////////////\n//    Value/Octave Noise     //\n///////////////////////////////\n\nfloat valueNoise(float x, float seed)\n{\n    float xMin = floor(x),\n          xMax = ceil(x);\n\n    float noiseMin = hashT(vec2(xMin, seed)).r,\n          noiseMax = hashT(vec2(xMax, seed)).r;\n\n    float t = x - xMin;\n    //t = SMOOTHERSTEP(t); //Actually gives worse results due to\n                           //  the dumb simplicity of the underlying noise\n    \n    return mix(noiseMin, noiseMax, t);\n}\nfloat valueNoise(vec2 x, float seed)\n{\n    vec2 xMin = floor(x),\n         xMax = ceil(x);\n    vec4 xMinMax = vec4(xMin, xMax);\n\n    vec2 t = x - xMin;\n    //t = SMOOTHERSTEP(t); //Actually gives worse results due to\n                           //  the dumb simplicity of the underlying noise\n    \n    #define VALUE_NOISE_2D(pos) hashT(vec3(pos, seed)).r\n    return mix(mix(VALUE_NOISE_2D(xMinMax.xy),\n                   VALUE_NOISE_2D(xMinMax.zy),\n                   t.x),\n               mix(VALUE_NOISE_2D(xMinMax.xw),\n                   VALUE_NOISE_2D(xMinMax.zw),\n                   t.x),\n               t.y);\n}\n\n//Octave noise behaves the same regardless of dimension.\n#define IMPL_OCTAVE_NOISE(noiseFunc, noiseMidArg)                    \\\n    float sum = 0.0,                                                 \\\n          scale = 1.0,                                               \\\n          nextWeight = 1.0,                                          \\\n          totalWeight = 0.0;                                         \\\n    for (int i = 0; i < nOctaves; ++i)                               \\\n    {                                                                \\\n        sum += noiseFunc(x * scale, noiseMidArg seed + float(i)) * nextWeight;  \\\n        totalWeight += nextWeight;                                   \\\n                                                                     \\\n        nextWeight /= persistence;                                   \\\n        scale *= persistence;                                        \\\n    }                                                                \\\n                                                                     \\\n    return sum / totalWeight;\nfloat octaveNoise(float x, float seed, int nOctaves, float persistence) { IMPL_OCTAVE_NOISE(valueNoise, ) }\nfloat octaveNoise(vec2 x, float seed, int nOctaves, float persistence) { IMPL_OCTAVE_NOISE(valueNoise, ) }\n\n\n/////////////////////////\n//    Worley Noise     //\n/////////////////////////\n\n//Helper function for worley noise that finds the point in a cell.\n//Outputs its position, and returns whether or not it really exists.\nbool getWorleyPoint(float cell, float chanceOfPoint, float seed, out float pos)\n{\n    vec2 rng = hashT(vec2(cell, seed)).xy;\n    \n    pos = cell + rng.x;\n    return (rng.y < chanceOfPoint);\n}\nbool getWorleyPoint(vec2 cell, float chanceOfPoint, float seed, out vec2 pos)\n{\n    vec3 rng = hashT(vec3(cell, seed)).xyz;\n    \n    pos = cell + rng.xy;\n    return (rng.z < chanceOfPoint);\n}\n\n//Generates worley-noise points that might influence the given position.\n//See the below functions for common use-cases.\nvoid worleyPoints(float x, float chanceOfPoint, float seed,\n                  out int outNPoints, out float outPoints[3]);\nvoid worleyPoints(vec2 x, float chanceOfPoint, float seed,\n                  out int outNPoints, out float outPoints[3]);\n//Implementation below:\n#define IMPL_WORLEY_START(T)                                    \\\n    T xCenter = floor(x),                                       \\\n      xMin = xCenter - 1.0,                                     \\\n      xMax = xCenter + 1.0;                                     \\\n    nPoints = 0;                                                \\\n    T nextPoint\n//end #define\n#define IMPL_WORLEY_POINT(cellPos)                                  \\\n    if (getWorleyPoint(cellPos, chanceOfPoint, seed, nextPoint))    \\\n        points[nPoints++] = nextPoint\n//end #define\nvoid worleyPoints(float x, float chanceOfPoint, float seed,\n                  out int nPoints, out float points[3])\n{\n    IMPL_WORLEY_START(float);\n    IMPL_WORLEY_POINT(xMin);\n    IMPL_WORLEY_POINT(xCenter);\n    IMPL_WORLEY_POINT(xMax);\n}\nvoid worleyPoints(vec2 x, float chanceOfPoint, float seed,\n                  out int nPoints, out vec2 points[9])\n{\n    IMPL_WORLEY_START(vec2);\n    \n    IMPL_WORLEY_POINT(xMin);\n    IMPL_WORLEY_POINT(xCenter);\n    IMPL_WORLEY_POINT(xMax);\n    \n    IMPL_WORLEY_POINT(vec2(xMin.x, xCenter.y));\n    IMPL_WORLEY_POINT(vec2(xMin.x, xMax.y));\n    \n    IMPL_WORLEY_POINT(vec2(xCenter.x, xMin.y));\n    IMPL_WORLEY_POINT(vec2(xCenter.x, xMax.y));\n    \n    IMPL_WORLEY_POINT(vec2(xMax.x, xMin.y));\n    IMPL_WORLEY_POINT(vec2(xMax.x, xCenter.y));\n}\n\n//Variant 1: straight-line distance, to the nearest point.\nfloat worley1(float x, float chanceOfPoint, float seed);\nfloat worley1(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY1(T, nMaxPoints)                                              \\\nfloat worley1(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist = 9999999.9;                                                   \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /*Specify a hard-coded cap,  */            \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        minDist = min(minDist, efficientDist(points[i], x));                     \\\n    }                                                                            \\\n    return min(realDist(minDist, points[0]), 1.0);                \\\n}\n//end #define\nIMPL_WORLEY1(float, 3)\nIMPL_WORLEY1(vec2,  9)\n\n//Variant 2: manhattan distance, to the nearest point.\nfloat worley2(float x, float chanceOfPoint, float seed);\nfloat worley2(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY2(T, nMaxPoints)                                              \\\nfloat worley2(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist = 9999999.9;                                                   \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /* Specify a hard-coded cap,  */           \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        minDist = min(minDist, sumComponents(abs(points[i] - x)));               \\\n    }                                                                            \\\n    return min(realDist(minDist, points[0]), 1.0);                               \\\n}\n//end #define\nIMPL_WORLEY2(float, 3)\nIMPL_WORLEY2(vec2,  9)\n\n//Variant 3: straight-line distance, to the second- nearest point.\nfloat worley3(float x, float chanceOfPoint, float seed);\nfloat worley3(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY3(T, nMaxPoints)                                              \\\nfloat worley3(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist1 = 9999999.9,                                                  \\\n          minDist2 = 9999999.9;                                                  \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /* Specify a hard-coded cap,  */           \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        float newD = efficientDist(points[i], x);                                \\\n        if (newD < minDist1) {                                                   \\\n            minDist2 = minDist1; minDist1 = newD;                                \\\n        } else if (newD < minDist2) {                                            \\\n            minDist2 = newD;                                                     \\\n        }                                                                        \\\n    }                                                                            \\\n    return SATURATE(min(realDist(minDist2, points[0]) / 1.5, 1.0));                    \\\n}\n//end #define\nIMPL_WORLEY3(float, 3)\nIMPL_WORLEY3(vec2,  9)\n\n//TODO: More variants\n\n//Octave worley noise:\nfloat octaveWorley1Noise(float x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(worley1, chanceOfCell COMMA); }\nfloat octaveWorley1Noise(vec2 x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(worley1, chanceOfCell COMMA); }\nfloat octaveWorley2Noise(float x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(worley2, chanceOfCell COMMA); }\nfloat octaveWorley2Noise(vec2 x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(worley2, chanceOfCell COMMA); }\n\n//TODO: Profile worley noise compared to a more hard-coded implementation.\n\n\n\n///////////////////\n//    Camera     //\n///////////////////\n\nstruct Camera\n{\n    vec2 pixelUV, pixelWorld;\n    vec2 screenUV; //Uncorrected for aspect ratio;\n                   //   use this to read from buffers\n    \n    vec2 horzUVRange, horzWorldRange;\n    \n    //Vertical UV and world space are identical, ranging from 0 to 1, for simplicity.\n};\n\nCamera getCamera(vec2 fragCoord, float time, vec2 mouseUV)\n{\n    vec2 uvScreen = fragCoord / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = vec2(uvScreen.x * aspect, uvScreen.y);\n    \n    vec3 worldHorzData  //Pos, Min, Max\n        = vec3(uv.x, 0.0, aspect);\n    float worldY = uv.y;\n               \n    //Find a good position for mountain-debugging.\n    worldHorzData -= 0.75;\n    \n    //Pan rightward.\n    //worldHorzData += time * 0.3;\n    \n    //Add mouse controls.\n    worldHorzData += mouseUV.x * 20.0;\n    \n    return Camera(uv, vec2(worldHorzData.x, worldY),\n                  uvScreen,\n                  vec2(0.0, aspect),\n                  vec2(worldHorzData.yz));\n}\n\n///////////////\n//    Sun    //\n///////////////\n\nstruct SunState\n{\n    vec2 dir;\n    vec3 brightness;\n    vec2 worldPos;\n};\n\nSunState getSunData(Camera cam, float time)\n{\n    vec2 dir = normalize(vec2(-1));\n    \n    //Use the sun's X direction to determine its horizontal position.\n    // -1 maps to the right edge of the screen; +1 maps to the left edge.\n    float horzRange = cam.horzWorldRange.y - cam.horzWorldRange.x;\n    vec2 worldPos = vec2(\n        mix((cam.horzWorldRange.x + cam.horzWorldRange.y) / 2.0,\n            cam.horzWorldRange.y,\n            -dir.x),\n        0.9\n    );\n                \n    return SunState(dir, vec3(1), worldPos);\n}\n\n\n/////////////////////////\n//    Data buffers     //\n/////////////////////////\n\n//Buffer A contains terrain data.\n//  Channel R: biome (0.0 is \"underwater\", 0.5 is \"plains\", 1.0 is \"mountains\")\n//  Channel G: terrain height (in UV space -- 0 to 1\n//  Channel B: mountain cave mask (1 means caves, 0 means solid rock)\n//  Channel A: [unused]\nstruct BufferA\n{\n    float biome, terrHeight, caveMask;\n};\n//Buffer B contains various biome-specific data.\n// Channel R: Gold ore (0.0 is \"none\", 0.1-1.0 is used to generate color)\n// Channel G: Iron ore (0.0 is \"none\", 0.1-1.0 is used to generate color)\n// Channel B: [unused]\n// Channel A: [unused]\nstruct BufferB\n{\n    //TODO: Remove the \"mask\" from the names\n    float goldMask, ironMask;\n};\n\n\n//---------------------------\n//Buffer-specific helpers:\n\n//From buffer value to real value:\nfloat bufferOreWeight(float oreValue) { return INV_LERP(0.1, 1.0, oreValue); }\n//From buffer value to 0-or-1 mask:\nfloat bufferOreMask(float oreValue) { return step(0.05, oreValue); }\n\n//From real masks to buffer value:\nfloat bufferOreValue(float binaryMask, float noiseMask) { return binaryMask * mix(0.1, 1.0, noiseMask); }\n\n//---------------------------\n\n//Packing helpers:\nvec4 packBuffer(BufferA buf)\n{\n    return vec4(buf.biome, buf.terrHeight, buf.caveMask, 1.0);\n}\nvec4 packBuffer(BufferB buf)\n{\n    return vec4(buf.goldMask, buf.ironMask, 0, 1);\n}\n\n//Unpacking helpers:\nvoid unpackBuffer(vec4 v, out BufferA buf)\n{\n    buf.biome = v.x;\n    buf.terrHeight = v.y;\n    buf.caveMask = v.z;\n}\nvoid unpackBuffer(vec4 v, out BufferB buf)\n{\n    buf.goldMask = v.x;\n    buf.ironMask = v.y;\n}\n//One-liner unpacking helpers:\nBufferA unpackBufferA(vec4 v) { BufferA b; unpackBuffer(v, b); return b; }\nBufferB unpackBufferB(vec4 v) { BufferB b; unpackBuffer(v, b); return b; }\n\n//Reading/unpacking helpers:\nvoid readBuffer(sampler2D tex, vec2 uv, out BufferA buf) { unpackBuffer(textureLod(tex, uv, 0.0), buf); }\nvoid readBuffer(sampler2D tex, vec2 uv, out BufferB buf) { unpackBuffer(textureLod(tex, uv, 0.0), buf); }\n//One-liner reading helpers:\nBufferA readBufferA(sampler2D tex, vec2 uv) { BufferA b; readBuffer(tex, uv, b); return b; }\nBufferB readBufferB(sampler2D tex, vec2 uv) { BufferB b; readBuffer(tex, uv, b); return b; }\n\n//Samples from four neighboring buffer values and stores the results.\n#define BUF_SAMPLE_AROUND_ME(BufType, bufTex, uv, radius, outName) \\\n    BufType outName[4]; { \\\n        vec3 texel = vec3(vec2(radius) / iResolution.xy, 0.0); \\\n        readBuffer(bufTex, uv - texel.xz, outName[0]); \\\n        readBuffer(bufTex, uv - texel.zy, outName[1]); \\\n        readBuffer(bufTex, uv + texel.xz, outName[2]); \\\n        readBuffer(bufTex, uv + texel.zy, outName[3]); \\\n    }\n#define BUF_PULL_MINX(outName) outName[0]\n#define BUF_PULL_MINY(outName) outName[1]\n#define BUF_PULL_MAXX(outName) outName[2]\n#define BUF_PULL_MAXY(outName) outName[3]", "buffer_a_code": "float getBiome(float x)\n{\n    //For testing, use something very simple.\n    //The real biome curve is further below.\n    float dumbBiome = OSCILLATE(0.0, 1.0, fract(x/4.0) + 0.25);\n    return tripleSmoothSmoothstep(0.0, 0.5, 1.0, dumbBiome);\n\n    float raw = OSCILLATE(0.15 + OSCILLATE(0.0, 0.2, x/21.0),\n                          0.5 + OSCILLATE(-0.275, 0.4, x/25.0),\n                          x/6.7);\n    return tripleSmoothSmoothstep(0.0, 0.5, 1.0, raw);\n}\n\nfloat getTerrHeight(float x, float biome)\n{\n    float mountains = mix(0.7, 1.0,\n                          octaveNoise(x*8.0, 2.234, 8, 1.8)\n                          * min(1.0, 1.6*worley1(x*2.0, 0.8, 4.31))),\n          plains = mix(0.4, 0.6, octaveNoise(x*2.0, 0.7834, 5, 2.0)),\n          water = mix(0.0, 0.2, octaveNoise(x*2.0, 1.56927, 3, 8.0));\n\n    return tripleLerp(water, plains, mountains, biome);\n}\n\nfloat getCaveMask(vec2 pos, float biome, float terrainHeight)\n{\n    //TODO: Get rid of the tiny floating chunks of rock inside caves\n\n    float domainWarp = octaveWorley1Noise(pos * vec2(45, 25),\n                                          5.234, 2, 2.0, 0.5);\n    \n    vec2 domainOffset = vec2(0, (domainWarp * 1.3 * domainWarp));\n    float rawValue = octaveWorley1Noise(pos*vec2(15, 15) + domainOffset,\n                                        2.543, 1,\n                                        2.0, 1.0);\n    return step(mix(0.25, 0.65, pos.y / terrainHeight),\n                rawValue * pow(biome, 1.5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera cam = getCamera(fragCoord, iTime, iMouse.xy / iResolution.xy);\n    \n    float biome = getBiome(cam.pixelWorld.x),\n          terrHeight = getTerrHeight(cam.pixelWorld.x, biome),\n          caveMask = getCaveMask(cam.pixelWorld, biome, terrHeight);\n          \n    fragColor = packBuffer(BufferA(biome, terrHeight, caveMask));\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define TEX_BUF_A iChannel1\n\nfloat getGoldValue(vec2 pos, BufferA bufA,\n                  BufferA bufANeighbors[4])\n{\n    //Remove gold as the mountain biome drops off,\n    //    and as the elevation increases.\n    float maskExponent = (0.75 + (pos.y * 7.0)) / pow(bufA.biome, 2.5);\n    float mask1 = pow(octaveNoise(pos * 2.5, 0.0023453, 5, 3.0),\n                      maskExponent),\n          mask2 = pow(octaveNoise(pos * 2.5, 0.345, 2, 3.0),\n                      1.4);\n    #define ORE_GOLD_MASK1 0.35\n    #define ORE_GOLD_MASK2 0.45\n    float mask = step(ORE_GOLD_MASK1, mask1)\n                  * step(ORE_GOLD_MASK2, mask2);\n\n    //Remove gold that's too close to a cave surface.\n    mask *= 1.0 - step(0.01, bufA.caveMask\n                               + bufANeighbors[0].caveMask + bufANeighbors[1].caveMask\n                               + bufANeighbors[2].caveMask + bufANeighbors[3].caveMask);\n    \n    float border = min(mask,\n                       border(mask1,\n                              ORE_GOLD_MASK1, 1.0 - (ORE_GOLD_MASK1/2.0),\n                              65.0)\n                         + border(mask2,\n                                  ORE_GOLD_MASK2, 1.0 - (ORE_GOLD_MASK2/2.0),\n                                  55.0));\n\n    float oreNoise = SHARPEN(octaveNoise(pos * 80.0, 8.2523, 4, 2.0));\n    \n    return bufferOreValue(mask, oreNoise);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera cam = getCamera(fragCoord, iTime, iMouse.xy / iResolution.xy);\n    \n    vec3 texel = vec3(1.0 / iResolution.xy, 0);\n    BufferA bufA = readBufferA(TEX_BUF_A, cam.screenUV);\n    BUF_SAMPLE_AROUND_ME(BufferA, TEX_BUF_A, cam.screenUV, 3, bufANeighbors)\n    \n    float goldValue = getGoldValue(cam.pixelWorld, bufA, bufANeighbors);\n    fragColor = packBuffer(BufferB(goldValue, 0.0));\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 432, 432, 469], [470, 470, 745, 745, 1283], [1285, 1285, 1572, 1572, 6740], [8088, 8088, 8150, 8150, 9961], [10021, 10021, 10076, 10187, 10833], [10836, 10836, 10893, 10893, 11268]]}
{"id": "fdtczl", "name": "Burn down the gym", "author": "ruudhelderman", "description": "2D fire effect + fire sound, both based on gradient noise.\nYou can draw lines of fire with your mouse, as this is a fork of \"Draw with mouse [antialiased]\"\nhttps://www.shadertoy.com/view/wlKfDm\n", "tags": ["2d", "noise", "fire", "audio"], "likes": 11, "viewed": 777, "published": 3, "date": "1656104258", "time_retrieved": "2024-07-30T16:43:20.072402", "image_code": "// Simple but effective 2D fire effect:\n// sum two noise patterns moving at different speeds, then do color mapping.\n// Copyright 2022 Ruud Helderman\n// MIT License\n\nconst vec2 grain = vec2(9, 6);\nconst float oven = 3.2;\nconst vec2 rise = vec2(0, 8);\nconst vec2 slide = vec2(0.5);\nconst vec4 color = vec4(-1, -2, -3, 0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos = grain * fragCoord / iResolution.y - iTime * rise;\n    float octave1 = 0.2 * (snoise(pos + iTime * slide) + snoise(pos - iTime * slide));\n    float octave2 = 0.9 * snoise(pos * 0.45);\n    float obstacles = 7.0 * texture(iChannel0, uv).r;\n    fragColor = octave1 + length(vec2(oven * (1.0 - uv.y) + octave2, obstacles)) + color;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Forked from \"Draw with mouse [antialiased]\"\n// https://www.shadertoy.com/view/wlKfDm\n// Customizations by Ruud Helderman\n\nconst float blur = 16.0;\nconst float glow = 10.0;\nconst float fade = 0.95;\nconst vec2 rise = vec2(0, 4);\n\n#define S(d,r,pix) smoothstep(blur, -blur, (d)/(pix)-(r))\nfloat line(vec2 p, vec2 a,vec2 b) {\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = (fragCoord.xy)/iResolution.y;\n       \n    vec2 pos1 = iMouse.xy/iResolution.y;\n    vec4 prevMouse = texture(iChannel1, ouv).rgba;\n    vec2 pos2 = prevMouse.rg;\n       \n    vec3 backCol = fade * texture(iChannel0, (fragCoord - rise)/iResolution.xy).rgb;\n                \n    float d = 0.;\n    if(prevMouse.w > 0.){\n        // d = clamp(drawLine(pos2, pos1, ouv, 3., 1.), 0., 1.);\n        d = S( line( ouv,pos2, pos1), 3., glow/iResolution.x);\n    }  \n    \n    d += max(0.0, 0.8 * texture(iChannel2, fragCoord/iResolution.xy).r - 0.3);\n    \n    // vec3 col = backCol + vec3(d);\n    \n    vec3 col = max(backCol, vec3(d));\n    \n    fragColor = vec4(col, 1.);    \n}\n", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Forked from \"Draw with mouse [antialiased]\"\n// https://www.shadertoy.com/view/wlKfDm\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iMouse.xy/iResolution.y,1.0,iMouse.z);    \n}", "buffer_b_inputs": [], "common_code": "// Simplex Noise, designed by Ken Perlin\n// Code from \"webgl-noise\"\n// https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n", "sound_code": "// Procedural fire sound\n// - Rumble/roar: low frequency noise with random overdrive (clipping)\n// - Sparks: random 10 ms noise bursts, with decay\n// Inspired by Andy Farnell's work on procedural audio.\n// Copyright 2022 Ruud Helderman\n// MIT License\n\nconst float volume = 0.2;\nconst float overdrive = 3.0;\nconst mat2 mix_stereo = mat2(0.8, 0.2, 0.2, 0.8);\n\nconst float f1 = 1.0;      // overdrive rate\nconst float f2 = 100.0;    // rumble noise\nconst float f3 = 100.0;    // spark rate\nconst float f4 = 4000.0;   // spark noise\n\nfloat square(float a) { return a * a; }\nfloat decay(float t) { return min(1.5 * exp(-1.5 * t), 1.0); }\nfloat mono(float a) { return snoise(vec2(a, 0.0)); }\nvec2 stereo(float a) { return vec2(snoise(vec2(a, 1.0)), snoise(vec2(a, 2.0))); }\n\nvec2 mainSound( int samp, float time )\n{\n    return volume * mix_stereo * (\n        (0.5 + square(mono(f1*time))) * clamp(stereo(f2*time) * overdrive, -1.0, 1.0) +\n        decay(fract(f3*time)) * max(vec2(0), stereo(floor(f3*time))) * stereo(f4*time)\n    );\n}\n", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtczl.jpg", "access": "api", "license": "mit", "functions": [[322, 322, 379, 379, 765]]}
{"id": "fsdfRH", "name": "schwarz euclidean tiling", "author": "remaindeer", "description": "- practicing SDF for better grids\n- https://en.wikipedia.org/wiki/Wythoff_symbol\n", "tags": ["triangle", "hexagon", "construction", "wythoff"], "likes": 9, "viewed": 325, "published": 3, "date": "1656103293", "time_retrieved": "2024-07-30T16:43:20.857304", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec2 q = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    p *= 2.0;\n    q *= 2.0;\n    p = rotmat2(radians(-5.0 * iTime)) * p;\n    q = rotmat2(radians(-5.0 * iTime)) * q;\n\n    float t = 0.075;\n\n    // Wythoff parameters\n    //// pick point within fundamental triangle\n    //// https://mathworld.wolfram.com/TrianglePointPicking.html\n    //// http://extremelearning.com.au/evenly-distributing-points-in-a-triangle/\n    float a1 = 0.5 + sin(0.25 * iTime) / 2.0;\n    float a2 = 0.5 + cos(2.00 * iTime) / 2.0;\n    //// generator point\n    vec2 g = (((a1 + a2) < 1.0) ? (a1 * v3 + a2 * v2) : ((1.0 - a1) * v3 + (1.0 - a2) * v2));\n    //// mirror\n    float m = mod(round((iTime - 2.0 / 2.0) / 2.0), 9.0);\n\n    // distance\n    float d = sdSchwartz632Plane(p, g, m, t);\n    \n    // color\n    vec3 col = vec3(0.5);\n    col = (d > 0.0) ? col : 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n    col *= t - exp(-1.0 * abs(d));\n    col *= t + cos(150.0 * d);\n    col = mix(col, vec3(0.5), 1.0 - smoothstep(0.0, t, abs(d)));\n    \n    //// mouse\n    if (iMouse.z > 0.001)\n    {\n        d = sdSchwartz632Plane(q, g, m, t);\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - q) - abs(d)) - 0.005));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - q) - 0.015));\n    }\n\n    // output\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define cos30 cos(radians(30.0))\n#define sqrt3 sqrt(3.0)\n#define v1 vec2(0, 0)\n#define v2 vec2(0, cos30)\n#define v3 vec2(0.5, cos30)\n\nmat2 rotmat2(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 intersection(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    // http://paulbourke.net/geometry/pointlineplane/\n    float d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;\n    // float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;\n    return p1 + ua * (p2 - p1);\n}\n\nfloat opIntersection( float d1, float d2 ) { \n    // https://iquilezles.org/articles/distfunctions2d/\n    return max(d1, d2); \n}\n\nfloat opUnion(float d1, float d2) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return min(d1, d2); \n}\n\nfloat opOnion(in float sdf, in float thickness) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return abs(sdf) - thickness;\n}\n\nvec2 opRep(in vec2 p, in vec2 c) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat sdCircle(vec2 p, float r) {\n    // https://iquilezles.org/articles/distfunctions2d/\n    return length(p) - r;\n}\n\nvec2 snub632()\n{\n    // fermat point\n    vec2 pf = intersection(vec2(-0.75, cos30 / 2.0), v3, vec2(1, 0), v2);\n    // reflect over side (y-axis)\n    vec2 q1 = vec2(-1.0 * pf.x, pf.y);\n    // vec2 q2 = vec2(pf.x, pf.y + 2.0 * (cos30 - pf.y));\n    // project to hypotenuse then double to obtain reflection\n    vec2 q3 = dot(pf, v3) / dot(v3, v3) * v3;\n    q3 = pf + 2.0 * (q3 - pf);\n    // snub point is at half the hypotenuse of the new right triangle (Thales's theorem)\n    return q1 + ((q3 - q1) / 2.0);\n}\n\nfloat sdSchwartz632Snub(vec2 p, float t)\n{\n    // p the uv\n    // t the thickness\n    // take advantage of symmetry\n    float a = atan(p.y, p.x);\n    float M = floor(mod(degrees(a) - 30.0, 360.0) / 60.0) * 60.0;\n    p = rotmat2(radians(M)) * p;\n    // central point\n    float d = sdCircle(p, t);\n    // snub point\n    vec2 g = snub632();\n    // rotate\n    vec2 G = rotmat2(radians(180.0)) * (g - v2) + v2;\n    // d = opUnion(d, opOnion(sdTriangle(p, v1, v2, v3), t*0.25)); \n    d = opUnion(d, sdSegment(p, g, G) - t);\n    // fix by https://www.shadertoy.com/user/mla\n    d = opUnion(d, sdSegment(rotmat2(radians(-60.0)) * p, g, G) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(-60.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+60.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+120.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+180.0)) * (G - g) + g) - t);\n    return d;\n}\n\nfloat sdSchwartz632(vec2 p, vec2 g, float m, float t)\n{\n    // p the uv\n    // g the generator point\n    // m the mirror toggle\n    // t the thickness\n    // snub case\n    if (m == 8.0) {\n        return sdSchwartz632Snub(p, t);\n    }\n    p = abs(p);\n    if (p.y < 2.0 * cos30 * p.x) {\n        p = rotmat2(radians(-60.0)) * p;\n        p = abs(p);\n    }\n    float d = sdCircle(p, t); \n    // d = opUnion(d, opOnion(sdTriangle(p, v1, v2, v3), t*0.25)); \n    d = opUnion(d, sdCircle(p - g, t)); \n    float M = float(m);\n    d = bool(mod(m, 2.0)) ? opUnion(d, sdSegment(p, g, vec2(0, g.y)) - t) : d;\n    vec2 v = v3 - v1;\n    d = bool(mod(floor(m / 2.0), 2.0)) ? opUnion(d, sdSegment(p, g, dot(g, v) / dot(v, v) * v) - t) : d;\n    d = bool(mod(floor(m / 4.0), 2.0)) ? opUnion(d, sdSegment(p, g, vec2(g.x, v2.y)) - t) : d;\n    return d;\n}\n\nfloat sdSchwartz632Plane(vec2 p, vec2 g, float m, float t)\n{\n    // p the uv\n    // g the generator point\n    // m the mirror toggle\n    // t the thickness\n    vec2 v = vec2(3.0, 2.0 * cos30);\n    vec2 p1 = opRep(p, v);\n    vec2 p2 = opRep(p + v / 2.0, v);\n    return opUnion(\n        sdSchwartz632(p1, g, m, t),\n        sdSchwartz632(p2, g, m, t)\n    );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1500]]}
{"id": "sdtfzH", "name": "windy day", "author": "yasuo", "description": "windy day\nI'm looking for a more efficient way to do this.", "tags": ["wind"], "likes": 9, "viewed": 228, "published": 3, "date": "1656082245", "time_retrieved": "2024-07-30T16:43:24.454685", "image_code": "#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat SK = 0.03;\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat barX(vec2 uv, float w){\n    uv.x -= clamp( uv.x, -w, w );\n    float d = length(uv)-0.02;\n    return d;\n}\n\nfloat barY(vec2 uv, float h){\n    uv.y -= clamp( uv.y, -h, h );\n    float d = length(uv)-0.02;\n    return d;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat circle(vec2 uv, float dir) {\n    vec2 prevUV = uv;\n    float d = 1.0;\n    \n    float w[9] = float[](\n        0.09,\n        0.17,\n        0.21,\n        0.23,\n        0.25,\n        0.23,\n        0.21,\n        0.17,\n        0.09\n    );\n    \n    for(float i = 0.; i<float(w.length()); i++){\n        uv = prevUV;      \n        \n        uv.x+=dir*sin(dir*iTime*(dir*20.5)+i)*(0.01+(i*0.001));\n        uv.y+=(i*0.045);\n                  \n        uv*=Rot(radians(sin(iTime*(dir*30.0)+i)*5.0+i));\n        \n        float d2 = barX(uv,w[int(i)]);\n        d = smin(d,d2,SK);\n    }\n    return d;\n}\n\nfloat bg(vec2 uv, float dir, float num){\n    vec2 prevUV = uv;\n    float d = 1.0;\n    \n    for(float i = 1.; i<=num; i++){\n        uv = prevUV;      \n       \n        uv.x+=dir*sin(dir*iTime*(dir*20.5)+i)*(0.01+(i*0.001));\n        uv.y+=(i*0.045);\n                  \n        uv*=Rot(radians(sin(iTime*(dir*sin(i)*30.0)+i)));\n        \n        float d2 = barX(uv,0.85);\n        d = smin(d,d2,SK);\n    }\n    return d;\n}\n\nfloat triangle(vec2 uv, float dir, float h, float w) {\n    vec2 prevUV = uv;\n    float d = 1.0;\n    \n    for(float i = 1.; i<h; i++){\n        uv = prevUV;      \n        \n        uv.x+=dir*sin(dir*iTime*(dir*20.5)+i)*(0.01+(i*0.001));\n        uv.y+=(i*0.045);\n                  \n        uv*=Rot(radians(sin(2.*iTime*(dir*sin(i)*30.0))*sin(i*0.5)*5.0));\n        \n        float d2 = barX(uv,i*w);\n        d = smin(d,d2,SK);\n    }\n    return d;\n}\n\n\nfloat cloud(vec2 uv, float dir, float h) {\n    vec2 prevUV = uv;\n    float d = 1.0;\n    \n    for(float i = 1.; i<=h; i++){\n        uv = prevUV;      \n        \n        uv.x+=dir*sin(dir*iTime*(dir*20.5)+i)*(0.01+(i*0.001));\n        uv.y+=(i*0.045);\n                  \n        uv*=Rot(radians(sin(2.*iTime*(dir*sin(i)*30.0))*sin(i*0.5)*5.0));\n        \n        float d2 = barX(uv,sin(i*0.5+0.5)*0.17);\n        d = smin(d,d2,SK);\n    }\n    return d;\n}\n\nvec3 tree(vec2 uv, vec3 col, float dir){\n    vec2 prevUV = uv;\n    uv.y+=0.27;\n    uv*=Rot(radians(2.*sin(iTime*(dir*20.0))*3.0));\n    float d = barY(uv,0.2);\n    col=mix(col,vec3(0.3,0.3,0.2),S(d,0.0)); \n    \n    uv = prevUV;\n    d = triangle(uv,dir, 6., 0.03);\n    uv.y+=0.15;\n    float d2 = triangle(uv,dir, 6., 0.03);\n    d = smin(d,d2,SK);\n    col=mix(col,mix(vec3(0.5,0.8,0.5),vec3(0.3,0.4,0.3),uv.y*-3.),S(d,0.0)); \n    return col;\n}\n\nvec3 treeSmall(vec2 uv, vec3 col, float dir){\n    vec2 prevUV = uv;\n    uv.y+=0.42;\n    uv*=Rot(radians(2.*sin(iTime*(dir*20.0))*3.0));\n    float d = barY(uv,0.1);\n    col=mix(col,vec3(0.4,0.4,0.3),S(d,0.0)); \n    \n    uv = prevUV;\n    uv.y+=0.2;\n    d = triangle(uv,dir, 6., 0.03);\n    col=mix(col,mix(vec3(0.3,0.9,0.3),vec3(0.3,0.4,0.3),uv.y*-3.),S(d,0.0)); \n    return col;\n}\n\nvec3 grass(vec2 uv, vec3 col, float dir){\n    vec2 prevUV = uv;\n    float d = 1.0;\n    \n    for(float i = 1.; i<=6.; i++){\n        uv = prevUV;      \n        \n        uv.x+=(i*0.05);        \n        uv*=Rot(radians(sin(2.*iTime*(dir*sin(i)*30.0))*10.0));\n        \n        float d2 = barY(uv,0.03+sin(i)*0.01);\n        d = smin(d,d2,SK);\n    }\n    col=mix(col,mix(vec3(0.1,0.2,0.1),vec3(0.3,0.4,0.3),uv.y*-10.),S(d,0.0)); \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    \n    float glitchBlock = 30.0;\n    vec2 uv2 = fract(uv*glitchBlock)-0.5;\n    vec2 id = floor(uv2);\n    \n    vec2 n2 = fract(sin(id*123.456)*789.125);\n    n2+=dot(id.x,id.y*567.89);\n    \n    float glitchDist = 0.02;\n    float glitchTime = iTime*10.0;\n    uv.x-=(fract(floor(uv.y+n2.y*glitchBlock)*glitchTime)*glitchDist);\n    uv.x+=sin(floor(uv.y*glitchBlock*10.0)*iTime*30.)*0.01;\n    \n    \n    vec2 prevUV = uv;\n    \n    vec3 col = vec3(1.0);\n    \n    uv.y-=0.52;\n    float d = bg(uv,-1.0,19.);\n    col=mix(col,mix(vec3(0.6,0.8,1.0),vec3(0.5,0.9,1.0),uv.y),S(d,0.0));\n    uv = prevUV;\n    \n    uv.y+=0.35;\n    d = bg(uv,1.0,3.);\n    col=mix(col,mix(vec3(0.6,0.3,0.2),vec3(0.3,0.2,0.1),uv.y*10.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x-=0.45;\n    uv.y-=0.45;\n    d = circle(uv,1.0);\n    col=mix(col,mix(vec3(0.9,0.83,0.63),vec3(0.7,0.7,0.6),uv.y*20.0),S(d,0.0));    \n    uv = prevUV;\n    \n    uv.x+=iTime*0.2;\n    uv.x = mod(uv.x,2.0)-1.;\n    d = triangle(uv,1.0, 9., 0.05);\n    col=mix(col,mix(vec3(0.2,0.4,0.2),vec3(0.1,0.3,0.1),uv.y*10.0),S(d,0.0));    \n    uv = prevUV;\n    \n    uv.x+=iTime*0.2;\n    uv.x-=1.35;\n    uv.x = mod(uv.x,2.0)-1.;\n    uv.y+=0.03;\n    d = triangle(uv,-1.2, 8., 0.05);\n    col=mix(col,mix(vec3(0.2,0.3,0.2),vec3(0.1,0.2,0.1),uv.y*5.0),S(d,0.0));    \n    uv = prevUV;      \n    \n    uv.x+=iTime*0.2;\n    uv.x-=0.9;\n    uv.x = mod(uv.x,2.0)-1.;\n    uv.y+=0.13;\n    d = triangle(uv,1.3, 6., 0.05);\n    col=mix(col,mix(vec3(0.2,0.5,0.2),vec3(0.1,0.2,0.1),uv.y*4.0)*0.8,S(d,0.0));    \n    uv = prevUV;       \n    \n    uv.x+=iTime*0.2;\n    uv.x-=0.5;\n    uv.x = mod(uv.x,2.0)-1.;\n    uv.y+=0.1;\n    d = triangle(uv,-1.0, 7., 0.05);\n    col=mix(col,mix(vec3(0.2,0.6,0.2),vec3(0.1,0.2,0.1),uv.y*3.0)*0.8,S(d,0.0));    \n    uv = prevUV;    \n    \n    uv.x+=iTime*0.25;\n    uv.x = mod(uv.x,1.6)-0.8;\n    uv.y-=0.45;\n    d = cloud(uv,-1.2, 4.);\n    col=mix(col,mix(vec3(0.88),vec3(0.5),uv.y*2.0),S(d,0.0)); \n    uv.x-=0.2;\n    uv.y-=0.05;\n    d = cloud(uv,1.2, 3.);\n    col=mix(col,mix(vec3(0.92),vec3(0.6),uv.y),S(d,0.0));\n    uv.x-=0.4;\n    uv.y+=0.28;\n    uv.x*=1.6;\n    d = cloud(uv,-1.3, 3.);\n    col=mix(col,mix(vec3(0.92),vec3(0.6),uv.y*-3.0),S(d,0.0));  \n    uv = prevUV;    \n    \n    uv*=2.0;\n    uv.x+=iTime*0.3;\n    uv.x = mod(uv.x,1.2)-0.6;\n    uv.y+=0.4;\n    col = tree(uv,col,1.0);\n    uv = prevUV;    \n    \n    uv*=2.0;\n    uv.x+=iTime*0.3;\n    uv.x +=0.5;\n    uv.x = mod(uv.x,1.2)-0.6;\n    uv.y+=0.4;\n    col = treeSmall(uv,col,-1.1);\n    uv = prevUV; \n    \n    uv.x+=iTime*0.3;\n    uv.x = mod(uv.x,0.6)-0.3;\n    uv.y+=0.5;\n    col = grass(uv,col,1.0);\n    \n    uv.x+=iTime*2.0;\n    col+=Hash21(uv*100.0)*0.3;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 235, 278, 278, 378], [380, 380, 409, 409, 490], [492, 492, 521, 521, 602], [604, 604, 626, 626, 716], [1310, 1310, 1350, 1350, 1725], [1727, 1727, 1781, 1781, 2169], [2172, 2172, 2214, 2214, 2619], [2621, 2621, 2661, 2661, 3061], [3063, 3063, 3108, 3108, 3441], [3443, 3443, 3484, 3484, 3882], [3884, 3884, 3941, 3991, 6768]]}
{"id": "sdtBRH", "name": "Milky way galaxy", "author": "Peace", "description": "Procedural milky way galaxy", "tags": ["space", "galaxy", "stars", "nebula", "cosmos", "milkyway"], "likes": 10, "viewed": 968, "published": 3, "date": "1656080003", "time_retrieved": "2024-07-30T16:43:25.459001", "image_code": "#define BACKGROUND_COLOR vec3(0.1, 0.2, 0.6)\n#define SECONDARY_COLOR vec3(0.49, 0.45, 0.655)\n#define BIG_STAR_SIZE 16.\n#define MEDIUM_STAR_RATIO 0.3\n#define BIG_STAR_CHANCE 0.1\n#define STAR_COLOR vec3(0.9, 0.7, 1.0)\n#define SPACE_DUST_COLOR vec3(0.432941, 0.38627, 0.69020)\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec3 hash(vec3 p3)\n{    \n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxx+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nfloat voronoi(vec2 n, float t) {\n    \n    vec3 p = vec3(n.x, n.y, t);\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 q = h * h * h * h * vec4(dot(d0, hash(i)), dot(d1, hash(i + i1)), dot(d2, hash(i + i2)), dot(d3, hash(i + 1.0)));\n    \n    return dot(vec4(50.), q);\n\n}\n\n\nfloat voronoiFbm(vec2 p, int iter)\n{\n    float f = 0.0;\n    float a = 1.0;\n    float norm = 0.0;\n    \n    for (int i = 0; i < iter; i++) {\n\t    f += a * abs(voronoi(p, 0.0)); \n        norm += a;\n        p *= 2.0;\n        a *= 0.65;\n    }\n    \n    return 1.0 - f / norm;\n}\n\nfloat fbm(vec2 p, int iter, float freq, float amp)\n{\n    float n = 0.0;\n    float a = 1.0;\n    float norm = 0.0;\n    for(int i = 0; i < iter; ++i)\n    {\n        n += noise(p) * a;\n        norm += a;\n        p *= freq;\n        a *= amp;\n    }\n    return n / norm;\n}\n\n\nfloat fbm(vec2 p, int iter)\n{\n    return fbm(p, iter, 2.0, 0.5);\n}\n\nvec3 starColor(vec2 p)\n{\n    return sin(vec3(.2, .3, .9)*fract(rand(p + vec2(7.91, 246.792))*2345.2)*123.2)*vec3(0.15, 0.1, 0.15) + 0.75;\n}\n\nvoid stars(inout vec3 col, vec2 fragCoord, float density)\n{\n    vec2 p = fragCoord;\n    if(rand(vec2(ivec2(fragCoord / 2.0)) * 2.0) < MEDIUM_STAR_RATIO)\n        fragCoord = vec2(ivec2(fragCoord / 2.0)) * 2.0;\n    vec3 star = col * 0.5 + 0.5 * starColor(p);\n   \n    if(rand(fragCoord + vec2(1071.52, -662.1)) > 0.0) return;\n    col = star;\n}\n\nvoid bigStars(inout vec3 col, vec2 fragCoord, float density)\n{\n    vec2 p = vec2(ivec2(fragCoord / BIG_STAR_SIZE)) * BIG_STAR_SIZE;\n    float star_size = BIG_STAR_SIZE * pow(rand(p), 2.0);\n    vec3 star = col * 0.5 + 0.5 * starColor(p);\n    float d = max(1.0 - distance(p + star_size * 0.5, fragCoord) / star_size * 2.0, 0.0);\n    star += d * d * d * d;\n    \n    if(rand(p + vec2(6181.616, 9028.1)) > BIG_STAR_CHANCE) return;\n    col = mix(col, star, d * d * d);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = BACKGROUND_COLOR; // Background\n    float primary = sqrt(fbm(uv * 3.0 + vec2(6.175, -23.612), 8, 1.5, 0.5)); // Space lighness\n    float secondary = fbm(uv * 4.0, 8);\n    float nebula = 4.0 * pow(fbm(uv * 4.0 + vec2(-12.1, 2.62), 18, 2.0, 0.5), 5.0);\n    float space = primary * secondary * nebula;\n    vec3 variation = normalize(vec3(fbm((uv + vec2(11.61)) * 2.0, 8), fbm((uv - vec2(2.11)) * 2.0, 8), fbm((uv + vec2(66.61)) * 2.0, 8)));\n    \n    col *= space;\n    col = mix(col, secondary * SECONDARY_COLOR, 0.5); // Nebula\n    col = mix(variation, col, 0.93);\n    col += SPACE_DUST_COLOR * vec3(pow(fbm(uv * 12.0, 18, 2.0, 0.5), 3.0) * 0.5);\n    col += vec3(0.7, 0.6, 0.5) * nebula;\n    stars(col, fragCoord, space);\n    bigStars(col, fragCoord, space);\n    col /= 1.0 + vec3(1.0, 1.3, 1.5) * (4.0 * vec3(pow(max(voronoiFbm(uv * 2.0, 8), 0.0), 6.0))); // Voronoi (stripes of emptiness)\n    col = rgb2hsv(col);\n    col *= vec3(1.0, 1.0 + iMouse.x / 500.0, 1.0 + iMouse.y / 500.0);\n    col = hsv2rgb(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtBRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 275, 295, 295, 362], [364, 364, 384, 384, 593], [595, 595, 615, 615, 792], [795, 795, 827, 827, 1514], [1517, 1517, 1553, 1553, 1788], [1790, 1790, 1842, 1842, 2054], [2057, 2057, 2086, 2086, 2123], [2125, 2125, 2149, 2149, 2264], [2266, 2266, 2325, 2325, 2606], [2608, 2608, 2670, 2670, 3072], [3074, 3074, 3096, 3096, 3427], [3429, 3429, 3451, 3451, 3620], [3622, 3622, 3679, 3679, 4779]]}
{"id": "NdVyRc", "name": "Animated Icosahedral Weave", "author": "Shane", "description": "Attaching an animated triangle Truchet weave to the triangle cells of an icosahedron.", "tags": ["truchet", "geometry", "pattern", "icosahedron", "spherical", "polyhedron", "weave"], "likes": 65, "viewed": 912, "published": 3, "date": "1656078262", "time_retrieved": "2024-07-30T16:43:26.551080", "image_code": "/*\n\n    Animated Icosahedral Weave\n    --------------------------\n    \n    See \"Buffer A\" for an explanation.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    //\n    // See Buffer A for an explanation.\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Animated Icosahedral Weave\n    --------------------------\n    \n    Of all the geometric art out there, 3D polyhedron variations would have to \n    be among my favorites. This is more of a 3D polyhedral texture demonstration,\n    but I'll post more interesting 3D ones later. This is the icosahedral \n    version of my previous \"Animated Triangle Grid Weave\" example. I was pretty \n    sure it'd work in theory, but couldn't be sure until I tried it. I was able \n    to use an icosahedral template of mine, so thankfully, didn't have to put \n    too much thinking into it.\n    \n    In fact, I put more effort into the background and color scheme than the \n    icosahedral sphere construction itself. Technically speaking, there wasn't\n    a great deal to it: Obtain the nearest icosahedral triangle face information, \n    then render arcs around each of the vertices. Obtain the angle of the pixel on\n    each arc, then use that to render some repeat moving parts, and that's it.\n    \n    Of course, I'm glossing over the spherical arc rendering and spherical \n    angles, but that's not as hard as you'd think, and you can find that amongst \n    the code somewhere.\n    \n    Anyway, this was just a simple demonstration, but as mentioned, I intend to \n    post more interesting examples along these lines later. \n\n    \n\n\tOther examples:\n    \n\t// To my knowledge, the following is the only animated polyhedral weave on \n    // here, which is not surprising, because although looking cool, they're not\n    // that fun to make. :) Having made one of these, I can say that the static \n    // non-animated version is simple enough to produce, but including moving parts \n    // can be fiddly work. I'll get around to posting my own one at some stage.\n    medusas hairdo with uv - flockaroo\n    https://www.shadertoy.com/view/ltBcDw\n    \n    // In terms of aesthetics and sheer technical ability, this would\n    // have to be one of my favorites.\n    heavy metal squiggle orb - mattz\n    https://www.shadertoy.com/view/wsGfD3\n    \n    // The flat plane version.\n    Animated Triangle Grid Weave - Shane\n    https://www.shadertoy.com/view/7sycz3\n\n\n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n// Color: White: 0, Pinkish Red: 1, Green 2, Blue: 3.\n#define COLOR 1\n\n// Two arcs subtended from each spherical triangle vertex. The alternative\n// is a single arc.\n#define DOUBLE_ARC\n\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.609, 57.583)), 6.2831859))*43758.5453); \n}\n\n\n// IQ's vec3 to float hash.\nfloat hash31(in vec3 p){\n    return fract(sin(mod(dot(p, vec3(91.537, 151.761, 72.453)), 6.2831859))*435758.5453);\n}\n\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n   \n    p.xz *= rot2(iTime/3./2.);\n    p.yz *= rot2(iTime/6./4. + 0.); \n    \n    return p;\n    \n}\n\n/*\n// hash based 3d value noise\nvec4 hash41T(vec4 p){\n    \n    return fract(sin(p)*43758.5453);\n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3DT(vec3 p){\n    \n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(hash41T(h), hash41T(h + s.x), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Two layers of noise.\nfloat fBm(vec3 p){ return n3DT(p)*.57 + n3DT(p*2.)*.28 + n3DT(p*4.)*.15; }\n*/ \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n#define PI 3.14159265359\n#define TAU 6.2831853\n#define PHI 1.618033988749895 \n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n// Moving parts direction vectors.\nvec3 dir, dir2;\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 p, inout vec3[3] gVertID, const float rad){\n       \n \n    // Longitudinal scale.\n    const float scX = 5.;\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n    vec3 q = p; // Top section coordinates.\n    //vec3 q2 = vec3(rot2(-PI/scX)*p.xz, p.y).xzy; // Bottom section coordinates.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    ////vec4 sph = mod(a + vec4(0, 0, PI/5., PI/5.), TAU);\n    vec4 sph = mod(atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = 0; i<4; i++){\n\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i%2], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    float ax = sph[id];\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : -1.;\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID[0] = vec3(ax, ayT, rad);\n    gVertID[1] = vec3(mod(ax - PI/5.*baseFlip, TAU), ayB, rad);\n    gVertID[2] = vec3(mod(ax + PI/5.*baseFlip, TAU), ayB, rad);\n\n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id%2==0) gVertID[0].x = 0.;\n    \n\n    // Arc direction vectors. Hacked in at the last minute.\n    #ifdef DOUBLE_ARC\n    // You'd think this would present the most problems, but double\n    // arc directions are easier.\n    dir = vec3(1);\n    #else\n    // For single arcs, directions need to be flipped in two of the\n    // latitudinal strips, which is not all that surprising.\n    if(id==1 || id==2) dir = vec3(1, -1, 1);\n    else dir = vec3(-1, 1, -1);\n    #endif\n     \n    return q;\n}\n\n\n \n// You could get out a pen and paper and figure out the arc distances, or\n// if you're lazy like me, you could use Mattz's formula below. :)\n//\n// By the way, the original example that it comes from is awesome.\n// heavy metal squiggle orb - mattz\n// https://www.shadertoy.com/view/wsGfD3\n//\n// Distance from point p to a circle perpendicular to a central vector n \n// and passing through point p0.\n//\nfloat pCircDist(vec3 p, vec3 n, vec3 p0) {\n\n    // Projecting \"p0\" onto \"n\".\n    vec3 c = dot(p0, n)*n;\n    \n    // Perpendicular distance.\n    p -= c, p0 -= c;\n    \n    p -= normalize(p - dot(p, n)*n)*length(p0);\n    \n \n    return length(p); \n    \n}\n\n// Angle between 3D vectors. Similar to the 2D version. It's easy to derive\n// this yourself, or look it up on the internet.\nfloat angle(vec3 p0, vec3 p1){\n\n    return acos(dot(p0, p1)/(length(p0)*length(p1)));\n}\n\n// TDHooper's closest icosahedron vertex formula. The original is \n// clever and concise. The original formula is here:\n// Closest icosahedron vertices - tdhooper\n// https://www.shadertoy.com/view/fdXcDl\n//\nvec3 icosahedronVertex(inout vec3 p) {\n\n    // TDHooper's function is designed for differently aligned vertices,\n    // which I'm guessing are center face aligned along the vertical. Mine \n    // have vertically algined vertex poles, so rather than do rewrite \n    // the function, I've lazily realigned the coordinate system. Not my\n    // best work. :D\n    \n    // Coordinate realignment.\n    //const float iAng = acos(dot(vec3(PHI, 1, 0), \n    //                   vec3(0, 1, 0))/length(vec3(PHI, 1, 0)));\n    const float iAng = acos(1./length(vec2(PHI, 1)));\n    const float cIR = cos(iAng), sIR = sin(iAng);\n    const mat2 mIR = mat2(cIR, -sIR, sIR, cIR);\n    p.xy = mIR*p.xy;\n    \n    vec3 ap = abs(p);\n    vec3 v = vec3(PHI, 1, 0);\n    if (ap.x + ap.z*PHI > dot(ap, v)) v = vec3(1, 0, PHI);\n    if (ap.z + ap.y*PHI > dot(ap, v)) v = vec3(0, PHI, 1);\n    return v*.52573111*(max(vec3(0), sign(p))*2. - 1.);\n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    float wall = -(length(p - sphPos - vec3(0, 0, -(48. - 3.))) - 48.);\n     // Flat plane back wall.\n    //float wall = -p.z + 3.;\n    \n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n    // Sphere.\n    float sph = length(q) - .5;\n    \n///////////////////////////    \n\n    // Icosahedron vertices for the current cell.\n    // Using TDHooper's simple icasahedron vertices\n    // formula. \"v0\" is is the nearest vertex \n    // coordinate for a sphere of radius one.\n    vec3 v0 = icosahedronVertex(q); \n\n    // The \".5\" figure is compensating for the sphere's\n    // \".05\" radius.\n    float vert = length(q -  v0*.5) - .02;\n  \n////////////////////////////////    \n \n    // Overall object ID -- There in one rundundant slot there.\n    vID = vec4(sph, wall, vert, 1e5);\n    \n    // Shortest distance.\n    return  min(min(sph, wall), vert);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Frame blend value for the sphere.\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .25, -1.75);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t     \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n        \n        // A bright color with grey tones is a design cliche, but cliches are\n        // cliches for a reason. :)\n        #if COLOR == 0\n        const vec3 bCol = vec3(.7); // White.\n        #elif COLOR == 1\n        const vec3 bCol = vec3(1, .1, .2); // Pink.\n        #elif COLOR == 2\n        const vec3 bCol = vec3(.45, .85, .15); // Green.\n        #else\n        const vec3 bCol = vec3(.2, .6, 1.2); // Blue.\n        #endif\n        \n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n        \n\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The sphere.\n            \n            \n            \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n            \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n            // Icosahedron vertices and vertex IDs for the current cell.\n            vec3[3] v, vertID;\n            \n            // Obtaining the local cell coordinates and spherical coordinates\n            // for the icosahedron cell.\n            const float rad = .5;\n            vec3 lq = getIcosTri(txP, vertID, rad);\n    \n            v[0] = sphericalToWorld(vertID[0]);//vec3(0, rad, 0);\n            v[1] = sphericalToWorld(vertID[1]);\n            v[2] = sphericalToWorld(vertID[2]);\n            \n             \n           \n            // Edge mid points, edge tangents and exit and entry points.\n            vec3[3] vE, vN;\n            vec3[6] vE2;\n            \n            // Edge mid points.\n            vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n            vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n            vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n             \n  \n            // The cell center, which doubles as a cell ID,\n            // due to its uniqueness, which can be used for \n            // randomness, etc.\n            vec3 id = normalize((v[0] + v[1] + v[2]))*rad;\n             \n\n            // Icosahedral cell boundary.\n            //\n            // Rendering lines on a sphere is a little different to those on a plane.\n            // Lines between points translate to great arcs between points. This is\n            // just three triangle edge borders. I normally do these individually, but\n            // discovered this matrix short cut in on of Mattz's examples. Quite obvious...\n            // once someone else did it. :)\n            mat3 mEdge = mat3(cross(v[0], v[1]), cross(v[1], v[2]), cross(v[2], v[0]));\n            vec3 ep = abs(normalize(lq)*mEdge)/length(v[0] - v[1]);  \n            \n            // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n            // \"abs\" above away.\n            float line = min(min(ep.x, ep.y), ep.z) - .0035;\n \n          \n            #ifdef DOUBLE_ARC\n            // Calculating the tangent vectors for each edge, as well as the two\n            // entry and exit points on each side of the mid-edge point. All are\n            // used to produce the random curves within each triangle cell.\n            for(int i = 0; i<3; i++){\n                \n                // Edge entry points -- One on each side of the mid point.\n                float mOffs = .333/2.; // Edge mid point offset.\n                vE2[i*2] = normalize(mix(v[i], v[(i + 1)%3], .5 - mOffs))*rad;\n                vE2[i*2 + 1] = normalize(mix(v[i], v[(i + 1)%3], .5 + mOffs))*rad; \n                \n            } \n            #endif\n           \n \n            vec3 laneDir = vec3(1);\n            // Rendering the spline curves between entry and exit points. There are six\n            // alltogether. We're indexing into random indices, and that creates the \n            // randomness, strangely enough. :)\n            vec3 ln = vec3(1e5), ln2 = vec3(1e5);\n            vec3 angl;\n             \n            for(int i = 0; i<3; i++){\n            \n                vec3 v0 = v[(i + 2)%3], v2 = v[(i + 1)%3];\n         \n                \n                // Using Mattz's spherical arc formula to determine the\n                // arc distance. It's easy enough to work out, but it's\n                // even easier just to use Mattz's formula. :) By the way,\n                // the original example that it comes from is awesome.\n                //\n                // heavy metal squiggle orb - mattz\n                // https://www.shadertoy.com/view/wsGfD3\n                #ifdef DOUBLE_ARC\n                ln[i] = pCircDist(lq, normalize(v0), vE2[((i + 2)%3)*2]); \n                ln[i] = abs(ln[i]); \n                ln2[i] = pCircDist(lq, normalize(v0), vE2[((i + 2)%3)*2 + 1]); \n                ln2[i] = abs(ln2[i]); \n                \n                if(ln[i]<ln2[i]) laneDir[i] *= -1.;\n                #else\n                ln[i] = pCircDist(lq, normalize(v0), vE[((i + 2)%3)]); \n                ln[i] = abs(ln[i]); \n                #endif\n                \n                // Moving parts.\n                //\n                // Angle of each pixel on each arc. As above, further calculations\n                // are performed outside the loop for speed.\n                angl[i] = angle(cross(lq, v0), cross(v2, v0));\n  \n\n            }\n            \n            // Combine the top and bottom arcs and givving them some thickness\n            #ifdef DOUBLE_ARC\n            // Comining the arcs in order to perform just a single render.\n            ln = min(ln, ln2);\n            ln -= .04;\n            #else\n            ln -= .05;\n            #endif\n            \n \n\n            \n            // RENDERING.\n            \n            \n            // Smoothing factor.\n            float sf = .003; \n           \n            \n            // Initial background color.\n            texCol = vec3(.05); \n\n            \n            // Cell border lines.\n            texCol = mix(texCol, vec3(.2), (1. - smoothstep(0., sf*2., line ))*.35);\n            texCol = mix(texCol, vec3(.0), (1. - smoothstep(0., sf, line))*.9);\n            \n            // Cell vertices.\n            vec3 v3 = vec3(length(lq - v[0]), length(lq - v[1]), length(lq - v[2])); \n            float vert = min(min(v3.x, v3.y), v3.z) - .035;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert - .005))*.35);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert - .005));\n            texCol = mix(texCol, vec3(.1), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .0075));\n\n            \n            // Angular repetition.\n            #ifdef DOUBLE_ARC\n            // Repeat objects need to be divisible by 5 (due to the five triangles per\n            // revolution, or whatever), and maybe 2 also on occasion. If you don't like\n            // science, try any set of numbers, and if it works, great. :D\n            const float aOuter = 40., aInner = 20.;\n            vec3 angNum = vec3(aOuter); \n            // Less repetion along the inner arcs, since the arc length is shorter, which in\n            // turn means a smaller circle. Therefore, fewer squares are required to fill out\n            // the perimeter of the circle.\n            if(laneDir.x<0.){ angNum.x = aInner; };\n            if(laneDir.y<0.){ angNum.y = aInner; };\n            if(laneDir.z<0.){ angNum.z = aInner; };\n            #else\n            const float aOuter = 20.; // Only one arc, so only one repetition factor.\n            vec3 angNum = vec3(aOuter);        \n            #endif\n\n            // Angular ID, for multicolored squares. Not used here.\n            //vec3 rpFct = aInner/10.;// Repetition factor and ID (not used).\n            //vec3 angID = mod(floor(angl/6.2831*angNum*dir*laneDir + iTime*2.), rpFct)/rpFct;\n\n\n            // Repeat partitioning the squares along the vertical.\n            angl = fract(angl/6.2831*angNum*dir*laneDir + iTime*2.);\n\n            #ifdef DOUBLE_ARC\n            // No rounding, but it's there as an option.\n            vec3 an2 = vec3(0);//max(ln, cos(angl*6.2831)*.5 + .5);\n            // Moving squares.\n            angl = (abs(angl - .5)*2. - .85)/aOuter;\n            angl = max(angl, ln + .0165*(1. + an2*.2));\n            #else\n            // Rounding the square edges.\n            vec3 an2 = vec3(0);//max(ln, cos(angl*6.2831)*.5 + .5);\n            // Moving squares.\n            angl = (abs(angl - .5)*2. - .9)/aOuter;\n            angl = max(angl, ln + .0165*(1. + an2*.2));\n            #endif\n            \n            // Extra noise.\n            //float ns = fBm(txP*256.);\n            //texCol *= ns*.5 + .75;\n            \n            \n            // Rendering the arc lines and squares over the top.\n            for(int i = min(0, iFrame); i<3; i++){ \n            \n                // Arc lines.\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*8., ln[i] - .01))*.5);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, ln[i] - .0085));\n                texCol = mix(texCol, vec3(.1)*1.2, 1. - smoothstep(0., sf, ln[i]));\n                \n                // Arc line rails.\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, abs(ln[i] + .011 - .005) - .0025));\n           \n                // Squares.\n                //\n                //vec3 lCol = vec3(1);\n                //if(i==1) lCol = bCol;\n                //lCol = mod(angID[i], 2.)<.5? bCol : vec3(1);\n                vec3 lCol = bCol*1.2;//.5 + .45*sin(6.2831*angID[i] + vec3(0, 1, 2) + 1.);\n                float shd = max(.2 - angl[i]/.02, 0.);\n                vec3 rCol = vec3(1)*shd;//*(fract(angID[i])*.7 + .6);\n                //if(mod(floor(angID[i]*4.), 2.)<.5){ vec3 tmp = lCol; lCol = rCol; rCol = tmp; }\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, angl[i]));\n                texCol = mix(texCol, rCol, 1. - smoothstep(0., sf, angl[i] + .007));\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, angl[i] + .011));\n                texCol = mix(texCol, lCol, 1. - smoothstep(0., sf, angl[i] + .018));\n                \n                \n            }\n            \n    \n            \n        }\n        else if(objID==1){ \n        \n            //  Wall.\n         \n            // Intitial background color.\n           \n           \n            // Rendering an ordered subdivided pattern.\n            const vec2 sc = vec2(1./2., 1./4.);\n            float sf = .005;\n            vec2 p = rot2(3.14159/6.)*sp.xy;\n            float iy = floor(p.y/sc.y);\n            float rndY = hash21(vec2(iy));\n            if(mod(iy, 2.)<.5) p.x += sc.x/2. + iTime/8.*(rndY*.65 + .35);\n            else p.x -= iTime/8.*(rndY*.65 + .35);\n            vec2 ip = floor(p/sc);\n            p -= (ip + .5)*sc;\n            \n            // I catered for angular subdivision, then decided against\n            // it, so this could be tidied up a lot, which I'll do later.\n            float a = 0.;//atan(sc.y, sc.x) + 3.14159/9.;\n            if(mod(ip.x, 2.)<.5) a += 3.14159/2.;\n            if(mod(ip.y, 2.)<.5) a += 3.14159/2.;\n            vec2 pR = rot2(-a)*p;\n            float tri = pR.y<0.? -1. : 1.;\n            ip.x += tri*.5; // Subdivided ID.\n            \n            // Rectangle distance value.\n            p = abs(p) - sc/2.;\n            float shp = max(p.x, p.y);\n            shp = max(shp, -tri*pR.y);\n            \n            // Rendering the squares.\n            texCol = vec3(.04) + hash21(ip)*.02;\n            // Extra noise.\n            //float ns = fBm(sp*256.);\n            //texCol *= ns*.5 + .75;\n            texCol = mix(texCol, texCol*2.5, (1. - smoothstep(0., sf*3.5, abs(shp) - .015)));\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, abs(shp) - .015))*.9);\n            //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, abs(shp + .06) - .005))*.5);\n    \n            /*\n            // Rectangles on random blocks.\n            if(abs(ip.y + 2.)>7. && hash21(ip + .11)<.5){\n                shp += .045;\n                vec3 svCol = texCol;\n                float sh = max(.1 - shp/.08, 0.);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, shp));\n                texCol = mix(texCol, vec3(sh), 1. - smoothstep(0., sf, shp + .02));\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, shp + .04));\n                texCol = mix(texCol, bCol*1.2, 1. - smoothstep(0., sf, shp + .06));\n            } \n            */\n\n        }\n        else {  \n            // The icosahedral vertices.\n            texCol = bCol;\n        }\n\n        \n        \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(4, .2, .1), fBlend);\n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .7, .4)*spec*freS*sh*2.);\n \n\n\n            // Shading.\n        col *= ao*atten;\n        \n       \n\t\n\t}\n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(col, 0.), 1);\n\t\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVyRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 173, 291, 523]]}
{"id": "3tdcRB", "name": "Black n White Bird", "author": "BradyInstead", "description": "bird", "tags": ["bird"], "likes": 13, "viewed": 262, "published": 3, "date": "1656026945", "time_retrieved": "2024-07-30T16:43:27.376872", "image_code": "// Fork of \"Bird\" by BradyInstead. https://shadertoy.com/view/wdsfWM\n// 2020-12-30 23:59:38\n\n#define PI 3.14159265358979323846\n\n#define FLOOR_Y 3.\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fnoise( in vec3 pos )\n{\n    float f = 0.0;\n\tvec3 q = 8.0*pos;\n    f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    return f;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdPlane( vec3 p)\n{\n\treturn abs(p.y);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 opCheapBend(in vec3 p , float amount)\n{\n    float k = amount; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 opRotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat model(vec3 p)\n{\n    // set up\n    p*=.9;\n    p.y -= .5;\n    \n    \n    // bird\n    float bird;\n    \n    // movement\n    p.y += -1. - sin(iTime*14.) * .2 * sin(iTime);\n    \n    \n    // body\n    float body;\n    {\n    \tvec3 bp = p;\n        bp *= 1.;\n        bp.z += 1.25;\n        bp.y *= 1.25;\n        bp.y *= .6 + sin(bp.z*4. + 3.)*.1;\n        //bp.yx *= 1. - sin(bp.zy*25.)*.05;\n        \n        bp.z *= 1.2;\n        \n        body = sdCapsule( bp, vec3(0., -.25, .0), vec3(.1, .1, 2.), .3);\n    }\n    bird = body;\n    \n    \n    // head\n    float head;\n    {\n        vec3 hp = p;\n        hp.z -= .7;\n        hp.x -= .1;\n        hp.y -= .2;\n        \n        head = sdSphere(hp, .24);\n    }\n    bird = opSmoothUnion(bird, head, .2);\n    \n    \n    // beak\n    float beak;\n    {\n        // position\n        vec3 bp = p;\n        bp.z -= 1.2;\n        bp.x -= .1;\n        bp.y -= .1;\n        //bp.z *= .3;\n        //bp.y *= .75;\n        \n        bp.y += bp.z*.25;\n        \n        // rotate\n        bp = opRotate(bp, vec3(1., 0., 0.), - PI * .6);\n        \n        beak = sdRoundCone( bp, .025, .1, .3 ) * .8;\n    }\n    bird = opSmoothUnion(bird, beak, .1);\n    \n    \n    // wings\n    float wings = 9999999.;\n    {\n        // shaping\n    \tvec3 wp = opCheapBend(p, sin(iTime*14.) * .2 * sin(iTime));\n    \t//wp.z += pow(abs(wp.x), 4.)*.1;\n        wp.y -= .15;\n        \n        // rotate\n        wp = opRotate(wp, vec3(1., 0., 0.), - PI * .1);\n        \n        // texturing\n        if(wp.z < .35)\n        \t\twp.z += sin(wp.x * 30.) * .05 * wp.z;\n        \n        // wing frills\n       \tif(wp.z < -.1)\n            wp.z += sin(abs(wp.x) * 1.6) * .3;\n        else\n            wp.z += sin(abs(wp.x) * 2.75) * .1;\n        \n        // texturing\n        wp.y *= 1. - sin(wp.z*25.)*.05;\n        \n        //wp.z -= wp.x;\n        \n        \n        //if(wp.x > .2 || wp.x < -.1)\n    \t\twings = sdBox(wp, vec3(2.8, .05, .4));\n        \n        \n        wings *= .4;\n    }\n    bird = opSmoothUnion(bird, wings, .05); \n    \n    \n    // talons\n    float talons = 999999.;\n    {\n        for(float i = -1.; i <= 1.; i+=2.)\n        {\n            float index = 0.;\n            for(float j = 3.; j > 2.; j-=.3)\n            {\n            \n        \t\tvec3 wp = p;\n                \n        \t\twp = opCheapBend(wp, sin(iTime*14.) * .2 * sin(iTime));\n                \n        \t\twp.x += j * i;\n            \twp.x += .1;\n        \t\twp.z += .6;\n        \t\twp.y -= .2;\n        \t\twp.y *= 1.1;\n                wp.y += (index/3.)*.2;\n              \n        \n        \t\ttalons = min(talons, sdCapsule( wp, vec3(0., 0., 0.), vec3(.1, .1, .7), .025));\n                \n                index++;\n                \n            }\n        }\n    }\n    bird = opSmoothUnion(bird, talons, .3); \n    \n    \n    // tail\n    float tail;\n    {\n    \tvec3 wp = p;\n        wp *= .7;\n        \n        // positioning\n        //wp.z += 1.7;\n        wp.y += .1;\n        wp.z -= .7;\n        wp.z *= 1.2;\n        wp.x *= .6;\n        \n        // shaping\n       \t//wp.z += sin(wp.x * 30.) * .05;\n        //wp.z += abs(sin(wp.x*1.5));\n        \n        //if(wp.x > 1.)\n        \twp.z += sin(wp.x + PI/2.)*2.;\n        wp.x *= 1.5;\n        \n        wp.x *= 1. + wp.z*.9;\n        wp.x *= 1.4;\n        \n        // texturing\n        wp.y *= 1. - sin(wp.x*25.)*.3;\n        \n    \ttail = sdBox(wp, vec3(.5, .05, .4)) * .7;\n    }\n    bird = opSmoothUnion(bird, tail, .25);\n    \n    \n    // return\n    return bird;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 90; i++)\n    {\n\t\tfloat m = model(ro+rd*dist);\n        dist += m;\n        \n        if(m < .05) return dist;\n        else if(dist > 30.) break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(.01, -.01, 0.);\n    \n    return normalize(vec3(\n        model(pos + eps.xzz) - model(pos + eps.yzz),\n        model(pos + eps.zxz) - model(pos + eps.zyz),\n        model(pos + eps.zzx) - model(pos + eps.zzy)));\n}\n\nfloat shadow(in vec3 pos, in vec3 ld)\n{\n    float spread = 3.;\n    float res = 1.0;\n\tfor(float t = .2; t < .4;)\n    {\n        float dist = model(pos+ld*t);\n        if(dist<.001) return 0.;\n        res = min(res, spread*dist/t);\n        t += dist;\n    }\n    return res;\n}\n\nvec3 background()\n{\n\treturn vec3(0.);  \n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 rd, float dist)\n{\n    if(dist < 0.) return background();\n    \n    vec3 ld = normalize(vec3(2., 10., 2.));\n    //vec3 ld = normalize(lp-pos);\n    \n    vec3 lightColor = vec3(.9, .6, .1) * 1.8;\n    \n    float dif = max(dot(nor,ld),0.);\n    float sha = 0.;\n    if(dif > .01) sha = shadow(pos, ld);\n    vec3 lin = vec3(dif*sha);\n    \n    vec3 col = lin;\n    \n    // bird\n    col *= lightColor;\n    \n    col = min(col, vec3(1.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float zoom = 3.;\n    vec3 ro = vec3(sin(iTime*.5)*zoom, zoom * 2., cos(iTime*.5)*zoom); \n    vec3 ta = vec3(0.);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,.5));\n    \n    float dist = raymarch(ro, rd);\n    vec3 pos = ro+rd*dist;\n    vec3 nor = normal(pos);\n    \n    vec3 col = shade(pos, nor, rd, dist);\n    \n    col = mix(col, background(), pow(dist/30., 2.));\n    \n    col = vec3(dot(col.rgb, vec3(0.299, 0.587, 0.114)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tdcRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 205, 205, 300], [302, 302, 328, 328, 802], [930, 930, 959, 959, 1181], [1183, 1183, 1218, 1218, 1242], [1244, 1244, 1275, 1275, 1362], [1364, 1364, 1416, 1416, 1537], [1539, 1539, 1597, 1597, 1861], [1863, 1863, 1887, 1887, 1907], [1909, 1909, 1962, 1962, 2062], [2064, 2064, 2108, 2108, 2284], [2286, 2286, 2331, 2331, 2959], [2961, 2961, 3008, 3008, 3081], [3083, 3083, 3104, 3118, 6509], [6511, 6511, 6551, 6551, 6761], [6763, 6763, 6786, 6786, 7017], [7019, 7019, 7058, 7058, 7289], [7291, 7291, 7310, 7310, 7332], [7334, 7334, 7387, 7387, 7817], [7819, 7819, 7876, 7876, 8591]]}
{"id": "sscfzH", "name": "sRGB Gamma Correction", "author": "cppio", "description": "Demonstrating how 0.5 does not represent an equal blend with black unless gamma correction is used.", "tags": ["gamma"], "likes": 2, "viewed": 238, "published": 3, "date": "1656015233", "time_retrieved": "2024-07-30T16:43:28.168755", "image_code": "vec3 gamma(vec3 linear) {\n    return mix(1.055 * pow(linear, vec3(1.0 / 2.4)) - 0.055, 12.92 * linear, lessThanEqual(linear, vec3(0.0031308)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float x;\n    if (uv.x < 0.5 && uv.y > 0.5) {\n        x = fragCoord.x + fragCoord.y;\n    } else if (uv.x > 0.5 && uv.y < 0.5) {\n        x = 0.5;\n    } else if (fragCoord.x + 0.5 * iResolution.y < fragCoord.y + 0.5 * iResolution.x ^^ uv.x < 0.5) {\n        x = fragCoord.y - 0.5 + float(uv.x > 0.5);\n    } else {\n        x = fragCoord.x - 0.5 + float(uv.x > 0.5);\n    }\n    vec3 col = 0.5 + 0.5 * cos(iTime + vec3(0, 2, 4));\n    fragColor = vec4(vec3(mod(x, 2.0)) * col, 1);\n    if (iMouse.z <= 0.0) fragColor.rgb = gamma(fragColor.rgb);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 145]]}
{"id": "ss3BzH", "name": "simple drawing program", "author": "mds2", "description": "An attempt at a very simple drawing program", "tags": ["test", "simple", "mouse", "drawing"], "likes": 3, "viewed": 255, "published": 3, "date": "1656011071", "time_retrieved": "2024-07-30T16:43:28.917752", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 oldColor = texture(iChannel0, uv);\n    \n    vec2 toMouse = abs(iMouse.xy - fragCoord.xy);\n    \n    float close = step(toMouse.x + toMouse.y, 30.0);\n    \n    vec3 newColor = mod(oldColor.rgb + vec3(0.1, 0.2, 0.3) * close, vec3(1.0));\n    \n    fragColor = vec4(newColor, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3BzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 190]]}
{"id": "ss3Bz8", "name": "Pixelated Image w/ Color Lookup", "author": "Xorberax", "description": "Pixelates and maps colors for an image.\nTweak the PIXELATION_FACTOR constant to scale the pixelation.\nClick and drag up/down in the render window to tweak the brightness for color mapping.\n", "tags": ["pixelation", "pixelated"], "likes": 4, "viewed": 511, "published": 3, "date": "1655997619", "time_retrieved": "2024-07-30T16:43:29.872200", "image_code": "const float PIXELATION_FACTOR = 4.0;\n\nvec2 getPixelatedSampleCoord(vec2 fragCoord)\n{\n    return fragCoord - mod(fragCoord, PIXELATION_FACTOR);\n}\n\nvec4 getMappedColor(vec4 color)\n{\n    float luma = luma(color) + iMouse.y / iResolution.y;\n    if (luma > 0.95)\n    {\n        return vec4(0.75, 0.8, 0.9, 1.0);\n    }\n    else if (luma > 0.93)\n    {\n        return vec4(0.7, 0.5, 0.2, 1.0);\n    }\n    else if (luma > 0.88)\n    {\n        return vec4(0.6, 0.5, 0.3, 1.0);\n    }\n    else if (luma > 0.8)\n    {\n        return vec4(0.5, 0.25, 0.25, 1.0);\n    }\n    else if (luma > 0.7)\n    {\n        return vec4(0.25, 0.15, 0.25, 1.0);\n    }\n    else if (luma > 0.6)\n    {\n        return vec4(0.23, 0.15, 0.25, 1.0);\n    }\n    else if (luma > 0.3)\n    {\n        return vec4(0.2, 0.1, 0.15, 1.0);\n    }\n    else if (luma > 0.25)\n    {\n        return vec4(0.15, 0.1, 0.05, 1.0);\n    }\n    else if (luma > 0.2)\n    {\n        return vec4(0.0, 0.0, 0.1, 1.0);\n    }\n    else if (luma > 0.1)\n    {\n        return vec4(0.05, 0.0, 0.05, 1.0);\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sampleCoord = getPixelatedSampleCoord(fragCoord);\n    vec2 uv = sampleCoord / iResolution.xy;\n    fragColor = getMappedColor(texture(iChannel0, uv));\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Credit: https://github.com/hughsk/glsl-luma/blob/master/index.glsl\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3Bz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 84, 84, 144], [146, 146, 179, 179, 1068], [1070, 1070, 1127, 1127, 1288]]}
{"id": "7scfR8", "name": "Image Pixelation", "author": "Xorberax", "description": "Pixelates an image. Tweak the PIXELATION_FACTOR constant to scale the pixelation.", "tags": ["pixelation", "pixelated"], "likes": 2, "viewed": 335, "published": 3, "date": "1655995675", "time_retrieved": "2024-07-30T16:43:30.689016", "image_code": "const float PIXELATION_FACTOR = 8.0;\n\nvec2 getPixelatedSampleCoord(vec2 fragCoord)\n{\n    return fragCoord - mod(fragCoord, PIXELATION_FACTOR);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sampleCoord = getPixelatedSampleCoord(fragCoord);\n    vec2 uv = sampleCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 84, 84, 144], [146, 146, 203, 203, 348]]}
{"id": "Ns3BRH", "name": "well bottom", "author": "nikixd", "description": "...", "tags": ["noise", "ring"], "likes": 5, "viewed": 237, "published": 3, "date": "1655983272", "time_retrieved": "2024-07-30T16:43:31.528772", "image_code": "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat circle(vec2 center, float radius, vec2 uv)\n{\n    const float blur = 0.01;\n    vec2 offset = uv - center;\n    float dist = sqrt(pow(offset.x, 2.0) + pow(offset.y, 2.0));\n    return 1.0 - smoothstep(radius - blur / 2.0, radius + blur / 2.0, dist);\n}\n\nfloat ring(vec2 center, float radius, float thickness, vec2 uv)\n{\n    float c1 = circle(center, radius, uv);\n    float c2 = circle(center, radius + thickness, uv);\n    return (1.0 - c1) * c2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zero in the center and closest edge is 1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    float ratio = iResolution.x / iResolution.y;\n    uv *= vec2(max(1.0, ratio), max(1.0, 1.0 / ratio));\n    \n    vec2 offset = vec2(\n        snoise(vec3(uv.xy*4.0, iTime)),\n        snoise(vec3(-uv.xy*4.0, iTime))\n    ) * 0.1;\n    \n    vec3 col = pow(length(uv), 3.0) * vec3(0.05) + ring(vec2(0.0), 0.9, 0.02, uv + offset) * vec3(0.9);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3BRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 70], [72, 72, 93, 93, 142], [144, 144, 166, 166, 207], [209, 209, 237, 237, 289], [291, 291, 313, 313, 1984], [1986, 1986, 2036, 2036, 2239], [2241, 2241, 2306, 2306, 2434], [2436, 2436, 2493, 2541, 2981]]}
{"id": "fddfRn", "name": "Rhombic Dodecahedron Grid Tiling", "author": "gehtsiegarnixan", "description": "I created Quadruple Rhombic Dodecahedron Tiling used for Directional Flow in 3D. ", "tags": ["3d", "grid", "tetrahedron", "distance", "barycentric", "flow", "honeycomb", "tiling", "trilinear", "directional", "dodecahedron", "rhombic"], "likes": 5, "viewed": 272, "published": 3, "date": "1655976654", "time_retrieved": "2024-07-30T16:43:32.458286", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nRhombic Dodecahedron Tiling perfectly in 3D space.\nI made four perfectly overlaying Rhombic Dodecahedron Grid Tiles. In the pattern I\naranged them they have a very useful property. If you add up the edge distance of \nall 4 grids they add up to 1 in all points. This allows us to do bilinear \ninterpolation between 4 samples in 3D space. \n\nThis project contains: \n- Rhombic Dodecahedron Distance function. \n- An infinite Rhombic Dodecahedron Gird Tiling with Center Distance, Edge Distance, \n    centered UVW Coordinates, and Cell ID. \n- Four Rhombic Dodecahedron Girds with the grids being offset so that their\n    edges get perfectly hidden by each other\n\nI created this for a 3D version of the Hex Directional Flow with only 4 flowmaps \n+ 4 textures samples. In contrast the original directional flow has 8 flowmaps + \n8 textures when used in 3D. But to showcase it here, I need a nice 3D Flow \nand Texture. Maybe I will make it in future.\n*/\n\n//#define ZEROTOONE\n\n// show the alpha instead of UVWs\n#define ALPHA\n\n#define sqrt2 \t\t\t1.4142135624 //sqrt(2.)\n#define half_sqrt2\t\t0.7071067812 //sqrt(2.)/2.\n#define qurt_sqrt2\t\t0.3535533906 //sqrt(2.)/4.\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}\n\n//Distance from the Edge of Rhombic Dodecahedron\nfloat rhomDist(vec3 p) {\n    vec3 hra = vec3(0.5, 0.5, half_sqrt2); //vector to Diagonal Edge\n    p = abs(p);\n    float pBC = max(p.x,p.y); //rigt and top edge\n    float pABC = max(dot(p, hra),pBC); //diagonal edge\n    \n    //optional 0-1 range\n    return (.5-pABC)*2.;\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal3D \n{\n    vec3 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec3 id;         // ID values\n    float alpha;  // Edge distance from the cell's center to its boundaries\n};\n\n//Rhombic Dodecahedron Tiling\ntilingVal3D rohmTile(vec3 uvw) {\n    vec3 r = vec3(1.0,1.0,sqrt2);\n    vec3 h = r*.5;\n\n    vec3 a = mod(uvw, r)-h;\n    vec3 b = mod(uvw-h,r)-h;\n    \n    vec3 gvw = dot(a, a) < dot(b,b) ? a : b; //center rhom uvw\n    float edist = rhomDist(gvw); //Edge distance with range 0-1\n    //float cdist = dot(gvw, gvw); // squared distance with range 0-1\n    vec3 id = uvw-gvw; // simple ID calculation\n    \n    return tilingVal3D(gvw, id, edist);\n}\n\n// scaled with offset Rhombic Dodecahedron tiling\ntilingVal3D rohmCell(vec3 uvw, vec3 offset, float gridRes) {\n    tilingVal3D rohmTiling = rohmTile(uvw*gridRes + offset);\n    vec3 tiledUV = (rohmTiling.id - offset)/gridRes; //rohm pixaltion    \n    return tilingVal3D(rohmTiling.grid, tiledUV,rohmTiling.alpha);\n}\n\n// 4 Rhombic Dodecahedron tiles offset so their edges get hidden by each other\nvec3 quadGrid(vec3 uvw, float gridRes, float contrast) {\n    tilingVal3D a = rohmCell(uvw, vec3( .0, .0, .0), gridRes);\n    tilingVal3D b = rohmCell(uvw, vec3( .5, .0, qurt_sqrt2), gridRes);\n    tilingVal3D c = rohmCell(uvw, vec3( .0, .5, qurt_sqrt2), gridRes);\n    tilingVal3D d = rohmCell(uvw, vec3( .0, .0, half_sqrt2), gridRes);\n   \n    // increase contrast\n    vec4 alpha = smoothContrast(vec4(a.alpha, b.alpha, \n                                c.alpha, d.alpha), contrast);\n                                \n#ifdef ZEROTOONE\n    // rescale UVWs to 0-1\n    a.grid = a.grid *0.5+0.5;\n    b.grid = b.grid *0.5+0.5;\n    c.grid = c.grid *0.5+0.5;\n    d.grid = d.grid *0.5+0.5;   \n#endif\n    \n    // interpolate UVWs cause shadertoy doesn't have nice 3d Textures\n    vec3 col = a.grid * alpha.x +\n               b.grid * alpha.y +\n               c.grid * alpha.z +\n               d.grid * alpha.w;\n#ifndef ZEROTOONE\n    col *= 2.0;\n#endif\n\n#ifdef ALPHA\n    col = alpha.xyz;\n#endif\n    \n    return col;\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 1.5; //size of Ico\n    float contrast = 1.; //1 no contrast, higher values increase contrast\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.1*iTime); // used as z dimension      \n    vec3 point = vec3(uv, time); //animated uv cords\n    \n    //cosmetic rotate for fun hexagons otherwise it looks so square\n    point = rotate(point, normalize(vec3(1.,0.,0.))); \n    \n    vec3 col = quadGrid(point,gridRes, contrast);\n        \n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddfRn.jpg", "access": "api", "license": "mit", "functions": [[2236, 2379, 2428, 2466, 2635], [2637, 2686, 2710, 2710, 2957], [3237, 3267, 3299, 3299, 3707], [3709, 3759, 3819, 3819, 4023], [4025, 4104, 4160, 4160, 5106], [5108, 5183, 5212, 5349, 5770], [5772, 5772, 5828, 5828, 6341]]}
{"id": "7syyDc", "name": "Ray Tracing in One Weekend Test", "author": "73begonia", "description": "@Peter Shirley;\nReference:https://raytracing.github.io/books/RayTracingInOneWeekend.html;\n@ shicz86;\nhttps://www.shadertoy.com/view/3djfRy;", "tags": ["raytracing", "raytracer", "gi", "spheres", "pathtracing", "pathtracer", "realtime", "one", "weekend"], "likes": 8, "viewed": 519, "published": 3, "date": "1655949012", "time_retrieved": "2024-07-30T16:43:33.378825", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int depth = 4;\nconst float pi = 3.1415926535;\nconst int spp = 4;\n\nfloat seed = 0.0;\nvec2 UV = vec2(0.);\n\n#define LAMBERT    0\n#define METAL      1\n#define DIELECTRIC 2\n#define MIN_FLOAT 1e-3\n#define MAX_FLOAT 1e5\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat random()\n{\n\treturn fract(sin(dot(UV, vec2(12.9898, 78.233)) + seed++) * 43758.5453);\n}\n\nvec3 random_in_unit_sphere()\n{\n\tvec3 p = vec3(0.);\n    do{\n        p=2.*vec3(random(),random(),random())-vec3(1.);\n    }while(dot(p,p)>=1.);\n    return p;\n}\n\nvec3 random_in_unit_disk()\n{\n\tvec3 p =  vec3(0.);\n    do{\n        p=2.*vec3(random(),random(),0)-vec3(1.,1.,0.);\n    }while(dot(p,p)>=1.);\n    return p;\n}\n\nstruct Ray\n{\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Material\n{\n  int materialType;\n  vec3 normal;\n  vec3 baseColor;\n  float fuzz;\n  float refractionIndex;\n};\n\nstruct HitResult\n{\n  float t;\n  vec3 hitPoint;\n  Material material;\n  bool front_face;\n};\n\nstruct Sphere\n{\n    vec4 sph;\n    Material material;\n};\n\nstruct Camera\n{\n    vec3 origin;\n    vec3 lowerLeftCorner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n    float lensRadius;\n};\n\nvec3 set_face_normal(Ray r, vec3 outward_normal)\n{\n    float front_face = dot(r.rd, outward_normal);\n    if(front_face < 0.)\n        return outward_normal;\n    else\n        return -outward_normal;\n}\n\n\nvec3 nSphere(vec3 pos, Sphere s ) {\n    return (pos-s.sph.xyz)/s.sph.w;\n}\n\nbool iSphere(Ray r, Sphere s, float t_min, float t_max, inout HitResult res)\n{\n  vec3 oc = r.ro - s.sph.xyz;\n  float a = dot(r.rd, r.rd);\n  float h = dot(oc, r.rd);\n  float c = dot(oc, oc) - s.sph.w * s.sph.w;\n  float discriminant = h * h - a * c;\n  vec3 outward_normal;\n  \n  if(discriminant > 0.)\n  {\n      float root = sqrt(discriminant);\n      float temp = (-h - root) / a;\n      if(temp < t_max && temp > t_min)\n      {\n          res.t = temp;\n          res.hitPoint = r.ro + res.t * r.rd;\n          outward_normal = nSphere(res.hitPoint, s);\n          res.front_face = dot(r.rd, outward_normal) < 0.;\n          \n          res.material = s.material;\n          res.material.normal = set_face_normal(r, outward_normal);\n          return true;\n      }\n      temp = (-h + root) / a;\n      if(temp < t_max && temp > t_min)\n      {\n          res.t = temp;\n          res.hitPoint = r.ro + res.t * r.rd;\n          outward_normal = nSphere(res.hitPoint, s);\n          res.front_face = dot(r.rd, outward_normal) < 0.;\n          \n          res.material = s.material;\n          res.material.normal = set_face_normal(r, outward_normal);\n          return true;\n      }\n  }\n  return false;    \n}\n\nMaterial m_Lambertian(vec3 baseColor)\n{\n\treturn Material(LAMBERT, vec3(0.), baseColor, 0., 0.);\n}\n\nMaterial m_Metal(vec3 baseColor, float fuzz)\n{\n\treturn Material(METAL, vec3(0.), baseColor, fuzz, 0.);\n}\n\nMaterial m_Dielectric(float refractionIndex)\n{\n\treturn Material(DIELECTRIC, vec3(0.), vec3(0.), 0., refractionIndex);\n}\n\nfloat schlick(float cos_theta, float n2)\n{\n    const float n1 = 1.0f;  // refraction index for air\n\n    float r0s = (n1 - n2) / (n1 + n2);\n    float r0 = r0s * r0s;\n\n    return r0 + (1.0f - r0) * pow((1.0f - cos_theta), 5.0f);\n}\n\nbool refractVec(vec3 v, vec3 n, float ni_over_nt, out vec3 refracted)\n{\n    vec3 uv = normalize(v);\n\n    float dt = dot(uv, n);\n\n    float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0f - dt * dt);\n\n    if (discriminant > 0.0f)\n    {\n        refracted = ni_over_nt*(uv - n * dt) - n * sqrt(discriminant);\n\n        return true;\n    }\n    else\n        return false;\n}\n\nbool lambertian(Ray r, HitResult res, out vec3 attenuation, out Ray scattered) \n{\n    scattered = Ray(res.hitPoint, res.material.normal + random_in_unit_sphere());\n\tattenuation = res.material.baseColor;\n\treturn true;\n}\n\nbool metal(Ray r, HitResult res, out vec3 attenuation, out Ray scattered) \n{\n    float fuzz = res.material.fuzz;\n    vec3 reflected = reflect(normalize(r.rd), res.material.normal);\n    scattered = Ray(res.hitPoint, reflected + fuzz * random_in_unit_sphere());\n    attenuation = res.material.baseColor;\n    return (dot(scattered.rd, res.material.normal) > 0.0);   \n}\n\nbool dielectric(Ray r, HitResult res, out vec3 attenuation, out Ray scattered) \n{\n\tattenuation = vec3(1.);\n    float etai_over_etat = (res.front_face) ? (1.0 / res.material.refractionIndex) : (res.material.refractionIndex);\n    \n    vec3 unit_direction = normalize(r.rd);\n    float cos_theta = min(dot(-unit_direction, res.material.normal), 1.0);\n    float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n    if (etai_over_etat * sin_theta > 1.0 ) {\n        vec3 reflected = reflect(unit_direction, res.material.normal);\n        scattered = Ray(res.hitPoint, reflected);\n        return true;\n    }\n    float reflect_prob = schlick(cos_theta, etai_over_etat);\n    if (random() < reflect_prob)\n    {\n        vec3 reflected = reflect(unit_direction, res.material.normal);\n        scattered = Ray(res.hitPoint, reflected);\n        return true;\n    }\n    vec3 refracted = refract(unit_direction, res.material.normal, etai_over_etat);\n    scattered = Ray(res.hitPoint, refracted);\n    return true;\n}\n\nbool material_BSDF(HitResult res, Ray wo, out Ray wi, out vec3 attenuation)\n{\n    int materialType = res.material.materialType;\n\n    if(materialType == LAMBERT)\n    {\n        return lambertian(wo, res, attenuation, wi);\n    }\n    else if(materialType == METAL)\n    {\n        return metal(wo, res, attenuation, wi);\n    }\n    else if(materialType == DIELECTRIC)\n    {\n    \treturn dielectric(wo, res, attenuation, wi);\n    }\n\n    return false;\n}\n\nbool iScene(Ray r, float t_min, float t_max, out HitResult tempRes)\n{\n    tempRes.t = t_max;\n    bool hit = false;\n\n\tSphere s1 = Sphere(vec4(0., -1000, 0., 1000.), m_Lambertian(vec3(0.5)));\n    if(iSphere(r, s1, t_min, tempRes.t, tempRes))\n    {\n        hit = true;\n    }\n    \n    Sphere s2 = Sphere(vec4(0, 1, 0, 1.0), m_Dielectric(1.5));\n    if(iSphere(r, s2, t_min, tempRes.t, tempRes))\n    {\n        hit = true;\n    }\n    \n    Sphere s3 = Sphere(vec4(-4, 1, 0, 1.0), m_Lambertian(vec3(0.4, 0.2, 0.1)));\n    if(iSphere(r, s3, t_min, tempRes.t, tempRes))\n    {\n        hit = true;\n    }\n    \n    Sphere s4 = Sphere(vec4(4, 1, 0, 1.0), m_Metal(vec3(0.7, 0.6, 0.5), 0.0));\n    if(iSphere(r, s4, t_min, tempRes.t, tempRes))\n    {\n        hit = true;\n    }\n    \n    for(int a = -11; a < 11; a++)\n        for(int b = -11; b < 11; b++)\n        {\n            float m_seed = float(a) + float(b)/1000.;\n            vec3 rand1 = hash3(m_seed);            \n            vec3 center = vec3(float(a)+.9*rand1.x,.2,float(b)+.9*rand1.y); \n            float choose_mat = rand1.z;\n            \n            if (distance(center,vec3(4,.2,0)) > .9) \n            {\n                if (choose_mat < 0.8) \n                { \n                    Sphere s = Sphere(vec4(center, 0.2), m_Lambertian(hash3(m_seed)* hash3(m_seed)));\n                    if (iSphere(r, s, t_min, tempRes.t, tempRes))\n                        hit=true;\n                } \n                else if (choose_mat < 0.95) \n                { \n                    Sphere s = Sphere(vec4(center, 0.2), m_Metal(.5*(hash3(m_seed)+1.),.5*hash1(m_seed)));\n                    if (iSphere(r, s, t_min, tempRes.t, tempRes))\n                        hit=true;\n                } \n                else \n                { \n                    Sphere s = Sphere(vec4(center, 0.2), m_Dielectric(1.5));\n                    if (iSphere(r, s, t_min, tempRes.t, tempRes)) \n                        hit=true;\n                }\n            }\n        }\n    \n    return hit;\n}\n\nvec3 ray_color(Ray r, vec2 uv)\n{\n    vec3 col = vec3(1.);\n\t\n    HitResult res;\n    Ray scattered;\n    vec3 attenuation;\n    \n    for(int i = 0; i < depth; i++)\n    {\n\t\tif(iScene(r, MIN_FLOAT, MAX_FLOAT, res))\n\t\t{\n\t\t\tbool wasScattered = material_BSDF(res, r, scattered, attenuation);\n\t\t\tr.ro = scattered.ro;\n\t\t\tr.rd = scattered.rd;\n\t\t\t\n\t\t\tif(wasScattered)\n\t\t\t\tcol *= attenuation;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcol *= vec3(0.);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvec3 unit_direction = normalize(r.rd);\n            float t = 0.5*(unit_direction.y+1.0);\n            col *= mix(vec3(1.),vec3(.5,.7,1.),t);\n            return col;\n\t\t}\n    }\n    \n    return vec3(0.);\t\n}\n\nvoid Camera_init(out Camera camera, vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect, float aperture, float focusDist)\n{\n    camera.lensRadius = aperture / 2.0;\n    \n    float theta = vfov * pi / 180.0;\n    float halfHeight = tan(theta / 2.0);\n    float halfWidth = aspect * halfHeight;\n\n    camera.origin = lookfrom;\n\n    camera.w = normalize(lookfrom - lookat);\n    camera.u = normalize(cross(vup, camera.w));\n    camera.v = cross(camera.w, camera.u);\n\n    camera.lowerLeftCorner = camera.origin  - halfWidth  * focusDist * camera.u\n                                            - halfHeight * focusDist * camera.v\n                                            -              focusDist * camera.w;\n\n    camera.horizontal = 2.0 * halfWidth  * focusDist * camera.u;\n    camera.vertical   = 2.0 * halfHeight * focusDist * camera.v;\n}\n\n\nRay Camera_getRay(Camera camera, float s, float t)\n{\n    vec3 rd = camera.lensRadius * random_in_unit_sphere();\n    vec3 offset = camera.u * rd.x + camera.v * rd.y;\n\n    Ray r;\n\n    r.ro = camera.origin + offset;\n    r.rd = camera.lowerLeftCorner + s * camera.horizontal + t * camera.vertical - camera.origin - offset;\n\n    return r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    seed = iTime;\n    UV = fragCoord / iResolution.xy;\n    \n    vec3 lookfrom = vec3(13, 2, 3);\n    const vec3 lookat = vec3(0.0, 0.0, 0.);\n    float aspect_ratio = iResolution.x / iResolution.y;\n    float distToFocus = 10.;\n    float aperture = 0.1;\n    \n    Ray r;\n    Camera cam;\n    vec3 col;\n    vec2 uv;\n    \n    \n    for(int i = 0; i < spp; i++)\n    {   \n        uv = (fragCoord.xy + vec2(random(), random())) / iResolution.xy;\n        \n        Camera_init(cam, lookfrom, lookat, vec3(0., 1., 0.), 20., aspect_ratio, aperture, distToFocus);\n\t    r = Camera_getRay(cam, uv.x, uv.y);\n\t\t\n        col += ray_color(r, uv);\n    }\n    \n    col /= float(spp);\n    \n    col = pow(clamp(col, 0., 1.), vec3(0.45));\n    \n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    col = mix(lastFrameColor, col, 1.0f / float(iFrame+1));\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 163]]}
{"id": "7dtBRn", "name": "Simple voronoi", "author": "marvpaul", "description": "This is a simple voronoi shader", "tags": ["voronoisimple"], "likes": 1, "viewed": 181, "published": 3, "date": "1655942578", "time_retrieved": "2024-07-30T16:43:34.173699", "image_code": "float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0); \n    int points = 4;\n     vec2 array[4] = vec2[4](\n     vec2(0.1+0.2*sin(iTime), 0.3),\n     vec2(0.3+cos(iTime)*0.05, 0.1),\n     vec2(0.8+sin(iTime)*0.02, 0.7-cos(iTime)*0.01),\n     vec2(0.1, 0.3));\n     float dmin = 1000.0;\n     int point = 0; \n     vec2 factor = vec2(100.0, 100.0*iResolution.y/iResolution.x);\n     for (int i = 0; i < points; i++){\n         float uv_x = float(int(uv.x*factor.x))/factor.x;\n         float uv_y = float(int(uv.y*factor.y))/factor.y;\n         \n         float uv_x_a = float(int(array[i].x*factor.x))/factor.x;\n         float uv_y_a = float(int(array[i].y*factor.y))/factor.y;\n         if(vec2(uv_x, uv_y) == vec2(uv_x_a, uv_y_a)){\n             col = vec3(1,0,0);\n         }\n         \n         if(length(array[i] - uv) < dmin){\n             point = i; \n             dmin = length(array[i] - uv);\n         }\n     }\n\n    // Output to screen\n    vec2 vector = vec2(0.2*float(point),0.2*float(point));\n        vec2 vector2 = vec2(sin(0.2*float(point)),cos(0.2*float(point)));\n                vec2 vector3 = vec2(cos(0.2*float(point)),sin(0.2*float(point)));\n    \n    fragColor = vec4(col+vec3(rand(vector),rand(vector2), rand(vector3)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtBRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 220], [222, 222, 279, 329, 1566]]}
{"id": "wt3XRf", "name": "Moshed Geometry", "author": "BradyInstead", "description": "Custom raymarching engine", "tags": ["raymarcher"], "likes": 6, "viewed": 239, "published": 3, "date": "1655929715", "time_retrieved": "2024-07-30T16:43:34.959598", "image_code": "\n#define NUM_COLORS 2\n\nfloat sdSphere( vec3 p, float s )\n{\n    p.y += sin(iTime*4.)/20. +.08;\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), -1.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdOcta( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat model(vec3 p)\n{\n    //vec2 mouse = iMouse.xy/iResolution.xy * 1.;\n    vec2 mouse = vec2(cos(iTime*.1), sin(iTime*.1)) * .5 + .5;\n    float time = iTime + mouse.x*1.5;\n    \n    p *= 1.;\n    \n    // movement\n    p.x += sin(time*8.0)/30.;\n  \tp.z += cos(time*8.0)/30.;\n    p.y += sin(time*4.0)/10. - .1;\n    \n    float octaWidth = .5 + mouse.x*.25;\n    float octa = sdOcta(p + vec3(octaWidth*sin(time), 0., octaWidth*cos(time)), .25);\n    octa = opSmoothUnion(octa, sdOcta(p + vec3(octaWidth*sin(time + 3.14), 0., octaWidth*cos(time + 3.14)), .25), cos(time*8.)*.1 + .5);\n    octa = opSmoothUnion(octa, sdOcta(p + vec3(octaWidth*cos(time), 0., octaWidth*sin(time + 3.14)), .25), cos(time*8.)*.1 + .5);\n    octa = opSmoothUnion(octa, sdOcta(p + vec3(octaWidth*cos(time + 3.14), 0., octaWidth*sin(time)), .25), cos(time*8.)*.1 + .5);\n    \n    \n    float shiftAmount = 15. - mouse.y*10.;\n    \n    p.x += sin(p.x*30. + time)/shiftAmount;\n    p.z += cos(p.z*30. + time)/shiftAmount;\n    \n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    p.y = abs(p.y);\n    \n    // sizing\n    p*= .7;\n    \n    float torus = sdTorus (p + vec3(0., 0., 0.), vec2(0.25,0.05));\n    float sphere = sdSphere(p, .2);\n    \n    float dist = opSmoothUnion(torus, sphere, .1 + cos(time*8.0)*.05);\n    dist = opSmoothUnion(dist, octa, mouse.x*.4);\n    return dist * .9;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 90; i++)\n    {\n\t\tfloat m = model(ro+rd*dist);\n        dist += m;\n        \n        if(m < .01) return dist;\n        else if(dist > 20.) break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(.01, -.01, 0.);\n    \n    return normalize(vec3(\n        model(pos + eps.xzz) - model(pos + eps.yzz),\n        model(pos + eps.zxz) - model(pos + eps.zyz),\n        model(pos + eps.zzx) - model(pos + eps.zzy)));\n}\n\nfloat shadow(in vec3 pos, in vec3 ld)\n{\n    float spread = 3.;\n    float res = 1.0;\n\tfor(float t = .2; t < .4;)\n    {\n        float dist = model(pos+ld*t);\n        if(dist<.001) return 0.;\n        res = min(res, spread*dist/t);\n        t += dist;\n    }\n    return res;\n}\n\nvec3 getColor(int r)\n{\n    switch(r)\n    {\n        case 0:\n        \treturn vec3(86., 48., 107.) \t/256.;\n        case 1:\n        \treturn vec3(98., 67., 198.) \t/256.;\n        case 2:\n        \treturn vec3(102., 165., 250.)\t/256.;\n        case 3:\n        \treturn vec3(186., 250., 236.)\t/256.;\n    }\n    \n    return vec3(0.);\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 rd, float dist)\n{\n    if(dist < 0.) return vec3(0., 1., 0.);\n    \n    vec3 lp = vec3(sin(iTime*2.0)*2.0, 4.0, cos(iTime*2.0)*2.0);\n    vec3 ld = normalize(lp-pos);\n    \n    float dif = max(dot(nor,ld),0.);\n    float sha = 0.;\n    if(dif > .01) sha = shadow(pos, ld);\n    vec3 lin = vec3(dif*sha);\n    \n    float sharp = .25;\n    float inten = 1.0;\n    vec3 ref = 2.0 * dot(ld, nor)*nor-ld;\n    lin += pow(max(0., dot(-rd, ref)), sharp) * vec3(inten) * sha;\n    \n    vec3 col = lin;\n    col *= exp(-.01*dist*dist);\n    \n    // toon\n    col *= vec3(NUM_COLORS);\n    float colFract = abs(sin(fract(col.r) * 3.14 * 1.5));\n    col = floor(col);\n    \n    \n    // pallete\n    //col = getColor(int(col.r));\n    col = mix(getColor(int(col.r-1.)), getColor(int(col.r)), colFract);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    p.x = abs(p.x) - .1;\n    p *= .7;\n    \n    int pix = int(fragCoord.x + fragCoord.y);\n    float dither = float(pix%2)*.6;\n    \n    vec3 ro = vec3(1. + dither, 1. + dither, 1. + dither); \n    vec3 ta = vec3(0.);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,.5 + sin(iTime)*.1));\n    \n    float dist = raymarch(ro, rd);\n    vec3 pos = ro+rd*dist;\n    vec3 nor = normal(pos);\n    \n    vec3 col = shade(pos, nor, rd, dist);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3XRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 58, 58, 117], [119, 119, 152, 152, 217], [219, 219, 271, 271, 393], [395, 395, 427, 427, 707], [709, 709, 761, 761, 860], [862, 862, 883, 933, 2195], [2197, 2197, 2237, 2237, 2447], [2449, 2449, 2472, 2472, 2703], [2705, 2705, 2744, 2744, 2975], [2977, 2977, 2999, 2999, 3299], [3301, 3301, 3354, 3354, 4130], [4132, 4132, 4189, 4189, 4892]]}
{"id": "NsdBzn", "name": "Indexed Mercator Spiral", "author": "mla", "description": "Mercator spiral with indexing of tiles. Doing this with tiles moving in both directions should be possible but I haven't quite worked out the details yet.\n\nThis impossible movement makes the sphere look less 3-dimensional as well.", "tags": ["spiral", "loxodrome", "mercator"], "likes": 15, "viewed": 338, "published": 3, "date": "1655923169", "time_retrieved": "2024-07-30T16:43:35.763449", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Spherical texturing with Mercator projection, with indexed tiles\n// moving along loxodromes.\n//\n// Matthew Arcus, mla, 2022.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvec3 indexed(vec2 uv) {\n  float t = -PI/4.0;\n  vec2 uv0 = uv;\n  uv = rotate(uv,t);\n  uv *= 4.0/cos(t);\n  uv0 *= 4.0/cos(t);\n  uv.y += 0.1*iTime*(mod(uv.x,2.0) < 1.0 ? 1.0 : -1.0);\n  uv = mod(uv,8.0);\n  ivec2 iv = ivec2(floor(uv));\n  float rnd = float(ihash((uint(iv.x)<<16) ^ uint(iv.y)))/pow(2.0,32.0);\n  uv = mod(uv,1.0);\n  vec2 dv = min(uv,1.0-uv);\n  float d = min(dv.x,dv.y);\n  vec3 tex = textureGrad(iChannel0,uv,vec2(dFdx(uv0.y)),vec2(dFdy(uv0.y))).rgb;\n  float tone = dot(tex,tex);\n  vec3 col = hsv2rgb(vec3(rnd,0.5,1));\n  col *= 0.8*tone;\n  col = mix(vec3(0),col,smoothstep(0.01,0.02,d));\n  return col;\n}\n\nvec3 getColor(vec3 p) {\n  float x = atan(p.x,p.y);       // Longitude\n  float y = asin(p.z/length(p)); // Latitude\n  y = log(tan(0.25*PI+0.5*y));   // Mercator\n  vec2 uv = vec2(x,y);\n  uv /= PI;\n  return indexed(uv);\n}\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // normal\n};\n\nstruct Sphere {\n  float r;      // radius\n  vec3 p;       // centre\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit) {\n  vec3 p = s.p;\n  float r = s.r;\n  float c = length(p);\n  vec3 q = ray.q, d = ray.d;\n  // |q + t*d - p|^2 = r^2\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+(c+r)*(c-r);\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return false;\n  // Normal is the radial vector of sphere\n  hit = Hit(t, (q+t*d-p)/r);\n  return true;\n}\n\nbool intersectScene(Ray r, out Hit hit) {\n  Sphere s = Sphere(1.0, vec3(0));\n  if (intersectSphere(s,r,hit)) {\n    return true;\n  }\n  return false;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec3 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec3(0);\n  } else {\n    vec3 n = hit.n;\n    if (dot(r.d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = getColor(hit.n);\n    vec3 color = baseColor.xyz*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),10.0);\n    color += 0.5*specular;\n    //color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return color;\n  }\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (true) {\n    p.yz = rotate(p.yz,iTime * 0.1618);\n    p.zx = rotate(p.zx,iTime * 0.1);\n  }\n  return p.xzy;\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n#define float3 vec3\nfloat3 ACESFilm(float3 x) {\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    x = x*(a*x+b)/(x*(c*x+d)+e);\n    return x;\n}\n\nvec3 postprocess(vec3 col, vec2 q) {\n  // Some experimental tone mapping.\n  col = ACESFilm(col);\n  //color = 2.0*color/(1.0+color);\n  col *= 0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  col = clamp(col,0.0,1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  return col;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/index.htm\nvec3 postprocess0(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/vec3(2.2));\n  //col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  //col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.5,1.0,-1.0));\n  light = transform(light);\n  vec3 p = vec3(0,0,-2.5);\n  p = transform(p);\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,2);\n      r = transform(r);\n      r = normalize(r); // Normalize after transform\n      col += solve(Ray(p,r));\n    }\n  }\n  col /= AA*AA;\n  vec2 q = fragCoord.xy/iResolution.xy;\n  col = postprocess(col,q);\n  fragColor = vec4(col,1);\n  if (check) fragColor = vec4(1,0,0,1);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.14159;\nbool check = false;\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 320, 320, 909], [911, 911, 934, 934, 1129], [1373, 1373, 1427, 1427, 1912], [1914, 1914, 1955, 1955, 2063], [2108, 2108, 2127, 2127, 2539], [2541, 2541, 2568, 2568, 2900], [3001, 3001, 3028, 3028, 3182], [3184, 3184, 3220, 3257, 3452], [3454, 3537, 3574, 3574, 3811], [3813, 3813, 3870, 3870, 4518]]}
{"id": "sdKcWt", "name": "Icosahedron Edge Distance", "author": "gehtsiegarnixan", "description": "An algorithm that gives you the distance to the nearest edge of an Icosahedron", "tags": ["3d", "mouse", "triangle", "hexagon", "distance", "icosahedron"], "likes": 0, "viewed": 195, "published": 3, "date": "1655911236", "time_retrieved": "2024-07-30T16:43:36.517433", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI created an algorithm, that gives you the distance to the nearest edge of an\nIcosahedron.\n\nIt has mouse controls to rotated around the center.\n\nI made this because I wanted to make a 3D tiling pattern, but I only skim\nread the Wikipedia article and chose the wrong shape. This shape cannot be \nseamlessly tiled. Lol\n*/\n\n#define pi              3.1415926536\n#define inv_sqrt3\t0.5773502693 // 1/sqrt(3)\n#define nGRa \t\t0.3568220898 // normalized Golden Ration\n#define nGRc \t\t0.9341723590 // normalized 2 Golden Ration + 1\n\nconst vec3 hrA = vec3(inv_sqrt3); //vector to Icosahedron Edge A\nconst vec3 hrB = vec3(0., nGRc, nGRa); //vector to Icosahedron Edge B\nconst vec3 hrC = vec3(nGRa, 0., nGRc); //vector to Icosahedron Edge C\nconst vec3 hrD = vec3(nGRc, nGRa, 0.); //vector to Icosahedron Edge D\n\n//Icosahedron Distance from Center\nfloat IcoDist(vec3 p) {\n    p = abs(p);\n    float pAB = max(dot(p, hrA),dot(p, hrB));\n    float pCD = max(dot(p, hrC),dot(p, hrD));\n    float dist = max(pAB,pCD);\n    \n    // optional makes it 0-1 inside, and negative outside\n    return (.5-dist)*2.; \n}\n\n// makes Cool colormap with polynimal 6\nvec3 Cool(float t) {\n    const vec3 c0 = vec3(-0.000941,1.000941,1.000000);\n    const vec3 c1 = vec3(1.001170,-1.001170,-0.000000);\n    const vec3 c2 = vec3(0.004744,-0.004748,0.000001);\n    const vec3 c3 = vec3(-0.011841,0.011841,-0.000005);\n    const vec3 c4 = vec3(0.012964,-0.012943,0.000009);\n    const vec3 c5 = vec3(-0.005110,0.005073,-0.000008);\n    const vec3 c6 = vec3(-0.000046,0.000064,0.000003);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y; //centered square UVs\n    float time = fract(0.2*iTime-0.5)-0.5; // used as z dimension    \n    float size = 0.9; //size of Ico\n    \n    vec3 point = vec3(uv, time)/size; //animated uv cords    \n    \n    // controls rotates around the center\n    vec3 camRot = vec3(0.5 - iMouse.yx / iResolution.yx, 0) * 2.0 * pi;\n    camRot.y = -camRot.y;\n    point = rotate(point, camRot);\n    \n    float ico = IcoDist(point); \n    \n    ico = clamp(ico, 0.,1.); //saturate so the cmap doesn't break\n    vec3 col = Cool(ico); // applying cosmetic colormap\n    \n    fragColor = vec4(col,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKcWt.jpg", "access": "api", "license": "mit", "functions": [[1880, 1915, 1938, 1938, 2168], [2170, 2210, 2230, 2230, 2675], [2677, 2752, 2781, 2918, 3339], [3341, 3341, 3398, 3398, 4035]]}
{"id": "fscBRr", "name": "Colored Blocks", "author": "deni_de", "description": "pseudo random colored blocks animation", "tags": ["ceil"], "likes": 3, "viewed": 296, "published": 3, "date": "1655886167", "time_retrieved": "2024-07-30T16:43:37.661375", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord = ceil( 14. * fragCoord / iResolution.y );\n    fragColor = 0.5 + 0.5 * cos( iTime + fragCoord.xyxy * fragCoord.x * fragCoord.y + vec4(1,2,4,1) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 219]]}
{"id": "fs3fzn", "name": "Reading Room", "author": "dr2", "description": "A dodecagonal library", "tags": ["symmetry", "library", "book", "building"], "likes": 17, "viewed": 337, "published": 3, "date": "1655882533", "time_retrieved": "2024-07-30T16:43:38.609839", "image_code": "// \"Reading Room\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// A dodecagonal library\n\n// (Book titles hidden because of #cancelliterature)\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nvec2 Hashv2v2 (vec2 p);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, ltPos, qHit;\nvec2 xzBk, csRf;\nfloat tCur, dstFar, rOcc, rDom, rEx, hDom, hWal, nSecW, nSecD, aHitW, aHitD, bWid,\n   rfAng, rfEx, tnSecW, refSphHt, refSphRad;\nint idObj;\nbool isSh, extVu;\nconst int idDom = 1, idWsup = 2, idRf = 3, idWal = 4, idEntr = 5, idLtop = 6, idLsup = 7,\n   idLmp = 8, idPil = 9, idTab = 10, idChr = 11, idLeg = 12, idBcaseH = 13, idBcaseL = 14,\n   idBk = 15, idCen = 16, idPlat = 17, idRail = 18, idDor = 19, idFlr = 20, idSphr = 21;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qqW, qqD;\n  float dMin, d, a, r, dOcc, dBk, ddz, hd;\n  dMin = dstFar;\n  a = atan (p.z, - p.x) / (2. * pi);\n  aHitW = (floor (nSecW * a) + 0.5) / nSecW;\n  aHitD = (floor (nSecD * a) + 0.5) / nSecD;\n  hd = 2. * hWal + 2. * rfEx + hDom + rDom;\n  r = length (p.xz);\n  dOcc = rOcc - r;\n  qqW = vec3 (Rot2D (p.xz, 2. * pi * aHitW), p.y).xzy;\n  qqD = vec3 (Rot2D (p.xz, 2. * pi * aHitD), p.y).xzy;\n  ddz = 1. - abs (qqD.z);\n  q = qqW;\n  q.xy -= vec2 (- rOcc, 2. * hWal + 2. * rfEx);\n  d = max (max (abs (length (vec2 (q.x, max (q.y - hDom, 0.))) - rDom) - 0.05, dOcc), - q.y);\n  d = max (d, - PrBox2Df (vec2 (abs (q.z) - 0.5, q.y - 1.5), vec2 (0.25, 0.8)));\n  DMINQ (idDom);\n  q = qqD;\n  q.xy -= vec2 (-0.5 * rOcc, hd);\n  d = PrCylDf (q.yzx, 0.05, 0.5 * rOcc);\n  DMINQ (idLtop);\n  q = qqW;\n  q.xy = Rot2Cs (q.xy - vec2 (- rDom - rEx - rOcc, 2. * hWal + 0.05), csRf) - vec2 (0.1, rfEx);\n  d = PrBox2Df (q.xy, vec2 (rEx + 0.3, 0.06));\n  q.x = qqW.x;\n  DMINQ (idRf);\n  q = qqW;\n  q.xy -= vec2 (- rDom - 2. * rEx - rOcc + 0.05, hWal + 0.05);\n  d = PrBox2Df (q.xy, vec2 (0.05, hWal + 0.05));\n  d = SmoothMax (d, - PrBox2Df (vec2 (fract (0.8 * q.z + 0.5) - 0.5, q.y - 1.75),\n     vec2 (0.25, 0.25)), 0.02);\n  q = qqD;\n  q.y -= hWal - 1.3;\n  d = max (d, - PrBox2Df (q.yz, vec2 (1.25, 0.7)));\n  DMINQ (idWal);\n  q.x -= - rDom - 2. * rEx - 1.2;\n  d = max (PrBoxDf (q, vec3 (0.7, 1.35, 0.8)), - PrBox2Df (q.yz, vec2 (1.25, 0.7)));\n  DMINQ (idEntr);\n  q.y -= 0.05;\n  d = max (PrBoxDf (q, vec3 (0.04, 1.25, 0.7)), - PrBox2Df (abs (q.yz) - vec2 (0.52, 0.3),\n     vec2 (0.47, 0.25)));\n  DMINQ (idDor);\n  q = qqW;\n  q.xz = Rot2D (vec2 (q.x, abs (q.z)) - vec2 (- rOcc, rOcc * tnSecW), pi / nSecW);\n  q.y -= 2. * hWal + 2. * rfEx;\n  d = max (max (PrRoundBox2Df (vec2 (length (vec2 (q.x + 0.1, max (q.y - hDom, 0.))) -\n     rDom, q.z), vec2 (0.1, 0.08), 0.02), dOcc), - q.y);\n  DMINQ (idWsup);\n  q.xy -= vec2 (- rDom - 0.05, - hWal - rfEx);\n  d = min (PrCylDf (q.xzy, 0.1, hWal + rfEx), PrCylDf (vec3 (q.xz, abs (q.y) - hWal -\n     rfEx + 0.04), 0.12, 0.04));\n  DMINQ (idPil);\n  q.xy -= vec2 (-2. * rEx - 0.25, - rfEx);\n  d = PrRoundBoxDf (q, vec3 (0.13, hWal + 0.05, 0.1), 0.02);\n  DMINQ (idWsup);\n  q = p;\n  q.y -= hd;\n  d = PrCylDf (q.xzy, 0.5 * rOcc, 0.05);\n  DMINQ (idLtop);\n  q.y -= -0.5 * rDom;\n  d = PrCylDf (q.xzy, 0.1 * rOcc, 0.5 * rDom + 0.05);\n  q = qqW;\n  q.xy -= vec2 (- rOcc, hd - rDom);\n  d = min (d, PrCylDf (q.yzx, 0.02, rOcc));\n  DMINQ (idLsup);\n  q = qqW;\n  q.xy -= vec2 (-2. * rOcc, hd - rDom);\n  d = PrSphDf (q, 0.1);\n  DMINQ (idLmp);\n  q = qqW;\n  q.xy -= vec2 (- rDom - rEx, 2. * hWal + rfEx - 0.2);\n  d = PrCylDf (q.xzy, 0.03, 0.25);\n  DMINQ (idLsup);\n  q.y -= -0.3;\n  d = PrSphDf (q, 0.15);\n  DMINQ (idLmp);\n  q = qqW;\n  q.x = abs (q.x + rDom + rEx + 0.4);\n  q.xy -= vec2 (1.3, 0.9);\n  d = PrRoundBoxDf (q, vec3 (1., 0.03, 0.5), 0.01);\n  DMINQ (idTab);\n  d = PrCylDf ((q - vec3 (0., 0.25, 0.)).xzy, 0.015, 0.2);\n  DMINQ (idLsup);\n  d = PrSphDf (q - vec3 (0., 0.5, 0.), 0.07);\n  DMINQ (idLmp);\n  q.xz = abs (q.xz);\n  q -= vec3 (0.9, -0.45, 0.4);\n  d = PrCylDf (q.xzy, 0.05, 0.45);\n  DMINQ (idLeg);\n  q = qqW;\n  q.x = abs (q.x + rDom + rEx + 0.4);\n  q.xy -= vec2 (1.3, 0.5);\n  q.xz = abs (q.xz) - vec2 (0.5, 0.7);\n  d = PrRoundBoxDf (q, vec3 (0.3, 0.03, 0.25), 0.01);\n  DMINQ (idChr);\n  q.xz = abs (q.xz);\n  q -= vec3 (0.2, -0.25, 0.15);\n  d = PrCylDf (q.xzy, 0.03, 0.25);\n  DMINQ (idLeg);\n  q = qqW;\n  q.z = 2.1 * fract (q.z / 2.1 + 0.5);\n  xzBk.y = floor ((qqW.z + 1.05) / 2.1);\n  q -= vec3 (- rDom - 2. * rEx - 0.2, 1.7, 1.05);\n  d = PrRoundBoxDf (q, vec3 (0.2, 1.7, 0.9), 0.01);\n  dBk = d;\n  q.y -= -0.15;\n  d = max (d, - max (PrBox2Df (vec2 (0.4 * (fract (q.y / 0.4 + 0.5) - 0.5), q.z),\n     vec2 (0.18, 17. * bWid)), abs (q.y - 0.2) - 1.6));\n  d = max (d, ddz);\n  DMINQ (idBcaseH);\n  d = max (q.x - 0.17, max (dBk, ddz));\n  DMINQ (idBk);\n  q = qqW;\n  q.xy -= vec2 (- rDom - 0.5, 0.66);\n  xzBk.x = sign (q.x);\n  q.x = abs (q.x) - 0.7;\n  d = PrRoundBoxDf (q, vec3 (0.22, 0.66, 0.42), 0.01);\n  dBk = d;\n  q.y -= 0.05;\n  d = max (d, - max (PrBox2Df (vec2 (0.4 * (fract (q.y / 0.4 + 0.5) - 0.5), q.z),\n     vec2 (0.18, 8. * bWid)), abs (q.y) - 0.6));\n  d = max (d, ddz);\n  DMINQ (idBcaseL);\n  d = max (abs (q.x) - 0.17, max (dBk, ddz));\n  DMINQ (idBk);\n  q = p;\n  d = PrRoundBox2Df (vec2 (r - (rDom - 1.7), q.y - 0.5), vec2 (0.15, 0.5) - 0.02, 0.01);\n  d = SmoothMax (d, ddz - 0.5, 0.02);\n  DMINQ (idCen);\n  q = p;\n  d = length (vec2 (r - (rDom - 1.7), q.y - 0.98)) - 0.03;\n  d = SmoothMax (d, ddz - 0.45, 0.02);\n  DMINQ (idRail);\n  q = p;\n  d = max (r - (rDom - 1.6), abs (q.y - 0.05) - 0.05);\n  DMINQ (idPlat);\n  q = qqW;\n  d = max (r - (2. * rEx + rDom + 2.), q.y - 0.02);\n  DMINQ (idFlr);\n  if (isSh) {\n    q = p;\n    q.y -= refSphHt;\n    d = PrSphDf (q, refSphRad);\n    DMINQ (idSphr);\n  }\n  q = p;\n  q.y -= 0.5 * (hd - 0.8 * rDom + refSphHt);\n  d = PrCylDf (q.xzy, 0.02, 0.5 * (hd - 0.8 * rDom - refSphHt));\n  DMINQ (idLsup);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  float sh, d, h;\n  isSh = true;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = SmoothMin (sh, smoothstep (0., 0.015 * d, h), 0.1);\n    d += h;\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  isSh = false;\n  return 0.8 + 0.2 * sh;\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.02, 0.03, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.07 * pi * smoothstep (0.4, 0.47, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nfloat FloorAO (vec3 ro)\n{\n  vec3 q;\n  float d, ddz;\n  ddz = abs (Rot2D (ro.xz, 2. * pi * (floor (nSecD * atan (ro.z, - ro.x) / \n     (2. * pi)) + 0.5) / nSecD).y);\n  q = qHit;\n  q.xz = Rot2D (vec2 (q.x, abs (q.z)) - vec2 (- rOcc, rOcc * tnSecW), pi / nSecW);\n  q.x -= - rDom - 0.05;\n  d = length (q.xz) - 0.12;\n  q = qHit;\n  q.x = abs (q.x + rDom + rEx + 0.4) - 1.3;\n  q.xz = abs (q.xz) - vec2 (0.9, 0.4);\n  d = min (d, length (q.xz) - 0.05);\n  q = qHit;\n  q.x = abs (q.x + rDom + rEx + 0.4) - 1.3;\n  q.xz = abs (abs (q.xz) - vec2 (0.5, 0.7)) - vec2 (0.2, 0.15);\n  d = min (d, length (q.xz) - 0.03);\n  q = qHit;\n  q.x = abs (q.x + rDom + 0.5) - 0.7;\n  if (ddz > 1.) d = min (d, PrRoundBox2Df (q.xz, vec2 (0.22, 0.42), 0.01));\n  q = qHit;\n  q.z = 2.1 * fract (q.z / 2.1 + 0.5);\n  q.xz -= vec2 (- rDom - 2. * rEx - 0.2, 1.05);\n  if (ddz > 1.) d = min (d, PrRoundBox2Df (q.xz, vec2 (0.22, 0.9), 0.01));\n  if (ddz > 0.45) d = min (d, abs (length (ro.xz) - (rDom - 1.7)) - 0.14);\n  d = min (d, length (ro.xz) - (rDom - 1.6));\n  return 0.8 + 0.2 * smoothstep (0., 0.03, d);\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, inout vec3 vn, out vec2 vf)\n{\n  vec4 col4;\n  vec3 rg;\n  vec2 q, s, b;\n  float r, a, h;\n  r = length (ro.xz);\n  a = atan (ro.z, - ro.x);\n  q = vec2 (0.);\n  vf = vec2 (0.);\n  if (idObj <= idEntr) {\n    if (idObj == idDom) {\n      col4 = (length (vec2 (qHit.x, max (qHit.y - hDom, 0.))) > rDom) ?\n         vec4 (1., 0.8, 0., 0.3) : vec4 (0.8, 0.6, 0.4, 0.2);\n      vf = vec2 (64., 0.2);\n    } else if (idObj == idWsup) {\n      col4 = vec4 (0.8, 0.5, 0.4, 0.2);\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idRf) {\n      col4 = (qHit.y > 0.) ? vec4 (1., 0.4, 0.3, 0.2) : vec4 (0.7, 0.3, 0., 0.);\n      col4 *= 0.8 + 0.2 * smoothstep (0., 0.02, min (abs (dot (vec2 (abs (qHit.z), qHit.x),\n         sin (pi / nSecW + vec2 (0.5 * pi, 0.)))), abs (fract (((qHit.y > 0.) ? 1. : 4.) *\n         qHit.x + 0.5) - 0.5)));\n      vf = vec2 (64., 0.2);\n    } else if (idObj == idWal) {\n      col4 = vec4 (0.8, 0.6, 0.4, 0.2);\n      rg = ShGrid (qHit.zy, vec2 (3., 4.), 1);\n      col4 *= rg.y;\n      vn.xz = Rot2D (vn.xz, 2. * pi * aHitW);\n      rg.xz *= sign (vn.x);\n      if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n      else vn.xz = Rot2D (vn.xz, rg.x);\n      vn.xz = Rot2D (vn.xz, -2. * pi * aHitW);\n      vf = vec2 (64., 1.);\n    } else if (idObj == idEntr) {\n      if (abs (vn.y) > 0.9) {\n        col4 = (qHit.y < 0.) ? vec4 (0.5, 0.6, 0.5, 0.2) : vec4 (1., 0.4, 0.3, 0.2);\n      } else {\n        col4 = vec4 (0.8, 0.6, 0.4, 0.2);\n        if (- qHit.x < 0.69) {\n          rg = ShGrid (qHit.xy, vec2 (3., 4.), 1);\n          col4 *= rg.y;\n          vn.xz = Rot2D (vn.xz, 2. * pi * aHitD);\n          rg.xz *= sign (vn.z);\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n          vn.xz = Rot2D (vn.xz, -2. * pi * aHitD);\n        }\n      }\n      vf = vec2 (64., 1.);\n    }\n  } else if (idObj <= idTab) {\n    if (idObj == idLtop) {\n      col4 = vec4 (1., 0.8, 0., 0.3);\n    } else if (idObj == idLsup) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n    } else if (idObj == idLmp) {\n      col4 = vec4 (1., 1., 0.9, -1.);\n    } else if (idObj == idPil) {\n      col4 = vec4 (1., 0.2, 0.2, 0.2);\n      vf = vec2 (128., 0.5);\n    } else if (idObj == idTab) {\n      col4 = vec4 (0.8, 0.4, 0.2, 0.2);\n      if (PrBox2Df (qHit.xz, vec2 (1., 0.5)) < 0.) q = qHit.zx;\n    }\n  } else if (idObj <= idBk) {\n    if (idObj == idChr) {\n      col4 = vec4 (0.5, 0.3, 0.2, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.01,\n         abs (abs (qHit.x) - 0.25)));\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idLeg) {\n      col4 = vec4 (0.5, 0.5, 0.5, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.02,\n         abs (fract (16. * qHit.y + 0.5) - 0.5) - 0.05));\n      vf = vec2 (64., 0.2);\n    } else if (idObj == idBcaseH) {\n      col4 = vec4 (0.9, 0.4, 0.2, 0.2);\n      if (qHit.y > 1.7) q = qHit.xz;\n      else if (abs (qHit.z) > 0.9) q = qHit.xy;\n      else q = qHit.yz;\n    } else if (idObj == idBcaseL) {\n      col4 = vec4 (0.9, 0.4, 0.2, 0.2);\n      if (qHit.y > 0.61) q = qHit.xz;\n      else if (abs (qHit.z) > 0.4) q = qHit.xy;\n      else q = qHit.yz;\n    } else if (idObj == idBk) {\n      b = vec2 ((qHit.y + 0.2) / 0.4, qHit.z / bWid);\n      s = Hashv2v2 (floor (b.yx) + ((r > rDom + 2. * rEx - 1.) ? nSecW * aHitW + 1.3 * xzBk.y :\n         nSecD * aHitD + 1.3 * xzBk.x));\n      b = fract (b);\n      b.x *= 0.4;\n      b.y -= 0.5;\n      h = 0.32 + 0.06 * s.x - b.x;\n      if (h > 0.) {\n        col4 = vec4 (HsvToRgb (vec3 (s.y, 0.8, 1.)), 0.2) * (1.2 - 0.2 * smoothstep (0., 0.02, h)) *\n           (0.5 + 0.5 * smoothstep (0., 0.04, b.x - 0.002 - 0.03 * b.y * b.y));\n        col4 = mix (vec4 (0.8, 0.8, 0.3, 0.), col4, smoothstep (0., 0.01, min (abs (b.x -\n           0.02 * s.x - 0.07) - 0.012, PrBox2Df (vec2 (b.x - 0.02 * s.x - 0.2, b.y),\n           vec2 (0.07, 0.2)))));\n        vn.xz = Rot2D (vn.xz, 0.35 * pi * b.y);\n        vf = vec2 (64., 0.2);\n      } else col4 = vec4 (0.2, 0.2, 0.2, 0.);\n    }\n  } else if (idObj <= idFlr) {\n    if (idObj == idCen) {\n      col4 = vec4 (0.9, 0.4, 0.2, 0.2);\n      if (ro.y > 0.98) q = vec2 (r, a);\n      else q = vec2 (0.5 * ro.y, a);\n    } else if (idObj == idPlat) {\n      col4 = vec4 (0.6, 0.3, 0.1, 0.2) * (0.8 + 0.2 * smoothstep (0., 0.01,\n         abs (fract (4. * r + 0.5) - 0.5) - 0.02));\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.9, 0.7, 0.2, 0.3);\n    } else if (idObj == idDor) {\n      col4 = vec4 (0.8, 0.4, 0.2, 0.2);\n      q = qHit.zy;\n    } else if (idObj == idFlr) {\n      b = Rot2D (ro.xz, 2. * pi * aHitD);\n      if (- qHit.x < 2. * rEx + rDom + rOcc + 0.05 || - b.x < rDom + 2. * rEx + 1.9 &&\n         abs (b.y) < 0.7) {\n        col4 = vec4 (0.5, 0.6, 0.5, 0.2) * (0.85 + 0.15 * smoothstep (0., 0.01,\n           min (abs (dot (vec2 (abs (qHit.z), qHit.x), sin (pi / nSecW + vec2 (0.5 * pi, 0.)))),\n           abs (fract (qHit.x + 0.5) - 0.5))));\n        q = qHit.xz;\n        col4.rgb *= FloorAO (ro);\n      } else col4 = vec4 (0.5, 0.5, 0.5, 0.1);\n    }\n  }\n  if (q != vec2 (0.)) col4 *= 0.6 + 0.4 * Fbm2 (vec2 (12., 3.) * q);\n  return col4;\n}\n\nvec3 GrndNf (vec2 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return vec3 (normalize (vec3 (Fbm2 (p) - vec2 (Fbm2 (p + e.xy),\n     Fbm2 (p + e.yx)), 4. * e.x)).xzy);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.02 * (0.1 + 0.9 * IFbm1 (32. * atan (rd.x, rd.z) / pi))) {\n    col = 0.8 * vec3 (0.35, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 5. * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = mix (vec3 (0.3, 0.4, 0.8), clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w, dMin;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      dMin = d;\n      vn = (ro + d * rd) / rad;\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, ds4;\n  vec3 col, vn, ltDir;\n  vec2 vf;\n  float dstObj, dstSph, ltDist, sh;\n  rOcc = 0.5;\n  rDom = 4.;\n  rEx = 4.;\n  hDom = 2.;\n  hWal = 2.5;\n  nSecW = 12.;\n  nSecD = 4.;\n  tnSecW = tan (pi / nSecW);\n  bWid = 0.05;\n  rfAng = 0.05 * pi;\n  csRf = sin (- rfAng + vec2 (0.5 * pi, 0.));\n  rfEx = - (rEx + 0.2) * csRf.y / csRf.x;\n  refSphRad = 0.4;\n  refSphHt = 4. - cos (0.03 * pi * tCur);\n  isSh = false;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (k == 0) {\n      ds4 = SphHit (ro - vec3 (0., refSphHt, 0.), rd, refSphRad);\n      dstSph = ds4.x;\n      if (dstSph < min (dstObj, dstFar)) {\n        ro += dstSph * rd;\n        rd = reflect (rd, ds4.yzw);\n        ro += 0.01 * rd;\n      } else break;\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol (ro, rd, vn, vf);\n    if (! extVu) {\n      ltDist = length (ltPos - ro);\n      ltDir = normalize (ltPos - ro);\n    } else {\n      ltDir = sunDir;\n      ltDist = dstFar;\n    }\n    sh = (idObj != idBk) ? ObjSShadow (ro + 0.01 * vn, ltDir, ltDist) : 1.;\n    if (vf.y != 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    else col = col4.rgb * (0.5 + 0.5 * max (- dot (rd, vn), 0.));\n  } else if (rd.y < 0.) {\n    ro += (- ro.y / rd.y) * rd;\n    vn = GrndNf (0.5 * ro.xz);\n    col = (0.4 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz)))) * (0.2 + 0.8 * max (dot (vn, sunDir), 0.));\n    col = mix (col, 0.8 * vec3 (0.35, 0.4, 0.5), pow (1. + rd.y, 16.));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, mMid[2], ut[2], mSize, msw;\n  float el, az, zmFac, asp, sr;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (asp, -1.);\n  mMid[1] = (1. - mSize.y) * vec2 (- asp, -1.);\n  for (int k = 0; k < 2; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < 2; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  az = 0.;\n  if (vuId == 0) el = -0.02 * pi;\n  else if (vuId == 1) el = -0.07 * pi;\n  else if (vuId == 2) el = 0.;\n  if (mPtr.z > 0. && vuId == regId) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  if (vuId == 0) {\n    el = clamp (el, -0.3 * pi, 0.3 * pi);\n  } else if (vuId == 1) {\n    az = clamp (mod (az + pi, 2. * pi) - pi, -0.8 * pi, 0.8 * pi);\n    el = clamp (el, -0.3 * pi, -0.02 * pi);\n  } else if (vuId == 2) {\n    el = 0.;\n  }\n  vuMat = StdVuMat (el, az);\n  extVu = false;\n  if (vuId == 0) {\n    ro = vec3 (1., 2. , -6.);\n    zmFac = 3.;\n  } else if (vuId == 1) {\n    ro = vuMat * vec3 (0., 3., -50.);\n    zmFac = 4.;\n    extVu = true;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 2. , -6.);\n    zmFac = 0.3;\n  }\n  ltPos = ro + vec3 (2., 2., -4.);\n  dstFar = 150.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n  if (extVu) sunDir = vuMat * sunDir;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize ((vuId == 2) ? vec3 (2. * sin (uvv.x / asp + vec2 (0., 0.5 * pi)), uvv.y).xzy : \n       vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.3, 0.3, 0.7);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat IFbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 10.;\n  for (int j = 0; j < 3; j ++) {\n    f += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / (1.75 * a));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3fzn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1471, 1471, 1493, 1493, 6451], [6453, 6453, 6486, 6486, 6734], [6736, 6736, 6757, 6757, 7014], [7016, 7016, 7067, 7067, 7353], [7355, 7355, 7395, 7395, 7769], [7771, 7771, 7796, 7796, 8840], [8842, 8842, 8902, 8902, 13907], [13909, 13909, 13931, 13931, 14072], [14074, 14074, 14108, 14108, 14722], [14724, 14724, 14767, 14767, 15022], [15024, 15024, 15059, 15059, 16848], [16850, 16850, 16906, 16906, 19573], [19575, 19575, 19607, 19607, 19707], [19709, 19709, 19755, 19755, 19802], [19804, 19804, 19837, 19837, 19926], [19928, 19928, 19975, 19975, 20022], [20024, 20024, 20057, 20057, 20084], [20086, 20086, 20128, 20128, 20179], [20181, 20181, 20203, 20203, 20230], [20232, 20232, 20254, 20254, 20281], [20283, 20283, 20328, 20328, 20420], [20422, 20422, 20467, 20467, 20505], [20507, 20507, 20543, 20543, 20749], [20751, 20751, 20781, 20781, 20894], [20896, 20896, 20927, 20927, 20991], [20993, 20993, 21017, 21017, 21139], [21173, 21173, 21197, 21197, 21250], [21252, 21252, 21276, 21276, 21388], [21390, 21390, 21415, 21415, 21561], [21563, 21563, 21588, 21588, 21774], [21776, 21776, 21799, 21799, 21966], [21968, 21968, 21989, 21989, 22144], [22146, 22146, 22175, 22175, 22387], [22389, 22389, 22428, 22428, 22685]]}
{"id": "fsKyDc", "name": "流汗黄豆", "author": "ADogFish", "description": "cha bu duo de le", "tags": ["emoji"], "likes": 4, "viewed": 235, "published": 3, "date": "1655865347", "time_retrieved": "2024-07-30T16:43:39.389753", "image_code": "const vec3 faceColor = vec3(1.,0.7843,0.2392);\nconst vec3 black = vec3(0.);\nconst vec3 white = vec3(1.);\nconst vec3 lightBlue = vec3(0.517, 0.705, 0.905);\nconst vec3 darkBlue = vec3(0.368, 0.427, 0.850);\nconst vec3 tongueColor = vec3(0.941, 0.227, 0.090);\nconst vec3 sweatColor = vec3(0, 0.737, 0.949);\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nfloat cro(in vec2 a, in vec2 b )\n{\n    return a.x*b.y - a.y*b.x; \n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nfloat sdCircle(vec2 p, float r, vec2 offset, float smSize) \n{\n    return 1. - smoothstep(r - smSize, r, distance(p, offset));\n}\n\nfloat sdRectangle(vec2 p, vec2 offset, vec2 size, float smSize)\n{\n    vec2 lb = offset - size * .5;\n    vec2 rt = offset + size * .5;\n    vec2 lbRes = smoothstep(lb, lb + smSize, p);\n    vec2 rtRes = 1. - smoothstep(rt - smSize, rt, p);\n    return lbRes.x * lbRes.y * rtRes.x * rtRes.y;\n}\n\n// r1 > r2\nfloat sdRim(vec2 p, float r1, float r2, vec2 offset, float smSize)\n{\n    float d = distance(p, offset);\n    float d1 = 1. - smoothstep(r1 - smSize, r1, d);\n    float d2 = smoothstep(r2 - smSize, r2, d);\n\n    return min(d1, d2);\n}\n\nvec4 face(vec2 p) \n{\n    float outline = sdCircle(p, 0.65, vec2(.0), .005);\n    float inside = sdCircle(p, 0.625, vec2(.0), .005);\n    \n    vec3 col = faceColor * inside;\n\treturn vec4(col, saturate(outline));\n}\n\nvec4 eye(vec2 p)\n{\n    float rim1 = sdRim(p + vec2(0.265, .02), 0.20, 0.15, vec2(.0, 0.03), .005);\n    float rim2 = sdRim(p + vec2(-0.265, .02), 0.20, 0.15, vec2(.0, 0.03), .005);\n\n    float cut = sdRectangle(p, vec2(.0, -0.35), vec2(0.95, 0.75), .005);\n    \n\treturn vec4(black, saturate(max(rim1, rim2) - cut));\n}\n\nvec4 mouth(vec2 p)\n{\n    float outline1 = sdCircle(p, 0.42, vec2(.0, 0.05), .005);\n    float cut = sdRectangle(p, vec2(.0, 0.41), vec2(0.90, 0.75), .005);\n    float tooth = sdRectangle(p, vec2(.0, -0.05), vec2(0.75, 0.1), .005);\n    float tongue = sdCircle(p, 0.18, vec2(0.0, -0.4), .0001);\n    float outline2 = sdRim(p, 0.43, 0.38, vec2(.0, 0.05), .005);\n\n    vec3 col = mix(black, tongueColor, tongue);\n    col = mix(col, white, tooth);\n    col = mix(col, black, outline2);\n\n\treturn vec4(col, saturate(outline1  - cut));\n}\n\nvec4 sweat(vec2 p)\n{\n    vec2 v1 = cos(vec2(0.0, 2.0));\n\tvec2 v2 = cos(vec2(0.0, 1.0));\n    float r1 = 0.5;\n    float r2 = 0.01;\n    \n\tfloat d = sdUnevenCapsule(p * 3., v1, v2, r1, r2 );\n    d = 1. - smoothstep(0.01, 0.02, saturate(d));\n    \n\treturn vec4(sweatColor, d);\n}\n\nvec3 background(vec2 p) \n{\n    float x = sin(7. * (p.x + iTime));\n    float y = cos(7. * (p.y + iTime));\n    float r = length(p);\n    \n    return mix(lightBlue, darkBlue, smoothstep(0.5, 0.7, acos(r * x * y)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n\t// coloring\n    vec4 Face = face(p);\n    vec4 Eye = eye(p);\n    vec4 Mouth = mouth(p + vec2(.0, 0.15));\n    vec4 Sweat = sweat(p + vec2(-0.15, -0.5));\n    \n    vec3 col = background(p);\n    col.rgb = mix(col, Face.rgb, Face.a);    \n    col.rgb = mix(col, Eye.rgb, Eye.a);  \n    col.rgb = mix(col, Mouth.rgb, Mouth.a);\n    col.rgb = mix(col, Sweat.rgb, Sweat.a);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 329, 329, 360], [362, 362, 396, 396, 429], [431, 483, 569, 569, 1056], [1058, 1058, 1119, 1119, 1185], [1187, 1187, 1252, 1252, 1475], [1477, 1488, 1556, 1556, 1717], [1719, 1719, 1739, 1739, 1929], [1931, 1931, 1949, 1949, 2245], [2247, 2247, 2267, 2267, 2771], [2773, 2773, 2793, 2793, 3045], [3047, 3047, 3073, 3073, 3259], [3262, 3262, 3319, 3369, 3860]]}
{"id": "ssKcDt", "name": "tauris building", "author": "jorge2017a2", "description": "tauris building", "tags": ["taurisbuilding"], "likes": 9, "viewed": 257, "published": 3, "date": "1655864492", "time_retrieved": "2024-07-30T16:43:40.146729", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n//tauris building---21-jun-2022\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdTorus( vec3 p, vec2 t )\n\t{ vec2 q = vec2(length(p.xz)-t.x,p.y);  return length(q)-t.y; }\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0+3.0*sin(iTime);  //piso inf\n    res =opU2(res, vec2(planeDist1,104.0));\n    p.z= opRep1D(p.z,50.0 );\n    p.x=abs(p.x)-16.0;\n    float d1= sdBox(p, vec3(10.,10.0,50.0) );\n    p=p0;\n    //\n    p.x=abs(p.x)-18.0;\n    p-=vec3(-1.0,4.0,-10.0);\n    p.z= opRep1D(p0.z-25.0,50.0 );\n    \n    p.y= opRep1D(p.y,2.5 );\n    \n    float d2= sdBox(p, vec3(9.,1.0,10.0) );\n    p=p0;\n    p.x=abs(p.x)-18.0;\n    p.z= opRep1D(p0.z,20.0 );\n    p.y= opRep1D(p0.y,5.0 );\n    \n    float d3= sdTorus(p, vec2(7.0,2.5)  );\n    \n    res =opU2(res, vec2(d1,103.0));\n    res =opU2(res, vec2(d2,102.0));\n    res =opU2(res, vec2(d3,101.0));\n    p=p0;\n    p.z= opRep1D(p.z+20.0,30.0);\n    float d4a= sdTorus(p-vec3(0.0,5.0,0.0), vec2(12.0,2.5)  );\n    float d4b= sdBox(p, vec3(9.,1.0,10.0) );\n    res =opU2(res, vec2(d4a,100.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a,b,c,d;\n    a = vec3(0.2);b = vec3(0.5);c = vec3(1.0);d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    //diff = pow(diff, 0.75) * 4.0;   //antes\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n\n    \n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 ) { col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor)*vec3(0.0,0.5,1.0)*2.0; }\n\tif (i==102 ) { return tex3D(iChannel0, p/32., nor)*vec3(1.0,0.5,1.0)*2.0; ; }\n\tif (i==103 ) { return tex3D(iChannel0, p/32., nor)*vec3(1.0,0.75,0.0)*4.0; ; }\n    if (i==104 ) { \n      col=tex3D(iChannel0, p/32., nor)*vec3(1.0,0.75,0.0)*4.0; \n      col=vec3((col.x+col.y+col.z)/3.0);\n      return col;\n    }\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n   if (id_color>=100 ) { return  getColorTextura( p, nor,id_color); }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;        \n    }\n    else if(hit.x>MAX_DIST-10.0)\n    col= vec3(0.0);\n    \n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*10.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 )*(0.8-0.5*sin(t)); \n   vec3 ro=vec3(-5.0,30.0,-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   //float limite=18.0*sin(iTime);\n   float limite=mod(iTime,18.0);\n   \n   if(limite<3.0)\n       rd= rotate_x(rd,radians(25.));\n   if(limite>3.0 && limite<6.0)\n     {  ro.y+=10.0;  rd= rotate_x(rd,radians(65.)); }\n   if(limite>6.0 && limite<9.0)\n     { \n     vec3 ro=vec3(0.0,2.0+t,-25.0);\n     rd= rotate_x(rd,radians(-145.));}\n   if(limite>9.0 && limite<12.0)\n     {  \n         rd= rotate_y(rd,radians(180.));\n         rd= rotate_z(rd,radians(45.));\n     }\n    if(limite>12.0 && limite<15.0)\n     {  //rd= rotate_y(rd,radians(180.));\n         rd= rotate_x(rd,radians(270.));\n     } \n     \n     if(limite>15.0 && limite<18.0)\n     {  rd= rotate_y(rd,radians(180.));\n        rd= rotate_x(rd,radians(90.));\n     } \n     \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[494, 494, 530, 530, 551], [552, 552, 584, 584, 668], [669, 669, 703, 703, 765], [767, 767, 803, 803, 848], [850, 850, 884, 884, 980], [981, 981, 1015, 1015, 1106], [1107, 1107, 1141, 1141, 1232], [1233, 1233, 1267, 1267, 1358], [1360, 1360, 1385, 1385, 2270], [2272, 2272, 2296, 2296, 2458], [2460, 2460, 2508, 2508, 2787], [2790, 2790, 2834, 2834, 3155], [3157, 3157, 3194, 3194, 3451], [3453, 3453, 3476, 3476, 3614], [3616, 3616, 3706, 3706, 4717], [4719, 4719, 4768, 4768, 5236], [5239, 5239, 5309, 5309, 5397], [5399, 5399, 5426, 5426, 5515], [5517, 5517, 5575, 5575, 5623], [5625, 5625, 5648, 5648, 5760], [5762, 5762, 5793, 5793, 6420], [6422, 6422, 6479, 6479, 7653]]}
{"id": "7syyRc", "name": "3D Test Bench - Solid Shape", "author": "MasterEric", "description": "A raymarched 3D scene with well-annotated rendering functions, for easy adaptation and extension. Includes support for shading and anti-aliasing.", "tags": ["sdf", "shading"], "likes": 1, "viewed": 187, "published": 3, "date": "1655858162", "time_retrieved": "2024-07-30T16:43:42.900367", "image_code": "/**\n * A raymarched 3D scene with well-annotated rendering functions,\n * for easy adaptation and extension.\n * Includes support for shading and anti-aliasing.\n * @author MasterEric\n * \n * References:\n * - https://iquilezles.org/articles/distfunctions/\n * - http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n * - https://www.shadertoy.com/view/Wtl3zN\n * - http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n * - https://www.shadertoy.com/view/4tf3WH\n * - https://github.com/electricsquare/raymarching-workshop\n */\n\n// The number of subdivisions of the draw distance we check the raycast at.\n// Higher numbers produce a sharper image.\n#define ITERATIONS 100\n// The distance at which we are considered to be at an object.\n// Smaller numbers produce a sharper image.\n#define MIN_D 0.0001\n// The draw distance.\n// Larger numbers need more iterations to produce a sharp image.\n#define MAX_D 30.0\n\n#define SHADOW_SOFTNESS 10.0\n\n// 1 = sample 1 pixel, no anti-aliasing\n// 2 = sample 2x2 pixels for MSAA\n// 3 = sample 3x3 pixels for MSAA\n#define AA_SAMPLE 2\n\n#define GAMMA 0.4545\n\n// Random junk.\nprecision highp float;\n\n/**\n * UTILITY FUNCTIONS\n */\nfloat dot2(in vec3 v) {\n    return dot(v, v);\n}\n\n/**\n * TRANSFORM FUNCTIONS\n */\n\n// To apply rotation or translation to a mesh,\n// we simply apply a transformation to the point being sampled.\n// This function rotates a point about an arbitrary axis by the given angle.\nvec3 rotate(vec3 point, vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    mat4 rotMatrix = mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0, oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n\n    vec3 result = (rotMatrix * vec4(point, 1.0)).xyz;\n\n    return result;\n}\n\n// This function translates a point by a given vector.\nvec3 translate(vec3 point, vec3 transform) {\n    return point + transform;\n}\n\n// Combine two shapes into one.\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nvec2 opUnion( vec2 d1, vec2 d2 ) { return min(d1,d2); }\nvec3 opUnion( vec3 d1, vec3 d2 ) { return min(d1,d2); }\nvec4 opUnion( vec4 d1, vec4 d2 ) { return min(d1,d2); }\n\n// Subtract one shape from another shape.\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nvec2 opSubtraction( vec2 d1, vec2 d2 ) { return max(-d1,d2); }\nvec3 opSubtraction( vec3 d1, vec3 d2 ) { return max(-d1,d2); }\nvec4 opSubtraction( vec4 d1, vec4 d2 ) { return max(-d1,d2); }\n\n// Returns only the space where two shapes only overlap.\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nvec2 opIntersection( vec2 d1, vec2 d2 ) { return max(d1,d2); }\nvec3 opIntersection( vec3 d1, vec3 d2 ) { return max(d1,d2); }\nvec4 opIntersection( vec4 d1, vec4 d2 ) { return max(d1,d2); }\n\n// Returns the space where only one shape (not both) exist.\nfloat opXor( float d1, float d2 ) { return max(-min(d1, d2), max(d1, d2)); }\nvec2 opXor( vec2 d1, vec2 d2 ) { return max(-min(d1, d2), max(d1, d2)); }\nvec3 opXor( vec3 d1, vec3 d2 ) { return max(-min(d1, d2), max(d1, d2)); }\nvec4 opXor( vec4 d1, vec4 d2 ) { return max(-min(d1, d2), max(d1, d2)); }\n\n// NOTE TO SELF: To scale a mesh:\n// divide the input point by the scale factor,\n// then multiply the result by the scale factor.\n\n/*\n * SHAPE FUNCTIONS\n */\n\n// signed distance to a sphere\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// signed distance to an infinite 2D plane\nfloat sdPlane(vec3 p) {\n    return p.y;\n}\n\n// Unsigned distance to a trangle (with vertices a, b, c)\nfloat udTriangle(vec3 p, vec3 a, vec3 b, vec3 c) {\n    vec3 ba = b - a;\n    vec3 pa = p - a;\n    vec3 cb = c - b;\n    vec3 pb = p - b;\n    vec3 ac = a - c;\n    vec3 pc = p - c;\n    vec3 nor = cross(ba, ac);\n\n    return sqrt((sign(dot(cross(ba, nor), pa)) +\n        sign(dot(cross(cb, nor), pb)) +\n        sign(dot(cross(ac, nor), pc)) < 2.0) ? min(min(dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0.0, 1.0) - pa), dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0.0, 1.0) - pb)), dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0.0, 1.0) - pc)) : dot(nor, pa) * dot(nor, pa) / dot2(nor));\n}\n\n// Signed distance to an n-sided polygon\n// Via: https://math.stackexchange.com/questions/1641859/distance-function-for-n-prism\nfloat sdNGon(int nSides, vec2 pos, float radius) {\n    // these 2 lines can be precomputed\n    float an = 6.2831853 / float(nSides);\n    float he = radius * tan(0.5 * an);\n\n    // rotate to first sector\n    pos = -pos.yx; // if you want the corner to be up\n    float bn = an * floor((atan(pos.y, pos.x) + 0.5 * an) / an);\n    vec2 cs = vec2(cos(bn), sin(bn));\n    pos = mat2(cs.x, -cs.y, cs.y, cs.x) * pos;\n\n    // side of polygon\n    return length(pos - vec2(radius, clamp(pos.y, -he, he))) * sign(pos.x - radius);\n}\n\n// Signed distance to an n-sided 2D plane\nfloat sdNPlane(int nSides, vec3 pos, float radius) {\n    return sdNGon(nSides, pos.xy, radius);\n}\n\nfloat sdNPrism(int nSides, vec3 pos, float radius, float height) {\n    // for the distance result of any 2D SDF, returns a 3D prism for the 3rd axis position value v\n    float d2d = sdNGon(nSides, pos.xy, radius);\n    vec2 d = vec2(d2d, abs(pos.z) - 0.5 * height);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// signed distance to a cube with side length b\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n/**\n * SCENE FUNCTIONS\n */\n\n// Number of objects in the scene.\n#define OBJECT_COUNT 4\n\n// Collection of object distances in the scene.\nfloat distS[OBJECT_COUNT];\n\nfloat map(in vec3 pos) {\n    // The stored result.\n    float result = MAX_D;\n\n    // For each shape, we check if it's closer than a shape we've already evaluated.\n\n    // Ground plane.\n    result = opUnion(result, sdPlane(pos - vec3(0.0, 0.0, 0.0)));\n\n    // Sphere.\n    float customShape = sdSphere(pos - vec3(0.0, 0.75, 0.0), 0.5);\n    customShape = opSubtraction(sdSphere(pos - vec3(0.25, 1.0, 0.5), 0.5), customShape);\n    result = opUnion(result, customShape);\n\n    return result;\n}\n\n/**\n * RENDER FUNCTIONS\n */\n\n// Applies a soft shadow effect to the scene.\nfloat softShadow(in vec3 ro, in vec3 rd, float mint, float maxt) {\n    float res = 1.0;\n    float ph = 1e20;\n    for(float t = mint; t < maxt;) {\n        float h = map(ro + rd * t);\n        if(h < 0.001)\n            return 0.0;\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, SHADOW_SOFTNESS * d / max(0.0, t - y));\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// Renders the scene using a ray-marching algorithm.\nfloat castRay(vec3 rayOrigin, vec3 rayDir) {\n    vec3 rayPosition = rayOrigin;\n    float inc = 0.0;\n    float dist = 0.0;\n\n    for(int i = 0; i < ITERATIONS; i++) {\n        // Increment the ray position.\n        rayPosition = rayOrigin + dist * rayDir;\n\n        // Get the distance from the ray position to the closest object.\n        // When the distance is less than MIN_D, we have hit an object.\n        // inc = map(rayPosition);\n\n        inc = map(rayPosition);\n\n        // Increase the distance for the next iteration.\n        // The distance we move along the ray is equal to the distance to the closest object.\n        // This improves performance by skipping large distances but has performance issues if you skim past an edge.\n        dist += inc;\n\n        // If we've reached the maximum distance, return -1.\n        if(dist > MAX_D)\n            return -1.0;\n\n        // If we've hit an object, exit the loop.\n        if(inc < MIN_D)\n            break;\n    }\n\n    return dist;\n}\n\nfloat ambientOcclusion(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float h = 0.001 + 0.15 * float(i) / 4.0;\n        float d = map(pos + h * nor);\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 1.5 * occ, 0.0, 1.0);\n}\n\nvec3 normal(in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy) +\n        e.yyx * map(pos + e.yyx) +\n        e.yxy * map(pos + e.yxy) +\n        e.xxx * map(pos + e.xxx));\n}\n\nvec3 gamma(vec3 col) {\n    return pow(col, vec3(GAMMA));\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir) {\n    vec3 resultColor = vec3(0.0);\n\n    float t = castRay(rayOrigin, rayDir);\n\n    if(t >= 0.0) {\n        vec3 position = rayOrigin + t * rayDir;\n        vec3 normal = normal(position);\n\n        // Material color\n        // TODO: Add support for multiple materials.\n        vec3 material = vec3(0.3);\n\n        vec3 lightPosition = normalize(vec3(0.0, 0.3, 0.5));\n\n        vec3 hal = normalize(lightPosition - rayDir);\n\n        // Calculate and apply the diffuse.\n        float diffuse = clamp(dot(normal, lightPosition), 0.0, 1.0) *\n            softShadow(position, lightPosition, 0.01, 3.0);\n        resultColor = material * 4.0 * diffuse * vec3(1.00, 0.70, 0.5);\n\n        // Calculate and apply the specular.\n        float specular = pow(clamp(dot(normal, hal), 0.0, 1.0), 16.0) *\n            diffuse *\n            (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rayDir), 0.0, 1.0), 5.0));\n        resultColor += 12.0 * specular * vec3(1.00, 0.70, 0.5);\n\n        // Calculate and apply ambient light.\n        float occ = ambientOcclusion(position, normal);\n        float ambient = clamp(0.5 + 0.5 * normal.y, 0.0, 1.0);\n        resultColor += material * ambient * occ * vec3(0.0, 0.08, 0.1);\n\n        // Apply black fog based on distance.\n        resultColor *= exp(-0.0005 * t * t * t);\n    }\n\n    return resultColor;\n}\n\n// Given an XYZ camera position, and an XYZ camera focus, and the current position in screen space,\n// determine the direction of our raycast.\n// Includes a parameter to modify the camera roll.\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget, float camRoll)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 cameraAngle = vec3(sin(camRoll), cos(camRoll), 0.0);\n    vec3 camRight = normalize(cross(cameraAngle, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\n// Determines the ray position and direction,\n// and performs the render() function.\n// \nvec3 antiAliasedRender(vec2 fragCoord, vec3 cameraPosition, vec3 cameraFocus, float cameraRoll) {\n    vec3 resultColor = vec3(0.0);\n\n    #if AA_SAMPLE > 1\n\n    for(int m = 0; m < AA_SAMPLE; m++) {\n        for(int n = 0; n < AA_SAMPLE; n++) {\n            vec2 aaOffset = vec2(float(m), float(n)) / float(AA_SAMPLE) - 0.5;\n            vec2 normalizedScreenCoord = (-iResolution.xy + 2.0 * (fragCoord + aaOffset)) / iResolution.y;\n\n            // ray direction\n            vec3 rayDirection = getCameraRayDir(normalizedScreenCoord, cameraPosition, cameraFocus, cameraRoll);\n\n            // render\t\n            vec3 col = render(cameraPosition, rayDirection);\n\n\t    \t// Correct colors by applying gamma\n            col = pow(col, vec3(0.4545));\n\n            resultColor += col;\n        }\n    }\n    resultColor /= float(AA_SAMPLE * AA_SAMPLE);\n\n    #else\n\n    vec2 normalizedScreenCoord = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    vec3 rayDirection = getCameraRayDir(normalizedScreenCoord, cameraPosition, cameraFocus, cameraRoll);\n    vec3 col = render(cameraPosition, rayDirection);\n\n\t// Correct colors by applying gamma\n    resultColor = pow(col, vec3(0.4545));\n\n    #endif\n\n    return resultColor;\n}\n\n/**\n * MAIN FUNCTION\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Easy variables to manipulate the camera and the resulting scene.\n    float cameraRoll = 0.0;\n    float cameraSpinRate = 2.0;\n    float cameraHeight = 1.14;\n\n    // The point the camera focuses its view on.\n    vec3 cameraFocus = vec3(0.0, 1.0, 0.0);\n\n    // The point the camera is currently looking from.\n    float cameraAngle = 3.0 + (sin(iTime) * 8.0);\n\n    vec3 cameraPosition = vec3(3.0, cameraHeight, -3.0);\n\n    // By multipying the X and Z by the cosine and sine,\n    // we rotate the cameraPosition around the origin.\n    cameraPosition.x *= cos(0.1 * cameraAngle);\n    cameraPosition.z *= sin(0.1 * cameraAngle);\n\n    vec3 resultColor = antiAliasedRender(fragCoord, cameraPosition, cameraFocus, cameraRoll);\n\n    fragColor = vec4(resultColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syyRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1150, 1179, 1202, 1202, 1226], [1260, 1448, 1497, 1497, 2029], [2031, 2086, 2130, 2130, 2162], [2164, 2196, 2233, 2233, 2254], [2255, 2255, 2289, 2289, 2310], [2311, 2311, 2345, 2345, 2366], [2367, 2367, 2401, 2401, 2422], [2424, 2466, 2509, 2509, 2531], [2532, 2532, 2572, 2572, 2594], [2595, 2595, 2635, 2635, 2657], [2658, 2658, 2698, 2698, 2720], [2722, 2779, 2823, 2823, 2844], [2845, 2845, 2886, 2886, 2907], [2908, 2908, 2949, 2949, 2970], [2971, 2971, 3012, 3012, 3033], [3035, 3095, 3130, 3130, 3171], [3172, 3172, 3204, 3204, 3245], [3246, 3246, 3278, 3278, 3319], [3320, 3320, 3352, 3352, 3393], [3553, 3584, 3617, 3617, 3645], [3647, 3690, 3713, 3713, 3731], [3733, 3791, 3841, 3841, 4360], [4362, 4490, 4540, 4580, 5007], [5009, 5051, 5103, 5103, 5148], [5150, 5150, 5216, 5315, 5474], [5476, 5524, 5553, 5553, 5648], [5813, 5813, 5837, 5863, 6300], [6331, 6377, 6443, 6443, 6800], [6802, 6855, 6899, 6899, 7844], [7846, 7846, 7896, 7896, 8162], [8164, 8164, 8190, 8190, 8393], [8395, 8395, 8417, 8417, 8453], [8455, 8455, 8497, 8497, 9811], [9813, 10007, 10082, 10166, 10533], [10535, 10624, 10721, 10721, 11837], [11839, 11864, 11919, 11991, 12687]]}
{"id": "sdVyWt", "name": "Mandelbrot variation", "author": "mrange", "description": "License CC0: Mandelbrot variation\nTinkered with julia mapping. Not amazing but different enough to share.", "tags": ["mandelbrotjulia"], "likes": 18, "viewed": 327, "published": 3, "date": "1655847163", "time_retrieved": "2024-07-30T16:43:43.991450", "image_code": "// License CC0: Mandelbrot variation\n//  Tinkered with julia mapping. Not amazing but different enough to share.\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat cell_df(vec2 np, vec2 mp, vec2 off) {\n  const vec2 n0 = normalize(vec2(1.0, 1.0));\n  const vec2 n1 = normalize(vec2(-1.0, 1.0));\n\n  np += off;\n  mp -= off;\n  \n  float hh = hash(np);\n  vec2 n = hh > 0.5 ? n0 : n1;\n  vec2 t = vec2(n.y, -n.x);\n\n\n  vec2  p0 = mp;  \n  p0 = abs(p0);\n  p0 -= 0.5;\n  float d0 = length(p0)-0.0;\n\n  vec2  p1 = mp;\n  float d1 = dot(n, p1);\n  float px = dot(t, p1);\n  d1 = abs(px) > sqrt(0.5) ? d0 : abs(d1); \n\n  float d = d0;\n  d = min(d, d1);\n  \n  return d;\n}\n\nfloat truchet_df(vec2 p) {\n  vec2 np = floor(p+0.5);\n  vec2 mp = fract(p+0.5) - 0.5;\n  float d = 1E6;\n  const float off = 1.0;\n  for (float x=-off;x<=off;++x) {\n    for (float y=-off;y<=off;++y) {\n      vec2 o = vec2(x,y);\n      d = min(d,cell_df(np, mp, o));\n    }\n  }\n  return d;\n}\n\nvoid julia_map(inout vec2 p, vec2 c) {\n  for (int i = 0; i < 89; ++i) {\n    vec2 p2 = p*p;\n    p = vec2(p2.x-p2.y, 2.0*p.x*p.y);\n    p += c;\n  }\n}\n\nvec2 transform(vec2 p) {\n  p *= 0.0125;\n  p.x -= 0.5;\n  p += vec2(0.59, 0.62);\n  julia_map(p, p);\n  p *= 30.0;\n  p += 0.2*TIME;\n  return p;\n}\n\nvec3 effect(vec3 col, vec2 p_, vec2 np_) {\n  vec2 p  = transform(p_);\n  vec2 np = transform(np_);\n  float aa = distance(p, np)*sqrt(0.5);\n\n  float d = truchet_df(p)-aa;\n  \n  col = mix(col, vec3(0.1), smoothstep(aa, -aa, d));\n\n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec2 np = p+2.0/RESOLUTION.y;\n  \n  vec3 col = vec3(1.0);\n  col = effect(col, p, np);\n  \n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVyWt.jpg", "access": "api", "license": "cc0-1.0", "functions": [[172, 232, 253, 253, 323], [325, 325, 368, 368, 814], [816, 816, 842, 842, 1099], [1101, 1101, 1139, 1139, 1247], [1249, 1249, 1273, 1273, 1390], [1392, 1392, 1434, 1434, 1633], [1636, 1636, 1691, 1691, 1932]]}
{"id": "ssKyDK", "name": "hexagonal tilings", "author": "remaindeer", "description": "- first pass at sdf-based grid\n- improved construction method here: https://www.shadertoy.com/view/fsdfRH\n- https://en.wikipedia.org/wiki/List_of_Euclidean_uniform_tilings#The_[6,3]_group_family\n\n", "tags": ["grid", "sdf", "tiling", "tile", "euclidean", "hexagonal", "uniform", "tnumber"], "likes": 16, "viewed": 408, "published": 3, "date": "1655842978", "time_retrieved": "2024-07-30T16:43:44.997759", "image_code": "const float R = 1.0 / 3.0;\nconst float r = R * cos(radians(30.0));\n\nfloat dist(vec2 p, int scene)\n{\n    float d;\n    switch(scene) {\n        case 1: { // hex\n            vec2 v = vec2(3.0 * R, 2.0 * r);\n            vec2 p1 = opRep(p, v);\n            vec2 p2 = opRep(p + v / 2.0, v);\n            d = opUnion(\n                sdHexagon(p1, r),\n                sdHexagon(p2, r)\n            );\n            break;\n        }\n        case 2: { // trihex\n            vec2 v = vec2(2.0 * R, 4.0 * r);\n            vec2 p1 = opRep(p, v);\n            vec2 p2 = opRep(p + v / 2.0, v);\n            vec2 px = vec2(0);\n            d = sdHexagon(p1, r);\n            d = opUnion(d, sdHexagon(p2, r));\n            d = opUnion(d, sdTriangle(opRep(p - vec2(0, r), v), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle(opRep(p - vec2(R, r), v), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle(opRep(p - vec2(R, 3.0 * r), v), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle(opRep(p - vec2(2.0 * R, 3.0 * r), v), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            break;\n        }\n        case 3: { // snubhex\n            mat2 b = mat2(2.5 * R, r, 0.5 * R, 3.0 * r);\n            mat2 binv = inverse(b);\n            vec2 p1 = b * round(binv * p);\n            d = sdHexagon(p - p1, r);\n            d = opUnion(d, sdTriangle((p - vec2(0, r)) - (b * round(binv * (p - vec2(0, r)))), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(R, r)) - (b * round(binv * (p - vec2(R, r)))), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(4.0 * R, r)) - (b * round(binv * (p - vec2(4.0 * R, r)))), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(6.0 * R, r)) - (b * round(binv * (p - vec2(6.0 * R, r)))), vec2(-0.5 * R, 0), vec2(0, +r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(R, r)) - (b * round(inverse(b) * (p - vec2(R, r)))), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(4.0 * R, r)) - (b * round(binv * (p - vec2(4.0 * R, r)))), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(5.0 * R, r)) - (b * round(binv * (p - vec2(5.0 * R, r)))), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            d = opUnion(d, sdTriangle((p - vec2(6.0 * R, r)) - (b * round(binv * (p - vec2(6.0 * R, r)))), vec2(-0.5 * R, 0), vec2(0, -r), vec2(0.5 * R, 0)));\n            break;\n        }\n        case 4: { // rhombitrihex\n            mat2 b = mat2(R + r + R / 2.0, R / 2.0 + r, 0, r + R + r);\n            mat2 binv = inverse(b);\n            vec2 p1 = b * round(binv * p);\n            vec2 px;\n            d = sdHexagon(p - p1, r);\n            d = opUnion(d, sdBox((p - vec2(0, R / 2.0 + r)) - (b * round(binv * (p - vec2(0, R / 2.0 + r)))), vec2(R / 2.0)));\n            d = opUnion(d, sdTriangle((p - vec2(R / 2.0, R / 2.0 + r)) - (b * round(binv * (p - vec2(R / 2.0, R / 2.0 + r)))), vec2(0, -(R / 2.0)), vec2(0, (R / 2.0)), vec2(r, 0)));\n            px = ((rotmat2(radians(60.0)) * p) - vec2(0 , R / 2.0 + r));\n            d = opUnion(d, sdBox(px - (b * round(binv * px)), vec2(R / 2.0)));\n            d = opUnion(d, sdTriangle((p - vec2(R + r, 0)) - (b * round(binv * (p - vec2(R + r, 0)))), vec2(0, -(R / 2.0)), vec2(0, (R / 2.0)), vec2(-r, 0)));\n            px = ((rotmat2(radians(120.0)) * p) - vec2(0 , R / 2.0 + r));\n            d = opUnion(d, sdBox(px - (b * round(binv * px)), vec2(R / 2.0)));  \n            break;\n        }\n        case 5: { // dualhex\n            float s2 = R * sqrt(3.0) / 3.0; \n            float s = 2.0 * s2;\n            float R3 = s * sqrt(3.0) / 3.0;\n            float r3 = s * sqrt(3.0) / 6.0;\n            float a = R3 + r3;\n            mat2 b = mat2(1.5 * R, r, 0, 2.0 * r);\n            vec2 px;\n            px = p - vec2(0, r3);\n            px = opRep(px, vec2(s, 2.0 * a));\n            d = sdEquilateralTriangle(px, s2);\n            px = p - vec2(0, r3);\n            px = px - vec2(1.5 * s, a);\n            px = opRep(px, vec2(s, 2.0 * a));\n            d = opUnion(d, sdEquilateralTriangle(px, s2));\n            px = p - vec2(0, R3);\n            px = px - vec2(1.5 * s, 0);\n            px = rotmat2(radians(180.0)) * px;\n            px = opRep(px, vec2(s, 2.0 * a));\n            d = opUnion(d, sdEquilateralTriangle(px, s2));\n            px = p - vec2(0, R3);\n            px = px - vec2(s, a);\n            px = rotmat2(radians(180.0)) * px;\n            px = opRep(px, vec2(s, 2.0 * a));\n            d = opUnion(d, sdEquilateralTriangle(px, s2));\n            break;\n        }\n        case 6: { // dualtrihex\n            mat2 b = mat2(1.5 * R, r, 0, 2.0 * r);\n            vec2 p1 = b * round(inverse(b) * p);\n            vec2 px;\n            for (int i = 0; i < 6; i++) {\n                px = rotmat2(radians(float(i) * 60.0)) * p;\n                px -= b * round(inverse(b) * px);\n                d = opUnion(d, sdRhombus(px - vec2(0, r / 2.0), vec2(R / 2.0 / 2.0, r / 2.0)));\n                px = rotmat2(radians(float(i) * 60.0)) * p;\n                px = px - vec2(R - R / 4.0, 1.5 * r);\n                px -= b * round(inverse(b) * px);\n                d = opUnion(d, sdRhombus(px - vec2(0,r/2.0), vec2(R / 2.0 / 2.0, r / 2.0)));\n            }\n            break;\n        }\n        case 7: { // dualsnubhex\n            float R3 = R * sqrt(3.0) / 3.0;\n            float r3 = R * sqrt(3.0) / 6.0;\n            vec2 v0 = vec2(0, 0);\n            vec2 v1 = vec2(0, r + r3);\n            vec2 v2 = vec2(R / 2.0, r + R3);\n            vec2 v3 = vec2(R, r + r3);\n            vec2 v4 = vec2(R, R3);\n            vec2[] v = vec2[](v0,v1,v2,v3,v4);\n            mat2 b = 2.0 * mat2(2.5 * R, r, 0.5 * R, 3.0 * r);\n            mat2 binv = inverse(b);\n            vec2 px = p;\n            vec2 p1 = px - b * round(binv * px);\n            px = p - vec2(2.5 * R, 1.0 * r);\n            vec2 p2 = px - b * round(binv * px);\n            px = p - vec2(2.0 * R, -2.0 * r);\n            vec2 p3 = px - b * round(binv * px);\n            px = p - vec2(0.5 * R, 3.0 * r);\n            vec2 p4 = px - b * round(binv * px);\n            for (int i = 0; i < 6; i++) {\n                px = p1;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd5Gon(px, v));\n                px = p2;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd5Gon(px, v));\n                px = p3;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd5Gon(px, v));\n                px = p4;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd5Gon(px, v));\n            }\n            break;\n            \n        }\n        case 8: { // dualrhombitrihex\n            float R3 = R * sqrt(3.0) / 3.0;\n            float r3 = R * sqrt(3.0) / 6.0;\n            vec2 v0 = vec2(0, 0);\n            vec2 v1 = vec2(0, r);\n            vec2 v2 = vec2(R / 2.0, r);\n            vec2 v3 = vec2(0.75 * R, r / 2.0);\n            vec2[] v = vec2[](v0,v1,v2,v3);\n            vec2 b = vec2(3.0 * R, 2.0 * r);\n            vec2 p1 = opRep(p, b);\n            vec2 p2 = opRep(p + b / 2.0, b);\n            for (int i = 0; i < 6; i++) {\n                vec2 px = p1;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd4Gon(px, v));\n                px = p2;\n                px = rotmat2(radians(float(i) * 60.0)) * px;\n                d = opUnion(d, sd4Gon(px, v));\n            }\n        }\n    }\n   return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // transform\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    p = rotmat2(radians(5.0 * iTime)) * p;\n    m = rotmat2(radians(5.0 * iTime)) * m;\n    \n    // distance\n    int scene = 1 + int(mod(round(iTime), 8.0));\n    float d = dist(p, scene);\n\n    // color\n    vec3 col = vec3(0);\n    col = (d > 0.0) ? col : 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n    float th = 0.075 * R;\n    col *= th - exp(-2.0 * abs(d));\n    col *= th + cos(300.0 * d);\n    col = mix(col, vec3(0.5), 1.0 - smoothstep(0.0, th, abs(d)));\n    \n    if( iMouse.z>0.001 )\n    {\n        d = dist(m, scene);\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) -abs(d)) - 0.005));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "float ndot(vec2 a, vec2 b )\n{ \n    return a.x*b.x - a.y*b.y;\n}\n\nmat2 rotmat2(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat opUnion( float d1, float d2 )\n{ \n    return min(d1,d2); \n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nvec2 opRep( in vec2 p, in vec2 c )\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\n// r is the half-side\nfloat sdEquilateralTriangle(  in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n\n\treturn d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sd4Gon( in vec2 p, in vec2[4] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sd5Gon( in vec2 p, in vec2[5] v )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\n// r is the inradius\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[7749, 7749, 7806, 7826, 8731]]}
{"id": "fdVcDd", "name": "The Bonne Projection", "author": "mla", "description": "The Bonne projection, a generalization of the Werner projection, [url]https://en.wikipedia.org/wiki/Bonne_projection[/url]. Projection is also equal area and with correct distances along central meridian and the concentric lines of latitude. Mousable.", "tags": ["projection", "werner", "bonne"], "likes": 13, "viewed": 257, "published": 3, "date": "1655840933", "time_retrieved": "2024-07-30T16:43:46.517695", "image_code": "const float PI = 3.14159;\nconst float TWOPI = 2.0*PI;\nfloat WIDTH = 400.0;\nfloat HEIGHT = 200.0;\n\nfloat cot(float x) { return 1.0/tan(x); }\nfloat sqr(float x) { return x*x; }\n\nvec2 werner(float x, float y) {\n  float r = length(vec2(x,y)); // Concentric circles\n  float theta = atan(x,-y);\n  float phi = 0.5*PI - r; // Colatitude is distance from pole\n  float lambda = r * theta/cos(phi);\n  return vec2(phi,lambda);\n}\n\nvec2 bonne(float x, float y, float p) {\n  float cotp = 1.0/tan(p);\n  float rho = sqrt(sqr(x) + sqr(cotp - y));\n  float phi,lambda;\n  if (p > 0.0) {\n    phi = cotp + p - rho;\n    lambda = rho * atan(x, cotp - y)/cos(phi);\n  } else if (p < 0.0) {\n    phi = cotp + p + rho;\n    lambda = rho * atan(x, y - cotp)/cos(phi);\n  } else {\n    // Degenerate case - the sinusoidal projection\n    phi = y;\n    lambda = x/cos(phi);\n  }\n  return vec2(phi,lambda);\n}\n\nvec3 sphere(float phi, float lambda) {\n  float y = sin(phi);\n  float x = cos(phi)*cos(lambda);\n  float z = cos(phi)*sin(lambda);\n  return vec3(x,y,z);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec3 getcol(float phi, float lambda) {\n  vec3 p = sphere(phi,lambda);\n  if (WIDTH <= iResolution.x) p.zx = rotate(p.zx,0.1*PI*iTime);\n  if (iMouse.z > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  lambda = atan(p.z,p.x);\n  phi = asin(p.y);\n#if 0\n  vec3 col = texture(iChannel1,p).xyz; // Cubemap\n#elif 0\n  vec3 col = texture(iChannel0,vec2(0.5+lambda/TWOPI,0.5+phi/PI)).xyz;\n#else\n  float u = 0.5+lambda/TWOPI;\n  float v = 0.5+phi/PI;\n  v = 1.0-v;\n  u *= WIDTH/iResolution.x;\n  v *= HEIGHT/iResolution.y;\n  vec3 col = texture(iChannel2,vec2(u,v)).xyz;\n  col = pow(col,vec3(0.5));\n#endif\n  if (true) {\n    // Draw grid lines\n    phi *= 12.0/PI;\n    vec3 lcol = vec3(0.8);\n    lambda *= 12.0/PI;\n    col = mix(lcol,col,0.5+0.5*smoothstep(0.0,fwidth(lambda),abs(lambda-round(lambda))));\n    //if (round(phi) == 0.0) lcol = vec3(0.8,0,0);\n    col = mix(lcol,col,0.5+0.5*smoothstep(0.0,fwidth(phi),abs(phi-round(phi))));\n  }\n  return col;\n}\n  \nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    vec2 uv = 2.25*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    //uv.y -= 0.5;\n    float x = uv.x, y = uv.y;\n    float p = 0.5*PI*sin(0.5*iTime);\n    y -= 0.7*p;\n    vec2 latlong = bonne(x,y,p);\n    float phi = latlong.x, lambda = latlong.y;\n    vec3 col = getcol(phi,lambda);\n    // Smooth out the edges - this does produce an annoying\n    // halo further out where the fwidths go awry.\n    if (abs(lambda) > PI+0.1) col *= 0.0;\n    col *= 1.0-smoothstep(0.0,fwidth(lambda),abs(lambda)-PI);\n    col *= 1.0-smoothstep(0.0,fwidth(phi),abs(phi)-0.5*PI);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "///////////////////////////////////////////////////////////////////////////////\n//\n// 16 color GIF, cropped, run length encoded and packed into an array of uvec4s\n// Upper 4 bits of each byte is the runlength-1 (we don't need 0 length runs,\n// obviously), lower 4 bits is the color index.\n//\n// Original image by NASA.\n//\n// Does basic coloring here rather than in Image tab to get the benefit\n// of texture filtering.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst uvec4 data[] = uvec4[](\nuvec4(0x2170f0f0u,0xf0f06110u,0xf130f0f0u,0xc0211071u),\nuvec4(0x00610061u,0x10512021u,0x00710061u,0x00610051u),\nuvec4(0xf1f1f1f1u,0x209100d1u,0xf1f16061u,0xf2f0f051u),\nuvec4(0x42713231u,0xf2317261u,0x00a2c332u,0x24f43012u),\nuvec4(0x21020130u,0x01208120u,0x01001110u,0x204120f0u),\nuvec4(0xf1f1f1f1u,0x05e10551u,0xb1f1f1f1u,0x506400f0u),\nuvec4(0x13721162u,0x81927312u,0xf0f01130u,0x001170f0u),\nuvec4(0xe2b0f001u,0x14f42200u,0x11022160u,0xa1f180f0u),\nuvec4(0xf1102110u,0x30611531u,0x30211001u,0x00110021u),\nuvec4(0xf1f13061u,0x110521f1u,0x31007115u,0x2220e460u),\nuvec4(0x21107103u,0x41400140u,0xf1201180u,0x0201c011u),\nuvec4(0x102460f0u,0x60f0f0e4u,0x000412d4u,0x01001102u),\nuvec4(0x102100f0u,0x20010081u,0x15917031u,0x30113021u),\nuvec4(0x30111041u,0x02410231u,0x13050243u,0x52210205u),\nuvec4(0x00310523u,0x10410021u,0x00111001u,0x9581f1f1u),\nuvec4(0x22010211u,0x0004f430u,0xf050f021u,0x0044b0f0u),\nuvec4(0x14f40074u,0x34008420u,0xf4107400u,0x0014d644u),\nuvec4(0xf0f02132u,0x61800130u,0x11001100u,0x32202100u),\nuvec4(0x02330100u,0x02130201u,0x05010541u,0x001120b1u),\nuvec4(0x00011001u,0x81f14061u,0x00b1f115u,0x32b18041u),\nuvec4(0x122400a4u,0x3040f001u,0x605400e4u,0xf0242034u),\nuvec4(0x10f46012u,0x64000234u,0xf4000460u,0xe0019294u),\nuvec4(0x512244f4u,0x01303100u,0x01221110u,0x05432223u),\nuvec4(0x21031501u,0x21005105u,0xe0f0f0f0u,0x25110001u),\nuvec4(0x10612501u,0x15610001u,0x00a10001u,0x50213001u),\nuvec4(0x22206432u,0xb050f001u,0x50120012u,0xd011a002u),\nuvec4(0x90114031u,0x00348012u,0x10041214u,0x14f42002u),\nuvec4(0xf624f416u,0x321416f6u,0x20110213u,0x10215011u),\nuvec4(0x10111221u,0xf0810001u,0xf0f0f0f0u,0x003100f0u),\nuvec4(0x40f001f1u,0x00240014u,0x12040012u,0xf0110410u),\nuvec4(0x00616060u,0x02610251u,0xf001e021u,0xa6b490f0u),\nuvec4(0x17e6f647u,0x97086706u,0x04064446u,0x03024031u),\nuvec4(0x12112322u,0x20510503u,0xf0f0f001u,0xf0f014a0u),\nuvec4(0x911001b0u,0x10f03100u,0xf012c034u,0x0150f070u),\nuvec4(0x010001c0u,0x11c01140u,0x200120f0u,0x0607d654u),\nuvec4(0x0a270927u,0x09170907u,0x29272917u,0x16173617u),\nuvec4(0x0b070b27u,0x47092b09u,0x07692718u,0x04863719u),\nuvec4(0x20021406u,0x90010311u,0x10020074u,0xf0010312u),\nuvec4(0xf6840004u,0xf4260496u,0xf0240064u,0x40150170u),\nuvec4(0xf034f001u,0xe0f080f0u,0x00f0f0c1u,0x0417b664u),\nuvec4(0x0907091bu,0x09470907u,0x08074907u,0x06274917u),\nuvec4(0x08173827u,0xca282a27u,0x0c290758u,0x270b0709u),\nuvec4(0x462a070bu,0x00212014u,0x36140001u,0x24302234u),\nuvec4(0x64062406u,0xd607e6f6u,0x0496f604u,0x10f03426u),\nuvec4(0x10f00123u,0x60f0f044u,0x00140004u,0x4001f004u),\nuvec4(0x01e0f001u,0x37f68480u,0x472b7708u,0x19171a18u),\nuvec4(0x570a0627u,0x3afafa08u,0x29070937u,0x20049637u),\nuvec4(0x34221001u,0xf6f62406u,0x04270486u,0xf6470426u),\nuvec4(0x566736f6u,0x70f0f024u,0x2480f0d4u,0x60f02400u),\nuvec4(0x21b0f011u,0x04b62480u,0x87260436u,0x47091709u),\nuvec4(0xfa569708u,0x4708dafau,0x014024c6u,0x14000223u),\nuvec4(0x670a5726u,0xf6f6f60au,0x670496f6u,0x2486070au),\nuvec4(0xf644d0f0u,0x34d05416u,0x40040044u,0x12141654u),\nuvec4(0xf0f00100u,0x07764440u,0x2b36040bu,0x170b1627u),\nuvec4(0x570b4716u,0x570a0809u,0x070a3604u,0x3afafafau),\nuvec4(0x0406f607u,0x161402b0u,0x47190b37u,0xf6f6f6f6u),\nuvec4(0x061726f6u,0xf0546667u,0x54f6f654u,0x14001400u),\nuvec4(0x20642400u,0x04035624u,0x14101412u,0xc0f00302u),\nuvec4(0x1b14a604u,0x04460b0du,0x0b070b16u,0x1b070604u),\nuvec4(0x16141617u,0x18270b27u,0x57361437u,0xeafafa08u),\nuvec4(0x4012e637u,0x12043001u,0x29172624u,0xf6271607u),\nuvec4(0xf6f6f6f6u,0x17060446u,0xf6f6d4e6u,0x703494d6u),\nuvec4(0x14060402u,0x02041206u,0x13240214u,0x4614b0f0u),\nuvec4(0x040d3b07u,0x07860407u,0x26277604u,0x29371607u),\nuvec4(0x47246627u,0x08bafafau,0xb6470819u,0x04803204u),\nuvec4(0x14023002u,0xf6f62716u,0xf60476f6u,0x1b4604c6u),\nuvec4(0x16171b07u,0x06f6f627u,0x36f6f60au,0x04002454u),\nuvec4(0x04365410u,0x00020402u,0x01030234u,0x561490f0u),\nuvec4(0x0b472b04u,0x071b1627u,0x1b060706u,0x17160b47u),\nuvec4(0x37163706u,0xc6042706u,0xfa273427u,0x1a183afau),\nuvec4(0x14862709u,0x00210223u,0x40026011u,0xf6f6f624u),\nuvec4(0x57260a16u,0x0b27a6f6u,0x2b0d1b17u,0x47080709u),\nuvec4(0xf6071b09u,0x060b3796u,0x46f6f607u,0x0406f624u),\nuvec4(0x03023420u,0xd604b0f0u,0x070b0d57u,0x040b070bu),\nuvec4(0x07260406u,0x0b06170bu,0x08170617u,0x0a173817u),\nuvec4(0x94460b17u,0xfa262436u,0x19074afau,0x040b070bu),\nuvec4(0x02230436u,0x22017001u,0x60011021u,0xc6f6f604u),\nuvec4(0x14271807u,0x1b2796f6u,0x1b470827u,0x0b270807u),\nuvec4(0x17290709u,0x0796f60bu,0x162b2d1bu,0x06f6f63bu),\nuvec4(0x122426f6u,0xc0f00103u,0x470b5604u,0x07c61466u),\nuvec4(0x37461726u,0x245004f4u,0xdafa0756u,0x09072937u),\nuvec4(0x13044607u,0x1001c002u,0x20221011u,0xa6f6f644u),\nuvec4(0xf6270907u,0x0d0b07c6u,0x18070847u,0x1b077b09u),\nuvec4(0x1a371b07u,0x07c63aa6u,0xf6f60a26u,0x2446f666u),\nuvec4(0x4604e0f0u,0x66970b07u,0x26070b17u,0x1b070b07u),\nuvec4(0x27080716u,0x09671826u,0x14508417u,0x17061426u),\nuvec4(0x3c07cafau,0x0436072bu,0x04000203u,0x011001a0u),\nuvec4(0x10011240u,0xa6f6f644u,0x170c0907u,0x0a070bd6u),\nuvec4(0x0d2b4776u,0x0d0b0d2bu,0x0d2b07ebu,0x2d26177bu),\nuvec4(0x1b07c62bu,0xf686f6f6u,0x60f01496u,0x0b074634u),\nuvec4(0x0b870997u,0x0d1b1607u,0x061b0d0bu,0x08173617u),\nuvec4(0x09070407u,0x26472908u,0x46148024u,0x9afa0817u),\nuvec4(0x090c0927u,0x02043627u,0xc0010014u,0xf6445062u),\nuvec4(0xc63786f6u,0x0b2d070au,0x1b160b16u,0x0d7b1704u),\nuvec4(0x0d4b3dcbu,0x1d1b0d2bu,0x260b3d7bu,0x061a160au),\nuvec4(0x474b071au,0xf6f60a06u,0x34c6f627u,0x47865490u),\nuvec4(0x07583716u,0x0d1b0d0bu,0x04071b46u,0x1b472637u),\nuvec4(0x09170957u,0x0406170bu,0x14402406u,0x0c1b1746u),\nuvec4(0x076afa08u,0x1b07090cu,0x02041627u,0x14104400u),\nuvec4(0x02000410u,0xb0014220u,0x66f6f614u,0x27090b04u),\nuvec4(0x0d0b07a6u,0x1d171d0bu,0x8b2d1b07u,0x4b1d2b0du),\nuvec4(0x58073b0du,0x09071b07u,0x0918278bu,0x070a0617u),\nuvec4(0xbd4b170bu,0xf6f6f60bu,0x2d2b0746u,0x2466472bu),\nuvec4(0x0a460406u,0x04360736u,0x57096746u,0x0a46071bu),\nuvec4(0x17180706u,0x09072b26u,0x0b070b27u,0x27195809u),\nuvec4(0x14101416u,0x070b2766u,0x1c175afau,0x0b17061bu),\nuvec4(0xa4000416u,0x11320302u,0x460420f0u,0x0486f697u),\nuvec4(0x96070b17u,0x1d1b1d0bu,0x0b2d0b0au,0xab1d0b1du),\nuvec4(0x17095b09u,0x0708c7a8u,0x27080719u,0x1d2b0d0bu),\nuvec4(0x2d0b7d3bu,0x070b4d1bu,0xf646f60au,0x2b0dbb26u),\nuvec4(0x0b275687u,0x07063b0du,0x0817760bu,0x0b071b47u),\nuvec4(0x1b1d0b07u,0x070b0716u,0x171b070bu,0x070b3746u),\nuvec4(0x38470b04u,0x24062719u,0x07461410u,0x0b070b09u),\nuvec4(0x07186afau,0x0709070au,0x00042604u,0x02040054u),\nuvec4(0x10020400u,0xf0110201u,0x07161410u,0x08270849u),\nuvec4(0x0a86f657u,0x160b0726u,0x0b071617u,0x0b0d1b0du),\nuvec4(0x2d1b0d0au,0x3d0b0d1bu,0x8889270bu,0x07091709u),\nuvec4(0x17188708u,0x170b0d0bu,0x07093729u,0x27080738u),\nuvec4(0x270b0d2bu,0x5d0b0d0bu,0x1706470bu,0x1b27061bu),\nuvec4(0xd6173617u,0xe8070817u,0x27296c09u,0x1b0d0b1du),\nuvec4(0x68170827u,0x0b071b27u,0x0b170b47u,0x3b160a27u),\nuvec4(0x170d0b06u,0x0807262bu,0x0a070b07u,0x17160706u),\nuvec4(0x0718071bu,0x1416170bu,0x14561410u,0x1afa0706u),\nuvec4(0x84172947u,0x04104402u,0x11100120u,0x041614d0u),\nuvec4(0x190c1917u,0x370b6748u,0x16070bc6u,0x0b271617u),\nuvec4(0x1b171b07u,0x0d0b0617u,0x170b0d0bu,0x0d4b0d5bu),\nuvec4(0x091b080bu,0x77c8197cu,0x0d0b1718u,0x1c09170bu),\nuvec4(0x09270809u,0x08092817u,0x1b1d7b07u,0x174d2b1du),\nuvec4(0x0d0b1749u,0x1959170bu,0x17a6071bu,0x17290b09u),\nuvec4(0x07399c19u,0x0d0c1948u,0xa817380bu,0x3b571637u),\nuvec4(0x2b070b27u,0x08170b17u,0x28170627u,0x0d0b3617u),\nuvec4(0x070b170bu,0x17090728u,0x07463426u,0x0afa170bu),\nuvec4(0x14071c09u,0x14020436u,0x64005426u,0x00643140u),\nuvec4(0x29074614u,0x0748090cu,0x27285748u,0x070b0d36u),\nuvec4(0x1d2b0716u,0x071b071bu,0x070b170bu,0x0b190708u),\nuvec4(0x160d1b1du,0x4b1d0b2du,0xb9172b07u,0x371807b8u),\nuvec4(0x071b2718u,0x092c0908u,0x49470908u,0x08074b07u),\nuvec4(0x4b0d6b07u,0x49270b0du,0x190c3937u,0x071b0927u),\nuvec4(0x0a56070bu,0x0d3b0716u,0x390c091bu,0x28372907u),\nuvec4(0x07093809u,0x1709172bu,0x27c80768u,0x0d6b2708u),\nuvec4(0x0b076809u,0x36170827u,0x0b1a0617u,0x18090b0du),\nuvec4(0x16170b27u,0x09072634u,0x08ba0817u,0x0d0c0907u),\nuvec4(0xc614660bu,0x30213054u,0x29075664u,0x5738090cu),\nuvec4(0x070b0728u,0x1708470bu,0x0b0d0a16u,0x2b070b17u),\nuvec4(0x2b270b0du,0x19271b07u,0x0d0b1d0bu,0x2b07060bu),\nuvec4(0x3b3d0b1du,0x0789470du,0x1b0768f8u,0x1c090807u),\nuvec4(0x17081729u,0x281c0918u,0x07091729u,0x170b074bu),\nuvec4(0x37081708u,0x07490708u,0x07392708u,0x1b271b07u),\nuvec4(0x260b0907u,0x070a1b17u,0x0b09073bu,0x09071827u),\nuvec4(0x28293847u,0x0b173809u,0x07380709u,0x17a80736u),\nuvec4(0x37180748u,0x0b182738u,0x072a5637u,0x0b093b0du),\nuvec4(0x040b2917u,0x07560406u,0x08090709u,0x0c0b279au),\nuvec4(0x3614660bu,0x26571617u,0x20040614u,0x76246011u),\nuvec4(0x17283907u,0x2728173bu,0x0d4b771bu,0x279b271bu),\nuvec4(0x1d3b3d1bu,0x2d1b0d3bu,0x28171d3bu,0x88076907u),\nuvec4(0x0d27b807u,0x1c09080bu,0x2c690829u,0x17390819u),\nuvec4(0x070b0d0bu,0x17083708u,0x59070819u,0x170b1918u),\nuvec4(0x1709070bu,0x06070607u,0x460b0927u,0x1b291b07u),\nuvec4(0x09072b18u,0x07290b17u,0x17392ce9u,0x07080709u),\nuvec4(0x28f80706u,0x0b0748a7u,0x560a1b07u,0x0a273b17u),\nuvec4(0x04060718u,0x06044617u,0x09071614u,0x178a0807u),\nuvec4(0x42043614u,0x0b173604u,0x09182917u,0x0204360bu),\nuvec4(0x24702200u,0x48390766u,0x0716070bu,0x3708171bu),\nuvec4(0x070a361bu,0x0d0b070bu,0x176b373bu,0x2b090709u),\nuvec4(0x2b2d3b2du,0x3b1d2b1du,0x08070b0du,0x39172807u),\nuvec4(0x1738f817u,0x0d0b0718u,0x2c090807u,0x1c094c99u),\nuvec4(0x07090c09u,0x1709171bu,0x17690738u,0x0d0b1d09u),\nuvec4(0x070b1d1bu,0x7617560bu,0x06070607u,0x18572b27u),\nuvec4(0x09071817u,0x29dc291cu,0x38f80718u,0x1b0d2b67u),\nuvec4(0x06171b07u,0x07090b0du,0x1726070bu,0x1758172bu),\nuvec4(0x07165456u,0x36177a19u,0x24203204u,0x18190746u),\nuvec4(0x00243637u,0x04700103u,0x07461400u,0x4829070bu),\nuvec4(0x060a0b07u,0x08371b07u,0x0b172b27u,0x5b0d0b07u),\nuvec4(0x0b072827u,0x0d0b0957u,0xeb1d0b17u,0x0b0d5b0du),\nuvec4(0x07396718u,0x87982738u,0x794c492bu,0x291c091cu),\nuvec4(0x07291857u,0x0d0b0779u,0x0b0d170bu,0x06070b1du),\nuvec4(0x36041786u,0x0a07160au,0x28372b07u,0x08096c09u),\nuvec4(0x08096ca9u,0x07580709u,0x2b2728f8u,0x17261b1du),\nuvec4(0x0b07061bu,0x04071607u,0x08170436u,0x26040937u),\nuvec4(0x02043024u,0x5a170604u,0x070b0907u,0x44502224u),\nuvec4(0x442b0736u,0x84201456u,0x07194726u,0x17090728u),\nuvec4(0x0b0d0b06u,0x0b0d3be7u,0x070908f7u,0x074b1d3bu),\nuvec4(0x175b072bu,0x68071d4bu,0x08070927u,0xc8070817u),\nuvec4(0x49372bb7u,0x290c392cu,0x0817390cu,0x0c190809u),\nuvec4(0x1b090759u,0x18070807u,0x0d0b0927u,0x0bf6060bu),\nuvec4(0x0b090b1du,0x08070b0du,0x2c090817u,0x09081c09u),\nuvec4(0x791c0908u,0x195c291cu,0x28175817u,0x2b27b817u),\nuvec4(0x1b86070du,0x07060416u,0x04260726u,0x12143657u),\nuvec4(0x12010220u,0x074a1706u,0x0204070bu,0x140094a0u),\nuvec4(0x56641002u,0x56140004u,0x28392c17u,0x07260b07u),\nuvec4(0x470bc70bu,0x0d0b070bu,0x1708d71bu,0x074b0d0bu),\nuvec4(0x071b57dbu,0x0708070bu,0x78f80718u,0x0b07a827u),\nuvec4(0x18270817u,0x290c294cu,0x1807290cu,0x07290c29u),\nuvec4(0x072b170bu,0x29072908u,0x5d07e647u,0x070b170bu),\nuvec4(0x091d0908u,0x1c0d0c1bu,0x0c0d0c09u,0x1c393c0du),\nuvec4(0x08096c19u,0x16570807u,0x0b27e817u,0x0604e60du),\nuvec4(0x0738070bu,0x04063466u,0x06028002u,0x08170a17u),\nuvec4(0x90120617u,0x00140244u,0x46546004u,0x66140204u),\nuvec4(0x38195c07u,0x0b36070bu,0x1b071b67u,0x0b070b07u),\nuvec4(0x09070b57u,0x2708b71bu,0x0d0b370bu,0x19971bfbu),\nuvec4(0xf8070807u,0x381728f8u,0x999c0927u,0x0706170cu),\nuvec4(0x07060719u,0x0c29171bu,0x02042709u,0xe6041604u),\nuvec4(0x370b3d07u,0x0c090708u,0x0c09170du,0x1c09070bu),\nuvec4(0x5c0d0c19u,0x1c190c09u,0x0c191c09u,0x28076809u),\nuvec4(0x0d27f807u,0x1b06f607u,0x86174807u,0x1402a002u),\nuvec4(0x070b270bu,0x34900204u,0x0654b012u,0x09079644u),\nuvec4(0x2817192cu,0x26070b07u,0x0d6b0d07u,0x1b0a060bu),\nuvec4(0x090897f7u,0x677bfb17u,0x0758070bu,0x0788f8f8u),\nuvec4(0x0c190708u,0x0c190c19u,0x0c090c79u,0x06074609u),\nuvec4(0x0b071b0au,0x041b1927u,0x04122302u,0x07c60402u),\nuvec4(0x070b0706u,0x2b09070bu,0x060b0917u,0x07090c0au),\nuvec4(0x370b0436u,0x290c0d3cu,0x0768591cu,0x1b0758f8u),\nuvec4(0x0706f60au,0x360b670du,0xd0042617u,0x070b1402u),\nuvec4(0x34900204u,0x0264a002u,0xb6240204u,0x390c0b07u),\nuvec4(0x1b170917u,0x1607061du,0x2b171637u,0xf7180b0du),\nuvec4(0x07090877u,0x67eb0d8bu,0x1738071bu,0x290718f8u),\nuvec4(0x07080718u,0x079908f8u,0x1b29072bu,0x09070a56u),\nuvec4(0x120b270bu,0x21030204u,0x02000240u,0x271ad614u),\nuvec4(0x160c073bu,0x040a1604u,0x04121123u,0x092c0716u),\nuvec4(0x092c191cu,0x1988091cu,0x07c81a48u,0x06f6070bu),\nuvec4(0x28270b0du,0x16070b07u,0x260b0917u,0x1204f004u),\nuvec4(0x12248001u,0x0746c490u,0x0b290786u,0x36072b57u),\nuvec4(0x47f7ab07u,0x17183718u,0xf877bbfbu,0x190c2948u),\nuvec4(0x07980958u,0x08290809u,0x37861719u,0x0b0c1746u),\nuvec4(0x03120706u,0x04020001u,0x10700102u,0x04030213u),\nuvec4(0x070d16f6u,0x060b170bu,0x1302060au,0x02015001u),\nuvec4(0x090b0714u,0x0d5c092cu,0x07a8090cu,0x0b1708f8u),\nuvec4(0x17f60a0du,0x170b2748u,0x16070918u,0x12e00204u),\nuvec4(0x90221490u,0x16340604u,0x07261014u,0x17a61706u),\nuvec4(0x370b2604u,0x0704460bu,0x07f78b06u,0x3718370bu),\nuvec4(0x17cb0738u,0xa77b071bu,0x0c5918f8u,0x17491cb9u),\nuvec4(0x16f60739u,0x09070b07u,0x0306070du,0x04021120u),\nuvec4(0x11307012u,0x1b07f602u,0x16170604u,0x05030d03u),\nuvec4(0x0b0704b0u,0x199c0b07u,0x88f81918u,0x072b0d17u),\nuvec4(0x076807d6u,0x16070958u,0xa021c004u,0x70011022u),\nuvec4(0x20032654u,0x29072604u,0x060a9607u,0x18170a1bu),\nuvec4(0x07060b09u,0x2b0d0716u,0x1b070b27u,0x0bb71807u),\nuvec4(0xbb2748b7u,0x0b070b77u,0x98071867u,0x0c195807u),\nuvec4(0x2c498c19u,0x08390c29u,0xd6070c09u,0x0b071614u),\nuvec4(0x0c090807u,0x20010217u,0x01031211u,0x02015070u),\nuvec4(0x76140203u,0x36071b17u,0x030e0d07u,0x40512005u),\nuvec4(0x17060402u,0x08099c09u,0x0768f829u,0x171b1708u),\nuvec4(0x1617762bu,0x58076807u,0x02360b07u,0x202100f0u),\nuvec4(0x00040214u,0x26646001u,0x04300304u,0x0b190726u),\nuvec4(0x061b0db6u,0x0b071b07u,0x1b0d2b46u,0x7b772857u),\nuvec4(0x48171b47u,0x1b271b37u,0x0b675b07u,0xc8074837u),\nuvec4(0x2c090819u,0x4c092c09u,0x0c290c29u,0x0c191c09u),\nuvec4(0xf6070c39u,0x070b1604u,0x032b1c19u,0x11001100u),\nuvec4(0x80800302u,0x27561211u,0x02160a06u,0x20050e13u),\nuvec4(0x60312011u,0x070b0604u,0x1c093c09u,0xf8091c09u),\nuvec4(0x37081788u,0x074b170bu,0xf817460bu,0x26070b07u),\nuvec4(0x2230f024u,0x22200160u,0x30222400u,0x96771604u),\nuvec4(0x171b071bu,0x2b0d0b66u,0x0bd73877u,0x28070b57u),\nuvec4(0x5bb70807u,0x28091897u,0x0829c807u,0x695c0709u),\nuvec4(0x095c7908u,0x76447607u,0x090c080bu,0x0d090c07u),\nuvec4(0x0114031eu,0x90030100u,0x00048001u,0x07161402u),\nuvec4(0x03020426u,0x05031e0du,0x21021501u,0x01701105u),\nuvec4(0x16070620u,0x08392c09u,0xf8491c09u,0x0d2b47a8u),\nuvec4(0x07060a0bu,0x47f8170bu,0x01300246u,0x12500150u),\nuvec4(0x31000160u,0x50121410u,0x162b1716u,0x76070b17u),\nuvec4(0x0b0d070au,0x07160b17u,0x274b270bu,0x57185708u),\nuvec4(0x1917f70bu,0x670b2718u,0x370b076bu,0x090c0748u),\nuvec4(0x2c191708u,0x07593819u,0x1c090c08u,0x273948e9u),\nuvec4(0x34001466u,0x0c090b56u,0x0b070907u,0x1e050e03u),\nuvec4(0x51050122u,0x01021413u,0x07061480u,0x4e03020bu),\nuvec4(0x00110503u,0x11100175u,0x17101160u,0x1c090706u),\nuvec4(0x0c0d1c59u,0x080af829u,0x27980a06u,0x070b263bu),\nuvec4(0x265718f8u,0x21200204u,0x01002140u,0x01502200u),\nuvec4(0x12202110u,0x46041100u,0x0d2b263bu,0x2d2b0756u),\nuvec4(0x170b0d2bu,0x0807f71bu,0x18870807u,0x28273b07u),\nuvec4(0x38473809u,0x38676b17u,0x28090c09u,0x2c0d1c09u),\nuvec4(0x07293809u,0x590c190au,0x0758390cu,0x09082918u),\nuvec4(0x070b190cu,0x0b06071bu,0x07368406u,0x07090c09u),\nuvec4(0x050e0302u,0x131e0110u,0x11200200u,0x02001100u),\nuvec4(0x06242001u,0x3e030224u,0x8511051fu,0x05010503u),\nuvec4(0xa0210503u,0x07160b02u,0x0c491c0bu,0x0c1d0c0du),\nuvec4(0xb81af829u,0x0b0d1b17u,0xf81b0a06u,0x04360b68u),\nuvec4(0x1302b130u,0x31021302u,0x13003120u,0x04160011u),\nuvec4(0x17163b26u,0x0d0b070bu,0x0b0a160bu,0x9b0d2b3du),\nuvec4(0x080708e7u,0x3b071877u,0x58170827u,0x68170807u),\nuvec4(0x18373b17u,0x4c294807u,0x0c1d1c19u,0x08092809u),\nuvec4(0xc91c0907u,0x19880908u,0x170b090cu,0x1b090d09u),\nuvec4(0x0716a407u,0x03020b19u,0x0103051eu,0x0f000500u),\nuvec4(0x0406131eu,0x00010002u,0x04021414u,0x0f5e2312u),\nuvec4(0x003155f5u,0x16028011u,0x0c1d0907u,0x292d2c39u),\nuvec4(0x2b27b8f8u,0x0b06070du,0x18096807u,0x56377817u),\nuvec4(0x10812002u,0x02031241u,0x00010061u,0x04012503u),\nuvec4(0x16040206u,0x0726170bu,0x070d2b09u,0x1d0b060au),\nuvec4(0x172b371bu,0x570bd70bu,0x074b8718u,0x0768372bu),\nuvec4(0x393857a8u,0x098c196cu,0x49f90708u,0x29280728u),\nuvec4(0x0b27090cu,0x070b170du,0x060406a4u,0x1e130709u),\nuvec4(0x0005032fu,0x032e2311u,0x06040302u,0x051fae04u),\nuvec4(0x952f350fu,0x0531250fu,0x04124071u,0x1d1c0706u),\nuvec4(0x0d0c0d5cu,0xd8f8190cu,0x3b070b07u,0x08078807u),\nuvec4(0x07061789u,0x3014460bu,0x25212531u,0x22010203u),\nuvec4(0x05210061u,0x0001050fu,0x66040012u,0x0b173b07u),\nuvec4(0x38170b1du,0x38273807u,0x0b273827u,0x1d3b0df7u),\nuvec4(0x2778270bu,0x093817c8u,0x2c0d4c0du,0x0c0d2c29u),\nuvec4(0x18895c09u,0x17180789u,0x09081918u,0x0b07090cu),\nuvec4(0x06171629u,0x0d0b16b4u,0x1f0e3f0eu,0x15130201u),\nuvec4(0x4f0e5e2fu,0x25cf0305u,0x650f451fu,0x00310001u),\nuvec4(0x00010011u,0x07121021u,0x0d0c0719u,0x0d2c091cu),\nuvec4(0x18190d0cu,0xf8090819u,0x07281a38u,0x17980708u),\nuvec4(0x27062728u,0x56172614u,0x10112004u,0x25012501u),\nuvec4(0x12030251u,0x45210541u,0x07d61402u,0x2728071bu),\nuvec4(0x09280728u,0x2b17c807u,0x0b170b87u,0x0b5d0b0du),\nuvec4(0xf8475817u,0x0d3c0928u,0x0d0c0d0cu,0x4c29ac39u),\nuvec4(0x28092819u,0x18373829u,0x0b0d0b29u,0x09161907u),\nuvec4(0x0274160bu,0x0d031604u,0x0e032f0eu,0x03050e1fu),\nuvec4(0x130f030eu,0x1f03350fu,0x0f031f23u,0x8f459f03u),\nuvec4(0x71150165u,0x20021012u,0x09070602u,0x899c0b07u),\nuvec4(0x78f80aa8u,0x16570817u,0x0b373607u,0x30042604u),\nuvec4(0x95110004u,0x02010501u,0x05511200u,0x14006501u),\nuvec4(0x2b270b96u,0x38171807u,0x59380907u,0x1b375807u),\nuvec4(0x1b370b37u,0x38070b9du,0x98271b17u,0x0c293839u),\nuvec4(0xbc093c3du,0x68294c29u,0x08175829u,0x071d1b19u),\nuvec4(0x070b1629u,0x03124416u,0x1d070402u,0x2f0e4f0eu),\nuvec4(0x1e03050eu,0x0e430e03u,0x15df231fu,0x008195cfu),\nuvec4(0x11000102u,0x09070620u,0x391c090bu,0x0ad8493cu),\nuvec4(0x07161748u,0x271817f8u,0x27081756u,0x0624460bu),\nuvec4(0x95010204u,0x75112241u,0x0433350fu,0x2b070b36u),\nuvec4(0x28170b17u,0x47294817u,0x090c071bu,0x471b8708u),\nuvec4(0x170b9d4bu,0x07080718u,0x2998072bu,0x09081918u),\nuvec4(0x09280a08u,0x290c2d0cu,0x393c299cu,0x58172968u),\nuvec4(0x0b1d1b17u,0x090c0907u,0x07060407u,0x22030416u),\nuvec4(0x04000203u,0x0e0d0402u,0x2e022e9fu,0x0f130e03u),\nuvec4(0x1f130e03u,0x05ffff0eu,0x2071351fu,0x06025001u),\nuvec4(0x090c091bu,0x494c0928u,0x160708f8u,0x19d8360au),\nuvec4(0x07081708u,0x0b07860bu,0x04560b07u,0x45011226u),\nuvec4(0x00110031u,0x55213201u,0x0433650fu,0x2b0d0b26u),\nuvec4(0x08071807u,0x1c190807u,0x37091c1du,0x0918071bu),\nuvec4(0x8b09070cu,0x1b0d2b17u,0x2bad0b07u,0xf8073b37u),\nuvec4(0x290c0908u,0x0908090cu,0x091c1d0cu,0x193c3d2cu),\nuvec4(0x0938791cu,0x3708091cu,0x084b1918u,0x06140729u),\nuvec4(0x02130407u,0x12000130u,0x6f150e0du,0x130e1f1eu),\nuvec4(0x2f0e0f2eu,0x1f1e032eu,0x65dfff0eu,0x40121081u),\nuvec4(0x091c1704u,0x495c2918u,0x28f81908u,0x38171817u),\nuvec4(0x071b1807u,0x172b1728u,0x14c61706u,0x11651302u),\nuvec4(0x11100115u,0x25310022u,0x0413c501u,0x071b0a06u),\nuvec4(0x3d090748u,0x090c1d0cu,0x09072b37u,0x2b071918u),\nuvec4(0x071d0b17u,0x0d0b0a06u,0x060b3d5bu,0x271b2d2au),\nuvec4(0x68471b06u,0x480a281au,0x1c28191cu,0x5c090c1du),\nuvec4(0x18993c1du,0x09670849u,0x19171b27u,0x16040207u),\nuvec4(0x40020407u,0x1e030214u,0x1e5f250fu,0x030f0e1fu),\nuvec4(0x5f1e0f0eu,0xff8e5f0eu,0x0031754fu,0x40024001u),\nuvec4(0x190b0706u,0x699c0918u,0x060708f8u,0x280a2618u),\nuvec4(0x070d2b07u,0x07091708u,0x073b071bu,0x030213c6u),\nuvec4(0x21650f05u,0x01220140u,0x0fc52100u,0x06040345u),\nuvec4(0x08070d07u,0x0d090829u,0x0d0b170cu,0x2709170bu),\nuvec4(0x0d49073bu,0x1a060d0bu,0x06071b07u,0x370b1d07u),\nuvec4(0x1b362d0bu,0x26072b1du,0x0a58373bu,0x0d0c0948u),\nuvec4(0x08090c09u,0x0c19180au,0x8c0d0c19u,0x290809f9u),\nuvec4(0x09085708u,0x1b070807u,0x020b1907u,0x16041604u),\nuvec4(0x04021002u,0x0d0b0406u,0x0f250f1eu,0x0f4e3f03u),\nuvec4(0x0f0e130eu,0xae1f5f1eu,0x21756fffu,0x06400170u),\nuvec4(0x5c090c17u,0x090d4c0du,0x07f8391cu,0x0a162806u),\nuvec4(0x17083728u,0x06042b19u,0x04070b07u,0x13020436u),\nuvec4(0x0a260402u,0x00010302u,0x11034501u,0x11100105u),\nuvec4(0x02212230u,0x13151321u,0x050f1315u,0x06113501u),\nuvec4(0x08071b07u,0x0c090c09u,0x0b09170du,0x060a0b0du),\nuvec4(0x19372907u,0x0b0d1b17u,0x04020416u,0x0b220b07u),\nuvec4(0x1d073817u,0x1d072607u,0x170b080bu,0x3b160a08u),\nuvec4(0x1d0ca837u,0x4978190cu,0xf95c090cu,0x08090c19u),\nuvec4(0x08191847u,0x030b1937u,0x06040200u,0x02040617u),\nuvec4(0x0e2d1604u,0x130e232fu,0x03055f3eu,0x1e030f0eu),\nuvec4(0x4e031e4fu,0x1e0f0e0fu,0x01456fffu,0x02606105u),\nuvec4(0x07061001u,0x0c290c09u,0x1c0d0c19u,0x2c0d1c09u),\nuvec4(0xf8090c19u,0x081a3816u,0x08171607u,0x070b1719u),\nuvec4(0x160b0726u,0x2314060au,0x02130102u,0x05110326u),\nuvec4(0x01007503u,0x42102110u,0x01030210u,0x00010305u),\nuvec4(0x04011543u,0x14270806u,0x28070b06u,0x070b0709u),\nuvec4(0x0706021du,0x07160719u,0x07491c09u,0x1204271bu),\nuvec4(0x04000110u,0x02000400u,0x071c0d0cu,0x0a1d0708u),\nuvec4(0x080b0716u,0x1b071817u,0x08372b07u,0x09580907u),\nuvec4(0x19081918u,0x090c2d1cu,0x08095c0du,0x1c090c49u),\nuvec4(0x0c790849u,0x18271819u,0x09071907u,0x19070b07u),\nuvec4(0x0102030bu,0x29060203u,0x0d040617u,0x8f150f1eu),\nuvec4(0x5f0e0f0eu,0x0f0e0305u,0x0e0f2e03u,0x0f7e0e0fu),\nuvec4(0x0e4f2e03u,0x758f134fu,0x10113091u,0x092c1906u),\nuvec4(0x390c090cu,0x07d8497cu,0x48073806u,0x17091807u),\nuvec4(0x0456070bu,0x01053312u,0x13120135u,0x00651f11u),\nuvec4(0x10310511u,0x01002132u,0x2f330513u,0x07041002u),\nuvec4(0x3c491c08u,0x12030407u,0x17061400u,0x0426070cu),\nuvec4(0x37391c09u,0x34200204u,0x2c2d1430u,0x04060a09u),\nuvec4(0x071b1706u,0x073b170bu,0x19380728u,0x091c190cu),\nuvec4(0x0d0c9d1cu,0x08070807u,0x0c090c09u,0x0c290c09u),\nuvec4(0x08092c09u,0x38090c99u,0x29380b07u,0x031b040bu),\nuvec4(0x04012002u,0x07090b07u,0x0e1d030bu,0x0eaf151fu),\nuvec4(0x03251f03u,0x0f0e0305u,0x1f1e5e13u,0x0f2e0f0eu),\nuvec4(0xaf0e0f0eu,0x7195af03u,0x06110230u,0xfc091c09u),\nuvec4(0x17b8491cu,0x0617180au,0x0709280au,0x2b070918u),\nuvec4(0x43060a26u,0x0f350f25u,0x00010315u,0x150f0501u),\nuvec4(0x1501451fu,0x22011011u,0x31002100u,0x1f050f33u),\nuvec4(0x07041205u,0x18192819u,0x30030b29u,0x07140b04u),\nuvec4(0x06170c09u,0x1c070604u,0x27091c09u,0x34373406u),\nuvec4(0x2c070600u,0x090d0c09u,0x17160406u,0x1d090708u),\nuvec4(0x0938373bu,0x2c3d1c6du,0x18490c29u,0x08292c09u),\nuvec4(0x0c390c59u,0x07193c29u,0x18070d0bu,0x030d0c29u),\nuvec4(0x04401112u,0x1e032407u,0x03052fffu,0x1f03053fu),\nuvec4(0x3f3e1f1eu,0xff0eaf2eu,0x0210a195u,0x0c090410u),\nuvec4(0x8c198c09u,0xb8278839u,0x071b2709u,0x4f451356u),\nuvec4(0x21052f05u,0x652f2510u,0x22011011u,0x01152100u),\nuvec4(0x04133f63u,0x69080907u,0x02030407u,0x07063004u),\nuvec4(0x07190b32u,0x0c070604u,0x072b0c09u,0x2c09470bu),\nuvec4(0x0d0b2729u,0x0c08092cu,0x3726090du,0x0708472bu),\nuvec4(0x180c0948u,0x3d0c0d0cu,0x8948190cu,0x290c893cu),\nuvec4(0x291c094cu,0x0b0d0b07u,0x032c2907u,0x07040280u),\nuvec4(0xff1e0314u,0x053f034fu,0x2f250e02u,0x1e1f1e2eu),\nuvec4(0x23bf5e4fu,0x0f03153fu,0x05131523u,0x65030513u),\nuvec4(0x07040001u,0x0dac090cu,0x98490d4cu,0x2709a827u),\nuvec4(0x060a0b0du,0x25230224u,0x110543bfu,0x11650f25u),\nuvec4(0x02000410u,0x05210214u,0x01051f93u,0x18192706u),\nuvec4(0x02071c09u,0x01040604u,0x0b070410u,0x04022103u),\nuvec4(0x0914021bu,0x0b07090cu,0x2c192716u,0x0c0d2c29u),\nuvec4(0x091d3c0du,0x1604071du,0x474b070bu,0x29181918u),\nuvec4(0x991c2d1cu,0x491c4948u,0x091c892cu,0x071b0d0bu),\nuvec4(0x1b090706u,0x030b1c09u,0x00122430u,0x04070914u),\nuvec4(0x7fff0e03u,0x0f3e0f0eu,0x2e1f5f15u,0x2f3e034fu),\nuvec4(0x030e3f13u,0x033e031eu,0x1305030fu,0x0021957fu),\nuvec4(0x0d090601u,0x4c091c09u,0x2c1d5c09u,0x68578829u),\nuvec4(0x0d0b0719u,0x2213160bu,0x35ff6501u,0x0503151fu),\nuvec4(0x20010503u,0x02142204u,0x03052100u,0x13055305u),\nuvec4(0x0b070405u,0x09180938u,0x04060407u,0x04100112u),\nuvec4(0x00020b07u,0x0b061211u,0x090c1412u,0x0706140bu),\nuvec4(0x2c096c99u,0x0b09070du,0x0b0a0614u,0x28375b0du),\nuvec4(0x1d0c5d09u,0x3c1918b9u,0x2c3d0c0du,0x2d0b2ca9u),\nuvec4(0x060a070bu,0x170b260bu,0x32101214u,0x1b071400u),\nuvec4(0xff0e0304u,0x1e23152fu,0x030f3e0fu,0x0e2f3f15u),\nuvec4(0x2e133f03u,0x130e332fu,0x0f3e030eu,0x0f030f1eu),\nuvec4(0x133f0305u,0x853f030fu,0x04010001u,0x090b0d07u),\nuvec4(0x4c0d6c0du,0xa8390c1du,0x0c074857u,0x06072b07u),\nuvec4(0x21000203u,0xff231f35u,0x0521352fu,0x12140011u),\nuvec4(0x05202204u,0x0e050f23u,0x01030f05u,0x04130503u),\nuvec4(0x09172807u,0x020b090cu,0x04025013u,0x030b4406u),\nuvec4(0x090c0732u,0x0b071407u,0x5c291c19u,0x090d2c19u),\nuvec4(0x0406072cu,0x0c180d26u,0x0d285709u,0xa96d0c19u),\nuvec4(0x096c2d1cu,0x291c1d0cu,0x190c590cu,0x0a072d0bu),\nuvec4(0x1b260a16u,0x00020419u,0x00031402u,0x0b090624u),\nuvec4(0x4f1e0406u,0x01058f2eu,0x0f130500u,0x0e032f03u),\nuvec4(0x0500052fu,0x0e331f2fu,0x0e0f0e23u,0x2e0f7e3fu),\nuvec4(0xa5bf235fu,0x09040100u,0x0d0c090bu,0x392c1dacu),\nuvec4(0x19484798u,0x070d0b17u,0x0002030au,0x4f250115u),\nuvec4(0x15df0315u,0x00014503u,0x32041011u,0x11233203u),\nuvec4(0x00031523u,0x01150302u,0x081b1704u,0x020b1c09u),\nuvec4(0x06442001u,0x0b172607u,0x00120103u,0x0b090203u),\nuvec4(0x06040604u,0x193c0907u,0x18090c1du,0x091d0c29u),\nuvec4(0x360b0d2cu,0x073c090du,0x2c2d0998u,0x2c491c1du),\nuvec4(0x0c0d8c0du,0x2c1d1c1du,0x0c192c09u,0x3d0b0c19u),\nuvec4(0x361b070bu,0x0207091bu,0x00120610u,0x19070406u),\nuvec4(0x0e030407u,0x555f2e5fu,0x1f030f13u,0x2f031f05u),\nuvec4(0x15010005u,0x0f250f0fu,0x2f030f03u,0x2fffff9eu),\nuvec4(0x02000145u,0x0d1b0904u,0x095c192cu,0x192c0d0cu),\nuvec4(0x07380748u,0x1938271bu,0x0d0b0718u,0x0003060bu),\nuvec4(0x453f1521u,0x03bf230fu,0x31050125u,0x11420410u),\nuvec4(0x33053302u,0x00050f0eu,0x04025302u,0x03121b06u),\nuvec4(0x39171402u,0x0b170907u,0x04020406u,0x11000306u),\nuvec4(0x440b1310u,0x1d0b032du,0x78090704u,0x2c1b0d6cu),\nuvec4(0x19681c29u,0x1c5d0c08u,0x37094c2du,0x0d0c0709u),\nuvec4(0x090c0d5cu,0x0b595c2du,0x0b170b0du,0x1b46070du),\nuvec4(0x16140217u,0x2c070604u,0x1e03040du,0x0e0f0e5fu),\nuvec4(0x052f0e0fu,0x050f0510u,0x131f0e13u,0x130f0305u),\nuvec4(0x0503051fu,0x05011500u,0x03010001u,0x7e1f8e0fu),\nuvec4(0x0145dfffu,0x27040100u,0x39bc390cu,0x072b4738u),\nuvec4(0x19080728u,0x1d0b0718u,0x05210317u,0x3f13457fu),\nuvec4(0x00018523u,0x03220021u,0x00010022u,0x23050301u),\nuvec4(0x0004014fu,0x20013503u,0x04061706u,0x08191716u),\nuvec4(0x070b0759u,0x04060416u,0x03121021u,0x20130224u),\nuvec4(0x07580744u,0x094c0918u,0x390c0d0cu,0x0908093cu),\nuvec4(0x170cbd1cu,0x5c199739u,0x4c0d0c1du,0x07091c09u),\nuvec4(0x66273b19u,0x361b0907u,0x0b2c0927u,0x5e5f1e04u),\nuvec4(0x0503152fu,0x0e130501u,0x0304055fu,0x11050f15u),\nuvec4(0x11030105u,0x4f7e1302u,0xff0e1f1eu,0x1503353fu),\nuvec4(0x350f251fu,0x04110501u,0x9c590c07u,0x08075839u),\nuvec4(0x18172b07u,0x08190807u,0x071d0b17u,0x25020306u),\nuvec4(0x130f359fu,0x0501932fu,0x03121021u,0x2f533132u),\nuvec4(0x11130015u,0x01050125u,0x190b0604u,0x1d086917u),\nuvec4(0x460b0719u,0x40110204u,0x0b502302u,0x07040203u),\nuvec4(0x07380908u,0x4c08070bu,0x38090809u,0x3c3d2c69u),\nuvec4(0x0c09e75du,0x1c191c09u,0x08192c4du,0x1d4b0729u),\nuvec4(0x26071b66u,0x170b0907u,0x2e022b09u,0x5e1f0e1fu),\nuvec4(0x0110054fu,0x132f5e03u,0x0115110eu,0x0e430520u),\nuvec4(0x0f030e6fu,0xff3e3f0eu,0x000185bfu,0x090b1402u),\nuvec4(0x0807090cu,0x48397c19u,0x1b0d3b17u,0x0b173817u),\nuvec4(0x0a060b0du,0x5f250203u,0x03150365u,0x05732f0eu),\nuvec4(0x02310511u,0x10110213u,0x53000201u,0x0100013fu),\nuvec4(0x11050110u,0x06000500u,0x0908070au,0x0b18790cu),\nuvec4(0x26170b2du,0x01200204u,0x01126002u,0x07140220u),\nuvec4(0x0748090cu,0x6c0b0d0bu,0x08090c69u,0x0c0d0c09u),\nuvec4(0x0c0d0c3du,0x3d090809u,0x1907193cu,0x092c3967u),\nuvec4(0x1d1c0d1cu,0x2b07096cu,0x27860a4du,0x0b170b09u),\nuvec4(0x03040213u,0x1f0e0f1eu,0x3f0e0f4eu,0x13000105u),\nuvec4(0x130e2f6eu,0x00310305u,0x0f030f03u,0x132e7f23u),\nuvec4(0x2e0f1e0fu,0x01a55fffu,0x04023115u,0x0d090400u),\nuvec4(0x0c28070bu,0x1c091c09u,0x2b274829u,0x1b070b0du),\nuvec4(0x071d1b37u,0x05030416u,0x5501157fu,0x633f0e13u),\nuvec4(0x02004105u,0x00115203u,0x01000301u,0x01052f23u),\nuvec4(0x03120100u,0x06200115u,0x2c091807u,0x38190c19u),\nuvec4(0x08070b17u,0x170b0d07u,0x04200406u,0x02040716u),\nuvec4(0x44200110u,0x07680906u,0x190b1d0bu,0x592c0d0cu),\nuvec4(0x0d0c291cu,0x0d1c0d1cu,0x1d092817u,0x07095c09u),\nuvec4(0x07190719u,0x07090709u,0x0d3c0d1cu,0x091c1d1cu),\nuvec4(0x0b27190cu,0x071d1b2du,0x090b760au,0x01231407u),\nuvec4(0x1e031400u,0x2e1f0e0fu,0x0110056fu,0x131f8e13u),\nuvec4(0x0e130f05u,0x1e3f0323u,0x3e132e6fu,0x33df1e0fu),\nuvec4(0x21e50305u,0x04121105u,0x070d0c07u,0x391c0918u),\nuvec4(0x2748290cu,0x2b170d2bu,0x160d1b27u,0x01000214u),\nuvec4(0x03256f05u,0x0e5f3325u,0x05010543u,0x32031211u),\nuvec4(0x25010511u,0x4f130400u,0x00010075u,0x09180a14u),\nuvec4(0x48490c0du,0x0b174837u,0x06140604u,0x14070837u),\nuvec4(0x0c561400u,0x07380928u,0x0c090b3du,0x3c090c0du),\nuvec4(0x0c090809u,0x4c192809u,0x0c2d2837u,0x3c890c39u),\nuvec4(0x096d0c0du,0x093c0907u,0x3d3b170bu,0x07046607u),\nuvec4(0x21131209u,0x1e031200u,0x2e0f2e0fu,0x051f1e0fu),\nuvec4(0x02010001u,0x2f4e3f13u,0x034f0513u,0x133f0503u),\nuvec4(0x0e030e8fu,0x8f3e1f03u,0x13453f2eu,0x01050195u),\nuvec4(0x12011015u,0x06070904u,0x2c090809u,0x08190c19u),\nuvec4(0x3b073819u,0x4b1d2b0du,0x240a0b0du,0x05000103u),\nuvec4(0x2e13557fu,0x0e0f0e1fu,0x12112543u,0x05031213u),\nuvec4(0x13011543u,0x0501057fu,0x04100230u,0x08093c07u),\nuvec4(0x68377809u,0x16170b07u,0x0708271bu,0x07040708u),\nuvec4(0x280c272du,0x4d074809u,0x5c0d0c09u,0x19381918u),\nuvec4(0x0908573cu,0x27090c1du,0x27090739u,0x2d0c1d19u),\nuvec4(0x28093d0cu,0x3b2c0907u,0x1b1d0b07u,0x1456070du),\nuvec4(0x03020706u,0x22110325u,0x0f6e0f1eu,0x33051f2eu),\nuvec4(0x034f3e4fu,0x053f031fu,0x1e5fff03u,0x131f0e0fu),\nuvec4(0x151f032eu,0xd513452fu,0x16171241u,0x2c193c18u),\nuvec4(0x0b173809u,0x27060b5du,0x0b1d0b0du,0x03022406u),\nuvec4(0x0f257f25u,0x2e033e13u,0x02212543u,0x020015b3u),\nuvec4(0x0f155f03u,0x01000105u,0x04000410u,0x191c0706u),\nuvec4(0x0b0798f8u,0x07083b1du,0x1b070b1du,0x18291807u),\nuvec4(0x0b075809u,0x09070b0du,0x1908076cu,0x091c2928u),\nuvec4(0x1847090cu,0x190c3d07u,0x190b0927u,0x2d0c090du),\nuvec4(0x2d0c0d1cu,0x0917280cu,0x3b0d1b1cu,0x0b0d1709u),\nuvec4(0x06145607u,0x25030e02u,0x12010503u,0x8e1f0e13u),\nuvec4(0x0e0f0e3fu,0x0e2f1e0fu,0x134f1e0fu,0x051f155fu),\nuvec4(0x038e13efu,0x4523a54fu,0x00314513u,0x04030102u),\nuvec4(0x0b070907u,0x3c090807u,0x0b271839u,0x0726070du),\nuvec4(0x0204070bu,0x0a060a06u,0x24061d07u,0x01150f02u),\nuvec4(0x1f057f05u,0x05439e03u,0x25c31211u,0x40355f03u),\nuvec4(0x190a1614u,0x7b17b8f8u,0x1b08071du,0x19080708u),\nuvec4(0x17980908u,0x090b060au,0x0c181d4cu,0x191c0809u),\nuvec4(0x1b19070du,0x0c094827u,0x0c092c1du,0x0c1d0c2du),\nuvec4(0x092d0c6du,0x291c0718u,0x09070b0du,0x070b072bu),\nuvec4(0x3446070bu,0x05020513u,0x1201150fu,0x0f1e0003u),\nuvec4(0x0f1e2f5eu,0x3f0e0f1eu,0x2f2e1f0eu,0x2f0e0f0eu),\nuvec4(0x050f1f15u,0x652f0213u,0x9f2e433fu,0x130513f5u),\nuvec4(0x31150125u,0x04030002u,0x0b04170au,0x093c0907u),\nuvec4(0x180c090cu,0x0b0d0b07u,0x02030466u,0x0b0a1614u),\nuvec4(0x24060b0du,0xaebf151fu,0x02010553u,0x154f25f3u),\nuvec4(0x00220011u,0xf8171602u,0x570b27f8u,0x070b0708u),\nuvec4(0x0b090708u,0x68190839u,0x090b260bu,0x292c090cu),\nuvec4(0x1c09281cu,0x1748074bu,0x2d0c0718u,0x090c092cu),\nuvec4(0x7d1c1d1cu,0x491c190cu,0x0d0b070bu,0x560b291bu),\nuvec4(0x03020614u,0x03053300u,0x03000105u,0x1f0e0300u),\nuvec4(0x0f1e0f4eu,0x1f2e1f6eu,0x031f7f6eu,0x2f0e0305u),\nuvec4(0x33750115u,0x650345dfu,0x75230503u,0x05030521u),\nuvec4(0x0b040301u,0x070b1409u,0x090c192cu,0x0d17180cu),\nuvec4(0x2032340au,0x0b160401u,0x04160b0du,0x6f151f02u),\nuvec4(0x63be2f03u,0x0ec30201u,0x1f050f23u,0x01151f05u),\nuvec4(0x06220110u,0xf8f8070bu,0x17088738u,0x07040718u),\nuvec4(0x0b095869u,0x0c290726u,0x09071809u,0x1908090cu),\nuvec4(0x48172b1cu,0x09070b67u,0x070c7d0cu,0x5d0c0d08u),\nuvec4(0x0907392cu,0x1b070b07u,0x560c2907u,0x3e031402u),\nuvec4(0x02013315u,0x0e030003u,0x8e4f030fu,0x2e1f3e0fu),\nuvec4(0x1f6f5e0fu,0x00050315u,0x03050135u,0x43050f35u),\nuvec4(0xd503a5efu,0x17040351u,0x3c090b14u,0x17090c19u),\nuvec4(0x04060d0bu,0x26504200u,0x0503241du,0x137f1500u),\nuvec4(0x0273ae0fu,0x4f335e93u,0x06400115u,0x3817d817u),\nuvec4(0x4817e819u,0x08092817u,0x0c071409u,0x361b5859u),\nuvec4(0x0c070617u,0x0b790809u,0x08070b0du,0xdb374807u),\nuvec4(0x3d191c07u,0x592c0d0cu,0x19171917u,0x0436070cu),\nuvec4(0x02040203u,0x1315030eu,0x130e0305u,0x00020005u),\nuvec4(0x1f030213u,0x0f9e0f1eu,0x0f1e0f1eu,0x2f5e0f3eu),\nuvec4(0x054f0f03u,0x02041213u,0x1f150310u,0xcf250325u),\nuvec4(0x51d503a5u,0x06030200u,0x0b040217u,0x192c0d09u),\nuvec4(0x0d0b081cu,0x01030206u,0x01201100u,0x070a1620u),\nuvec4(0x0b06040du,0x038f2502u,0x0f0e0f0eu,0x1105339eu),\nuvec4(0x038e8302u,0x152f130fu,0x0b163001u,0x0c3928f8u),\nuvec4(0xf8091819u,0x07180728u,0x07140708u,0x1b782918u),\nuvec4(0x170a1607u,0x0b275b04u,0x68271d17u,0x294d4b17u),\nuvec4(0x080d0c07u,0x0d2c1d19u,0x290c192cu,0x29170c17u),\nuvec4(0x1422260bu,0x050e0d03u,0x051e5301u,0x0e131220u),\nuvec4(0x0e2f0e23u,0x0e3f0e1fu,0x4e0fbe0fu,0x53054f1fu),\nuvec4(0xcfb50312u,0x11c503a5u,0x04054105u,0x04020417u),\nuvec4(0x080d6c0bu,0x50030417u,0x20040001u,0x06142604u),\nuvec4(0x1502060bu,0x0e0f1e8fu,0x7e0f0e1fu,0x83020133u),\nuvec4(0x40156f8eu,0x48f80716u,0xf8090869u,0x07081728u),\nuvec4(0x07140708u,0x070b6869u,0x04170416u,0x23120312u),\nuvec4(0x1d070602u,0x07080d1bu,0x4d0b5788u,0x09270c09u),\nuvec4(0x394c0d1cu,0x09173917u,0x07160b0cu,0x1e02340bu),\nuvec4(0x02000500u,0x03050e43u,0x03020001u,0x0e1f030eu),\nuvec4(0x032f0e0fu,0x4f8e038fu,0x456f3f1eu,0x05011223u),\nuvec4(0x1f050100u,0x9f251105u,0x15f52f13u,0x14111071u),\nuvec4(0x04000307u,0x12177c07u,0x04160450u,0x16142210u),\nuvec4(0x03020614u,0xaee36effu,0x2001156fu,0xf8170604u),\nuvec4(0x590c1948u,0x072819d8u,0x07180718u,0x08690b14u),\nuvec4(0x0d0b3809u,0x0709072bu,0x01000204u,0x16121002u),\nuvec4(0xd8173d0bu,0x073d0b07u,0x17080c09u,0x0b27198cu),\nuvec4(0x0d191b19u,0x07060a0bu,0xb32e331du,0x2e120005u),\nuvec4(0x0e030e2fu,0x03050f03u,0x230f032fu,0x0f6e0f05u),\nuvec4(0x2f0e2f0eu,0x756f0f0eu,0x00330513u,0x2f250125u),\nuvec4(0x2e030f03u,0x05033f23u,0x0513852fu,0x00010091u),\nuvec4(0x02010312u,0x5c0d0904u,0x0100021bu,0x04000110u),\nuvec4(0x24000436u,0x1236041bu,0x737edf03u,0x037e5302u),\nuvec4(0x01058f0eu,0x07060420u,0x0c0958f8u,0x28191829u),\nuvec4(0x58092809u,0x38172819u,0x59072407u,0x17280908u),\nuvec4(0x081b071bu,0x12200229u,0x17061400u,0x780b0d1bu),\nuvec4(0x08190809u,0x1c0b4d17u,0x197c1917u,0x0b170b17u),\nuvec4(0x1a071b1du,0x030d0706u,0x2e13055eu,0x05030f23u),\nuvec4(0x22010503u,0x3f0e1f2eu,0x130e1f03u,0x2e2f033fu),\nuvec4(0x433f0e03u,0x5f130f1fu,0x01550345u,0x13000302u),\nuvec4(0x131e2305u,0x030f030fu,0xb59f031eu,0x10012091u),\nuvec4(0x5c070401u,0x020b0d09u,0x060a4630u,0x061b0402u),\nuvec4(0x1b070d0bu,0x00320402u,0x2f1e9f03u,0x2305331eu),\nuvec4(0x135e4322u,0x01156f35u,0x170b0620u,0x481958f8u),\nuvec4(0x08091819u,0x08f80c19u,0x07140709u,0x1b075859u),\nuvec4(0x07182b07u,0x1203100du,0x16020400u,0x0d09070bu),\nuvec4(0x0928170bu,0x07080718u,0x0b080708u,0x0b06072du),\nuvec4(0x0b07090cu,0x090b6c19u,0x02465b17u,0x330b0203u),\nuvec4(0x2e050f1eu,0x2305132fu,0x03020105u,0x2f0e0312u),\nuvec4(0x0f034f0eu,0x0f031f03u,0x1f0e2f13u,0x01032f1eu),\nuvec4(0x00050300u,0x5f230305u,0x13753305u,0x0e030402u),\nuvec4(0x01958fffu,0x0120a105u,0x09060300u,0x0407095cu),\nuvec4(0x16011001u,0x020b2d07u,0x07120133u,0x0b02042bu),\nuvec4(0x01030403u,0x052f0e7fu,0x1325231fu,0x63020305u),\nuvec4(0x4f25135eu,0x04300115u,0x170b0d06u,0x2809c8f8u),\nuvec4(0x28f8092cu,0x0c09140bu,0x5b275839u,0x02000307u),\nuvec4(0x07041240u,0x980b170bu,0x160a1b27u,0x171c071au),\nuvec4(0x0b391c29u,0x0706071du,0x0304660du,0x13020100u),\nuvec4(0x0f031e0fu,0x3e0f0e03u,0x0115331fu,0x05120302u),\nuvec4(0x1e1f050eu,0x030f0e0fu,0x0e5f7305u,0x0302032fu),\nuvec4(0x03031210u,0x2f030f05u,0x2f431205u,0x13010035u),\nuvec4(0x8fff0204u,0x1122b1b5u,0x07097c04u,0x06141002u),\nuvec4(0x030b1d1bu,0x14201115u,0x0002032bu,0x4f6e0322u),\nuvec4(0x15530e03u,0x03120100u,0x1f5e2305u,0x50116513u),\nuvec4(0x270b0706u,0x1c09f8f8u,0x0718f809u,0x1c07140bu),\nuvec4(0x1b277819u,0x90020327u,0x07580736u,0x0d0b0738u),\nuvec4(0x2402040bu,0x07090b06u,0x190c0908u,0x090c2907u),\nuvec4(0x0b26070du,0x04020436u,0x03122103u,0x5e032e0fu),\nuvec4(0x0005432fu,0x05120302u,0x2305030eu,0x050f0e1fu),\nuvec4(0x13051f03u,0x056f1305u,0x02030103u,0x05023301u),\nuvec4(0x00031033u,0x4f130503u,0x01151f03u,0x0e0d0203u),\nuvec4(0x8fff050fu,0x01109165u,0x01130112u,0x0d4c0703u),\nuvec4(0x140c0d0cu,0x0b060a16u,0x030d0b07u,0x3e231015u),\nuvec4(0x27041203u,0x1f2e020bu,0x1e0f033eu,0x13250f03u),\nuvec4(0x01220125u,0x032e3305u,0x4503051fu,0x0d069001u),\nuvec4(0x58f8072bu,0xf8098819u,0x06070928u,0x1c070602u),\nuvec4(0x04577819u,0x70010003u,0x0b260401u,0x19280758u),\nuvec4(0x1004220bu,0x071b0612u,0x190c090cu,0x072c090cu),\nuvec4(0x0b09160au,0x02031416u,0x03010203u,0x13040201u),\nuvec4(0x6e03051eu,0x1105431fu,0x13010203u,0x2f0e430eu),\nuvec4(0x0e030f13u,0x030f1305u,0x051f1305u,0x02210301u),\nuvec4(0x13030513u,0x02000115u,0x6f030f53u,0x050f2325u),\nuvec4(0x21559fffu,0x10026105u,0x01000102u,0x0c131203u),\nuvec4(0x1c090c29u,0x1d0b170bu,0x031b080bu,0x031e2301u),\nuvec4(0x02140005u,0x0c1b0204u,0x06241b0du,0x4f2e0214u),\nuvec4(0x01252315u,0x1f033e73u,0x06900165u,0xf8071b1du),\nuvec4(0x09e81958u,0x14070cd8u,0x191c0906u,0x030607a8u),\nuvec4(0x02800110u,0x27580926u,0x20031b09u,0x00041004u),\nuvec4(0x090b0604u,0x1907190bu,0x0c070907u,0x070b260bu),\nuvec4(0x13020304u,0x04110011u,0x0f0e0317u,0x4e031e13u),\nuvec4(0x0f43050fu,0x00130001u,0x1f0e0302u,0x139f0301u),\nuvec4(0x101f331fu,0x02010001u,0x01131523u,0x0f053302u),\nuvec4(0x4f050f03u,0xff454f03u,0x0513056fu,0x00513523u),\nuvec4(0x00210001u,0x01001102u,0x0b231002u,0x0b0d3b4cu),\nuvec4(0x020b0807u,0x06240043u,0x0e532204u,0x04030e23u),\nuvec4(0x0f1e0406u,0x231e0f0eu,0x63121315u,0x1f05132eu),\nuvec4(0x01150335u,0x073b0690u,0x18f80728u,0x28079809u),\nuvec4(0x0c07d829u,0x0b160406u,0x0b98190cu,0x00011302u),\nuvec4(0x20015001u,0x07060402u,0x2b075809u,0x04018003u),\nuvec4(0x090b1d0bu,0x17181907u,0x12260709u,0x00030204u),\nuvec4(0x04111001u,0x05030b0cu,0x1e130500u,0x031f2e03u),\nuvec4(0x050f330fu,0x02001300u,0x010f0e03u,0x05030513u),\nuvec4(0x1f055f1eu,0x1f130e03u,0x03011553u,0x0e132f05u),\nuvec4(0x0f031f03u,0x3f030503u,0x0e0fff13u,0xc18533bfu),\nuvec4(0x01130112u,0x1b330210u,0x090c292cu,0x02070807u),\nuvec4(0x36140203u,0x02041214u,0x03010503u,0x20250110u),\nuvec4(0x1e050314u,0x15230e1fu,0x2f631223u,0x453f1305u),\nuvec4(0x04020301u,0x1d143002u,0x1708072bu,0x1908f8f8u),\nuvec4(0x06070cf8u,0x1c070604u,0x1b090859u,0x02030113u),\nuvec4(0x01600110u,0x17060420u,0x0b0d0748u,0x06a0030du),\nuvec4(0x090d071du,0x0827191bu,0x04060709u,0x04021402u),\nuvec4(0x05110302u,0x0b0c0702u,0x2302100eu,0x0305034eu),\nuvec4(0x15230e0fu,0x13001300u,0x0e03050eu,0x030f0e03u),\nuvec4(0x3f1e1f0eu,0x0e030f03u,0x0f131f23u,0x05110503u),\nuvec4(0x3e132f13u,0xff0e8f53u,0x2503355fu,0x1501550fu),\nuvec4(0x02110061u,0x32131203u,0x13110011u,0x0906041du),\nuvec4(0x0b09071cu,0x01322647u,0x02000513u,0x05011001u),\nuvec4(0x1200011fu,0x6f150304u,0x256f33f3u,0x03020401u),\nuvec4(0x0d070430u,0x170b0d1bu,0x0938f8f8u,0x09b81918u),\nuvec4(0x0704160bu,0x4908091cu,0x21300207u,0x01600105u),\nuvec4(0x02000100u,0x38090604u,0xa0131b07u,0x060b0604u),\nuvec4(0x1b09070au,0x070c0957u,0x03021406u,0x01150204u),\nuvec4(0x0d1b0205u,0x0e030e33u,0x15733e0fu,0x03041301u),\nuvec4(0x0f2e030eu,0x1e030f1eu,0x130f0e0fu,0x031f030fu),\nuvec4(0x1f130e3fu,0x03051105u,0x030e030fu,0x4e030e0fu),\nuvec4(0x9f0e1f43u,0x3f137f0eu,0xb1752f85u,0x10510302u),\nuvec4(0x03510001u,0x1d0b0602u,0x1b07093cu,0x04120406u),\nuvec4(0x00110302u,0x25110001u,0x0400011fu,0x01120402u),\nuvec4(0x23055f03u,0x73120302u,0x23254f5eu,0x06200105u),\nuvec4(0xf8075b0du,0xa85928f8u,0x160d0c19u,0x0c0d0c07u),\nuvec4(0x0b0d0c29u,0x00120002u,0x05030112u,0x10117001u),\nuvec4(0x38070604u,0x01020b07u,0x360401a0u,0x0d0b0907u),\nuvec4(0x19271807u,0x2204060cu,0x03010503u,0x04010305u),\nuvec4(0x1f1e260bu,0x1563055eu,0x04020300u,0x1e1f9e03u),\nuvec4(0x0f131f13u,0x050f0e03u,0x1f0e0f1eu,0x0e330105u),\nuvec4(0x4e2f150fu,0x035e9f43u,0xa53fa56fu,0x03211041u),\nuvec4(0x03813031u,0x1907040eu,0x0d07191cu,0x04020607u),\nuvec4(0x01000312u,0x05032100u,0x100f2503u,0x02000204u),\nuvec4(0x5f030204u,0x33223315u,0x030e0305u,0x01752f6eu),\nuvec4(0x0b060100u,0xf8173b0du,0xb84928f8u,0x071d1c09u),\nuvec4(0x2c0d0906u,0x0002030bu,0x13120132u,0x00316005u),\nuvec4(0x07160204u,0xb0030b38u,0x16140214u,0x0b1d0b09u),\nuvec4(0x07092b0du,0x12030709u,0x03010503u,0x04031001u),\nuvec4(0x03070b17u,0x534e230eu,0x00050f0eu,0x03000302u),\nuvec4(0x1f2e031eu,0x1f031f5eu,0x03050305u,0x0e2f1305u),\nuvec4(0x13050e0fu,0x0e0e0f0eu,0x231f1503u,0xff231f2eu),\nuvec4(0x750f158fu,0x0571b52fu,0x02050103u,0x20112001u),\nuvec4(0x00110511u,0x07021301u,0x090b0706u,0x22160d07u),\nuvec4(0x02344011u,0x00010513u,0x03040102u,0x2f451204u),\nuvec4(0x83052305u,0x01755f6eu,0x2b0d0b06u,0x48f8f817u),\nuvec4(0x094cc829u,0x521b0907u,0x15020410u,0x00011302u),\nuvec4(0x00311031u,0x06040204u,0x0908090bu,0x01020b07u),\nuvec4(0x32040190u,0x070b0716u,0x071b1d1bu,0x00020b18u),\nuvec4(0x20012513u,0x1b140b02u,0x4e031f0eu,0x0005630fu),\nuvec4(0x0e0d0312u,0x2f3e030fu,0x15332f3eu,0x1f030f13u),\nuvec4(0x030e2f0eu,0x05030e2eu,0x1f030f13u,0x2f030e03u),\nuvec4(0x1f030503u,0x031fff03u,0x550f451fu,0x3501950fu),\nuvec4(0x052160a1u,0x13051041u,0x070b0704u,0x0302070bu),\nuvec4(0x40010001u,0x14061704u,0x24000122u,0x45020412u),\nuvec4(0x0201254fu,0x031f0543u,0x1e0f2e0fu,0x150f057fu),\nuvec4(0x1d060401u,0xf8f8170bu,0x19b81968u,0x08090d0cu),\nuvec4(0x22140907u,0x06040624u,0x03111304u,0x00059115u),\nuvec4(0x06000204u,0x0b072907u,0x0601a003u,0x16001204u),\nuvec4(0x0917161bu,0x0c08071du,0x0113020bu,0x20050105u),\nuvec4(0x06140604u,0x3f0e0d17u,0x02530f2eu,0x0e032e33u),\nuvec4(0x3e1f2e1fu,0x03051e03u,0x0510150fu,0x3e1e7f23u),\nuvec4(0x2f05233fu,0x3f050305u,0x051fff03u,0xf52f150fu),\nuvec4(0x61350105u,0x01302100u,0x11032100u,0x01100105u),\nuvec4(0x06040330u,0x31020b07u,0x1b072420u,0x06140b17u),\nuvec4(0x04004604u,0x6f151103u,0x13154305u,0x137e3305u),\nuvec4(0x0401154fu,0x170d0706u,0xf817b819u,0x0c1948f8u),\nuvec4(0x09080c1du,0x02374407u,0x02130213u,0x05812501u),\nuvec4(0x00020001u,0x090b0602u,0x020d0b08u,0x0206a001u),\nuvec4(0x16040103u,0x07260b07u,0x061b2d0bu,0x11050302u),\nuvec4(0x04020612u,0x1b071b26u,0x0e1f031eu,0x430f0e0fu),\nuvec4(0x153e030eu,0x5f0e2f13u,0x1f030f03u,0x03150302u),\nuvec4(0x6f053312u,0x53158e1eu,0x0f050315u,0x053f0513u),\nuvec4(0x2f35ef03u,0x311501b5u,0x33121103u,0x00111001u),\nuvec4(0x10210521u,0x20011001u,0x0c0b0403u,0x1001040bu),\nuvec4(0x4b061004u,0x0b090729u,0x06071b17u,0x25201204u),\nuvec4(0x152f051fu,0x05031553u,0x2f630e33u,0x10050f05u),\nuvec4(0x0b060a16u,0x27a80907u,0x09380988u,0x4c1958f8u),\nuvec4(0x17081918u,0x0708091cu,0x15010302u,0x15130213u),\nuvec4(0x00012551u,0x07040012u,0x070b0709u,0x04a00504u),\nuvec4(0x04000302u,0x36070b16u,0x161d0b07u,0x52001304u),\nuvec4(0x02140b06u,0x1e061b07u,0x3e0f0e0fu,0x13051301u),\nuvec4(0x05000204u,0x0f13000fu,0x05af0305u,0x23150322u),\nuvec4(0x4f051301u,0x331f7e3eu,0x33252305u,0x55ef033fu),\nuvec4(0x3521953fu,0x40110061u,0x00310001u,0x07127011u),\nuvec4(0x07240b0cu,0x0d2b0714u,0x0b071c07u,0x07080b17u),\nuvec4(0x0206071du,0x950f0540u,0x12030103u,0x059f6501u),\nuvec4(0x02011501u,0x0b0d1614u,0x073827a8u,0x37191809u),\nuvec4(0x0d4c68f8u,0x08592c19u,0x33350e07u,0x0400b501u),\nuvec4(0x06040102u,0x050b062bu,0x04018001u,0x1b160422u),\nuvec4(0x0d0b0a36u,0x52001226u,0x04030b06u,0x07021b13u),\nuvec4(0x3e0f0e0du,0x1305030fu,0x00022300u,0x01031501u),\nuvec4(0x00030205u,0x054f000fu,0x050f332fu,0x03020103u),\nuvec4(0x2f150302u,0x3f2e030eu,0x032f2e03u,0x2513053fu),\nuvec4(0x156f1503u,0x851f65bfu,0x05812503u,0x00210041u),\nuvec4(0x30010051u,0x04023001u,0x0a0b091bu,0x0b070b06u),\nuvec4(0x071d1b1du,0x0d2b173bu,0x20040607u,0x55211514u),\nuvec4(0x03050143u,0x13050315u,0x254f0305u,0x02231513u),\nuvec4(0x19181b0au,0x170b0758u,0x29a87748u,0x497c0998u),\nuvec4(0x030d0728u,0x0503250fu,0x85030112u,0x02040011u),\nuvec4(0x0b070410u,0x01020b14u,0x04001170u,0x16040102u),\nuvec4(0x36070d0bu,0x00143607u,0x03020412u,0x04020604u),\nuvec4(0x1b071423u,0x232e0f0eu,0x03120302u,0x01042302u),\nuvec4(0x00010200u,0x02030214u,0x4f051f03u,0x05031f33u),\nuvec4(0x01050103u,0x1f4e3f03u,0x0e030005u,0x053f0e3fu),\nuvec4(0x3503050fu,0x4f030503u,0xf5bf1503u,0xe1050135u),\nuvec4(0x41100120u,0x04000290u,0x1b070402u,0x290d0b04u),\nuvec4(0x2b07091cu,0x18070b2du,0x0a0b0d07u,0x02161406u),\nuvec4(0x45113003u,0x150315e3u,0x35010211u,0x07040501u),\nuvec4(0x0928070du,0x57180728u,0x49083728u,0x0d4c58f8u),\nuvec4(0x0b48390cu,0x13052f03u,0x02012205u,0x04000185u),\nuvec4(0x06041002u,0x09040204u,0x0180030bu,0x00020403u),\nuvec4(0x0a1b1614u,0x00020476u,0x04031402u,0x05030416u),\nuvec4(0x0b070403u,0x0e0d090cu,0x01151f13u,0x0e030e02u),\nuvec4(0x13021002u,0x03120332u,0x02250005u,0x0f050115u),\nuvec4(0x3f030f03u,0x01030215u,0x031f0502u,0x0e0e1f1eu),\nuvec4(0x2e03000fu,0x352f2e1fu,0x35030002u,0x350f251fu),\nuvec4(0x1501857fu,0x15415501u,0x05010531u,0x20110021u),\nuvec4(0xa0312001u,0x12030204u,0x04030203u,0x09071c0bu),\nuvec4(0x073b170du,0x2718070bu,0x0a161a1bu,0x01500204u),\nuvec4(0x33120395u,0x01051301u,0x01051105u,0x2f050300u),\nuvec4(0x0b020315u,0x18274807u,0x0b074b17u,0x09070b07u),\nuvec4(0x48f8490cu,0x091c0d3cu,0x130b0758u,0x0513052fu),\nuvec4(0x33120112u,0x00013305u,0x04100204u,0x09040012u),\nuvec4(0x0180030bu,0x14120405u,0x24761b26u,0x04030400u),\nuvec4(0x13061706u,0x020d0706u,0x0e0d0b09u,0x0e251f13u),\nuvec4(0x11050305u,0x05730223u,0x02012523u,0x250f1503u),\nuvec4(0x0501053fu,0x1e031f13u,0x1f0e0e1fu,0x2e0f1e23u),\nuvec4(0x0301252fu,0x03150302u,0x4f250f55u,0x015511d5u),\nuvec4(0x31152100u,0x11106100u,0x11300100u,0x04600120u),\nuvec4(0x01320112u,0x091c0700u,0x072b171du,0x39070819u),\nuvec4(0x072b1d0bu,0x01400216u,0x11750100u,0x15010302u),\nuvec4(0x20014511u,0x151f1503u,0x04020001u,0x1708070bu),\nuvec4(0x170b071bu,0x0402031du,0x092b0d0bu,0x1928090cu),\nuvec4(0x3c2938f8u,0x1b074819u,0x03051f13u,0x11051305u),\nuvec4(0x01058302u,0x20021400u,0x02030501u,0x12700103u),\nuvec4(0x24020001u,0x0b090b26u,0x02060486u,0x0c070604u),\nuvec4(0x0706041bu,0x0b130503u,0x2f030e03u,0x03552305u),\nuvec4(0x01152310u,0x03051302u,0x02100500u,0x25012511u),\nuvec4(0x1503151fu,0x0f1e1f13u,0x134f0e1eu,0x030f0e2fu),\nuvec4(0x1203351fu,0x450f6501u,0xf501c51fu,0x10312031u),\nuvec4(0xc0013011u,0x03020402u,0x03220310u,0x0d2c0b00u),\nuvec4(0x07091b37u,0x7b390819u,0x11201416u,0x02415500u),\nuvec4(0x01552103u,0x0f451310u,0x3b042005u,0x0b072b0du),\nuvec4(0x04000113u,0x191b1d0au,0x78f80938u,0x48290c09u),\nuvec4(0x03070807u,0x031f0501u,0x1503051fu,0x21034203u),\nuvec4(0x00010513u,0x01000204u,0x05010510u,0x10013001u),\nuvec4(0x05010011u,0x2b040200u,0x070c0716u,0x0b07b60bu),\nuvec4(0x03070b19u,0x0f05030eu,0x0e031203u,0x05030f05u),\nuvec4(0x00111553u,0x23250112u,0x01201135u,0x25030120u),\nuvec4(0x3503050fu,0x3f4e1f03u,0x0225cf15u,0x354f6501u),\nuvec4(0x05010551u,0xa5010511u,0x5001a071u,0x50210011u),\nuvec4(0x01030204u,0x04010002u,0x04020302u,0x0d090c0bu),\nuvec4(0x1b370807u,0x09073907u,0x260d671bu,0x00212004u),\nuvec4(0x02015501u,0x45111213u,0x4f051311u,0x01001105u),\nuvec4(0x12010543u,0x01101113u,0x090b3604u,0x080958f8u),\nuvec4(0x39380c09u,0x030b1738u,0x051f1302u,0x1243051fu),\nuvec4(0x00011203u,0x01051301u,0x11000214u,0x00110500u),\nuvec4(0x00010521u,0x01031011u,0x0d0c2405u,0x090d160bu),\nuvec4(0x1c1ba60bu,0x2513040bu,0x0322050fu,0x0503050eu),\nuvec4(0x02105523u,0x50251355u,0x35312001u,0x03010511u),\nuvec4(0x2f0e031fu,0xef05033fu,0x55031105u,0x750f150fu),\nuvec4(0xf021e571u,0x01121120u,0x12145002u,0x00320100u),\nuvec4(0x09070403u,0x1b47082cu,0x07180917u,0x0718071bu),\nuvec4(0x070b2708u,0x00010226u,0x12217511u,0x45111203u),\nuvec4(0xf50f2503u,0x01350305u,0x04320110u,0x1948f807u),\nuvec4(0x09382908u,0x0d0b1748u,0x05030102u,0x151f051fu),\nuvec4(0x52030523u,0x04002513u,0x01002102u,0x02049105u),\nuvec4(0x03050005u,0x0b0c0b24u,0x0b0d070au,0x091b0786u),\nuvec4(0x330b090cu,0x0402151fu,0x01030203u,0x01552305u),\nuvec4(0x23352310u,0x1011a005u,0x00110511u,0x03150311u),\nuvec4(0x5f031f0eu,0x05039f0eu,0x1300251fu,0x113501d5u),\nuvec4(0x11c50135u,0x307220f0u,0x52202204u,0x0d0c0b04u),\nuvec4(0x1b37380cu,0x1b080917u,0x0b176807u,0x00020426u),\nuvec4(0x00c14531u,0x35030501u,0xa51f030fu,0x3001254fu),\nuvec4(0xf8070614u,0x38078938u,0x1b070807u,0x3f15030du),\nuvec4(0x43350f05u,0x23220302u,0x02000105u,0x51450110u),\nuvec4(0x02100105u,0x13051105u,0x0c090604u,0x0b0d170bu),\nuvec4(0x171b0a56u,0x03040b29u,0x0e03150fu,0x14020402u),\nuvec4(0x25110553u,0x35011001u,0x0f130501u,0x0031a005u),\nuvec4(0x00010511u,0x15130105u,0xcf031f0eu,0x13056f03u),\nuvec4(0x21c51302u,0x01550115u,0x20f001d5u,0x20111241u),\nuvec4(0x00114002u,0x07060211u,0x280c0d09u,0x1b370807u),\nuvec4(0x273b0907u,0x0b0d1748u,0x41020426u,0x32003135u),\nuvec4(0x05130201u,0x550f0563u,0x05130503u,0x2001157fu),\nuvec4(0x07040204u,0x2948f809u,0x191c0908u,0x0d2b0728u),\nuvec4(0x5f250103u,0x00023355u,0x01021302u,0x12040015u),\nuvec4(0x25016501u,0x05030421u,0x02030521u,0x0d1b0704u),\nuvec4(0x460b070bu,0x070b592bu,0x12074403u,0x22030704u),\nuvec4(0x00210523u,0x05212001u,0x130e0501u,0x04200105u),\nuvec4(0x01006140u,0x00050105u,0x2f131503u,0x231f13bfu),\nuvec4(0x0503152fu,0x25317513u,0x25011531u,0x10619501u),\nuvec4(0x1270f001u,0x10110240u,0x0d090704u,0x18070a09u),\nuvec4(0x08078b47u,0x08072817u,0x26070d0bu,0x0102060au),\nuvec4(0x43850100u,0x05113302u,0x01130523u,0x15131503u),\nuvec4(0x11257f13u,0x06000210u,0x38f80b07u,0x3c390c09u),\nuvec4(0x0b070809u,0x2511032du,0x4503055fu,0x11030503u),\nuvec4(0x15121302u,0x03020400u,0x01550165u,0x05013513u),\nuvec4(0x2b060403u,0x1b46071du,0x0b290b0du,0x02030b0du),\nuvec4(0x06120d4bu,0x1302140bu,0x01151301u,0x01000140u),\nuvec4(0x0f030e25u,0x04200105u,0x81050140u,0x031f1315u),\nuvec4(0x4f0e3f2fu,0x0e030f0eu,0x5f030e03u,0x31f52315u),\nuvec4(0x01250105u,0x11209195u,0x020110f0u,0x14302406u),\nuvec4(0x0c080702u,0x8b77180du,0x0d171847u,0x06171d0bu),\nuvec4(0x0102060au,0x41456110u,0x12017302u,0x03151105u),\nuvec4(0x01553f35u,0x04000100u,0x28f81b06u,0x06090c29u),\nuvec4(0x0d0c090au,0x0708090cu,0x00021d0bu,0x152f3501u),\nuvec4(0x0213850fu,0x00131223u,0x0300f512u,0x09141355u),\nuvec4(0x070d0b07u,0x0d0b0a36u,0x1b17090bu,0x04020b0du),\nuvec4(0x0407060bu,0x02040203u,0x06020704u,0x0207040bu),\nuvec4(0x01150214u,0x01030120u,0x0e030523u,0x30110e03u),\nuvec4(0x01052004u,0x01050105u,0x01151105u,0x033f4f35u),\nuvec4(0x2e1f2305u,0xc5337f23u,0x25310501u,0x0501b501u),\nuvec4(0x10110041u,0xe0110001u,0x10521001u,0x07040214u),\nuvec4(0x67080c1du,0x07ab070bu,0x3d0b072bu,0x160b1d1bu),\nuvec4(0x25033002u,0x05033501u,0x01232193u,0x05032102u),\nuvec4(0x551f0523u,0x0d062021u,0x08f80709u,0x0a072c19u),\nuvec4(0x08192c07u,0x00020d1bu,0xb53f3501u,0x22030213u),\nuvec4(0x03000123u,0x00951f25u,0x02135513u,0x0b070914u),\nuvec4(0x3607060du,0x172b170bu,0x090c0412u,0x1406070cu),\nuvec4(0x04020402u,0x090b0706u,0x0416140cu,0x03120102u),\nuvec4(0x13125400u,0x02201420u,0x20152100u,0x23250011u),\nuvec4(0x1e033f2fu,0x0e03150fu,0x0305af33u,0x9125f5f5u),\nuvec4(0x21b00160u,0x07320170u,0x87080c1du,0x3d2b3dbbu),\nuvec4(0x170b0d1bu,0x11020426u,0x0f650100u,0x05030e03u),\nuvec4(0x15130e43u,0x03011201u,0x03350385u,0x07042115u),\nuvec4(0xc809380bu,0x07093c09u,0x0c090c19u,0x031b0809u),\nuvec4(0x0f150110u,0x03053f05u,0x02335531u,0x03000143u),\nuvec4(0x0f051f15u,0x0f050395u,0x04020365u,0x0d0b090bu),\nuvec4(0x0a16071bu,0x070b4d0bu,0x0d070406u,0x03020b09u),\nuvec4(0x1402230eu,0x06071b16u,0x07090b07u,0x02030204u),\nuvec4(0x02241244u,0x30241003u,0x20012511u,0x05110001u),\nuvec4(0x4e032f23u,0x1e33051fu,0x156f050fu,0xf50f053fu),\nuvec4(0x2150a1e5u,0x01000160u,0x01302100u,0x02034002u),\nuvec4(0x090d0c06u,0x170b3708u,0x271b4d9bu,0x1d0b074bu),\nuvec4(0x0102144bu,0x11000100u,0x23154f15u,0x0102550fu),\nuvec4(0x85111302u,0x04212533u,0x07091827u,0x2c393cc8u),\nuvec4(0x02070809u,0x1f351001u,0x12051f05u,0x05010521u),\nuvec4(0x13010501u,0x11233201u,0x0f150f03u,0x00650135u),\nuvec4(0x13650f03u,0x0b090604u,0x04060b1du,0x0d2b0726u),\nuvec4(0x0406070bu,0x0b090c0bu,0x02042302u,0x1b141b07u),\nuvec4(0x090b0709u,0x2417081bu,0x00120002u,0x20241052u),\nuvec4(0x05313041u,0x1f05031fu,0x0e130f3eu,0x0e030e13u),\nuvec4(0x0301051fu,0x053f2305u,0x0f030503u,0x00b1e5f5u),\nuvec4(0x02210051u,0x00110211u,0x00411051u,0x04030001u),\nuvec4(0x090d0c07u,0x072b4708u,0x1d0b0d6bu,0x1b47092bu),\nuvec4(0x1b0d0b27u,0x00041b27u,0x5f151312u,0x0e031e03u),\nuvec4(0x12313503u,0x35011511u,0x10012563u,0x0b070402u),\nuvec4(0x0c1908f8u,0x07290c49u,0x45110204u,0x0201053fu),\nuvec4(0x11040a06u,0x03053105u,0x01132211u,0x150f0310u),\nuvec4(0x0301053fu,0x1f050f05u,0x450f1300u,0x0413150fu),\nuvec4(0x0b0d1907u,0x070a660au,0x0b061216u,0x0e070b04u),\nuvec4(0x12045315u,0x0c3d0c0bu,0x00043b09u,0x00120004u),\nuvec4(0x02030b04u,0x04003400u,0x01000410u,0x33250160u),\nuvec4(0x0f0e0f0eu,0x0f2e032eu,0x051f0e03u,0x051f8300u),\nuvec4(0x03151f03u,0x25f51175u,0x100100d1u,0x00b10231u),\nuvec4(0x03310021u,0x0d0c0704u,0x670b2709u,0x180b179bu),\nuvec4(0x18271817u,0x18070b27u,0x06071b07u,0x535f3502u),\nuvec4(0x01003115u,0x00010203u,0x43016311u,0x0b063025u),\nuvec4(0xa8092807u,0x0c590719u,0x31120b29u,0x1f150f25u),\nuvec4(0x06041205u,0x01354104u,0x04002312u,0x03057f13u),\nuvec4(0x1f050f05u,0x351f1305u,0x0305030fu,0x0204020eu),\nuvec4(0x14a60a2bu,0x07020b07u,0x2205020bu,0x06040e23u),\nuvec4(0x1d0b2603u,0x021b3c0bu,0x0d070634u,0x04020403u),\nuvec4(0x22003400u,0x0f030570u,0x1f7e1e33u,0x051f0e03u),\nuvec4(0x33051301u,0x052f030fu,0x653f050fu,0x9115f531u),\nuvec4(0x01000100u,0x31000100u,0x11020302u,0x0105e105u),\nuvec4(0x0c0b0403u,0x7ba70c1du,0x08072837u,0x38173837u),\nuvec4(0x0b070b07u,0x150f0503u,0x25133e4fu,0x11021041u),\nuvec4(0x13150305u,0x1f231115u,0x07063025u,0x88491809u),\nuvec4(0x0c090709u,0x02040869u,0x0f051120u,0x13050115u),\nuvec4(0x02031200u,0x05510204u,0x01130223u,0x05030406u),\nuvec4(0x053f053fu,0x1f03114fu,0x1f132f15u,0x2724020eu),\nuvec4(0x120b04b6u,0x01331203u,0x0b020e03u,0x0a160b02u),\nuvec4(0x0c2b0d0bu,0x041b1c0du,0x0d0b070bu,0x0022141eu),\nuvec4(0x21120004u,0x11000102u,0x2f0e0302u,0x13030f23u),\nuvec4(0x1f05133eu,0x050f0e03u,0x23051311u,0x3f13055fu),\nuvec4(0x01002145u,0x15f50105u,0x00211501u,0x13414021u),\nuvec4(0x15a10021u,0x05010501u,0x1d0b0603u,0x1807090cu),\nuvec4(0x68376b67u,0x68173827u,0x25030b07u,0x15231e5fu),\nuvec4(0x02010041u,0x65010203u,0x01153f43u,0x04000100u),\nuvec4(0x49180706u,0x09280958u,0x0c084907u,0x040b0709u),\nuvec4(0x25211001u,0x03150302u,0x00120011u,0x15011021u),\nuvec4(0x00131203u,0x05030204u,0x0f1301efu,0x3f033f15u),\nuvec4(0x0402030eu,0x170b091bu,0x0416170bu,0x02041326u),\nuvec4(0x15030503u,0x0e030503u,0x04061400u,0x1b1d0a26u),\nuvec4(0x0c0d1c07u,0x01052e1du,0x00140b1eu,0x02040013u),\nuvec4(0x43111001u,0x030f233fu,0x0e1f1e03u,0x2305030fu),\nuvec4(0x00010315u,0x0e131103u,0x0503155fu,0x0001354fu),\nuvec4(0x0115f531u,0x11505125u,0x91051300u,0x41052110u),\nuvec4(0x1d0a060eu,0x4807090cu,0x78276b37u,0x78070807u),\nuvec4(0x04073809u,0x2513af13u,0x02030231u,0x05032521u),\nuvec4(0x3f330513u,0x00110025u,0x19080704u,0x59082918u),\nuvec4(0x390c0908u,0x070c190cu,0x0001021bu,0x05010001u),\nuvec4(0x05030201u,0x11031503u,0x04001200u,0x03112002u),\nuvec4(0x03020105u,0x13020001u,0x4f033f05u,0x012f0305u),\nuvec4(0x3f031f13u,0x031e3f13u,0x1b073b12u,0x14020407u),\nuvec4(0x01001233u,0x14032203u,0x5d0b560bu,0x021c070bu),\nuvec4(0x05231103u,0x12140203u,0x01020403u,0x05210210u),\nuvec4(0x0f033f03u,0x15034f33u,0x05030503u,0x03110513u),\nuvec4(0x05030100u,0x03050f0eu,0x0f05032fu,0x451f1503u),\nuvec4(0x00011201u,0x0511b501u,0x25014501u,0x00213001u),\nuvec4(0x03150321u,0x51251105u,0x01150125u,0x06030e05u),\nuvec4(0x08091d07u,0x3b374807u,0xd8077847u,0x03020709u),\nuvec4(0x0f1e8f05u,0x41050305u,0x01120112u,0x33450105u),\nuvec4(0x01253f1eu,0x07060410u,0x08890829u,0x090c390cu),\nuvec4(0x070c090cu,0x40030b18u,0x02250311u,0x04003123u),\nuvec4(0x11100206u,0x01230103u,0x057f0322u,0x1f03150fu),\nuvec4(0x1f130105u,0x0f051f03u,0x030e5f13u,0x1b0d1b52u),\nuvec4(0x07040b17u,0x1b04121bu,0x66141203u,0x072d1607u),\nuvec4(0x0b0d140au,0x02100426u,0x02140223u,0x25331203u),\nuvec4(0x0f331f03u,0x250f1523u,0x02010001u,0x01000123u),\nuvec4(0x03011013u,0x0e030f0eu,0x350f752fu,0x21020311u),\nuvec4(0x31000185u,0x01050155u,0x35135140u,0x15210021u),\nuvec4(0x0e037511u,0x1d0c0a04u,0xb7480708u,0x17c81778u),\nuvec4(0x6f15130bu,0x1125230eu,0x11121105u,0x63251102u),\nuvec4(0x0410256fu,0xc9080b06u,0x090c290cu,0x0728092cu),\nuvec4(0x13014002u,0x04000305u,0x11000123u,0x21022410u),\nuvec4(0x03220133u,0x131f037fu,0x2301051fu,0x030f031fu),\nuvec4(0x1f0e030fu,0x032e3f03u,0x33121312u,0x00121702u),\nuvec4(0x020d0b06u,0x2607e604u,0x0c0b0002u,0x120b040bu),\nuvec4(0x1b330213u,0x02000233u,0x15030501u,0x050f053fu),\nuvec4(0x01150213u,0x33056300u,0x4f132005u,0x85030f03u),\nuvec4(0x0001150fu,0x11650302u,0x11154115u,0x11305105u),\nuvec4(0x35032100u,0x15310031u,0x030e7511u,0x191d0706u),\nuvec4(0x27183758u,0x09881798u,0x130b0728u,0x0f0e6f15u),\nuvec4(0x1305330eu,0x02001102u,0x05830001u,0x01259f03u),\nuvec4(0x09f90714u,0x1907390cu,0x40021718u,0x00031501u),\nuvec4(0x02032513u,0x04000105u,0x05110416u,0x03021302u),\nuvec4(0x7f130200u,0x03051f03u,0x2300031fu,0x153f030fu),\nuvec4(0x0e03050fu,0x5e03051fu,0x05110533u,0x020b3403u),\nuvec4(0x140246f6u,0x141b0200u,0x22030022u,0x03020e03u),\nuvec4(0x00221302u,0x65001305u,0x11100201u,0x231f4503u),\nuvec4(0x23200105u,0x031f135fu,0x35020395u,0x00a10051u),\nuvec4(0x10016001u,0x15030511u,0x10110513u,0x05010531u),\nuvec4(0x000e6521u,0x0c0d1c0au,0x07c85758u,0x09380948u),\nuvec4(0x030b0718u,0x3f1e5f45u,0x02100135u,0x05031103u),\nuvec4(0x7f730503u,0x04002115u,0x0cf92c07u,0x09070908u),\nuvec4(0x02031728u,0x01200200u,0x03451310u,0x02000105u),\nuvec4(0x02230604u,0x00011213u,0x456f0513u,0x00150f03u),\nuvec4(0x0f1e130eu,0x15232503u,0x012f1e23u,0x4e030510u),\nuvec4(0x66140223u,0x96070607u,0x04020a0bu,0x13120012u),\nuvec4(0x10030214u,0x03000102u,0x030e032eu,0x02010302u),\nuvec4(0x01001203u,0x10010200u,0x25034202u,0x00130e5fu),\nuvec4(0x8f130004u,0x03050345u,0xd1153135u,0x11101102u),\nuvec4(0x11201100u,0xa1451110u,0x01050115u,0x07040375u),\nuvec4(0x18091c2du,0x4807b877u,0x08291809u,0x25011317u),\nuvec4(0x0e035f03u,0x0211452fu,0x01051203u,0x7f532513u),\nuvec4(0x06300f05u,0x0c192c08u,0x08791c39u,0x3809080cu),\nuvec4(0x01020309u,0x12000203u,0x65010316u,0x13020421u),\nuvec4(0x13120302u,0x159f2311u,0x0103050fu,0x2e030e02u),\nuvec4(0x0f13150fu,0x05130e03u,0x15230e03u,0x15230002u),\nuvec4(0x20051f03u,0x3b0d1b86u,0x061b0a36u,0x15031203u),\nuvec4(0x14132503u,0x13220310u,0x03041301u,0x13010312u),\nuvec4(0x03020105u,0x01431222u,0x032f1500u,0x0001130fu),\nuvec4(0x4f050302u,0x03150f05u,0x01352315u,0xf1551100u),\nuvec4(0x05416051u,0x00110501u,0x85010581u,0x0c06030fu),\nuvec4(0x6728094du,0x180918f8u,0x0708090cu,0x4501030du),\nuvec4(0x030e034fu,0x350f130eu,0x05114201u,0x33010501u),\nuvec4(0x057f031eu,0x0401100fu,0x092c0908u,0x080cb91cu),\nuvec4(0x380c0819u,0x01100207u,0x00010300u,0x030b0706u),\nuvec4(0x04000175u,0x23121103u,0x6f231102u,0x03150f03u),\nuvec4(0x02011305u,0x0f0e030eu,0x05131f0eu,0x1e331e0fu),\nuvec4(0x1e030513u,0x10054f23u,0x070a6604u,0x08090b0du),\nuvec4(0x1b360a2bu,0x01100207u,0x02041065u,0x12030113u),\nuvec4(0x22030410u,0x00620001u,0x33042212u,0x03020302u),\nuvec4(0x5f05434fu,0x00120125u,0x00012521u,0x00b15511u),\nuvec4(0x10310031u,0x03050361u,0x01100315u,0x01b56103u),\nuvec4(0x5d080203u,0x19c8871cu,0x19280908u,0x01030b07u),\nuvec4(0x1f030f65u,0x01650f33u,0x11020302u,0x15031100u),\nuvec4(0x0f058f43u,0x08041001u,0x0ca95c09u,0x09082908u),\nuvec4(0x02030738u,0x0c070440u,0x0085030du,0x11050306u),\nuvec4(0x05230142u,0x0113355fu,0x130f3320u,0x0f2e230fu),\nuvec4(0x0e0f1e13u,0x0e030503u,0x4f03051fu,0x46040005u),\nuvec4(0x1b060a17u,0x1b070807u,0x170b4607u,0x00041004u),\nuvec4(0x01130165u,0x02030200u,0x02030503u,0x03020403u),\nuvec4(0x10021152u,0x02000202u,0x0e031210u,0x3f0e0305u),\nuvec4(0x05130f1eu,0x0503051fu,0x1402550fu,0x01030210u),\nuvec4(0x03000400u,0x00e13501u,0x05615031u,0x00410311u),\nuvec4(0x0105f501u,0x07040500u,0x0c0d4c0du,0x27183708u),\nuvec4(0x18399809u,0x0b071809u,0x3f451103u,0x020021b3u),\nuvec4(0x23051341u,0x20159f05u,0x190c0906u,0x1829f91cu),\nuvec4(0x03071809u,0x04110002u,0x090b0406u,0x1165030cu),\nuvec4(0x11030604u,0x0e135203u,0x2f050f03u,0x05130f35u),\nuvec4(0x0e0f3320u,0x0f0e0503u,0x4e032e13u,0x1f0e030fu),\nuvec4(0x0e3f1305u,0x17360401u,0x272b0708u,0x0a0b0d0bu),\nuvec4(0x063b0a36u,0x01003402u,0x01030125u,0x05230200u),\nuvec4(0x03041311u,0x00022110u,0x02012201u,0x0e020452u),\nuvec4(0x050f050fu,0x0e2f0e03u,0x331f150fu,0x00010305u),\nuvec4(0x40240321u,0x81551102u,0x21001120u,0x11003160u),\nuvec4(0x01032205u,0x01050102u,0x100105f5u,0x1c1d0b13u),\nuvec4(0x07182c07u,0x39584748u,0x02172928u,0x2e3f2531u),\nuvec4(0x01450f13u,0x05212220u,0x0f530113u,0x01056f0eu),\nuvec4(0x08070400u,0x194819f9u,0x07080907u,0x0002030bu),\nuvec4(0x1b040604u,0x03070908u,0x00050155u,0x02030406u),\nuvec4(0x01033203u,0x050f0573u,0x00430e2fu,0x030f0e23u),\nuvec4(0x0e2f0e0fu,0x0e1f7e03u,0x0301051fu,0x0f0e1f0eu),\nuvec4(0x280b3614u,0x0718073bu,0x0a070d0bu,0x0b0d0a16u),\nuvec4(0x10416427u,0x01051301u,0x10020b33u,0x11021001u),\nuvec4(0x04141302u,0x04020022u,0x050f0e02u,0x0e0f0e1fu),\nuvec4(0x151f153fu,0x00031233u,0x03520511u,0x71551110u),\nuvec4(0x01b04100u,0x33052302u,0x1045f501u,0x0e030103u),\nuvec4(0x0d0c0702u,0x680c1d1cu,0x58171b07u,0x17392829u),\nuvec4(0x15210302u,0x2305335fu,0x03022115u,0x03050122u),\nuvec4(0x1f131501u,0x156f0e13u,0x08040001u,0x390809f9u),\nuvec4(0x08070918u,0x10031b07u,0x070b0604u,0x0719070bu),\nuvec4(0x04006503u,0x11020306u,0x01020322u,0x0f031573u),\nuvec4(0x1f031f05u,0x03040105u,0x030f130fu,0x0e0f0e05u),\nuvec4(0x3e030e0fu,0x054f1e1fu,0x00050210u,0x07360405u),\nuvec4(0x1728070bu,0x07380708u,0x070a072bu,0x08070b0du),\nuvec4(0x04063407u,0x02300406u,0x15030201u,0x03052301u),\nuvec4(0x32112012u,0x02140b16u,0x04000200u,0x03050e03u),\nuvec4(0x11c55f05u,0x15010200u,0x02030223u,0x10010001u),\nuvec4(0x81250105u,0x01007100u,0x41002100u,0x01050100u),\nuvec4(0x01f50145u,0x0e152310u,0x2d3c0702u,0x0b174809u),\nuvec4(0x08192817u,0x08391829u,0x31030617u,0x1f150f15u),\nuvec4(0x15430e03u,0x02230221u,0x05130541u,0x0e130503u),\nuvec4(0x01056f03u,0x0c080400u,0x0c1908f9u,0x2b070819u),\nuvec4(0x04200302u,0x29180706u,0x04115513u,0x12210203u),\nuvec4(0x02000203u,0x15031573u,0x0401054fu,0x0f030f13u),\nuvec4(0x1f1e0305u,0x7f3e0f1eu,0x00040003u,0x0b460014u),\nuvec4(0xc8070b0du,0x1d070d0bu,0x07091807u,0x12140624u),\nuvec4(0x03110210u,0x03210001u,0x00220e15u,0x03120012u),\nuvec4(0x020b0704u,0x00020402u,0x1e020402u,0x2f13150fu),\nuvec4(0x35034513u,0x03021513u,0x23050145u,0x01120305u),\nuvec4(0x61056110u,0x01201130u,0x0345b100u,0x11251115u),\nuvec4(0x25031045u,0x020e1503u,0x092d3c06u,0x170b1738u),\nuvec4(0x29380918u,0x0b171918u,0x21000316u,0x3f150100u),\nuvec4(0x2305432eu,0x00012201u,0x25030501u,0x01058f53u),\nuvec4(0x0c090704u,0x171c29f9u,0x02040b0du,0x04000220u),\nuvec4(0x0b290807u,0x01251f13u,0x21031200u,0x05013022u),\nuvec4(0x05330503u,0x2f051f03u,0x23101f05u,0x0e050f0eu),\nuvec4(0x4e1f0e0fu,0x3401256fu,0x070b2756u,0x1d0b07c8u),\nuvec4(0x0b09280bu,0x0014060au,0x12000214u,0x10020001u),\nuvec4(0x03040001u,0x22042301u,0x02000100u,0x04002213u),\nuvec4(0x1e020422u,0x0f23050fu,0x03252f05u,0x03254375u),\nuvec4(0x13050325u,0x05113215u,0xe0010551u,0x35110591u),\nuvec4(0x15010501u,0x00113521u,0x45031502u,0x0d09040eu),\nuvec4(0x38091d2cu,0x68072b07u,0x17191829u,0x0204060bu),\nuvec4(0x25101110u,0x332e031fu,0x22411305u,0x23252315u),\nuvec4(0x00155f1eu,0xf9081604u,0x06070d69u,0x06044002u),\nuvec4(0x090c190bu,0x1f15030bu,0x13020025u,0x00012205u),\nuvec4(0x53022102u,0x2f151315u,0x10050f05u,0x4f030533u),\nuvec4(0x054f035eu,0x56340001u,0x2be8371bu,0x07080918u),\nuvec4(0x0004460bu,0x02141211u,0x04061103u,0x040e0112u),\nuvec4(0x01000302u,0x22000102u,0x04000203u,0x03040012u),\nuvec4(0x0f233f0eu,0x45234523u,0x25133523u,0x01150123u),\nuvec4(0xb0811543u,0x050105c1u,0x15112503u,0x00211501u),\nuvec4(0x23050301u,0x01050f05u,0x2c09040eu,0x1718092du),\nuvec4(0x1988171bu,0x19071908u,0x0304020bu,0x21000102u),\nuvec4(0x0e132f25u,0x01130533u,0x22031105u,0x130e7305u),\nuvec4(0x0210253fu,0x39160400u,0x0709f90cu,0x0203060bu),\nuvec4(0x0b140130u,0x090c0908u,0x350f0503u,0x13020100u),\nuvec4(0x02030501u,0x23620001u,0x23450325u,0x13020015u),\nuvec4(0x03050305u,0x1e0f4e3fu,0x0f052f03u,0x26240005u),\nuvec4(0xf8272b07u,0x09181728u,0x070b0918u,0x20010236u),\nuvec4(0x02040214u,0x13002411u,0x00011204u,0x00020332u),\nuvec4(0x14120400u,0x033f0e0du,0x23d5033fu,0x01150345u),\nuvec4(0x41220315u,0x21105125u,0x01101100u,0x81100100u),\nuvec4(0x11652145u,0x15033005u,0x25030503u,0x08040e01u),\nuvec4(0x0d1c0d0cu,0x1718090cu,0x4998071bu,0x00041b08u),\nuvec4(0x23050302u,0x0f434f25u,0x03350325u,0x83052300u),\nuvec4(0x0001153fu,0x00110302u,0x08070604u,0x38d90c09u),\nuvec4(0x02040b07u,0x14013001u,0x0b190807u,0x250f0503u),\nuvec4(0x05630200u,0x15236211u,0x05134513u,0x13020113u),\nuvec4(0x4f050305u,0x00050f4eu,0x1f250301u,0x0b160213u),\nuvec4(0xf8170b07u,0x07280738u,0x04360b68u,0x24000102u),\nuvec4(0x01021400u,0x12040b02u,0x00012203u,0x03020002u),\nuvec4(0x22041102u,0x9f0e0304u,0x03450f05u,0x23850325u),\nuvec4(0x13022325u,0x00e14011u,0x00010201u,0x057135a1u),\nuvec4(0x05110511u,0x85030201u,0x09040e01u,0x070c1d2cu),\nuvec4(0x071b1718u,0x060b49a8u,0x21000204u,0x030e5f45u),\nuvec4(0x030f030eu,0x23021145u,0x43053305u,0x0320152fu),\nuvec4(0x16042005u,0xa91c1908u,0x020b2738u,0x02010001u),\nuvec4(0x07040001u,0x130d1918u,0x9335031fu,0x33120012u),\nuvec4(0x45130501u,0x00131513u,0x5e4f2513u,0x03000203u),\nuvec4(0x05030105u,0x0604051fu,0x78f80b0du,0x3617a807u),\nuvec4(0x04221012u,0x00020400u,0x02140201u,0x2322030eu),\nuvec4(0x12040021u,0x0e0d0400u,0x0f132e5fu,0x03051f55u),\nuvec4(0x03050305u,0x01652335u,0x12130105u,0x00713031u),\nuvec4(0x03010211u,0x00e10001u,0x35010011u,0x75330021u),\nuvec4(0x040e0300u,0x090d3c09u,0x071b2718u,0x0b0729a8u),\nuvec4(0x0003040au,0x436f1541u,0x02010355u,0x05430523u),\nuvec4(0x052f0e33u,0x03021001u,0x04100105u,0x1c090816u),\nuvec4(0x180918a9u,0x020b071bu,0x02000130u,0x010d3907u),\nuvec4(0x03010533u,0x03256315u,0x23112322u,0x03050325u),\nuvec4(0x11051305u,0x051f0533u,0x1e134f03u,0x03000223u),\nuvec4(0x1b06001fu,0x58f80928u,0x38071837u,0x04261b07u),\nuvec4(0x02200402u,0x02044014u,0x1e030204u,0x10012513u),\nuvec4(0x03041204u,0x2f0e2f0eu,0x031f0e03u,0x1355132fu),\nuvec4(0x13052305u,0x12055185u,0x00310201u,0x00510061u),\nuvec4(0x00510041u,0x05910011u,0x01650133u,0x09040e15u),\nuvec4(0x08071d2cu,0x48072b37u,0x17191809u,0x03020416u),\nuvec4(0x11001110u,0x032e5f15u,0x11122165u,0x230e4325u),\nuvec4(0x0400152fu,0x20011502u,0x09080604u,0x0708e90cu),\nuvec4(0x2001023bu,0x04010001u,0x030b0918u,0x151f1305u),\nuvec4(0x15030503u,0x15330503u,0x11132203u,0x65011513u),\nuvec4(0x01000503u,0x132f1523u,0x05030e2fu,0x10051e1fu),\nuvec4(0x04000103u,0xf8070d06u,0x17381918u,0x070b070bu),\nuvec4(0x17480708u,0x0206070bu,0x24300213u,0x02040120u),\nuvec4(0x11650310u,0x14020400u,0x1e3f0e03u,0x030f0e4fu),\nuvec4(0x03050f05u,0x63250335u,0xa1150155u,0x01020312u),\nuvec4(0x00120112u,0x10010012u,0x20011011u,0x12211001u),\nuvec4(0x05021301u,0x01021102u,0x01131203u,0x01351100u),\nuvec4(0x0e150200u,0x0c0d3c0bu,0x3b270809u,0x0b393807u),\nuvec4(0x03021607u,0x00011012u,0x4f250011u,0x1305531eu),\nuvec4(0x03022105u,0x13150102u,0x032f5325u,0x03020402u),\nuvec4(0x04001115u,0x0c090806u,0x08090cd9u,0x12070b0du),\nuvec4(0x02410001u,0x0b070807u,0x1f050f13u,0x0f050f03u),\nuvec4(0x93050f05u,0x13020312u,0x03051115u,0x10550105u),\nuvec4(0x032f0533u,0x1f251e1fu,0x00030233u,0x070d1604u),\nuvec4(0x3b1768f8u,0x08073827u,0x070b0807u,0x01022304u),\nuvec4(0x01103400u,0x00120400u,0x13050103u,0x02001035u),\nuvec4(0x03051e14u,0x3f137f3eu,0x03450325u,0x55030501u),\nuvec4(0x05211511u,0x420102c1u,0x43226140u,0x43021302u),\nuvec4(0x11053322u,0x15132105u,0x0d1c070eu,0x180c0d0cu),\nuvec4(0x38073b27u,0x070c0819u,0x04030416u,0x35410220u),\nuvec4(0x0523257fu,0x02030231u,0x0e338501u,0x0314011fu),\nuvec4(0x04000135u,0x0c090a06u,0x0b071cd9u,0x04020406u),\nuvec4(0x05010302u,0x07040021u,0x63af2302u,0x42131205u),\nuvec4(0x11151103u,0x03050105u,0x03020015u,0x3f050335u),\nuvec4(0x2f031203u,0x00052315u,0xf81b1604u,0x275b0758u),\nuvec4(0x03060b88u,0x02000125u,0x22101134u,0x55030503u),\nuvec4(0x02041211u,0x132f051eu,0x3f0e0f1eu,0x031f0513u),\nuvec4(0x1135132fu,0x55111203u,0x00310391u,0x31105231u),\nuvec4(0x01220372u,0x02031200u,0x31020031u,0x03010502u),\nuvec4(0x03210321u,0x2d1c080eu,0x0807080cu,0x18074b07u),\nuvec4(0x160b3907u,0x01300304u,0x831f9503u,0x31222125u),\nuvec4(0x23550105u,0x02040115u,0x10013513u,0x990c0816u),\nuvec4(0x040b095cu,0x15131400u,0x12040021u,0xd39f1300u),\nuvec4(0x01020112u,0x05010302u,0x02004521u,0x0513a503u),\nuvec4(0x0e0f052fu,0x1600131fu,0x58f8070bu,0x2b2d0b07u),\nuvec4(0x04078817u,0x00111513u,0x00110234u,0x03020302u),\nuvec4(0x12314501u,0x051e0304u,0x0e0f132fu,0x0523056fu),\nuvec4(0x35232f03u,0x15033213u,0x15410501u,0x41127103u),\nuvec4(0x03623100u,0x31120122u,0x12003123u,0x030125a1u),\nuvec4(0x0d1c0805u,0x6b17181cu,0x16391817u,0x30010003u),\nuvec4(0xc3651301u,0x41124105u,0x01050f85u,0x151f2300u),\nuvec4(0x0001050fu,0x39070604u,0x191c8908u,0x5503340bu),\nuvec4(0x15320001u,0x0105a37fu,0x12010205u,0x02030201u),\nuvec4(0x35010513u,0x13010501u,0x00151145u,0x13550301u),\nuvec4(0x00030e2fu,0x0768f816u,0x0d0b1d0bu,0x0708271bu),\nuvec4(0x13070b58u,0x01000105u,0x01023400u,0x00031210u),\nuvec4(0x03151001u,0x00020021u,0x1f0e0302u,0x0f131f03u),\nuvec4(0x2f635f0eu,0x13552305u,0x05112512u,0x00b12531u),\nuvec4(0x22111011u,0xe1004201u,0x21000115u,0x15034105u),\nuvec4(0x07040e11u,0x090c092du,0x48077b17u,0x04060b0cu),\nuvec4(0x31157102u,0x05000200u,0x01450f53u,0x01322105u),\nuvec4(0x130001b5u,0x0f052f15u,0x16041005u,0x19083907u),\nuvec4(0x191c390cu,0x0204020bu,0x1f030200u,0x00121035u),\nuvec4(0x252f1304u,0x0305b30fu,0x01130205u,0x03020103u),\nuvec4(0x35013512u,0x01151103u,0x00050120u,0x15010304u),\nuvec4(0x050e3f43u,0xf8070604u,0x3d1b0748u,0x770b070bu),\nuvec4(0x030b0918u,0x20050f05u,0x00020024u,0x01020001u),\nuvec4(0x02001200u,0x05030501u,0x04020011u,0x1f0e0302u),\nuvec4(0x1f031f03u,0x0f035f03u,0x033f330eu,0x230501a5u),\nuvec4(0x41254115u,0x21023100u,0x01301110u,0x6103f172u),\nuvec4(0x0e052115u,0x1c1d0c06u,0x277b2708u,0x0b090b09u),\nuvec4(0x10011216u,0x01052001u,0x02131130u,0x030f2501u),\nuvec4(0x0221650fu,0x05210203u,0x01035511u,0x155f0310u),\nuvec4(0x07260420u,0x0c590829u,0x04091c0du,0x04000102u),\nuvec4(0x10251f13u,0x1f133002u,0x73050345u,0x01122335u),\nuvec4(0x03020112u,0x01250105u,0x11a00305u,0x5f233512u),\nuvec4(0x17060305u,0x37680798u,0x0d0b1d0bu,0x670b070bu),\nuvec4(0x031b0918u,0x00050f05u,0x00240001u,0x04100102u),\nuvec4(0x03022012u,0x04002025u,0x131f1e03u,0x031f033fu),\nuvec4(0x132f030fu,0x050f0305u,0x0f35033fu,0x21450305u),\nuvec4(0x31008165u,0x01001122u,0x21100130u,0x91124102u),\nuvec4(0x01456103u,0x0c060305u,0x28190c0du,0x272b0d3bu),\nuvec4(0x06070d2bu,0x01401204u,0x34000105u,0x01050110u),\nuvec4(0x85031502u,0x11020021u,0x03352110u,0x00050305u),\nuvec4(0x03020103u,0x01252f05u,0x07160420u,0x0c0d0c99u),\nuvec4(0x10120b09u,0x1f030204u,0x10042025u,0x05038503u),\nuvec4(0x43254301u,0x12112205u,0x31051103u,0x34200422u),\nuvec4(0x03050140u,0x6f050315u,0x07060305u,0x370847c8u),\nuvec4(0x0d08070bu,0x271b171bu,0x030b2918u,0x44120115u),\nuvec4(0x04010002u,0x04220302u,0x10310302u,0x0f1e0204u),\nuvec4(0x030e0f03u,0x1f030e2fu,0x031f0e33u,0x335f030fu),\nuvec4(0x35230f05u,0x15113521u,0x00112021u,0x20110241u),\nuvec4(0x10011001u,0x00310001u,0x05e11261u,0x05011501u),\nuvec4(0x0d0c0703u,0x0807190cu,0x1d0b1709u,0x0708071bu),\nuvec4(0x070b0718u,0x20021306u,0x00211001u,0x04021402u),\nuvec4(0x11050102u,0x12302185u,0x45310001u,0x00131503u),\nuvec4(0x151f1503u,0x3001050fu,0x0c590726u,0x0d092c09u),\nuvec4(0x10010002u,0x251f1302u,0x13021410u,0x02052355u),\nuvec4(0x25130e13u,0x05031533u,0x05010041u,0x04001341u),\nuvec4(0x14004302u,0x02101400u,0x05130f13u,0x052f052fu),\nuvec4(0x57880704u,0x091b373bu,0x1b180b0du,0x28170807u),\nuvec4(0x25030b09u,0x44000200u,0x04000102u,0x04020322u),\nuvec4(0x02102113u,0x032e0300u,0x3f0e1f1eu,0x0e3f1e13u),\nuvec4(0x333f053fu,0x1155231fu,0x01051305u,0xc1050305u),\nuvec4(0x01000100u,0x0305b162u,0x03220105u,0x15610041u),\nuvec4(0x07030501u,0x19280c1du,0x0d0b0708u,0x370b0d1bu),\nuvec4(0x0206070du,0x35611001u,0x05330200u,0x00351110u),\nuvec4(0x40110001u,0x21021302u,0x01050105u,0x12010305u),\nuvec4(0x2f130005u,0x30052f15u,0x59071604u,0x071c090cu),\nuvec4(0x0100030du,0x1f130420u,0x01241115u,0x15132530u),\nuvec4(0x05030e33u,0x15330503u,0x21031503u,0x03510210u),\nuvec4(0x03020001u,0x12131521u,0x03101200u,0x053f131fu),\nuvec4(0x1704151fu,0x072b0778u,0x172b0726u,0x1718070bu),\nuvec4(0x0718071bu,0x070c1718u,0x12002503u,0x01122400u),\nuvec4(0x02010324u,0x01120001u,0x4e020230u,0x0e2f132fu),\nuvec4(0x5f030e03u,0x0e037f0eu,0xc5131503u,0x05110211u),\nuvec4(0x01220133u,0x22001132u,0x00110203u,0x02510011u),\nuvec4(0x00710241u,0x03011561u,0x0d0c0602u,0x08191809u),\nuvec4(0x0b3d0b17u,0x070d0b17u,0x21201216u,0x11050165u),\nuvec4(0x01200100u,0x11101165u,0x21020312u,0x01051105u),\nuvec4(0x01020013u,0x03010302u,0x2f053f05u,0x01001115u),\nuvec4(0x190b0604u,0x0749080cu,0x1440030du,0x053f0503u),\nuvec4(0x11102400u,0x03050325u,0x23154312u,0x10013355u),\nuvec4(0x13023112u,0x15210210u,0x0f831501u,0x030e030eu),\nuvec4(0x0500050fu,0x07060411u,0x1b961778u,0x08070b08u),\nuvec4(0x28174b07u,0x0e0b0719u,0x02050315u,0x02340003u),\nuvec4(0x04020410u,0x00110230u,0x03120001u,0x1f030f1eu),\nuvec4(0x1e2f131eu,0x0eff0e03u,0x0f231513u,0x01000185u),\nuvec4(0x13111312u,0x31020305u,0x22000122u,0x037105c1u),\nuvec4(0x05010061u,0x00051302u,0x07040e11u,0x48090d09u),\nuvec4(0x2b1d1b17u,0x0a0b0d07u,0x01021306u,0x020311f5u),\nuvec4(0x12a11513u,0x03055103u,0x01030011u,0x13050302u),\nuvec4(0x01455f15u,0x07060100u,0x030d2759u,0x03023021u),\nuvec4(0x0001054fu,0x25210014u,0x85531213u,0x05030501u),\nuvec4(0x01003113u,0x03010002u,0x00010301u,0x23a52103u),\nuvec4(0x05032f1eu,0x06041014u,0x06572807u,0x14023302u),\nuvec4(0x0b170b26u,0x28076b07u,0x050e0b19u,0x0113250fu),\nuvec4(0x02302400u,0x20240004u,0x03120011u,0x0f033f1eu),\nuvec4(0x0f033f13u,0x0f032f0eu,0x13059f03u,0x13150305u),\nuvec4(0x05018395u,0x11104113u,0x01006112u,0xb1006100u),\nuvec4(0x11005100u,0x07060103u,0x380c0d0cu,0x0b0d3b17u),\nuvec4(0x16170b07u,0xf5030213u,0x15130125u,0x02033281u),\nuvec4(0x01004125u,0x45031503u,0x652f052fu,0x07160200u),\nuvec4(0x23040726u,0x12002501u,0x4f0e0300u,0x22000105u),\nuvec4(0x13050311u,0x03357302u,0x01150135u,0x10210305u),\nuvec4(0x00121102u,0x31030011u,0x030e03b5u,0x22033f0eu),\nuvec4(0x37040203u,0x4312130bu,0x14000215u,0x27060716u),\nuvec4(0x0928076bu,0x03650e07u,0x20240211u,0x06240002u),\nuvec4(0x02040604u,0x02000200u,0x034f0e03u,0x1f15130fu),\nuvec4(0xaf036f03u,0x75530f23u,0x11232521u,0x15021115u),\nuvec4(0x30010211u,0x22030231u,0x02110041u,0x10710551u),\nuvec4(0x06030511u,0x190c0d17u,0x2d2b1728u,0x02260a07u),\nuvec4(0x0f350103u,0x0f250f15u,0x81550175u,0x11105122u),\nuvec4(0x01050102u,0x4f150315u,0x11353f25u,0x13260402u),\nuvec4(0x3155030eu,0x054f0e03u,0x11031211u,0x75631223u),\nuvec4(0x31034501u,0x00120100u,0x00051102u,0x2f3ea581u),\nuvec4(0x1e030e13u,0x2f331e33u,0x04331e23u,0x0b06070au),\nuvec4(0x074b070du,0x030d2908u,0x0001750fu,0x40240002u),\nuvec4(0x04060b24u,0x03000112u,0x1f0e3f05u,0x05030503u),\nuvec4(0x5f03050fu,0x0f23cf03u,0x35138543u,0x00211543u),\nuvec4(0x21103201u,0x03050110u,0x05512251u,0x05911511u),\nuvec4(0x09070600u,0x28091c0du,0x1b071b17u,0x0302261du),\nuvec4(0x255f2501u,0x3501950fu,0x32211521u,0x10110011u),\nuvec4(0x21030201u,0x4f250315u,0x4f050305u,0x01150f05u),\nuvec4(0x130b1413u,0x30351105u,0x353f0e05u,0x02032210u),\nuvec4(0x2f630211u,0x00550175u,0x21220011u,0x01001100u),\nuvec4(0x23856100u,0x231e232eu,0x13151f05u,0x02132e9fu),\nuvec4(0x1b0a0604u,0x0c090847u,0x01250319u,0x10010355u),\nuvec4(0x0b341044u,0x10120607u,0x1f030110u,0x13451f0eu),\nuvec4(0x03cf056fu,0x1f45530eu,0x01052145u,0x61150305u),\nuvec4(0x01100122u,0x11036110u,0x31057122u,0x04036105u),\nuvec4(0x0c0d0917u,0x38074809u,0x160b0d07u,0x25010304u),\nuvec4(0x350f25bfu,0x00410531u,0x03212231u,0x23411001u),\nuvec4(0x2f051f05u,0x15031f05u,0x0e03554fu,0x010f0e03u),\nuvec4(0x03051100u,0x13001115u,0x0f030f0eu,0x01121025u),\nuvec4(0x63120012u,0x1503255fu,0x15011501u,0x12041021u),\nuvec4(0x20110011u,0x451f5571u,0x4e130fb3u,0x031e03afu),\nuvec4(0x08171b04u,0x090c0917u,0x0f050317u,0x001400a5u),\nuvec4(0x161b0674u,0x01100304u,0x353f0503u,0x4f150302u),\nuvec4(0x2f63cf25u,0x01452f15u,0x10316500u,0x00013011u),\nuvec4(0x02510571u,0x00010001u,0x15411321u,0x03010001u),\nuvec4(0x1c080704u,0x171b4809u,0x04262b09u,0x1fff1503u),\nuvec4(0x81251145u,0x10010022u,0x01120021u,0x05031502u),\nuvec4(0x052f051fu,0x4503355fu,0x10013f03u,0x33310301u),\nuvec4(0x0115230fu,0x01020100u,0x355f6352u,0x00112541u),\nuvec4(0x30120004u,0x20112001u,0xb5310011u,0x05033503u),\nuvec4(0x0f230e13u,0x0e033f03u,0x8f030e03u,0x37040203u),\nuvec4(0x1302062bu,0x0f150f55u,0x02100125u,0x16242604u),\nuvec4(0x0b170807u,0x85210003u,0x1f230f13u,0x0f450315u),\nuvec4(0x030e4f05u,0x031f131fu,0x0305034fu,0x03052185u),\nuvec4(0x01502115u,0x21059100u,0x21001120u,0x11030500u),\nuvec4(0x03020105u,0x15010501u,0x1c090704u,0x0b272809u),\nuvec4(0x0446170du,0x6fff0513u,0x12307135u,0x11120011u),\nuvec4(0x02000200u,0x1f130501u,0x2f051f05u,0x03154f03u),\nuvec4(0x0f053f35u,0x15212005u,0x230f3301u,0x12001105u),\nuvec4(0x03020300u,0x03051322u,0x03055f25u,0x21053125u),\nuvec4(0x03021100u,0x01001170u,0x11002120u,0x0ff51105u),\nuvec4(0x13050345u,0x138f035fu,0x13560412u,0x01250f95u),\nuvec4(0x14010204u,0x17162406u,0x00030719u,0x01050120u),\nuvec4(0x03150f55u,0x1f05030fu,0x4f035fa5u,0x01754f33u),\nuvec4(0x21153100u,0x11001130u,0x51156100u,0x00010200u),\nuvec4(0x05010001u,0x33010501u,0x06210305u,0x290c0907u),\nuvec4(0x1d1b0718u,0x0204460au,0x256fff13u,0x22011091u),\nuvec4(0x05020391u,0x151f0503u,0x454f050fu,0x03010003u),\nuvec4(0x40052f35u,0x05012501u,0x03150f03u,0x04000115u),\nuvec4(0x05221322u,0x256f4523u,0x02010071u,0x11601201u),\nuvec4(0x31300110u,0x01351105u,0x03d50305u,0x05030f15u),\nuvec4(0x156f134fu,0x0001051fu,0x25030256u,0x65032503u),\nuvec4(0x44020302u,0x07090736u,0x60000203u,0x03010011u),\nuvec4(0x3f050335u,0x25030f05u,0x238f133fu,0x3f0e130eu),\nuvec4(0x03053175u,0x10211021u,0x00110011u,0x41231511u),\nuvec4(0x13021312u,0x51052302u,0x09070620u,0x1718390cu),\nuvec4(0x0446070bu,0x656fff23u,0x05010511u,0x00010011u),\nuvec4(0x13711022u,0x01101115u,0x1f050f25u,0x05130255u),\nuvec4(0x2001055fu,0x23250302u,0x3011150fu,0x02031203u),\nuvec4(0x35610201u,0x0021354fu,0x70011051u,0x60011001u),\nuvec4(0x05110551u,0xf5011501u,0x5f134f25u,0x15030f15u),\nuvec4(0x03470201u,0x03650f05u,0x01050355u,0x06171634u),\nuvec4(0x02030b07u,0x80010210u,0x050f1511u,0x056f0513u),\nuvec4(0x2e9f133fu,0x11555f13u,0x01028105u,0x11001140u),\nuvec4(0x03053365u,0x03421102u,0x31101102u,0x09070604u),\nuvec4(0x6617490cu,0x4f130204u,0x752fff0eu,0x22013021u),\nuvec4(0x05811001u,0x12040011u,0x650f0503u,0x00013f83u),\nuvec4(0x05131501u,0x2503150fu,0x02300103u,0x01002203u),\nuvec4(0x01053120u,0x61451f55u,0x11300150u,0x41900120u),\nuvec4(0x11050115u,0x35f50105u,0x4f030f03u,0x03150f15u),\nuvec4(0x0704250fu,0xc5030719u,0x1001350fu,0x1c070614u),\nuvec4(0x0430130bu,0x22006406u,0x03052f13u,0x03051f25u),\nuvec4(0x0e030fffu,0x653f1533u,0x20110071u,0x00111001u),\nuvec4(0x15010011u,0x10514511u,0x40212201u,0x0c091704u),\nuvec4(0x07190c19u,0x0446070bu,0x959fff23u,0x02031251u),\nuvec4(0x05510211u,0x65531501u,0x45230533u,0x0f53150fu),\nuvec4(0x25030f03u,0x01001103u,0x70130402u,0x02010001u),\nuvec4(0x452f4511u,0x30015051u,0x0031e011u,0x11053105u),\nuvec4(0x0f0335f5u,0x012503a5u,0x07190700u,0x15010003u),\nuvec4(0x1501a50fu,0x07061400u,0x3602071cu,0x22044614u),\nuvec4(0x4f230e03u,0x03051305u,0xff050315u,0x45130e1fu),\nuvec4(0x6071650fu,0x013305a1u,0x51151125u,0x04402100u),\nuvec4(0x38191c17u,0x03044607u,0x9fff1302u,0x215251a5u),\nuvec4(0x03150100u,0x65012315u,0x130f3513u,0x7f250365u),\nuvec4(0x01050305u,0x90032220u,0x45110011u,0x1001154fu),\nuvec4(0x40212021u,0x80210011u,0x00310001u,0xc5313571u),\nuvec4(0x2513a513u,0x07040201u,0x02040003u,0x0f450f15u),\nuvec4(0x11351f05u,0x1c090400u,0x22343607u,0x05430204u),\nuvec4(0x2f055f03u,0x13151f05u,0x230fff05u,0x210501d5u),\nuvec4(0x01600100u,0x11000102u,0x05033100u,0x00415501u),\nuvec4(0x12210001u,0x06200100u,0x07191c17u,0x14560718u),\nuvec4(0xafff1302u,0x02034195u,0x00711203u,0x01020301u),\nuvec4(0x03250105u,0x03050302u,0x9f551375u,0x03050f03u),\nuvec4(0x44100452u,0x11600100u,0x41401195u,0x61100100u),\nuvec4(0x41200150u,0x31002110u,0x33a55115u,0x11351395u),\nuvec4(0x01001302u,0x05033513u,0x0f052f03u,0x1c070035u),\nuvec4(0x32440709u,0x6f056302u,0x03155f03u,0x1f150305u),\nuvec4(0x0f059f35u,0x0031a523u,0x10118021u,0x31133581u),\nuvec4(0x03050302u,0x00010301u,0x00110211u,0x0c090706u),\nuvec4(0x66172809u,0x3f051204u,0xc56fff1eu,0x32010201u),\nuvec4(0x02311001u,0x03211501u,0x01052315u,0x03551365u),\nuvec4(0x130f0e6fu,0x03120305u,0x02240032u,0x00021400u),\nuvec4(0x20040604u,0x20018521u,0x10411001u,0x10011051u),\nuvec4(0x10210011u,0x10014011u,0x35b10031u,0x85430503u),\nuvec4(0x0f251311u,0x05111005u,0x15035513u,0x0501251fu),\nuvec4(0x0c090b00u,0x44020709u,0x01011002u,0xff051335u),\nuvec4(0x1f252fc5u,0x81a53305u,0x01501110u,0x11659100u),\nuvec4(0x03050305u,0x11020351u,0x090b0702u,0x0728090cu),\nuvec4(0x15020476u,0x7fff4e1fu,0x10125185u,0x03210001u),\nuvec4(0x31000102u,0x0f050315u,0x45100305u,0x45133513u),\nuvec4(0x0f030e2fu,0x00010503u,0x42001213u,0x52100203u),\nuvec4(0x00110204u,0x05013511u,0x04062001u,0x00020110u),\nuvec4(0x20510001u,0x00110001u,0x90310011u,0x00010001u),\nuvec4(0x35910011u,0x55131503u,0x45130561u,0xe5012401u),\nuvec4(0x14020301u,0x04003427u,0x03040130u,0xff150f05u),\nuvec4(0x0f25f51fu,0xa5131f05u,0x30010021u,0x25319021u),\nuvec4(0x31650103u,0x11003105u,0x01000113u,0x1c070600u),\nuvec4(0x04562739u,0xae1f0512u,0x1e1f0e2fu,0x0521458fu),\nuvec4(0x20011011u,0x00221022u,0x22014581u,0x05136503u),\nuvec4(0x050e531fu,0x0243050fu,0x11030503u,0x11001100u),\nuvec4(0x02032102u,0x11000113u,0x20251105u,0x06043604u),\nuvec4(0x22000204u,0x40c15001u,0x20011011u,0x00510011u),\nuvec4(0x05110001u,0x05011503u,0x91051133u,0x01340155u),\nuvec4(0x1301c503u,0x04b42602u,0x4fff0503u,0x03b51f05u),\nuvec4(0x71851375u,0x51700130u,0x111513c5u,0x41030125u),\nuvec4(0x1c0b0704u,0x070b1729u,0x01003456u,0x1e0fbe0fu),\nuvec4(0x0503257fu,0x15012503u,0x10110061u,0x03013204u),\nuvec4(0x05110091u,0x21020302u,0x13152345u,0x030f0305u),\nuvec4(0x1125830fu,0x05031105u,0x35710531u,0x46143001u),\nuvec4(0x40017012u,0x30010061u,0x10010001u,0x10210211u),\nuvec4(0x00210011u,0x15011351u,0x05210513u,0x40010001u),\nuvec4(0x01350301u,0x04220003u,0x05236502u,0x02030513u),\nuvec4(0x06c40604u,0x05000513u,0x05bf031fu,0x253f050fu),\nuvec4(0x65035503u,0x65031503u,0x01400521u,0x11504110u),\nuvec4(0x01155100u,0x03050365u,0x01050165u,0x04000110u),\nuvec4(0x091c090bu,0x0024b637u,0x038e0305u,0x130f2325u),\nuvec4(0x5503054fu,0x022142b1u,0x02012051u,0x05211300u),\nuvec4(0x05430503u,0x05433503u,0x55031553u,0x05010513u),\nuvec4(0x15013501u,0x02004511u,0x24170644u,0x21000130u),\nuvec4(0x0100f110u,0x31200100u,0x00010200u,0x03211001u),\nuvec4(0x33110331u,0x11000105u,0x35210580u,0x12010503u),\nuvec4(0x13150195u,0x34564402u,0x00050302u,0x15df0304u),\nuvec4(0x231f151fu,0x41e50185u,0x02500130u,0xf50105c1u),\nuvec4(0x01202145u,0x0c0b0704u,0x070b1719u,0x544054c6u),\nuvec4(0x851f0501u,0x35010503u,0x32912501u,0x11200150u),\nuvec4(0x03051312u,0x85130531u,0x01030513u,0x11130563u),\nuvec4(0x15000105u,0x65130501u,0x14235511u,0x16340002u),\nuvec4(0xa1500214u,0x01101100u,0x01203100u,0x01000100u),\nuvec4(0x13024110u,0x43110321u,0x3103c001u,0x95130145u),\nuvec4(0x03001501u,0x04160401u,0x14061416u,0x13252312u),\nuvec4(0x2385af1eu,0x805195f5u,0x10010001u,0x85012551u),\nuvec4(0x0501951fu,0x04111011u,0x07090c17u,0x44d60708u),\nuvec4(0x14201430u,0x00010302u,0x25300335u,0x55031001u),\nuvec4(0x20011271u,0x01225004u,0x15210502u,0x11220021u),\nuvec4(0x03353100u,0x430e0001u,0x01051305u,0x01750170u),\nuvec4(0x12216503u,0x34020004u,0x01020416u,0x61002120u),\nuvec4(0x01007100u,0x2100f130u,0x51130523u,0x05124110u),\nuvec4(0x21050341u,0x11153105u,0x23020115u,0x44262402u),\nuvec4(0x0e5f1523u,0x13658f03u,0x45130115u,0x15110501u),\nuvec4(0x0501a511u,0x90110021u,0x05010071u,0xb51f9501u),\nuvec4(0x04111011u,0x090b0706u,0x76070b18u,0x06071b07u),\nuvec4(0x10017024u,0x40010312u,0x01100105u,0x02011520u),\nuvec4(0x50617503u,0x41423012u,0x22031210u,0x10410001u),\nuvec4(0x13001305u,0x35230e05u,0x01600110u,0x01050f45u),\nuvec4(0x13a50103u,0x04360422u,0x05014002u,0x05113511u),\nuvec4(0x109100b1u,0x35210001u,0x05030513u,0x02510031u),\nuvec4(0x00111200u,0x21031001u,0x11053105u,0x11030500u),\nuvec4(0x24110513u,0x1f133426u,0xa5ff0305u,0x00716513u),\nuvec4(0x13050305u,0x11b09105u,0x11000130u,0x652f05f5u),\nuvec4(0x02012001u,0x0b271b16u,0x14060476u,0x01021062u),\nuvec4(0x11100440u,0x01200210u,0x02010002u,0x31351325u),\nuvec4(0x01000120u,0x02000140u,0x50021004u,0x23022011u),\nuvec4(0x03020312u,0x11220312u,0x23020302u,0x35030f2eu),\nuvec4(0x14000130u,0x03021002u,0x01050305u,0x0f251305u),\nuvec4(0x160400b5u,0x13101234u,0x00119501u,0x310021f1u),\nuvec4(0x03451305u,0x2103c115u,0x01000110u,0x31054105u),\nuvec4(0x01030125u,0x00050105u,0x16041624u,0x1f052304u),\nuvec4(0x35df0305u,0x05012513u,0x03051100u,0x01208125u),\nuvec4(0x15032100u,0x00013031u,0x20116001u,0x55410001u),\nuvec4(0x45132501u,0x1503154fu,0x03011011u,0x470b0706u),\nuvec4(0x10022476u,0x12130234u,0x02143203u,0x00010234u),\nuvec4(0x450f4511u,0x40311511u,0x00022001u,0x10023022u),\nuvec4(0x23120002u,0x43426312u,0x0e0f1305u,0x4015032fu),\nuvec4(0x03020301u,0x10130205u,0x13250204u,0x01050195u),\nuvec4(0x24220410u,0x11a55302u,0x71000100u,0x81000100u),\nuvec4(0x010291e5u,0x01101120u,0x61031105u,0x05430105u),\nuvec4(0x35130274u,0x31c59f1fu,0x41051130u,0x11001110u),\nuvec4(0x01100210u,0x02130203u,0x31502100u,0x01458130u),\nuvec4(0x131e0325u,0x1f050335u,0x41250315u,0x07060402u),\nuvec4(0x1617191bu,0x16041624u,0x01630204u,0x03223305u),\nuvec4(0x06071604u,0x0f6e0304u,0x05010005u,0x00111523u),\nuvec4(0x00224041u,0x03020012u,0xa3321322u,0x33050331u),\nuvec4(0x00255f0eu,0x21020001u,0x23150105u,0x0f152302u),\nuvec4(0x44127175u,0x13051110u,0x110011c5u,0x0135d100u),\nuvec4(0x0160a1d5u,0x00810005u,0x00230513u,0x1e034402u),\nuvec4(0x457f6f03u,0x15030503u,0x15110503u,0x90110001u),\nuvec4(0x70010301u,0x63212001u,0x02113002u,0x151365a1u),\nuvec4(0x532f0e03u,0x13053185u,0x06270602u,0x43153302u),\nuvec4(0x01004112u,0x02101105u,0x22011001u,0x12030204u),\nuvec4(0x051e3305u,0x13050100u,0x01004195u,0x63423322u),\nuvec4(0x0305231fu,0x02010305u,0x8f430501u,0x45330115u),\nuvec4(0x050f331fu,0x01107513u,0x02100145u,0x00021001u),\nuvec4(0x1521b501u,0x03010531u,0x15110511u,0x1175f521u),\nuvec4(0x21506105u,0x11102100u,0x35030100u,0x2e231213u),\nuvec4(0x03253f8fu,0x23150325u,0x11106125u,0x02130170u),\nuvec4(0x01120011u,0x51102110u,0x41152305u,0x11753100u),\nuvec4(0x336f1345u,0x120511b5u,0x02030416u,0x00111005u),\nuvec4(0x02155311u,0x01002113u,0x02400103u,0x10410203u),\nuvec4(0x951e0304u,0x12034503u,0x12131201u,0x01130503u),\nuvec4(0x1f131e73u,0x05030513u,0xbf330213u,0xaf450315u),\nuvec4(0x10350f55u,0x80042014u,0x10750301u,0x15030561u),\nuvec4(0xf5010511u,0x051115f5u,0x20110001u,0x10211001u),\nuvec4(0x13054001u,0x73010001u,0x53350fbfu,0x31250355u),\nuvec4(0x01d01100u,0x01500223u,0x83055130u,0x131513e5u),\nuvec4(0x233f351fu,0x23054195u,0x01100305u,0x13020100u),\nuvec4(0x25231501u,0x10010001u,0x00011001u,0x00010001u),\nuvec4(0x22010211u,0x02000100u,0x03051e01u,0x11050195u),\nuvec4(0x03020312u,0x01030112u,0x134e7335u,0x0305030fu),\nuvec4(0x030e2305u,0x456fffffu,0x02041223u,0x10243013u),\nuvec4(0x00019501u,0xf5030531u,0x0031a5f5u,0x00010001u),\nuvec4(0x10110201u,0x20010001u,0x1003000eu,0x05130501u),\nuvec4(0x532513ffu,0x01a06195u,0x11102130u,0x23a54140u),\nuvec4(0x333503e5u,0x25136f05u,0x1041451fu,0x33221305u),\nuvec4(0x80110071u,0x00041001u,0x01020122u,0x02000220u),\nuvec4(0x2503250eu,0x73f31503u,0x0e0f0315u,0x031f032fu),\nuvec4(0x0e051305u,0x8fffff13u,0x01053375u,0x44001400u),\nuvec4(0x01c50110u,0x11051105u,0x01250105u,0x1105f5f5u),\nuvec4(0x01104105u,0x01200102u,0x43021330u,0x1515df15u),\nuvec4(0x35231533u,0x25030503u,0x2001b041u,0xf5031581u),\nuvec4(0x154f1305u,0x0f15231fu,0x13051325u,0x03055f85u),\nuvec4(0x1021452fu,0x02132112u,0x00018001u,0x03000421u),\nuvec4(0x01800102u,0x12201102u,0x01250e03u,0xf3157302u),\nuvec4(0x037f152fu,0xffff2305u,0x5401d5afu,0xf5002420u),\nuvec4(0x25013531u,0x11c5f501u,0x21003135u,0x13300130u),\nuvec4(0x9f550311u,0x05014535u,0x35132521u,0x80510503u),\nuvec4(0x20111001u,0xb5212531u,0x159f2503u,0x2f557f03u),\nuvec4(0x4f150325u,0x100103a5u,0x02510201u,0x01301103u),\nuvec4(0x03010003u,0x130e1302u,0x10021400u,0x02004214u),\nuvec4(0x050e1314u,0x01020501u,0x630e7312u,0x1f033fffu),\nuvec4(0xffff0315u,0x050185bfu,0x10011501u,0x44000132u),\nuvec4(0x05712503u,0x0021b501u,0xf5413521u,0x01050105u),\nuvec4(0x01207125u,0x05210240u,0x03e50103u,0x21201105u),\nuvec4(0x31050305u,0x00010513u,0x60310011u,0x2523a5d1u),\nuvec4(0x057f5503u,0x450f25efu,0x051f350fu,0x0511551fu),\nuvec4(0x01020311u,0x02230520u,0x36044244u,0x14230204u),\nuvec4(0x03121302u,0x0543f302u,0x9fff2503u,0x7fffff35u),\nuvec4(0x81750f15u,0x02030102u,0x03124001u,0x6511a001u),\nuvec4(0x10110521u,0xc17511f1u,0x01203100u,0x21000130u),\nuvec4(0xd5031112u,0x00110541u,0x00110011u,0x20011001u),\nuvec4(0x03717001u,0x01050105u,0x051f15f5u,0xbfff051fu),\nuvec4(0x41e51f55u,0x03020100u,0x14020311u,0x14021416u),\nuvec4(0x04022022u,0x10122406u,0x83f30543u,0xff051305u),\nuvec4(0x2503050fu,0xffff353fu,0x2061758fu,0x10210011u),\nuvec4(0x12010014u,0x7501a001u,0x00013021u,0x00010001u),\nuvec4(0x20010011u,0x50212571u,0x00712011u,0x22044011u),\nuvec4(0x45113210u,0x11112503u,0x02504105u,0x11400210u),\nuvec4(0x91122120u,0x3f851355u,0xf5ffff05u,0x03505125u),\nuvec4(0x34160402u,0x21300426u,0x05232243u,0x95231573u),\nuvec4(0x7f05afffu,0xff051f15u,0x152f358fu,0x350f153fu),\nuvec4(0xb0310001u,0x01301211u,0x01901100u,0xb0f00120u),\nuvec4(0x50215061u,0x50011041u,0x13a20001u,0x20010501u),\nuvec4(0x0001d001u,0x00413032u,0x01052321u,0x01000105u),\nuvec4(0xffa51355u,0x01a54fffu,0x51050100u,0x04260470u),\nuvec4(0x16141726u,0x05212204u,0x75011301u,0x251f7533u),\nuvec4(0x01056fffu,0x2f250110u,0x151f3523u,0x058f150fu),\nuvec4(0x0100558fu,0x01050145u,0x11004125u,0x001100f0u),\nuvec4(0x0234d021u,0xf0010001u,0x01800190u,0x01e00110u),\nuvec4(0x60020100u,0x04520001u,0x01003132u,0x11400102u),\nuvec4(0x13020160u,0x13252112u,0x03113321u,0x01050115u),\nuvec4(0xff350f95u,0xe52f05afu,0x50112041u,0x14373614u),\nuvec4(0x03041607u,0x0f753112u,0x2f950f05u,0x159fff05u),\nuvec4(0x01001410u,0x03150305u,0x7f950145u,0x0f051105u),\nuvec4(0x11050155u,0x05300120u,0x11001100u,0xf0f01100u),\nuvec4(0x34060440u,0x04003406u,0x14c03470u,0x80f02400u),\nuvec4(0x90010011u,0x10220352u,0x00016001u,0x00111201u),\nuvec4(0x02110001u,0x05310253u,0x13013513u,0xf5110521u),\nuvec4(0x3f35bf15u,0x13750f05u,0x11202195u,0x37461450u),\nuvec4(0x14162406u,0x21000140u,0x1f551f65u,0x159fff25u),\nuvec4(0x01020330u,0x01053105u,0x01050130u,0x0f053f75u),\nuvec4(0x03041005u,0x30011075u,0x02142002u,0x04b0f004u),\nuvec4(0x061a5480u,0x16042604u,0x20740684u,0x16340654u),\nuvec4(0x0220f074u,0x2231a011u,0x21020203u,0x31120312u),\nuvec4(0x11330542u,0x65015503u,0xf5f5f531u,0x31250195u),\nuvec4(0x17660490u,0x0624062au,0x41702204u,0x153f35f5u),\nuvec4(0x0311858fu,0x05310002u,0x10011001u,0x15012511u),\nuvec4(0x14416501u,0x11450103u,0x4a063440u,0x04001406u),\nuvec4(0x24000480u,0x04162450u,0xaa561446u,0x2a160426u),\nuvec4(0x04063416u,0x24360416u,0x0634567au,0xc012c054u),\nuvec4(0x05110311u,0x02031223u,0x13210203u,0x35613511u),\nuvec4(0x75414511u,0x15010551u,0x00118511u,0x1035f501u),\nuvec4(0x10011011u,0x46048001u,0x14063a47u,0xb0120406u),\nuvec4(0xf5410001u,0x1f452f05u,0x41450195u,0x02000120u),\nuvec4(0x00610001u,0x01401135u,0x03020400u,0x11001110u),\nuvec4(0x6a262410u,0x14961a07u,0x24161466u,0xfafafa16u),\nuvec4(0x94363afau,0x12000260u,0x11003130u,0x01300330u),\nuvec4(0x05816315u,0x0561c531u,0x30010041u,0x01002521u),\nuvec4(0x01050100u,0x11000120u,0x31050100u,0x01151155u),\nuvec4(0x01300120u,0x21001110u,0x44161400u,0x14163a27u),\nuvec4(0x11c01406u,0x1fc56110u,0x011500c5u,0x01150110u),\nuvec4(0x01102125u,0x21300410u,0x16a00120u,0x16241034u),\nuvec4(0x3406cafau,0xfa162406u,0xaafafafau,0x04461446u),\nuvec4(0x32000260u,0x50121100u,0x00410201u,0x05033511u),\nuvec4(0x15110501u,0x05010521u,0x05d12511u,0x00011071u),\nuvec4(0x00110521u,0x00110001u,0x10013011u,0x25313005u),\nuvec4(0x00011011u,0x34900103u,0x14161426u,0x07080716u),\nuvec4(0x04161a08u,0x60020416u,0x00015031u,0x0f35f541u),\nuvec4(0x11301135u,0x14801130u,0x04002400u,0x01300110u),\nuvec4(0x14200100u,0x24062a16u,0x07fafa06u,0x0624063au),\nuvec4(0xfafafafau,0x34266afau,0x11a00400u,0x41000130u),\nuvec4(0x31154100u,0xf1056125u,0x00610541u,0x00010021u),\nuvec4(0x10011011u,0x20214001u,0x00211021u,0x10113001u),\nuvec4(0x36044664u,0x4a06270au,0x14160a17u,0x11120406u),\nuvec4(0x314571f0u,0x01750105u,0x54264460u,0x44365a66u),\nuvec4(0xaafafa16u,0xfafafa17u,0x5afafafau,0x04302446u),\nuvec4(0x01401480u,0xf1003100u,0x00a10021u,0x00013021u),\nuvec4(0x1470f041u,0x64063430u,0x24362426u,0x4a074a26u),\nuvec4(0x14361a17u,0x303180f0u,0x20112541u,0xfafa2614u),\nuvec4(0xfafafafau,0xfafafafau,0x2a07aafau,0x0a060a07u),\nuvec4(0x00803416u,0x10010034u,0x00010001u,0x70f140f1u),\nuvec4(0x30011001u,0x16441654u,0x76240604u,0x3614b614u),\nuvec4(0x075a0614u,0x560a274au,0x6170f084u,0xfa261410u),\nuvec4(0xfafafafau,0xfafa077au,0xfafafafau,0x080a079au),\nuvec4(0x1416370au,0x34202400u,0xc0210302u,0x70115041u),\nuvec4(0x56845071u,0x16141614u,0x06141604u,0x362a367au),\nuvec4(0x06145654u,0x0a08079au,0x44b60406u,0x113021d0u),\nuvec4(0xfa160420u,0xfafafafau,0xfafa07bau,0xfafafafau),\nuvec4(0x070917dau,0x4446040bu,0x50121406u,0x0120f001u),\nuvec4(0x01000100u,0x64507100u,0x54660706u,0x44260406u),\nuvec4(0xfa160406u,0x2afa362au,0xf6140627u,0x1400f054u),\nuvec4(0xfafafa06u,0xfafafafau,0xfafafafau,0x0b27bafau),\nuvec4(0x26962417u,0x1130f004u,0x01000150u,0x00121305u),\nuvec4(0x34020402u,0x1a06fa96u,0xfa077406u,0x24478afau),\nuvec4(0x06d456f6u,0xfafafafau,0xfafafafau,0x4afafafau),\nuvec4(0x092d0b07u,0x34472afau,0x707426b6u,0x15410011u),\nuvec4(0x76243001u,0xfafafafau,0x764a37fau,0x2426f604u),\nuvec4(0xfafafa66u,0xfafafafau,0xfafafafau,0x076d074au),\nuvec4(0x070a08fau,0x96044624u,0x14860406u,0x11206426u),\nuvec4(0xfa461402u,0xfafafafau,0x0708274au,0x6406f6dau),\nuvec4(0xfafafa46u,0xfafafafau,0xfafafafau,0x0b371d7au),\nuvec4(0x162afa0du,0xf6448684u,0xfa460a56u,0xfafafafau),\nuvec4(0x660afafau,0xfafa2674u,0xfafafafau,0xfafafafau),\nuvec4(0x090ddafau,0x0d070907u,0x27ea071au,0x24369416u),\nuvec4(0x164406f6u,0xfafafafau,0xfafa17fau,0x063446bau),\nuvec4(0xfafafafau,0xfafafafau,0xeafafafau,0x4d070a17u),\nuvec4(0x07ca170au,0x04364708u,0xf6165436u,0xfafafa26u),\nuvec4(0x083afafau,0xfafafa27u,0xfa17085au,0xfafafafau),\nuvec4(0xfafafafau,0x07aafafau,0x070a070bu,0x0b070a2du),\nuvec4(0x6a47da07u,0x46760a16u,0xfafa061au,0xfafafafau),\nuvec4(0xfafa072au,0xfafa08aau,0xfafafafau,0xfafafafau),\nuvec4(0x176afafau,0x070a0709u,0x09070a0bu,0xfa578a17u),\nuvec4(0xfafa460au,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0x09271a37u,0xfa07ba07u),\nuvec4(0xfafafa7au,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0x0afafafau,0x17092709u,0x27ca0709u),\nuvec4(0xfafa5afau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0x2709170au,0x08aa0709u),\nuvec4(0x2afa472au,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0x472afafau,0x17081afau),\nuvec4(0xfada172au,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0x57eafafau,0x070a081au),\nuvec4(0x0a3a070au,0x1a171a17u,0xfafafa17u,0x077afafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0x671afafau,0x0847da2au,0x8a371a17u,0x270afa17u),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafa4afau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0xfafafafau,0xfafafafau),\nuvec4(0xfafafafau,0xfafafafau,0x0000fafau,0x00000000u));\nconst int rowindex[] = int[](\n0,47,103,168,251,327,407,481,541,630,714,780,840,914,990,1069,1165,1264,1341,1431,1528,1639,1755,1906,2055,2204,2364,2516,2677,2816,2958,3097,3230,3356,3482,3595,3714,3837,3971,4088,4230,4383,4537,4669,4802,4952,5081,5219,5365,5509,5670,5841,6046,6218,6387,6525,6682,6846,7029,7205,7382,7538,7693,7865,8053,8220,8391,8557,8722,8874,9027,9170,9325,9466,9606,9765,9942,10099,10254,10435,10602,10781,10961,11129,11295,11463,11621,11791,11957,12133,12295,12471,12655,12842,13033,13207,13380,13539,13691,13852,14017,14190,14353,14514,14680,14865,15034,15215,15400,15589,15781,15953,16121,16297,16469,16649,16821,17004,17187,17382,17572,17758,17930,18112,18290,18450,18624,18805,19006,19169,19331,19494,19674,19846,20028,20228,20426,20619,20795,20968,21127,21288,21446,21605,21772,21931,22085,22227,22365,22491,22628,22779,22922,23063,23204,23353,23486,23618,23770,23921,24069,24210,24353,24489,24625,24735,24837,24957,25060,25175,25265,25370,25480,25594,25698,25805,25912,26030,26113,26179,26247,26312,26371,26425,26472,26518,26560,26603,26647,26690,26721,26754,26788,26819,26851,26885,26918,26943,26968,26993,27018);\n\nconst int WIDTH = 400;\nconst int HEIGHT = 200;\n\nconst vec3 colors[] = vec3[](\nvec3(0x20,0xa0,0xe0),\nvec3(0x10,0x90,0xd0),\nvec3(0x20,0x90,0xb0),\nvec3(0x10,0x60,0xb0),\nvec3(0x60,0xc0,0xd0),\nvec3(0x10,0x70,0xd0),\nvec3(0xa0,0xe0,0xf0),\nvec3(0xb0,0xc0,0x90),\nvec3(0xe0,0xd0,0xa0),\nvec3(0xb0,0xa0,0x60),\nvec3(0xe0,0xe0,0xe0),\nvec3(0x50,0xa0,0x60),\nvec3(0x90,0x70,0x30),\nvec3(0x50,0x60,0x30),\nvec3(0x10,0x40,0xb0),\nvec3(0x10,0x60,0xd0));\n\nvec3 getcolor(int i) {\n  return colors[i%colors.length()]/255.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  float ires = iResolution.x*10000.0 + iResolution.y;\n  if (iFrame != 0 && fragColor.w == ires) return; // Check for resize\n  fragColor.w = ires;\n  int row = int(fragCoord.y); // Desired row\n  row = min(row,HEIGHT-1); // Clamp at edges\n  int col = int(fragCoord.x); // Desired column\n  col = min(col,WIDTH-1); // Clamp at edges\n  // Find the index of the start of the row\n  int rstart = rowindex[row];\n  // And of the next row\n  int rend = rowindex[row+1];\n  int c = -1;\n  int colcount = 0; // column count\n  for (int index = rstart; index < rend; index++) {\n    int i = index;\n    uvec4 entry = data[i/16];\n    i %= 16;\n    uint t = entry[i/4];\n    i %= 4;\n    t >>= 8*i;\n    int count = (int(t >> 4)&15)+1;\n    colcount += count;\n    if (col < colcount) {\n      c = int(t)&15; // Found it!\n      break;\n    }\n  }\n  if (c < 0) fragColor.rgb = vec3(1,0,0); // Shouldn't happen\n  else fragColor.rgb = getcolor(c);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 118, 118, 139], [140, 140, 160, 160, 174], [176, 176, 207, 207, 416], [418, 418, 457, 457, 868], [870, 870, 908, 908, 1022], [1024, 1055, 1085, 1085, 1130], [1132, 1132, 1170, 1170, 2223], [2227, 2227, 2281, 2281, 2871]]}
{"id": "NdVcWd", "name": "iTime vs iFrame", "author": "FabriceNeyret2", "description": "Challenge the render by shaking the window and/or causing mouse events.\nUsing iTime (left) is better for fluid animation (despite ireg fps), at same target speed whatever the system.\nUsing iFrame (right) is better for exact correspondance with prev frame.", "tags": ["blur", "animation", "tuto", "relaxation", "itime", "iframe"], "likes": 15, "viewed": 1376, "published": 3, "date": "1655832840", "time_retrieved": "2024-07-30T16:43:47.258714", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = texelFetch(iChannel0, ivec2(u), 0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = (2.*u - R ) / R.y;\n    float x = U.x;\n    U.x -= .8*sign(x);                      // offset for the 2 views\n    float t = x<0. ? iTime                  // left use iTime, assumed 60 fps\n                   : float(iFrame)/60.,     // right use iFrame\n          a = mod( atan(U.y,U.x) - t , 6.283 ) -3.1415;   // rotating angle\n    O =  max(  pow(vec4(.9,.8,.7,0),vec4(.05))            // fade past color\n             * texelFetch(iChannel0, ivec2(u), 0 ),\n             vec4( step( abs(a) - .5/60. , 0. ) )         // draw new fan segment\n         //  vec4( smoothstep( 3./R.y/length(U), 0., abs(a) - .5/60. ) )\n            );\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 85]]}
{"id": "7dycDV", "name": "Wind Waves of Cyclone using HDF", "author": "gehtsiegarnixan", "description": "Hex Directional Flow with a cyclone flow map and a Sinewave perpendicular to the Flow Vector like water waves", "tags": ["wave", "water", "hexagon", "sine", "hex", "gabor", "flowmap", "wind", "vectorfield", "viridis", "cyclone", "directionalflow"], "likes": 28, "viewed": 692, "published": 3, "date": "1655832377", "time_retrieved": "2024-07-30T16:43:47.998735", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nUpdate: I made a faster version using my Square Directional Flow \n(https://www.shadertoy.com/view/7ddBWl).\n\nThis is using my Hex Directional Flow algorithm \n(https://www.shadertoy.com/view/fsGyDG) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nI played around with circular and straight waves, but the circular ones don't look \nthat different for how much more work they are. So I kept the straight waves, but see\ndD and cD to test for yourself.\n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n#define sqrt3 \t\t\t1.7320508076 //sqrt(3)\n#define half_sqrt3\t\t0.8660254038 //sqrt(3)/2\n#define inv_sqrt3\t\t0.5773502693 // 1/sqrt(3)\n#define inv_twice_sqrt3\t0.2886751346 // 1/(2 sqrt(3))\n\n// if you want flat tops (hex rotated by 30deg) swap xy in hr and the p.x to p.y in hexDist\nconst vec2 r = vec2(1, sqrt3); // 1, sqrt(3)\nconst vec2 h = vec2(0.5,half_sqrt3); // 1/2, sqrt(3) /2\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p) {\n\tp = abs(p);   \n    return max(dot(p, h), p.x);\n}\n\n// struct to fill with needed HexTile Parametes\nstruct hexParams {\n  vec2 gv;\n  vec2 id;\n  float edist;\n};\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nhexParams hexTile(vec2 uv) {   \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b; //center hex UV coords\n    \n    // float edist = .5-hexDist(gv);  // Edge distance.\n    float edist = (.5-hexDist(gv))*2.; //  Edge distance with range 0-1\n    // float cdist = dot(gv, gv); // squared distance from the center.\n    // float cdist = dot(gv, gv)*3.; // squared distance with range 0-1\n    vec2 id = uv-gv; // simple ID calculation\n    \n    return hexParams(gv,id,edist); // xy hex coords + z distance to edge\n}\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// generates pixelated directional waves\nfloat flowHexCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    hexParams hexValues = hexTile(uv * gridRes + offset); \n    hexValues.gv =  hexValues.gv / gridRes;\n    hexValues.id = (hexValues.id - offset)/ gridRes;    \n    \n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(hexValues.id - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    //float cD = length(hexValues.gv + (dir/(gridRes))); //Circular Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, hexValues.id).x;\n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * hexValues.edist; // apply amplitue and alpha mask    \n    return wave;\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowHexCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowHexCell(uv, vec2(0,inv_sqrt3), gridRes, time, len);\n    float c = flowHexCell(uv, vec2(0.5,inv_twice_sqrt3), gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dycDV.jpg", "access": "api", "license": "mit", "functions": [[3438, 3484, 3507, 3507, 3557], [3667, 3741, 3769, 3769, 4301], [4303, 4384, 4407, 4407, 4855], [4857, 4895, 4920, 4920, 4950], [4952, 4990, 5014, 5014, 5044], [5046, 5085, 5141, 5141, 6331], [6333, 6374, 6453, 6453, 7631], [7633, 7699, 7772, 7772, 8009], [8011, 8011, 8068, 8068, 8434]]}
{"id": "fdKcWd", "name": "Flowmap Topical Cyclone", "author": "gehtsiegarnixan", "description": "This generates a flow map approximating a tropic cyclone. The one I used as reverence had a diameter of around 300km.", "tags": ["swirl", "flow", "field", "vector", "archimedes", "flowmap", "vectorfield", "tornado", "cyclone"], "likes": 25, "viewed": 670, "published": 3, "date": "1655832370", "time_retrieved": "2024-07-30T16:43:48.783637", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is an approximation of a tropical cyclone flowmap at sea level. \nThe reference cyclone had a diamter of 300km. The maximum velocity was 53m/s. \nIt was generated using the CM1 weather model in a super computer. \n\nThe flowmap is just a vector field that can be used for other stuff like this \n(https://www.shadertoy.com/view/7dycDV)\n\nThe quiver plot is from Reima (https://www.shadertoy.com/view/ls2GWG)\n*/\n\n#define twoPi           6.2831853072\n#define pi              3.1415926536\n#define ARROW_TILE_SIZE 32.0\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n\tvec2 center = (p1 + p2) * 0.5;\n\tfloat len = length(p2 - p1);\n\tvec2 dir = (p2 - p1) / len;\n\tvec2 rel_p = p - center;\n\tfloat dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n\tfloat dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n\treturn max(dist1, dist2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n\tfloat mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE * 0.5);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\n\t\t// Signed distance from shaft\n\t\tfloat shaft = line(p, v, -v);\n\t\t// Signed distance from head\n\t\tfloat head = min(line(p, v, 0.4*v + 0.2*vec2(-v.y, v.x)),\n\t\t                 line(p, v, 0.4*v + 0.2*vec2(v.y, -v.x)));\n\n\t\treturn min(shaft, head);\n\t} else {\n\t\t// Signed distance from the center point\n\t\treturn mag_p;\n\t}\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x) {\n    return (1.0 + x) / 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212; //\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05; // makes sure mask is 0-1 range\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    //flow += vec2(0.00001,0.00001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float radius = 0.3; // of the first spiral\n    float time = iTime * 1.0; // rotation speed  \n    vec2 uv = (fragCoord.xy- (0.5*iResolution.xy))/iResolution.y; // center screen coords \n    \n    vec2 flowMap = cycloneFlow(uv, radius, time);    \n        \n    float arrow_dist = arrow(fragCoord.xy, flowMap* ARROW_TILE_SIZE * 0.4);\n\tvec4 arrow_col = vec4(0, 0, 0, clamp(arrow_dist, 0.0, 1.0));\n\n    fragColor = mix(arrow_col, vec4(make0to1(flowMap),0.5,1.0), arrow_col.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKcWd.jpg", "access": "api", "license": "mit", "functions": [[1598, 1660, 1697, 1697, 1763], [1765, 1817, 1855, 1855, 2101], [2103, 2249, 2278, 2346, 3048], [3050, 3088, 3112, 3112, 3142], [3144, 3182, 3205, 3205, 3235], [3237, 3276, 3332, 3332, 4561], [4563, 4563, 4620, 4620, 5095]]}
{"id": "NdyyWy", "name": "Flowmap Donut", "author": "gehtsiegarnixan", "description": "This generates a flow map of a donut.", "tags": ["flow", "field", "vector", "flowmap", "vectorfield"], "likes": 12, "viewed": 433, "published": 3, "date": "1655832365", "time_retrieved": "2024-07-30T16:43:49.579510", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a donut shaped flowmap I did for testing. \n\nThe quiver plot is from Reima (https://www.shadertoy.com/view/ls2GWG)\n*/\n\n#define ARROW_TILE_SIZE 32.0\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// Computes the signed distance from a line segment\nfloat line(vec2 p, vec2 p1, vec2 p2) {\n\tvec2 center = (p1 + p2) * 0.5;\n\tfloat len = length(p2 - p1);\n\tvec2 dir = (p2 - p1) / len;\n\tvec2 rel_p = p - center;\n\tfloat dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n\tfloat dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n\treturn max(dist1, dist2);\n}\n\n// v = field sampled at arrowTileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns a signed distance from the arrow\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n\tfloat mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE * 0.5);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\n\t\t// Signed distance from shaft\n\t\tfloat shaft = line(p, v, -v);\n\t\t// Signed distance from head\n\t\tfloat head = min(line(p, v, 0.4*v + 0.2*vec2(-v.y, v.x)),\n\t\t                 line(p, v, 0.4*v + 0.2*vec2(v.y, -v.x)));\n\n\t\treturn min(shaft, head);\n\t} else {\n\t\t// Signed distance from the center point\n\t\treturn mag_p;\n\t}\n}\n\n//shifts value range from -1-1 to 0-1\nvec2 make0to1(vec2 x) {\n    return (1.0 + x) / 2.0;\n}\n\n// makes a simple flowmap in the shape a donut swirl centered on point\nvec2 donutFlow(vec2 point, float spread, float offset)\n{    \n    float cenderDistance = length(point); // distance to center    \n    // simple inverted x^2 https://www.desmos.com/calculator/ibidozowyh\n    float donut =  1.0-pow(2.0*(cenderDistance-offset)/spread, 2.0);     \n    donut = clamp(donut, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(-point.y, point.x)); // flow vectors\n    flow *= donut;  // masked by donut\n    //flow = (flow+1.0)/2.0; // generates a flowmap texture\n    //flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy- (0.5*iResolution.xy))/iResolution.y; // center screen coords \n    uv += vec2(cos(iTime),sin(iTime))*0.1; //rotating center\n    float spread = mix(0.4, 0.3, sin(0.9*iTime)*0.5+0.5); //changing donut size\n    \n    // making flowmap\n    vec2 flowMap = donutFlow(uv, spread, 0.33);\n     \n    //adding arrows\n    float arrow_dist = arrow(fragCoord.xy, flowMap* ARROW_TILE_SIZE * 0.4);\n\tvec4 arrow_col = vec4(0, 0, 0, clamp(arrow_dist, 0.0, 1.0));\n    \n    fragColor = mix(arrow_col, vec4(make0to1(flowMap),0.5,1.0), arrow_col.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyyWy.jpg", "access": "api", "license": "mit", "functions": [[1239, 1301, 1338, 1338, 1404], [1406, 1458, 1496, 1496, 1742], [1744, 1890, 1919, 1987, 2689], [2691, 2729, 2752, 2752, 2782], [2784, 2855, 2911, 2911, 3438], [3440, 3440, 3497, 3497, 4053]]}
{"id": "ssGcWd", "name": "Retro loading screen", "author": "Peace", "description": "retro loading screen, with scrolling text and 3D background", "tags": ["oldschool", "retro", "loadingscreen", "blockytext"], "likes": 4, "viewed": 290, "published": 3, "date": "1655815907", "time_retrieved": "2024-07-30T16:43:50.498053", "image_code": "vec2 uv;\nvec3 col = vec3(0);\nvec3 fill = vec3(0);\nfloat width = 0.01;\nvec3 color = vec3(0);\nfloat cx = 0.0;\nfloat cy = 0.0;\nfloat cs = 0.0;\n\n#define _ST(x, y, s) cx = x; cy = y; cs = s;\n#define _ADV cx += cs * (3.0 / 5.0) * 1.1;\n#define _LET(let) let(cx, cy, cs); _ADV\n#define _A _LET(A)\n#define _B _LET(B)\n#define _C _LET(C)\n#define _D _LET(D)\n#define _E _LET(E)\n#define _F _LET(F)\n#define _G _LET(G)\n#define _H _LET(H)\n#define _I _LET(I)\n#define _J _LET(J)\n#define _K _LET(K)\n#define _L _LET(L)\n#define _M _LET(M)\n#define _N _LET(N)\n#define _O _LET(O)\n#define _P _LET(P)\n#define _Q _LET(Q)\n#define _R _LET(R)\n#define _S _LET(S)\n#define _T _LET(T)\n#define _U _LET(U)\n#define _V _LET(V)\n#define _W _LET(W)\n#define _X _LET(X)\n#define _Y _LET(Y)\n#define _Z _LET(Z)\n#define _0 _LET(zero)\n#define _1 _LET(one)\n#define _2 _LET(two)\n#define _3 _LET(three)\n#define _4 _LET(four)\n#define _5 _LET(five)\n#define _6 _LET(six)\n#define _7 _LET(seven)\n#define _8 _LET(eight)\n#define _9 _LET(nine)\n#define _SP _ADV\n\nvoid rect(float x, float y, float w, float h)\n{\n    if(uv.x >= x && uv.x <= x + w && uv.y >= y && uv.y <= y + h)\n        if(!(uv.x >= x + width && uv.x <= x + w - width && uv.y >= y + width && uv.y <= y + h - width))\n            color = col;\n        else\n            color = fill;\n}\n\nvoid A(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n}\n\nvoid B(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n}\n\nvoid C(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n}\n\nvoid D(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n}\n\nvoid E(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n}\n\nvoid F(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid G(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n}\n\nvoid H(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid I(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 1.0, y + d * 1.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 1.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n}\n\n\nvoid J(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n}\n\nvoid K(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid L(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n}\n\nvoid M(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n}\n\nvoid N(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n}\n\nvoid O(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n}\n\nvoid P(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n}\n\nvoid Q(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n}\n\nvoid R(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid S(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid T(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 1.0, y + d * 1.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 1.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid U(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid V(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid W(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid X(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid Y(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid Z(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n}\n\nvoid zero(float x, float y, float s)\n{\n     float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n}\n\nvoid one(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 1.0, y + d * 1.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 1.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n}\n\nvoid two(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n}\n\nvoid three(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n}\n\nvoid four(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n}\n\nvoid five(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n}\n\nvoid six(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n}\n\nvoid seven(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n}\n\nvoid eight(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 0.0, y + d * 1.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n}\n\nvoid nine(float x, float y, float s)\n{\n    float size = 5.0;\n    float w = s / size;\n    float d = w - width;\n    rect(x + d * 0.0, y + d * 0.0, w, w);\n    rect(x + d * 1.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 0.0, w, w);\n    rect(x + d * 2.0, y + d * 1.0, w, w);\n    rect(x + d * 0.0, y + d * 2.0, w, w);\n    rect(x + d * 1.0, y + d * 2.0, w, w);\n    rect(x + d * 2.0, y + d * 2.0, w, w);\n    rect(x + d * 0.0, y + d * 3.0, w, w);\n    rect(x + d * 0.0, y + d * 4.0, w, w);\n    rect(x + d * 1.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 4.0, w, w);\n    rect(x + d * 2.0, y + d * 3.0, w, w);\n}\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define COLOR1 vec3(0.9, 0.9, 0.9)\n#define COLOR2 vec3(0.03, 0.03, 0.03)\n#define LIGHTCOLOR  vec3(0.94, 0.95, 1.)\n\n#define ARMS 10.\n#define DENSITY 2.\n#define ANGLE_SPEED 2.\n#define ANGLE_TEMPO 3.\n#define SPEED 2.\n#define SMOOTH 0.02\n\nfloat smoothstepCheckerboard(in vec2 uv) \n{\n    uv = fract(uv + 0.25);\n    float sm2 = SMOOTH * 0.5;\n    vec2 p01 =\n        smoothstep(0.25 - sm2, 0.25 + sm2, uv) -\n        smoothstep(0.75 - sm2, 0.75 + sm2, uv);\n    vec2 pn11 = (p01 - 0.5) * 2.;\n    return 0.5 - 0.5 * pn11.x * pn11.y;\n}\n\nvoid checkerboardTunnel()\n{\n    float a = atan(uv.x, uv.y);\n    float r = length(uv);\n    float w = a - sin(1. / r) * r * ANGLE_SPEED * sin((iTime - 1./r) / ANGLE_TEMPO);\n    vec2 polar = vec2(w * ARMS / PI2, 1. / r * DENSITY + iTime * SPEED );\n    vec3 checker = mix(COLOR1, COLOR2,smoothstepCheckerboard(polar));\n    float light = smoothstep(0.7, 0.2, r);\n    color = mix(checker, LIGHTCOLOR, light);\n    color = pow(color, vec3(1./2.2));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    uv = vec2(ivec2(uv * iResolution.xy * 0.15)) / (iResolution.xy * 0.15);\n    checkerboardTunnel();\n    uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    col = color * 0.4;\n    fill = mix(color, vec3(1.0, uv.yx),  0.9);\n    width = 0.0125;\n    _ST(-1.0, 0.1 + sin(iTime * 4.0) * 0.03, 0.75)_B _T _C _R\n    \n    float a = iResolution.x/iResolution.y;\n    fill = color * 0.2;\n    width = 0.03;\n    rect(-a * 2.0, -0.8, a * 4.0, 0.35);\n    \n    col = vec3(0);\n    fill = vec3(1);\n    fill = vec3(sin(iTime * 3.0) * 0.5 + 1.2, sin(-iTime * 3.0) * 0.5 + 1.2, cos(iTime * 3.0) * 0.5 + 1.2); //Colorful play text\n    width = 0.0;\n    \n    _ST(a - mod(iTime, a * 2.5), -0.7, 0.15)\n    _P _L _A _Y\n    \n    \n    color = color * (1.0 - pow(length(uv), 3.0) * 0.1);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1001, 1001, 1048, 1048, 1283], [1285, 1285, 1320, 1320, 1813], [1815, 1815, 1850, 1850, 2427], [2429, 2429, 2464, 2464, 2915], [2917, 2917, 2952, 2952, 3445], [3447, 3447, 3482, 3482, 3975], [3977, 3977, 4012, 4012, 4421], [4423, 4423, 4458, 4458, 4951], [4953, 4953, 4988, 4988, 5523], [5525, 5525, 5560, 5560, 6011], [6014, 6014, 6049, 6049, 6500], [6502, 6502, 6537, 6537, 7030], [7032, 7032, 7067, 7067, 7434], [7436, 7436, 7471, 7471, 8006], [8008, 8008, 8043, 8043, 8536], [8538, 8538, 8573, 8573, 9150], [9152, 9152, 9187, 9187, 9680], [9682, 9682, 9717, 9717, 10210], [10212, 10212, 10247, 10247, 10782], [10784, 10784, 10819, 10819, 11354], [11356, 11356, 11391, 11391, 11758], [11760, 11760, 11795, 11795, 12330], [12332, 12332, 12367, 12367, 12818], [12820, 12820, 12855, 12855, 13390], [13392, 13392, 13427, 13427, 13878], [13880, 13880, 13915, 13915, 14282], [14284, 14284, 14319, 14319, 14770], [14772, 14772, 14810, 14810, 15220], [15222, 15222, 15259, 15259, 15584], [15586, 15586, 15623, 15623, 16032], [16034, 16034, 16073, 16073, 16608], [16610, 16610, 16648, 16648, 17099], [17101, 17101, 17139, 17139, 17632], [17634, 17634, 17671, 17671, 18248], [18250, 18250, 18289, 18289, 18656], [18658, 18658, 18697, 18697, 19316], [19318, 19318, 19356, 19356, 19933], [20223, 20223, 20266, 20266, 20511], [20513, 20513, 20540, 20540, 20955]]}
{"id": "fdGyWt", "name": "XXHash32", "author": "AshenFlowersFalling", "description": "GLSL port of old version of XXHash32\n\nAlso includes a high-quality random float generator", "tags": ["noise", "random", "hash"], "likes": 1, "viewed": 315, "published": 3, "date": "1655769772", "time_retrieved": "2024-07-30T16:43:51.275973", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(random(vec3(fragCoord, float(iFrame))));\n}", "image_inputs": [], "common_code": "#define USE_MAX 1  // use \"max\" as the comparison, otherwise use \"min\"\n#define QUANTIZE 0 // quantise initial noise to 8-bits?\n\n#define INIT_FRAMES 1\n\n#define R2 19\n\n#define SIGMA 1.41421356237\n#define M_PI 3.14159265359\n\n// high-quality hash, modified version of old version of XXHash32 from https://github.com/Cyan4973/xxHash (BSD license)\n\nstruct vec5\n{\n\tfloat v[5];\n};\nstruct uvec5\n{\n\tuint v[5];\n};\nstruct vec6\n{\n\tfloat v[6];\n};\nstruct uvec6\n{\n\tuint v[6];\n};\n\nuvec6 touvec6(uvec5 x) { uvec6 x6;    x6.v[0] = x.v[0]; x6.v[1] = x.v[1]; x6.v[2] = x.v[2]; x6.v[3] = x.v[3]; x6.v[4] = x.v[4]; x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec4 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = x.w;    x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec3 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec2 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uint  x) { uvec6 x6;    x6.v[0] = x;      x6.v[1] = uint(0);x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\n\n#define PRIME32_1\t2654435761U\n#define PRIME32_2\t2246822519U\n#define PRIME32_3\t3266489917U\n#define PRIME32_4\t668265263U\n#define PRIME32_5\t374761393U\n\nuint rotl32(uint x, int shift)\n{\n\treturn (x << shift) | (x >> (32 - shift));\n}\nvoid XXH32_InitV(inout uint v[4], uint seed)\n{\n    v[0] = seed + PRIME32_1 + PRIME32_2;\n    v[1] = seed + PRIME32_2;\n    v[2] = seed + uint(0);\n    v[3] = seed - PRIME32_1;\n}\nvoid XXH32_Inner(const uint p[4], inout uint v[4])\n{\n    v[0] += p[0] * PRIME32_2;\n    v[0] = rotl32(v[0], 13);\n    v[0] *= PRIME32_1;\n\n    v[1] += p[1] * PRIME32_2;\n    v[1] = rotl32(v[1], 13);\n    v[1] *= PRIME32_1;\n\n    v[2] += p[2] * PRIME32_2;\n    v[2] = rotl32(v[2], 13);\n    v[2] *= PRIME32_1;\n\n    v[3] += p[3] * PRIME32_2;\n    v[3] = rotl32(v[3], 13);\n    v[3] *= PRIME32_1;\n}\n\nuint XXHash32_32(uint input_s[8])\n{\n    uint h32;\n\tuint v[4];\n\n\tXXH32_InitV(v, uint(0));\n\n\tXXH32_Inner(uint[4](input_s[0], input_s[1], input_s[2], input_s[3]), v);\n    XXH32_Inner(uint[4](input_s[4], input_s[5], input_s[6], input_s[7]), v);\n\n    h32 = rotl32(v[0], 1) + rotl32(v[1], 7) + rotl32(v[2], 12) + rotl32(v[3], 18);\n\n    h32 += uint(32);\n\n    h32 ^= h32 >> 15;\n    h32 *= PRIME32_2;\n    h32 ^= h32 >> 13;\n    h32 *= PRIME32_3;\n    h32 ^= h32 >> 16;\n\n    return h32;\n}\n\nuint hash(uvec6 x, uint seed) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(seed));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec4 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec3 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec2 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uint x, uint seed)  { return hash(touvec6(x), seed);}\nuint hash(uvec6 x) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(0));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x) { return hash(touvec6(x));}\nuint hash(uvec4 x) { return hash(touvec6(x));}\nuint hash(uvec3 x) { return hash(touvec6(x));}\nuint hash(uvec2 x) { return hash(touvec6(x));}\nuint hash(uint x)  { return hash(touvec6(x));}\n\nuint lzcnt(uint x)\n{\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    \n    uint c;\n    \n    x = x - ((x >> 1) & uint(0x55555555));                    \n    x = (x & uint(0x33333333)) + ((x >> 2) & uint(0x33333333));\n    c = ((x + (x >> 4) & uint(0xF0F0F0F)) * uint(0x1010101)) >> 24;\n\n    return uint(32) - c;\n}\n\n// random float that uses the full range from [0, 1)\n\nfloat floatrandhq(uvec6 x) \n{\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint mantissabits = uint(23);\n    const uint exponentbits = uint(8);\n    const uint hashbits     = uint(32);\n    const uint hashbitslg2  = uint(5);\n    uint current;\n    uint cnt;\n    uint pw2;    \n    // ceil((2^(ebits - 1) - 2) / 2^hashbits)\n    uint maxrec = (uint(1 << (exponentbits - uint(1))) - uint(2) + hashbits - uint(1)) >> hashbitslg2;\n    uint m;\n    uint i;\n    \n    current = hash(x, uint(0));\n    cnt = lzcnt(current);\n    pw2 = cnt;\n\n    for (i = uint(1); (i < maxrec) && (cnt == hashbits); i++)\n    {\n        current = hash(x, i +  uint(1));\n        cnt = lzcnt(current);\n        pw2 += cnt;\n    }\n    \n    // if less than 23 bits left, we need to generate a new hash to fill the mantissa\n    if ((int(hashbits) - int(cnt) - 1) < int(mantissabits))\n        current = hash(x, i +  uint(1));\n    \n    if (pw2 < uint(1 << (exponentbits - uint(1))) - uint(2))\n        m = (uint(1 << (exponentbits - uint(1))) - uint(2) - pw2) << mantissabits;\n    else // subnormal\n        m = uint(0);\n        \n    m |= ieeeMantissa & current;\n    \n    return uintBitsToFloat( m );\n}\n\nuvec5 floatBitsToUint2(vec5 v)\n{\n    uvec5 u;\n\n    u.v[0] = floatBitsToUint(v.v[0]);\n    u.v[1] = floatBitsToUint(v.v[1]);\n    u.v[2] = floatBitsToUint(v.v[2]);\n    u.v[3] = floatBitsToUint(v.v[3]);\n    u.v[4] = floatBitsToUint(v.v[4]);\n\n    return u;\n}\n\nfloat random( float x ) { return floatrandhq(touvec6(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec5  v ) { return floatrandhq(touvec6(floatBitsToUint2(v))); }\nfloat random( vec6  v ) \n{ \n    return floatrandhq(\n            uvec6(uint[6](\n                floatBitsToUint(v.v[0]),\n                floatBitsToUint(v.v[1]),\n                floatBitsToUint(v.v[2]),\n                floatBitsToUint(v.v[3]),\n                floatBitsToUint(v.v[4]),\n                floatBitsToUint(v.v[5])\n                ))\n        );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 121]]}
{"id": "sdVyWc", "name": "Fork of Blue Noise", "author": "AshenFlowersFalling", "description": "Fork of original shader, now with comments!\n\nGenerates tileable blue noise / poisson disc of floor-pow2-window-res size.\n\nRight 20% of window shows which pixels have been swapped in the current frame.\n\nClick with left mouse button to reset.", "tags": ["noise", "hash", "bluenoise"], "likes": 6, "viewed": 460, "published": 3, "date": "1655768469", "time_retrieved": "2024-07-30T16:43:52.047909", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 sz = ivec2(pow(vec2(2.0), floor(log2(iResolution.xy))));\n    ivec2 px = ivec2(fragCoord) % sz;\n    float v = texelFetch(iChannel0, px, 0).r;    \n    \n    fragColor = vec4(v, v, v, 1.0);\n    \n    if (gl_FragCoord.x/iResolution.x > 0.8)\n        fragColor = texelFetch(iChannel0, px, 0).gggg;\n#if SHOW_DITHERING\n    ivec2 tpos = ivec2(fragCoord) % textureSize(iChannel1, 0);\n    if (gl_FragCoord.x/iResolution.x > 0.5)\n    {\n        if (v < texelFetch(iChannel1, tpos, 0).r)\n            fragColor = vec4(1.0);\n        else\n            fragColor = vec4(0.0);\n    }\n    else\n    {\n        if (random(vec2(px)) < texelFetch(iChannel1, tpos, 0).r)\n            fragColor = vec4(1.0);\n        else\n            fragColor = vec4(0.0);\n    }\n#endif\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SHOW_DITHERING 0 // show white/blue noise dithered image\n#define POISSON_DISC 0   // generate approximate poisson disc texture instead of blue noise\n#define USE_MAX 1        // use \"max\" as the comparison, otherwise use \"min\"\n#define QUANTIZE 0       // quantise initial noise to 8-bits?\n\n#define INIT_FRAMES 1\n\n#define R2 11 // 19 works well for high-quality\n\n#define SIGMA 1.41421356237\n#define M_PI 3.14159265359\n\n\n// high-quality hash, modified version of old version of XXHash32 from https://github.com/Cyan4973/xxHash (BSD license)\n\nstruct vec5\n{\n\tfloat v[5];\n};\nstruct uvec5\n{\n\tuint v[5];\n};\nstruct vec6\n{\n\tfloat v[6];\n};\nstruct uvec6\n{\n\tuint v[6];\n};\n\nuvec6 touvec6(uvec5 x) { uvec6 x6;    x6.v[0] = x.v[0]; x6.v[1] = x.v[1]; x6.v[2] = x.v[2]; x6.v[3] = x.v[3]; x6.v[4] = x.v[4]; x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec4 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = x.w;    x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec3 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec2 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uint  x) { uvec6 x6;    x6.v[0] = x;      x6.v[1] = uint(0);x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\n\n#define PRIME32_1\t2654435761U\n#define PRIME32_2\t2246822519U\n#define PRIME32_3\t3266489917U\n#define PRIME32_4\t668265263U\n#define PRIME32_5\t374761393U\n\nuint rotl32(uint x, int shift)\n{\n\treturn (x << shift) | (x >> (32 - shift));\n}\nvoid XXH32_InitV(inout uint v[4], uint seed)\n{\n    v[0] = seed + PRIME32_1 + PRIME32_2;\n    v[1] = seed + PRIME32_2;\n    v[2] = seed + uint(0);\n    v[3] = seed - PRIME32_1;\n}\nvoid XXH32_Inner(const uint p[4], inout uint v[4])\n{\n    v[0] += p[0] * PRIME32_2;\n    v[0] = rotl32(v[0], 13);\n    v[0] *= PRIME32_1;\n\n    v[1] += p[1] * PRIME32_2;\n    v[1] = rotl32(v[1], 13);\n    v[1] *= PRIME32_1;\n\n    v[2] += p[2] * PRIME32_2;\n    v[2] = rotl32(v[2], 13);\n    v[2] *= PRIME32_1;\n\n    v[3] += p[3] * PRIME32_2;\n    v[3] = rotl32(v[3], 13);\n    v[3] *= PRIME32_1;\n}\n\nuint XXHash32_32(uint input_s[8])\n{\n    uint h32;\n\tuint v[4];\n\n\tXXH32_InitV(v, uint(0));\n\n\tXXH32_Inner(uint[4](input_s[0], input_s[1], input_s[2], input_s[3]), v);\n    XXH32_Inner(uint[4](input_s[4], input_s[5], input_s[6], input_s[7]), v);\n\n    h32 = rotl32(v[0], 1) + rotl32(v[1], 7) + rotl32(v[2], 12) + rotl32(v[3], 18);\n\n    h32 += uint(32);\n\n    h32 ^= h32 >> 15;\n    h32 *= PRIME32_2;\n    h32 ^= h32 >> 13;\n    h32 *= PRIME32_3;\n    h32 ^= h32 >> 16;\n\n    return h32;\n}\n\nuint hash(uvec6 x, uint seed) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(seed));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec4 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec3 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec2 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uint x, uint seed)  { return hash(touvec6(x), seed);}\nuint hash(uvec6 x) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(0));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x) { return hash(touvec6(x));}\nuint hash(uvec4 x) { return hash(touvec6(x));}\nuint hash(uvec3 x) { return hash(touvec6(x));}\nuint hash(uvec2 x) { return hash(touvec6(x));}\nuint hash(uint x)  { return hash(touvec6(x));}\n\n\n\nuint lzcnt(uint x)\n{\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    \n    uint c;\n    \n    x = x - ((x >> 1) & uint(0x55555555));                    \n    x = (x & uint(0x33333333)) + ((x >> 2) & uint(0x33333333));\n    c = ((x + (x >> 4) & uint(0xF0F0F0F)) * uint(0x1010101)) >> 24;\n\n    return uint(32) - c;\n}\n\nfloat floatrandhq(uvec6 x) \n{\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint mantissabits = uint(23);\n    const uint exponentbits = uint(8);\n    const uint hashbits     = uint(32);\n    const uint hashbitslg2  = uint(5);\n    uint current;\n    uint cnt;\n    uint pw2;    \n    // ceil((2^(ebits - 1) - 2) / 2^hashbits)\n    uint maxrec = (uint(1 << (exponentbits - uint(1))) - uint(2) + hashbits - uint(1)) >> hashbitslg2;\n    uint m;\n    uint i;\n    \n    current = hash(x, uint(0));\n    cnt = lzcnt(current);\n    pw2 = cnt;\n\n    for (i = uint(1); (i < maxrec) && (cnt == hashbits); i++)\n    {\n        current = hash(x, i +  uint(1));\n        cnt = lzcnt(current);\n        pw2 += cnt;\n    }\n    \n    // if less than 23 bits left, we need to generate a new hash to fill the mantissa\n    if ((int(hashbits) - int(cnt) - 1) < int(mantissabits))\n        current = hash(x, i +  uint(1));\n    \n    if (pw2 < uint(1 << (exponentbits - uint(1))) - uint(2))\n        m = (uint(1 << (exponentbits - uint(1))) - uint(2) - pw2) << mantissabits;\n    else // subnormal\n        m = uint(0);\n        \n    m |= ieeeMantissa & current;\n    \n\n    return uintBitsToFloat( m );\n}\n\nuvec5 floatBitsToUint2(vec5 v)\n{\n    uvec5 u;\n\n    u.v[0] = floatBitsToUint(v.v[0]);\n    u.v[1] = floatBitsToUint(v.v[1]);\n    u.v[2] = floatBitsToUint(v.v[2]);\n    u.v[3] = floatBitsToUint(v.v[3]);\n    u.v[4] = floatBitsToUint(v.v[4]);\n\n    return u;\n}\n\nfloat random( float x ) { return floatrandhq(touvec6(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec5  v ) { return floatrandhq(touvec6(floatBitsToUint2(v))); }\nfloat random( vec6  v ) \n{ \n    return floatrandhq(\n            uvec6(uint[6](\n                floatBitsToUint(v.v[0]),\n                floatBitsToUint(v.v[1]),\n                floatBitsToUint(v.v[2]),\n                floatBitsToUint(v.v[3]),\n                floatBitsToUint(v.v[4]),\n                floatBitsToUint(v.v[5])\n                ))\n        );\n}\n\n\nfloat gaussian (float x, float sigma) \n{\n    float h0 = x / sigma;\n    float h = h0 * h0 * -0.5;\n    float a = 1.0 / (sigma * sqrt(2.0 * M_PI));\n    return a * exp(h);\n}\n\nfloat distf(float v, float x) {\n    return 1.0 - x;\n}\n\nvec2 quantify_error (sampler2D channel, ivec2 p, ivec2 sz, float val0, float val1) \n{\n    float Rf = float(R2) / 2.0;\n    int R = int(Rf);\n    float has0 = 0.0;\n    float has1 = 0.0;\n    float w = 0.0;\n    \n    for (int sy = -R; sy <= R; ++sy) \n    {\n        for (int sx = -R; sx <= R; ++sx) \n        {\n            float d = length(vec2(sx,sy));\n            \n            if ((d > Rf) || ((sx == 0) && (sy == 0)))\n                continue;\n                \n            ivec2 t = (p + ivec2(sx,sy) + sz) % sz;\n\t\t\tfloat v = texelFetch(channel, t, 0).r;\n\n            float dist0 = abs(v - val0);\n            float dist1 = abs(v - val1);\n\n            float q = gaussian(d, SIGMA);\n\n            w += q;            \n            has0 += distf(val0, dist0) * q;\n            has1 += distf(val1, dist1) * q;\n            \n        }\n    }\n\n    return vec2(has0 / w, has1 / w);\n}\n", "buffer_b_code": "#if USE_MAX\n#define CMPF max\n#else\n#define CMPF min\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float swap = 0.0;\n#if USE_MAX\n    // if using max\n    float chance_limit = 0.64; // only converges if <= ~0.661819 @ 640 x 480 (512 x 256), or ~0.661 @ 1920 x 1080 (1024 x 1024)\n#else    \n    // if using min\n    float chance_limit = 0.24; // only converges if <= ~0.25 @ 640 x 480 (512 x 256)\n#endif    \n    ivec2 p0 = ivec2(fragCoord);\n    \n    if (iFrame < INIT_FRAMES || iMouse.z > 0.0) \n    {\n        // uniform histogram of values, can change to arbitrary histogram\n        float v = random(vec3(p0, float(iFrame)));\n#if QUANTIZE && !POISSON_DISC\n        v = floor(v * 256.0) / 256.0;\n#elif POISSON_DISC\n        v = v < 0.875 ? 0.0 : 1.0;  // only converges for >= ~0.825\n#endif\n        fragColor = vec4(v, vec3(0.0));\n        return;\n    }\n    \n    ivec2 sz = ivec2(pow(vec2(2.0), floor(log2(iResolution.xy)))); // make data power-of-two in dimensions\n    uint hashval = hash(uint(iFrame), uint(0));\n    ivec2 mask = ivec2(uvec2(hashval >> 16, hashval & uint(0xFFFF)) % uvec2(sz));// constant mask for all pixels in the current frame\n\n    ivec2 p1 = (p0 ^ mask) % sz; // coordinates of pixel to potentially swap with, importantly this is a one-to-one mapping between pairs\n\n    float v0 = texelFetch(iChannel0, p0, 0).r; // get data at current pixel\n    float v1 = texelFetch(iChannel0, p1, 0).r; // get data at pixel to potentially swap with\n\n    float chance0 = random(vec3(p0, float(iFrame))); // random number [0, 1) seeded with p0 coords and current frame\n    float chance1 = random(vec3(p1, float(iFrame))); // random number [0, 1) seeded with p1 coords and current frame\n    float chance = CMPF(chance0, chance1);           // any function that's order-independent with respect to \"chance0\" and \"chance1\"\n\n    if (chance > chance_limit) // limit swapping rate to make sure algorithm converges\n    {\n        fragColor = vec4(v0, vec3(0.0));\n        return;\n    }\n\n    vec2 s0_x0 = quantify_error(iChannel0, p0, sz, v0, v1);\n    vec2 s1_x1 = quantify_error(iChannel0, p1, sz, v1, v0);\n\n    float err_s = s0_x0.x + s1_x1.x;\n    float err_x = s0_x0.y + s1_x1.y;\n\n    float p = v0;\n\n    // less error if a swap were to take place: so swap.\n    // note that this code will ALWAYS execute at p1 if it executed at p0, and vice-versa\n    if (err_x < err_s) \n    {\n        p = v1;\n        if (v0 != v1)\n            swap += 1.0;\n    }\n\n    fragColor = vec4(p, swap, 0.0, 1.0);\n}                        \n", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 806]]}
{"id": "ssKyW3", "name": "topdown starfield 2", "author": "FabriceNeyret2", "description": "variant of 2011 GLSL1.2 code ( nVidia G80 :-D )  port https://shadertoy.com/view/7lsyzf\nwith direct gaussian (no table ) and better hash\n\nmouse.y : zoom\nshift-mouse.y: force LOD change", "tags": ["poisson", "stars", "pointprocess"], "likes": 1, "viewed": 52, "published": 3, "date": "1655745112", "time_retrieved": "2024-07-30T16:43:53.014325", "image_code": "// variant \"topdown starfield\" by FabriceNeyret2. https://shadertoy.com/view/7lsyzf\n// with direct gaussian (no table ) and better hash\n\n/****** FroggyPerlin_FS.glsl **************************/\n\nfloat deltac = .5,    // userParam3.a  = x translation\n        cmoy = .5;    // userParam3.z  = y translation\nint N = 3;            // UserParam2.x  = LOD\nvec2 localCoord;      // varying vec4  = normalized pixel coords\nfloat xscale = .05;   // userParam1.x  = zoom\nvec4 C;               // output        = output color\n\n#define SQR(x) ((x)*(x))\n\n// --- User interface was:\n// key:            + -             →  N++ / --\n// mouse: shift-left: scale noise  →  1.x *= rx= 1.+dMouse.x/R.x\n//            middle: zoom         →  camera move ( 0,0,ry)\n//             right: translate    →  camera move (-rx,-ry,0)\n\n\n\n/******************************************************\\\n**                                                    **\n**      Stats.glsl           Fabrice NEYRET 30/06/11  **\n**                                                    **\n\\******************************************************/\n\n// rnd(seed)    Uniform[0,1]\n//                  (low quality and precision)\n// rnd3(xseed,yseed,seed)\n// gauss(u)     Normal(0,1)\n//                  use uniform as seed\n// intgauss(x)  cumulative distr func of Normal(0,1)\n//                  use x = (x-xm)/s for N(xm,s^2)\n\n//#line 15 1\n\n// seq(fsolve(1/2*(1+erf(x/sqrt(2)))=i/255.,x), i = 0..255);\nfloat invgauss[256] = float[](\n  -13.50858432, -2.658748992, -2.416134297, -2.264727419,   -2.152315053, -2.061916502, -1.985770403, -1.919651290,   -1.860993476, -1.808117371, -1.759861028, -1.715385840,   -1.674065908, -1.635421185, -1.599075078, -1.564726471,   -1.532130657, -1.501085946, -1.471424060, -1.443003065,   -1.415702094, -1.389417334, -1.364058929, -1.339548561,   -1.315817530, -1.292805229, -1.270457904, -1.248727645,   -1.227571561, -1.206951090, -1.186831433, -1.167181068,   -1.147971348, -1.129176158, -1.110771617, -1.092735829,   -1.075048664, -1.057691573, -1.040647418, -1.023900333,   -1.007435601, -0.9912395403, -0.9752994069, -0.9596033111,   -0.9441401408, -0.9288994918, -0.9138716087, -0.8990473298,   -0.8844180399, -0.8699756243, -0.8557124305, -0.8416212336,   -0.8276952018, -0.8139278686, -0.8003131056, -0.7868450995,   -0.7735183280, -0.7603275409, -0.7472677410, -0.7343341688,   -0.7215222841, -0.7088277541, -0.6962464387, -0.6837743800,   -0.6714077892, -0.6591430371, -0.6469766453, -0.6349052758,   -0.6229257234, -0.6110349080, -0.5992298682, -0.5875077530,   -0.5758658170, -0.5643014135, -0.5528119909, -0.5413950853,   -0.5300483169, -0.5187693864, -0.5075560692, -0.4964062122,   -0.4853177302, -0.4742886030, -0.4633168707, -0.4524006317,   -0.4415380391, -0.4307272994, -0.4199666679, -0.4092544476,   -0.3985889860, -0.3879686745, -0.3773919440, -0.3668572645,   -0.3563631432, -0.3459081219, -0.3354907758, -0.3251097114,   -0.3147635664, -0.3044510061, -0.2941707233, -0.2839214366,   -0.2737018897, -0.2635108491, -0.2533471031, -0.2432094621,   -0.2330967553, -0.2230078312, -0.2129415555, -0.2028968119,   -0.1928724988, -0.1828675299, -0.1728808328, -0.1629113487,   -0.1529580307, -0.1430198431, -0.1330957617, -0.1231847716,   -0.1132858673, -0.1033980512, -0.09352033436, -0.08365173407,   -0.07379127404, -0.06393798335, -0.05409089672, -0.04424905235,   -0.03441149226, -0.02457726114, -0.01474540668,   -0.004914977406, 0.004914977155, 0.01474540642, 0.02457726089,   0.03441149176, 0.04424905210, 0.05409089646, 0.06393798310,   0.07379127354, 0.08365173382, 0.09352033411, 0.1033980509,   0.1132858670, 0.1231847714, 0.1330957614, 0.1430198428,   0.1529580304, 0.1629113485, 0.1728808325, 0.1828675294,   0.1928724985, 0.2028968116, 0.2129415553, 0.2230078306,   0.2330967551, 0.2432094618, 0.2533471029, 0.2635108488,   0.2737018895, 0.2839214363, 0.2941707228, 0.3044510058,   0.3147635661, 0.3251097112, 0.3354907753, 0.3459081217,   0.3563631430, 0.3668572642, 0.3773919437, 0.3879686742,   0.3985889858, 0.4092544470, 0.4199666676, 0.4307272991,   0.4415380388, 0.4524006311, 0.4633168704, 0.4742886028,   0.4853177300, 0.4964062120, 0.5075560689, 0.5187693861,   0.5300483166, 0.5413950850, 0.5528119906, 0.5643014132,   0.5758658164, 0.5875077527, 0.5992298679, 0.6110349077,   0.6229257228, 0.6349052755, 0.6469766450, 0.6591430368,   0.6714077889, 0.6837743797, 0.6962464383, 0.7088277535,   0.7215222838, 0.7343341684, 0.7472677407, 0.7603275402,   0.7735183276, 0.7868450991, 0.8003131052, 0.8139278682,   0.8276952014, 0.8416212332, 0.8557124301, 0.8699756239,   0.8844180395, 0.8990473294, 0.9138716079, 0.9288994914,   0.9441401404, 0.9596033107, 0.9752994065, 0.9912395399,   1.007435601, 1.023900332, 1.040647417, 1.057691573,   1.075048664, 1.092735828, 1.110771616, 1.129176157,   1.147971347, 1.167181067, 1.186831432, 1.206951090,   1.227571560, 1.248727645, 1.270457904, 1.292805229,   1.315817529, 1.339548560, 1.364058929, 1.389417333,   1.415702093, 1.443003064, 1.471424059, 1.501085945,   1.532130656, 1.564726471, 1.599075077, 1.635421184,   1.674065907, 1.715385839, 1.759861026, 1.808117368,   1.860993475, 1.919651288, 1.985770401, 2.061916499,   2.152315051, 2.264727416, 2.416134292, 2.658748984, 13.50858432\n);\n\n//seq(evalf(1/2*(1+erf(((2*i/255-1)*3.2)/sqrt(2)))), i = 0..255);\nfloat Intgauss[256] = float[](\n0.6871380e-3, 0.7494356e-3, 0.8169004e-3, 0.8899146e-3, 0.9688851e-3, 0.10542440e-2, 0.11464499e-2, 0.12459894e-2, 0.13533781e-2, 0.14691620e-2, 0.15939188e-2, 0.17282592e-2, 0.18728282e-2, 0.20283069e-2, 0.21954132e-2, 0.23749034e-2, 0.25675740e-2, 0.27742627e-2, 0.29958497e-2, 0.32332593e-2, 0.34874612e-2, 0.37594717e-2, 0.40503552e-2, 0.43612252e-2, 0.46932459e-2, 0.50476330e-2, 0.54256549e-2, 0.58286340e-2, 0.62579476e-2, 0.67150286e-2, 0.72013666e-2, 0.77185082e-2, 0.82680583e-2, 0.88516803e-2, 0.94710962e-2, 0.101280874e-1, 0.108244945e-1, 0.115622174e-1, 0.123432152e-1, 0.131695056e-1, 0.140431650e-1, 0.149663273e-1, 0.159411831e-1, 0.169699787e-1, 0.180550152e-1, 0.191986463e-1, 0.204032774e-1, 0.216713632e-1, 0.230054056e-1, 0.244079514e-1, 0.258815900e-1, 0.274289497e-1, 0.290526957e-1, 0.307555258e-1, 0.325401674e-1, 0.344093732e-1, 0.363659176e-1, 0.384125920e-1, 0.405521998e-1, 0.427875528e-1, 0.451214648e-1, 0.475567470e-1, 0.500962022e-1, 0.527426190e-1, 0.554987662e-1, 0.583673862e-1, 0.613511885e-1, 0.644528440e-1, 0.676749772e-1, 0.710201601e-1, 0.744909052e-1, 0.780896580e-1, 0.818187898e-1, 0.856805910e-1, 0.896772632e-1, 0.938109124e-1, 0.980835408e-1, .1024970404, .1070531852, .1117536236, .1165998722, .1215933076, .1267351604, .1320265080, .1374682681, .1430611923, .1488058602, .1547026733, .1607518498, .1669534188, .1733072163, .1798128798, .1864698448, .1932773408, .2002343882, .2073397956, .2145921572, .2219898512, .2295310383, .2372136614, .2450354446, .2529938944, .2610862998, .2693097340, .2776610567, .2861369163, .2947337533, .3034478039, .3122751044, .3212114960, .3302526301, .3393939748, .3486308209, .3579582890, .3673713374, .3768647696, .3864332432, .3960712786, .4057732686, .4155334878, .4253461032, .4352051838, .4451047123, .4550385955, .4650006759, .4749847425, .4849845435, .4949937969, .5050062031, .5150154565, .5250152575, .5349993241, .5449614045, .5548952877, .5647948162, .5746538968, .5844665122, .5942267314, .6039287214, .6135667568, .6231352304, .6326286626, .6420417110, .6513691791, .6606060252, .6697473699, .6787885040, .6877248956, .6965521961, .7052662467, .7138630837, .7223389433, .7306902660, .7389137002, .7470061056, .7549645554, .7627863386, .7704689617, .7780101488, .7854078428, .7926602044, .7997656118, .8067226592, .8135301552, .8201871202, .8266927837, .8330465812, .8392481502, .8452973267, .8511941398, .8569388077, .8625317319, .8679734920, .8732648396, .8784066924, .8834001278, .8882463764, .8929468148, .8975029596, .9019164592, .9061890876, .9103227368, .9143194090, .9181812102, .9219103420, .9255090948, .9289798399, .9323250228, .9355471560, .9386488115, .9416326138, .9445012338, .9472573810, .9499037978, .9524432530, .9548785352, .9572124472, .9594478002, .9615874080, .9636340824, .9655906268, .9674598326, .9692444742, .9709473043, .9725710503, .9741184100, .9755920486, .9769945944, .9783286368, .9795967226, .9808013537, .9819449848, .9830300213, .9840588169, .9850336727, .9859568350, .9868304944, .9876567848, .9884377826, .9891755055, .9898719126, .9905289038, .9911483197, .9917319417, .9922814918, .9927986334, .9932849714, .9937420524, .9941713660, .9945743451, .9949523670, .9953067541, .9956387748, .9959496448, .9962405283, .9965125388, .9967667407, .9970041503, .9972257373, .9974324260, .9976250966, .9978045868, .9979716931, .9981271718, .9982717408, .9984060812, .9985308380, .9986466219, .9987540106, .9988535501, .9989457560, .9990311149, .9991100854, .9991830996, .9992505644, .9993128620\n);\n\n#if 1                                // $Fab\n    #define  gauss(u) sqrt(-2.*log(u.x)) * cos(2.*3.1415927*u.y ) // takes u = rand2_uniform()\n#else\nfloat gauss(float u) { // takes u = rand_uniform()\n    // return 4*(2*u-1);\n    u*=256.;\n    if (u>=255.) return invgauss[255];\n    int iu = int(u);\n    float fu = u-float(iu);\n    return (1.-fu)*invgauss[iu]+fu*invgauss[iu+1];\n}\n#endif\n\nfloat intgauss(float x) { // use (x-xm)/s for N(m,s^2)\n    x = (x/3.2)*128.+128.;\n    if (x<0.) return Intgauss[0];\n    if (x>255.) return Intgauss[255];\n    int ix = int(x);\n    float fx = x-float(ix);\n    return (1.-fx)*Intgauss[ix]+fx*Intgauss[ix+1];\n}\n\nfloat rnd(int i) { // attention: limited precision and quality.\n#define NB_CHIFFRES 1000. //  1000.\n#define POIDS_FAIBLE 1000000. // 1000000.\n    return mod((sin(0.01*float(i)+.1234567)*POIDS_FAIBLE), NB_CHIFFRES)/NB_CHIFFRES;\n}\n\n#define rnd3x2(x,y,z) ihash(uvec3(ivec3(x,y,z)+10000000)).xy  // $Fab\n\nfloat rnd3(int x,int y, int c) { // decorelated seeds (window=512)\n    return rnd(x+(y<<9)+(c<<18));\n}\n\n\n\nvec3 ihash( uvec3 x ) //  $Fab https://www.shadertoy.com/view/XlXcW4\n{\n    uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\n\n/***************************************************\\\n**\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   **\n**\tstars.glsl\t\t\t\t  \tFabrice NEYRET  30/06/11 **\n**\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   **\n\\***************************************************/\n//#line 6 2\n\n// tirage procedural de bruit poissonnien scalable.\n// Principe: partant d'une densité d, on subdivise un quadtree\n// en y tirant la densité des tiles selon la loi de Poisson, recursivement.\n// Quand on atteint les petits nombres, on discretise d,\n// et on tire les positions d'étoiles dans le tile.\n// On affiche soit les etoiles, soit les densités par tile.\n\n\n//--- contribution d'une etoile à un tile\n\n#define LUM 5.76*10. // 1.E-2 // 1.E0 // 1.E8\n#define RAD .125 // rayon de l'etoile\n\n// etoile = gauss(xP,yP,s) pixel grid = x,y,x+l,y+l\nfloat star(float xP, float yP, float s, float x, float y, float l) {\n    float invs = 1./s, r=l*.5;\n    float d = sqrt(SQR(x+r-xP) + SQR(y+r-yP));\n    // à 3.2*s, moins de .5% de luminosité\n    if (d >  3.2*s+r) return 0.; // etoile hors pixel\n    if (d < -3.2*s+r) return 1.; // etoile dans pixel\n    else   // etoile en partie dans le pixel\n        return  (intgauss((x+l-xP)*invs)-intgauss((x-xP)*invs))\n               *(intgauss((y+l-yP)*invs)-intgauss((y-yP)*invs));\n}\n\n//--- processus de Poisson recursif\n\nvoid draw_points() {\n // NB: we need ints as index in the quadtree -> virtual grid\n#define Z 9       // resolution grille virtuelle\n#define L (1<<Z)\t//  > à largeur des etoiles (sinon clip!)\n#define root (-4) // extrapole la racine de la grille\n    float n = 0.05; // densité: 1 case sur 20 dans L*L\n  n *= float(1<<(2*(Z-root))); // conv en nombre sur grille\n\n    // coords ecrans -> coord grille\n    float scale = 20.*xscale;\n    float fx = scale*(localCoord.x-.5) +deltac;\n    float fy = scale*(localCoord.y-.5) +cmoy;\n    //  n *= 1./(.01+fx*fx+fy*fy);              // distrib pseudo-gaussienne\n    //  n *= 20*exp(-.5*(fx*fx+fy*fy)/SQR(.5)); // distrib gaussienne\n    fx *=float(L); fy *=float(L);\n    int x = int(floor(fx)), y = int(floor(fy));\n    //if (x*y==0) { gl_FragData[0].g=255; return; }\n\n    //int depth = 7;  // prof d'exploration\n  int depth = int(8.-log2(scale))-N+3; if (depth>Z) depth=Z;\n\n    // tirage de Poisson en quadtree: quel n dans tile courant ?\n    int xx,yy; // coord du tile\n    int k=1<<(Z-root), M=-k; // taille du tile et mask de coords\n#define COORDS 1\n#if COORDS // seed tile = coords du tile (par maskage de x,y)\n             // Pb: les fils gauche ont le meme seed que le pere !\n             // patch: rand(layer i)\n    xx = x&M; yy=y&M; // coord du tile\n#else      // seed tile = coords du tile (par division)\n             // Pb: seed = 0 pour tout tile > MSB\n    xx = x>>(Z-root); yy = y>>(Z-root); \n#endif\n\n#if 1\n    float d = 1.;\n#else\n    float d = pow(.5,1./float(depth-root)); // rectif pour assurer Poisson\n#endif\n    for(int i=root; i<depth; i++) {\n        //if (n>=10)\n    // n-poisson ~ N(l,l) + correction de continuité\n        // http://en.wikipedia.org/wiki/Poisson_distribution\n        // tile pere = densité 4n. on tire fluctuations Poissonniennes\n        n += sqrt(n*d)*gauss(rnd3x2(xx,yy,i*COORDS))-0.5; // approx si n<=5\n        // <><><> added i instead of 0. thus, correlated with next rands\n        //else\n        // // n = n*(2*rnd3(xx,yy,1));\n        // n = n*(1+1*(2*rnd3(xx,yy,1)-1));\n\n        if (n<4.) { // petit nombre\n         // if (rnd3(xx,yy,1)<(n-int(n))) n++; n=int(n); // frac -> proba\n            if (rnd3(xx,yy,1)<fract(n)) n++; n=floor(n); // frac -> proba\n            if (n<1.) return; // zone de ciel noir\n            if (n<4.) break; // draw stars\n        }\n\n        // on subdivise\n        n = n*0.25; // densité moyenne des fils\n        k>>=1; M |= k; // on passe aux tiles fils\n#if COORDS\n        xx = x&M; yy=y&M; // coord du tile\n#else\n        xx = x>>(Z-(i+1)); yy = y>>(Z-(i+1)); \n#endif\n\n        if (n<4.) {  // petit nombre\n            float n_=n;\n         // if (rnd3(xx,yy,0)<(n-int(n))) n++; n=int(n); // frac -> proba\n            if (rnd3(xx,yy,0)<fract(n)) n++; n=floor(n); // frac -> proba\n            if (n<1.) return; // zone de ciel noir\n#if 1\n            if (n_>=1.) { // on permute 1 etoile entre 2 fils (sinon 4 clones)\n#if COORDS\n                int u = int(rnd3(xx&~k,yy&~k,2)*16.); // 4 random bits\n                if ((bool(xx&k)==bool(u&1))&&(bool(yy&k)==bool(u&2))) n++;\n                if ((bool(xx&k)==bool(u&4))&&(bool(yy&k)==bool(u&8))) n--;\n#else\n                int u = int(rnd3(xx>>1,yy>>1,2)*16.); // 4 random bits\n                if ((bool(xx&1)==bool(u&1))&&(bool(yy&1)==bool(u&2))) n++;\n                if ((bool(xx&1)==bool(u&4))&&(bool(yy&1)==bool(u&8))) n--;\n#endif\n            }\n#endif\n            if (n<4.) break;\n        }\n    }\n\n#define SHOWTILE 2 // 1: tiles colorés 0: points+tiles 2: points ou tiles\n#define SHOWDENS 1\n\n#if 1\n    { // if (depth==Z) {\n    // petits n: on tire les coordonnées des etoiles\n    // puis on les dessine (integrale contrib sur pixel)\n    if (n<4.) {\n#define band 2.5 // 3 // bandguard au bords du tile\n        float x0=float(xx)+band*RAD, y0=float(yy)+band*RAD, l=float(k)-2.*band*RAD;\n        float x1 = x0+l*rnd3(xx,yy,1),  // au hasard dans le tile\n                y1 = y0+l*rnd3(xx,yy,2);\n        float v1, v2 = 0., v3 = 0. , x2,y2,x3,y3;\n        if (n>1.5) { // 2 etoiles\n            x2 = x0+l*rnd3(xx,yy,3), // au hasard dans le tile\n            y2 = y0+l*rnd3(xx,yy,4);\n            if (n>2.5) { // 3 etoiles\n                x3 = x0+l*rnd3(xx,yy,5), // au hasard dans le tile\n                y3 = y0+l*rnd3(xx,yy,6);\n            }\n        }\n\n        if ((SHOWTILE < 2)||(depth==Z)) { // on voit les points\n            float I = LUM*SQR(RAD)/SQR(scale); // intensité des étoiles\n            v1            = I*star(x1,y1,RAD, fx,fy,scale);\n            if (n>1.5) v2 = I*star(x2,y2,RAD, fx,fy,scale);\n            if (n>2.5) v3 = I*star(x3,y3,RAD, fx,fy,scale);\n        }\n\n#if\t SHOWTILE == 0      // points blancs\n        C.rgb = v1+v2+v3; \n        return; \n#elif SHOWTILE == 1     // points + tiles en couleur\n        // 1ere en blanc, 2eme en rouge, 3eme en bleu\n        C.r = v1+v2 + .05*int(n>1.5);\n        C.g = v1    + .05*int(n<1.5);\n        C.b = v1+v3 + .05*int(n>2.5);\n        return;\n#elif SHOWTILE == 2\n        if (depth==Z) {\n            C.rgb = vec3(v1+v2+v3);\n            return;\n        }\n        else {\n            M = -(1<<(Z-depth));\n            xx = x&M; yy=y&M; // coord du tile le plus fin (=LOD)\n            float v = 0.;     // on recalcule n dans ce tile\n            if (         ((int(floor(x1))&M)==xx)&&((int(floor(y1))&M)==yy)) v++;\n            if ((n>1.5)&&((int(floor(x2))&M)==xx)&&((int(floor(y2))&M)==yy)) v++;\n            if ((n>2.5)&&((int(floor(x3))&M)==xx)&&((int(floor(y3))&M)==yy)) v++;\n            float I = LUM*SQR(RAD);  // intensité des étoiles\n            C.rgb = vec3(v/float(M*M)*I);// gl_FragData[0].r=M/4.;\n            return;\n        }\n#endif\n\n    }\n    }\n#endif\n\n\n    // affichage là où on ne peut individualiser les etoiles\n#if SHOWDENS==1\n    // tracé des densités par tiles\n    float I = LUM*SQR(RAD); // /SQR(scale); // intensité des étoiles\n    C.rgb =  vec3(n/float(k*k)*I);\n#elif SHOWDENS==2\n    n = n/float(k*k)*20; // densité\n    // < moyenne: bleu\n    // > 16*moy: jaune\n    // > 80*moy: rouge\n    // au dela: vert\n    if (n<=1.)      C.b  = n;\n    else if (n<16.) C.rg = n/16.;\n    else if (n<64.) C.r  = n/64.;\n    else            C.g   = n/256.;\n#else\n    //   1..3   : draw\n    //   4..16  : jaune n/16\n    //  17..64  : blanc n/64\n    //  65..256 : bleu  n/256\n    // 257..    : vert  n/4096\n    if (n>256.)     C.g   = int(n)>>12; // n/4064\n    else if (n>64.) C.b   = int(n)>>8;  // n/256\n    else if (n>16.) C.rgb = int(n)>>6;  // n/64\n    else C.rg = int(n)>>4; // n/16\n#endif\n\n    return;\n}\n\n#undef Z\n#undef L\n\n// --- essai\n\nvoid draw_points0() {\n    float scale = 20.*xscale;\n    int Z=8; // / log2(scale)\n    int L=512;\n    float fx = (localCoord.x-.5)*scale + deltac;\n    float fy = (localCoord.y-.5)*scale + cmoy;\n    int x = int(floor(float(L)*fx));\n    int y = int(floor(float(L)*fy));\n    int xx=x, yy=y;\n    float p=1.; int r=1<<Z;\n    for(int i=0; i<Z; i++) {\n        //xx = (x/r); //xx*=r; \n        //yy = (y/r); //yy*=r; \n        p = rnd3(xx,yy,i)*pow(p,.25);\n        if (p < exp(-0.05*float(r*r))) return;\n        r /= 2;\n    }\n    C = vec4(1);\n}\n\n/* ============================================================== */\n\n#define shift   ( texelFetch(iChannel3,ivec2(16,0),0).x  > 0.)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    localCoord = U/R.y;\n    if (iMouse.z>0.) { \n        if (shift) N = int(6.*iMouse.y/R.y);\n        else xscale *= 5.*iMouse.y/R.y;\n    }\n    draw_points();\n    O = C;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKyW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9268, 9268, 9293, 9322, 9523], [9525, 9525, 9543, 9588, 9753], [9826, 9826, 9858, 9892, 9928], [9932, 9932, 10002, 10002, 10172], [10902, 10954, 11022, 11022, 11429], [18039, 18039, 18060, 18060, 18572], [18708, 18708, 18746, 18746, 18946]]}
{"id": "fsycDc", "name": "curvature of an isovalue 2", "author": "FabriceNeyret2", "description": "Trying to compute the curvature along an isovalue.\ninspiration: https://computergraphics.stackexchange.com/questions/5892/how-to-calculate-curvature-of-isoline-of-image\n\nwhat is this glitch at extrema ?", "tags": ["2d", "curve", "curvature", "short", "isovalue"], "likes": 13, "viewed": 354, "published": 3, "date": "1655706675", "time_retrieved": "2024-07-30T16:43:53.767312", "image_code": "// alternative from https://shadertoy.com/view/fsKcDV\n// inspired by https://computergraphics.stackexchange.com/questions/5892/how-to-calculate-curvature-of-isoline-of-image\n// To answer Andrei Zelenco on the Fbk group: https://www.facebook.com/groups/shadertoy/posts/1111326822781676/\n\n#define R iResolution.xy\n//#define normalize(v) ( length(v) > 1e-5 ? normalize(v) : vec2(0) )\n\nfloat T( vec2 U ) { // === signed function to plot.\n // float v = texelFetch( iChannel0, ivec2(U), 0 ).r;\n // float v = texture( iChannel0, U/R+.01*iTime).r;                 // texture\n // float v = length( 2.*U - R ) / R.y;                             // circle\n    U = 3.*( U+U - R ) / R.y; float v = length(sin(U)+cos(U+U-iTime))/3.; // complex math shape\n    return ( v-.4 ) / fwidth(v);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 D = vec2(2,0);\n   \n    O-=O;\n    float v = T(u);\n    vec2 G = normalize(vec2(- dFdy(v), dFdx(v)));           // isovalue tangent direction\n    float l = T(u-G), r = T(u+G);                           // check neighbors in tangent direction\n // O = vec4( 1.-abs(v));   return;         // isovalues test\n // O = vec4(.5+.5*cos(v)); return;         // isovalues test\n    \n  //l = ( v - (l+r)/2. ) * R.y/4.; // * R.y*R.y/36.;\n    l = (l+r)/2. - v; l = 2.*l / (1.-l*l) *R.y/10. ;\n    \n    O = vec4( l * vec2(1,-1), .3, 1 )                      // draw curvature R/G = sign\n        * clamp(2.-abs(v),0.,1.);                          // draw contour\n}\n\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsycDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[382, 382, 401, 644, 775], [777, 777, 815, 815, 1468]]}
{"id": "fdyyWc", "name": "tree ladder", "author": "jorge2017a2", "description": "tree ladder", "tags": ["treeladder"], "likes": 8, "viewed": 264, "published": 3, "date": "1655692063", "time_retrieved": "2024-07-30T16:43:54.575152", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n//----tree ladder---19-jun-2022\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n//The displacement example below is using sin(20*p.x)*sin(20*p.y)*sin(20*p.z)\n//as displacement pattern, but you can of course use anything you might imagine.\n//iq https://iquilezles.org/articles/distfunctions\nfloat displacement(vec3 p)\n{\n  float val=0.92;  \n  //return sin(val*p.x)*sin(val*p.y)*sin(val*p.z);\n  return sin(val*p.x)*sin(val*p.y)*sin(val*p.z);\n}\n\nfloat opDisplace( float dist, in vec3 p )\n{   float d1 =dist; //primitive(p);\n    float d2 = displacement(p);\n    return d1+d2;\n}\n\nfloat arbol(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    float sds1=sdSphere(p-vec3(0.0,5.0,0.0) , 4.5 );\n    sds1= opDisplace(sds1, p -vec3(0.0,5.0,0.0) );\n    return sds1;\n}    \n\nvec2 escaleraar(vec3 p) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    float d1,d2,d3;\n    \n    for(float i=0.0;i<4.0;i++)\n    {   d1= sdBox( p-vec3(0.0, i*10.0,i*10.0), vec3(25.0,5.0,5.0) );\n        if(mod(i,2.0)==0.0)\n         {  d2= sdCylinderXZ(p-vec3(0.0, (i+1.0)*10.0,i*10.0), vec2(1.0,6.0) );\n            d3=arbol(p-vec3(0.0, (i+1.0)*10.0+2.0,i*10.0));\n         }\n        else\n        {   d2= sdCylinderXZ(p-vec3(-10.0, (i+1.0)*10.0,i*10.0), vec2(1.0,6.0) );\n            d3=arbol(p-vec3(-10.0, (i+1.0)*10.0+2.0,i*10.0));\n        }\n        res=opU2(res, vec2(d1,100.0));\n        res=opU2(res, vec2(d2,3.0));\n        res=opU2(res, vec2(d3,30.0));\n    }\n    return res;\n}\n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tp.y=p.y-5.0;\n    \n    vec2 es1= escaleraar(p);\n    res =opU2(res, es1);\n    \n    float d1= sdSphere(p-vec3(0.0,45.0,60.0), 30.0 );\n    res =opU2(res,vec2(d1,102.0));\n        \n    float d2= sdSphere(p-vec3(10.0,75.0,120.0), 40.0 );\n    res =opU2(res,vec2(d2,101.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 ) { col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor)*vec3(0.0,0.5,1.0)*2.0; }\n\tif (i==102 ) { return tex3D(iChannel0, p/32., nor)*vec3(1.0,0.5,1.0)*2.0; ; }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    //float d = pow(rd.z+0.3,2.)*pow(rd.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n\treturn sky;\n    //return sky*d;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n    \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;    \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,100.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,14.0,-30.0);\n   ro.z+=t;\n   ro.y+=t;\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[495, 495, 531, 531, 552], [553, 553, 585, 585, 669], [671, 671, 710, 710, 805], [808, 808, 844, 844, 889], [891, 1101, 1129, 1129, 1251], [1253, 1253, 1296, 1296, 1382], [1384, 1384, 1405, 1405, 1570], [1576, 1576, 1602, 1602, 2253], [2256, 2256, 2281, 2281, 2608], [2610, 2610, 2634, 2634, 2796], [2798, 2798, 2846, 2846, 3125], [3128, 3128, 3172, 3172, 3493], [3495, 3495, 3532, 3532, 3789], [3792, 3792, 3815, 3815, 3960], [3962, 3962, 4052, 4052, 5011], [5013, 5013, 5062, 5062, 5356], [5358, 5358, 5390, 5390, 5682], [5685, 5685, 5755, 5755, 5933], [5935, 5935, 5962, 5962, 6051], [6053, 6053, 6111, 6111, 6159], [6161, 6161, 6184, 6184, 6296], [6298, 6298, 6329, 6329, 6953], [6955, 6955, 7012, 7012, 7465]]}
{"id": "wdtfzN", "name": "Aerophones in Flatland", "author": "pyBlob", "description": "https://www.microsoft.com/en-us/research/wp-content/uploads/2016/10/Aerophones.pdf\n\nMouse + Keyboard: See comment in Image", "tags": ["sound", "simulation", "aerophone"], "likes": 11, "viewed": 285, "published": 3, "date": "1655685256", "time_retrieved": "2024-07-30T16:43:55.334122", "image_code": "/*\nGLSL implementation of:\n  https://www.microsoft.com/en-us/research/wp-content/uploads/2016/10/Aerophones.pdf\n\nKeyboard:\n  Toggle controls, current state is visible at the left side.\n  0 = inflow (mouse)\n  1 = wall (mouse)\n  2 = erase (mouse)\n  3 = draw ellipse\n  4 = draw trumpet\n  5 = trumpet path A\n  6 = trumpet path B\n\nBuffer D: interaction\nCommon: simulation + physical constants\n*/\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    vec4 M = texelFetch(iChannel0, ivec2(O), 0);\n    if (false)\n    {\n        C = M;\n        //C.xy = C.yx;\n        C.xy *= 1. * deltat / deltas;\n        C.xy += .5;\n        C.w = .5 + C.w / 2e5;\n        //C.xyz = C.xyw;\n        C.xyz = mix(C.xyw, vec3(1,0,1), C.z);\n    }\n    else\n    {\n        float f = M.a;\n        f /= 2e4;\n        //f = sign(f) * sqrt(abs(f / 5e4));\n        //f = sign(f) * log(max(0., abs(f / 1e2))) / log(2e4 / 1e2);\n        C = vec4(1,.2,0,0) * max(0., f) + vec4(0,.05,1,0) * max(0., -f);\n        C = mix(C, vec4(1,0,1,0), M.z);\n    }\n    \n    if (O.x < 10.)\n    {\n        int key = 0x30 + int(O.y/iResolution.y*10.);\n        float v = texelFetch(iChannel2, ivec2(key, 2), 0).r;\n    \tC = mix(\n            vec4(.2),\n            vec4(1,0,0,0),\n            key == 0x30 || key == 4 ? 1.-v : v\n        );\n    }\n\n    if (false)\n    {\n        ivec2 I = ivec2(O);\n        vec4 U = 1. - vec4(I, iResolution.xy - 1. - vec2(I)) / 6.;\n        float border = max(0., max(max(U.x, U.y), max(U.z, U.w)));\n        C = vec4(border);\n    }\n    \n    C = sqrt(C);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    C = update(iChannel0, iResolution, ivec2(O));\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// offset to reference temperature [K]\nconst float deltaT = 0.;\n\n// density [kg / m³]\nconst float rho    = 1.1760    * (1. - 0.00335 * deltaT);\n\n// speed of sound at reference pressure [m / s]\nconst float c      = 3.4723e2  * (1. + 0.00166 * deltaT);\n\nconst float gamma  = 1.4017    * (1. - 0.00002 * deltaT);\n\nconst float mu     = 1.8460e-5 * (1. + 0.0025  * deltaT);\n\nconst float P      = 0.7073    * (1. - 0.0004  * deltaT);\n\n// time-step [s]\n//const float deltat = 7.81e-6;\n//const float deltat = 7.70e-6;\n//const float deltat = 7.81e-7;\nconst float deltat = 7.81e-6 / 4.;\n\n// grid resolution [m]\nconst float deltas = 3.83e-3;\n\n// air pressure at equilibrium [Pa]\nconst float P0     = 1.01325e5;\n\nconst float betac  = 1.2;\n\nfloat next_p(vec4 L, vec4 M, vec4 D, float sigmaprime_M)\n{\n    // local speed of sound\n    float cn = c;\n    if (true)\n        cn *= clamp(1. + betac * M.a / P0, 0.9, 1.1);\n    \n    vec2 dvdxy = (M.xy - vec2(L.x, D.y)) / deltas;\n    float divergencev = dvdxy.x + dvdxy.y;\n\n    float next_p_M = (M.a - rho * cn * cn * deltat * divergencev) / (1. + sigmaprime_M * deltat);\n    return next_p_M;\n}\n\nvec4 fetch(sampler2D iChannel, ivec2 RI, ivec2 I, ivec2 dI)\n{\n    I = min(RI - 1, max(ivec2(0, 0), I + dI));\n    return texelFetch(iChannel, I, 0);\n}\n\nvoid boundary(out float sigmaprime, out float beta, ivec2 RI, ivec2 I, float wall)\n{\n    vec4 U = 1. - vec4(I, RI - 1 - I) / 6.;\n    float border = max(0., max(max(U.x, U.y), max(U.z, U.w)));\n\n    beta = 1. - wall;\n    float sigma = .5 / deltat * border;\n    sigmaprime = 1. - beta + sigma;\n}\n\nvec4 update(sampler2D iChannel, vec3 iResolution, ivec2 O)\n{\n    ivec2 I = ivec2(O);\n    ivec2 RI = ivec2(iResolution.xy);\n\n    /*\n        A T -\n        L M R\n        - D B\n\n\t\tx: vx M -> R\n\t\ty: vy M -> T\n\t\tb:  b @ M\n\t\ta:  p @ M\n    */\n    vec4 A = fetch(iChannel, RI, I, ivec2(-1, +1));\n    vec4 T = fetch(iChannel, RI, I, ivec2( 0, +1));\n    vec4 L = fetch(iChannel, RI, I, ivec2(-1,  0));\n    vec4 M = fetch(iChannel, RI, I, ivec2( 0,  0));\n    vec4 R = fetch(iChannel, RI, I, ivec2(+1,  0));\n    vec4 D = fetch(iChannel, RI, I, ivec2( 0, -1));\n    vec4 B = fetch(iChannel, RI, I, ivec2(+1, -1));\n    \n    float sigmaprime_T, sigmaprime_M, sigmaprime_R;\n    float beta_T, beta_M, beta_R;\n    boundary(sigmaprime_T, beta_T, RI, I + ivec2( 0, +1), T.b);\n    boundary(sigmaprime_M, beta_M, RI, I + ivec2( 0,  0), M.b);\n    boundary(sigmaprime_R, beta_R, RI, I + ivec2(+1,  0), D.b);\n\n    float next_p_T = next_p(A, T, M, sigmaprime_T);\n    float next_p_M = next_p(L, M, D, sigmaprime_M);\n    float next_p_R = next_p(M, R, B, sigmaprime_R);\n    \n    vec2 betav_M = min(vec2(beta_M), vec2(beta_R, beta_T));\n    vec2 next_vb = vec2(0);\n\n    vec2 next_gradient_p = (vec2(next_p_R, next_p_T) - next_p_M) / deltas;\n    vec2 next_v\n        = ( betav_M * M.xy\n          - betav_M * betav_M * deltat * next_gradient_p / rho\n          + sigmaprime_M * deltat * next_vb\n          )\n        / ( beta_M\n            + sigmaprime_M * deltat\n          )\n        ;\n\n    return vec4(next_v, M.b, next_p_M);\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b, float i, float j)\n{\n    vec2 v = b - a;\n    vec2 l = p - a;\n    float h = dot(l, v) / dot(v, v);\n    return length(l - v * clamp(h, i, j));\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n    return sdLine(p, a, b, 0., 1.);\n}\n", "buffer_b_code": "\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    C = update(iChannel0, iResolution, ivec2(O));\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    C = update(iChannel0, iResolution, ivec2(O));\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    C = update(iChannel0, iResolution, ivec2(O));\n\n    bool inflow = texelFetch(iChannel2, ivec2(0x30, 2), 0).r == 0.;\n    bool wall   = texelFetch(iChannel2, ivec2(0x31, 2), 0).r != 0.;\n    bool erase  = texelFetch(iChannel2, ivec2(0x32, 2), 0).r != 0.;\n    bool pipe   = texelFetch(iChannel2, ivec2(0x33, 2), 0).r == 0.;\n    bool ellipse= texelFetch(iChannel2, ivec2(0x34, 2), 0).r != 0.;\n    bool pathA  = texelFetch(iChannel2, ivec2(0x35, 2), 0).r != 0.;\n    bool pathB  = texelFetch(iChannel2, ivec2(0x36, 2), 0).r != 0.;\n    bool mouse  = iMouse.z >= 0.;\n    bool init = iFrame < 20 || (texelFetch(iChannel2, ivec2(0x33, 1), 0).r != 0.) || (texelFetch(iChannel2, ivec2(0x34, 1), 0).r != 0.);\n    float rmouse = length(iMouse.xy - O);\n    \n    //if (false)\n    if (ellipse)\n    {\n        //C = vec4(0.);\n        //C.x += 1e3 * exp(-4. * pow((O.x - iResolution.x / 2.) / 50., 2.));\n        //C.y += 1e3 * exp(-4. * pow((O.y - iResolution.y / 2.) / 50., 2.));\n        //C.x += 1e3* exp(-4. * pow((length(O - iResolution.xy / 2.)) / 50., 2.));\n        \n        vec2 o = (O - iResolution.xy / 2.) / iResolution.x;\n        vec2 a = o + vec2(.1, 0);\n        vec2 b = o - vec2(.1, 0);\n        float r = length(a) + length(b);\n        C.b = float(r > .4);\n        if (init)\n            C.a = exp(-pow(length(a) / .01, 2.)) * 1e5;\n    }\n    if (pipe)\n    {\n        //C = vec4(0);\n        // Position [mm]\n        vec2 o = (O - floor(iResolution.xy / 2.) + .5) * deltas / 1e-3;\n        float r = 1e3;\n        if (pathA)\n        {\n            r = min(r, sdLine(o, vec2(-400, 30), vec2(-30, 30)) - 3.);\n            r = min(r, sdLine(o, vec2(30, 30), vec2(400, 30)) - 3.);\n        }\n        else\n        {\n            r = min(r, sdLine(o, vec2(-400, 30), vec2(400, 30)) - 3.);\n        }\n        if (pathB)\n        {\n            r = min(r, sdLine(o, vec2(-200, -150), vec2(-200, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(-140, -90), vec2(-140, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(200, -150), vec2(200, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(140, -90), vec2(140, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(-200, -150), vec2(200, -150)) - 3.);\n            r = min(r, sdLine(o, vec2(-140, -90), vec2(140, -90)) - 3.);\n            r = min(r, sdLine(o, vec2(-400, -30), vec2(400, -30)) - 3.);\n        }\n        else\n        {\n            r = min(r, sdLine(o, vec2(-200, -150), vec2(-200, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(-140, -90), vec2(-140, 30)) - 3.);\n            r = min(r, sdLine(o, vec2(200, -150), vec2(200, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(140, -90), vec2(140, 30)) - 3.);\n            r = min(r, sdLine(o, vec2(-200, -150), vec2(200, -150)) - 3.);\n            r = min(r, sdLine(o, vec2(-140, -90), vec2(140, -90)) - 3.);\n            r = min(r, sdLine(o, vec2(-400, -30), vec2(-200, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(-140, -30), vec2(140, -30)) - 3.);\n            r = min(r, sdLine(o, vec2(200, -30), vec2(400, -30)) - 3.);\n        }\n        r = min(r, sdLine(o, vec2(-400, 30), vec2(-400, -30)) - 3.);\n        C.b = float(r < 0.);\n        if (init)\n            C.a = length((o - vec2(-370., 0))) < 30. ? 1e5 : 0.;\n    }\n\n    if (mouse)\n    {\n        if (inflow)\n        {\n            float r = 1. - rmouse / 10.;\n            if (r > 0.)\n            {\n                r = 3. * r * r - 2. * r * r * r;\n                C.a += r * 1e5 * (1. - C.b);\n\n            }\n        }\n        if (wall)\n        {\n            if (rmouse < 3.)\n            {\n                C.b = 1. - float(erase);\n                C.a *= (1. - C.b);\n            }\n        }\n    }\n}\n", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[392, 392, 431, 431, 1503]]}
{"id": "NdyyW3", "name": "\"Rasterbars\" in 2022", "author": "mrange", "description": "License CC0: \"Rasterbars\" in 2022\nWas tinkering with recreating the classic raster bar effect from 1980/1990\nHaving a _bit_ more compute power I need to put a twist on it obviously\n\n", "tags": ["rasterbars"], "likes": 36, "viewed": 703, "published": 3, "date": "1655673345", "time_retrieved": "2024-07-30T16:43:56.103067", "image_code": "// License CC0: \"Rasterbars\" in 2022\n//  Was tinkering with recreating the classic raster bar effect from 1980/1990\n//  Having a _bit_ more compute power I need to put a twist on it obviously\n\n\n#define PI          3.141592654\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\n// ---==> Some parameters to play around with <==---\n// Undefine to use old specular lighting\n#define COLORBURN\n#define SKYDOME\nconst int   bars     = 7;\nconst mat2  trans    = ROT(PI/9.0);\nconst float twist    = 1.0;\nconst float dist     = 0.5;\nconst float rounding = 0.125;\n\n#define TAU         (2.0*PI)\n#define RESOLUTION  iResolution\n#define TIME        iTime\n\n#define MAX_RAY_LENGTH  15.0\n#define MAX_RAY_MARCHES 70\n#define TOLERANCE       0.00001\n#define NORM_OFF        0.005\n\nint g_hit = 0;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec3 band_color(float ny) {\n  vec3 hsv = vec3(0.0);\n  float ramp = 1.0/abs(ny);\n  if (abs(ny) < 4.0) {\n    hsv = vec3(0.0, 0.0, 0.);\n  } else if (ny > 0.0) {\n    hsv = vec3(0.88, 2.5*ramp,0.8);\n  } else {\n    hsv = vec3(0.53, 4.0*ramp, 0.8);\n  }\n\n  return hsv2rgb(hsv);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b, vec4 r) {\n  r.xy = (p.x>0.0)?r.xy : r.zw;\n  r.x  = (p.y>0.0)?r.x  : r.y;\n  vec2 q = abs(p)-b+r.x;\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat df_bars(vec3 p) {\n  p.xy *= trans;\n  float tm = TIME;\n  p.y += dist*sin(0.5*p.x+0.5*p.z+tm);\n  vec2 bp = p.zy;\n  \n  float d = 1E6;\n\n//  float bs = 0.25*smoothstep(-0.9, -0.25, -cos(0.1*p.x+tm));\n  const float bs = 0.25;\n  vec2 bsz = vec2(bs);\n  vec4 brd = vec4(bs*rounding);\n\n  for (int i = 0; i < bars; ++i) {\n    float ii = float(i);\n    vec2 pp = bp;\n    float a = -tm+0.5*ii;\n    float b = ii+p.x-2.0*tm;\n    pp.y += sin(a);\n    mat2 rot =  ROT(-PI/4.0*cos(a+twist*b));\n    pp.x -= bsz.x*sqrt(2.0)*ii; \n    pp *= rot;\n    float dd = box(pp, bsz, brd);\n    if (dd < d) {\n      g_hit = i;\n      d = dd;\n    }\n  }\n  \n  return d; \n}\n\nfloat df(vec3 p) {\n  return df_bars(p);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float ti, out int iter) {\n  float t = ti;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nconst vec3 lightPos = vec3(2.0, 3.0, -5.0); \nconst vec3 lightCol = vec3(HSV2RGB(vec3(0.53, 0.5, 1.0)));\nconst vec3 overCol  = vec3(HSV2RGB(vec3(0.88, 0.25, 0.8)));\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3  ld    = normalize(lightPos - ro);\n  float dif   = max(dot(ld, rd), 0.0);\n\n  vec3  col   = vec3(0.0);\n\n  if ((rd.y > abs(rd.x)*1.0) && (rd.y > abs(rd.z*0.25))) { \n    col = 2.0*overCol*rd.y;\n  }\n  float rb = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.9, 4.0),0.0))-0.1;\n\n  col += overCol*pow(clamp(1.0 - rb*0.5, 0.0, 1.0), 6.0);\n  col += lightCol*pow(dif, 8.0);\n  col += 4.0*lightCol*pow(dif, 40.0);\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  vec3 ro = vec3(0.0, 0.0, -5.0);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 3.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n\n  int iter;\n  g_hit = -1;\n  float t = rayMarch(ro, rd, 4.0, iter);\n  int hit = g_hit;\n  \n  vec3 col = vec3(1.0);\n  vec3 bcol = band_color(-4.0*float(hit-(bars-1)/2));\n  bcol *= bcol;\n  if (t < MAX_RAY_LENGTH) {\n    vec3 p = ro + rd*t;\n    vec3 n = normal(p);\n    vec3 r = reflect(rd, n);\n    vec3 ld= normalize(lightPos-p);\n  \n    float dif = max(dot(ld, n), 0.0);\n    col = bcol*mix(0.5, 1.0, dif);\n#ifdef SKYDOME    \n    vec3 rs= skyColor(p, r);\n    float fre = 1.0+dot(rd, n);\n    fre *= fre;\n    float rf  = mix(0.05, 1.0, fre);\n    col += rf*rs;\n#else   \n    float spe = pow(max(dot(ld, r), 0.0), 30.0);\n    col += spe;\n#endif    \n  }\n  \n  return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p  = -1. + 2. * q;\n  p.x     *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col  = effect(p);\n#if defined(COLORBURN)  \n  col -= vec3(0.2, 0.3, 0.2);\n#endif  \n  col += smoothstep(4.0, 0.0, TIME);\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyyW3.jpg", "access": "api", "license": "cc0-1.0", "functions": [[938, 938, 960, 960, 1106], [1401, 1461, 1483, 1483, 1531], [1533, 1619, 1658, 1658, 1783], [1785, 1785, 1812, 1812, 2056], [2058, 2176, 2211, 2211, 2360], [2362, 2362, 2385, 2385, 3000], [3002, 3002, 3020, 3020, 3043], [3045, 3045, 3103, 3103, 3297], [3299, 3299, 3322, 3322, 3530], [3697, 3697, 3730, 3730, 4153], [4155, 4155, 4176, 4176, 5100], [5103, 5103, 5158, 5158, 5469]]}
{"id": "fsKcDV", "name": "curvature of an isovalue", "author": "FabriceNeyret2", "description": "WIP.\nTrying to compute the curvature along an isovalue.\nHere I search the curvature center via the intersection of the lines given by position + gradient of the 2 pixel neighbors closest to the isovalue.\nNot isotropic on the circle ex. Ultra noisy on text", "tags": ["2d", "curve", "curvature", "short", "isovalue"], "likes": 8, "viewed": 282, "published": 3, "date": "1655660089", "time_retrieved": "2024-07-30T16:43:56.948805", "image_code": "// To answer Andrei Zelenco on the Fbk group: https://www.facebook.com/groups/shadertoy/posts/1111326822781676/\n// Probably simpler way here: https://computergraphics.stackexchange.com/questions/5892/how-to-calculate-curvature-of-isoline-of-image\n\n#define R iResolution.xy\n\nvec4 T( vec2 U , int i ) { // === signed function to plot. return (value, id, gradient)\n // float v = texelFetch( iChannel0, ivec2(U), 0 ).r;\n // float v = texture( iChannel0, U/R+.01*iTime).r;                 // texture\n // float v = length( 2.*U - R ) / R.y;                             // circle\n    U = 3.*( U+U - R ) / R.y; float v = length(sin(U)+cos(U+U-iTime))/3.; // complex math shape\n    return vec4( v-.4, i, dFdx(v),dFdy(v) );\n}\n\n#define sort(a,b) abs(a).x > abs(b).x ?  c=b, b = a, a=c  : b  // keep closest to isovalue 0\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 D = vec2(2,0);\n   \n    O-=O;\n    vec4 v = T(u,0), c,\n         l = T(u-D   ,-1), r = T(u+D   ,1),     // check neighbors\n         b = T(u-D.yx,-2), t = T(u+D.yx,2);\n   //O = vec4( 1.-abs(v.x)/fwidth(v.x));   return; // isovalues test\n   //O = vec4(.5+.5*cos(v.x/fwidth(v.x))); return; // isovalues test\n    if ( abs(v.x)/fwidth(v.x) > 4.) return;     // compute curvature only on contour     \n    sort(l,r);                                  // keep 2 closest to isoval\n    sort(l,b);\n    sort(l,t);                                  // l = nearest to isoval 0\n  //sort(l,v); sort(r,v);                       // includes center in the options\n    sort(r,b);\n    sort(r,t);                                  // r = second neared\n    if (abs(v).x > abs(r.x) ) return;           // trace only on the contour\n    \n#define point(l) ( abs(l.y)==1. ? D : D.yx ) *sign(l.y) \\\n                  - 0.*l.x/l.zw                 // adjust point on isoval 0\n    vec2 P1 = point(l),                         // sample point relative location\n         P2 = point(r),\n          d = -(P2-P1) / ( normalize(r.zw) - normalize(l.zw) )  // intersection of the bisector lines\n              * 360./R.y;\n    O = vec4( 60./(d.x+d.y) * vec2(1,-1), v.x+.4, 1 );          // draw curvature R/G = sign\n // O = vec4( 6.*(1./d.x+1./d.y) * vec2(1,-1), v.x+.4, 1 );     // draw curvature R/G = sign\n // O = mix(O, vec4(1), clamp(1.-abs(v.x)/fwidth(v.x),0.,1.) ); // draw contour\n}\n\n\n\n\n\n /* // --- old complex method ( ~ marching cube )\n    float v00 = T(u)     , v10 = T(u+d ),\n          v01 = T(u+d.yx), v11 = T(u+1.), i=0.;\n    if      (v00*v10 < 0.) P1 = vec2( 1.- v10/v00, 0), i++;\n    else if (v01*v11 < 0.) P1 = vec2( 1.- v11/v01, 1), i++;\n    if      (v00*v01 < 0.) P2 = vec2( 0, 1.- v01/v00), i++;\n    else if (v10*v11 < 0.) P2 = vec2( 0, 1.- v11/v10), i++;\n    if (i!=2.) { O=vec4(0,0,1,1); return; }\n */", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 274, 300, 572, 715], [811, 811, 849, 849, 2300]]}
{"id": "sdVcDK", "name": "Wave Thingy 508192", "author": "SnoopethDuckDuck", "description": "very messy, just playing around with stuff", "tags": ["e"], "likes": 6, "viewed": 246, "published": 3, "date": "1655652422", "time_retrieved": "2024-07-30T16:43:57.724731", "image_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define cc(x, p) sign(x) * pow(abs(x), p)\n   \nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}\n    \nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n    \n    \n    float sc = 12.;\n    uv *= sc;\n    uv.x -= iTime;\n    \n    //uv.y += cc(cos(0.02 * uv.x + 0.25 * iTime), 40.);\n    float fx = fract(uv.x) - 0.5;\n    float ix = floor(uv.x) + 0.5;\n    uv.y += 0.2 * sc * thc(1.5, 0.1 * mix(ix, uv.x, 0.5 + 0.5 * cos(12. * uv.y)) + 0.5 * iTime);\n    float m = 2. * mod(ix + 0.5, 2.) - 1.;\n    float h = mix(1., 3., 0.5 + 0.5 * cos(0.2 * ix + iTime));\n    float fy = uv.y + h * m * cc(thc(6., m * pi * 0.25 + 0.1 * ix + iTime), 0.25);\n    \n    float d = length(vec2(fx, fy)) - 0.5;\n\n    float k = 0.75 * sc / iResolution.y;\n    float s = smoothstep(-k, k, -fy);\n    \n    if (uv.y < 0.) {\n        s = 1. - s;\n    }\n\n    s -= smoothstep(-k, k, -d + 0.075);\n    s = max(s, smoothstep(-k, k, -d));\n    k *= 15.;\n    vec3 col1 = pal(0.25 * thc(1., ix) + 1.25 - abs(fy) / sc + 1. * abs(uv.y) / sc, 0.28* vec3(0,1,2)/3.);\n    vec3 col2 = pal(0.25 * (2. * smoothstep(-k, k, uv.y) - 1.) + cos(0.25 * iTime + 0.5 * ouv.x) + ouv.y * 0.3, 0.45 * vec3(0,1,2)/3.);\n    vec3 col = mix(col2, mix(col1, col2, exp(-0.75 * abs(uv.y))), s);\n    col = mix(1.-vec3(0.,0.15,0.15), col, 0.8);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVcDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 145, 145, 245], [247, 247, 286, 286, 387], [393, 393, 426, 426, 481], [484, 484, 541, 541, 1770]]}
{"id": "fdVyDV", "name": "gpu sound 7542 (loud)", "author": "AShaderBeginner", "description": "I discovered you can use sound and the audio shader outputs raw amplitudes.\nI didn't notice this earlier, because I thought audio shaders would output frequencies and amplitudes of sine waves.\nThis is pretty fun!\n(loud)", "tags": ["sound"], "likes": 4, "viewed": 348, "published": 3, "date": "1655644588", "time_retrieved": "2024-07-30T16:43:58.550523", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // circles\n    float circ = mod(length(uv) - iTime * 0.1, 0.1);\n    circ = smoothstep(0.022, 0.028, circ) - smoothstep(0.072, 0.078, circ);\n    \n    // also color depending on radius, too\n    float rad = mod(floor((atan(uv.y, uv.x) + 6.28 + (length(uv) + iTime)) / 0.785) + 0.785, 1.57);\n    vec3 col = mix(vec3(1.0,0.5,0.0), vec3(0.78,0.0,0.0), smoothstep(0.5133,0.5333,rad) - smoothstep(1.036,1.056,rad));\n    \n    fragColor.rgb = mix(col, vec3(1.0),circ);\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    return vec2( step(0.5, fract(6.28 * 200. * time * (sin(floor(time * 10.) / 10.) * 0.25 + 0.75))) );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVyDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 624]]}
{"id": "NsKyDV", "name": "fwidth vs derivative length", "author": "cutesthypnotist", "description": "Compare fwidth (left) to derivative length (right) for anti-aliasing a spiral.\n\nMouse controls: Click to move the line. \nClick and drag off-screen to the left or right to keep a specific spiral.", "tags": ["spiral", "derivatives", "aa", "fwidth"], "likes": 7, "viewed": 311, "published": 3, "date": "1655644420", "time_retrieved": "2024-07-30T16:43:59.363350", "image_code": "#define AA 75.\n#define SWIRLY 50.\n#define SCALE 75.\n#define SIZE 0.25\n#define TIMESCALE 2.0\n\nvec3 hue(float x) {\n    x = 1.5 + 1.5 * cos(sin(x / 6.283185) * 6.283185);\n    return clamp(abs(vec3(x) - vec3(1., 2., 3.)), 0., 1.);\n}\n\nvoid mainImage( out vec4 O, in vec2 FC )\n{\n    vec2 R = iResolution.xy;\n    vec2 U = ( FC - 0.5 * R ) / R.y;   \n    vec2 m = ( iMouse.xy - 0.5 * R) * 2.0 / R.y;\n    float t = iTime * TIMESCALE;\n    \n    // Which side of screen?\n    // Now with janky mouse control.\n    float side = iMouse.z > 0. ? ( FC.x - (0.5 + 0.3 * m.x) * R.x) : ( FC.x - (0.5 + sin(iTime)*0.20) * R.x );\n    //side = 1.;\n    \n    // 2D SDF\n    float dist = log( 1.0 - length(U) ) * SCALE;\n    \n    // Polar conversion\n    float angle = atan(U.x,U.y);\n    \n    // Derivative length.\n    vec2 derv = vec2( dFdx(dist), dFdy(dist) );\n    \n    // Note that fwidth is implemented as abs(dFdx(x)) + abs(dFdy(x)).\n    float width = ( side > 0. ) \n        ? length(derv) \n        : fwidth(dist);\n        \n    dist *= 0.5;\n    \n    // Apply anti-aliasing.\n    float aa = min( AA, AA * width );\n    float swirls = smoothstep(\n        -aa, \n        aa * width, \n        SIZE - sin(  dist + angle + t)\n    );\n    \n    // Screen divider\n    float divider = min( side * side / 8., 1.);\n    \n    \n    vec2 layer = vec2(\n        sin( angle * 0.5 ), \n        cos( swirls * swirls ) * SWIRLY \n    );\n    \n    // Give me the swirlies boss\n    O = vec4(divider * \n        mix(\n            1.0 - hue( length(layer) + t * 0.3 ), \n            hue( length(layer) + t * 0.1 ), \n            swirls\n        ), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKyDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 112, 112, 228], [230, 230, 272, 272, 1591]]}
{"id": "fsKyDK", "name": "Silly Waves", "author": "SnoopethDuckDuck", "description": "Made using this color palette: https://lospec.com/palette-list/ayy4", "tags": ["ayy4"], "likes": 7, "viewed": 273, "published": 3, "date": "1655641244", "time_retrieved": "2024-07-30T16:44:00.105366", "image_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat bwave(vec2 uv, float sc, float r) {\n    uv *= sc;\n    float fx = fract(uv.x) - 0.5;\n    float ix = floor(uv.x) + 0.5;\n    \n    float wave = thc(2., uv.x + iTime);\n    float wave2 = thc(2., ix + iTime);\n    \n    float d = uv.y - wave;\n    d = smin(d, length(vec2(fx, uv.y - wave2)) - r, 0.25);\n    \n    float k = sc / iResolution.y;\n    return smoothstep(-k, k, -d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n   \n    float time = iTime + 1500.;\n   \n    float sc = 12. + 4. * thc(1.5, 0.5 * time + 0.75 * uv.x);\n    uv.x += 0.2 * time / sc;\n    uv.y -= 0.05 * thc(0.5, 0.5 * time + 0.75 * uv.x);\n    \n    vec3 col = vec3(0,48,59)/255.,\n         col1 = vec3(255,119,119)/255.,\n         col2 = vec3(255,206,150)/255.,\n         col3 = vec3(241,242,218)/255.;\n\n    float o = 2. * pi / 3.;\n\n    float t = uv.x + time;\n    float r1 = 0.35 + 0.15 * thc(3., t);\n    float r2 = 0.35 + 0.15 * thc(3., t + o);\n    float r3 = 0.35 + 0.15 * thc(3., t - o);\n    \n    float x1 = 0.125 + 0.075 * thc(1., time + uv.y);\n    float x2 = 0.25  + 0.075 * thc(1., time + uv.y + o);\n    float x3 = 0.375 + 0.075 * thc(1., time + uv.y - o);\n    \n    float y1 = 0.25/sc - 0.22 + 0.075 * cos(t);\n    float y2 = 0.25/sc - 0.   + 0.075 * cos(t + o);\n    float y3 = 0.25/sc + 0.22 + 0.075 * cos(t - o);\n    \n    float w1 = bwave(uv + vec2(x1, y1), sc, r1);\n    float w2 = bwave(uv + vec2(x2, y2), sc, r2);   \n    float w3 = bwave(uv + vec2(x3, y3), sc, r3);\n    \n    col = mix(col, col1, w1);              \n    col = mix(col, col2, w2);              \n    col = mix(col, col3, w3);\n                \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 100, 100, 200], [202, 202, 243, 243, 575], [577, 577, 634, 634, 1891]]}
{"id": "7syyDV", "name": "The benefit of random reciprocal", "author": "mrange", "description": "License CC0: The benefit of random reciprocals\nResult from some random coding and adding a random reciprocal turned out \"weird\" so I kept it\n", "tags": ["2d"], "likes": 6, "viewed": 233, "published": 3, "date": "1655629953", "time_retrieved": "2024-07-30T16:44:00.983019", "image_code": "// License CC0: The benefit of random reciprocals\n//  Result from some random coding and adding a random reciprocal turned out \"weird\" so I kept it\n\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\nvec3 alphaBlend(vec3 bg, vec4 fg) {\n  return mix(bg, fg.xyz, fg.w);\n}\n\nvec4 rasterbar(vec2 p, float bf, float aa) {\n  p = p.yx;\n  \n  const float hw = 0.2;\n  float d = abs(p.y) - hw;\n  float x = p.y/hw;\n  \n  float df = sqrt(max(1.0-x*x, 0.0));\n  vec3 col = hsv2rgb(vec3(bf, df, 1.0-0.5*df));\n  col = mix(vec3(1.0), col, mix(0.0, 1.0, exp(-1.5*(1.0-bf))));\n  \n  float t = smoothstep(aa, -aa, d);\n  return vec4(col, t);\n}\n\nfloat offset(float tm) {\n  return 1.5*sin(tm)*mix(0.25, 1.0, 0.5+0.5*sin(sqrt(0.5)*tm*0.2));\n}\n\nfloat doffset(float tm) {\n  const float eps = 0.01; \n  return (offset(tm+eps)-offset(tm-eps))/(2.0*eps);\n}\n\nvec3 effect(vec2 p) {\n  float aa = 2.0/RESOLUTION.y;\n  vec3 col = vec3(1.0);\n  \n  const int bars = 14;\n\n  for (int i = 0; i < bars; ++i) {\n    vec2 pp = p;\n    float ii = float(i);\n    float bf = ii/float(bars);\n    float itime = TIME + 0.2*ii;\n    float off = offset(itime); \n    float doff = doffset(itime);\n    \n    float oz = mix(0.5, 1.0, bf);\n    pp /= oz;\n    pp.x += off; \n    pp *= ROT(0.2*doff);\n    \n    // Bunch of random code\n    const float flip = 0.125;\n    float ai = smoothstep(-flip, flip, sin(0.25*itime));\n    float iz = pow(max((length(pp-vec2(0.0, 0.6*sin(bf+0.3*itime)))-0.3), 0.), -mix(1.0, 4.0, ai));\n    float mm = mix(5.0, 20.0, length(pp));\n    iz *= 0.05+0.5+0.5*cos(mm*pp.x);\n    iz = mix(iz, 1.0/iz, 1.0-ai);\n    pp /= iz;\n\n    vec4 rcol = rasterbar(pp, bf,aa*iz*oz);\n    col = alphaBlend(col, rcol);\n  }\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p);\n  col = mix(col, vec3(1.0), smoothstep(2.0, 0.0, TIME));\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syyDV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[418, 418, 440, 440, 586], [588, 688, 709, 709, 782], [783, 883, 905, 905, 954], [956, 956, 991, 991, 1025], [1027, 1027, 1071, 1071, 1374], [1376, 1376, 1400, 1400, 1470], [1472, 1472, 1497, 1497, 1578], [1580, 1580, 1601, 1601, 2434], [2436, 2436, 2491, 2491, 2722]]}
{"id": "ssGcWV", "name": "the nyan cat tunnel", "author": "oatmealine", "description": "mess around with the #defines a little!\noriginally made for https://juke.fr/", "tags": ["2d", "simple", "texture", "post", "abstract"], "likes": 1, "viewed": 311, "published": 3, "date": "1655623492", "time_retrieved": "2024-07-30T16:44:01.789862", "image_code": "#define TEXMULT vec2(1.0/6.0, 1.0) // get just 1 nyancat\n#define DEPTH 4.0 // fun to mess around with\n#define RADIUS 0.3\n#define AMP 1. // please do not set this to 0. or else you'll cause an infinite loop\n\n//#define NOFLASH\n//#define NOCOLOR\n\nvec4 dist(vec2 uv, float radius, vec2 dir) {\n    float middle = uv.x * iResolution.x;\n    float rad = radius * iResolution.x;\n    for (\n        vec2 offset = vec2(0.0);\n        length(offset) <= rad;\n        offset += dir\n    ) {\n        vec3 oldCol = vec3(0.0);\n        for (\n            float neg = -1.0;\n            neg <= 1.0;\n            neg += 2.0\n        ) {\n          vec2 uv2 = uv + offset * neg / iResolution.xy;\n          vec4 tex = texture(iChannel0, uv2 * TEXMULT);\n          if (tex.a < 1.0) return vec4(oldCol.rgb, length(offset) / rad);\n          oldCol = tex.rgb;\n        }\n    }\n    return vec4(vec3(0.0), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 tcolor = texture(iChannel0, uv * TEXMULT);\n    if (tcolor.a >= 1.0) {\n        float t = iTime * 0.9;\n        vec4 dr = dist(uv, RADIUS, vec2(sin(t), cos(t)) * AMP);\n        float d = dr.a;\n        float a = sin(t * 4.0 + d * DEPTH);\n        #ifdef NOFLASH\n        a = 1.0;\n        #endif\n        #ifdef NOCOLOR\n        dr.rgb = vec3(1.0);\n        #endif\n        fragColor = vec4(vec3(a) * dr.rgb, 1.0);\n    } else {\n        fragColor = vec4(vec3(sin(uv.y * 1.8 + iTime * 0.9 * 2.0) * 0.1 + 0.45 - 0.3) * vec3(0.8, 0.7, 1.0), 1.0);\n    }\n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGcWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 288, 288, 875], [877, 877, 934, 934, 1524]]}
{"id": "7sycDK", "name": "Mario Oil Painting", "author": "shyshokayu", "description": "Layered/fractal voronoi is cool :)\n\n[url=https://shadertube.web.app/shaders/view/?v=-N4u7ohJ2wOfscy50ZpZ]Shader Source (by me)[/url]", "tags": ["voronoi", "noise", "oil", "paint", "polygon", "mario", "art", "oilpaint", "poly"], "likes": 16, "viewed": 565, "published": 3, "date": "1655617095", "time_retrieved": "2024-07-30T16:44:02.599697", "image_code": "#define imageResolution iResolution.xy\n#define imageAspectRatio (imageResolution.x / imageResolution.y)\n#define imageTime iTime\n\nconst vec4[] colors = vec4[](\n    vec4(0.000, 0.000, 0.000, 0.0), // Black\n    vec4(0.443, 0.415, 0.007, 1.0), // Brown\n    vec4(0.976, 0.670, 0.000, 1.0), // Yellow\n    vec4(0.850, 0.007, 0.000, 1.0) // Red\n);\n\nconst ivec2 size = ivec2(16, 16);\n\nconst int[] pixels = int[](\n    0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,0,\n    0,0,0,0,3,3,3,3,3,3,3,3,3,0,0,0,\n    0,0,0,0,1,1,1,2,2,1,2,0,0,0,0,0,\n    0,0,0,1,2,1,2,2,2,1,2,2,2,0,0,0,\n    0,0,0,1,2,1,1,2,2,2,1,2,2,2,0,0,\n    0,0,0,1,1,2,2,2,2,1,1,1,1,0,0,0,\n    0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,\n    0,0,0,0,1,1,3,1,1,1,0,0,0,0,0,0,\n    0,0,0,1,1,1,3,1,1,3,1,1,1,0,0,0,\n    0,0,1,1,1,1,3,3,3,3,1,1,1,1,0,0,\n    0,0,2,2,1,3,2,3,3,2,3,1,2,2,0,0,\n    0,0,2,2,2,3,3,3,3,3,3,2,2,2,0,0,\n    0,0,2,2,3,3,3,3,3,3,3,3,2,2,0,0,\n    0,0,0,0,3,3,3,0,0,3,3,3,0,0,0,0,\n    0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,\n    0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0\n);\n\n// Hash functions from https://www.shadertoy.com/view/4djSRW\nvec2 random22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec4 textureMario(vec2 uv) {\n    ivec2 p = ivec2(floor(fract(uv) * vec2(size)));\n    \n    int id = (p.x % size.x) + (((size.y - 1) - (p.y % size.y)) * size.x);\n    \n    return colors[pixels[id]] * step(abs(uv.x - 0.5), 0.5) * step(abs(uv.y - 0.5), 0.5);\n}\n\nvec3 voronoiPoint(vec2 uv, vec2 size) {\n    float d = 10.0;\n    vec2 p = vec2(0.0);\n    \n    uv *= size;\n\n    vec2 i = floor(uv);\n    vec2 f = uv - i;\n\n    for(int ix = -1; ix <= 1; ++ix) {\n        for(int iy = -1; iy <= 1; ++iy) {\n            vec2 np = vec2(float(ix), float(iy));\n            vec2 point = random22(i + np);\n            float sd = length(np + point - f);\n            \n            if(sd < d) {\n                d = sd;\n                p = i + np + point;\n            }\n        }\n    }\n    \n    return vec3(p / size, d);\n}\n\nvec4 mainImage(vec2 imageCoordinate) {\n    vec2 uv = (imageCoordinate / imageResolution) - 0.5;\n    uv *= vec2(max(1.0, imageAspectRatio), max(1.0, 1.0 / imageAspectRatio));\n    uv += 0.5;\n    \n    vec3 color = vec3(0.0);\n    \n    int iterations = int(floor(imageTime * 8.0)) % 64;\n    for(int i = 1; i <= iterations; ++i) {\n        float z = float(i);\n        vec2 offset = random21(z);\n        color += textureMario(voronoiPoint(uv + offset, vec2(z)).xy - offset).xyz;\n    }\n    color /= max(1.0, float(iterations));\n\n    color = mix(vec3(0.15, 0.15, 0.15), color, step(abs(uv.x - 0.5), 0.5) * step(abs(uv.y - 0.5), 0.5));\n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    o = mainImage(i);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sycDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[999, 1060, 1083, 1083, 1228], [1230, 1230, 1254, 1254, 1389], [1391, 1391, 1419, 1419, 1646], [1648, 1648, 1687, 1687, 2184], [2186, 2186, 2224, 2224, 2846], [2848, 2848, 2884, 2884, 2908]]}
{"id": "7sGcDK", "name": "Texture Oil Painting", "author": "shyshokayu", "description": "Layered/fractal voronoi is cool :)\n\n[url=https://shadertube.web.app/shaders/view/?v=-N4uOrdTIu-ytsbWbvuU]Shader Source (by me)[/url]", "tags": ["voronoi", "noise", "oil", "paint", "polygon", "art", "oilpaint", "poly"], "likes": 7, "viewed": 662, "published": 3, "date": "1655617063", "time_retrieved": "2024-07-30T16:44:03.422497", "image_code": "#define imageResolution iResolution.xy\n#define imageAspectRatio (imageResolution.x / imageResolution.y)\n#define imageTime iTime\n\n// Hash functions from https://www.shadertoy.com/view/4djSRW\nvec2 random22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec4 textureCustom(vec2 uv) {\n    return texture(iChannel0, uv) * step(abs(uv.x - 0.5), 0.5) * step(abs(uv.y - 0.5), 0.5);\n}\n\nvec3 voronoiPoint(vec2 uv, vec2 size) {\n    float d = 10.0;\n    vec2 p = vec2(0.0);\n    \n    uv *= size;\n\n    vec2 i = floor(uv);\n    vec2 f = uv - i;\n\n    for(int ix = -1; ix <= 1; ++ix) {\n        for(int iy = -1; iy <= 1; ++iy) {\n            vec2 np = vec2(float(ix), float(iy));\n            vec2 point = random22(i + np);\n            float sd = length(np + point - f);\n            \n            if(sd < d) {\n                d = sd;\n                p = i + np + point;\n            }\n        }\n    }\n    \n    return vec3(p / size, d);\n}\n\nvec4 mainImage(vec2 imageCoordinate) {\n    vec2 uv = (imageCoordinate / imageResolution) - 0.5;\n    uv *= vec2(max(1.0, imageAspectRatio), max(1.0, 1.0 / imageAspectRatio));\n    uv += 0.5;\n    \n    vec3 color = vec3(0.0);\n    \n    int iterations = int(floor(imageTime * 8.0)) % 64;\n    for(int i = 1; i <= iterations; ++i) {\n        float z = float(i);\n        vec2 offset = random21(z);\n        color += textureCustom(voronoiPoint(uv + offset, vec2(z)).xy - offset).xyz;\n    }\n    color /= max(1.0, float(iterations));\n\n    color = mix(vec3(0.15, 0.15, 0.15), color, step(abs(uv.x - 0.5), 0.5) * step(abs(uv.y - 0.5), 0.5));\n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 o, vec2 i) {\n    o = mainImage(i);\n}\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGcDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 190, 213, 213, 358], [360, 360, 384, 384, 519], [521, 521, 550, 550, 645], [647, 647, 686, 686, 1183], [1185, 1185, 1223, 1223, 1846], [1848, 1848, 1884, 1884, 1908]]}
{"id": "ssyyDK", "name": "CLOUDY PILLARS [shader-a-day #1]", "author": "NEAR_DREAM_UNITY", "description": "I see everybody's doing these ray* things to do their 3D. Some of them are only like 200 chars even, so it can't be too hard... Gotta figure 'em out if I want to gain the power of creating 3D worlds out of nothing but functions!", "tags": ["raycaster", "rayshooter", "rayblaster"], "likes": 3, "viewed": 260, "published": 3, "date": "1655613575", "time_retrieved": "2024-07-30T16:44:04.263249", "image_code": "/*\n    CLOUDY PILLARS [shader-a-day #1]\n        by NEAR DREAM UNITY\n            2022/06/18\n*/\n\n\nfloat  Cloud  (vec3 q) {\n    vec2 plane = q.xz * mat2x2(15., 8., -8., 15.);\n    float thicc = dot(q, vec3(0.3, 1., 0.7));\n    float value = pow(\n        0.5 + 0.5 * dot(sin(plane), cos(plane)),\n        4. + cos(20. * thicc) + sin(100. * thicc)\n    );\n    return clamp(-.25 + 1.25 * value, 0., 1.);\n}\n\n\nvec3  HotColour  (float value) {\n    return 0.5 + 0.5 * cos(3.141 * (\n        vec3(1.5, 1., 0.) + value\n    ));\n}\n\n\nvec3  CoolColour  (float value) {\n    return vec3(\n        1.,\n        0.5 * value,\n        0.375 + 0.625 * value\n    );\n}\n\n\nvec3  TestColours2DImage  (vec2 p) {\n    //return HotColour(fract(p.y));\n    return CoolColour(fract(p.y));\n}\n\n\nvec3  TestPillars2DImage  (vec2 p) {\n    vec3 d3 = vec3(p.x, iTime, p.y);\n    return HotColour(Cloud(d3));\n}\n\n\nvec2  Rotate  (vec2 a, float r) {\n    float s = sin(r);\n    float c = cos(r);\n    return vec2(a.x * c - a.y * s, a.x * s + a.y * c);\n}\n\n\nvec3  Rayshoot3DImage  (vec2 p) {\n    vec3 direction = normalize(vec3(p * 2., -1.));\n    direction.yz = Rotate(direction.yz, 0.25 + 0.25 * cos(iTime * 0.5));\n    direction.xz = Rotate(direction.xz, sin(iTime * 0.4));\n    vec3 origin = vec3(iTime * 0.125, 0., 0.);\n\n    float capacity = 5.;\n    vec3 colour = vec3(0.);\n    for (float progress = 0.; progress < 1.; progress += 0.001953125) {\n        vec3 ray = origin + progress * direction * 3.;  // Terrible I'm sure. This is my first try.\n\n        float density = Cloud(ray);\n\n        colour += clamp(capacity, 0., 1.) * (1. - progress) * CoolColour(density) * density * 0.175;\n        capacity -= density * 0.3;\n    }\n    return colour;\n}\n\n\nvoid  mainImage  (out vec4 o, vec2 p) {\n    p = (p * 2. - iResolution.xy) / iResolution.y;\n    //o = vec4(TestColours2DImage(p), 1.);\n    //o = vec4(TestPillars2DImage(p), 1.);\n    o = vec4(Rayshoot3DImage(p), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 120, 120, 395], [398, 398, 430, 430, 511], [514, 514, 547, 547, 636], [639, 639, 675, 711, 748], [751, 751, 787, 787, 859], [862, 862, 895, 895, 996], [999, 999, 1032, 1032, 1689], [1692, 1692, 1731, 1731, 1908]]}
{"id": "sdGcWK", "name": "Time and Memory", "author": "Txoka", "description": "This represents how the present is influenced by our past experiences. \nI dont know if this really makes any sense, don't take it seriously, it's just an artistic representation.", "tags": ["time", "perception", "memory", "mind"], "likes": 10, "viewed": 286, "published": 3, "date": "1655604385", "time_retrieved": "2024-07-30T16:44:05.245622", "image_code": "#define animate\nfloat line(vec2 p,vec2 p2,vec2 uv){\n    vec2 n=uv-p;\n\tvec2 w=p2-p;\n\treturn smoothstep(40.*AA,0.0,length(n-w*clamp(dot(n,w)/dot(w,w),0.,1.)));\n}\n\nfloat point(vec2 p,vec2 uv){\n\treturn 10.*AA/dot2(uv-p);\n}\n\nfloat circle(vec2 p,float r,vec2 uv){\n    return smoothstep(30.*AA,0.0,abs(length(uv-p)-r));\n}\nconst float th=0.1;\n\nvoid mainImage( out vec4 O, in vec2 U){\n    vec2 uv = (U*2.-R)/R.y;\n    uv*=10.;\n    vec2 uv2=uv;\n    O=vec4(0);\n    if(uv.y<0.){\n        uv.y=fract(uv.y)-0.5;\n        O = vec4(point(vec2(0),uv));\n    }\n    float sec=fract(iTime);\n    float radi=2.;\n    #ifdef animate\n    radi*=sqrt(max(0.,sec-0.5)*2.);\n    #endif\n    O+=circle(vec2(0,5),radi,uv2);\n    O+=point(vec2(0,5),uv2);\n    O+=line(vec2(0,-10),vec2(0,-0.5),uv2);\n    float circles=0.;\n    if(uv2.x<0.){\n        for(int i=0;i<100;i++){\n            float p1=-0.5-float(i);\n            float p2=5.;\n            vec2 c=vec2(0,(p1+p2)*0.5);\n            float r=(p2-p1)*0.5;\n            float k=hash12(vec2(float(i),floor(iTime)));\n            k=pow(k,float(i+1)*0.5);\n            if(k>th)circles+=circle(c,r,uv2)*(k-th)/(1.-th);\n        }\n    }\n    #ifdef animate\n    circles*=smoothstep(1.,-1.,uv2.y+10.-(min(0.5,sec))*30.);\n    #endif\n    \n    O+=circles;\n}", "image_inputs": [], "common_code": "#define R iResolution.xy\n#define AA (1./R.y)\n\nfloat dot2(vec2 x){return dot(x,x);}\n\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 51, 51, 159], [161, 161, 189, 189, 218], [220, 220, 257, 257, 314], [336, 336, 375, 375, 1250]]}
{"id": "ttsczl", "name": "Octagon Fractal", "author": "NicRule", "description": "Octagon Fractal", "tags": ["octagonfractal"], "likes": 7, "viewed": 240, "published": 3, "date": "1655597587", "time_retrieved": "2024-07-30T16:44:06.124273", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\t\tscale coordinates to be square\n    vec2 uv = ( fragCoord* 2. - iResolution.xy) / min(iResolution.x, iResolution.y)*8.;\n    \n    vec3 col = vec3(0.);\n    float ww = 0.;\n    vec2 m;\n    vec2 d;\n    vec2 cell;\n    \n    for(int i=2; i<8; i++){\n        m = fract(uv*5.+0.5);\n        d = fract(uv*5.);\n        cell = floor(abs(uv*5.)+float(i)*5372.);\n        \n    //    m = fract(uv*5.);\n    //    d = fract(uv*5.+0.5);\n     //   cell = floor(abs(uv*5.+0.5)+float(i)*5372.);// + iTime/10.);\n        \n    //    ww *= 0.5;\n    //    ww += 0.5*\n        ww = \n        //    clamp(\n               length(\n                    max(1.0-abs(m-.5)*10000.+400.,0.) +\n                    max(abs(d.x+vec2(d.y-1.,-d.y))*10000.-6500.,0.)\n                )\n        //    , 0. , 1.)\n        ;\n     //   col *= 0.5;\n        col += vec3(abs(sin(cell.x*cell.y*1.273) + fract(tan(cell.x+cell.y+d.x*27.428+m.y*30.82 + iTime))) , \n                    abs(cos((cell.x+cell.y*523.246)*39.3741)) , 0.5f) * clamp(1.0-ww , 0.0 , 1.0)*0.25;\n     //   col += vec3(clamp(1.0-ww , 0.0 , 1.0)*0.2 * vec3(i%2,i%3,i%4));\n        //       length(\n         //           min(abs(m-.5)*10000.-2000.,0.) + \n          //          min(abs(-d.x-vec2(d.y-1.,-d.y))*10000. - 2000. , 0.)\n           //     );\n        \n        uv /= 2.0;\n    }\n    \n//    col = vec3(ww);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsczl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 96, 1417]]}
{"id": "7sVczd", "name": "caspar-klug walk", "author": "remaindeer", "description": "- visualization of Caspar-Klug Theory: https://viralzone.expasy.org/8577\n- reimplementing this effect from democapsid: https://www.shadertoy.com/view/sltGDj\n- finally learning how to use SDF...\n\n", "tags": ["grid", "sdf", "hexagon", "casparklug"], "likes": 7, "viewed": 280, "published": 3, "date": "1655579938", "time_retrieved": "2024-07-30T16:44:06.948070", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Caspar-Klug\n    float h = 1.0 + round(8.0 / 2.0 * sin(float(iFrame) / 120.0)) + floor(8.0 / 2.0);\n    float k = round(8.0 / 2.0 * sin(float(iFrame) / 30.0)) + floor(8.0 / 2.0);\n    //float h = 4.0;\n    //float k = 2.0;\n    float R = 1.0 / ((h + k) * 1.5);\n    float r = R * cos(radians(30.0));\n    vec2 i = vec2(1.5 * R, 1.0 * r);\n    vec2 j = vec2(0.0 * R, 2.0 * r);\n    mat2 b = mat2(i, j);\n    vec2 t1 = vec2(0);\n    vec2 t2 = b * vec2(h, k);\n    vec2 t3 = rotmat2(radians(-60.0)) * t2;\n    \n    // transform\n    vec2 p = fragCoord / iResolution.y;\n    float s = distance(t1, t2);\n    float a = sqrt(3.0) / 2.0 * s;\n    vec2 h1 = t1 + h * i;\n    vec2 x1 = dot(h1, t2) / dot(t2, t2) * t2;\n    float h1_x1_dist = distance(h1, x1);\n    p *= a + h1_x1_dist;\n    p.y -= h1_x1_dist;\n    p.x -= ((iResolution.x / iResolution.y / a) -  s) / 2.0;\n    p = rotmat2(-atan(t2.y, t2.x)) * p;\n    \n    // distance\n    vec2 v = vec2(3.0 * R, 2.0 * r);\n    vec2 p1 = opRep(p, v);\n    vec2 p2 = opRep(p + v / 2.0, v);\n    float d1 = opUnion(\n        sdHexagon(p1, r),\n        sdHexagon(p2, r)\n    );\n    float d2 = sdHexagon(p - t1, r);\n    float d3 = sdHexagon(p - t2, r);\n    float d4 = sdHexagon(p - t3, r);\n    float th = r * 0.25;\n    float d5;\n    d5 = /*********/ sdSegment(rotmat2(radians(000.0)) * (p - t1), t1, h1);\n    d5 = opUnion(d5, sdSegment(rotmat2(radians(000.0)) * (p - t1), h1, t2));\n    d5 = opUnion(d5, sdSegment(rotmat2(radians(000.0)) * (p - t1), h1, x1));\n    d5 = opUnion(d5, sdSegment(rotmat2(radians(120.0)) * (p - t2), t1, h1));\n    d5 = opUnion(d5, sdSegment(rotmat2(radians(120.0)) * (p - t2), h1, t2));\n    d5 = opUnion(d5, sdSegment(rotmat2(radians(120.0)) * (p - t2), h1, x1));\n    d5 = opUnion(d5, sdSegment(rotmat2(radians(240.0)) * (p - t3), t1, h1));\n    d5 = opUnion(d5, sdSegment(rotmat2(radians(240.0)) * (p - t3), h1, t2));\n    d5 = opUnion(d5, sdSegment(rotmat2(radians(240.0)) * (p - t3), h1, x1));\n    d5 -= th;\n    float d6 = (\n        opUnion(\n            opOnion(sdTriangle(p, t1, t2, t3), th),\n            opOnion(\n                sdTriangle(\n                    p,\n                    x1,\n                    t2 + (t3 - t2) * length(x1),\n                    t3 + (t1 - t3) * length(x1)\n                ),\n                th\n            )\n        )\n    );\n\n    // color\n    vec3 col = vec3(0);\n    col = (d1 > 0.0) ? col : vec3(0.72, 0.45, 0.20);\n    col = (d2 > 0.0) ? col : vec3(1.0, 0.0, 0.0);\n    col = (d3 > 0.0) ? col : vec3(0.0, 1.0, 0.0);\n    col = (d4 > 0.0) ? col : vec3(0.0, 0.0, 1.0);\n    col = (d5 > 0.0) ? col : vec3(0.0, 1.0, 1.0);\n    col = (d6 > 0.0) ? col : 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n    float d = min(min(min(d1, d2), d3), d4);\n    col *= th - exp(-2.0 * abs(d));\n    col *= th + cos(300.0 * d);\n    col = mix(col, vec3(0.5), 1.0 - smoothstep(0.0, th, abs(d)));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "// https://iquilezles.org/articles/distfunctions2d/\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat opUnion( float d1, float d2 ) { \n    return min(d1,d2); \n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nvec2 opRep( in vec2 p, in vec2 c )\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\n// r is the inradius\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nmat2 rotmat2(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 79, 2937]]}
{"id": "ssVyDy", "name": "infinite bouncing balls 3D", "author": "FabriceNeyret2", "description": "Procedural exact bouncing equation ( cf https://www.desmos.com/calculator/ldosgtfifk ).\nfalse-3D variant of https://www.shadertoy.com/view/NsKyRd\n\nWIP. hard to see the depth.\nlong term purpose: repro https://twitter.com/Bbbn192/status/1511007901963403272", "tags": ["2d", "gif", "short"], "likes": 22, "viewed": 335, "published": 3, "date": "1655568486", "time_retrieved": "2024-07-30T16:44:07.981308", "image_code": "// false-3D variant of https://www.shadertoy.com/view/NsKyRd\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float k=.85, g=10., L = 2.*sqrt(4./g); // physics parameters g/2 H=4.\n    vec2  R = iResolution.xy,\n          U = 5.*( u+u - R ) / R.y, V, P;              // normalize coordinates\n    float v, m, a= iMouse.z > 0. ? 3.*(iMouse.y/R.y-.5) : .5;\n    O = vec4(vec3(.8), U.y/10.+.5 );\n    for( float z = 7.; z > -8.; z-- ) {\n        V = U - z; \n        V *= mat2( 1, 0, sin(a), cos(a) ) /cos(a) ;              // isometric projection\n        V.x += 5.*fract(1e4*sin(1e4*z));\n        float t = fract(iTime),\n              x = ( floor(V.x-t) + t ) / L,                      // action domain\n              i = floor( log2( 1. - (1.-k)*(x+.5) ) / log2(k) ), // bounce number\n              K = pow(k,i),\n              X = x -  (1.-K) / (1.-k) + .5,                     // start of bounce i\n              h = x < 0. ?  2. \n                : x > 1./(1.-k) - .5 ? -2.\n                         : -2. +  L*L*g* X*( K - X );            // bounce trajectory\n                         \n       P =   vec2(fract(V.x-t)-.5, V.y+2.)                       // local sphere shadow\n           * mat2(cos(a),0,-sin(a),1); P.y/=.5;                  // back-projection\n       v = (h+2.)/4.;\n       m = clamp( 1. - R.y/(15.+v*80.)*( length(P+vec2(0,.6)) -.25 ) ,0.,1.);       // shadow mask\n       O.rgb = mix(O.rgb, vec3(.6*v), m );                       // blend shasow\n       \n       P =  vec2(fract(V.x-t)-.5, V.y-h)                         // local sphere\n          * mat2(cos(a),0,-sin(a),1);                            // back-projection\n       m = clamp( 1. - R.y/15.*( length(P) -.32 ) ,0.,1.);       // mask\n       O = mix(O, \n               vec4( vec3(1.-2.*length(P),0,0)                       // blend sphere\n                     + max(0., 1.-R.y/50.*( length(P-.12) -.05 )),\n                     (U.y-h+2.)/20.+.5 ),\n               m );\n    }\n//  O += vec4(0,0,exp(-3.*(1.-O.w)),0);\n    O = mix(O, vec4(.6,.8,1,1), exp(-2.*max(0.,1.-O.w))); // fog\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 100, 100, 2037]]}
{"id": "NdVyWw", "name": "Oblivion radar : remake ", "author": "Spacehead", "description": "attempt to replicate radar\nhttps://www.shadertoy.com/view/4s2SRt", "tags": ["2d", "radar"], "likes": 4, "viewed": 215, "published": 3, "date": "1655563434", "time_retrieved": "2024-07-30T16:44:08.815079", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat circleSdf(in vec2 st)\n{\n    return length(st);\n}\n\nfloat boxSdf(in vec2 st, in vec2 sz)\n{\n    st = abs(st) - sz;\n    return length(max(st.x, st.y));\n}\n\nfloat stroke(float f, float size, float w)\n{\n    float a = f + w * .5;\n    float b = f - w * .5;\n    return smoothstep(size, size+.01, a) - smoothstep(size-.01, size, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scale = iResolution.xy / vec2(640, 360);\n    vec2 st = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    st *= scale;\n        \n    float scaleT = iTime * 0.2;\n    \n    float cosT = cos(scaleT);\n    float sinT = sin(scaleT);\n    float sin3T = sin(scaleT * 3.);\n    \n    float r = length(st);\n    float a = atan(st.y, st.x);\n    float circle = circleSdf(st);\n    float cutArea = step(circle, 1.35);\n    \n    float angle =  iTime * 2.;\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    mat2 rot = mat2(cosA, -sinA, sinA, cosA);\n    vec2 stR = st * rot;\n    \n    vec3 col;\n    \n    vec2 animMove = vec2(cosT + sinT, sinT / cosT);\n    float redCircle = circleSdf(st + animMove);\n    float redF = smoothstep(0.025, 0.02, redCircle);\n    \n    redF = smoothstep(0.031, 0.03, redCircle) * abs(sin(iTime * 17.));\n    redF += stroke(redCircle, 0.04, 0.02);\n    float waveR = 0.07 + fract(iTime) * 0.43;\n    redF += smoothstep(waveR - 0.1, waveR, redCircle) * smoothstep(waveR+.01, waveR, redCircle);\n    redF *= cutArea;\n    \n    \n    float whiteF = stroke(circle, 1.35, .02);\n    whiteF += stroke(abs(st.x), abs(st.y), 0.02) * cutArea * .5;\n    \n    animMove = vec2(cosT + sin3T / 1.5, -sin3T + (cosT * 1.2));\n    float moveCircle = circleSdf(st + animMove);\n    whiteF += smoothstep(0.025, 0.02, moveCircle) * cutArea;\n    \n    animMove = vec2(cosT * 0.7 + sinT, sin3T + cosT);\n    moveCircle = circleSdf(st + animMove);\n    whiteF += smoothstep(0.025, 0.02, moveCircle) * cutArea;\n    \n    \n    \n    float blueF = stroke(circle, 1.75, 0.035);\n    blueF = max(blueF - smoothstep(0.,.01,cos(a * 8.) - 0.95), .0);\n    blueF = max(blueF - step(cos(a * 2.), .01) * 0.5, .0);\n    \n    float cut1 = step(cos(a * 2.), 0.8 * (1. + sin(iTime)) / 2.);\n    blueF += (stroke(circle, 1.45, .02) * 0.3) * cut1;\n    \n    blueF += stroke(circle, 0.9, .015);\n    blueF += stroke(circle, 0.55, .015);\n    blueF += stroke(circle, 0.05, .015);\n    \n    \n    blueF += (1. - stroke(abs(st.x), abs(st.y), 3.45 + sin(iTime) * 0.35)) * \n    smoothstep(1., 0.99, boxSdf(st, vec2(0.76 + sin(iTime) * .175)));\n    \n\n    a = atan(stR.y, -stR.x);\n    \n    blueF += (smoothstep(0.8 , 1., (a + PI) / TWO_PI) * .3) * cutArea + \n    smoothstep(.01, .002, boxSdf(stR + vec2(-0.67, 0.), vec2(.67, .001)));\n    \n    \n    col = vec3(redF * vec3(0.988, 0.376, 0.223));\n    col += whiteF;\n    col += vec3(0.741, 0.949, 1.) * blueF;\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 84, 84, 109], [111, 111, 149, 149, 210], [212, 212, 256, 256, 384], [386, 386, 443, 443, 2891]]}
{"id": "NsKyRd", "name": "infinite bouncing balls", "author": "FabriceNeyret2", "description": "Procedural exact bouncing equation ( cf https://www.desmos.com/calculator/ldosgtfifk ).\nLoopless.", "tags": ["2d", "gif", "short", "loopless"], "likes": 12, "viewed": 286, "published": 3, "date": "1655545828", "time_retrieved": "2024-07-30T16:44:09.653836", "image_code": "// Bouncing equation: cf https://www.desmos.com/calculator/ldosgtfifk\n// I: bounce number.  X(i): bounce start.  p(x,I(x)): bounce trajectory\n#define I(x)    floor( log2( 1. - (1.-k)*((x)/L+.5) ) / log2(k) )\n#define X(i)    L* ( (1.-pow(k,i)) / (1.-k) - .5 )\n#define p(x,i) ( x<X(40.) ? (x-X(i))* ( V*pow(k,i) - g/2.* (x-X(i)) ) : 0.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float k=.85, H=4., g=20., V = sqrt(2.*g*H), L = 2.*V/g; // physics parameters\n    vec2  R = iResolution.xy,\n          U = 5.*( 2.*u - R ) / R.y;                        // normalize coordinates\n    \n    float t = fract(iTime),\n          x = floor(U.x-t+2.) + t,                          // action domain\n          h = x < 0. ?  2. \n                     : -2. + p(x,I(x));                     // bouncing\n                 //  : -2. + 4.*abs(cos(x)) * exp(-.5*x);   // very fake test\n    O = vec4(1,0,0,1)                                       // draw\n      * smoothstep(15./R.y,0.,length( vec2(fract(U.x-t)-.5, U.y-h) ) -.2 );\n}\n\n\n\n\n\n\n\n\n\n/**  // --- 342 chars version ( from 423 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    float k=.85, g=10., L = 2.*sqrt(4./g); // physics parameters g/2 H=4.\n    vec2  R = iResolution.xy,\n          U = 5.*( u+u - R ) / R.y;                          // normalize coordinates\n    \n    float t = fract(iTime),\n          x = ( floor(U.x-t+2.) + t ) / L,                   // action domain\n          i = floor( log2( 1. - (1.-k)*(x+.5) ) / log2(k) ), // bounce number\n          K = pow(k,i),\n          X = x -  (1.-K) / (1.-k) + .5,                     // start of bounce i\n          h = x < 0. ?  2. \n            : x > 1./(1.-k) - .5 ? -2.\n                     : -2. +  L*L*g* X*( K - X );            // bounce trajectory\n    O = vec4(1,0,0,1)                                        // draw\n      * (1.-R.y/15.*(length( vec2(fract(U.x-t)-.5, U.y-h) ) -.2 ));\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKyRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 374, 374, 1005]]}
{"id": "NdKcWy", "name": "Honeycomb pattern Grid", "author": "El_Sargo", "description": "Trying out hexagon tiling", "tags": ["2d", "hexagon"], "likes": 6, "viewed": 298, "published": 3, "date": "1655516791", "time_retrieved": "2024-07-30T16:44:10.404337", "image_code": "vec2 localHex(vec2 p){\n    const float z = sqrt(1.-0.25);\n    const vec2 g = vec2(1.5,z);\n    vec2 tile = mod(p+g,2.*g)-g;        \n    if (abs(tile.y) > z/0.5*(1.-abs(tile.x))){tile = mod(tile,2.*g)-g;}\n    return tile;\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 prev = texture(iChannel0, uv).xyz;\n    vec2 nuv = (uv-0.5)*vec2(1,iResolution.y/iResolution.x)*20.;\n    vec2 w =  nuv+iTime*vec2(0.2,0.4);\n    vec2 p = localHex(w);\n    float l = length(p);\n    float n = smoothstep(.9,.7,l)*(-1./(smoothstep(.6,0.9,l)+0.01));\n    vec2 id = round(4.*(w-p));\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec2 r = p*rot(3.*iTime*sin(id.y)+id.x+m.x*3.+m.y*5.);\n    float hex = smoothstep(0.2,0.,-sdHexagon(r, 0.45)+0.1)*100.;\n    n = l > 0.5 ? n: hex;\n    vec3 nor = -normalize(vec3(n*p.x,-1.,n*p.y));\n    const vec3 sun = normalize(vec3(0,1,0));\n    vec3 scl = vec3(0.957,0.827,0.541);\n    vec3 amb = vec3(1.000,1.000,1.000);\n    vec3 col;\n    vec3 bcl = vec3(0.855,0.510,0.027);\n    vec3 hvc = normalize(sun-(normalize(vec3(nuv.x*-2.,-0.7,-nuv.y*2.))));\n    \n    col += bcl*max(0.,dot(nor,sun));\n    col += pow(max(0.,dot(nor,hvc)),20.);\n    col += amb*bcl*.1;\n    vec2 sp = l > .5 ? p : r;\n    col += .65*texture(iChannel0,sp).xyz*smoothstep(.3,1.,nor.y);\n    \n    col = smoothstep(0.,1.2,col);\n    col = pow(col, vec3(.5,1.7,1.6));\n    col *= smoothstep(.53,.45,abs(uv.y-0.5))*smoothstep(.53,0.45,abs(uv.x-0.5));\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 221], [223, 223, 265, 265, 455], [457, 457, 475, 475, 538], [540, 540, 597, 647, 1902]]}
{"id": "NsKyDG", "name": "Infinite hexes background", "author": "mrange", "description": "License CC0: Infinite hexes\nA few weeks ago I tried to recreate a background of a twitch stream\nThe initial estimate was: \"Should be easy!\"\nIt wasn't.", "tags": ["2d", "hex"], "likes": 39, "viewed": 641, "published": 3, "date": "1655499653", "time_retrieved": "2024-07-30T16:44:11.360779", "image_code": "// License CC0: Infinite hexes background\n//  A few weeks ago I tried to recreate a background of a twitch stream\n//  The initial estimate was: \"Should be easy!\"\n//  I spent many evenings tinkering with the shadows as I had the idea\n//  that no raytracing is needed because it \"Should be easy!\" so I just fake the shadows.\n//  In the end I stopped developing the shader disatisfied.\n//  Coming back a few weeks later I now thinks it looks kind of ok.\n//  It is a bit dark but it is intended as a background effect.\n//  The shadows are not perfect but passable. \n//  So I thought I just publish it. \n//  The code is hackish and I have no memory how it works anymore except it annoys me :)\n//\n//  Trust the process\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// https://lists.office.com/Images/72f988bf-86f1-41af-91ab-2d7cd011db47/89ec7e89-f5c4-4b93-9c25-3f75e5220995/T7THIPBZ0Z2YSIOMG8GGIG3OWC/615d356e-0a16-4105-814d-f0408c7d5efb\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n  const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat shape(vec2 p) {\n  return hexagon(p.yx, 0.4)-0.075;\n}\n\nfloat cellHeight(float h) {\n  return 0.05*2.0*(-h);\n}\n\nvec3 cell(vec2 p, float h) {\n  float hd = shape(p);\n\n  const float he = 0.0075*2.0;\n  float aa = he;\n  float hh = -he*smoothstep(aa, -aa, hd);\n  \n  return vec3(hd, hh, cellHeight(h));\n}\n\nfloat height(vec2 p, float h) {\n  return cell(p, h).y;\n}\n\nvec3 normal(vec2 p, float h) {\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy, h) - height(p - e.xy, h);\n  n.y = height(p + e.yx, h) - height(p - e.yx, h);\n  n.z = 2.0*e.x;\n  \n  return normalize(n);\n}\n\nvec3 planeColor(vec3 ro, vec3 rd, vec3 lp, vec3 pp, vec3 pnor, vec3 bcol, vec3 pcol) {\n  vec3  ld = normalize(lp-pp);\n  float dif  = pow(max(dot(ld, pnor), 0.0), 1.0);\n  vec3 col = pcol;\n  col = mix(bcol, col, dif);\n  return col;\n}\n\nconst mat2 rots[6] = mat2[](\n    ROT(0.0*TAU/6.0)\n  , ROT(1.0*TAU/6.0)\n  , ROT(2.0*TAU/6.0)\n  , ROT(3.0*TAU/6.0)\n  , ROT(4.0*TAU/6.0)\n  , ROT(5.0*TAU/6.0)\n); \n\nconst vec2 off = vec2(1.0, 0.0);\n\nconst vec2 offs[6] = vec2[](\n    off*rots[0]\n  , off*rots[1]\n  , off*rots[2]\n  , off*rots[3]\n  , off*rots[4]\n  , off*rots[5]\n  );\n  \nfloat cutSlice(vec2 p, vec2 off) {\n  // A bit like this but unbounded\n  // https://www.shadertoy.com/view/MlycD3\n  p.x = abs(p.x);\n  off.x *= 0.5; \n\n  vec2 nn = normalize(vec2(off));\n  vec2 n  = vec2(nn.y, -nn.x);\n\n  float d0 = length(p-off);\n  float d1 = -(p.y-off.y);\n  float d2 = dot(n, p);\n  \n  bool b = p.x > off.x && (dot(nn, p)-dot(nn, off)) < 0.0;\n  \n  return b ? d0 : max(d1, d2);\n}\n\nfloat hexSlice(vec2 p, int n) {\n  n = 6-n;\n  n = n%6;\n  p *= rots[n];\n  p = p.yx;\n  const vec2 dim  = vec2((0.5)*2.0/sqrt(3.0), (0.5));\n  return cutSlice(p, dim);\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  const float z = 0.327;\n  float aa = 2.0/(z*RESOLUTION.y);\n  \n  p.yx = p;\n  \n  vec3 lp = vec3(3.0, 0.0, 1.0);\n  \n  p -= vec2(0.195, 0.);\n  p /= z;\n\n  float toff = 0.2*TIME;\n  p.x += toff;\n  lp.x += toff;\n\n  vec2 hp  = p;\n  vec2 hn  = hextile(hp);\n  float hh = hash(hn);\n  vec3 c   = cell(hp, hh);\n  float cd = c.x;\n  float ch = c.z;  \n\n  vec3 fpp = vec3(p, ch);\n  vec3 bpp = vec3(p, 0.0);\n\n  vec3 ro = vec3(0.0, 0.0, 1.0);\n  vec3 rd = normalize(fpp-ro);\n\n  vec3  bnor = vec3(0.0, 0.0, 1.0);\n  vec3  bdif = lp-bpp;\n  float bl2  = dot(bdif, bdif);\n\n  vec3  fnor = normal(hp, hh);\n  vec3  fld  = normalize(lp-fpp); \n\n  float sf = 0.0;\n\n  for (int i = 0; i < 6; ++i) {\n    vec2  ioff= offs[i];\n    vec2  ip  = p+ioff;\n    vec2  ihn = hextile(ip);\n    float ihh = hash(ihn);\n    float ich = cellHeight(ihh);\n    float iii = (ich-ch)/fld.z;\n    vec3  ipp = vec3(hp, ch)+iii*fld;\n    \n    float hsd = hexSlice(ipp.xy, i);\n    if (ich > ch) {\n      sf += exp(-20.0*tanh_approx(1.0/(10.0*iii))*max(hsd+0., 0.0));\n    }\n  }\n\n  const float sat = 0.23;\n  vec3 bpcol = planeColor(ro, rd, lp, bpp, bnor, vec3(0.0), HSV2RGB(vec3(240.0/36.0, sat, 0.14)));\n  vec3 fpcol = planeColor(ro, rd, lp, fpp, fnor, bpcol, HSV2RGB(vec3(240.0/36.0, sat, 0.19)));\n\n  vec3 col = bpcol;\n  col = mix(col, fpcol, smoothstep(aa, -aa, cd));\n  col *= 1.0-tanh_approx(sf);\n\n  float fo = exp(-0.025*max(bl2-0., 0.0));\n  col *= fo;\n  col = mix(bpcol, col, fo);\n\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy; \n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  col = sRGB(col);\n  \n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKyDG.jpg", "access": "api", "license": "cc0-1.0", "functions": [[892, 1165, 1186, 1186, 1259], [1260, 1360, 1382, 1382, 1431], [1433, 1493, 1521, 1587, 1663], [1817, 1817, 1839, 1839, 1985], [2281, 2341, 2362, 2362, 2432], [2434, 2535, 2563, 2662, 2989], [2991, 3109, 3141, 3141, 3321], [3323, 3323, 3344, 3344, 3381], [3383, 3383, 3410, 3410, 3436], [3438, 3438, 3466, 3466, 3623], [3625, 3625, 3656, 3656, 3681], [3683, 3683, 3713, 3713, 3911], [3913, 3913, 3999, 3999, 4144], [4473, 4473, 4507, 4585, 4864], [4866, 4866, 4897, 4897, 5030], [5032, 5032, 5061, 5061, 6502], [6504, 6504, 6559, 6559, 6740]]}
{"id": "fsGyDG", "name": "Directional Flow Hexagon", "author": "gehtsiegarnixan", "description": "an improvement with two less texture lookups of Catlike Coding's Direction Flow [url]https://catlikecoding.com/unity/tutorials/flow/directional-flow/ [/url]", "tags": ["wave", "water", "hexagon", "barycentric", "flow", "hex", "directional", "vectorfield", "direction"], "likes": 17, "viewed": 559, "published": 3, "date": "1655483313", "time_retrieved": "2024-07-30T16:44:12.120747", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nUpdate: I created an even faster version Square Directional Flow \n(https://www.shadertoy.com/view/7dtBWl).\n\nThis is an improved version of the Directional Flow algroithm. It only uses\n6 texture lookups instead of 8. It does this by switching the square grid \npattern to a hexagonal grid pattern.\n\nDirectional Flow animates and rotates a texture in multiple directions with \na flowmap. This means that water wave textures can flow in multiple directions \nat the same time, while the waves point in the right direction. This is not \npossible with trational flow animation, which either has only one wind \ndirection or stretches the texture with temporal blending. The Directional Flow\ndoes this by blending in the spatial dimension. \n\nThe previous 8 sample Directional Flow is implemented in shadertoys here:\nhttps://www.shadertoy.com/view/fsKczd\n\nHere is my Rhombic Dodecahedron Tiling to have Hex Directional Flow in 3D:\nhttps://www.shadertoy.com/view/fddfRn\n\nHere is a diffeent use case with cyclone windwaves:\nhttps://www.shadertoy.com/view/7dycDV\n\nThe earliest iteration of directional flow I could find is from 2010:\nhttps://www.rug.nl/society-business/centre-for-information-technology/research/hpcv/publications/watershader/\nBut CatlikeCoding's version is much better explained, so I recommend reading \nit as a guide:\nhttps://catlikecoding.com/unity/tutorials/flow/directional-flow/\n*/\n\n//#define ShowGrid\n\n#define SQRT3 \t\t\t1.7320508076 //sqrt(3)\n#define HALF_SQRT3\t\t0.8660254038 //sqrt(3)/2\n#define INV_SQRT3\t\t0.5773502693 // 1/sqrt(3)\n#define INV_TWO_SQRT3 0.2886751346 // 1/(2 sqrt(3))\n\n// if you want flat tops (hex rotated by 30deg) swap xy in hr and the p.x to p.y in hexDist\n#define R vec2(1, SQRT3) // 1, sqrt(3)\n#define H vec2(0.5,HALF_SQRT3) // 1/2, sqrt(3) /2\n\nfloat hexDist(vec2 p) {\n\tp = abs(p);   \n    return max(dot(p, H), p.x);\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\ntilingVal hexTile(vec2 uv) {   \n    vec2 a = mod(uv, R)-H;\n    vec2 b = mod(uv-H, R)-H;\n    \n    vec2 grid = dot(a, a) < dot(b,b) ? a : b;    \n    \n    // float edist = .5-hexDist(gv);  // Edge distance.\n    float edist = (.5-hexDist(grid))*2.; //  Edge distance with range 0-1    \n    // float cdist = dot(gv, gv); // squared distance from the center.\n    vec2 id = uv-grid; // simple ID calculation\n    \n    return tilingVal(grid, id, edist);  // make tilingVal struct\n}\n\n// makes a hexagon pixelized pattern without offset\ntilingVal hexPixelizor(vec2 uv, float gridRes, vec2 offset) {\n    // generate hex grid tiling\n    tilingVal tiling = hexTile(uv * gridRes + offset); \n    // generate square grid tiling    \n    tiling.id = (tiling.id - offset)/gridRes; //pixaltion    \n    return tiling;\n}\n\n// 3 hex pixaled flowing textures thier edges get hidden by each other\nvec3 hexDirectionalFlow(sampler2D tex, sampler2D flow, vec2 uv, \n                           float gridRes, float time, float contrast) { \n    // generate grid values each is at the corners of the others\n    tilingVal A = hexPixelizor(uv, gridRes, vec2(0.));\n    tilingVal B = hexPixelizor(uv, gridRes, vec2(0,INV_SQRT3));\n    tilingVal C = hexPixelizor(uv, gridRes, vec2(0.5,INV_TWO_SQRT3));\n\n    // sample flow map in each grid\n    vec2 flowA = flowMap(flow, A.id);\n    vec2 flowB = flowMap(flow, B.id);\n    vec2 flowC = flowMap(flow, C.id);\n    \n    // scale UVs so the entire texture is visible in a tile\n    // the proper range is ~1-3 and artists don't read, so constant\n    A.grid *= 2.0;\n    B.grid *= 2.0;\n    C.grid *= 2.0;\n    \n    // rotate and offset then sample texture\n    vec3 gridA = PanDirectionalTex(tex, A.grid, flowA, time);\n    vec3 gridB = PanDirectionalTex(tex, B.grid, flowB, time);\n    vec3 gridC = PanDirectionalTex(tex, C.grid, flowC, time);\n    \n    //All edgeDist added = 1 -> so we can skip the more expensive C calculation\n    vec3 alpha = vec3(A.edgeDist, B.edgeDist, 1.-(A.edgeDist + B.edgeDist)); \n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    // interpolate result\n    vec3 col = gridA * alpha.x + gridB * alpha.y + gridC * alpha.z;\n    \n#ifdef ShowGrid\n    // overlaying the edges of the alpha mask\n    float lineThickness = 0.03; // must be smaller than 0.1\n    vec3 mask = step(abs(alpha - 0.1), vec3(lineThickness));\n    return max(mask, col);\n#else\n    return col;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {    \n    float time = iTime* .4; // flow speed multiplier\n    float gridRes = 8.; // the number of subdivisions for the sampling of the flowmap\n    float contrast = 2.;  // 1-inf, increased the contrast between the tiles\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n\n    vec3 hdf = hexDirectionalFlow(iChannel0, iChannel1, uv, gridRes, time, contrast);\n    \n    #ifndef  ShowGrid   \n    hdf += vec3(0.0,0.2,0.5); //adding arbitrary watery color\n    #endif\n    \n    fragColor = vec4(hdf, 0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal {\n    vec2 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec2 id;         // ID values\n    float edgeDist;  // Edge distance from the cell's center to its boundaries\n};\n\n// rotates UV by direction\nvec2 rotateUV(vec2 uv, vec2 direction)\n{\n    // Normalize the direction vector\n    direction = normalize(direction);\n\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2(\n        direction.x, -direction.y,\n        direction.y, direction.x\n    );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// rotates and animates texture in flowmap direction \nvec3 PanDirectionalTex (sampler2D sam, vec2 uv, vec2 flowMap, float time) {  \n    uv += flowMap*time; // add offset with time\n\n    uv = rotateUV(uv, flowMap); // rotate UVs\n    \n    return texture(sam, uv).xyz; // sample texture\n}\n\n// generates a -1-1 smooth flowmap\nvec2 flowMap(sampler2D sam, vec2 uv) {\n    //a random spot in the noise map, normally you use an actual flowmap\n    vec2 flowMap = texture(sam, uv*0.05).xy;\n    return flowMap * 2. -1.; // constant bias scale for -1 to 1 range\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGyDG.jpg", "access": "api", "license": "mit", "functions": [[2862, 2862, 2885, 2885, 2935], [2937, 3011, 3039, 3039, 3483], [3485, 3537, 3598, 3630, 3808], [3810, 3881, 4017, 4083, 5428], [5430, 5430, 5486, 5486, 5997]]}
{"id": "sdKczh", "name": "Eisenstein Series", "author": "mla", "description": "Eisenstein Series modular forms.\n\n[url]https://en.wikipedia.org/wiki/Eisenstein_series[/url]\nDavid Lowry-Duda: [url]https://davidlowryduda.com/quanta-langlands-viz/[/url]\n@branc116: [url]https://www.shadertoy.com/view/Nsyyzh[/url]\n\nShows E4-E30. Mousable.", "tags": ["complex", "form", "modular", "eisensteinseries"], "likes": 9, "viewed": 317, "published": 3, "date": "1655480807", "time_retrieved": "2024-07-30T16:44:12.871739", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Eisenstein Series, Matthew Arcus, mla, 2022\n//\n// Based on original work by David Lowry-Duda:\n// https://davidlowryduda.com/quanta-langlands-viz/\n// Also inspired by (and some code based on)\n// @branc116's https://www.shadertoy.com/view/Nsyyzh\n//\n// <mouse>: apply transform to disk or plane\n// 'h': Half plane/disk\n// 'p': Show phase as color\n// 'm': Show (log) magnitude as shading\n// 'l': Show log(w) tiles\n// 'r': Show fundamental region\n// 'f': Use pullback/fold\n// 'c': Continuous coloring\n// 't': Rotate colors\n// 'e': Use texture for coloring\n//\n// A Modular Form is a complex valued function, defined on\n// the upper half plane, that is invariant (up to a certain\n// scaling factor, determined by the \"weight\" of the form) \n// under the action of the modular group (integer valued\n// Mobius transformations with unit determinant).\n//\n// The Eisenstein Series modular form of weight k is the sum of \n// 1/(nz+m)^k for all integers n,m, except 0,0. Since k >= 4,\n// and Re(z) < 0.5 in the fundamental region the sum converges\n// fairly quickly, so can be used directly to evaluate the form.\n// Some optimization of the calculation is possible, in which\n// Riemann's zeta function plays an important part (see code).\n//\n// The value of the form is shown with color indicating phase\n// and shading showing (log) magnitude. The boundary of the\n// fundamental region is also shown ('p','m' and 'r' control\n// these).\n//\n// By default the upper halfplane is shown, (press 'h' to map\n// into the unit disk). Use mouse for a Mobius transformation \n// of the disk or plane.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat zeta(int n) {\n  // Should probably use a fixed array here, eg. zeta(4) = 1.082323 etc.\n  float x = 0.0;\n  for (int j = 6; j > 1; --j) {\n    x += 1.0/pow(float(j),float(n));\n  }\n  return x+1.0;\n}\n\n// Euclid's algorithm - since this is only used for small n,m,\n// we hardly ever loop.\nbool coprime(int n, int m) {\n  while (m != 0) {\n    int t = m;\n    m = n%m;\n    n = t;\n  }\n  return n == 1;\n}\n\n// The Eisenstein series - sum 1/(nz+m)^k for all integers n,m, except 0,0\n// Since for a modular form, k is at least 4, and Re(z) <= 1/2, things\n// converge fairly quickly & for drawing pictures we can get away with n,m <= 3.\n// Based on original function by @branc116\nvec2 eisen0(vec2 z, int weight) {\n  vec2 w = complex(0);\n  int N = 3;\n  for (int i = -N; i <= N; ++i) {\n    vec2 prod = float(i)*z;\n    for (int j = -N; j <= N; ++j) {\n      if (i == 0 && j == 0) continue;\n      w += cinv(cpow(prod+complex(j), weight));\n    }\n  }\n  return w;\n}\n\n// Optimized version - since all pairs (n,m) are all pairs (tn',tm')\n// for coprime n',m' and any positive t, can sum 1/(nz+m)^k just for coprime\n// n, m, and multiply by zeta(k) = sum(1/t^k). Once we do this, various\n// simplifications of the loop bounds are also possible.\n// Note that zeta(k) is approximately 1 for integer k >= 4 and anyway\n// multiplication by a constant factor doesn't make much difference\n// to the displayed image.\nvec2 eisen(vec2 z, int k) {\n  int N = 3;\n  if (key(CHAR_Z)) N++; // Do an extra round, just to check.\n  vec2 w = complex(1); // 0,1\n  w += cinv(cpow(z,k)); // 1,0 \n  w += cinv(cpow(z+complex(1), k)); // 1,1\n  w += cinv(cpow(z-complex(1), k)); // 1,-1\n  for (int i = 1; i <= N; ++i) {\n    vec2 iz = float(i)*z;\n    for (int j = i+1; j <= N; ++j) {\n      if (!coprime(i,j)) continue;\n      vec2 jz = float(j)*z;\n      w += cinv(cpow(iz+complex(j), k));\n      w += cinv(cpow(iz-complex(j), k));\n      w += cinv(cpow(jz+complex(i), k));\n      w += cinv(cpow(jz-complex(i), k));\n    }\n  }\n  w *= 2.0*zeta(k);\n  return w;\n}\n\nvec2 act(mat2 gamma, vec2 z) {\n  // Action of Mobius transformation matrix on z.\n  float a = gamma[0][0], b = gamma[0][1];\n  float c = gamma[1][0], d = gamma[1][1];\n  return cdiv(a*z+complex(b),c*z+complex(d));\n}\n\nvec2 pullback(vec2 z, out mat2 gamma) {\n  // Returns gamma, w such that gamma(z) = w and w is\n  // (essentially) in the fundamental domain. We specify\n  // the matrices in \"row major\" form, and swap the order\n  // of multiplication (since this is GLSL).\n  gamma = mat2(1);\n  for (int i = 0; i < 40; i++) {\n    if (abs(z.x) < 0.5 && dot(z,z) > 1.0) break;\n    float xshift = -floor(z.x + 0.5);\n    mat2 shiftmatrix = mat2(1, xshift, 0, 1);\n    gamma *= shiftmatrix;\n    z = act(shiftmatrix, z);\n    if (dot(z,z) < 1.0) {\n      z = -cinv(z);\n      gamma *= mat2(0, -1, 1, 0);\n    }\n  }\n  return z;\n}\n\nfloat clength(vec2 z) {\n  // \"Careful\" length - avoid overflow for very large values\n  float t = max(abs(z.x),abs(z.y));\n  if (t <= 1e4) return length(z);\n  z /= t;\n  return t*length(z);\n}\n\nvec3 getcolor(vec2 z) {\n  if (!key(CHAR_H)) {\n    // Halfplane\n    z.y += 1.0;\n    if (iMouse.x > 0.0) {\n      vec2 c = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n      z.x -= c.x;\n      z *= (c.y+1.0)/dot(z,z);\n      z.x += c.x;\n      z /= dot(z,z);\n    }\n  } else {\n    if (dot(z,z) > 1.0) return vec3(0);\n    if (iMouse.x > 0.0) {\n      vec2 c = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n      if (dot(c,c) > 1.0) c /= dot(c,c);\n      z -= c;\n      z *= (dot(c,c)-1.0)/dot(z,z);\n      z += c;\n      z /= -dot(z,z);\n    }\n    z.y += 1.0;\n    z *= 2.0/dot(z,z);\n    z.y -= 1.0;\n    z /= dot(z,z);\n  }\n  mat2 gamma = mat2(1);\n  if (!key(CHAR_F)) z = pullback(z,gamma);\n  float a = gamma[0][0], b = gamma[0][1];\n  float c = gamma[1][0], d = gamma[1][1];\n  int weight = 2*(int(iTime)%14+2);\n  vec2 w = eisen(z,weight);\n  if (w == vec2(0)) return vec3(0);\n  // Apply modularity - note that gamma is inverse of mapping\n  // to fundamental region & and has unit determinant.\n  w = cmul(w,cpow(-c*z + complex(a),weight));\n  if (key(CHAR_D)) w = cmul(w,w);\n  float t = 0.0;\n  if (key(CHAR_T)) t = 0.2*iTime;\n  float h = 0.5+atan(w.y,w.x)/TWOPI;\n  if (!key(CHAR_C)) h *= 0.5; // Use limited color range\n  vec3 col = vec3(1,1,0.5);\n  if (!key(CHAR_P)) col = 0.2+0.8*h2rgb(h+t);\n  if (key(CHAR_E)) {\n    // Tile with texture\n    vec2 uv = clog(w)/PI;\n    uv += 1.0;\n    uv = mod(uv,2.0);\n    uv = min(uv,2.0-uv); // Mirroring\n    col = texture(iChannel0,uv).rgb;\n    col = pow(col,vec3(2.2));\n  }\n  if (key(CHAR_L)) {\n    vec2 uv = 4.0*clog(w)/PI;\n    float px = fwidth(uv.x);\n    uv = fract(uv);\n    uv = min(uv,1.0-uv);\n    col *= smoothstep(0.0,min(px,0.1),min(uv.x,uv.y));\n  }\n  if (!key(CHAR_M)) col *= 0.65+0.35*sin(t+4.0*log(clength(w)));\n  if (!key(CHAR_R)) {\n    //  Fundamental region borders\n    float d = abs(0.5-abs(z.x)) - 0.02;\n    d = min(d,abs(length(z)-1.0) - 0.02);\n    d = min(d,abs(z.x)-0.015);\n    float px = fwidth(d);\n    col *= 0.5+0.5*smoothstep(-px,px,d);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  int AA = 2;\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++){\n      for (int j = 0; j < AA; j++) {\n        vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n        col += getcolor(z);\n      }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) { if (!b) alert = true; }\n\nconst float PI = 3.14159265359;\nconst float TWOPI = 2.0*3.14159265359;\n\n#define complex(x) (vec2((x),0))\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n  //return mat2(z.x,z.y,-z.y,z.x)*w; // Miscompiles on ANGLE\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 cexp(vec2 z) {\n  // If cos and sin were perfect we wouldn't need normalize\n  return exp(z.x)*normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n  return cexp(cmul(clog(z),w));\n}\n\nvec2 cpow0(vec2 z, int n) {\n  return cpow(z,vec2(n,0));\n}\n\nvec2 cpow(vec2 z, int n) {\n  // Integer powers by repeated squaring, more\n  // for precision than for performance.\n  vec2 res = vec2(1,0);\n  vec2 t = z;\n  while (true) {\n    if ((n&1) == 1) res = cmul(t,res);\n    n >>= 1;\n    if (n == 0) break;\n    t = cmul(t,t);\n  }\n  return res;\n}\n\nvec3 h2rgb(float h) {\n  // Function by iq\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1745, 1745, 1764, 1837, 1945], [1947, 2034, 2062, 2062, 2143], [2145, 2415, 2448, 2448, 2692], [2694, 3134, 3161, 3161, 3751], [3753, 3753, 3783, 3833, 3965], [3967, 3967, 4006, 4220, 4564], [4566, 4566, 4589, 4650, 4754], [6757, 6757, 6809, 6809, 7150]]}
{"id": "7dGyWy", "name": "tunnel box", "author": "jorge2017a2", "description": "tunnel box", "tags": ["tunnelbox"], "likes": 9, "viewed": 280, "published": 3, "date": "1655476306", "time_retrieved": "2024-07-30T16:44:13.618742", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n//tunnel box---17-jun-2022\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\nfloat mAng;\nvec3 mHitp;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 AnillocuadradoVert(vec3 p, float pmat)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n   float d1a= sdBox( p, vec3(12.0,12.0,2.0) );\n   float d1b= sdBox( p, vec3(8.0,8.0,2.5) );\n    d1a= Difference(d1a, d1b);\n    res =opU2(res, vec2(d1a,pmat));\n    return res;\n}   \n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    \n    vec3 p0=p;\n\t\n    p.y=p.y-15.0;\n    vec3 p1=p-vec3(.0,.0, 0.0);\n    vec3 p2=p-vec3(.0,.0,-5.0);;\n    vec3 p3=p-vec3(.0,.0,-10.0);;\n    \n    float tt=iTime*10.0;\n    p1.z= opRep1D(p1.z, 15.0 );\n    p2.z= opRep1D(p2.z, 15.0 );\n    p3.z= opRep1D(p3.z, 15.0 );\n   \n    float ang1=radians(60.0 +tt);\n    float ang2=radians(120.0 -tt);\n    float ang3=radians(180.0 +tt);\n    p1= rotate_z(p1, ang1);\n    p2= rotate_z(p2, ang2);\n    p3= rotate_z(p3, ang3);\n    vec2 Ac1= AnillocuadradoVert(p1,100.0);\n    vec2 Ac2= AnillocuadradoVert(p2,101.0);\n    vec2 Ac3= AnillocuadradoVert(p3,102.0);\n    res =opU2(res, Ac1);\n    res =opU2(res, Ac2);\n    res =opU2(res, Ac3);\n    \n    if (res.x==Ac1.x) {mAng=ang1; mHitp=p1;}\n    if (res.x==Ac2.x) {mAng=ang2; mHitp=p2;}\n    if (res.x==Ac3.x) {mAng=ang3; mHitp=p3;}\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    p=mHitp;\n    nor= rotate_z(nor, mAng);\n    if (i==100 ){ col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor)*vec3(1.0,0.2,0.2)*2.0; }\n\tif (i==102 ) { return tex3D(iChannel0, p/16., nor)*vec3(0.5,1.0,0.2)*2.0; }\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{   if (id_color>=100 ){ return  getColorTextura( p, nor,id_color); } }\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST-10.0)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else\n        col=vec3(0.0);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,15.0+5.*sin(t),-25.0+t*5.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[561, 561, 593, 593, 677], [679, 679, 723, 723, 750], [751, 751, 791, 791, 818], [819, 819, 864, 864, 892], [893, 931, 967, 967, 1012], [1014, 1014, 1048, 1048, 1144], [1145, 1145, 1179, 1179, 1270], [1271, 1271, 1305, 1305, 1396], [1398, 1398, 1443, 1443, 1662], [1668, 1668, 1693, 1693, 2552], [2554, 2554, 2578, 2578, 2740], [2742, 2742, 2790, 2790, 3069], [3071, 3071, 3115, 3115, 3436], [3438, 3438, 3475, 3475, 3732], [3734, 3734, 3757, 3757, 3902], [3904, 3904, 3994, 3994, 4954], [4956, 4956, 5005, 5005, 5284], [5286, 5286, 5356, 5356, 5426], [5428, 5428, 5455, 5455, 5544], [5546, 5546, 5604, 5604, 5652], [5654, 5654, 5677, 5677, 5789], [5791, 5791, 5822, 5822, 6420], [6422, 6422, 6479, 6479, 6921]]}
{"id": "ssGyWy", "name": "Shader Cap", "author": "yasuo", "description": "Sold out!", "tags": ["cap"], "likes": 12, "viewed": 267, "published": 3, "date": "1655476042", "time_retrieved": "2024-07-30T16:44:14.543270", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 256\n#define MAX_DIST 128.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define MATERIAL 0\n#define MATERIAL1 1\n#define NAVY vec3(0.0,0.2,0.3)\n#define RED vec3(0.5,0.1,0.1)\n#define GREEN vec3(0.0,0.3,0.2)\n#define GALAXY vec3(0.75,0.75,0.8)\n#define PI 3.141592653589793\n\n#define ZERO (min(iFrame,0))\n\nconst vec3 colors[4] = vec3[](NAVY,RED,GREEN,GALAXY);\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nvec3 bend(vec3 p, float k){\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n\tconst vec3 s = vec3(27, 111, 57);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\nvec2 hash(vec2 p){\n    vec2 rand = fract(sin(p*123.456)*567.89);\n    rand += dot(rand,rand*34.56);\n    return fract(rand);\n}\n\nvec4 voronoi(vec2 uv, float scale){\n    uv*=scale;\n    \n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    \n    vec4 m_col = vec4(0.1);\n    float vd = 1.0;\n    for(int y = -1; y<=1; y++){\n        for(int x = -1; x<=1; x++){\n            vec2 n = vec2(float(x),float(y));\n            vec2 p = hash(id+n);\n            vec2 prevP = p;\n            p = 0.5 + 0.5*sin(iTime + 6.2831*p);\n            vec2 diff = n + p - gv;\n            float d = length(diff);\n            float ptd = length(diff)-(0.1*abs(prevP.x));\n\n            if ( d < vd ) {\n                vd = d;\n                m_col.xy = diff+hash(id+n);\n                m_col.w = ptd;\n            }\n            \n        }\n    }\n    \n    return m_col;\n}\n\nfloat perlin_noise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\nvec3 getVoronoiCol(vec2 p){\n    vec3 c = vec3(0.7);\n\n    vec2 vd = voronoi(p,5.0).xy;\n    c.rb=vd;\n    return c;\n}\n\nvec3 pnoiseCol(vec2 p){\n    p.y-=iTime*0.3;\n    vec3 c1 = vec3(perlin_noise(p*3.0),0.2,0.0);\n    vec3 c3 = vec3(0.5,0.0,perlin_noise(p));\n    return vec3(1.)+c1+c3; \n}\n\nvec3 getColor(vec2 p, int num){\n    vec3 c = vec3(1.);\n    int len = colors.length();\n    if(num<len){\n        c = colors[num];\n    } else {\n        if(num == len){\n            c = getVoronoiCol(p);\n        } else {\n            c = pnoiseCol(p);\n        }\n    }\n    return c;\n}\n\nfloat capDist(vec3 p){\n    vec3 prevP = p;\n    \n    p.yz*=Rot(radians(90.));\n    p.xy*=Rot(radians(90.));\n    p.x*=1.05;\n    float d = abs(sdHexPrism(p,vec2(0.5,0.2))-2.0)-0.1;\n    p = prevP;\n    d = max(-p.y-0.6,d);\n    \n    p.z+=2.46;\n    \n    vec3  q = bend(p,-0.12);\n    float d2 = sdBox(q,vec3(1.5,-2.3,0.7))-2.5;\n    \n    q.y+=0.5;\n    float mask = sdBox(q,vec3(2.5,0.5,1.57));\n    \n    d = max(-mask,d);\n    \n    d = smin(d,d2,0.2);\n    \n    p = prevP;\n    p.y-=2.3;\n    p.y*=2.;\n    d2 = length(p)-0.22;\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y-=1.92;\n    p.xz = DF(p.xz,1.5);\n    p.xz -= vec2(1.2,1.2);\n    p.xy*=Rot(radians(30.));\n    p.yz*=Rot(radians(-30.));\n    \n    d2 = sdTorus(p,vec2(0.1,0.05));\n    \n    d = min(d,d2);\n   \n    return d;\n}\n\n/*\nI always wanted to do the displacement to add elements to the surface of the model nicely, \nbut I have no clue what is the simplet way to approach this kinda stuff.\n*/\nfloat capLogo(vec3 p) {\n    p.y*=1.5;\n    p.y-=1.9;\n    p.z+=2.1;\n    \n    p.x*=-1.;\n    p.xy*=Rot(radians(80.));\n    p.xz*=Rot(radians(22.));\n    p*=0.8;\n    vec3 prevP = p;\n    p.x+=0.3;\n    p.xy*=Rot(radians(-20.));\n    float r = radians(100.0);\n    vec2 c = vec2(sin(r),cos(r));\n    float d = sdCappedTorus(p,c,0.3,0.2);\n    \n    p = prevP;\n    p.x-=0.3;\n    p.xy*=Rot(radians(160.));\n    r = radians(100.0);\n    c = vec2(sin(r),cos(r));\n    float d2 = sdCappedTorus(p,c,0.3,0.2);\n    \n    return smin(d,d2,0.05);\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p+=noise3d(p*500.0)*0.001;\n    float d = capDist(p);\n    float d2 = capLogo(p);\n    \n    vec2 model = vec2(d*0.6,MATERIAL);\n    vec2 model2 = vec2(d2,MATERIAL1);\n    \n    return combine(model,model2);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(10,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat backOut(float t) {\n  float f = 1.0 - t;\n  return 1.0 - (pow(f, 3.0) - f * sin(f * PI));\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 prevP = p;\n    if(mat == MATERIAL){\n        float frame = mod(iTime,30.);\n        int num = 0;\n        float time = frame;\n        vec3 c = vec3(1.0);\n        if(frame<5.){\n            c = getColor(p.xz,5);\n            time = getTime(time,1.5);\n        } else if(frame>=5.0 && frame<10.){\n            num = 1;\n            c = getColor(p.xz,0);\n            time = getTime(time-5.0,1.5);\n        } else if(frame>=10.0 && frame<15.) {\n            num = 2;\n            c = getColor(p.xz,1);\n            time = getTime(time-10.0,1.5);\n        } else if(frame>=15.0 && frame<20.) {\n            num = 3;\n            c = getColor(p.xz,2);\n            time = getTime(time-15.0,1.5);\n        } else if(frame>=20.0 && frame<25.) {\n            num = 4;\n            c = getColor(p.xz,3);\n            time = getTime(time-20.0,1.5);\n        } else if(frame>=25.0 && frame<30.) {\n            num = 5;\n            c = getColor(p.xz,4);\n            time = getTime(time-25.0,1.5);\n        }\n        \n        vec3 pos = p;\n        pos.y-=1.2;\n        float d = length(pos.xy)-(cubicInOut(time)*5.0);\n        c = mix(c,getColor(p.xz,num),S(d,-0.9));\n        \n        col = diffuseMaterial(n,rd,p,c);\n    } else if(mat == MATERIAL1){\n        vec3 c = vec3(0.9);\n        col = diffuseMaterial(n,rd,p,c);\n    }\n    return col;\n}\n\nvec3 drawUI(vec2 uv, vec3 col){\n    vec2 prevUV = uv;\n    float size = 0.035;\n    float y = -0.4;\n    \n    float frame = mod(iTime,30.);\n    vec2 selectedPos = vec2(-0.375,y);\n    float time = frame;\n    float ptime = frame;\n    float interval = 5.;\n    if(frame<5.){\n        time = getTime(time,0.6);\n    } else if(frame>=5.0 && frame<10.){\n        selectedPos = vec2(-0.225,y);\n        time = getTime(time-5.0,0.6);\n        ptime = ptime-5.0;\n    } else if(frame>=10.0 && frame<15.) {\n        selectedPos = vec2(-0.075,y);\n        time = getTime(time-10.0,0.6);\n        ptime = ptime-10.0;\n    } else if(frame>=15.0 && frame<20.) {\n        selectedPos = vec2(0.075,y);\n        time = getTime(time-15.0,0.6);\n        ptime = ptime-15.0;\n    } else if(frame>=20.0 && frame<25.) {\n        selectedPos = vec2(0.225,y);\n        time = getTime(time-20.0,0.6);\n        ptime = ptime-20.0;\n    } else if(frame>=25.0 && frame<30.) {\n        selectedPos = vec2(0.375,y);\n        time = getTime(time-25.0,0.6);\n        ptime = ptime-25.0;\n    }\n    \n    float dd = abs(length(uv-selectedPos)-(backOut(time)*(size+0.01)))-0.002;\n    col = mix(col, vec3(1.0),S(dd,0.0));\n    \n    dd = length(uv-vec2(-0.375,y))-size;\n    col = mix(col, getColor(uv,0),S(dd,0.0));\n    dd = length(uv-vec2(-0.225,y))-size;\n    col = mix(col, getColor(uv,1),S(dd,0.0));\n    dd = length(uv-vec2(-0.075,y))-size;\n    col = mix(col, getColor(uv,2),S(dd,0.0));\n    dd = length(uv-vec2(0.075,y))-size;\n    col = mix(col, getColor(uv,3),S(dd,0.0));\n    dd = length(uv-vec2(0.225,y))-size;\n    col = mix(col, getColor(uv,4),S(dd,0.0));\n    dd = length(uv-vec2(0.375,y))-size;\n    col = mix(col, getColor(uv,5)-vec3(0.55),S(dd,0.0)); \n    \n    // icon\n    uv.x-=0.07;\n    dd = abs(B(uv-vec2(0.3,0.4),vec2(0.04,0.025)))-0.002;\n    float dd2 = abs(B(uv-vec2(0.3,0.435),vec2(0.02,0.01)))-0.002;\n    dd = min(dd,dd2);\n    uv.x*=1.5;\n    dd2 = abs(length(uv-vec2(0.45,0.4))-0.01)-0.002;\n    dd = min(dd,dd2);\n    col = mix(col, vec3(0.0),S(dd,0.0));\n    \n    // progress\n    uv = prevUV;\n    uv-=selectedPos;\n    dd = abs(length(uv)-size)-0.003;\n    dd2 = abs(length(uv)-size)-0.003;\n    float deg = mod((ptime/interval*360.), 360.);\n    float r = radians(deg);\n    float cmask = dot(uv,vec2(cos(r),sin(r)));\n    \n    if(deg<180.){\n        dd = max(cmask,dd);\n        dd2 = max(-uv.x,dd2);\n        dd = min(dd,dd2);    \n    } else {\n        dd = max(cmask,dd);\n        dd = max(-uv.x,dd);\n    }\n    \n    col = mix(col, vec3(0.5,0.8,0.5),S(dd,0.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0.0, -10.);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(20.0));\n        ro.xz *= Rot(radians(sin(iTime*0.3)*60.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(0.8);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = mix(col,vec3(0.6),smoothstep(0.1, -0.5, uv.y));\n        uv.y-=iTime*0.2;\n        float ptd = voronoi(uv,7.0).w;\n        col = mix(col,vec3(0.9),S(ptd,-0.1));\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    // UI\n    uv = prevUV;\n    col = drawUI(uv,col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[758, 758, 794, 794, 836], [838, 896, 923, 923, 1053], [1055, 1113, 1156, 1156, 1255], [1257, 1315, 1346, 1346, 1437], [1439, 1497, 1530, 1530, 1599], [1601, 1659, 1729, 1729, 1869], [1871, 1929, 1965, 1965, 2248], [2250, 2362, 2387, 2387, 2726], [2728, 2728, 2746, 2746, 2852], [2854, 2854, 2889, 2889, 3561], [3563, 3563, 3591, 3591, 4181], [4183, 4183, 4210, 4210, 4297], [4299, 4299, 4322, 4322, 4466], [4468, 4468, 4499, 4499, 4745], [4747, 4747, 4769, 4769, 5508], [5510, 5681, 5704, 5704, 6200], [6202, 6202, 6224, 6224, 6451], [6453, 6453, 6511, 6511, 6778], [6780, 6780, 6804, 6804, 7005], [7007, 7007, 7049, 7049, 7244], [7246, 7287, 7336, 7336, 7630], [7632, 7632, 7689, 7689, 8303], [8305, 8305, 8332, 8332, 8416], [8418, 8418, 8442, 8442, 8513], [8515, 8515, 8554, 8554, 8599], [8601, 8601, 8660, 8660, 9974], [9976, 9976, 10007, 10007, 12503], [12505, 12505, 12562, 12562, 13587]]}
{"id": "NdyyDy", "name": "better mandelbrot zoom", "author": "Itay_milles", "description": "mandelbrot set zoom in with space shift and arrows", "tags": ["mandelbrot"], "likes": 1, "viewed": 203, "published": 3, "date": "1655458295", "time_retrieved": "2024-07-30T16:44:15.488742", "image_code": "#define MAX_ITR 1300\n#define THRESH 2.\n#define LIGHT_BLUE vec3(218.,112.,214.)/255.\n#define PURPLE vec3(75.,0.,130.)/255.\n#define BLACK vec3(0.)\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\nconst ivec2 SCREEN_COLOR_ADDR = ivec2(0, 0);\n\nvec2 DoubleMul( vec2 a, vec2 b )\n{\n\tvec2 c;\n\t// c = a*b\n\t// (c.y+c.x) = (a.x+a.y)*(b.x+b.y);\n\tc.y = a.y*b.y; // smallest part\n\tfloat l = a.x*b.x; // largest part\n\tfloat r = a.x*b.y + a.y*b.x; // part in-between.\n    c.x = l;\n    c.y += r;\n\treturn c;\n}\n\nvec2 complex_square(vec2 z)\n{\n    return vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y);\n}\n\nvec2 complex_cubic(vec2 z)\n{\n    float a = z.x;\n    float b = z.y;\n    return vec2(a*a*a-3.*a*b*b+b*a*a, 2.*a*a*b-b*b*b);\n}\n\nvec2 complex_sin(vec2 z)\n{\n    float a = z.x;\n    float b = z.y;\n    return vec2(sin(a)*cosh(b), cos(a)*sinh(b));\n}\n\nfloat mandal(vec2 c)\n{\n    vec2 z = vec2(0.);\n    int i = 0;\n    while (i < MAX_ITR && length(z) < THRESH)\n    {\n        z = complex_square(z) + c;\n        i++;\n    }\n    return float(i)/float(MAX_ITR);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 1.5*fragCoord/iResolution.xy - .5;\n    uv.x *= 1.7777777777777777777777777777778;\n    uv.x -= 1.;\n    uv.y -= 0.25;\n    \n    vec3 data = fetchData(iChannel0, SCREEN_COLOR_ADDR).xyz;\n    vec2 center = data.xy;\n    \n    float zoom = exp(-0.1*(data.z));\n    uv = center + (uv-center)*zoom;\n\n    float i = mandal(uv);\n    vec3 col = i > 0.95 ? vec3(0.): hsv2rgb(vec3(i, .8, exp(1./(60.*i + 1.8)*3.)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const ivec2 SCREEN_COLOR_ADDR = ivec2(0, 0);\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int LEFT  = 37;\nconst int UP    = 38;\nconst int RIGHT = 39;\nconst int DOWN  = 40;\nconst int SPACE = 32;\nconst int SHIFT = 16;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0); // Initial value\n    }\n\n    if (iFrame > 0) { // After initialization\n        if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n            fragColor = fetchData(iChannel0, SCREEN_COLOR_ADDR); // Load value from previous frame\n\n            // Update:\n            float stepsize = .1*exp(-0.1*fragColor.z);\n            fragColor.x += texelFetch(iChannel1, ivec2(LEFT, 0), 0).x*-stepsize;\n            fragColor.x += texelFetch(iChannel1, ivec2(RIGHT, 0), 0).x*stepsize;\n            fragColor.y += texelFetch(iChannel1, ivec2(UP, 0), 0).x*stepsize;\n            fragColor.y += texelFetch(iChannel1, ivec2(DOWN, 0), 0).x*-stepsize;\n            fragColor.z += 3.*exp(-0.02*fragColor.z)*texelFetch(iChannel1, ivec2(SPACE, 0), 0).x;\n            fragColor.z -= 3.*exp(-0.01*fragColor.z)*texelFetch(iChannel1, ivec2(SHIFT, 0), 0).x;\n            fragColor.z = max(fragColor.z, 0.);\n            }\n        }\n    }", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const ivec2 SCREEN_COLOR_ADDR = ivec2(0, 0);\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int LEFT  = 37;\nconst int UP    = 38;\nconst int RIGHT = 39;\nconst int DOWN  = 40;\nconst int SPACE = 32;\nconst int SHIFT = 16;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0); // Initial value\n    }\n\n    if (iFrame > 0) { // After initialization\n        if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n            fragColor = fetchData(iChannel0, SCREEN_COLOR_ADDR); // Load value from previous frame\n\n            // Update:\n            float stepsize = .1*exp(-0.1*fragColor.z);\n            fragColor.xy += texelFetch(iChannel1, ivec2(LEFT, 0), 0).x*-stepsize;\n            fragColor.xy += texelFetch(iChannel1, ivec2(RIGHT, 0), 0).x*stepsize;\n            fragColor.w += texelFetch(iChannel1, ivec2(UP, 0), 0).x*stepsize;\n            fragColor.w += texelFetch(iChannel1, ivec2(DOWN, 0), 0).x*-stepsize;\n            }\n        }\n    }", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyyDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[246, 246, 280, 280, 497], [499, 499, 528, 528, 578], [580, 580, 608, 608, 703], [705, 705, 731, 731, 820], [822, 822, 844, 844, 1026], [1028, 1028, 1050, 1050, 1381], [1383, 1383, 1405, 1405, 1574], [1576, 1576, 1633, 1683, 2153]]}
{"id": "NsycRy", "name": "Streamlined Hexagon Pixelizor", "author": "gehtsiegarnixan", "description": "streamlined Hexagonal Grid math to be as fast as possible. All commented useful for other stuff. Probably only for myself when I forget how to do it in half a year. ", "tags": ["pixel", "hexagon", "pattern", "tiling", "hex", "offset", "pixelizor"], "likes": 2, "viewed": 205, "published": 3, "date": "1655448288", "time_retrieved": "2024-07-30T16:44:16.235745", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define sqrt3 \t\t\t1.7320508076 //sqrt(3)\n#define half_sqrt3\t\t0.8660254038 //sqrt(3)/2\n\n// if you want flat tops (hex rotated by 30deg) swap xy in hr and the p.x to p.y in hexDist\nconst vec2 r = vec2(1, sqrt3); // 1, sqrt(3)\nconst vec2 h = vec2(0.5,half_sqrt3); // 1/2, sqrt(3) /2\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p) {\n\tp = abs(p);   \n    return max(dot(p, h), p.x);\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\nvec3 hexTile(vec2 uv) {\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b; //center hex UV coords\n    \n    // float edist = .5-hexDist(gv);  // Edge distance.\n    float edist = (.5-hexDist(gv))*2.; //  Edge distance with range 0-1\n    // float cdist = dot(gv, gv); // squared distance from the center.\n    // float cdist = dot(gv, gv)*3.; // squared distance with range 0-1\n    vec2 id = uv-gv; // simple ID calculation\n    \n    return vec3(id, edist); // xy hex coords + z distance to edge\n}\n\n// returns a pixelised hexagonal grid\nvec2 hexPixelizor(vec2 uv, float gridRes, vec2 offset){\n    vec2 scaledUV = uv * gridRes;\n    vec3 hex = hexTile(scaledUV + offset);\n    \n    return (hex.xy - offset)/gridRes; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 64.0; //Hex Grid Resolution\n    vec2 offset = vec2(sin(iTime) ,cos(iTime)); //circular motion\n    \n    vec2 uv = fragCoord.xy / iResolution.y; //square UV map   \n    \n    vec2 hexUV = hexPixelizor(uv, gridRes, offset);\n    \n    vec4 col = texture(iChannel0, hexUV.xy);\n    fragColor = vec4(col);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsycRy.jpg", "access": "api", "license": "mit", "functions": [[1361, 1407, 1430, 1430, 1480], [1482, 1556, 1579, 1579, 2102], [2104, 2142, 2197, 2197, 2320], [2322, 2322, 2379, 2379, 2697]]}
{"id": "fsGcWG", "name": "Shimmering emeralds", "author": "jarble", "description": "A glowing gem fractal.", "tags": ["fractal", "emerald"], "likes": 2, "viewed": 219, "published": 3, "date": "1655438453", "time_retrieved": "2024-07-30T16:44:16.976764", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/12.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<2;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 7; k++){\n            uv += (t2.yx)/scale*sign(uv.y-uv.x);\n            uv.x -= float(k-i);\n            //uv.x -= float(k-i)*floor(uv.x);\n            t2 = triangle_wave(uv.yx-1.5,scale);\n            t3 = triangle_wave(uv,scale);\n            uv.yx = (t2-t3)/(scale);\n            vec2 uv1 = uv + triangle_wave((uv.yx+iTime/2.)*2.,scale)/16.;\n        col.x = min(((uv1.x-uv1.y)),col.x)/sqrt(3.);\n        col = (col+vec3(col.x)).yzx/sqrt(3.);\n        }\n        \n    }\n    fragColor = vec4(-vec3(col*4.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGcWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 1035]]}
{"id": "NdGczc", "name": "kings dream", "author": "mAmaro", "description": "Was reading Chaos in Wonderland so I wanted to write a shader that draws a strange attractor like the Basic program does in the book.\n\nyou might need to pause and reset for it to work.", "tags": ["fractal", "attractors", "kingsdream"], "likes": 1, "viewed": 224, "published": 3, "date": "1655436971", "time_retrieved": "2024-07-30T16:44:17.782610", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord -iResolution.xy)/iResolution.y;\n    uv*=iTime;\n    vec4 tex  = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    #if 1\n    uv = vec2(atan(uv.x, uv.y), length(uv));\n    tex.r *= 0.5+0.2*sin(iTime+uv.x);\n    tex.g *= 0.5+0.2*cos(iTime-uv.y/uv.x);\n    #endif\n    fragColor = tex;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 Clifford(vec2 pos, vec2 consts)\n{\n    //a:r b:g c:b d:a\n    return vec2(sin(pos.x*pos.y/consts.g)*pos.y+cos(consts.r*pos.x-pos.y),\n                pos.x+sin(pos.y)/consts.g);\n}\n\nvec2 FractalDream(vec2 pos, vec4 consts)\n{\n    //a:r b:g c:b d:a\n    return vec2(sin(pos.y*consts.g) + consts.b*sin(pos.x*consts.g),\n                sin(pos.x*consts.r) + consts.a*sin(pos.y*consts.r));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    uv.x *= 1.86;\n    uv.y *= 1.51;\n    uv *= 0.5;\n    vec4 pos = vec4(uv, 1.0, 1.0);\n    float t = GetClock(iTime); // Allow 10.0 seconds before recomputing points\n    vec4 consts;\n    float Id = GetClockResetCount(iTime);\n    if(ShouldChangeInitialConditions(iTime))\n    {\n        consts.r = 3.0*Noise2(vec2(124.4,Id*Id)).x;\n        consts.g = 3.0*Noise2(vec2(Id*Id,uv.x*Id)).y;\n        consts.b = 3.0*Noise2(vec2(0.035235,Id)).x;\n        consts.a = 3.0*Noise2(vec2(mod(Id, 3.0)*0.124, sin(Id))).y;\n    }\n    else\n    {\n        consts.r = -0.966918;\n        consts.g =  2.879879;\n        consts.b =  0.765145;\n        consts.a =  0.744728;\n    }\n    // Only start the iterated function after 1 second elapses\n    if(t > 1.0)\n    {\n        // Overwrite the assumes init condision with result of functions\n        // previous run\n        pos = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        // Stop trying to compute points for the attractor after some time\n        // passes\n        if(t < MaxRenderTime)\n        {\n            vec2 tmp = pos.xy;\n            tmp = mod(Id, 5.0)<3.0?FractalDream(tmp, consts):Clifford(tmp, consts.rg/3.0);\n            pos = vec4(tmp, 1.0, 1.0);\n        }\n    }\n    fragColor = pos;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    uv.x *= 1.86;\n    uv.y *= 1.51;\n    //uv /= iTime*0.2;\n    //uv += fract(iTime*0.2);\n    float t = GetClock(iTime); // Allow 10.0 seconds before recomputing points\n    vec4 tex  = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 col = vec4(0.0);\n    float tolerance = 0.1;\n    float Valid = smoothstep(0.0, tolerance, length(uv-tex.xy))*\n                  smoothstep(0.0, tolerance, length(uv-tex.xy));\n    vec2 Attractor = vec2(Valid); //[0]\n    float Dot = smoothstep(0.1, 0.0, length(Attractor));\n    col = vec4(vec2(Dot), Dot, 1.0);\n    \n    vec4 canvas = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    #if 0\n    float dt = iTimeDelta;\n            float acc = 3.0;\n            float speed = 1.3;\n            vec2 oldvel = pos.zw;\n            vec2 newvel = acc*dt + mix(oldvel, speed*normalize(pos.xy-tmp), 0.5);\n            tmp = newvel*dt + 0.5*acc*dt*dt + tmp.xy;\n    #endif\n    fragColor = (t<1.0)?col:(col+canvas);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Percentage of the total clock cycle time deicated to rendering\n#define ClockCycleTime 10.0\n#define RenderTime     00.8\n#define MaxRenderTime  ClockCycleTime*RenderTime\n\nfloat GetClock(float Time)\n{\n    return mod(Time, ClockCycleTime);\n}\n\nfloat GetClockResetCount(float Time)\n{\n    return floor(Time/ClockCycleTime);\n}\n\nbool ShouldRender(float Time)\n{\n    return (Time<(ClockCycleTime*RenderTime));\n}\n\nbool ShouldChangeInitialConditions(float Time)\n{\n    float KingsCycle = mod(GetClockResetCount(Time), 5.0);\n    bool IsFirstReset = (KingsCycle<1.0);\n    return IsFirstReset==false;\n}\n\nvec2 Noise2(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\n//NOTE: Not so very code replaced by [0]\n#if 0\n\nbool F32Equals(float val, float expected, float epsilon)\n{\n    \n   return ((expected-epsilon*0.5) <= val) && (val <= (expected+epsilon*0.5));\n}\n\nif(F32Equals(tex.x, uv.x, 0.07) &&\n   F32Equals(tex.y, uv.y, 0.07) )\n{\n    //float Dot = smoothstep(0.20, 1.0, 0.1+0.2*0.5+0.5*sin(iTime)*length(tex.xy));\n    //col = vec4(tex.xy, Dot, col.w);\n}\n#endif", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 363]]}
{"id": "7dVyRt", "name": "Test Card F", "author": "mla", "description": "BBC Test Card F. A composition of two separate images, outer frame is 16 color RLE, inner image is 256 color unencoded.\n\n[url]https://en.wikipedia.org/wiki/Test_Card_F[/url]", "tags": ["rle", "testcard", "runlengthencoding", "bubblestheclown", "carolehersee"], "likes": 20, "viewed": 509, "published": 3, "date": "1655421703", "time_retrieved": "2024-07-30T16:44:19.726412", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// BBC Test Card F. mla, 2022\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float WIDTH0 = 365.0;\nconst float HEIGHT0 = 273.0;\n\nconst float WIDTH1 = 155.0;\nconst float HEIGHT1 = 152.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.y;\n  uv.y = 1.0-uv.y;\n  uv.x -= 0.5*iResolution.x/iResolution.y*(1.0-HEIGHT0/WIDTH0);\n  uv.x += 0.0004*sin(100.0*uv.y+10.0*iTime);\n  vec2 centre = 0.5*vec2(WIDTH0/HEIGHT0,1.0)+vec2(0.003,0.003);\n  vec3 col;\n  if (uv.x < 0.0 || uv.x > iResolution.x/iResolution.y*HEIGHT0/WIDTH0) {\n    col = vec3(0);\n  } else if (length(uv-centre)<0.265) {\n    uv -= centre;\n    uv *= 1.78;\n    uv += 0.5;\n    uv += vec2(0.015,0.005);\n    uv *= HEIGHT1/iResolution.xy;\n    col = texture(iChannel1,uv).rgb;\n  } else {\n    uv *= HEIGHT0/iResolution.xy;\n    col = texture(iChannel0,uv).rgb;\n  }\n  col *= 1.2; // A little more saturation\n  float line = fragCoord.y/ceil(iResolution.y/400.0);\n  if (int(line)%2 == 0) {\n    col *= 0.8+0.1*float(ihash(uint(30.0*iTime+line)))/exp2(32.0);\n  }\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29145, "src": "https://soundcloud.com/transdiffusion/bbctv-start-up-time-beat-by-ray-cathode-maddalena-fagandini-and-george-martin-1962", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "const uvec4 data[] = uvec4[](\nuvec4(0x1241f100u,0x2263f3f3u,0xf4f41200u,0xf5841024u),\nuvec4(0xf71695f5u,0x67f70057u,0x07a8f8f8u,0xcafafa09u),\nuvec4(0xbcfcfc0bu,0x41f1000du,0xf1000e06u,0xf3020031u),\nuvec4(0xf44283f3u,0xf5f5c4f4u,0xf71604a5u,0x67f71037u),\nuvec4(0x07a8f8f8u,0xcafafa09u,0xbcfcfc0bu,0x41f1000du),\nuvec4(0xf1000e06u,0xf3f30231u,0xf4f422a3u,0xb5f5f5c4u),\nuvec4(0x37f71604u,0xf7000100u,0xb8f8f847u,0xcafafa17u),\nuvec4(0xbcfcfc0bu,0x41f1000du,0xf1000e06u,0xf3f30231u),\nuvec4(0xf4f412b3u,0xb5f5f5c4u,0x27f71604u,0x47f72100u),\nuvec4(0x17b8f8f8u,0x0bcafafau,0x0dbcfcfcu,0x0641f100u),\nuvec4(0x31f1000eu,0xb3f3f302u,0xb4f4f422u,0x16b5f5f5u),\nuvec4(0x003137f7u,0xf8f847f7u,0xfafa17a8u,0xfcfc0bcau),\nuvec4(0xf1000dbcu,0x000e0641u,0xf30231f1u,0xf422b3f3u),\nuvec4(0xf5f5b4f4u,0x27f716b5u,0x47f74100u,0x17a8f8f8u),\nuvec4(0x0bcafafau,0x0dbcfcfcu,0x0641f100u,0x21f1000eu),\nuvec4(0xf3f30200u,0xf4f412b3u,0xa5f5f5d4u,0x0027f716u),\nuvec4(0x27f70041u,0x17b8f8f8u,0x0bcafafau,0x0dbcfcfcu),\nuvec4(0x0641f100u,0x21f1000eu,0xc3f3f300u,0xd4f4f412u),\nuvec4(0x04a5f5f5u,0x0017f706u,0xf827f761u,0xfa17b8f8u),\nuvec4(0xfc0bcafau,0x000dbcfcu,0x0e0641f1u,0x0021f100u),\nuvec4(0x12c3f3f3u,0xf5c4f4f4u,0x0604b5f5u,0x710007f7u),\nuvec4(0xf817f700u,0xfa27a8f8u,0xfc0bcafau,0x0009bcfcu),\nuvec4(0x0b0641f1u,0x0231f100u,0x12b3f3f3u,0xf5c4f4f4u),\nuvec4(0x0604b5f5u,0x810007f7u,0xf807f700u,0xfa17b8f8u),\nuvec4(0xfc0bcafau,0x000dbcfcu,0x0b0641f1u,0x0021f100u),\nuvec4(0xb3f3f302u,0xc4f4f412u,0x04b5f5f5u,0xf7a1f716u),\nuvec4(0xb8f8f807u,0xcafafa17u,0xbcfcfc0bu,0x41f1000du),\nuvec4(0xf1000b06u,0xf3f30031u,0xf4f422b3u,0xb5f5f5b4u),\nuvec4(0x00e71604u,0xf8f700a1u,0xfa17b8f8u,0xfc0bcafau),\nuvec4(0x0009bcfcu,0x0e0641f1u,0x01300100u,0xf3027150u),\nuvec4(0xf432a3f3u,0xf5f5b4f4u,0xd71604b5u,0xe706c100u),\nuvec4(0x07b8f8f8u,0xcafafa09u,0xbcfcfc0bu,0x00810009u),\nuvec4(0x0b090091u,0x005100c9u,0x83f3f312u,0x00143042u),\nuvec4(0x3564f4f4u,0x1465f534u,0x20125415u,0x10c13097u),\nuvec4(0x170607f7u,0xf6f6f8f8u,0xf9f946f6u,0x610006c9u),\nuvec4(0x0db90600u,0x0b0c8b0cu,0x71000e0cu,0x01301200u),\nuvec4(0x12002200u,0x7210b210u,0x71001100u,0x70f01100u),\nuvec4(0x10016041u,0x00c23032u,0x30022082u,0xf1f11012u),\nuvec4(0x10a10031u,0x201110f1u,0x10319001u,0xf1f1f1f1u),\nuvec4(0x10312061u,0x00210011u,0x00110001u,0xac0d0681u),\nuvec4(0x0bbc1c0bu,0x11202100u,0x11400200u,0x31000200u),\nuvec4(0x21100210u,0xf0f04280u,0xa0f021b0u,0x1150f011u),\nuvec4(0x11101100u,0x100110f0u,0xf0110011u,0x01c031e0u),\nuvec4(0x31102170u,0xf001b0f0u,0x611041a0u,0x11102110u),\nuvec4(0x31102110u,0xbcdc0e06u,0x0001060bu,0x0d090001u),\nuvec4(0x0d060106u,0x0d091009u,0x0d060106u,0x00210009u),\nuvec4(0x11002906u,0x3619f902u,0x0e090619u,0x061d0106u),\nuvec4(0x190619f9u,0x00061906u,0x36190611u,0x002906f9u),\nuvec4(0x36190211u,0x0e0946d9u,0x091d0106u,0xb9062906u),\nuvec4(0x09060936u,0x0601090du,0x1906090eu,0x06f62916u),\nuvec4(0x29021100u,0x090629d6u,0x11060926u,0xf9161900u),\nuvec4(0x090d1639u,0x090e0601u,0x49061906u,0x19067936u),\nuvec4(0x06110006u,0x31000619u,0x01061900u,0x10090d06u),\nuvec4(0x01060d09u,0x00090d06u,0xdc0e0021u,0x0009ad0bu),\nuvec4(0x0d260001u,0x0900060eu,0x0600090bu,0x00060d0eu),\nuvec4(0x000d0e09u,0x19060021u,0xf9061102u,0x060b0d89u),\nuvec4(0xf90b0e00u,0x00010099u,0x1102a9f9u,0x0b99f906u),\nuvec4(0x0b0d0109u,0x0d0b89f9u,0x0d0b0900u,0x110689f9u),\nuvec4(0x0699f906u,0x99f90011u,0x09000d0bu,0x89f90d0bu),\nuvec4(0x19061102u,0x09003102u,0x0600090eu,0x02060d0eu),\nuvec4(0x00090e09u,0x11261d06u,0xb8dc0b06u,0x00010009u),\nuvec4(0x061d1619u,0x090e0900u,0x061d0602u,0x0d0b0902u),\nuvec4(0x06002100u,0x06110609u,0x0b0d89f9u,0x0b0d0106u),\nuvec4(0x110099f9u,0x1102a9f9u,0x0b99f906u,0x0b0d0109u),\nuvec4(0x0d0c89f9u,0x0d0c0601u,0x110289f9u,0x0699f906u),\nuvec4(0x99f90011u,0x06000d0bu,0x89f90d0bu,0x09061106u),\nuvec4(0x00111006u,0x02090b09u,0x00061d06u,0x02090d09u),\nuvec4(0x02061d06u,0x06010019u,0x00c8dc0eu,0x091d0001u),\nuvec4(0x061d0602u,0x090e0902u,0x061d0600u,0x0d0b0900u),\nuvec4(0x06002100u,0xf9061102u,0x01090b99u,0x99f90e0du),\nuvec4(0xa9f91100u,0xf9021102u,0x01090c99u,0x89f90b0du),\nuvec4(0x06010d0bu,0x0299f90cu,0x99f90611u,0xf9001106u),\nuvec4(0x010d0b99u,0xf90d0b06u,0x02110689u,0x00210006u),\nuvec4(0x00090e09u,0x060d0e06u,0x090b0900u,0x061d0600u),\nuvec4(0x090d0900u,0x0d000100u,0x0100c8dcu,0x0d090600u),\nuvec4(0x0d060009u,0x0900060eu,0x0602090bu,0x0900091du),\nuvec4(0x21000d0bu,0xf9061110u,0x01090c99u,0x99f90e0du),\nuvec4(0xa9f91100u,0xf9061102u,0x01090c99u,0x89f90b0du),\nuvec4(0x06010d0bu,0x0699f90cu,0x99f90611u,0xf9001106u),\nuvec4(0x000d0b99u,0xf90d0b06u,0x10110689u,0x0b090021u),\nuvec4(0x0d060009u,0x0900060eu,0x0602090bu,0x00060e0du),\nuvec4(0x06090e09u,0xdc0d0011u,0x100100c8u,0x090d0906u),\nuvec4(0x061d0602u,0x090e0902u,0x091d0600u,0x090e0900u),\nuvec4(0xf9065102u,0x01060b99u,0x99f90b0du,0xf9061100u),\nuvec4(0x02110299u,0x090c99f9u,0xf90b0d01u,0x010e0b89u),\nuvec4(0x99f90b06u,0xf9061102u,0x00110699u,0x0d0b99f9u),\nuvec4(0x0d0b0601u,0x510689f9u,0x090e0d00u,0x0d0e0600u),\nuvec4(0x0b090006u,0x0d060009u,0x0900060eu,0x0006090bu),\nuvec4(0xdc0e0011u,0x000100c8u,0x09020609u,0x0602090eu),\nuvec4(0x0900061du,0x0600090bu,0x00090e0du,0x000d0e09u),\nuvec4(0x89f90641u,0x01060b0du,0x99f90b0du,0xa9f91100u),\nuvec4(0xf9061102u,0x01090c99u,0x89f90b0du,0x06010e0bu),\nuvec4(0x89f90d0cu,0xf9061102u,0x00110699u,0x0d0b99f9u),\nuvec4(0x0d0b0600u,0x410289f9u,0x090e0900u,0x061d0600u),\nuvec4(0x090e0902u,0x0e0d0600u,0x0e090209u,0x0016020du),\nuvec4(0xdc0e0001u,0x020100c8u,0x0900061du,0x0600090bu),\nuvec4(0x0900061du,0x0600090bu,0x0900061du,0x31000d0bu),\nuvec4(0x0d89f906u,0x0d01060bu,0x0099f90eu,0x02a9f911u),\nuvec4(0x99f90211u,0x0d01090cu,0x0b89f90bu,0x0b06010du),\nuvec4(0x110299f9u,0x0699f906u,0x99f90011u,0x06010d0bu),\nuvec4(0x89f90d0bu,0x09003100u,0x0600090eu,0x00020d0eu),\nuvec4(0x00090b09u,0x00061e06u,0x02090b09u,0x01001d06u),\nuvec4(0xc8dc0b02u,0x09000100u,0x0d120d0eu,0x0600090eu),\nuvec4(0x00060e0du,0x00090e09u,0x00061d06u,0x00090b09u),\nuvec4(0xf9060221u,0x060c0d79u,0xf90e0d01u,0xf9110099u),\nuvec4(0x061102a9u,0x060b99f9u,0xf90b0d01u,0x010d0b89u),\nuvec4(0xf90d0b09u,0x06110289u,0x110699f9u,0x0b99f900u),\nuvec4(0x0b06010du,0x310689f9u,0x090e0d00u,0x0d0e0600u),\nuvec4(0x090e0912u,0x061d0600u,0x090b0900u,0x091d0600u),\nuvec4(0xdc0e0211u,0x092100c8u,0x00060d0eu,0x00090b09u),\nuvec4(0x02061d06u,0x00090b09u,0x00061e06u,0x000d0e09u),\nuvec4(0xf9060021u,0x060b0d69u,0xf90e0d01u,0xf9110099u),\nuvec4(0x061102a9u,0x0c0d89f9u,0x0b0d0109u,0x0d0c89f9u),\nuvec4(0xf90b0901u,0x06110299u,0x110699f9u,0x0b99f900u),\nuvec4(0x0b09010du,0x000679f9u,0x0e0d0221u,0x0e090009u),\nuvec4(0x09000209u,0x0600090bu,0x0900061du,0x0602090bu),\nuvec4(0x1100061du,0xc8dc0b02u,0x06101100u,0x09120d0eu),\nuvec4(0x0600090bu,0x00020d0eu,0x00090b09u,0x060e0d06u),\nuvec4(0x090b0900u,0xf9063100u,0x060b0d59u,0x99f91e01u),\nuvec4(0xa9f91100u,0xf9061100u,0x060c0d89u,0xf90b0d01u),\nuvec4(0x010d0b89u,0x99f90b09u,0xf9061100u,0x00110699u),\nuvec4(0x0d0b99f9u,0x0d0b0901u,0x310259f9u,0x090d0902u),\nuvec4(0x161d0600u,0x0602091du,0x00060d0eu,0x16090d09u),\nuvec4(0x1002091du,0x0dc90201u,0x0100c80bu,0x00090d00u),\nuvec4(0x020d0b06u,0x090b0900u,0x0d0e0600u,0x0b090006u),\nuvec4(0x0d060009u,0x0900060eu,0x2100090bu,0x49f90600u),\nuvec4(0x01060b0du,0x0099f91eu,0x00a9f911u,0x89f90611u),\nuvec4(0x01060c0du,0x89f90b0eu,0x09010d0bu,0x0299f90cu),\nuvec4(0x99f90611u,0xf9001106u,0x010d0b99u,0xf90d0b09u),\nuvec4(0x06310249u,0x0900091du,0x02060d0eu,0x02090e09u),\nuvec4(0x00061d06u,0x02090e09u,0x02091d06u,0x22110019u),\nuvec4(0x0b095233u,0x000100c8u,0x00090e0du,0x020d0b09u),\nuvec4(0x090b0d00u,0x061e0600u,0x090b0900u,0x0b0e0200u),\nuvec4(0x0b090006u,0x00010009u,0xf9060001u,0x060b0d39u),\nuvec4(0x99f91e01u,0xf9000100u,0x061100a9u,0x0c0d89f9u),\nuvec4(0x0b0e0106u,0x0d0b89f9u,0xf90b0901u,0x06110099u),\nuvec4(0x110699f9u,0x0b99f900u,0x0b09010du,0x000249f9u),\nuvec4(0x0e0d0021u,0x1d090009u,0x090d0912u,0x021d0602u),\nuvec4(0x090d0900u,0x09161d16u,0x12100d0eu,0x0b0902a3u),\nuvec4(0x000100c8u,0x090e0d06u,0x0d0b0900u,0x0b090006u),\nuvec4(0x1e060009u,0x0b090002u,0x0e060009u,0x0900060bu),\nuvec4(0x21000d0bu,0x29f90600u,0x01060b0du,0x0099f91eu),\nuvec4(0xa9f90001u,0xf9061100u,0x060c0d89u,0xf90b0e01u),\nuvec4(0x010d0b89u,0x99f90b09u,0xf9061102u,0x00110699u),\nuvec4(0x0d0b99f9u,0xf90b0901u,0x21000239u,0x00091d06u),\nuvec4(0x16090d09u,0x02090e0du,0x09161d06u,0x0600090eu),\nuvec4(0x02090e0du,0x06090d09u,0x09d30201u,0x2100c80bu),\nuvec4(0x060e0d06u,0x0d0b0900u,0x0b0d0200u,0x0e060009u),\nuvec4(0x0900060du,0x0200090bu,0x00060e0du,0x000d0e09u),\nuvec4(0xf9060021u,0x060b0d19u,0x99f91e01u,0xa9f90011u),\nuvec4(0xf9061100u,0x060c0d89u,0xf90b0e01u,0x010d0b89u),\nuvec4(0x99f90c09u,0xf9061102u,0x00110699u,0x0d0b99f9u),\nuvec4(0xf90b0901u,0x00020619u,0x0e0d0221u,0x0b090209u),\nuvec4(0x0d020609u,0x0600090eu,0x00060e0du,0x00090e0du),\nuvec4(0x060e0d06u,0x090e0902u,0x02010206u,0xc80b09d3u),\nuvec4(0x06000100u,0x060b0d10u,0x0d0e0600u,0x090b0d10u),\nuvec4(0x061b0601u,0x0d0b0900u,0x0b0e0200u,0x0b090006u),\nuvec4(0x0021000du,0x0d09f906u,0x1e01060bu,0x001199f9u),\nuvec4(0x220659f9u,0x00110006u,0x02160216u,0x090216f6u),\nuvec4(0x1d01060bu,0x060266f6u,0x09010d0eu,0xf602060eu),\nuvec4(0x00110076u,0x0649f946u,0x99f90011u,0x09010d0bu),\nuvec4(0x0219f90bu,0x091d0631u,0x0d0e0600u,0x0e090600u),\nuvec4(0x0e090009u,0x0900060du,0x0602090eu,0x0902061du),\nuvec4(0x1226090eu,0xc80b09d3u,0x1d000100u,0x090b0d10u),\nuvec4(0x0d0e0601u,0x0b090002u,0x1e060009u,0x0b090006u),\nuvec4(0x0d06000du,0x0901060bu,0x21000d0bu,0x0df90600u),\nuvec4(0x1e01060bu,0x010099f9u,0x0059f900u,0x0201f1f1u),\nuvec4(0x0d01060eu,0x0d81f109u,0x0d090109u,0x01f1f100u),\nuvec4(0x0649f900u,0x99f90011u,0x09010d0bu,0x02f90d0bu),\nuvec4(0x0e0d0231u,0x0e090009u,0x0d00020du,0x0600090bu),\nuvec4(0x00060d0eu,0x00090b09u,0x060d0e06u,0x090e0900u),\nuvec4(0x121d0602u,0xc80b09d3u,0x09000100u,0x0206090du),\nuvec4(0x00090e0du,0x060d0b09u,0x090b0900u,0x0d0e0600u),\nuvec4(0x0b090006u,0x0d060009u,0x0900090bu,0x21000d0bu),\nuvec4(0x0b0df900u,0x0b0e0106u,0x010099f9u,0x0059f900u),\nuvec4(0x0001f1f1u,0x0d01060du,0x1d81f109u,0x000b0901u),\nuvec4(0x0001f1f1u,0x110649f9u,0x0b99f900u,0x0b09010du),\nuvec4(0x3102e90du,0x090e0d00u,0x090e0900u,0x0e0d0002u),\nuvec4(0x0e090009u,0x0b09120du,0x1d090009u,0x0b090006u),\nuvec4(0x0d060209u,0xd312090eu,0x00c80b09u,0x0e090011u),\nuvec4(0x0d060009u,0x0600090bu,0x0900061eu,0x0600090bu),\nuvec4(0x00060b0du,0x100d0b09u,0x00060b0eu,0x000d0b09u),\nuvec4(0xd9060021u,0x01060c0du,0x99f90b0eu,0xf9000100u),\nuvec4(0x11f1f159u,0x01060e02u,0x81f1090du,0x0b09011du),\nuvec4(0x01f1f100u,0x0649f900u,0x99f90011u,0x09010d0bu),\nuvec4(0x02d90d0bu,0x0e0d0631u,0x0e060009u,0x0b0d120du),\nuvec4(0x1e060009u,0x0d090206u,0x0e060009u,0x0900060du),\nuvec4(0x06020d0eu,0x02090e0du,0x09d30001u,0x2100c80bu),\nuvec4(0x090e0900u,0x090b0d10u,0x0d0b0600u,0x0b090002u),\nuvec4(0x0d060009u,0x0900060eu,0x0200090bu,0x00060b0eu),\nuvec4(0x000d0b09u,0xc9060021u,0x01060c0du,0x99f90b0eu),\nuvec4(0xf9000100u,0x11f1f159u,0x01060e00u,0x81f1090du),\nuvec4(0x09010d09u,0xf1f1000du,0x49f90001u,0xf9001106u),\nuvec4(0x010d0b99u,0xc90d0b09u,0x0d063102u,0x0900060bu),\nuvec4(0x0d120d0eu,0x0900060bu,0x00060d0eu,0x02090e09u),\nuvec4(0x02061d06u,0x00090e09u,0x00091e06u,0x09d30211u),\nuvec4(0x3100c80bu,0x090e0900u,0x090b0d10u,0x061d0600u),\nuvec4(0x090b0d00u,0x0b0e0200u,0x0b090006u,0x0d02000du),\nuvec4(0x0601090eu,0x01000d0bu,0xb9061100u,0x01060c0du),\nuvec4(0x99f90b0eu,0xf9000100u,0x00f1f159u,0x060e0001u),\nuvec4(0xf10d0e01u,0x09011d81u,0xf1f1000eu,0x49f90001u),\nuvec4(0xf9001106u,0x010d0b99u,0x06b90b09u,0x06210002u),\nuvec4(0x00060e0du,0x000d0b09u,0x090e0d02u,0x021d0900u),\nuvec4(0x090e0d00u,0x0d0e0602u,0x0e090206u,0x1d060009u),\nuvec4(0x00110009u,0x0b09d302u,0x004100c8u,0x100d0b09u),\nuvec4(0x00090b0du,0x020d0b06u,0x090b0900u,0x0b0d0600u),\nuvec4(0x0b090006u,0x0e02000du,0x0901060bu,0x21000d0bu),\nuvec4(0x0da90600u,0x0e01060cu,0x0099f90bu,0x49f90001u),\nuvec4(0x11f1f106u,0x01060d00u,0x81f1090du,0x0901090du),\nuvec4(0x11f1f10eu,0x0649f900u,0x99f90011u,0x09010d0bu),\nuvec4(0x0006a90bu,0x061d0631u,0x090e0900u,0x060e0d16u),\nuvec4(0x090d0900u,0x090e0d16u,0x061d0600u,0x090e0900u),\nuvec4(0x091d0602u,0xd3102100u,0x00c80b09u,0x00112001u),\nuvec4(0x000d0e09u,0x090b0d02u,0x101e0900u,0x00090b0du),\nuvec4(0x100e0b06u,0x00090c09u,0x090b0d02u,0x0d0b0901u),\nuvec4(0x06002100u,0x060b0d99u,0x99f91e01u,0xf9000100u),\nuvec4(0x21f10649u,0x86090600u,0x0b091609u,0x0d0b0609u),\nuvec4(0x0b1966f6u,0x0b0d060eu,0x0609b609u,0x0011f100u),\nuvec4(0x110649f9u,0x0b99f900u,0x0b09010du,0x21020699u),\nuvec4(0x061d0600u,0x090e0902u,0x091d0602u,0x090d0902u),\nuvec4(0x090e0d16u,0x0d0e0900u,0x0e090206u,0x1d060209u),\nuvec4(0x10110006u,0x09d30001u,0x0100c80bu,0x31020900u),\nuvec4(0x100d0b09u,0x01090b0du,0x000e0b06u,0x090c0d01u),\nuvec4(0x061b0201u,0x090c0900u,0x0b0e0001u,0x0b090006u),\nuvec4(0x0001000du,0x0d990001u,0x0b01060bu,0x0099f90eu),\nuvec4(0x49f90001u,0x0621f106u,0x0cab0c0eu,0x1c0b1c0bu),\nuvec4(0x4bfb0c2bu,0x7b2c0b1cu,0x0d1c1b0cu,0x0011f106u),\nuvec4(0x110649f9u,0x0b99f900u,0x0b09000du,0x06310299u),\nuvec4(0x0900091du,0x0d16090eu,0x0900090eu,0x0916090eu),\nuvec4(0x0602090eu,0x0900061du,0x0902090bu,0x1100091du),\nuvec4(0xd3121602u,0x0da80c09u,0x00010009u,0x00210019u),\nuvec4(0x10090b09u,0x01090c0du,0x100d0b06u,0x01090c0du),\nuvec4(0x01061b06u,0x00090c09u,0x060b0e02u,0x0d0b0901u),\nuvec4(0x0d893100u,0x1e00060cu,0x001199f9u,0x000649f9u),\nuvec4(0x0b0911f1u,0xfcfcfcfcu,0x0011f106u,0x110649f9u),\nuvec4(0x0b99f902u,0x0b090009u,0x00020679u,0x0d0e0621u),\nuvec4(0x0e090206u,0x0d060009u,0x0900060eu,0x06020d0eu),\nuvec4(0x00090d09u,0x060d0e09u,0x090e0902u,0x091d0600u),\nuvec4(0x06021100u,0xd3120609u,0x7b3c0b09u,0x0001000du),\nuvec4(0x00090d09u,0x0b090021u,0x0e0d100du,0x0b090109u),\nuvec4(0x0901000eu,0x0600090cu,0x00060e0bu,0x01090c09u),\nuvec4(0x090b0e00u,0x0d0b0901u,0x69063100u,0x00020b0du),\nuvec4(0x0099f91eu,0x49f90001u,0x0921f106u,0xfcfcfc0bu),\nuvec4(0x11f106fcu,0x0649f900u,0x99f90011u,0x09000d0bu),\nuvec4(0x0006690bu,0x0d0e0631u,0x0e090006u,0x0d060209u),\nuvec4(0x0900060eu,0x0d06021du,0x0902090eu,0x0e09161du),\nuvec4(0x1d090209u,0x00110006u,0x12061906u,0xbc0b09d3u),\nuvec4(0x0001000bu,0x09310239u,0x02000d0bu,0x00090b0du),\nuvec4(0x100e0b06u,0x01090c0du,0x01061b06u,0x100d0b09u),\nuvec4(0x01060b0eu,0x000d0c09u,0x59060021u,0x00020b0du),\nuvec4(0x99f90b0eu,0x49f90011u,0x0921f106u,0xfcfcfc0bu),\nuvec4(0x11f106fcu,0x0649f900u,0x99f90211u,0x0901090bu),\nuvec4(0x06490d0cu,0x1e063102u,0x0e090206u,0x1d060009u),\nuvec4(0x0e090009u,0x0d09160du,0x0e090209u,0x0e09160du),\nuvec4(0x1d060209u,0x00110006u,0x12062906u,0xbc0b09d3u),\nuvec4(0x0001000bu,0x06091609u,0x11000100u,0x000d0b09u),\nuvec4(0x090b0d02u,0x0e0b0601u,0x0c090002u,0x1b020109u),\nuvec4(0x0b090106u,0x0b0e100du,0x0c090109u,0x0021000du),\nuvec4(0x09162906u,0x0e00060bu,0x7689060du,0x06091609u),\nuvec4(0x00110619u,0x09060906u,0x09765916u,0x0921f106u),\nuvec4(0xfcfcfc0bu,0x11f106fcu,0x06090600u,0x061916b9u),\nuvec4(0x00110609u,0x06f62906u,0x0b092609u,0x0b09010du),\nuvec4(0x06290609u,0x0d063100u,0x0900060eu,0x0600090bu),\nuvec4(0x00060e0du,0x16090e09u,0x00090e0du,0x02061d09u),\nuvec4(0x00090e09u,0x00061d09u,0x29060021u,0x02b32206u),\nuvec4(0x0bbc0b09u,0x01001102u,0x0b095120u,0x0b0d100du),\nuvec4(0x0b060109u,0x0901020eu,0x0200090bu,0x00060b0eu),\nuvec4(0x100d0b09u,0x01090b0du,0x000e0c09u,0x06212021u),\nuvec4(0x0e01020bu,0xf1000109u,0x10010021u,0x10010041u),\nuvec4(0x10813011u,0x0b0921f1u,0xfcfcfcfcu,0x1021f106u),\nuvec4(0x00712001u,0x00110011u,0x01f10061u,0x01000100u),\nuvec4(0x01090d00u,0x01020d09u,0x21100100u,0x0e0d0600u),\nuvec4(0x0e090006u,0x0d060009u,0x0902060eu,0x06000d0eu),\nuvec4(0x00090b0du,0x060d0e06u,0x090e0900u,0x091d0600u),\nuvec4(0x02204100u,0x09060220u,0x0b0d2973u,0xd1020ebcu),\nuvec4(0x100d0b09u,0x01090b0du,0x060e0b06u,0x090b0901u),\nuvec4(0x060b0e10u,0x0d0b0900u,0x090c0d10u,0x0d0b0601u),\nuvec4(0x0b067100u,0x090e0102u,0xf1f1f1f1u,0xfc0b0951u),\nuvec4(0x06fcfcfcu,0xf1f1f1f1u,0x01090d51u,0x71000d09u),\nuvec4(0x00061d06u,0x00090b09u,0x060e0d06u,0x090b0900u),\nuvec4(0x0e0d0602u,0x0e060009u,0x0902060du,0x0600090bu),\nuvec4(0xc100061du,0x1cbb0d06u,0x01020bbcu,0x31027600u),\nuvec4(0x100d0e09u,0x00090b0du,0x00021b06u,0x00090b09u),\nuvec4(0x01061e02u,0x000d0b09u,0x090b0d02u,0x21001901u),\nuvec4(0x09022600u,0x0e00060cu,0x1196f60du,0x0046f600u),\nuvec4(0x0b0921f1u,0xfcfcfcfcu,0x0011f109u,0x110046f6u),\nuvec4(0xf6023600u,0x000d0e46u,0x02090b09u,0x02310016u),\nuvec4(0x09000609u,0x0600090bu,0x00090b0eu,0x020d0e09u),\nuvec4(0x00091d06u,0x060d0e09u,0x090b0900u,0x0d0e0600u),\nuvec4(0x00110006u,0x06110276u,0x0bbcdc0eu,0x89000100u),\nuvec4(0x0e093102u,0x0b0d100du,0x0e060109u,0x0b09100bu),\nuvec4(0x0e020009u,0x0901060bu,0x0d100d0bu,0x4100090bu),\nuvec4(0x0c0d3906u,0x0b0e0006u,0x001199f9u,0xf10059f9u),\nuvec4(0xfc0b0911u,0x09fcfcfcu,0xf90011f1u,0x00110649u),\nuvec4(0x0d0b99f9u,0x0d0c0901u,0x10310039u,0x000d0b09u),\nuvec4(0x060b0e06u,0x0d0e0900u,0x090e0d12u,0x0d0b0600u),\nuvec4(0x0b090006u,0x1d060009u,0x00110006u,0x00067906u),\nuvec4(0xdc0e0601u,0x01020bbcu,0x31009900u,0x000d0e09u),\nuvec4(0x090b0d01u,0x061e0600u,0x090b0900u,0x060b0e10u),\nuvec4(0x0d0b0900u,0x00311d10u,0x0c0d4906u,0x0b0e0106u),\nuvec4(0x010099f9u,0xf159f900u,0xfc0b0621u,0x09fcfcfcu),\nuvec4(0xf90011f1u,0x00110649u,0x0d0b99f9u,0x0d0b0901u),\nuvec4(0x00310249u,0x0d02001du,0x0600060eu,0x0d100d0bu),\nuvec4(0x0900090bu,0x00060d0bu,0x00090b09u,0x060e0d06u),\nuvec4(0x06001100u,0x02110689u,0x0bbcdc0eu,0xa9000102u),\nuvec4(0x1e093102u,0x0b090106u,0x0b060109u,0x0900060eu),\nuvec4(0x0e100d0cu,0x0901060bu,0x01020e0bu,0x59063100u),\nuvec4(0x01060c0du,0x99f90b0eu,0xf9000100u,0x0921f159u),\nuvec4(0xfcfcfc0bu,0x11f109fcu,0x0649f900u,0x99f90011u),\nuvec4(0x09010d0bu,0x02590d0bu,0x1d061031u,0x0b060009u),\nuvec4(0x0d06000du,0x0900090bu,0x00060d0eu,0x00090b09u),\nuvec4(0x060d0e06u,0x06001100u,0x02110699u,0x0bbcdc0eu),\nuvec4(0xb9000102u,0x0b063100u,0x0b0d100eu,0x1e060009u),\nuvec4(0x0b090106u,0x0b0d100du,0x0b090109u,0x06003109u),\nuvec4(0x060c0d69u,0xf90b0e00u,0x00010099u,0x21f159f9u),\nuvec4(0x090db906u,0x090d0b0du,0x190d191bu,0x192dd90du),\nuvec4(0x0e090e0bu,0x290d890bu,0xf106090du,0x49f90011u),\nuvec4(0xf9001106u,0x000d0b99u,0x690d0b09u,0x0b094102u),\nuvec4(0x0b090006u,0x0b0d100du,0x0e060009u,0x0b09120du),\nuvec4(0x0e060009u,0x0021090du,0x1106a906u,0xbcdc0e02u),\nuvec4(0x0001020bu,0x063102c9u,0x0c0d101eu,0x1b020109u),\nuvec4(0x0c090106u,0x0e00010du,0x0600090bu,0x00110002u),\nuvec4(0x0c0d7906u,0x0b0e0006u,0x010099f9u,0xf159f900u),\nuvec4(0x00a10031u,0x060d0601u,0xf1090d00u,0x1d010061u),\nuvec4(0x000e0900u,0x0001f1f1u,0x110649f9u,0x0b99f900u),\nuvec4(0x0b09000du,0x3102790du,0x06000602u,0x0d100d0bu),\nuvec4(0x0600090bu,0x02060d0eu,0x00090b09u,0x00061e06u),\nuvec4(0xb9060011u,0x0e021106u,0x020bbcdcu,0x02d90001u),\nuvec4(0x0d0b0631u,0x0b090102u,0x1b020109u,0x0b090106u),\nuvec4(0x0b0d100du,0x89064106u,0x00060c0du,0x99f90b0eu),\nuvec4(0xf9000100u,0x11f1f159u,0x01060e02u,0x81f1090du),\nuvec4(0x0b09011du,0x0011f1f1u,0x110649f9u,0x0b99f900u),\nuvec4(0x0b09000du,0x4100890du,0x000d0b06u,0x060b0d06u),\nuvec4(0x0d0b0900u,0x090b0d12u,0x0d0b0600u,0x00110006u),\nuvec4(0x1106c906u,0xbcdc0e02u,0x0001020bu,0x063100e9u),\nuvec4(0x09100e0bu,0x0201090bu,0x0900061eu,0x06000d0cu),\nuvec4(0x00210009u,0x0b0d9906u,0x0b0e0106u,0x001199f9u),\nuvec4(0xf1f159f9u,0x060b0211u,0xf1090d01u,0x090d0071u),\nuvec4(0x000e0901u,0x0001f1f1u,0x110649f9u,0x0b99f900u),\nuvec4(0x0b09010du,0x063102a9u,0x091d1009u,0x0d0b0900u),\nuvec4(0x0e090206u,0x1d060209u,0x06002106u,0x021106d9u),\nuvec4(0x0bbcdc0eu,0xf9000100u,0x1e063102u,0x0b090002u),\nuvec4(0x1b060109u,0x0b090006u,0x06004109u,0x060b0da9u),\nuvec4(0xf90b0e00u,0xf9001199u,0x11f1f159u,0x01060e00u),\nuvec4(0x71f1090du,0x01090d00u,0xf1000e09u,0xf90001f1u),\nuvec4(0x00110649u,0x0d0b99f9u,0xb90b0901u,0x0d024100u),\nuvec4(0x0900090bu,0x09100d0bu,0x0600090eu,0x1100061du),\nuvec4(0x06e90600u,0xdc0e0211u,0x01000bbcu,0x0209f900u),\nuvec4(0x101e0631u,0x00090b09u,0x01021b02u,0x00310d09u),\nuvec4(0x0b0db906u,0x0b0e0006u,0x001199f9u,0xf1f159f9u),\nuvec4(0x060e0211u,0xf1090e01u,0x09011d81u,0xf1f1000eu),\nuvec4(0x49f90001u,0xf9001106u,0x010d0b99u,0x06c90b09u),\nuvec4(0x00010011u,0x0e090119u,0x0d00020du,0x0600090bu),\nuvec4(0x21060d0eu,0x06f90600u,0xdc0e0611u,0x01000bbcu),\nuvec4(0x0019f900u,0x0b0e0631u,0x0c090106u,0x0b060109u),\nuvec4(0x3110060eu,0x0c0dc906u,0x0b0d0106u,0x010099f9u),\nuvec4(0xf159f900u,0x0e0611f1u,0x090d0106u,0x090d81f1u),\nuvec4(0xf10e0901u,0xf90011f1u,0x00110649u,0x0d0b99f9u),\nuvec4(0x0d0b0901u,0x103106c9u,0x020d0e09u,0x090b0900u),\nuvec4(0x0d0e0600u,0x06002106u,0x110609f9u,0xbcdc0e02u),\nuvec4(0x0001020bu,0x310229f9u,0x060e0d06u,0x090b0901u),\nuvec4(0x090e0001u,0x0dd90641u,0x0e01060cu,0x0099f90bu),\nuvec4(0x59f90001u,0x00e1f100u,0x060e0001u,0xf1090e01u),\nuvec4(0x09011d81u,0xc1f1000eu,0xf9002100u,0x00110649u),\nuvec4(0x0d0b99f9u,0x0d0b0901u,0x003106d9u,0x01000d09u),\nuvec4(0x00090b0du,0x060d0e06u,0x19f90631u,0x0e021106u),\nuvec4(0x020bbcdcu,0x39f90001u,0x1e063102u,0x0c090006u),\nuvec4(0x06020009u,0x0de90631u,0x0e01060cu,0x0099f90bu),\nuvec4(0x59f90001u,0x02110046u,0x0b0986f6u,0x0b0d0106u),\nuvec4(0x0d0b86f6u,0xf60b0901u,0x02110096u,0x0649f946u),\nuvec4(0x99f90011u,0x09010d0bu,0x06e90d0bu,0x0b0d2231u),\nuvec4(0x0e060109u,0x0021060du,0x0629f906u,0xdc0e0211u),\nuvec4(0x01060bbcu,0x0249f900u,0x0b0d0631u,0x0c090106u),\nuvec4(0x06003109u,0x060c0df9u,0xf90b0e01u,0x00010099u),\nuvec4(0x1100a9f9u,0x0d89f906u,0x0e00060cu,0x0b89f90bu),\nuvec4(0x0b09010du,0x110299f9u,0x0699f906u,0x99f90011u),\nuvec4(0x09010d0bu,0x02f90d0bu,0x090b0941u,0x0d0e0600u),\nuvec4(0xf9063106u,0x02110639u,0x0bbcdc0eu,0xf9000102u),\nuvec4(0x06310659u,0x0900061eu,0x06002106u,0x0c0d09f9u),\nuvec4(0x0b0e0006u,0x010099f9u,0x00a9f900u,0x99f90611u),\nuvec4(0x1e01060bu,0x0d0b89f9u,0xf90b0901u,0x06110299u),\nuvec4(0x110699f9u,0x0b99f900u,0x0b09010du,0x0209f90du),\nuvec4(0x06001631u,0x0631021eu,0x110649f9u,0xbcdc0e02u),\nuvec4(0x0001020bu,0x310069f9u,0x41001b06u,0x0c0d29f9u),\nuvec4(0x0b0e0006u,0x010099f9u,0x00a9f900u,0x89f90611u),\nuvec4(0x01060c0du,0x2286391bu,0x0d0c4936u,0xf90c0901u),\nuvec4(0x06110299u,0x110699f9u,0x0b99f900u,0x0b09010du),\nuvec4(0x410229f9u,0x21061d06u,0x59f90600u,0x0e021106u),\nuvec4(0x0c8b1cdcu,0x0001020eu,0x310279f9u,0x31000906u),\nuvec4(0x0d29f906u,0x0e00060cu,0x0099f90bu,0xa9f90001u),\nuvec4(0xf9061100u,0x060b0d89u,0x02090d01u,0x0031f120u),\nuvec4(0x09010609u,0x89f90d0bu,0xf9061100u,0x00110699u),\nuvec4(0x0d0b99f9u,0xf90b0901u,0x06310239u,0x06310609u),\nuvec4(0x110669f9u,0x0ddc0e06u,0x090d1978u,0x89f90011u),\nuvec4(0x31003106u,0x29f90d06u,0x00060c0du,0x99f90b0eu),\nuvec4(0xf9000100u,0x061100a9u,0x001689f9u,0x0001f1f1u),\nuvec4(0x0269f916u,0x99f90611u,0xf9001106u,0x010d0b99u),\nuvec4(0x49f90b09u,0x06007102u,0x110679f9u,0xc8dc0e06u),\nuvec4(0xf9000100u,0x00510699u,0x0d49f906u,0x0e00060bu),\nuvec4(0x1199f90bu,0x00a9f900u,0x49f90611u,0xf1000206u),\nuvec4(0x060081f1u,0x110039f9u,0x0699f906u,0x99f90011u),\nuvec4(0x09010d0bu,0x0259f90bu,0x99f90051u,0x0e061106u),\nuvec4(0x0100c8dcu,0x00a9f900u,0xf9060031u,0x060b0d59u),\nuvec4(0xf90b0e00u,0xf9001199u,0x061100a9u,0x000629f9u),\nuvec4(0x10e1f1f1u,0x110009f9u,0x0699f906u,0x99f90011u),\nuvec4(0x09010d0bu,0x0269f90bu,0x99f90641u,0x0e061106u),\nuvec4(0x0100c8dcu,0x00a9f900u,0xf9060021u,0x060b0d69u),\nuvec4(0xf90b0e00u,0xf9001199u,0x061100a9u,0xf10016e9u),\nuvec4(0x0651f1f1u,0x061100d9u,0x110699f9u,0x0b99f900u),\nuvec4(0x0b09010du,0x310679f9u,0x0699f906u,0xdc0e0211u),\nuvec4(0x000100c8u,0x1100a9f9u,0x79f90600u,0x00060c0du),\nuvec4(0x99f90b0eu,0xa9f90011u,0xc9061100u,0xf1f11006u),\nuvec4(0xb90091f1u,0xf9061102u,0x00110699u,0x0d0b99f9u),\nuvec4(0xf90b0901u,0x06210289u,0x110699f9u,0xc8dc0e02u),\nuvec4(0xf9000100u,0x061100a9u,0x0c0d89f9u,0x0b0e0106u),\nuvec4(0x010099f9u,0x00a9f900u,0x06a90611u,0xf1f1f110u),\nuvec4(0x890600d1u,0xf9061102u,0x00110699u,0x0d0b99f9u),\nuvec4(0xf90b0901u,0x06110099u,0x110699f9u,0xc8dc0e02u),\nuvec4(0xf9000100u,0x061100a9u,0x0c0d89f9u,0x0b0e0106u),\nuvec4(0x010099f9u,0x02a9f900u,0x06890611u,0xf1f1f100u),\nuvec4(0x690631f1u,0xf9061102u,0x00110699u,0x0d0b99f9u),\nuvec4(0x0d0b0900u,0x110289f9u,0x0699f906u,0xdc0e0211u),\nuvec4(0x000100c8u,0x1100a9f9u,0x0d89f906u,0x0e01060cu),\nuvec4(0x2199f90bu,0x1102a9f9u,0x00066906u,0xf1f1f1f1u),\nuvec4(0x02490671u,0x99f90611u,0xf9001106u,0x000d0b99u),\nuvec4(0xf90d0b09u,0x02110089u,0x110699f9u,0xc8dc0e02u),\nuvec4(0xf9000100u,0x061102a9u,0x060c99f9u,0xf90b0d01u),\nuvec4(0xa9f92199u,0x59061100u,0xf1f1f110u,0x060091f1u),\nuvec4(0x06110229u,0x110699f9u,0x0b99f900u,0x0b06000du),\nuvec4(0x0689f90du,0x99f90611u,0x0e021106u,0x0100c8dcu),\nuvec4(0x99f90600u,0xf9061100u,0x01060c99u,0x99f90e0du),\nuvec4(0x99f90621u,0x39021102u,0xf1f10002u,0x00d1f1f1u),\nuvec4(0x11000906u,0x0699f902u,0x99f90011u,0x0b09011eu),\nuvec4(0x110099f9u,0x0699f900u,0xdc0e0211u,0x000100c8u),\nuvec4(0x0e2b0d09u,0x190d4efbu,0x2bfb0e0du,0x0b0e2b0eu),\nuvec4(0x0e00060cu,0x5bfb1e0cu,0x1b0e291eu,0x5e0bfb0eu),\nuvec4(0x0b0d190du,0xf100090du,0xf1f1f1f1u,0x09060001u),\nuvec4(0x1e0d090du,0x0eeb4e0bu,0x2e290d1bu,0x1e1b1e3bu),\nuvec4(0x1e1b1e0bu,0x0c2b1e0bu,0x0c09000eu,0x4bfb2e0bu),\nuvec4(0x0d190d0eu,0x3bfb1e1bu,0x11090b0eu,0xc8dc0b06u),\nuvec4(0x0d000100u,0xfb1eabfbu,0x00060eabu,0xfb0c1b09u),\nuvec4(0x0e9bfbfbu,0xf1f10009u,0x31f1f1f1u,0x1e0b0d00u),\nuvec4(0xfbfb0e0bu,0x00095bfbu,0xfb0e5b06u,0x0d1bfbfbu),\nuvec4(0x0e060100u,0x0100c8dcu,0x01100100u,0x50f0f0f0u),\nuvec4(0xf0111011u,0x30f021a0u,0x10013011u,0xf1f1f1f1u),\nuvec4(0x011081f1u,0x0001f0f0u,0x5011b011u,0xf0014011u),\nuvec4(0x0100f0f0u,0x0d001110u,0x0100c8dcu,0x093d0900u),\nuvec4(0x2dfdfdfdu,0xf1f10009u,0xf1f1f1f1u,0x91f1f1f1u),\nuvec4(0xf1f1f100u,0x3d090691u,0xfdfdfd09u,0x1106190du),\nuvec4(0xc8dc0b06u,0x0d000100u,0x1d0e9bfbu,0x7bfb0c0bu),\nuvec4(0xf1060b0cu,0xf1b0f0f1u,0xf1f1f1f1u,0x3180f0e1u),\nuvec4(0x11201110u,0x00022110u,0x00020011u,0x06311011u),\nuvec4(0x9bfb0c0bu,0x8bfb0e0du,0x00090b0cu,0xdc0b0601u),\nuvec4(0x000100c8u,0x1102a9f9u,0x0d89f906u,0xe1f1060bu),\nuvec4(0x89f90600u,0xf1f10006u,0xf1f1f1f1u,0x0669f906u),\nuvec4(0x101d0611u,0x01090b09u,0x060e0d00u,0x0d0e0601u),\nuvec4(0x090e0910u,0x021e0601u,0x0d0b0921u,0x010289f9u),\nuvec4(0x99f90600u,0x06010006u,0x00c8dc0eu,0xf9060001u),\nuvec4(0x06110099u,0x060c99f9u,0x9110f021u,0x0689f900u),\nuvec4(0xf1f1f100u,0x11f1f1f1u,0x0659f906u,0x0b0c0611u),\nuvec4(0x0c0d0100u,0x0b02000du,0x0601090cu,0x01020b0cu),\nuvec4(0x100d0c09u,0x21090b0eu,0x99f90b09u,0xf9061100u),\nuvec4(0x06110699u,0x00c8dc0eu,0xa9f90001u,0xf9061100u),\nuvec4(0x060b0d89u,0x61f14021u,0x69f90600u,0xf1f1f106u),\nuvec4(0x41f1f1f1u,0x0649f900u,0x0e0b0611u,0x0c090100u),\nuvec4(0x0d00010du,0x0601060bu,0x0901021bu,0x0e100d0cu),\nuvec4(0x0921060bu,0x89f90d0bu,0xf9061102u,0x06110699u),\nuvec4(0x00c8dc0eu,0xa9f90001u,0xf9061100u,0x060b0d89u),\nuvec4(0x71f13021u,0x59f90600u,0xf1f10006u,0xf1f1f1f1u),\nuvec4(0x39f90051u,0x0b061106u,0x0901000eu,0x0e100d0cu),\nuvec4(0x0601090cu,0x0901021bu,0x0e100d0cu,0x0921060bu),\nuvec4(0x89f90d0bu,0xf9061102u,0x00110699u,0x00c8dc0eu),\nuvec4(0xa9f90001u,0xf9061100u,0x060b0d89u,0xa1f11021u),\nuvec4(0x0649f906u,0xf1f1f1f1u,0x0081f1f1u,0x0619f906u),\nuvec4(0x0e0b0611u,0x0c090102u,0x0c0e100du,0x1b060109u),\nuvec4(0x0c090102u,0x0b0e100du,0x0b062109u,0x0289f90du),\nuvec4(0x99f90611u,0x0e021106u,0x0100c8dcu,0x00a9f900u),\nuvec4(0x89f90611u,0x31060b0du,0x06a1f100u,0x000639f9u),\nuvec4(0xf1f1f1f1u,0x0091f1f1u,0x110619f9u,0x020e0b06u),\nuvec4(0x0d0c0901u,0x090c0e10u,0x021b0601u,0x0d0c0901u),\nuvec4(0x090b0e10u,0x0d0b0921u,0x110289f9u,0x0699f906u),\nuvec4(0xdc0d0211u,0x000100c8u,0x1100a9f9u,0x0d89f906u),\nuvec4(0x0031060bu,0x11f10071u,0x0629f906u,0xf1f1f1f1u),\nuvec4(0x00c1f1f1u,0x1106f906u,0x020e0b06u,0x0d0c0901u),\nuvec4(0x090c0e10u,0x021b0601u,0x0d0c0901u,0x090b0e10u),\nuvec4(0x0d0b0921u,0x110289f9u,0x0699f906u,0xdc0e0611u),\nuvec4(0x000100c8u,0x1100a9f9u,0x0d89f906u,0x1021060bu),\nuvec4(0xf906a1f1u,0xf1f10619u,0xf1f1f1f1u,0xe90600e1u),\nuvec4(0x0b061106u,0x0901020eu,0x00010d0cu,0x01090c0eu),\nuvec4(0x01021b06u,0x100d0c09u,0x21090b0eu,0xf90d0b09u),\nuvec4(0x06110289u,0x110699f9u,0x0bbe0902u,0x0100c80cu),\nuvec4(0x00a9f900u,0x89f90611u,0x21060b0du,0x0071f130u),\nuvec4(0x0609f906u,0xf1f1f100u,0xf1f1f1f1u,0x1106e900u),\nuvec4(0x000e0b06u,0x0d0c0901u,0x0c0e0001u,0x1b060109u),\nuvec4(0x0c090102u,0x0b0e1009u,0x0b092106u,0x0289f90du),\nuvec4(0x99f90611u,0x11902106u,0xc80d0600u,0xf9000100u),\nuvec4(0x061100a9u,0x0b0d89f9u,0xf1402106u,0xf9060061u),\nuvec4(0xf1f10006u,0xf1f1f1f1u,0x060211f1u,0x061106c9u),\nuvec4(0x01000e0bu,0x100d0c09u,0x01090c0eu,0x00021b06u),\nuvec4(0x10090c09u,0x21060b0eu,0xf90d0b09u,0x06110289u),\nuvec4(0xf10699f9u,0x00c80b06u,0xa9f90001u,0xf9061100u),\nuvec4(0x060b0d89u,0x51f15021u,0x0006f900u,0xf1f1f1f1u),\nuvec4(0x31f1f1f1u,0x1106c906u,0x000e0b06u,0x090c0901u),\nuvec4(0x0c0e0001u,0x0b060106u,0x0901020eu,0x0001090cu),\nuvec4(0x21060b0eu,0x99f90b09u,0xf9061102u,0x06f10699u),\nuvec4(0x0100c80bu,0x00a9f900u,0x89f90611u,0x21060b0du),\nuvec4(0xa110c110u,0x0006e900u,0xf1f1f1f1u,0x51f1f1f1u),\nuvec4(0x1106b906u,0x000e0b06u,0x090c0901u,0x0c0e0001u),\nuvec4(0x0b060106u,0x0c09100eu,0x0e000109u,0x0921060bu),\nuvec4(0x0299f90bu,0x99f90611u,0x0b06f106u,0x000100c8u),\nuvec4(0x1100a9f9u,0x0d89f906u,0x1021060bu,0x01f10071u),\nuvec4(0xf100e900u,0xf1f1f1f1u,0x0671f1f1u,0x061106a9u),\nuvec4(0x01000e0bu,0x10090c09u,0x01060c0eu,0x100e0b06u),\nuvec4(0x01090c09u,0x060b0e00u,0x0d0b0921u,0x110289f9u),\nuvec4(0x0699f906u,0xc80b06f1u,0xf9000100u,0x061100a9u),\nuvec4(0x0b0d89f9u,0x01802106u,0x0001f100u,0xf1f106d9u),\nuvec4(0xf1f1f1f1u,0xa90081f1u,0x0b061106u,0x0901000eu),\nuvec4(0x0e10090cu,0x0601060cu,0x00020e0bu,0x01090c09u),\nuvec4(0x060b0e00u,0x0d0b0921u,0x110289f9u,0x0699f906u),\nuvec4(0xc80b06f1u,0xf9000100u,0x061100a9u,0x0b0d89f9u),\nuvec4(0x61902106u,0xc9009100u,0xf1f10006u,0xf1f1f1f1u),\nuvec4(0x990091f1u,0x0b061106u,0x0901000eu,0x0e10090cu),\nuvec4(0x0601060cu,0x01020e0cu,0x010d0c09u,0x060b0e00u),\nuvec4(0xf90b0921u,0x06110299u,0xf10699f9u,0x00c80b06u),\nuvec4(0xa9f90001u,0xf9061100u,0x060b0d89u,0x00b14021u),\nuvec4(0x00c90091u,0xf1f1f1f1u,0xb1f1f1f1u,0x11068906u),\nuvec4(0x000e0b06u,0x090c0901u,0x060c0d10u,0x0b0c0601u),\nuvec4(0x0c090102u,0x0e00010du,0x0921060bu,0x0299f90bu),\nuvec4(0x99f90611u,0x0b06f106u,0x000100c8u,0x1100a9f9u),\nuvec4(0x0d89f906u,0x4021060bu,0xb90061f1u,0xf1f1f106u),\nuvec4(0xf1f1f1f1u,0x067906d1u,0x0e0b0611u,0x0c090102u),\nuvec4(0x0c0d1009u,0x0b060106u,0x0901020eu,0x0d100d0cu),\nuvec4(0x0921060bu,0x0299f90bu,0x99f90611u,0x0b06f106u),\nuvec4(0x000100c8u,0x1100a9f9u,0x0d89f906u,0xd021060bu),\nuvec4(0x00911011u,0xf1f106a9u,0xf1f1f1f1u,0x0679f1f1u),\nuvec4(0x0e0b0211u,0x0c090102u,0x0c0d1009u,0x0b060106u),\nuvec4(0x0900020eu,0x0d10090cu,0x0921060bu,0x0299f90bu),\nuvec4(0x99f90611u,0x0b06f106u,0x000100c8u,0x1100a9f9u),\nuvec4(0x0d89f906u,0xf1f1060bu,0xf1f100a9u,0xf1f1f1f1u),\nuvec4(0x6900f1f1u,0x1b061106u,0x0c090100u,0x0b00010du),\nuvec4(0x0601060cu,0x0901001bu,0x0b11090cu,0x0921060cu),\nuvec4(0x89f90d0bu,0xf9061106u,0x06f10699u,0x0100c80eu),\nuvec4(0x00a9f900u,0x89f90611u,0x11060b0du,0x0011a0f0u),\nuvec4(0xf1f10699u,0xf1f1f1f1u,0x6911f1f1u,0x06010006u),\nuvec4(0x0e26090eu,0x16390209u,0x0e26090eu,0x0d09000du),\nuvec4(0x00010219u,0xf90d0b09u,0x06110689u,0xf10699f9u),\nuvec4(0x00c80b06u,0xa9f90001u,0xf9061100u,0x060b0d89u),\nuvec4(0x86f60011u,0x89001102u,0xf1f1f106u,0xf1f1f1f1u),\nuvec4(0x590021f1u,0x0d061106u,0x020d0906u,0x090d0619u),\nuvec4(0x06090e06u,0x0d09060du,0x060d0902u,0x0d02090du),\nuvec4(0x09000109u,0x89f90d0bu,0xf9061106u,0x06f10699u),\nuvec4(0x0100c80bu,0x00a9f900u,0x89f90611u,0x11060b0du),\nuvec4(0x0286f600u,0x06890011u,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0x06490631u,0x060d0611u,0x19020d09u,0x06090d00u),\nuvec4(0x0e06090eu,0x060e0902u,0x090e0219u,0x11060d02u),\nuvec4(0xf90d0b09u,0x06110689u,0xf10699f9u,0x00c80e06u),\nuvec4(0xa9f90001u,0xf9061100u,0x060b0d89u,0x26f60011u),\nuvec4(0x16021602u,0x79001102u,0xf1f10006u,0xf1f1f1f1u),\nuvec4(0x0031f1f1u,0x06110649u,0x0d09060du,0x020d0906u),\nuvec4(0x0d06090du,0x060e0609u,0x19060d09u,0x06090d02u),\nuvec4(0x0911060du,0x89f90d0bu,0xf9061102u,0x06f10699u),\nuvec4(0x0100c80bu,0x00a9f900u,0x89f90611u,0x11060b0du),\nuvec4(0x0256f600u,0x00110216u,0xf1f10079u,0xf1f1f1f1u),\nuvec4(0x0651f1f1u,0x01000639u,0x09060d06u,0x0619020du),\nuvec4(0x0d06090du,0x060d0906u,0x19060d09u,0x06090d02u),\nuvec4(0x0911060du,0x89f90d0bu,0xf9061102u,0x06f10699u),\nuvec4(0x0100c80bu,0x00a9f900u,0x89f90611u,0x11060b0du),\nuvec4(0x0256f600u,0x69210216u,0xf1f1f106u,0xf1f1f1f1u),\nuvec4(0x390061f1u,0x0d061106u,0x020e0906u,0x0d06090du),\nuvec4(0x060d0609u,0x09060d09u,0x0d09020du,0x02090d02u),\nuvec4(0x0911060du,0x89f90d0bu,0xf9061102u,0x06f10699u),\nuvec4(0x0100c80bu,0x00a9f900u,0x89f90611u,0x11060b0du),\nuvec4(0x0286f600u,0x00690011u,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0x06290671u,0x060d0611u,0x19060d09u,0x06090d06u),\nuvec4(0x0e06090du,0x020d0906u,0x090d0619u,0x11060d02u),\nuvec4(0xf90d0b09u,0x06110689u,0xf10699f9u,0x00c80b06u),\nuvec4(0x09060001u,0x19060916u,0x110026f6u,0x76f60906u),\nuvec4(0x11060b09u,0x0286f600u,0x09060011u,0x02060916u),\nuvec4(0xf1f1f1f1u,0xf1f1f1f1u,0x00091691u,0x060d0611u),\nuvec4(0x19020d09u,0x06090d02u,0x0d06090du,0x060d0906u),\nuvec4(0x0d020d09u,0x060d0609u,0x090b0911u,0x09160906u),\nuvec4(0x110036f6u,0x76f61900u,0x0b06e110u,0x000100c8u),\nuvec4(0xf1f10001u,0x0d0651f1u,0xf6001106u,0xf1f10286u),\nuvec4(0xf1f1f1f1u,0x91f1f1f1u,0x09060d06u,0x0219020du),\nuvec4(0x0d06090du,0x060d0609u,0x09060d09u,0x090d060du),\nuvec4(0x11060d06u,0xf1000d09u,0x71f1f1f1u,0x00c80b06u),\nuvec4(0x91f1f1f1u,0x11060d06u,0x0286f600u,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0x0d0691f1u,0x020d0906u,0x090d0219u),\nuvec4(0x06090d06u,0x0d09060du,0x060d0906u,0x0d06090du),\nuvec4(0x0d091106u,0xf1f1f100u,0x0b0671f1u,0x000100c8u),\nuvec4(0x86f60906u,0x09061100u,0x0b0976f6u,0xf6001106u),\nuvec4(0x46210286u,0xf1f1f100u,0xf1f1f1f1u,0x0216b1f1u),\nuvec4(0x060d0611u,0x19020d09u,0x06090d02u,0x0d06090du),\nuvec4(0x060d0906u,0x0d020d09u,0x060d0609u,0x090b0911u),\nuvec4(0x66f60906u,0xf6001100u,0x06f10096u,0x0100c80bu),\nuvec4(0x00a9f900u,0x89f90611u,0x11060b0du,0x0286f600u),\nuvec4(0x00490011u,0xf1f1f1f1u,0xf1f1f1f1u,0x060900b1u),\nuvec4(0x060d0611u,0x19020d09u,0x06090d02u,0x0d06090du),\nuvec4(0x060d0906u,0x0d020d09u,0x060d0609u,0x0d0b0911u),\nuvec4(0x110689f9u,0x0699f906u,0xc80b06f1u,0xf9000100u),\nuvec4(0x061100a9u,0x0b0d89f9u,0xf6001106u,0x00110286u),\nuvec4(0xf1f10639u,0xf1f1f1f1u,0x09d1f1f1u,0x0d061106u),\nuvec4(0x020d0906u,0x090d0219u,0x06090d06u,0x0d09060du),\nuvec4(0x020d0906u,0x0d06090du,0x0b091106u,0x110299f9u),\nuvec4(0x0699f906u,0xc80b06f1u,0xf9000100u,0x061100a9u),\nuvec4(0x0b0d89f9u,0xf6001106u,0x06210286u,0xf1f10029u),\nuvec4(0xf1f1f1f1u,0x16d1f1f1u,0x060d0611u,0x19060d09u),\nuvec4(0x06090d06u,0x060d160du,0x19060d09u,0x06090d00u),\nuvec4(0x0911060du,0x89f90d0bu,0xf9061102u,0x06f10699u),\nuvec4(0x0100c80bu,0x00a9f900u,0x89f90611u,0x11060b0du),\nuvec4(0x0286f600u,0xf1003921u,0xf1f1f1f1u,0xd1f1f1f1u),\nuvec4(0x06110600u,0x0d09060du,0x0d061906u,0x160d0609u),\nuvec4(0x0d09060eu,0x0d001906u,0x060d0609u,0xf90b0911u),\nuvec4(0x06110299u,0xf10699f9u,0x00c80b06u,0xa9f90001u),\nuvec4(0xf9061100u,0x060b0d89u,0x96f60011u,0x19060011u),\nuvec4(0xf1f1f106u,0xf1f1f1f1u,0x1106f1f1u,0x09060d06u),\nuvec4(0x0d09060du,0x06090d00u,0x0d06090du,0x020d0906u),\nuvec4(0x0d020d09u,0x060d0609u,0x0d0b0911u,0x110289f9u),\nuvec4(0x0699f906u,0x0e06e100u,0x2d0b7d0bu,0xf9000100u),\nuvec4(0x061100a9u,0x0b0d89f9u,0xf6001106u,0x00111276u),\nuvec4(0xf1f10029u,0xf1f1f1f1u,0x00f1f1f1u,0x060d0611u),\nuvec4(0x19020d09u,0x06090d06u,0x0d06090du,0x020d0906u),\nuvec4(0x0d060d09u,0x060d0609u,0x0d0b0911u,0x110289f9u),\nuvec4(0x0699f906u,0x0ec90011u,0x020bbc0cu,0xa9f90001u),\nuvec4(0xf9061100u,0x060b0d89u,0x96f60011u,0x06190011u),\nuvec4(0xf1f1f100u,0xf1f1f1f1u,0x0621f1f1u,0x0d09060du),\nuvec4(0x06090d00u,0x0d06090du,0x060d0609u,0x09020d09u),\nuvec4(0x090d060du,0x11060d06u,0xf90d0b09u,0x06110289u),\nuvec4(0x110699f9u,0xbcdc0b06u,0x0001020bu,0x1100a9f9u),\nuvec4(0x0d89f906u,0x0011060bu,0x1182f206u,0xf1061900u),\nuvec4(0xf1f1f1f1u,0xf1f1f1f1u,0x060d0631u,0x09020d09u),\nuvec4(0x090d000du,0x0d160e02u,0x060d0906u,0x0d000d09u),\nuvec4(0x060d0609u,0x0b090001u,0x0289f90du,0x99f90611u),\nuvec4(0x0e021106u,0x020bbcdcu,0xa9f90001u,0xf9061100u),\nuvec4(0x060b0d89u,0x96f60011u,0xf1061921u,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0x060d0631u,0x09060d09u,0x090d060du),\nuvec4(0x09060d06u,0x0d09060du,0x0d061906u,0x060d0609u),\nuvec4(0x0b090001u,0x0289f90du,0x99f90611u,0x0e021106u),\nuvec4(0x020bbcdcu,0xa9f90001u,0xf9061100u,0x060b0d89u),\nuvec4(0x99f90211u,0x00191100u,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0x0d0631f1u,0x9906c906u,0x0b091106u,0x110299f9u),\nuvec4(0x0699f906u,0xdc0e0211u,0x01060bbcu,0x00a9f900u),\nuvec4(0x89f90611u,0x11060b0du,0x0099f902u,0xf1f11911u),\nuvec4(0xf1f1f1f1u,0x41f1f1f1u,0x79f90d06u,0x09110206u),\nuvec4(0x89f90d0bu,0xf9061102u,0x02110699u,0x0bbcdc0eu),\nuvec4(0xf9000100u,0x061100a9u,0x0b0d89f9u,0xf9021106u),\nuvec4(0x09001199u,0xf1f1f106u,0xf1f1f1f1u,0x0641f1f1u),\nuvec4(0x06c90629u,0x160d0649u,0xf90b0911u,0x06110299u),\nuvec4(0x110699f9u,0xbcdc0e06u,0x0001020bu,0x0d0e99f9u),\nuvec4(0x0d0b0201u,0x0b0d79f9u,0xf9001106u,0x00010099u),\nuvec4(0xf1f10609u,0xf1f1f1f1u,0x41f1f1f1u,0x1689f906u),\nuvec4(0x0d0b0911u,0x0e0d79f9u,0x89f91e10u,0x0e021106u),\nuvec4(0x020bbcdcu,0x99f90001u,0x06000b0eu,0x79f90d0bu),\nuvec4(0x11060b0du,0x1199f900u,0xf1060900u,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0x89f90641u,0x0b091116u,0x0d79f90du),\nuvec4(0x0e0b100bu,0x110689f9u,0xbcdc0e02u,0x0001020bu),\nuvec4(0x001b99f9u,0xf90d0b06u,0x060b0d79u,0x99f90011u),\nuvec4(0xf1020621u,0xf1f1f1f1u,0xf1f1f1f1u,0x89f90641u),\nuvec4(0x09110206u,0x79f90d0bu,0x00020b0du,0x89f90e0bu),\nuvec4(0x0e021106u,0x020bbcdcu,0x99f90001u,0x0b06011eu),\nuvec4(0x0d79f90du,0x0011060bu,0x001199f9u,0xf1f10006u),\nuvec4(0xf1f1f1f1u,0x41f1f1f1u,0x79f90d02u,0x06110206u),\nuvec4(0x79f90d0bu,0x00020b0du,0x89f90e0bu,0x0e021106u),\nuvec4(0x020bbcdcu,0x99f90001u,0x0b06001eu,0x0d79f90du),\nuvec4(0x0011060bu,0x001199f9u,0xf1f10006u,0xf1f1f1f1u),\nuvec4(0x41f1f1f1u,0x79f90d00u,0x06110206u,0x79f90d0bu),\nuvec4(0x00020b0du,0x89f90e0bu,0x0e021106u,0x020bbcdcu),\nuvec4(0x99f90001u,0x06000b0eu,0x79f90d0bu,0x11060b0du),\nuvec4(0x0099f900u,0xf1020001u,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0xf90d0051u,0x06111679u,0x79f90d0bu,0x00020b0du),\nuvec4(0x89f90e0bu,0x0e021106u,0x020bbcdcu,0x99f90001u),\nuvec4(0x06000b0eu,0x79f90d0bu,0x11060b0du,0x1199f900u),\nuvec4(0xf1f1f110u,0xf1f1f1f1u,0x0051f1f1u,0x0679f90du),\nuvec4(0x0b061102u,0x0d79f90du,0x0b00020bu,0x0689f90eu),\nuvec4(0xdc0e0211u,0x01020bbcu,0x0e99f900u,0x0b06000bu),\nuvec4(0x0d79f90du,0x0011060bu,0x101199f9u,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0x89f961f1u,0x06110206u,0x79f90d0bu),\nuvec4(0x00020b0du,0x89f90e0bu,0x0e021106u,0x1c0b8cdcu),\nuvec4(0x0001020eu,0x011b99f9u,0xf90d0b06u,0x060b0d79u),\nuvec4(0x99f90011u,0xf1f1f100u,0xf1f1f1f1u,0xf991f1f1u),\nuvec4(0x11020689u,0xf90d0b06u,0x060b0d79u,0xf90e0b00u),\nuvec4(0x00110689u,0x09acdc0du,0xf9001100u,0x06001e99u),\nuvec4(0x79f90d0bu,0x11060b0du,0x0099f902u,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0x89f991f1u,0x09110206u,0x79f90d0bu),\nuvec4(0x0b100b0du,0x0689f90du,0x0b090021u,0x00098cbcu),\nuvec4(0x99f90031u,0x0b06001eu,0x0b89f90du,0xf9021106u),\nuvec4(0xf1f1f199u,0xf1f1f1f1u,0xf9a1f1f1u,0x11020689u),\nuvec4(0x89f90b06u,0x0b120b0du,0x0689f90du,0x0d020031u),\nuvec4(0x060e6cacu,0x99f90051u,0x02010e0bu,0x79f90d0bu),\nuvec4(0x11060c0du,0xf199f902u,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0x0689f9a1u,0x0b061102u,0x0d79f90du,0xf91e100eu),\nuvec4(0x06610689u,0x0e4c8c0du,0x99f98106u,0x06000b0eu),\nuvec4(0x89f90d0bu,0x0211060bu,0xf1f199f9u,0xf1f1f1f1u),\nuvec4(0xa1f1f1f1u,0x020689f9u,0xf90b0911u,0x02001e89u),\nuvec4(0x89f90e0bu,0x0e068106u,0x092c0b6cu,0x06008100u),\nuvec4(0x011e89f9u,0xf90d0b06u,0x060b0d79u,0x99f90211u),\nuvec4(0xf1f1f1f1u,0xf1f1f1f1u,0x89f9a1f1u,0x06110206u),\nuvec4(0x79f90d0eu,0x0b02001eu,0x0689f90du,0x0b090091u),\nuvec4(0x000d1c4cu,0xfb0d00a1u,0x0b0c0e7bu,0xfb1c0600u),\nuvec4(0x11061c7bu,0xf199f902u,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0x0689f9a1u,0x0c091102u,0x0b0c8bfbu,0xfb0c0b16u),\nuvec4(0xa100098bu,0x2c0b0d00u,0x00c1060du,0x0d0e0d09u),\nuvec4(0x2efe0d2eu,0x2d020109u,0x8d1e1d2eu,0x2d2e0d1eu),\nuvec4(0xf9061100u,0xf1f10689u,0xf1f1f1f1u,0xa1f1f1f1u),\nuvec4(0x020689f9u,0x0e1d0211u,0x6e0d9e1du,0x090d1e0du),\nuvec4(0x0d0e0910u,0x0d0e2d0eu,0x0d0e7d7eu,0x06c10009u),\nuvec4(0x000c0b0du,0xf1f100f1u,0xf906a1f1u,0xf1f1f199u),\nuvec4(0xf1f1f1f1u,0xf9a1f1f1u,0x00310689u,0xf10091f1u),\nuvec4(0x00f100b1u,0x090b0b0du,0x0900b100u,0x1e0d1e1du),\nuvec4(0x0e0d1eedu,0x0d060009u,0x7d1e0d5eu,0x1d2e1d0eu),\nuvec4(0x11020d0eu,0x098dfd06u,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0x89f9a1f1u,0x1d062106u,0x0dae8d3eu,0x0d060009u),\nuvec4(0x1d0e0d0eu,0x0efe1d0eu,0xb100090du,0x1c0e0900u),\nuvec4(0x31090e1cu,0x0d005100u,0x2bfb0e3bu,0x000b0c0eu),\nuvec4(0x9bfb0c06u,0x0611060cu,0xf1098dfdu,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0x0689f9a1u,0xfb1c0921u,0x0c0b0e5bu),\nuvec4(0x0b06000eu,0x0e7bfb0cu,0x00910009u,0x3c3c0e09u),\nuvec4(0x8100060eu,0x0e0b99f9u,0x0d0b0601u,0x0b0d79f9u),\nuvec4(0xfd061106u,0xf100098du,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0x0689f991u,0x0d0b0621u,0x0b0e79f9u,0xf90d0b12u),\nuvec4(0x00810689u,0x5c5c0d06u,0x0061060eu,0x0e0b99f9u),\nuvec4(0x0d0b0601u,0x0b0d79f9u,0xfd061106u,0xf100098du),\nuvec4(0xf1f1f1f1u,0xf1f1f1f1u,0x0689f991u,0xf90b0921u),\nuvec4(0x100b0d89u,0x89f90e0bu,0x0e067106u,0x090b7c7cu),\nuvec4(0x0b99f951u,0x0b06000eu,0x0d79f90du,0x0611060bu),\nuvec4(0x00098dfdu,0xf1f1f1f1u,0xf1f1f1f1u,0x89f991f1u),\nuvec4(0x0b092106u,0x0e0d89f9u,0x0d0b0002u,0x510689f9u),\nuvec4(0x9c9c0b09u,0x0021060bu,0x001e99f9u,0xf90d0b06u),\nuvec4(0x060b0d79u,0x8dfd0611u,0xf1f10009u,0xf1f1f1f1u),\nuvec4(0x91f1f1f1u,0x210689f9u,0xf90d0b09u,0x060b0d79u),\nuvec4(0xf90d0b00u,0x00210689u,0xbcbc0b06u,0x0001000du),\nuvec4(0x0b0e99f9u,0x0d0c0601u,0x0b0d79f9u,0xfd061106u),\nuvec4(0xf100098du,0xf1f1f1f1u,0xf1f1f1f1u,0x0689f991u),\nuvec4(0x0d0b0921u,0x0b0d79f9u,0xf90d0b10u,0x02110689u),\nuvec4(0x0bbcdc0du,0xf9000102u,0x000b0e99u,0xf90d0b06u),\nuvec4(0x060b0d79u,0x8dfd0611u,0x00010009u,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0xf90d71f1u,0x09210679u,0x79f90d0bu),\nuvec4(0x0b100b0du,0x0689f90eu,0xdc0e0611u,0x01020bbcu),\nuvec4(0x1e99f900u,0x0d0b0600u,0x0b0d79f9u,0xfd061106u),\nuvec4(0x0100098du,0xf1f1f110u,0xf1f1f1f1u,0x0d61f1f1u),\nuvec4(0x210679f9u,0xf90d0b09u,0x100b0d79u,0x89f90e0bu),\nuvec4(0x0e061106u,0x020bbcdcu,0x99f90001u,0x06000b0eu),\nuvec4(0x79f90d0bu,0x11060b0du,0x098dfd06u,0xf1100100u),\nuvec4(0xf1f1f1f1u,0xf1f1f1f1u,0x89f90051u,0x0b092106u),\nuvec4(0x0e79f90du,0x0b00020bu,0x0689f90eu,0xdc0e0611u),\nuvec4(0x01000bbcu,0x0e99f900u,0x0b06000bu,0x0d79f90du),\nuvec4(0x0611060bu,0x00098dfdu,0x00060001u,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0xf90041f1u,0x09210689u,0x79f90d0bu),\nuvec4(0x00020b0eu,0x89f90e0bu,0x0e061106u,0x020bbcdcu),\nuvec4(0x99f90001u,0x0b06001eu,0x0d79f90du,0x0611060bu),\nuvec4(0x00098dfdu,0x00060001u,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0xf90041f1u,0x09210689u,0x79f90d0bu,0x00020b0du),\nuvec4(0x89f90e0bu,0x0e061106u,0x020bbcdcu,0x99f90001u),\nuvec4(0x0b06001bu,0x0d79f90du,0x0611060bu,0x00098dfdu),\nuvec4(0x00060001u,0xf1f1f1f1u,0xf1f1f1f1u,0xf90241f1u),\nuvec4(0x09210689u,0x79f90d0bu,0x0b120b0du,0x0689f90du),\nuvec4(0xdc0e0211u,0x01020bbcu,0x1e99f900u,0x0d0b0601u),\nuvec4(0x0b0d79f9u,0xfd061106u,0x0100098du,0xf1000900u),\nuvec4(0xf1f1f1f1u,0xf1f1f1f1u,0x89f90641u,0x0b092106u),\nuvec4(0x0d79f90du,0x0d0b120bu,0x110689f9u,0xbcdc0e02u),\nuvec4(0x0001000bu,0x0d0e99f9u,0x0d0b0601u,0x0b0d79f9u),\nuvec4(0xfd061106u,0x0100098du,0xf1000900u,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0x89f90641u,0x0b092106u,0x0d79f90du),\nuvec4(0x0d0e100eu,0x110689f9u,0xbcdc0e06u,0x0001020bu),\nuvec4(0x1102a9f9u,0x0d89f906u,0x0611060bu,0x00098dfdu),\nuvec4(0x06090001u,0xf1f1f1f1u,0xf1f1f1f1u,0xf90641f1u),\nuvec4(0x06210689u,0x89f90d0bu,0xf9061106u,0x06110699u),\nuvec4(0x0bbcdc0eu,0xf9000102u,0x061100a9u,0x0b0d89f9u),\nuvec4(0xfd061106u,0x0100098du,0xf1060900u,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0x89f90641u,0x0b092106u,0x0289f90du),\nuvec4(0x99f90611u,0x0e061106u,0x020bbcdcu,0xa9f90001u),\nuvec4(0xf9061100u,0x060b0d89u,0x3dfd0611u,0x00093d09u),\nuvec4(0x00190001u,0xf1f1f1f1u,0xf1f1f1f1u,0xf90631f1u),\nuvec4(0x09210689u,0x89f90d0bu,0xf9061102u,0x02110699u),\nuvec4(0x0bbcdc0eu,0xf9000102u,0x061100a9u,0x0b0d89f9u),\nuvec4(0xfd061106u,0x0100098du,0xf1001900u,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0x89f90631u,0x0b092106u,0x0689f90du),\nuvec4(0x99f90611u,0x0e021106u,0x020bbcdcu,0xa9f90001u),\nuvec4(0xf9061100u,0x060b0d89u,0x3b0e0611u,0x9b0e1b1eu),\nuvec4(0x1b0e0b0eu,0x0001000du,0xf1f10619u,0xf1f1f1f1u),\nuvec4(0x31f1f1f1u,0x0689f906u,0x0d0b0921u,0x110689f9u),\nuvec4(0x0699f906u,0xdc0e0211u,0x01020bbcu,0x00a9f900u),\nuvec4(0x89f90611u,0x11060b0du,0x7bfb0e06u,0x0001000eu),\nuvec4(0xf1f10619u,0xf1f1f1f1u,0x31f1f1f1u,0x0689f906u),\nuvec4(0x0d0b0921u,0x110689f9u,0x0699f906u,0xdc0e0211u),\nuvec4(0x6b1d0e1bu,0x0001000du,0x1100a9f9u,0x0d89f906u),\nuvec4(0x0611060bu,0x0e4bfb0eu,0x01000d1bu,0xf1002900u),\nuvec4(0xf1f1f1f1u,0xf1f1f1f1u,0x89f90621u,0x0b092106u),\nuvec4(0x0689f90du,0x99f90611u,0x0e021106u,0x1109badcu),\nuvec4(0x00a9f900u,0x89f90611u,0x11060b0du,0x7bfb0e06u),\nuvec4(0x0001000eu,0xf1f10229u,0xf1f1f1f1u,0x21f1f1f1u),\nuvec4(0x0689f906u,0x0d0b0621u,0x110689f9u,0x0699f906u),\nuvec4(0xdc0e0211u,0xf90011cau,0x061100a9u,0x0b0d89f9u),\nuvec4(0xfb061106u,0x01000d8bu,0xf1f13900u,0xf1f1f1f1u),\nuvec4(0x00f1f1f1u,0x89f90611u,0x0b092106u,0x110299f9u),\nuvec4(0x0699f906u,0xdc0b0611u,0x000100cau,0x1100a9f9u),\nuvec4(0x0d89f906u,0x0611060bu,0x0d7bfb0eu,0x39000100u),\nuvec4(0xf1f1f100u,0xf1f1f1f1u,0x1106e1f1u,0x0689f906u),\nuvec4(0xf90b0621u,0x06110299u,0x000699f9u,0x0dc90001u),\nuvec4(0x0011ca0cu,0x1100a9f9u,0x0d89f906u,0x0611060bu),\nuvec4(0x0d7bfb0eu,0x39000100u,0xf1f1f106u,0xf1f1f1f1u),\nuvec4(0x0600d1f1u,0x89f90611u,0x0b092106u,0x0289f90du),\nuvec4(0x99f90611u,0x0b06f106u,0xf90011cau,0x061100a9u),\nuvec4(0x0b0d89f9u,0x0e061106u,0x000d7bfbu,0x06390001u),\nuvec4(0xf1f1f100u,0xf1f1f1f1u,0x1116c1f1u,0x0689f906u),\nuvec4(0xf90b0921u,0x06110099u,0xf10699f9u,0x00ca0b09u),\nuvec4(0xa9f90001u,0x0d061100u,0x0c0d79f9u,0x0e061106u),\nuvec4(0x000d7bfbu,0x00490001u,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0x060900b1u,0x89f90611u,0x0b092106u,0x0289f90du),\nuvec4(0xf9060001u,0x06f10699u,0x0100ca0eu,0xf6090600u),\nuvec4(0x02110086u,0x0b0986f6u,0x0e061106u,0x000d7bfbu),\nuvec4(0x00093611u,0xf1f1f1f1u,0xf1f1f1f1u,0x000600b1u),\nuvec4(0x89f90611u,0x0b092106u,0x0086f609u,0x96f60211u),\nuvec4(0x0b06f100u,0xf1f1f1cau,0x060e06a1u,0xfb0e0611u),\nuvec4(0x61000d7bu,0xf1f1f100u,0xf1f1f1f1u,0x2100c1f1u),\nuvec4(0x0689f906u,0x000d0921u,0xf1f1f1f1u,0xca0b0971u),\nuvec4(0xa1f1f1f1u,0x11060e06u,0x7bfb0d06u,0xf1f1000du),\nuvec4(0xf1f1f1f1u,0x81f1f1f1u,0x0689f906u,0x000d0921u),\nuvec4(0xf1f1f1f1u,0xca0b0971u,0x06000100u,0x06090619u),\nuvec4(0x0619b639u,0x06110019u,0x0946f609u,0x020b0d16u),\nuvec4(0xfb0e0611u,0x01000d7bu,0x06490600u,0xf1f1f100u),\nuvec4(0xf1f1f1f1u,0x090281f1u,0x06110206u,0x210689f9u),\nuvec4(0x06090b09u,0xf6091609u,0x06110036u,0x26091619u),\nuvec4(0x06590679u,0xf1000609u,0x00ca0b06u,0xa9f90001u),\nuvec4(0xf9061100u,0x060b0d89u,0x8bfb0911u,0x0001000du),\nuvec4(0xf1f10269u,0xf1f1f1f1u,0x0071f1f1u,0x06110629u),\nuvec4(0x210689f9u,0x99f90b09u,0x06000106u,0xf10699f9u),\nuvec4(0x00ca0b09u,0xa9f90001u,0xf9061100u,0x060b0d89u),\nuvec4(0x8bfb0911u,0x6900110du,0xf1f10006u,0xf1f1f1f1u),\nuvec4(0x0661f1f1u,0x06110629u,0x210689f9u,0x99f90b09u),\nuvec4(0xf9061102u,0x09f10699u,0x0100ca0bu,0x00a9f900u),\nuvec4(0x89f90611u,0x11020b0du,0x0d8bfb09u,0x79000100u),\nuvec4(0xf1f1f102u,0xf1f1f1f1u,0x390051f1u,0xf9061106u),\nuvec4(0x09210689u,0x0299f90bu,0x99f90611u,0x0b06f106u),\nuvec4(0x000100cau,0x1100a9f9u,0x0d89f906u,0x0911020bu),\nuvec4(0x000d8bfbu,0x00890001u,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0x06390641u,0x89f90611u,0x0b092106u,0x110299f9u),\nuvec4(0x0699f906u,0xca0b09f1u,0xf9000100u,0x061100a9u),\nuvec4(0x0b0d89f9u,0x0e061106u,0x000d7bfbu,0x06890001u),\nuvec4(0xf1f1f1f1u,0xf1f1f1f1u,0x06490031u,0x89f90611u),\nuvec4(0x0b092106u,0x110099f9u,0x0699f906u,0xca0b09f1u),\nuvec4(0xf9000100u,0x061100a9u,0x0b0d89f9u,0x0e061106u),\nuvec4(0x0e9b0e7bu,0x0d1b0e0bu,0x99000100u,0xf1f1f100u),\nuvec4(0xf1f1f1f1u,0x490621f1u,0xf9061106u,0x09210689u),\nuvec4(0x0299f90bu,0x99f90611u,0x0b09f106u,0x000100cau),\nuvec4(0x1100a9f9u,0x0d89f906u,0x0911060bu,0x0c1b3c0bu),\nuvec4(0x0c6b1c1bu,0x000e1c2bu,0x06990001u,0xf1f1f100u),\nuvec4(0xf1f1f1f1u,0x590001f1u,0xf9061106u,0x09210689u),\nuvec4(0x0299f90bu,0x99f90611u,0x0b06f106u,0x000100cau),\nuvec4(0x1100a9f9u,0x0d89f906u,0x0911060bu,0x0b7cfc0bu),\nuvec4(0xa9000102u,0xf1f1f106u,0xf1f1f1f1u,0x066901f1u),\nuvec4(0x89f90611u,0x09110006u,0x0299f90bu,0x99f90611u),\nuvec4(0x0b09f106u,0x000100cau,0x1100a9f9u,0x0d89f906u),\nuvec4(0x0911060bu,0x0b7cfc0bu,0xa9000102u,0xf1f10006u),\nuvec4(0xf1f1f1f1u,0x6906e1f1u,0xf9061106u,0x11000689u),\nuvec4(0x99f90b09u,0xf9061102u,0x06f10699u,0x0011ca0bu),\nuvec4(0x1100a9f9u,0x0d89f906u,0x0611060bu,0x0b7cfc0bu),\nuvec4(0xb9000102u,0xf1f1f106u,0xf1f1f1f1u,0x067900d1u),\nuvec4(0x89f90611u,0x09110006u,0x0299f90bu,0x99f90611u),\nuvec4(0x0b06f106u,0xf90011cau,0x061100a9u,0x0b0d89f9u),\nuvec4(0x0b061106u,0x000b7cfcu,0x02c90001u,0xf1f1f1f1u),\nuvec4(0xc1f1f1f1u,0x06110689u,0x000689f9u,0xf90b0911u),\nuvec4(0x06110299u,0xf10699f9u,0x11ca0b09u,0x00a9f900u),\nuvec4(0x89f90611u,0x11060b0du,0x7cfc0b06u,0x0001000bu),\nuvec4(0xf1f102d9u,0xf1f1f1f1u,0x8906a1f1u,0xf9061106u),\nuvec4(0x11000689u,0x99f90b09u,0xf9061102u,0x06f10699u),\nuvec4(0x0011ca0bu,0x1100a9f9u,0x0d89f906u,0x0611060bu),\nuvec4(0x0b7cfc0bu,0xd9000100u,0xf1f10006u,0xf1f1f1f1u),\nuvec4(0x990081f1u,0xf9061106u,0x11000689u,0x99f90b09u),\nuvec4(0xf9061102u,0x06f10699u,0x0100ca0bu,0x00a9f900u),\nuvec4(0x89f90611u,0x11060b0du,0x7cfc0b06u,0x0001020bu),\nuvec4(0xf10006e9u,0xf1f1f1f1u,0xa971f1f1u,0xf9061106u),\nuvec4(0x11000689u,0x99f90b09u,0xf9061102u,0x06f10699u),\nuvec4(0x0100ca0bu,0x00a9f900u,0x89f90611u,0x11060b0du),\nuvec4(0x7cfc0b06u,0x0001020bu,0xf1f102f9u,0xf1f1f1f1u),\nuvec4(0x06b961f1u,0x89f90611u,0x09110006u,0x0299f90bu),\nuvec4(0x99f90611u,0x0b06f106u,0x000100cau,0x1100a9f9u),\nuvec4(0x0d89f906u,0x0611060bu,0xac2b9c0bu,0x0001020bu),\nuvec4(0xf10609f9u,0xf1f1f1f1u,0x0641f1f1u,0x061106b9u),\nuvec4(0x000689f9u,0x0d0b0911u,0x110689f9u,0x0699f906u),\nuvec4(0xca0b06f1u,0xf9000100u,0x061100a9u,0x0b0d89f9u),\nuvec4(0x0b061106u,0x0bac2b9cu,0xf9000102u,0xf1f10019u),\nuvec4(0xf1f1f1f1u,0xc90221f1u,0xf9061106u,0x11000689u),\nuvec4(0xf90d0b09u,0x06110289u,0xf10699f9u,0x00ca0d06u),\nuvec4(0xa9f90001u,0xf9061100u,0x060b0d89u,0xfc0b0611u),\nuvec4(0x01000b7cu,0x0029f900u,0xf1f1f1f1u,0x01f1f1f1u),\nuvec4(0x1106d900u,0x0689f906u,0x0b091100u,0x0289f90du),\nuvec4(0x99f90611u,0x06001106u,0x0b190699u,0x000100cau),\nuvec4(0x1100a9f9u,0x0d89f906u,0x0611060bu,0x0b7cfc0bu),\nuvec4(0xf9000100u,0xf1f10039u,0xf1f1f1f1u,0x06e900e1u),\nuvec4(0x89f90611u,0x09110006u,0x89f90d0bu,0xf9061102u),\nuvec4(0x06110699u,0x11cadc0bu,0x00a9f900u,0x89f90611u),\nuvec4(0x11060b0du,0x7cfc0b09u,0x0001000bu,0xf10639f9u),\nuvec4(0xf1f1f1f1u,0xf900d1f1u,0xf9061106u,0x11000689u),\nuvec4(0xf90d0b09u,0x06110289u,0x110699f9u,0xcadc0b06u),\nuvec4(0xf9000100u,0x061100a9u,0x0b0d89f9u,0x0b061106u),\nuvec4(0x000b7cfcu,0x49f90001u,0xf1f10006u,0xf1f1f1f1u),\nuvec4(0xf90600a1u,0xf9061106u,0x11000689u,0xf90d0b09u),\nuvec4(0x06110289u,0x110699f9u,0xcadc0e02u,0xf9000100u),\nuvec4(0x061100a9u,0x0b0d89f9u,0x0b061106u,0x000b7cfcu),\nuvec4(0x59f90001u,0xf1f10006u,0xf1f1f1f1u,0xf9060081u),\nuvec4(0x06110609u,0x000689f9u,0x0d0b0911u,0x110289f9u),\nuvec4(0x0699f906u,0xdc0e0211u,0x000100cau,0x1100a9f9u),\nuvec4(0x0d89f906u,0x0611060bu,0x0b7cfc0bu,0xf9000100u),\nuvec4(0xf1f10079u,0xf1f1f1f1u,0x29f90061u,0xf9061106u),\nuvec4(0x11000689u,0xf90d0b09u,0x06110689u,0x110699f9u),\nuvec4(0xcadc0e02u,0xf9000100u,0x061102a9u,0x0b0d89f9u),\nuvec4(0x0b061106u,0x000b7cfcu,0x89f90001u,0xf1f1f106u),\nuvec4(0x41f1f1f1u,0x0639f900u,0x99f90611u,0x0b091100u),\nuvec4(0x0289f90du,0x99f90611u,0x0e061106u,0x0100cadcu),\nuvec4(0x99f90600u,0xf9061100u,0x11060b99u,0x8cfc0b09u),\nuvec4(0xf9000102u,0xf1000699u,0xf1f1f1f1u,0xf90011f1u),\nuvec4(0x06110649u,0x110099f9u,0xf90d0b06u,0x06110289u),\nuvec4(0x110699f9u,0xcadc0e06u,0xf9000100u,0x000102a9u),\nuvec4(0x0d89f906u,0x0611060bu,0x0b7cfc0eu,0xf9000102u),\nuvec4(0xf1f102a9u,0xf1f1f1f1u,0x59f90001u,0xf9021106u),\nuvec4(0x09110099u,0x89f90d0bu,0xf9061106u,0x00110699u),\nuvec4(0x00cadc0du,0x0b0d0001u,0x1b7c0b2cu,0x0b1c0b7cu),\nuvec4(0x0b3c1b1eu,0x1c1b0cfcu,0xf6001106u,0xf0110096u),\nuvec4(0xf1f1f1b0u,0x01f1f1f1u,0x002160f0u,0x46f60226u),\nuvec4(0x0b062102u,0x1cfc0b3cu,0x1e0b1c0bu,0x6cfc0b2cu),\nuvec4(0x0601000du,0x00cadc0bu,0x09060001u,0x290d090du),\nuvec4(0x198dfdfdu,0x0002293du,0xf1f1f1f1u,0xf1f1f1f1u),\nuvec4(0xf1f1f1f1u,0x190231f1u,0x091d090du,0x394d29fdu),\nuvec4(0x097d298du,0x0100090du,0xcadc0b06u,0x01000100u),\nuvec4(0xf1103100u,0x41f11041u,0x11002110u,0xd0f00100u),\nuvec4(0xf1d0f001u,0xf1f1f1f1u,0xf0011091u,0x1160f0f0u),\nuvec4(0x01000100u,0x2081f110u,0x211041f1u,0xcadc0d00u),\nuvec4(0x0d000100u,0xfb0c9bfbu,0x0d0006dbu,0xcbfbfbfbu),\nuvec4(0xf106090eu,0xf1f1f1f1u,0xfb0e0951u,0x098bfbfbu),\nuvec4(0xdbfb0600u,0x099bfb0cu,0x0b060100u,0x0100cadcu),\nuvec4(0x0b0e0900u,0x0b0e0d1eu,0x290d1efeu,0x7efe0b0du),\nuvec4(0x01060c0bu,0x4efe0c0bu,0x0d293e0bu,0xfe0b1e0bu),\nuvec4(0x0d190d5eu,0x020d0c0bu,0xf1f1f1f1u,0x060021f1u),\nuvec4(0x3e1b0d09u,0x0d2efe0bu,0x0b7e0d19u,0x0bde0b0eu),\nuvec4(0x09000d0cu,0x1b0e0b0cu,0x190d5efeu,0x099efe0du),\nuvec4(0xdc0b0611u,0x000100cau,0x1100a9f9u,0x0d89f906u),\nuvec4(0x1e01060bu,0x210689f9u,0x1100a9f9u,0x00063906u),\nuvec4(0xf1f1f1f1u,0x110006f1u,0x0699f906u,0x99f90011u),\nuvec4(0x0901090bu,0x0099f90bu,0x99f90611u,0x0e061106u),\nuvec4(0x0100cadcu,0x00a9f900u,0x89f90611u,0x00060b0du),\nuvec4(0x99f90e0bu,0xf9000100u,0x061100a9u,0xf1f10059u),\nuvec4(0x00c1f1f1u,0x06110016u,0x110699f9u,0x0b99f902u),\nuvec4(0x0b090109u,0x110099f9u,0x0699f906u,0xdc0e0611u),\nuvec4(0x000100cau,0x1100a9f9u,0x0d89f906u,0x0b00060bu),\nuvec4(0x0099f90eu,0xa9f90001u,0x79061100u,0xf1f1f100u),\nuvec4(0x290691f1u,0xf9061102u,0x02110699u,0x0d0b99f9u),\nuvec4(0xf90b0900u,0x06110099u,0x110699f9u,0xcadc0e06u),\nuvec4(0xf9000100u,0x061100a9u,0x0b0d89f9u,0x0e0b0102u),\nuvec4(0x010099f9u,0x00a9f900u,0x00990611u,0xf1f1f1f1u),\nuvec4(0x02490651u,0x99f90611u,0xf9001106u,0x000d0b99u),\nuvec4(0x99f90b09u,0xf9061102u,0x06110699u,0x00cadc0eu),\nuvec4(0xa9f90001u,0xf9061100u,0x060b0d89u,0xf90e0b01u),\nuvec4(0x00010099u,0x1100a9f9u,0xf100b906u,0x11f1f1f1u),\nuvec4(0x11026906u,0x0699f906u,0x99f90011u,0x09000d0bu),\nuvec4(0x0099f90bu,0x99f90611u,0x0e061106u,0x0100cadcu),\nuvec4(0x00a9f900u,0xf9060011u,0x060c0d79u,0x99f91e01u),\nuvec4(0xf9000100u,0x061100a9u,0xf1f100d9u,0x0200c1f1u),\nuvec4(0x02590619u,0x99f90611u,0xf9001106u,0x000d0b99u),\nuvec4(0xf90d0b09u,0x06210679u,0x110699f9u,0xcadc0e02u),\nuvec4(0xf9000100u,0x002100a9u,0x0d69f906u,0x1e01060cu),\nuvec4(0x110099f9u,0x1100a9f9u,0xf102f906u,0x0081f1f1u),\nuvec4(0x1102a906u,0x0699f906u,0x99f90011u,0x09000d0bu),\nuvec4(0x69f90d0bu,0xf9063106u,0x02110699u,0x00cadc0eu),\nuvec4(0xa9f90001u,0x06003100u,0x060c69f9u,0x99f91e01u),\nuvec4(0xa9f91100u,0xf9061100u,0xf1f10029u,0x060231f1u),\nuvec4(0x061102c9u,0x110699f9u,0x0b99f900u,0x0b09000du),\nuvec4(0x0659f90du,0x99f90641u,0x0e021106u,0x0009badcu),\nuvec4(0x99f90001u,0xf9066106u,0x060c0d49u,0xf90b0d01u),\nuvec4(0xf9110099u,0x061100a9u,0x410059f9u,0x61f1f100u),\nuvec4(0x02f90610u,0x99f90611u,0xf9001106u,0x000d0b99u),\nuvec4(0x59f90b09u,0xf9066106u,0x02110689u,0x0d0bdc0eu),\nuvec4(0x0d0b1d6au,0xf9000100u,0x00710289u,0x0d39f906u),\nuvec4(0x0e01060cu,0x0099f90bu,0x00a9f911u,0x79f90611u),\nuvec4(0xf1000206u,0x061051f1u,0x110229f9u,0x0699f906u),\nuvec4(0x99f90011u,0x09010d0bu,0x0249f90bu,0x06310031u),\nuvec4(0x110679f9u,0x1cdc0e02u,0x1c0b0c5bu,0x0001000bu),\nuvec4(0x310279f9u,0x21000906u,0x29f90600u,0x01060c0du),\nuvec4(0x99f90b0eu,0xa9f91100u,0xf9061100u,0x060c0d89u),\nuvec4(0xf1000601u,0x160100c1u,0x110069f9u,0x0699f906u),\nuvec4(0x99f90011u,0x09010d0bu,0x0639f90bu,0x06090031u),\nuvec4(0x69f90631u,0x0e021106u,0x000bbcdcu,0x69f90001u),\nuvec4(0x0b063102u,0x0031000eu,0x0d19f906u,0x0e01060cu),\nuvec4(0x0099f90bu,0xa9f90001u,0xf9061100u,0x0c0d0679u),\nuvec4(0x091e0106u,0x21f10026u,0x09011600u,0x0099f90bu),\nuvec4(0x99f90611u,0xf9001106u,0x010d0b99u,0x29f90b09u),\nuvec4(0x0b064106u,0x0021060du,0x0659f906u,0xdc0e0611u),\nuvec4(0x01000bbcu,0x0259f900u,0x0e0b0631u,0x00090102u),\nuvec4(0x09f90631u,0x01060b0du,0x99f90b0eu,0xf9000100u),\nuvec4(0x061100a9u,0x0c0d89f9u,0x0b0d0106u,0x00123679u),\nuvec4(0x0b690612u,0x0c09010du,0x110099f9u,0x0699f906u),\nuvec4(0x99f90011u,0x09010d0bu,0x0219f90bu,0x06011631u),\nuvec4(0x31000d0eu,0x0649f906u,0xdc0e0611u,0x01000bbcu),\nuvec4(0x0049f900u,0x0e0b0631u,0x060c0910u,0xf9060031u),\nuvec4(0x01060b0du,0x99f90b0eu,0xf9000100u,0x061100a9u),\nuvec4(0x0c0d89f9u,0x0b0e0006u,0x02810269u,0x01090c69u),\nuvec4(0x99f90b09u,0xf9061100u,0x00110699u,0x0d0b99f9u),\nuvec4(0xf90b0901u,0x0d410009u,0x0901060cu,0x21020e0bu),\nuvec4(0x39f90600u,0x0e061106u,0x000bbcdcu,0x39f90001u),\nuvec4(0x0b063100u,0x0901000eu,0x1001090cu,0x0de90631u),\nuvec4(0x0e00060bu,0x1199f90bu,0x00a9f900u,0x89f90611u),\nuvec4(0x01020b0du,0x06790b0eu,0x36020100u,0x0c690201u),\nuvec4(0x0b09010du,0x0089f90du,0x99f90611u,0xf9001106u),\nuvec4(0x010d0b99u,0x02f90b09u,0x0d100231u,0x0601090bu),\nuvec4(0x31060d0eu,0x0629f906u,0xdc0e0611u,0x01000bbcu),\nuvec4(0x0029f900u,0x001e0631u,0x090b0d01u,0x090b0601u),\nuvec4(0x06210001u,0x060b0dd9u,0xf90b0e00u,0xf9001199u),\nuvec4(0x061100a9u,0x0b0d89f9u,0x0b0e0106u,0x06010089u),\nuvec4(0x59000139u,0x010d0c06u,0x99f90c09u,0xf9061100u),\nuvec4(0x00110699u,0x0d0b99f9u,0xe90b0901u,0x1d003100u),\nuvec4(0x090b0d10u,0x0d0b0600u,0xf9063106u,0x06110619u),\nuvec4(0x0bbcdc0eu,0xf9000100u,0x06310019u,0x01000b0eu),\nuvec4(0x01090c0du,0x51061b06u,0x0b0dc906u,0x0b0e0006u),\nuvec4(0x001199f9u,0x1100a9f9u,0x0d89f906u,0x1e01060bu),\nuvec4(0x49010089u,0x090c6916u,0xf90c0901u,0x06110099u),\nuvec4(0x110699f9u,0x0b99f900u,0x0b09010du,0x103102d9u),\nuvec4(0x100d0b09u,0x00090b0du,0x020d0b06u,0x09f90631u),\nuvec4(0x0e061106u,0x000bbcdcu,0x09f90001u,0x1b063100u),\nuvec4(0x090b0910u,0x0e0b0600u,0x0d090102u,0x06002100u),\nuvec4(0x060c0db9u,0xf90b0e00u,0xf9001199u,0x061100a9u),\nuvec4(0x0c0d89f9u,0x0b0e0106u,0x06010089u,0x010d0cc9u),\nuvec4(0x99f90c09u,0xf9061100u,0x00110699u,0x0d0b99f9u),\nuvec4(0xc90b0901u,0x0d003102u,0x0b060109u,0x0b0d100du),\nuvec4(0x0b060006u,0x0631060eu,0x061106f9u,0x0bbcdc0eu),\nuvec4(0xf9000102u,0x0b063102u,0x0d01000eu,0x0201090bu),\nuvec4(0x01060b0eu,0x51090c09u,0x0c0da906u,0x0b0e0106u),\nuvec4(0x001199f9u,0x1100a9f9u,0x0d89f906u,0x0e01060cu),\nuvec4(0x4100890bu,0x010d0c99u,0x99f90c09u,0xf9061100u),\nuvec4(0x00110699u,0x0d0b99f9u,0xb90b0901u,0x0d103102u),\nuvec4(0x0901090bu,0x09100d0bu,0x0601090cu,0x31060d0bu),\nuvec4(0x1106e906u,0xbcdc0e06u,0x0001020bu,0x063100e9u),\nuvec4(0x0901001eu,0x0e10090cu,0x0901060cu,0x06000d0cu),\nuvec4(0x06310209u,0x060c0d99u,0xf90b0e01u,0xf9001199u),\nuvec4(0x061100a9u,0x0c0d89f9u,0x0b0e0106u,0x00010089u),\nuvec4(0x0b990012u,0x0b09010du,0x110299f9u,0x0699f906u),\nuvec4(0x99f90011u,0x09010d0bu,0x3100a90bu,0x0d100902u),\nuvec4(0x0901060bu,0x0d100d0bu,0x0600090bu,0x31020e0bu),\nuvec4(0x1106d902u,0xbcdc0e02u,0x0001020bu,0x063100d9u),\nuvec4(0x01000e0bu,0x01090c0du,0x01061b02u,0x010d0b09u),\nuvec4(0x41061b00u,0x0c0d8906u,0x0b0d0106u,0x010099f9u),\nuvec4(0x00a9f900u,0x89f90611u,0x01060c0du,0x00890b0eu),\nuvec4(0x0bc90601u,0x0b09010du,0x110299f9u,0x0699f906u),\nuvec4(0x99f90011u,0x09010d0bu,0x4102990bu,0x100d0b06u),\nuvec4(0x01090b0du,0x020d0b06u,0x090c0900u,0x0e0b0601u),\nuvec4(0xc9023102u,0x0e021106u,0x020bbcdcu,0x00c90001u),\nuvec4(0x0d0b0631u,0x0b0d0106u,0x0e060109u,0x0901060bu),\nuvec4(0x02010d0cu,0x01090b0du,0x06002116u,0x060c0d79u),\nuvec4(0xf90b0e01u,0x00010099u,0x1100a9f9u,0x0d89f906u),\nuvec4(0x0e01060cu,0x0100890bu,0x0d0cc906u,0xf90b0901u),\nuvec4(0x06110099u,0x110699f9u,0x0b99f900u,0x0b09010du),\nuvec4(0x06310289u,0x0b090102u,0x0c0d100du,0x0e090109u),\nuvec4(0x0d00060du,0x0601090bu,0x0031061bu,0x021106b9u),\nuvec4(0x0bbcdc0eu,0xa9000102u,0x06310006u,0x0901001bu),\nuvec4(0x0201090cu,0x0901061bu,0x0d110d0cu,0x0901090cu),\nuvec4(0x0641090bu,0x060c0d69u,0xf90b0e01u,0xf9110099u),\nuvec4(0x061100a9u,0x0c0d89f9u,0x0b0e0106u,0x06010089u),\nuvec4(0x010d0cc9u,0x99f90c09u,0xf9061100u,0x00110699u),\nuvec4(0x0d0b99f9u,0x790b0901u,0x0b094102u,0x0c090109u),\nuvec4(0x0b0e100du,0x0b090009u,0x0c09100du,0x1e060109u),\nuvec4(0xa9063106u,0x0e021106u,0x020bbcdcu,0x00a90001u),\nuvec4(0x0d0b0631u,0x090c0d10u,0x061b0601u,0x0d0b0901u),\nuvec4(0x061b0001u,0x0d0c0901u,0x31000100u,0x0c0d5906u),\nuvec4(0x0b0e0006u,0x110099f9u,0x1100a9f9u,0x0d89f906u),\nuvec4(0x0e01060cu,0x1106790bu,0x0cb90600u,0x0c09010du),\nuvec4(0x110099f9u,0x0699f906u,0x99f90011u,0x09010d0bu),\nuvec4(0x00590d0bu,0x1e020041u,0x0b090106u,0x0d00020du),\nuvec4(0x0600060bu,0x00020d0bu,0x01090b09u,0x060e0b06u),\nuvec4(0x06990231u,0xdc0e0611u,0x01000bbcu,0x00068900u),\nuvec4(0x0d0b0931u,0x090c0d10u,0x021b0601u,0x090c0901u),\nuvec4(0x0c0b0001u,0x0c090106u,0x0d0e100du,0x49063100u),\nuvec4(0x00060b0du,0x1199f91eu,0x02a9f900u,0x89f90611u),\nuvec4(0x01060c0du,0x02690b0eu,0x0cb90031u,0x0b090109u),\nuvec4(0x110099f9u,0x0699f906u,0x99f90211u,0x0901090bu),\nuvec4(0x00490d0bu,0x101d0031u,0x01060b0eu,0x100d0b09u),\nuvec4(0x00090b0du,0x060e0b09u,0x090c0d01u,0x0e0d0600u),\nuvec4(0x89023106u,0x0e061106u,0x000bbcdcu,0x00890001u),\nuvec4(0x0d0b0631u,0x090c0d10u,0x001b0601u,0x090c0901u),\nuvec4(0x021b0601u,0x0d0c0901u,0x060c0e10u,0x39060041u),\nuvec4(0x01060c0du,0x0099f91bu,0xa9f90001u,0xf9061100u),\nuvec4(0x01060c99u,0x36790b0eu,0x01090bc9u,0x99f90b09u),\nuvec4(0xf9061100u,0x02110699u,0x0d0b99f9u,0x390b0901u),\nuvec4(0x00410006u,0x00090b09u,0x060b0d02u,0x090b0900u),\nuvec4(0x090b0d10u,0x0d0e0900u,0x0b0d0006u,0x1d060009u),\nuvec4(0x00210006u,0x06110679u,0x0bbcdc0eu,0x76000100u),\nuvec4(0x0d0b0641u,0x090b0d10u,0x061b0601u,0x090c0901u),\nuvec4(0x021b0201u,0x0d0b0900u,0x060c0d10u,0x000d0901u),\nuvec4(0x09360021u,0x0e01060bu,0x2196f60du,0x0096f602u),\nuvec4(0x76f60011u,0x060b0902u,0xf60d0e01u,0x01090b86u),\nuvec4(0x96f60b09u,0xf6021100u,0x00110096u,0x0d0e96f6u),\nuvec4(0x090e0901u,0x00310026u,0x09000609u,0x0200090bu),\nuvec4(0x0900061eu,0x02000d0bu,0x00090b0du,0x100d0e09u),\nuvec4(0x00090b0du,0x060e0b06u,0x00660031u,0xdc0e0611u),\nuvec4(0xd1000bbcu,0x010e0b09u,0x090c0d00u,0x001b0601u),\nuvec4(0x090c0901u,0x0c0b0201u,0x0c090106u,0x0c0e100du),\nuvec4(0x0c090109u,0x0671000eu,0x0e01060eu,0xf1f1f109u),\nuvec4(0x0641f1f1u,0x0e01020eu,0x0d81f109u,0x0b090109u),\nuvec4(0xf1f1f1f1u,0x090d51f1u,0x000d0901u,0x0e0b0271u),\nuvec4(0x0b090002u,0x0b0e100du,0x0b090006u,0x0b0d100du),\nuvec4(0x0e060009u,0x0b0d100du,0x0e060009u,0x02d1060du),\nuvec4(0x0c0ebd09u,0x21000bbcu,0x21100100u,0x0b091100u),\nuvec4(0x0c0d100du,0x0b060109u,0x0901000du,0x0201090cu),\nuvec4(0x0901061bu,0x0e100d0cu,0x0901060cu,0x31000d0cu),\nuvec4(0x06200100u,0x0e00060eu,0x21101109u,0x2100a100u),\nuvec4(0x2081f110u,0x90413011u,0x06011071u,0x0d00060du),\nuvec4(0x00110009u,0x00110001u,0x10315011u,0x00190001u),\nuvec4(0xf0010d09u,0x21303110u,0x01500120u,0x11101180u),\nuvec4(0xf1003120u,0x00010001u,0x090d0001u,0x060d0901u),\nuvec4(0x41000110u,0x060e0d06u,0x090b0900u,0x0e0d0600u),\nuvec4(0x0b090006u,0x0d02000du,0x0600090bu,0x00020e0bu),\nuvec4(0x00090b09u,0x51061e06u,0xc2000150u,0x0bbc0b09u),\nuvec4(0x06000100u,0x09410629u,0x0d10090bu,0x0601090bu),\nuvec4(0x01000e0bu,0x01090c09u,0x060e0b06u,0x0d0c0901u),\nuvec4(0x060b0e10u,0x0d0c0901u,0x39063100u,0x020b0906u),\nuvec4(0x060d0b01u,0x99f9f9f9u,0x0649f916u,0x06191609u),\nuvec4(0x06290619u,0x290619f9u,0xf9061906u,0xb9f91699u),\nuvec4(0xf9061906u,0x0b090669u,0x0b09010du,0x00020649u),\nuvec4(0x061e0621u,0x0d0b0900u,0x0e0d0200u,0x0b060006u),\nuvec4(0x0d02000du,0x0600090bu,0x00020e0bu,0x00090b09u),\nuvec4(0x31061d06u,0x02290600u,0x02000100u,0x0b091293u),\nuvec4(0x01000bbcu,0x090d0900u,0x09310006u,0x00010d0bu),\nuvec4(0x01090b0du,0x100d0b06u,0x01090c0du,0x01061b06u),\nuvec4(0x010d0c09u,0x060c0e00u,0x0e0c0901u,0x59063100u),\nuvec4(0x01020b0du,0xf9f9f91bu,0xf9f9f9f9u,0xf9f9f9f9u),\nuvec4(0x090be9f9u,0x590b0901u,0x06310006u,0x0900061du),\nuvec4(0x0600090bu,0x00060d0eu,0x00090b09u,0x090e0d06u),\nuvec4(0x0d0e0600u,0x0b090206u,0x0e060009u,0x1100060du),\nuvec4(0x06290600u,0xc3020100u,0x0dbb0b09u,0x19000100u),\nuvec4(0x09310006u,0x00010d0bu,0x01090c0du,0x000e0b06u),\nuvec4(0x0d0c0d01u,0x001b0601u,0x0d0c0901u,0x0c0e0001u),\nuvec4(0x0c090106u,0x0631000du,0x060b0d69u,0xf90e0b00u),\nuvec4(0xf9f9f9f9u,0xf9f9f9f9u,0xe9f9f9f9u,0x0900090bu),\nuvec4(0x1006690bu,0x0d0e0621u,0x0b090006u,0x0e020009u),\nuvec4(0x0900060bu,0x02000d0bu,0x00090b0du,0x020d0b09u),\nuvec4(0x090b0900u,0x0d0e0600u,0x19063106u,0xd3020006u),\nuvec4(0x0daa0c09u,0x19001109u,0x0b063100u,0x0d00010du),\nuvec4(0x0601090bu,0x01000e0cu,0x01090c0du,0x01061b02u),\nuvec4(0x01090c09u,0x01061b00u,0x000d0c09u,0x0d790631u),\nuvec4(0x1b00020bu,0xf9f9f9f9u,0xf9f9f9f9u,0xf9f9f9f9u),\nuvec4(0x01090be9u,0x00890b09u,0x061e0631u,0x0d0b0900u),\nuvec4(0x0e0d0600u,0x0b090009u,0x0b0d100du,0x0b090009u),\nuvec4(0x0900060du,0x0602090bu,0x21060e0du,0x06090600u),\nuvec4(0x09d30200u,0x1109ba0bu,0x11000600u,0x0c090100u),\nuvec4(0x0d00010du,0x0901060bu,0x0d100d0cu,0x0001090cu),\nuvec4(0x0901021bu,0x0201090cu,0x01060c0eu,0x000d0c09u),\nuvec4(0x00010001u,0x0c0d8906u,0xf91b0002u,0xf9f9f9f9u),\nuvec4(0xf9f9f9f9u,0xf90619f9u,0x090bb9f9u,0x990b0900u),\nuvec4(0x1e063102u,0x0b090006u,0x0d000209u,0x0900060eu),\nuvec4(0x00020d0bu,0x00090b0du,0x060d0e09u,0x090b0900u),\nuvec4(0x061d0602u,0x32001100u,0xba0b09d3u,0x0b097109u),\nuvec4(0x0b0e100du,0x0b060109u,0x0c0d100eu,0x1b020109u),\nuvec4(0x0c090106u,0x0b0e100du,0x0c090106u,0x0021000du),\nuvec4(0x0c0d9906u,0xf91e0006u,0xf9f9f9f9u,0xf9f9f9f9u),\nuvec4(0x160226d9u,0x0ba9f9f9u,0x0b090009u,0x063100a9u),\nuvec4(0x00060e0du,0x00090b09u,0x090e0d06u,0x0d0b0900u),\nuvec4(0x090b0d10u,0x0d0e0900u,0x0b090006u,0x1d060209u),\nuvec4(0x20110006u,0x0b09d302u,0x0b0961cau,0x0e00010du),\nuvec4(0x0601060bu,0x0d100e0bu,0x0601090cu,0x01000c0bu),\nuvec4(0x010d0c09u,0x01061b00u,0x000d0c09u,0x06110001u),\nuvec4(0x060c0da9u,0xf9f91e00u,0xf9f9f9f9u,0x99f9f9f9u),\nuvec4(0xf9061266u,0x090ba9f9u,0xb90b0900u,0x0d023102u),\nuvec4(0x0900060eu,0x0d100d0bu,0x0900060eu,0x00020d0eu),\nuvec4(0x00090b0du,0x060d0e06u,0x090b0900u,0x061d0600u),\nuvec4(0xd3023100u,0x21ca0b09u,0x0b091100u,0x0d00010du),\nuvec4(0x0601060bu,0x01000e0cu,0x01090c0du,0x01021b06u),\nuvec4(0x01090b09u,0x060c0b00u,0x0d0c0901u,0x0db90641u),\nuvec4(0x0e00060cu,0xf9f9f90bu,0xf9f9f9f9u,0x0699f9f9u),\nuvec4(0x26091619u,0x0bb9f9f9u,0x0b090009u,0x023102c9u),\nuvec4(0x00060e0du,0x000d0b09u,0x060e0d06u,0x0d0b0900u),\nuvec4(0x090b0910u,0x0d0e0600u,0x0b0d0006u,0x0d060009u),\nuvec4(0x0100060eu,0x09d31200u,0x0941ca0cu,0x1b10090bu),\nuvec4(0x0b090106u,0x0c0d100eu,0x0b060109u,0x0901020eu),\nuvec4(0x0001090cu,0x0901061bu,0x31000d0cu,0x0c0dc906u),\nuvec4(0x0b0e0006u,0xf9f9f9f9u,0xf9f9f9f9u,0x0916c9f9u),\nuvec4(0xf9060206u,0x090bb9f9u,0xd90b0900u,0x06210002u),\nuvec4(0x00090e0du,0x000d0b09u,0x090e0d06u,0x0d0e0602u),\nuvec4(0x090e0d12u,0x0e0d0600u,0x0e090006u,0x0d060009u),\nuvec4(0x0102090eu,0x09d30200u,0x0021ca0cu,0x010d0b09u),\nuvec4(0x090b0d00u,0x0d0b0600u,0x090c0d10u,0x0e0b0601u),\nuvec4(0x0c090106u,0x0e00010du,0x0901060cu,0x00110d0cu),\nuvec4(0x0dd90611u,0x1b00020cu,0x8649f9f9u,0x86299629u),\nuvec4(0xf9f9f9f9u,0x091659f9u,0xf9060206u,0x090bb9f9u),\nuvec4(0xe90b0900u,0x06210006u,0x00060b0du,0x16090e09u),\nuvec4(0x00060e0du,0x060d0b09u,0x090e0d02u,0x0d0e0600u),\nuvec4(0x0e090206u,0x0e060009u,0x0102090du,0x0c09d302u),\nuvec4(0x0c0921cau,0x0e000109u,0x0901060cu,0x01000d0cu),\nuvec4(0x01090c0eu,0x01001b06u,0x01090c0du,0x01061b02u),\nuvec4(0x31090c09u,0x0b0df900u,0x0e0b0002u,0x0649f9f9u),\nuvec4(0x06120642u,0x06720619u,0x02000619u,0x02061206u),\nuvec4(0xf9f90600u,0x59f9f9f9u,0x02060916u,0xb9f9f906u),\nuvec4(0x0900090bu,0x0206e90bu,0x1d022100u,0x0e090006u),\nuvec4(0x0d020009u,0x0900090eu,0x06020d0eu,0x02090e0du),\nuvec4(0x060d0e06u,0x090b0902u,0x0e0d0602u,0x09d31209u),\nuvec4(0x0611ca0cu,0x0001090bu,0x01060c0du,0x100d0c09u),\nuvec4(0x01090c0du,0x000b0c06u,0x090c0901u,0x061b0201u),\nuvec4(0x090c0901u,0x06002100u,0x020b0df9u,0xf9f91b00u),\nuvec4(0x06020639u,0x12293629u,0x06120639u,0x16000619u),\nuvec4(0x06021619u,0xf9f9f9f9u,0x091659f9u,0xf9160206u),\nuvec4(0x0d0ba9f9u,0xf90b0901u,0x21000609u,0x060e0d02u),\nuvec4(0x0d0e0900u,0x0b0d0200u,0x0e090009u,0x091d160du),\nuvec4(0x0d0e0900u,0x0e090006u,0x1d060209u,0x0b09e302u),\nuvec4(0x060011cau,0x060c0b10u,0x0d0b0901u,0x090c0d10u),\nuvec4(0x0e0b0601u,0x090c0d10u,0x061b0601u,0x090c0901u),\nuvec4(0x01000100u,0x0d19f900u,0x1b00020cu,0x0639f9f9u),\nuvec4(0x06190602u,0x02292609u,0x29164906u,0xf9264916u),\nuvec4(0xf9f9f9f9u,0x06091659u,0xf9f91602u,0x010d0ba9u),\nuvec4(0x19f90b09u,0x06210006u,0x00060e0du,0x060d0e09u),\nuvec4(0x090b0900u,0x0d0b0600u,0x0b090006u,0x1d090009u),\nuvec4(0x0b090006u,0x12091609u,0xca0b09d3u,0x01000100u),\nuvec4(0x060b0d00u,0x0d0b0901u,0x090c0d10u,0x0b0c0600u),\nuvec4(0x090c0910u,0x061b0001u,0x0d0c0901u,0x06002100u),\nuvec4(0x0c0d19f9u,0xf91b0002u,0x020639f9u,0x06020649u),\nuvec4(0x06191629u,0x00291219u,0x26021906u,0xf9f9f902u),\nuvec4(0x1669f9f9u,0x16020609u,0x0ba9f9f9u,0x0b09010du),\nuvec4(0x000629f9u,0x0e0d0621u,0x0b090006u,0x0d060209u),\nuvec4(0x0900090eu,0x09120d0eu,0x0600090bu,0x0900061eu),\nuvec4(0x10020d0bu,0x0b09d302u,0x061100cau,0x01060b0du),\nuvec4(0x100e0b09u,0x01090c0du,0x09101b06u,0x0001090cu),\nuvec4(0x01060b0eu,0x110d0c09u,0x39f91100u,0x00020c0du),\nuvec4(0xf9f90b0eu,0x06191639u,0x06020619u,0x06000619u),\nuvec4(0x06090619u,0x06190602u,0x00190602u,0xf9f9f936u),\nuvec4(0x1669f9f9u,0x16020609u,0x0ba9f9f9u,0x0b09010du),\nuvec4(0x000639f9u,0x0e0d0021u,0x0e090009u,0x0d00020du),\nuvec4(0x0600090bu,0x00060d0eu,0x02090b0du,0x060b0e06u),\nuvec4(0x090e0900u,0xd3020102u,0x00ca0c09u,0x0b0d0001u),\nuvec4(0x0c090106u,0x0b0d100du,0x1b060109u,0x0b0d0100u),\nuvec4(0x0c0b1009u,0x0c090106u,0x0600310du,0x0c0d39f9u),\nuvec4(0x0b0e0006u,0x0629f9f9u,0x16490600u,0x16492619u),\nuvec4(0x06020629u,0xf9f91649u,0x69f9f9f9u,0x02060916u),\nuvec4(0xa9f9f916u,0x09010d0bu,0x0649f90bu,0x0e0d0031u),\nuvec4(0x0b090009u,0x0d02000du,0x0600090eu,0x00060d0bu),\nuvec4(0x00090b09u,0x060d0e06u,0x0d0e0900u,0x09129332u),\nuvec4(0x0100ca0bu,0x00060d02u,0x100d0b09u,0x01090b0du),\nuvec4(0x00021b06u,0x00090c0du,0x01061b06u,0x000d0c09u),\nuvec4(0xf9060021u,0x060c0d49u,0xf90b0e00u,0x020629f9u),\nuvec4(0x02063906u,0x19261906u,0x12060906u,0x16292629u),\nuvec4(0xf9f90602u,0x69f9f9f9u,0x02060916u,0xa9f9f916u),\nuvec4(0x09010d0bu,0x0659f90bu,0x0d022100u,0x0900060bu),\nuvec4(0x09100d0eu,0x0600090eu,0x0e09121du,0x1e060009u),\nuvec4(0x02190206u,0x0dc90201u,0x0100ca0cu,0x09010600u),\nuvec4(0x0d100d0bu,0x0601090cu,0x01060e0bu,0x000d0c09u),\nuvec4(0x060b0e02u,0x0d0c0901u,0x00010011u,0x0c0d69f9u),\nuvec4(0x0b0e0006u,0x1619f9f9u,0x02063012u,0x10061906u),\nuvec4(0x06021622u,0x20020619u,0xf9061016u,0xf9f9f9f9u),\nuvec4(0x06091679u,0xf9f91602u,0x010d0ba9u,0x69f90b09u),\nuvec4(0x02210006u,0x00090e0du,0x060d0e06u,0x00091d00u),\nuvec4(0x060d0e09u,0x090e0902u,0x061d0600u,0x0b061112u),\nuvec4(0x0931cadcu,0x0d10090bu,0x0601090cu,0x0d01001bu),\nuvec4(0x0601090cu,0x01020e0bu,0x41090c09u,0x0d69f906u),\nuvec4(0x0e00060cu,0x29f9f90bu,0x09061936u,0x09162906u),\nuvec4(0x29260916u,0xf9560916u,0xf9f9f9f9u,0x06091689u),\nuvec4(0xf9f91602u,0x010d0ba9u,0x79f90b09u,0x00210006u),\nuvec4(0x0900091du,0x00060d0eu,0x00090b0du,0x160d0e06u),\nuvec4(0x02090e09u,0x00061d06u,0xdc0e0211u,0x000100cau),\nuvec4(0x100d0b09u,0x00090b0du,0x100d0b06u,0x01090c0du),\nuvec4(0x01061b02u,0x410d0c09u,0x0c0d89f9u,0xf91e0006u),\nuvec4(0xf9f9f9f9u,0xf9f9f9f9u,0x060916c9u,0xf9f91602u),\nuvec4(0x010d0ba9u,0xf90d0b09u,0x21000679u,0x090e0d00u),\nuvec4(0x0d0e0900u,0x090b0d12u,0x0d0b0600u,0x0b090206u),\nuvec4(0x0d060209u,0x0611090eu,0x00cadc0bu,0x0d0e0001u),\nuvec4(0x090c0d10u,0x0d0b0601u,0x090b0d10u,0x021b0601u),\nuvec4(0x090c0901u,0x11000100u,0x0d89f906u,0x1e00060cu),\nuvec4(0x8619f9f9u,0x96198639u,0xf9f9f9f9u,0x091689f9u),\nuvec4(0xf9060216u,0x0d0ba9f9u,0x0d0b0901u,0x310089f9u),\nuvec4(0x090e0d00u,0x0d0e0900u,0x0b090006u,0x0b060009u),\nuvec4(0x0900060du,0x0600090bu,0x0601001du,0x00cadc0bu),\nuvec4(0x10090001u,0x01090b0du,0x100e0b06u,0x01090b09u),\nuvec4(0x060b0e06u,0x090c0900u,0x11001100u,0x0d89f906u),\nuvec4(0x1e00060cu,0xf9f9f9f9u,0xf9f9f9f9u,0x0916c9f9u),\nuvec4(0xf9160206u,0x0d0ba9f9u,0xf90b0901u,0x06410099u),\nuvec4(0x00090e0du,0x020d0e09u,0x00091d00u,0x060d0e06u),\nuvec4(0x090b0900u,0x00090602u,0xdc0b0601u,0x200100cau),\nuvec4(0x01090b0du,0x100e0b06u,0x01090b0du,0x020e0b06u),\nuvec4(0x090c0d01u,0xf9060051u,0x060c0d89u,0xf9f91e00u),\nuvec4(0xf9f9f9f9u,0xc9f9f9f9u,0x06000236u,0x0ba9f9f9u),\nuvec4(0x0b09010du,0x510099f9u,0x090b0d00u,0x0d0e0900u),\nuvec4(0x0b0d0002u,0x1e060009u,0x0e0d0006u,0x06210209u),\nuvec4(0x00cadc0eu,0x0b0d0011u,0x0b060106u,0x0b0d100eu),\nuvec4(0x0b060009u,0x0901020eu,0x1031090cu,0x89f90611u),\nuvec4(0x00060c0du,0xf9f9f91eu,0xf9f9f9f9u,0x2699f9f9u),\nuvec4(0x00020612u,0xf9063206u,0x0d0b69f9u,0xf90b0901u),\nuvec4(0x20110299u,0x0b0d0011u,0x0e060009u,0x0e09160du),\nuvec4(0x0e060009u,0x0902060du,0x1100090eu,0xcadc0e06u),\nuvec4(0x09000100u,0x0901060bu,0x00020d0bu,0x00090b0du),\nuvec4(0x000e0b06u,0x090c0d01u,0x06002100u,0x99f91102u),\nuvec4(0x00060c0du,0xf9f90b0eu,0xf9f9f9f9u,0xa9f9f9f9u),\nuvec4(0xf9163926u,0x0d0ba9f9u,0xf90b0901u,0x16110299u),\nuvec4(0x0d002100u,0x0900090eu,0x00060d0eu,0x16090e0du),\nuvec4(0x0d09161du,0x06010009u,0x9a0ddc0bu,0x0100090du),\nuvec4(0x01090e02u,0x000e0b06u,0x090c0d01u,0x101b0601u),\nuvec4(0x310d0c09u,0x11001900u,0x0d89f906u,0x1b00060cu),\nuvec4(0xf9f9f9f9u,0xf9f9f9f9u,0xf9f9f9f9u,0x000d0be9u),\nuvec4(0xf90d0b09u,0x06110289u,0x21000609u,0x090e0900u),\nuvec4(0x0d0e0600u,0x0e090206u,0x0e090009u,0x0019160du),\nuvec4(0xdc0b0601u,0x2b1c4b0cu,0x01000e0cu,0x09010602u),\nuvec4(0x0d100e0bu,0x0601090cu,0x09100e0bu,0x0031090cu),\nuvec4(0x06110029u,0x0d79f90du,0x1b00060cu,0xf9f9f9f9u),\nuvec4(0xf9f9f9f9u,0xf9f9f9f9u,0x000d0be9u,0xf90d0c09u),\nuvec4(0x06110289u,0x2100190du,0x090e0900u,0x0d0e0902u),\nuvec4(0x00091d16u,0x160d0e09u,0x06000100u,0x0bbcdc0du),\nuvec4(0x0b092100u,0x0d01000du,0x0601090cu,0x00020e0bu),\nuvec4(0x31090c0du,0x06190600u,0xf9061100u,0x06090629u),\nuvec4(0x0d090619u,0x061d0002u,0xf9f90639u,0xe9f90629u),\nuvec4(0xf9060906u,0x06090649u,0x06091629u,0x09f90619u),\nuvec4(0x0609f906u,0x06c9f9f9u,0x06191609u,0x0e090669u),\nuvec4(0x0d090009u,0x06b90609u,0x01000699u,0x06290600u),\nuvec4(0x0e090031u,0x0e060009u,0x0900060du,0x0600090bu),\nuvec4(0x21060d0eu,0xbcdc0e06u,0x0621000bu,0x00010009u),\nuvec4(0x01000609u,0x11020906u,0x30410016u,0x1140f031u),\nuvec4(0x01200100u,0x02103110u,0x010001d0u,0x31d012c0u),\nuvec4(0x12d04100u,0x11a00110u,0x01502120u,0x01a01120u),\nuvec4(0x31e0f0f0u,0x401190f0u,0x11020001u,0x01800110u),\nuvec4(0x313021a0u,0x06020100u,0x16000102u,0x06020100u),\nuvec4(0x16000100u,0x0e022100u,0x000bbcdcu,0x20010091u),\nuvec4(0x00111002u,0x312021f1u,0x71108130u,0xc1503140u),\nuvec4(0x01201100u,0xf1201100u,0x20314031u,0x01f1f1f1u),\nuvec4(0x31300100u,0x3031f100u,0x00f15001u,0x00913071u),\nuvec4(0x00014081u,0x00e13001u,0x60011011u,0x06910001u),\nuvec4(0x0dccdc0du,0x06090d59u,0xa90d09d2u,0xd206090du),\nuvec4(0xe906d2f9u,0xe9a20422u,0xe906d206u,0x0900c100u),\nuvec4(0xd20609cdu,0xd2d90d09u,0x49e2e906u,0xc206890du),\nuvec4(0xc90d0906u,0x06c20006u,0xdc0b0d79u,0x090b4cfcu),\nuvec4(0x06048512u,0x09dc0e09u,0x0d14a502u,0x95140edcu),\nuvec4(0xcc0b0514u,0x3502090bu,0x0e145504u,0x04020ddcu),\nuvec4(0x04251445u,0x0bdc0906u,0xec09c109u,0x75040209u),\nuvec4(0x0ddc0e34u,0x14950206u,0x0ecc0b09u,0x04250409u),\nuvec4(0x0e091455u,0x040609dcu,0x04052455u,0x0ddc0d05u),\nuvec4(0x14851406u,0xfc7cfc0du,0x02050b4cu,0x05dc0ec5u),\nuvec4(0xdc0dc504u,0x04a5140eu,0x05dc0b05u,0xdc0ec502u),\nuvec4(0x04b5020du,0x000dec09u,0xdc0d02a1u,0xb502050bu),\nuvec4(0x0ddc0e04u,0x0504b504u,0x04050edcu,0x0bcc0ec5u),\nuvec4(0x0dc50405u,0xb5040ddcu,0x7cfc0504u,0x050b4cfcu),\nuvec4(0xdc0ec502u,0x040edcf5u,0xe5dc0bd5u,0x020ddc0eu),\nuvec4(0x9109fcd5u,0xec0b0900u,0x0ddc0ee5u,0xe50edce5u),\nuvec4(0xe50bcc0eu,0xe50ddc0du,0x5d6cfc0bu,0x0ee5ec0eu),\nuvec4(0x0edcf5dcu,0xe5dc0ee5u,0xe50ddc0eu,0x61000efcu),\nuvec4(0x0b060100u,0xdc0ee5fcu,0x0edce50du,0xe5dc0ee5u),\nuvec4(0xe50ddc0du,0x1b5d0eecu,0x0b064100u,0xdc0ee5dcu),\nuvec4(0x0edc0ee5u,0x0bcc0be5u,0xf5dc0ee5u,0x71090cfcu),\nuvec4(0xec0b0900u,0xdc0ee50bu,0x0edce50du,0x0bcc0ee5u),\nuvec4(0x0edc0ee5u,0x000ddce5u,0x0c093011u,0x0d004100u),\nuvec4(0x0ee50bccu,0x0edcf5dcu,0xe5dc0ee5u,0xfcf5dc0eu),\nuvec4(0x61060e0cu,0x0cfc0b06u,0x0edc0ee5u,0xe50edce5u),\nuvec4(0xe50bcc0eu,0xdcf5dc0eu,0x0951000du,0x0d02510bu),\nuvec4(0x0ee50bccu,0x0edcf5dcu,0x0b3c0ee5u,0xdc0ee58cu),\nuvec4(0x0d1cfcf5u,0xfc0d0051u,0xdc0ee51cu,0xcc0be50du),\nuvec4(0xcc0ee50eu,0xdc0de50bu,0x0ddce50eu,0x09004100u),\nuvec4(0x0041000cu,0x0ee5dc0du,0x0edcf5dcu,0x0bcc0ee5u),\nuvec4(0xf5dc0ee5u,0x060b1cfcu,0xfc0b0941u,0xdc0ee51cu),\nuvec4(0x0edce50eu,0xe5dc0ee5u,0xdcf5dc0eu,0x0951000du),\nuvec4(0x0641000cu,0x0ee5dc0eu,0xdc0de5dcu,0xdc0be50eu),\nuvec4(0xf5dc0ee5u,0x000d2cfcu,0xfc0e0221u,0xcc0ee52cu),\nuvec4(0xd5040d0bu,0x0ee50edcu,0x0de50bccu,0x0be50ddcu),\nuvec4(0x11000dccu,0x510c0930u,0x0bcc0d06u,0xe5dc0ee5u),\nuvec4(0xe50edc0du,0xe50bcc0eu,0x020edc0eu,0x1cfc0bd5u),\nuvec4(0x0621060eu,0xe52cfc0bu,0xe50edc0eu,0x04050edcu),\nuvec4(0x0bcc0bc5u,0x0ddc0ee5u,0x0dcc0be5u,0x0b095100u),\nuvec4(0xbd093619u,0x1ecde52eu,0x1eddd50du,0x0d0edde5u),\nuvec4(0x2ead09d5u,0x3c0ed50du,0x1d090e0bu,0x06090eacu),\nuvec4(0x0b3c0b09u,0xe50d2ebdu,0x1de51ecdu,0x0d1e9d0eu),\nuvec4(0x0e9d09d5u,0xe50d1e0du,0x1e8d0e0du,0x09e50e0bu),\nuvec4(0x0b3d090du,0x0c0d696cu,0x0d391d99u,0x3e051d29u),\nuvec4(0x0d056e15u,0x2d792d09u,0x190dce05u,0x691d090du),\nuvec4(0xce050e0du,0x192d2905u,0x8e053e7du,0x0d190d09u),\nuvec4(0x0d190d39u,0x4cee1d09u,0xbc0e190eu,0x4c0b090bu),\nuvec4(0x296d190bu,0x050dee1du,0x0d090d19u,0x0d091d49u),\nuvec4(0x05ce0d0eu,0x2d090d19u,0x0dde2d49u,0x2d190d09u),\nuvec4(0x0d093d09u,0x1d0915eeu,0x1e191d59u,0x050dbe0du),\nuvec4(0x5c0b0d69u,0x0c0d590du,0x0d0b0d59u,0x1509ad09u),\nuvec4(0x090e0bceu,0x0bce15bdu,0x1509cd0eu,0x15dd0bceu),\nuvec4(0x090e0bceu,0x0d0509bdu,0x0d0b6cceu,0x0e7c0bccu),\nuvec4(0x1509bd09u,0x0d0c0bbeu,0x0409ad09u,0x0d1cce05u),\nuvec4(0x15199d09u,0x0d0b1cbeu,0x04099d09u,0x0d1cbe15u),\nuvec4(0x06099d09u,0x1cae1504u,0x0b0d690bu,0x0e590d2cu),\nuvec4(0x0000000cu,0x00000000u,0x00000000u,0x00000000u));\nconst int rowindex[] = int[](\n0,42,82,122,161,199,237,277,316,356,396,434,472,516,565,642,711,860,971,1082,1193,1304,1412,1524,1635,1748,1863,1977,2100,2224,2349,2479,2615,2743,2874,3005,3137,3272,3402,3545,3686,3818,3951,4079,4242,4396,4504,4634,4756,4874,4990,5119,5241,5351,5458,5560,5660,5759,5857,5952,6042,6127,6209,6295,6367,6433,6497,6560,6623,6687,6752,6815,6877,6940,7039,7093,7145,7187,7248,7322,7398,7474,7550,7625,7700,7776,7853,7931,8006,8081,8156,8231,8307,8382,8456,8528,8600,8669,8738,8817,8894,8977,9057,9137,9214,9308,9374,9436,9517,9595,9671,9745,9818,9896,9977,10055,10133,10209,10264,10318,10375,10433,10491,10549,10609,10669,10729,10788,10845,10902,10957,11009,11062,11113,11169,11224,11299,11334,11408,11471,11527,11581,11635,11691,11746,11804,11861,11920,11981,12041,12100,12159,12219,12274,12329,12386,12441,12504,12560,12621,12676,12728,12785,12840,12894,12953,13012,13055,13095,13178,13234,13289,13344,13399,13455,13516,13580,13636,13693,13748,13802,13857,13913,13969,14024,14083,14142,14204,14262,14319,14379,14440,14499,14557,14615,14674,14742,14795,14847,14893,14980,15041,15104,15167,15230,15293,15359,15422,15485,15550,15623,15705,15792,15884,15977,16076,16178,16277,16382,16487,16599,16713,16834,16953,17080,17209,17338,17472,17588,17758,17904,18026,18146,18261,18379,18488,18598,18713,18825,18944,19073,19200,19323,19448,19578,19697,19817,19937,20044,20138,20238,20332,20418,20511,20602,20692,20782,20903,21001,21074,21132,21223,21292,21339,21384,21436,21485,21537,21585,21639,21696,21768,21880,21969);\n\nconst int WIDTH = 365;\nconst int HEIGHT = 273;\n\nconst vec3 colors[] = vec3[](\nvec3(0xd0,0xd0,0xd0),\nvec3(0xff,0xff,0xff),\nvec3(0xd0,0xd0,0xb0),\nvec3(0xf0,0xf0,0x50),\n\nvec3(0x00,0xe0,0xe0),\nvec3(0x50,0xe0,0x50),\nvec3(0xb0,0xb0,0xb0),\nvec3(0xd0,0x60,0xd0),\n\nvec3(0xe0,0x50,0x50),\nvec3(0x80,0x80,0x80),\nvec3(0x50,0x50,0xe0),\nvec3(0x30,0x30,0x30),\n\nvec3(0x00,0x00,0x00),\nvec3(0x50,0x50,0x50),\nvec3(0x30,0x40,0x30),\nvec3(0x80,0x80,0x70));\n\nvec3 getcolor(int i) {\n  return colors[i%colors.length()]/255.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  float ires = iResolution.x*10000.0 + iResolution.y;\n  if (iFrame != 0 && fragColor.w == ires) return; // Check for resize\n  fragColor.w = ires;\n  int row = int(fragCoord.y); // Desired row\n  row = min(row,HEIGHT-1); // Clamp at edges\n  int col = int(fragCoord.x); // Desired column\n  col = min(col,WIDTH-1); // Clamp at edges\n  // Find the index of the start of the row\n  int rstart = rowindex[row];\n  // And of the next row\n  int rend = rowindex[row+1];\n  int c = -1;\n  int colcount = 0; // column count\n  for (int index = rstart; index < rend; index++) {\n    int i = index;\n    uvec4 entry = data[i/16];\n    i %= 16;\n    uint t = entry[i/4];\n    i %= 4;\n    t >>= 8*i;\n    int count = (int(t >> 4)&15)+1;\n    colcount += count;\n    if (col < colcount) {\n      c = int(t)&15; // Found it!\n      break;\n    }\n  }\n  if (c < 0) fragColor.rgb = vec3(1,0,0); // Shouldn't happen\n  else fragColor.rgb = getcolor(c);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const uvec4 data[] = uvec4[](\nuvec4(0x03010201u,0x05050504u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x07050406u,0x02080505u),\nuvec4(0x04040902u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x0b050a05u,0x050c0a05u,0x04050605u,0x100f0e0du),\nuvec4(0x0405110du,0x11040512u,0x11111111u,0x05111111u),\nuvec4(0x13130505u,0x04040413u,0x15141303u,0x04170316u),\nuvec4(0x0a050505u,0x05050506u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x19021805u,0x0305040eu),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x0e050505u,0x0108020fu,0x04030102u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05070513u,0x02020805u,0x0513040eu),\nuvec4(0x05050505u,0x05050605u,0x050c0505u,0x05050505u),\nuvec4(0x050b0505u,0x1a150a05u,0x171b0209u,0x0c030311u),\nuvec4(0x090e0707u,0x0e0e0e09u,0x090e0e0eu,0x03070709u),\nuvec4(0x03050503u,0x16101a04u,0x06041a06u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x0e190218u,0x05050504u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x0f0e0505u,0x021c0802u,0x05040301u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050305u,0x0e020208u,0x05060505u,0x05050505u),\nuvec4(0x03050505u,0x050a0505u,0x05050505u,0x05050c05u),\nuvec4(0x071d0405u,0x180b1e1cu,0x01080101u,0x0f0f0f01u),\nuvec4(0x0f0f0f0fu,0x0f160f0fu,0x011c0f0fu,0x13070801u),\nuvec4(0x030f041bu,0x05051514u,0x05050505u,0x050a0505u),\nuvec4(0x03060511u,0x05050505u,0x05050505u,0x18050505u),\nuvec4(0x040e0202u,0x05050513u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x020f0e05u),\nuvec4(0x01021c18u,0x05050403u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x06050505u,0x08050505u),\nuvec4(0x13090f02u,0x05050605u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x11050c0cu,0x030c0405u,0x02010e1fu),\nuvec4(0x0216010fu,0x02020216u,0x16161616u,0x16161616u),\nuvec4(0x16161616u,0x16161616u,0x0f0f1616u,0x0718020fu),\nuvec4(0x0505050au,0x05050505u,0x05060305u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x02180505u,0x13040e02u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x18020f0eu,0x0301021cu),\nuvec4(0x05050504u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05030505u,0x02080505u,0x0513090fu),\nuvec4(0x06050505u,0x05030306u,0x03051305u,0x1111050cu),\nuvec4(0x1f030511u,0x0f010808u,0x020f0f02u,0x20161616u),\nuvec4(0x21201616u,0x21202020u,0x21212121u,0x20202020u),\nuvec4(0x16161616u,0x16162020u,0x0f162020u,0x0609081cu),\nuvec4(0x0605040bu,0x0c030c05u,0x03051105u,0x05050505u),\nuvec4(0x05050605u,0x19021805u,0x0505040eu,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x0e050505u,0x1c08020fu,0x04030102u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050305u,0x02020805u,0x0513130eu,0x05050505u),\nuvec4(0x03050505u,0x05050506u,0x07050505u,0x190f0822u),\nuvec4(0x1602021cu,0x2120020fu,0x23232021u,0x24242424u),\nuvec4(0x25252524u,0x25252525u,0x24252525u,0x21232324u),\nuvec4(0x16011616u,0x16161616u,0x010f0216u,0x1304050eu),\nuvec4(0x05050b0bu,0x05050c0cu,0x05050505u,0x05050506u),\nuvec4(0x0e0f1918u,0x05050504u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x0f0e0505u),\nuvec4(0x021c0802u,0x05040301u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05031303u),\nuvec4(0x0e020208u,0x05051313u,0x13050505u,0x03030513u),\nuvec4(0x07050b05u,0x160f0822u,0x16021616u,0x24012116u),\nuvec4(0x28272726u,0x29272725u,0x28282827u,0x28282828u),\nuvec4(0x28282828u,0x25252728u,0x25272525u,0x21162524u),\nuvec4(0x16161621u,0x0f161616u,0x030e0101u,0x03051105u),\nuvec4(0x0505050cu,0x06050505u,0x18050505u,0x040e1919u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x020f0e05u,0x01021c08u),\nuvec4(0x05050403u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x03050505u,0x08050313u,0x0b0e1902u),\nuvec4(0x05050605u,0x03030505u,0x03040406u,0x0f01080eu),\nuvec4(0x16161616u,0x27240821u,0x2b28272au,0x282b2828u),\nuvec4(0x25282c28u,0x2e2d2d2du,0x2d2d2e2eu,0x2e2d2d2du),\nuvec4(0x2c2c2e2eu,0x2c28252cu,0x232c2c28u,0x21212124u),\nuvec4(0x16160216u,0x22010f16u,0x11040403u,0x0505050cu),\nuvec4(0x05060505u,0x02180505u,0x13040e19u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x08020f0eu,0x0701021cu,0x05050504u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x02180505u,0x13041f02u,0x05060306u),\nuvec4(0x13040506u,0x0f080906u,0x16161616u,0x27242120u),\nuvec4(0x2b2b2b2bu,0x2f2f2b2bu,0x2e2e3028u,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x2d2d2d2eu),\nuvec4(0x2c2d2d2du,0x2525252cu,0x21240827u,0x16162021u),\nuvec4(0x1c160216u,0x150b0718u,0x05030604u,0x05030a13u),\nuvec4(0x0f191805u,0x0604040eu,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x04050305u,0x0e050506u),\nuvec4(0x0108190fu,0x04030102u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050605u),\nuvec4(0x19021805u,0x03051309u,0x05130505u,0x010e0513u),\nuvec4(0x160f0219u,0x27082116u,0x2b2a2b29u,0x2f312b2bu),\nuvec4(0x302f2830u,0x2e2e3030u,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e322e2eu,0x2e2e2e2eu,0x2d2d2d2du),\nuvec4(0x2c252d2du,0x24242425u,0x16212126u,0x16161616u),\nuvec4(0x130e181cu,0x030a0404u,0x03050505u,0x18020208u),\nuvec4(0x05050405u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x03050506u,0x190e0505u,0x02010802u),\nuvec4(0x05040301u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x0e020218u),\nuvec4(0x05050404u,0x09040505u,0x0f0f0f01u,0x27240202u),\nuvec4(0x33332a29u,0x312b2b2au,0x2f2f2f31u,0x2f2f2f2fu),\nuvec4(0x2e302f2fu,0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2e32322eu,0x2e2e2e2eu,0x342d2e2eu,0x25253534u),\nuvec4(0x25252525u,0x21212424u,0x16161616u,0x1f180f16u),\nuvec4(0x06130405u,0x18050503u,0x04221919u,0x05050504u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x02190e04u,0x0f021c08u,0x05050407u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05130505u,0x18050505u,0x05220202u,0x03050504u),\nuvec4(0x0f1c0107u,0x01020202u,0x361f1f22u,0x2a333336u),\nuvec4(0x282f2b2bu,0x2f31312fu,0x2f2f2f2eu,0x2e302f2fu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x322e2e2eu,0x34343232u,0x35353534u,0x25252535u),\nuvec4(0x21242525u,0x16202020u,0x181c1616u,0x06130403u),\nuvec4(0x02080503u,0x13042202u,0x05050503u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050305u),\nuvec4(0x08190f0eu,0x090f020fu,0x03060305u,0x03030303u),\nuvec4(0x03030303u,0x03030303u,0x03030303u,0x06030503u),\nuvec4(0x19180303u,0x0405180fu,0x01220705u,0x0f02020fu),\nuvec4(0x03092208u,0x36060603u,0x37363636u,0x2f2f2b2bu),\nuvec4(0x2f2f312fu,0x2f2f2f2fu,0x2e30302fu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x34323232u,0x2d2d2d2du,0x2535352du,0x242c2525u),\nuvec4(0x20202021u,0x010f2016u,0x1304130eu,0x02020806u),\nuvec4(0x05050518u,0x05050606u,0x06060505u,0x06060606u),\nuvec4(0x06060606u,0x03030503u,0x0e050503u,0x04010219u),\nuvec4(0x0d100404u,0x0d103838u,0x0d0d0d0du,0x0d0d0d0du),\nuvec4(0x0d0d0d0du,0x1b0d0d0du,0x1b0d1038u,0x13133938u),\nuvec4(0x03100d39u,0x02020f08u,0x070e080fu,0x050b0503u),\nuvec4(0x3a051313u,0x3336363au,0x2f313337u,0x2f312f30u),\nuvec4(0x2f2f2f2fu,0x2e30302fu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x32322e2eu,0x32323232u),\nuvec4(0x34343434u,0x35352d2du,0x24252c25u,0x20212123u),\nuvec4(0x0f161616u,0x1b3b0518u,0x39040439u,0x38383838u),\nuvec4(0x0d0d3838u,0x0d383838u,0x0d0d0d0du,0x380d0d0du),\nuvec4(0x1b38380du,0x04100d0du,0x0d3c0405u,0x0d17170du),\nuvec4(0x0d0d0d17u,0x0d0d0d0du,0x0d0d0d0du,0x0d0d0d0du),\nuvec4(0x3c170d0du,0x3d3c170du,0x143e0d0du,0x0208040du),\nuvec4(0x08190f16u,0x04040407u,0x39390404u,0x3f151539u),\nuvec4(0x372a373au,0x2f313737u,0x2f2f2f2fu,0x302f2f2fu),\nuvec4(0x2e2e3030u,0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x322e2e2eu,0x40403232u,0x40404032u),\nuvec4(0x352d2d35u,0x2c2c2535u,0x0f212325u,0x02160f0fu),\nuvec4(0x0d0d0508u,0x0d0d0d0du,0x0d0d3838u,0x0d0d0d0du),\nuvec4(0x0d0d0d0du,0x0d0d0d0du,0x3c0d0d0du,0x0d0d0d0du),\nuvec4(0x0d3d0d17u,0x1c01013du,0x01190f1cu,0x01010101u),\nuvec4(0x01010101u,0x01010101u,0x01010101u,0x191c4101u),\nuvec4(0x01010f1cu,0x1c0f0108u,0x1c02020fu,0x390a0e01u),\nuvec4(0x3b101010u,0x10103b3bu,0x15101010u,0x372a2a05u),\nuvec4(0x2f334236u,0x2f282f2eu,0x2f303030u,0x3030302fu),\nuvec4(0x2e2e2e2eu,0x2e2e302eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x32323232u,0x34343432u,0x3535352du),\nuvec4(0x23233535u,0x01082725u,0x16161620u,0x0801010fu),\nuvec4(0x41010101u,0x01010108u,0x01010101u,0x01010101u),\nuvec4(0x01010101u,0x1c010101u,0x081c0101u,0x080f0108u),\nuvec4(0x19020202u,0x020f020fu,0x02020202u,0x02020202u),\nuvec4(0x02020202u,0x02430202u,0x440f4302u,0x02020219u),\nuvec4(0x160f020fu,0x0308010fu,0x0d381b3bu,0x1b1b1b38u),\nuvec4(0x46383845u,0x0547460du,0x2a0e0948u,0x36363648u),\nuvec4(0x2f2f2829u,0x3128282fu,0x3030302fu,0x302e302fu),\nuvec4(0x2e2e2e30u,0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x34323232u,0x34343434u,0x35402d2du,0x35353535u),\nuvec4(0x23242425u,0x16161620u,0x02021616u,0x02020202u),\nuvec4(0x02020202u,0x02020202u,0x02020202u,0x02430202u),\nuvec4(0x0f020202u,0x020f0202u,0x0f020219u,0x08010219u),\nuvec4(0x081c0108u,0x08080808u,0x08080808u,0x08080808u),\nuvec4(0x08080808u,0x08010808u,0x0f020118u,0x01161616u),\nuvec4(0x1b3b050eu,0x0d0d0d38u,0x4a49490du,0x4b4a4646u),\nuvec4(0x4d0c054cu,0x480e0e1fu,0x33060648u,0x2b2b2b2au),\nuvec4(0x30303131u,0x30303030u,0x302f2f30u,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x34322e32u),\nuvec4(0x2d343434u,0x40404034u,0x23353535u,0x24252523u),\nuvec4(0x21162021u,0x010f1620u,0x08011818u,0x08010808u),\nuvec4(0x08080808u,0x08080808u,0x08080808u,0x01180108u),\nuvec4(0x191c0808u,0x02191c02u,0x05050e0fu,0x03030305u),\nuvec4(0x03030303u,0x03030303u,0x0c030303u,0x03050c0cu),\nuvec4(0x0e030c07u,0x16021c08u,0x03031f26u,0x0d141b15u),\nuvec4(0x0d0d0d0du,0x4f4e4649u,0x5112504au,0x0c0c5352u),\nuvec4(0x1f070303u,0x33360e09u,0x2b2b292au,0x2f302e2fu),\nuvec4(0x302e302fu,0x30302f2fu,0x2e303030u,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e32u,0x342d2e2eu),\nuvec4(0x35404040u,0x24353535u,0x24252424u,0x16162123u),\nuvec4(0x03180f16u,0x0a030505u,0x03030306u,0x03030503u),\nuvec4(0x0c030303u,0x030c0c0cu,0x05030507u,0x0f0f0e03u),\nuvec4(0x01190f18u,0x05040407u,0x05050505u,0x05050505u),\nuvec4(0x05040505u,0x05110405u,0x11051104u,0x19080704u),\nuvec4(0x0e242016u,0x3b035554u,0x0d141717u,0x46490d0du),\nuvec4(0x50575646u,0x51594c58u,0x51515151u,0x1f030c05u),\nuvec4(0x2718290eu,0x2f2f2927u,0x2f2f2f31u,0x2f302e30u),\nuvec4(0x3030302eu,0x30303030u,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x322e2e2eu,0x2e2e2e32u,0x34342d2eu,0x35404040u),\nuvec4(0x23252d35u,0x25252323u,0x16202125u,0x03181c16u),\nuvec4(0x050b0404u,0x05050413u,0x0513133fu,0x11110505u),\nuvec4(0x05050411u,0x13040504u,0x22190f09u,0x071c020fu),\nuvec4(0x03030604u,0x05050505u,0x05050505u,0x03060503u),\nuvec4(0x050c0505u,0x0e051103u,0x16161601u,0x063a4808u),\nuvec4(0x175a541fu,0x0d0d1417u,0x4f46491du,0x5058505bu),\nuvec4(0x595d5d5cu,0x4d4d5251u,0x1f0c0c0cu,0x290e1f1fu),\nuvec4(0x2f2b2a2bu,0x2f2f2f2fu,0x2e303030u,0x2f2f3030u),\nuvec4(0x30302f2fu,0x2e2e2e2eu,0x2e2e2e2eu,0x32322e2eu),\nuvec4(0x2e2e2e2eu,0x34342d2du,0x35404040u,0x35353535u),\nuvec4(0x25252535u,0x1620232cu,0x1f080202u,0x030c1104u),\nuvec4(0x03060505u,0x05060605u,0x05050505u,0x05050505u),\nuvec4(0x09050505u,0x0222020fu,0x04071c02u,0x05050505u),\nuvec4(0x05050505u,0x06050505u,0x05050505u,0x04050505u),\nuvec4(0x02010905u,0x2a080102u,0x3a55543au,0x170d5a3bu),\nuvec4(0x1d1d0d0du,0x5b4f4e5eu,0x5c605f5fu,0x5d5c5c5du),\nuvec4(0x59515159u,0x050c514cu,0x480e0305u,0x2f2b423au),\nuvec4(0x2f2f2f2fu,0x30302f2fu,0x2f2f2f2fu,0x30302f2fu),\nuvec4(0x2e2e2e30u,0x2e2e2e2eu,0x2e322e2eu,0x2e2e2e2eu),\nuvec4(0x342d2e2eu,0x35354040u,0x352d2d35u,0x27253535u),\nuvec4(0x16212124u,0x1f080f02u,0x03050404u,0x05060505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x0f091305u),\nuvec4(0x02192202u,0x0513071cu,0x05050606u,0x05050505u),\nuvec4(0x03060505u,0x05050505u,0x22050505u,0x2116160fu),\nuvec4(0x3a613618u,0x62043636u,0x0d1d1763u,0x46561d0du),\nuvec4(0x5f5b4e4eu,0x5c5c6060u,0x59595d58u,0x51516451u),\nuvec4(0x03034d52u,0x061f0e1fu,0x2f2b373au,0x2f2f2f2eu),\nuvec4(0x2f2f2f30u,0x2f2f2f2fu,0x2f2f2f2fu,0x2e2e3030u),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x342d2e2eu),\nuvec4(0x35354040u,0x35353535u,0x2c2c2d35u,0x16212425u),\nuvec4(0x1f1c0216u,0x03060b04u,0x06050506u,0x06060606u),\nuvec4(0x05050506u,0x05050505u,0x020f0e05u,0x0f020222u),\nuvec4(0x05050409u,0x05050505u,0x05050505u,0x05030505u),\nuvec4(0x05050c05u,0x02011805u,0x36182102u,0x42423661u),\nuvec4(0x5a5a6533u,0x1d1d175au,0x5e5e1d1du,0x50506656u),\nuvec4(0x5f5f5c5fu,0x515d5c59u,0x4c595252u,0x0c05124cu),\nuvec4(0x2a291f03u,0x2e2f333au,0x2e302f2fu,0x2f2f2f2fu),\nuvec4(0x2f2f2f2fu,0x2f2f2f2fu,0x2e2e302fu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x402d2e2eu,0x40404040u),\nuvec4(0x35353540u,0x2c252335u,0x20212325u,0x09080216u),\nuvec4(0x03050413u,0x06050505u,0x06060606u,0x05050505u),\nuvec4(0x05050505u,0x22020f22u,0x070f0219u,0x05050504u),\nuvec4(0x05050505u,0x05050505u,0x05050605u,0x0e050b03u),\nuvec4(0x16162116u,0x36363a0eu,0x543a373au,0x5a5a5a67u),\nuvec4(0x1d3e1d3eu,0x564e561du,0x505f4e4eu,0x515d505fu),\nuvec4(0x59585952u,0x4b4b5059u,0x4a464a4cu,0x48480612u),\nuvec4(0x2e2f373au,0x2f302f2fu,0x2f2f2f2fu,0x2f2f2f2fu),\nuvec4(0x2f2f2f2fu,0x2e2e2e30u,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x35352d2eu,0x35404040u,0x35354040u),\nuvec4(0x24353535u,0x16212425u,0x07010216u,0x03050505u),\nuvec4(0x05050506u,0x05060505u,0x05050505u,0x0e050505u),\nuvec4(0x1922020fu,0x04071c02u,0x05050505u,0x05050505u),\nuvec4(0x06050505u,0x04030305u,0x161c1805u,0x36292116u),\nuvec4(0x3a553636u,0x68543642u,0x3e5a5a3du,0x1d1d1d1du),\nuvec4(0x4e5e4e56u,0x4e574b4eu,0x52525957u,0x50584c51u),\nuvec4(0x4c4c4b4bu,0x394c4c4cu,0x3a061347u,0x2e2b6961u),\nuvec4(0x30302f30u,0x2f2f2f2fu,0x2f2f2f2fu,0x30302f2fu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x3535352du,0x40404040u,0x2d354040u,0x2c25252du),\nuvec4(0x20232527u,0x09080f16u,0x05050404u,0x06050505u),\nuvec4(0x05050606u,0x05050505u,0x0f0e0505u,0x02192202u),\nuvec4(0x0504071cu,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x0e050505u,0x2016160fu,0x363a5429u,0x3a424242u),\nuvec4(0x3d3d6536u,0x1d3e5a63u,0x561d1d1du,0x4e4e4e4au),\nuvec4(0x575b4e57u,0x4c595359u,0x4b4b4b4bu,0x124c4c4cu),\nuvec4(0x4a4a4c6au,0x61063f39u,0x2e284261u,0x302e2f2fu),\nuvec4(0x2f2f2f2fu,0x2f2f2f2fu,0x2e30302fu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x3535342du),\nuvec4(0x40404040u,0x2d354040u,0x2c2d3535u,0x2021252cu),\nuvec4(0x03010216u,0x05050504u,0x06050505u,0x05050505u),\nuvec4(0x05050505u,0x020f0e05u,0x1c021922u,0x05050407u),\nuvec4(0x05050505u,0x05050505u,0x0b060505u,0x20010e0bu),\nuvec4(0x55292116u,0x4242423au,0x3a3a3742u,0x0d633d62u),\nuvec4(0x3e1d175au,0x4b566b1du,0x4e4e4e4bu,0x594f5656u),\nuvec4(0x124c5853u,0x4c4c4c4cu,0x4c504b4bu,0x39504c4cu),\nuvec4(0x3a050447u,0x2e2b423au,0x2f30302fu,0x2f2f2f2fu),\nuvec4(0x302f2f2fu,0x2e2e2e30u,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x4035352eu,0x40404040u),\nuvec4(0x35404040u,0x35353535u,0x16212525u,0x07081616u),\nuvec4(0x050c0504u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x22020f0eu,0x071c0219u,0x05050504u,0x05050505u),\nuvec4(0x05050505u,0x07050305u,0x16201608u,0x37693a18u),\nuvec4(0x42424242u,0x14655537u,0x1717633du,0x3c3e1d17u),\nuvec4(0x4b4b566bu,0x1d565e4eu,0x536a5756u,0x536c5364u),\nuvec4(0x4b126a53u,0x4c504b57u,0x4c1e1212u,0x3f613910u),\nuvec4(0x2f253667u,0x2f2f2f2fu,0x2f2f2f2fu,0x3030302fu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x40342d2du,0x40404040u,0x40404040u),\nuvec4(0x2d353535u,0x20212427u,0x05221616u,0x05050511u),\nuvec4(0x05050505u,0x05050505u,0x0e050505u,0x1922020fu),\nuvec4(0x04071c02u,0x05050505u,0x05050505u,0x0a050505u),\nuvec4(0x2008070bu,0x36272016u,0x55374254u,0x36556d42u),\nuvec4(0x5a3d6742u,0x171d3d5au,0x3c3c3e1du,0x564a4a56u),\nuvec4(0x4e561d56u,0x53526a4cu,0x6e6e6e6cu,0x6a536c6eu),\nuvec4(0x12126a6au,0x101e1e12u,0x6267671bu,0x2f282961u),\nuvec4(0x30302f2fu,0x302f2f2fu,0x2e2e3030u,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x2d34352eu),\nuvec4(0x40342d2du,0x40404040u,0x40344040u,0x282e2d40u),\nuvec4(0x16212425u,0x05180102u,0x0c0c1104u,0x05050505u),\nuvec4(0x05050505u,0x0f0e0505u,0x020f2202u,0x0504071cu),\nuvec4(0x05050505u,0x05050505u,0x0a050505u,0x20161618u),\nuvec4(0x553a5527u,0x42554242u,0x6f36426du,0x5a141462u),\nuvec4(0x1d171d5au,0x563c1d3eu,0x561d4f4au,0x6a505b56u),\nuvec4(0x526a6a64u,0x6e6e7170u,0x6e6e6e6eu,0x6a64536cu),\nuvec4(0x3b4c1212u,0x673b6739u,0x302e2836u,0x2f2f2f2fu),\nuvec4(0x3030302fu,0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2d2d342eu,0x4040342du),\nuvec4(0x40404040u,0x34323240u,0x272c2e2du,0x16011828u),\nuvec4(0x04090f02u,0x05050c04u,0x0505050cu,0x05050505u),\nuvec4(0x020f0e05u,0x1c020f22u,0x05050407u,0x05050505u),\nuvec4(0x05050505u,0x0f220b05u,0x36271616u,0x42426955u),\nuvec4(0x42374242u,0x14724237u,0x0d5a1417u,0x1d1d3e17u),\nuvec4(0x4a561d1du,0x5b566b4eu,0x6a6a1257u,0x53525259u),\nuvec4(0x6c71716cu,0x6e6e736cu,0x536c6e6eu,0x4704126au),\nuvec4(0x6167673bu,0x2f2e2c27u,0x2f2f2f2fu,0x2e303030u),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2d2d2d2eu,0x40403434u,0x32403240u),\nuvec4(0x32322e32u,0x332c252eu,0x16012a3au,0x110c010fu),\nuvec4(0x0305110cu,0x05050505u,0x05050505u,0x22020f0eu),\nuvec4(0x0701020fu,0x05050504u,0x050c0c05u,0x11050c05u),\nuvec4(0x16160f07u,0x42543621u,0x42424242u,0x363a4242u),\nuvec4(0x1717623au,0x3e141414u,0x56561d1du,0x4f4e566bu),\nuvec4(0x584f561du,0x6a6a6a59u,0x6c6c5352u,0x716c7070u),\nuvec4(0x7373736eu,0x6c716e73u,0x3b12536au,0x36673b39u),\nuvec4(0x2f282e28u,0x3030302fu,0x2e2e2e2eu,0x32322e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x2e322e2eu),\nuvec4(0x2e2e2e2du,0x34343232u,0x2e324032u,0x2d2e3232u),\nuvec4(0x332b2828u,0x0f16010eu,0x04030802u,0x05050c0cu),\nuvec4(0x05050505u,0x0e130305u,0x0f22020fu,0x04071c02u),\nuvec4(0x05050505u,0x0c050503u,0x08070405u,0x2b16161cu),\nuvec4(0x42424254u,0x42424242u,0x54335542u,0x1417171bu),\nuvec4(0x1d3c0d0du,0x1d56561du,0x564f4e56u,0x4c4b4f5eu),\nuvec4(0x53536459u,0x70707070u,0x73717170u,0x73737374u),\nuvec4(0x6c6c6e73u,0x394a124du,0x28613b3bu,0x282f2828u),\nuvec4(0x2e303030u,0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x322e2e2eu,0x2e323232u,0x34322e2eu),\nuvec4(0x34343434u,0x402e3240u,0x282d2e35u,0x26242525u),\nuvec4(0x02161620u,0x0413220fu,0x05050306u,0x05050505u),\nuvec4(0x0f0e1306u,0x020f2202u,0x0504071cu,0x03050505u),\nuvec4(0x04030511u,0x0f021811u,0x753a0820u,0x42424242u),\nuvec4(0x42424242u,0x63653342u,0x1414173du,0x56563c0du),\nuvec4(0x561d5656u,0x5b5b4f4fu,0x6412574eu,0x70706c53u),\nuvec4(0x716c6c70u,0x76746e71u,0x73737376u,0x4d6c6c6eu),\nuvec4(0x10394751u,0x2828613bu,0x30282828u,0x2e303030u),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e32u,0x2e2e2e2eu),\nuvec4(0x3232322eu,0x2e323232u,0x34342d2du,0x342e3434u),\nuvec4(0x2e2d2e2eu,0x2323352eu,0x08082424u,0x020f1601u),\nuvec4(0x05041f1cu,0x05051303u,0x05050505u,0x021c0e13u),\nuvec4(0x1c020f22u,0x0a050407u,0x050a0505u,0x1f050c05u),\nuvec4(0x08160f0fu,0x553a5455u,0x42424242u,0x42424242u),\nuvec4(0x3d143b36u,0x0d141417u,0x5656563cu,0x4f5e5656u),\nuvec4(0x5b5b4e4fu,0x6c706458u,0x706c6c70u,0x736e716cu),\nuvec4(0x76767373u,0x73767676u,0x0c4d536cu,0x15150405u),\nuvec4(0x2828293au,0x2e302828u,0x2e30302eu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e2e32u,0x2e2e2e2eu,0x32323232u),\nuvec4(0x2d2e3232u,0x2d2d2d2du,0x35352d2du,0x35353535u),\nuvec4(0x24252535u,0x08082323u,0x160f0f01u,0x13040301u),\nuvec4(0x05050505u,0x05050505u,0x18020f0eu,0x071c020fu),\nuvec4(0x05050504u,0x05050505u,0x02080705u,0x652a160fu),\nuvec4(0x4269423au,0x42424242u,0x55424242u,0x173d171bu),\nuvec4(0x3c0d0d14u,0x56565656u,0x4e4f5b56u,0x59575b5bu),\nuvec4(0x706c6c53u,0x6c706c6cu,0x73736e71u,0x76767673u),\nuvec4(0x6e737676u,0x05514d6cu,0x3a050303u,0x2828282bu),\nuvec4(0x2e2e3028u,0x2e2e3030u,0x2e2e2e2eu,0x32323232u),\nuvec4(0x2e2e2e32u,0x32322e2eu,0x32323232u,0x2d2e3232u),\nuvec4(0x25252d2du,0x252c2523u,0x23232020u,0x24252525u),\nuvec4(0x08082424u,0x16160116u,0x0704040eu,0x050c0505u),\nuvec4(0x0e050505u,0x0f22020fu,0x04070102u,0x0c050505u),\nuvec4(0x05050505u,0x16190f22u,0x69613a18u,0x42426942u),\nuvec4(0x42424242u,0x63543636u,0x14143d17u,0x491d0d3cu),\nuvec4(0x56565656u,0x564e4f4eu,0x52644c4fu,0x706c7053u),\nuvec4(0x716c6c70u,0x7373736eu,0x74767676u,0x6e737476u),\nuvec4(0x070c536cu,0x2b360307u,0x28282828u,0x2e2e2e30u),\nuvec4(0x2e2e2e2eu,0x322e2e2eu,0x32323232u,0x2e2e3232u),\nuvec4(0x32322e2eu,0x32323232u,0x352d2d32u,0x16252525u),\nuvec4(0x252a2a25u,0x20202021u,0x27252320u,0x01270824u),\nuvec4(0x08161601u,0x05050503u,0x06110311u,0x0f0e0505u),\nuvec4(0x190f2219u,0x05040701u,0x05050505u,0x08070505u),\nuvec4(0x54210f02u,0x69695561u,0x55424242u,0x36424242u),\nuvec4(0x3d633f42u,0x3c3c143du,0x565e1d0du,0x4e5e5e56u),\nuvec4(0x575b4e57u,0x64646477u,0x6c706c53u,0x6e6e7171u),\nuvec4(0x7873736eu,0x76787376u,0x6e747476u,0x071f6e6eu),\nuvec4(0x282b3603u,0x30302e2eu,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x32322e2eu,0x32323232u,0x2e2e3232u,0x3232322eu),\nuvec4(0x34323232u,0x2c252d2du,0x1f182727u,0x3a543f04u),\nuvec4(0x24252a36u,0x21212123u,0x01181808u,0x18161620u),\nuvec4(0x11050403u,0x050c1103u,0x0f0f0e05u,0x01190f0eu),\nuvec4(0x05050407u,0x050c0505u,0x020f2205u,0x75652916u),\nuvec4(0x55424242u,0x42554242u,0x55365542u,0x3d3d1472u),\nuvec4(0x1d3c3c14u,0x56564656u,0x574e5b5eu,0x58605b4eu),\nuvec4(0x53536459u,0x6e716c70u,0x6e6e6e6eu,0x76736e6eu),\nuvec4(0x76767676u,0x6e747974u,0x480e7a7au,0x2e2f2b06u),\nuvec4(0x2e30302eu,0x2e2e2e2eu,0x322e2e2eu,0x32323232u),\nuvec4(0x32323232u,0x32323232u,0x32323232u,0x352d2e32u),\nuvec4(0x0e272c25u,0x18180e0eu,0x3f05480eu,0x363a6105u),\nuvec4(0x26242729u,0x01010801u,0x1f01020fu,0x03110504u),\nuvec4(0x0505030bu,0x090f0f0eu,0x0301020fu,0x05050504u),\nuvec4(0x1f040c05u,0x24201621u,0x69695454u,0x42424255u),\nuvec4(0x42555542u,0x67543642u,0x1717173du,0x563c3c0du),\nuvec4(0x5b5e4646u,0x4e57574eu,0x59575b5bu,0x70705352u),\nuvec4(0x6e6e7b6cu,0x6e73736eu,0x76767873u,0x74767676u),\nuvec4(0x7a7a7a74u,0x06060e7au,0x2e2e2f2bu,0x302e2e2eu),\nuvec4(0x32322e2eu,0x34323232u,0x32323232u,0x32322e2eu),\nuvec4(0x2e32322eu,0x2e2e2e32u,0x2c352e35u,0x1f1f2a27u),\nuvec4(0x08010118u,0x0e0e0808u,0x053a3629u,0x48360561u),\nuvec4(0x0f08290eu,0x05081602u,0x050a0504u,0x1f050505u),\nuvec4(0x0f0e0f0fu,0x051f0102u,0x0c0c0505u,0x16180605u),\nuvec4(0x542a0116u,0x55696954u,0x42424242u,0x42425555u),\nuvec4(0x173b5436u,0x0d171717u,0x4f563c3cu,0x4e5b4e4eu),\nuvec4(0x5b4e5757u,0x537c5860u,0x6e716c70u,0x736e6e73u),\nuvec4(0x7d7d7473u,0x74737676u,0x74747676u,0x7a7a7974u),\nuvec4(0x2b36030eu,0x2e2e2e2fu,0x2e2e322eu,0x3232322eu),\nuvec4(0x32323232u,0x32323434u,0x2e2e2e2eu,0x2e2e2e2eu),\nuvec4(0x2d2d2e2eu,0x2a28242cu,0x0e0e1f03u,0x187e0808u),\nuvec4(0x0e221808u,0x29082608u,0x0648482au,0x0f080907u),\nuvec4(0x04070f02u,0x050b0505u,0x0f0e030cu,0x020f220fu),\nuvec4(0x0504071cu,0x04050c05u,0x16161c0eu,0x69540418u),\nuvec4(0x42555569u,0x55554242u,0x36425555u,0x17171b61u),\nuvec4(0x1d0d3c17u,0x4f4a561du,0x574e4e4eu,0x575b5757u),\nuvec4(0x6c6c536au,0x7373716cu,0x6c6c7071u,0x7674736cu),\nuvec4(0x74747676u,0x7a747474u,0x090e7a7au,0x2f2f2b48u),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x32322e2eu,0x2e2e2e32u),\nuvec4(0x2e2e2e2eu,0x2e2d3432u,0x2e2e2d35u,0x272c2e2du),\nuvec4(0x03033327u,0x7e08180eu,0x480e1818u,0x08210822u),\nuvec4(0x08212126u,0x29080808u,0x19080e09u,0x05034102u),\nuvec4(0x05050505u,0x0f0f0911u,0x01020f0eu,0x11111e05u),\nuvec4(0x08051111u,0x36211616u,0x69695465u,0x42425555u),\nuvec4(0x42424242u,0x65424242u,0x173c1763u,0x1d1d1d3cu),\nuvec4(0x4e4f4f56u,0x50504e4eu,0x52586057u,0x536c6c6cu),\nuvec4(0x52535970u,0x5964646au,0x74715359u,0x73747676u),\nuvec4(0x7a7a7473u,0x2a0e2222u,0x2e302f29u,0x2e303030u),\nuvec4(0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e2e2eu,0x2e2e302eu),\nuvec4(0x2e28302eu,0x352d2d2du,0x2a27242cu,0x220e1f03u),\nuvec4(0x0e1f0e0eu,0x080e2218u,0x3f100e01u,0x26261601u),\nuvec4(0x26212126u,0x020f0108u,0x0404070fu,0x04040c11u),\nuvec4(0x0e0f0f0eu,0x0901160fu,0x1f1f0907u,0x160f2209u),\nuvec4(0x75612716u,0x55696969u,0x42424255u,0x42424242u),\nuvec4(0x14725542u,0x3c173c17u,0x561d1d1du,0x4e574f4fu),\nuvec4(0x5f585057u,0x6c645d57u,0x7f7f706cu,0x6c71716cu),\nuvec4(0x58595371u,0x6e715277u,0x746e6e6eu,0x18087a74u),\nuvec4(0x282a0e29u,0x2f2f2f2fu,0x2e2e2e2fu,0x2e2e2e2eu),\nuvec4(0x2e2e2e2eu,0x2e2e3030u,0x2d2d2d2eu,0x25353535u),\nuvec4(0x2a29282cu,0x1f031f2au,0x0808220eu,0x1f220808u),\nuvec4(0x03180809u,0x0e631a10u,0x08080121u,0x0f210108u),\nuvec4(0x02020f0fu,0x07070908u,0x08070709u,0x0f224319u),\nuvec4(0x0219020fu,0x0f024443u,0x210f0219u,0x6954610eu),\nuvec4(0x55555569u,0x42424242u,0x42424255u,0x175a673au),\nuvec4(0x563c3c3cu,0x4f561d1du,0x574e574bu,0x585f5850u),\nuvec4(0x70537c58u,0x716c707fu,0x585d5d64u,0x5858575fu),\nuvec4(0x6c70536au,0x7474746eu,0x071f0e0eu,0x28284206u),\nuvec4(0x28282828u,0x312f2f2fu,0x302f2f31u,0x2d302e2eu),\nuvec4(0x2d2d2d2du,0x6d312f2eu,0x7569426du,0x391b6272u),\nuvec4(0x07090505u,0x01010e06u,0x1f064818u,0x141b0318u),\nuvec4(0x0839631bu,0x08080116u,0x01010808u,0x43020f08u),\nuvec4(0x0f1c1902u,0x190f1c43u,0x160f2243u,0x02021902u),\nuvec4(0x02430244u,0x55270f02u,0x69695461u,0x42555555u),\nuvec4(0x55554242u,0x61424242u,0x0d141780u,0x1d1d3c3cu),\nuvec4(0x4b4f561du,0x5857574bu,0x585f5f58u,0x7f6c7f7cu),\nuvec4(0x607c707fu,0x60566b56u,0x6a6a775du,0x73715364u),\nuvec4(0x6a0c7474u,0x61154712u,0x28282855u,0x2f282828u),\nuvec4(0x3535282fu,0x35353535u,0x31282e2du,0x6f554231u),\nuvec4(0x62627281u,0x68628262u,0x03043814u,0x0d13090au),\nuvec4(0x0808073bu,0x3f480e29u,0x0d3d3d63u,0x21036314u),\nuvec4(0x08082420u,0x29010108u,0x020f1908u,0x02431c02u),\nuvec4(0x430f1919u,0x0f022122u,0x090e070eu,0x1601081fu),\nuvec4(0x61650e16u,0x5569696fu,0x42425555u,0x42554242u),\nuvec4(0x62655542u,0x3c1d3e17u,0x1d1d563cu,0x504b4f56u),\nuvec4(0x5c5c5057u,0x835d5758u,0x837f6c6cu,0x58586a83u),\nuvec4(0x70645b5bu,0x52646458u,0x6e76746cu,0x56464c6cu),\nuvec4(0x363a3f38u,0x2b2b2b2bu,0x2d2e2828u,0x3128302du),\nuvec4(0x6f554242u,0x62627281u,0x82828282u,0x14681482u),\nuvec4(0x1414683du,0x111f033bu,0x3d3d0407u,0x08080e04u),\nuvec4(0x1b631548u,0x1b0d3904u,0x0105631bu,0x08080801u),\nuvec4(0x7e090801u,0x22010202u,0x1f1f1f1fu,0x2202197eu),\nuvec4(0x061c1616u,0x0a0b0504u,0x08160f01u,0x426f5454u),\nuvec4(0x55555569u,0x42424255u,0x42424242u,0x17686555u),\nuvec4(0x491d170du,0x5e561d1du,0x5050574eu,0x585c5c58u),\nuvec4(0x6c7c5857u,0x6e6e6e6eu,0x706e6e71u,0x53747353u),\nuvec4(0x6e6e7153u,0x53748474u,0x3b4a8556u,0x27180538u),\nuvec4(0x2b282c25u,0x756f4237u,0x62807275u,0x14828262u),\nuvec4(0x14141414u,0x68826868u,0x63631468u,0x11141763u),\nuvec4(0x0c050403u,0x3d3d141bu,0x3f08293fu,0x080e0515u),\nuvec4(0x1f03041fu,0x2118673bu,0x01080808u,0x0f090e08u),\nuvec4(0x1e224343u,0x09030404u,0x0f22020fu,0x04031c19u),\nuvec4(0x0f1f0505u,0x65291620u,0x6955696fu,0x55555555u),\nuvec4(0x42424242u,0x55555542u,0x0d176315u,0x1d491d17u),\nuvec4(0x4e5b5e1du,0x58505057u,0x5f585c5cu,0x6e7f5958u),\nuvec4(0x76737373u,0x6e747373u,0x6e6e746eu,0x74737473u),\nuvec4(0x1d53747du,0x1b4c1249u,0x72050704u,0x62628072u),\nuvec4(0x82828268u,0x82821414u,0x14686868u,0x68141414u),\nuvec4(0x63631468u,0x0d141414u,0x050c1b17u,0x14390c05u),\nuvec4(0x14633814u,0x29482906u,0x03180808u,0x08084804u),\nuvec4(0x08212629u,0x01010808u,0x4301090eu,0x11050843u),\nuvec4(0x0f090311u,0x020f0e16u,0x050b071cu,0x20021806u),\nuvec4(0x75723621u,0x55696942u,0x42555555u,0x42425542u),\nuvec4(0x67555569u,0x1d0d1717u,0x561d491du,0x504e4e5eu),\nuvec4(0x5c505058u,0x5f5f585cu,0x787b835du,0x737d7478u),\nuvec4(0x6e747673u,0x76747473u,0x84767476u,0x0c6a6c79u),\nuvec4(0x3b39070eu,0x14633810u,0x14141414u,0x68688214u),\nuvec4(0x68686868u,0x63681468u,0x63631414u,0x14636363u),\nuvec4(0x0d171463u,0x1e121f39u,0x1b380d11u,0x063b3f3fu),\nuvec4(0x21080348u,0x683b1f08u,0x1616293bu,0x08081621u),\nuvec4(0x22010108u,0x43442207u,0x0405090fu,0x160f0903u),\nuvec4(0x1c020f22u,0x070b0b1fu,0x08201601u,0x426f6554u),\nuvec4(0x5555696fu,0x42555555u,0x69424255u,0x3d623a3au),\nuvec4(0x561d0d14u,0x4e561d49u,0x58504e4eu,0x5c5c5050u),\nuvec4(0x58606058u,0x78866c7cu,0x74737878u,0x74747474u),\nuvec4(0x76767474u,0x847d7674u,0x0e6c4d74u,0x3d3c040eu),\nuvec4(0x14141463u,0x68686363u,0x68686868u,0x63636368u),\nuvec4(0x14146314u,0x63631414u,0x38141414u,0x040d170du),\nuvec4(0x1e455007u,0x043b151bu,0x0e0e4803u,0x2a262648u),\nuvec4(0x38141b15u,0x2116161fu,0x0808260fu,0x03181c01u),\nuvec4(0x43434103u,0x05040318u,0x22160f09u,0x0701020fu),\nuvec4(0x0f090504u,0x720e2020u,0x69696954u,0x55555555u),\nuvec4(0x55425555u,0x3a694242u,0x633d1b61u,0x49491d0du),\nuvec4(0x574e5656u,0x50585857u,0x585c5c50u,0x7c5f6060u),\nuvec4(0x6e736e6cu,0x7876746eu,0x76767674u,0x767d7676u),\nuvec4(0x79847d76u,0x090c534du,0x1b1a1705u,0x63141414u),\nuvec4(0x63636363u,0x63631414u,0x63636363u,0x63141463u),\nuvec4(0x14631414u,0x0d381414u,0x05123817u,0x1e044a4au),\nuvec4(0x063b1b04u,0x48090e0eu,0x3b480808u,0x2765681bu),\nuvec4(0x21212020u,0x01010826u,0x0507080fu,0x0143447eu),\nuvec4(0x0e050407u,0x0f0e0f0fu,0x04070102u,0x16161806u),\nuvec4(0x69675521u,0x55556f69u,0x55555555u,0x42554242u),\nuvec4(0x653a3a55u,0x0d381768u,0x5e5e491du,0x57575746u),\nuvec4(0x58585858u,0x585c5c5cu,0x6c7c5f60u,0x786e6e7bu),\nuvec4(0x76787878u,0x7d767676u,0x767d7d7du,0x79797d7du),\nuvec4(0x037a0e0eu,0x0d0d3d0du,0x6363630du,0x38383863u),\nuvec4(0x38383838u,0x63636363u,0x14636314u,0x14146314u),\nuvec4(0x3d3c0d14u,0x56120445u,0x1004054cu,0x2213633eu),\nuvec4(0x2203090eu,0x62130e18u,0x21212a67u,0x260f1621u),\nuvec4(0x0f010808u,0x0e121f01u,0x0e444301u,0x0f0e0511u),\nuvec4(0x020f0e0fu,0x07040701u,0x27161601u,0x696f6565u),\nuvec4(0x55555569u,0x42555555u,0x69425542u,0x14673a42u),\nuvec4(0x1d0d0d14u,0x4e5e5e49u,0x5050574bu,0x5c5c5c58u),\nuvec4(0x5f5d5d5cu,0x7b835d5fu,0x7878787bu,0x76767878u),\nuvec4(0x767d7678u,0x76747676u,0x7a797d7du,0x1b03087au),\nuvec4(0x0d0d173cu,0x6363140du,0x63383863u,0x63636363u),\nuvec4(0x14636363u,0x14143863u,0x140d381bu,0x3b170d0du),\nuvec4(0x393c3905u,0x17451103u,0x22220538u,0x087e0722u),\nuvec4(0x2a540318u,0x21212001u,0x08012120u,0x010f4101u),\nuvec4(0x416c1e1fu,0x057e4343u,0x190f0e04u,0x01020f22u),\nuvec4(0x16090407u,0x722a2016u,0x42696f69u,0x55555569u),\nuvec4(0x42425555u,0x36694242u,0x1417623au,0x561d0d0du),\nuvec4(0x574f5e5eu,0x58505857u,0x5c5c5c5cu,0x5f585d59u),\nuvec4(0x7b6c835cu,0x78767b78u,0x7476767bu,0x78737876u),\nuvec4(0x7d786e78u,0x797a7d84u,0x0d451f41u,0x0d0d0d17u),\nuvec4(0x63630d0du,0x63633863u,0x63636363u,0x0d3c0d63u),\nuvec4(0x3b631738u,0x0d0d0d10u,0x0c040d0du,0x0c4a1d4au),\nuvec4(0x1b173b05u,0x1f0e0e05u,0x08080905u,0x2018051fu),\nuvec4(0x16202120u,0x4101210fu,0x1f010101u,0x43410350u),\nuvec4(0x04030843u,0x0e190f22u,0x070f020fu,0x16161804u),\nuvec4(0x6f725421u,0x6f55696fu,0x55555555u,0x55424255u),\nuvec4(0x653a6942u,0x0d143d63u,0x56565e1du,0x4e574b4fu),\nuvec4(0x5d585050u,0x59595c5cu,0x585f5c59u,0x7b7b877cu),\nuvec4(0x7878787bu,0x74747878u,0x76737b6eu,0x7d76747du),\nuvec4(0x08797479u,0x3c17390eu,0x0d0d0d0du,0x63630d0du),\nuvec4(0x63381463u,0x14383814u,0x1438171bu,0x3b130d17u),\nuvec4(0x3d3c1b14u,0x10040539u,0x03034a56u,0x0c393839u),\nuvec4(0x4612051fu,0x1f081f4cu,0x2120270eu,0x21161601u),\nuvec4(0x08011c0fu,0x4c4d0844u,0x4344840cu,0x0e1e0e0fu),\nuvec4(0x1c22020fu,0x13030f19u,0x24161608u,0x6f696561u),\nuvec4(0x69696969u,0x55555555u,0x69554242u,0x143b613au),\nuvec4(0x6b0d1417u,0x4f5e5656u,0x5857574bu,0x5c5c5c50u),\nuvec4(0x7c59595du,0x595c585du,0x7b897f88u,0x7b7b7b7bu),\nuvec4(0x7b78787bu,0x6c6c6c6cu,0x6c6e6c7fu,0x22087a74u),\nuvec4(0x0d3c3d39u,0x0d0d0d1du,0x14636363u,0x103b1414u),\nuvec4(0x38386363u,0x140d0d17u,0x14150663u,0x04380d63u),\nuvec4(0x3c46040cu,0x1e090746u,0x121f1245u,0x4a46464fu),\nuvec4(0x08221f12u,0x211c0108u,0x0216210fu,0x4108411cu),\nuvec4(0x03120c7au,0x44434408u,0x0f09047eu,0x191c2202u),\nuvec4(0x21030601u,0x65291616u,0x696f6965u,0x69696969u),\nuvec4(0x42555569u,0x55696942u,0x143d1465u,0x1d6b170du),\nuvec4(0x4b4b4e56u,0x58585057u,0x595c5c5cu,0x5d7c5d59u),\nuvec4(0x595d5c5cu,0x7b7b6c83u,0x7b7b7b7bu,0x837b787bu),\nuvec4(0x58587c52u,0x6e53646au,0x390e7974u,0x1d0d0d3du),\nuvec4(0x630d0d0du,0x14636363u,0x17153f14u,0x380d3814u),\nuvec4(0x1b170d38u,0x14173b09u,0x0c05100du,0x0d174604u),\nuvec4(0x1e040e07u,0x4e4c6c05u,0x464a4f4eu,0x0f080853u),\nuvec4(0x0f010102u,0x0102020fu,0x7a41080fu,0x7e03126au),\nuvec4(0x0843438au,0x020f0905u,0x01021c22u,0x1616090au),\nuvec4(0x65653620u,0x69696f69u,0x69696969u,0x55555569u),\nuvec4(0x3b3a3a69u,0x0d0d3d3du,0x5e1d6b17u,0x57574b4fu),\nuvec4(0x5c5c5850u,0x7c595c5cu,0x5c5d595du,0x885d5c5cu),\nuvec4(0x6c6c7f7fu,0x896c6c89u,0x6c6c787bu,0x6a585d83u),\nuvec4(0x746c7164u,0x17460c7au,0x0d1d0d38u,0x63630d0du),\nuvec4(0x17636363u,0x14170505u,0x1b381763u,0x18101714u),\nuvec4(0x0d141467u,0x04050410u,0x03381d10u,0x0c05110eu),\nuvec4(0x4e5e4e6au,0x514e4e4eu,0x1c011808u,0x0f020201u),\nuvec4(0x44440219u,0x120e4141u,0x016e0c04u,0x03014343u),\nuvec4(0x22020f1fu,0x061c021cu,0x21161622u,0x6f656555u),\nuvec4(0x6969696fu,0x55696969u,0x69695555u,0x3d1b6155u),\nuvec4(0x1d1d0d17u,0x575e1d1du,0x58575750u,0x5c5d5c58u),\nuvec4(0x597c5d58u,0x5c5d5959u,0x83595c58u,0x87878383u),\nuvec4(0x7b6c8383u,0x86787878u,0x716c837fu,0x0e6e6c74u),\nuvec4(0x0d3c3c1eu,0x0d0d0d0du,0x6363630du,0x06143814u),\nuvec4(0x63636348u,0x1b0d0d1bu,0x3f48140du,0x0d141414u),\nuvec4(0x1004043bu,0x0e07461du,0x6a6c0305u,0x4e575b5eu),\nuvec4(0x79515b4eu,0x1c010808u,0x18030e41u,0x41444343u),\nuvec4(0x6a120e08u,0x44011f05u,0x1f090143u,0x1c22020fu),\nuvec4(0x18030f19u,0x54261616u,0x6f6f7565u,0x69696f69u),\nuvec4(0x55556969u,0x54696969u,0x14171467u,0x1d1d3e1du),\nuvec4(0x4b4f561du,0x58585757u,0x5c5c5d5cu,0x5d59595du),\nuvec4(0x585c5c5du,0x7f83595cu,0x83837f87u,0x78788983u),\nuvec4(0x787d7d76u,0x717d7878u,0x4553536au,0x0d0d5617u),\nuvec4(0x0d0d0d0du,0x14636363u,0x48031463u,0x0d141714u),\nuvec4(0x17141417u,0x1413063du,0x63146314u,0x170d3b3bu),\nuvec4(0x030e0746u,0x50536e1fu,0x665b4e4eu,0x448b4d4eu),\nuvec4(0x041f0801u,0x08124645u,0x41444443u,0x6a12120eu),\nuvec4(0x4301846cu,0x0f1f0e44u,0x0f1c2202u,0x1608070fu),\nuvec4(0x65612716u,0x696f6f75u,0x6969696fu,0x69555569u),\nuvec4(0x1b656969u,0x17145a17u,0x1d6b1d17u,0x50574e56u),\nuvec4(0x5c5c5c50u,0x5d5c5d5cu,0x5c5c5959u,0x5c5c5c5cu),\nuvec4(0x83838859u,0x7c837f7fu,0x7b89877cu,0x86787b7bu),\nuvec4(0x6a52787bu,0x1d565012u,0x0d0d0d0du,0x63630d0du),\nuvec4(0x63636363u,0x14480614u,0x1b38103du,0x14140d10u),\nuvec4(0x14140606u,0x63146363u,0x0d173e38u,0x1f1f0e05u),\nuvec4(0x66586c6eu,0x59576666u,0x6c798b8cu,0x4c4f4512u),\nuvec4(0x440c464au,0x0e014344u,0x1f6a4c04u,0x43437e08u),\nuvec4(0x430f097eu,0x0f0f0f22u,0x2002081fu,0x6f65652au),\nuvec4(0x6f696f6fu,0x69695569u,0x69695555u,0x3d5a8054u),\nuvec4(0x3e173e14u,0x561d1d3cu,0x5057575bu,0x5c585c5cu),\nuvec4(0x595d5d5du,0x5d5d5c5du,0x5c58585cu,0x7b6c8359u),\nuvec4(0x8d7c7f7bu,0x605d585du,0x58595960u,0x126c5259u),\nuvec4(0x3c563c56u,0x0d0d0d3cu,0x63630d0du,0x14143863u),\nuvec4(0x38144806u,0x071f2205u,0x3b1a1b3fu,0x0d5a6304u),\nuvec4(0x63141438u,0x043e0d0du,0x6c6c1f1fu,0x5f50536cu),\nuvec4(0x8c6e5250u,0x4f4f1253u,0x4b504b4fu,0x4443054au),\nuvec4(0x051f0844u,0x796e6a12u,0x0843440eu,0x22430f09u),\nuvec4(0x2201430fu,0x48160201u,0x6f756565u,0x6f6f6f6fu),\nuvec4(0x69696969u,0x65544255u,0x17175a5au,0x17171717u),\nuvec4(0x5e1d1d1du,0x5d58574fu,0x5c5c5d5cu,0x5d5d595du),\nuvec4(0x5c5d5d5du,0x7c58605fu,0x7b897f7cu,0x837b787bu),\nuvec4(0x58585983u,0x64576058u,0x1d50536cu,0x0d380d17u),\nuvec4(0x0d0d0d0du,0x0d0d0d0du,0x05173838u,0x053b1b48u),\nuvec4(0x1f041004u,0x051b1b03u,0x63141763u,0x38141414u),\nuvec4(0x0739170du,0x6c6e4d1fu,0x526c6e53u,0x575f647fu),\nuvec4(0x58586666u,0x4f4b4b57u,0x848a430cu,0x4c6a1f41u),\nuvec4(0x1f796e6au,0x22084344u,0x0f180241u,0x0f180143u),\nuvec4(0x65362102u,0x6f6f7565u,0x69696f6fu,0x3a696969u),\nuvec4(0x5a626555u,0x17171717u,0x8e1d3e3eu,0x4f5e1d8eu),\nuvec4(0x5c5c5857u,0x5d5c5d59u,0x5d595d5du,0x585c5d5du),\nuvec4(0x7c5d5f60u,0x867b6c83u,0x867b7878u,0x83838389u),\nuvec4(0x4d746c83u,0x1d3c561eu,0x0d0d0d0du,0x0d0d0d0du),\nuvec4(0x170d0d0du,0x1f060d63u,0x14150415u,0x3b1b143du),\nuvec4(0x1b041b3bu,0x0d0d1417u,0x0d0d140du,0x0c051017u),\nuvec4(0x64536c0cu,0x5f575c64u,0x5f8f668fu,0x50597f7cu),\nuvec4(0x7a505058u,0x84848a43u,0x0c4c124du,0x446e7974u),\nuvec4(0x417a4143u,0x431c1802u,0x020f081cu,0x65653a01u),\nuvec4(0x6f6f6f75u,0x696f6969u,0x54696969u,0x175a6367u),\nuvec4(0x3e3e1717u,0x1d8e3c3eu,0x574f5e1du,0x595c5c58u),\nuvec4(0x5d5d5c59u,0x5d59595du,0x905c5d5du,0x7c5d5860u),\nuvec4(0x86867b6cu,0x897b7886u,0x7064837fu,0x5e126c6cu),\nuvec4(0x3c0d3c1au,0x0d0d383cu,0x0d0d0d0du,0x0d380d0du),\nuvec4(0x04030417u,0x0d631715u,0x131b3d38u,0x171b0439u),\nuvec4(0x630d0d14u,0x17380d0du,0x4a4a3b0du,0x565b5b4fu),\nuvec4(0x584e6656u,0x7d6c6c64u,0x4e58537du,0x448b514eu),\nuvec4(0x4d088b8au,0x6e6c124cu,0x438a1f7au,0x02010801u),\nuvec4(0x1c431c18u,0x24021601u,0x6f656561u,0x69696f6fu),\nuvec4(0x696f6f69u,0x62656969u,0x3e175a5au,0x1d1d3e3eu),\nuvec4(0x1d1d491du,0x58584f5eu,0x597c5c58u,0x5d5d5c5du),\nuvec4(0x5c5d597cu,0x905f5c5du,0x7f59585fu,0x7b7b867bu),\nuvec4(0x8686786eu,0x6c716c7bu,0x3c6b1d6au,0x0d0d0d1du),\nuvec4(0x0d0d0d0du,0x0d0d0d0du,0x1414380du,0x3f390613u),\nuvec4(0x1b1b1763u,0x393b6317u,0x0d141b05u,0x1717170du),\nuvec4(0x1d17383eu,0x4e5e5e49u,0x584e5756u,0x7d866c52u),\nuvec4(0x5d6c7d7du,0x595b5b57u,0x8a8b4484u,0x4c4d088bu),\nuvec4(0x6e53536au,0x4444016cu,0x18020108u,0x1c1c1901u),\nuvec4(0x61271616u,0x6f6f7565u,0x6969696fu,0x42696f69u),\nuvec4(0x5a146254u,0x3e171717u,0x45460d1du,0x561d565eu),\nuvec4(0x5858584fu,0x5d597c5cu,0x7c5d5d5cu,0x5d5c5d7cu),\nuvec4(0x58585c5du,0x7b835d58u,0x74867b86u,0x7d7d7d7du),\nuvec4(0x4f537374u,0x0d1d6b1au,0x0d0d0d0du,0x0d0d0d0du),\nuvec4(0x0d0d0d0du,0x0417141bu,0x17041507u,0x383d380du),\nuvec4(0x043b3b15u,0x0d0d141bu,0x0d0d630du,0x1d1d1d0du),\nuvec4(0x59584e56u,0x7d865251u,0x867d8b7du,0x574e4e52u),\nuvec4(0x8a6e5950u,0x8b8b0844u,0x644c0c79u,0x6c03126au),\nuvec4(0x01444401u,0x0118021cu,0x160f1c02u,0x65652716u),\nuvec4(0x6f6f6f75u,0x696f6969u,0x723a6969u,0x17141768u),\nuvec4(0x1d171717u,0x5e5e4949u,0x5b565656u,0x5d5c585fu),\nuvec4(0x5d5d7c7cu,0x7c7c5d5du,0x5d5d5c5du,0x5858585cu),\nuvec4(0x6c7f7c5du,0x7676867bu,0x747d7d76u,0x3c85506cu),\nuvec4(0x0d0d1d3cu,0x0d0d0d0du,0x0d0d0d0du,0x1b0d0d0du),\nuvec4(0x033b3d0du,0x3d383f15u,0x03041717u,0x1b13393bu),\nuvec4(0x14171717u,0x0d3e0d38u,0x5e490d0du,0x746c514bu),\nuvec4(0x7f868c8cu,0x5f605952u,0x504e504eu,0x8b43446eu),\nuvec4(0x7a8b8479u,0x05534c05u,0x8a0e6c12u,0x0f1c4344u),\nuvec4(0x021c1802u,0x1616160fu,0x75727229u,0x6975756fu),\nuvec4(0x69696f69u,0x14627569u,0x3e3e1417u,0x1d1d1d1du),\nuvec4(0x5656561du,0x575b5656u,0x7c5d5d5cu,0x5d5d5d7cu),\nuvec4(0x5d7c7c5du,0x5c5d5d5cu,0x5c585858u,0x6c53645du),\nuvec4(0x74746e71u,0x6a737674u,0x1d1d6b5eu,0x0d0d0d1du),\nuvec4(0x0d0d0d0du,0x0d0d0d0du,0x1b3d0d0du,0x38053b63u),\nuvec4(0x03041f04u,0x1a151f07u,0x633b050du,0x0d171714u),\nuvec4(0x0d171414u,0x5e464a45u,0x6452514bu,0x605f5c59u),\nuvec4(0x4e5b4e5fu,0x43745158u,0x08840844u,0x6a748484u),\nuvec4(0x1e056c4cu,0x4444746cu,0x020f1c43u,0x0f021c18u),\nuvec4(0x0e161616u,0x75657267u,0x69697575u,0x54696f6fu),\nuvec4(0x14146867u,0x491d1d0du,0x5e5e5e5eu,0x5656565eu),\nuvec4(0x5c575b56u,0x7c7c5d59u,0x5959595du,0x5c5d7c7cu),\nuvec4(0x5f585d5du,0x5c585760u,0x6c6c8359u,0x6c6c716cu),\nuvec4(0x8591536cu,0x0d1d3d85u,0x38380d0du,0x0d0d0d0du),\nuvec4(0x0d0d0d0du,0x3d1b1b0du,0x1b14483bu,0x15060e06u),\nuvec4(0x1b1a3d1bu,0x3b1b1003u,0x05043b3bu,0x220e1f1fu),\nuvec4(0x5b4f050eu,0x604e4e57u,0x66668f5fu,0x7a64584eu),\nuvec4(0x7a8b448bu,0x84840808u,0x12120e08u,0x03910492u),\nuvec4(0x43444474u,0x18020f0fu,0x0f0f191cu,0x65331616u),\nuvec4(0x6f6f7572u,0x69696f6fu,0x1b653a3au,0x3c0d1414u),\nuvec4(0x5e564949u,0x5e5e5e5eu,0x565b5b56u,0x595d5756u),\nuvec4(0x597c595du,0x596a5959u,0x5d5d597cu,0x66585959u),\nuvec4(0x575b608fu,0x64646459u,0x1e127712u,0x1d6b8e91u),\nuvec4(0x1d0d0d1du,0x0d0d3e3eu,0x0d0d0d17u,0x0d0d3d3eu),\nuvec4(0x15171414u,0x3b141b07u,0x04043b3bu,0x18030606u),\nuvec4(0x22221f22u,0x13050307u,0x493b1e39u,0x4e5b5656u),\nuvec4(0x8f66665bu,0x7f595f8fu,0x848a8b74u,0x087e7a08u),\nuvec4(0x08080808u,0x6c051e03u,0x08039191u,0x43444301u),\nuvec4(0x1c180202u,0x16161919u,0x72723316u,0x75757565u),\nuvec4(0x3a546f75u,0x14386761u,0x5e56560du,0x5b5b5e5eu),\nuvec4(0x56666666u,0x66666666u,0x5d595c60u,0x597c7c59u),\nuvec4(0x7c595959u,0x7c59597cu,0x5b5b587cu,0x5656565bu),\nuvec4(0x4f4f4e5eu,0x495e5e45u,0x1d1d3c6bu,0x0d1d1717u),\nuvec4(0x3b1b0d0du,0x10103b39u,0x06393b10u,0x0e080615u),\nuvec4(0x1f060704u,0x03130703u,0x050e0404u,0x17381b10u),\nuvec4(0x170d0d14u,0x46560d0du,0x4e4e4e4eu,0x645d5f4eu),\nuvec4(0x797d867fu,0x797a7a79u,0x7e087e7au,0x6a7e7908u),\nuvec4(0x916c5391u,0x087e6e50u,0x020f4444u,0x431c1802u),\nuvec4(0x16161616u,0x65727237u,0x75757575u,0x65546161u),\nuvec4(0x1d3c0d10u,0x5b5b5656u,0x665b5b5bu,0x66666666u),\nuvec4(0x8f666666u,0x595d595cu,0x7c59597cu,0x7c7c5d59u),\nuvec4(0x64647c7cu,0x5b5b5b58u,0x1d6b1d5eu,0x6b1d6b1du),\nuvec4(0x1d1d3c6bu,0x3d170d1du,0x09090b0du,0x09180e1fu),\nuvec4(0x09090909u,0x031f1f1fu,0x390e1803u,0x0d38103bu),\nuvec4(0x1738170du,0x1b031317u,0x0d3e1417u,0x0d1b0d0du),\nuvec4(0x5e1d1717u,0x64515150u,0x6e86866cu,0x6c6e6e7bu),\nuvec4(0x7e7e746cu,0x0879797eu,0x50127479u,0x77490592u),\nuvec4(0x0f7e740eu,0x02020f44u,0x16431c22u,0x36201616u),\nuvec4(0x75657267u,0x61756565u,0x383b6161u,0x56561d0du),\nuvec4(0x9366665bu,0x93939393u,0x93938f93u,0x58939393u),\nuvec4(0x59595d59u,0x597c5959u,0x7c7c595du,0x5d647c59u),\nuvec4(0x1d1d5b60u,0x1d1d1d1du,0x3c3c1d6bu,0x3e1d1d1du),\nuvec4(0x3b1d1d3eu,0x09221803u,0x3b15041fu,0x1b0d0d10u),\nuvec4(0x170d171bu,0x3d100e15u,0x0d0d140du,0x1a173817u),\nuvec4(0x3d0d0304u,0x140d1414u,0x0d0d0d17u,0x4f1d1d1du),\nuvec4(0x5264526au,0x53525252u,0x6e706c70u,0x79747474u),\nuvec4(0x79797979u,0x716a7792u,0x74126b91u,0x0f017e0eu),\nuvec4(0x22020243u,0x16191901u,0x67362016u,0x65656572u),\nuvec4(0x61616175u,0x1d0d103fu,0x5b565656u,0x93939366u),\nuvec4(0x93939393u,0x94939494u,0x595f9393u,0x5959595du),\nuvec4(0x5d7c7c7cu,0x5d7c7c5du,0x57596a59u,0x5e1d1d4fu),\nuvec4(0x496b6b5eu,0x1d1d3c3cu,0x1717171du,0x38173d17u),\nuvec4(0x170d1b10u,0x3d3d3b3eu,0x14140d1bu,0x0417171bu),\nuvec4(0x173d3807u,0x170d0d3du,0x0417631bu,0x0d173807u),\nuvec4(0x0d141414u,0x0d0d1717u,0x4c5e6b1du,0x59595959u),\nuvec4(0x6c536459u,0x7373716eu,0x7979746eu,0x53797479u),\nuvec4(0x5e535350u,0x1f79951du,0x19441c6eu,0x01220202u),\nuvec4(0x16161919u,0x72673620u,0x75756565u,0x39046161u),\nuvec4(0x5e565646u,0x938f6656u,0x93939393u,0x96949493u),\nuvec4(0x90969494u,0x59595894u,0x7c595959u,0x5d597c7cu),\nuvec4(0x775d7c7cu,0x5e126a59u,0x1e50491du,0x17496b49u),\nuvec4(0x1d1d1d1du,0x0d1d1d17u,0x0d1d0d0du,0x103e0d0du),\nuvec4(0x1b170422u,0x1339173eu,0x4813170du,0x0d0d0d1bu),\nuvec4(0x1417381bu,0x03391a14u,0x140d171bu,0x380d143eu),\nuvec4(0x1d3e171du,0x6a505e1du,0x6464646au,0x6c526464u),\nuvec4(0x716c6c6cu,0x766e7473u,0x576a7974u,0x915b6a6cu),\nuvec4(0x03047e92u,0x431c4344u,0x43012219u,0x20161619u),\nuvec4(0x65726736u,0x61757575u,0x1b103f04u,0x664e4649u),\nuvec4(0x93939366u,0x94939393u,0x96989797u,0x90969896u),\nuvec4(0x59595958u,0x7c7c5959u,0x7c5d7c7cu,0x77585d7cu),\nuvec4(0x1d5e646au,0x3905506bu,0x1d173e17u,0x1d1d1d1du),\nuvec4(0x1d170d1du,0x1d0d0d0du,0x030d3e1du,0x3b3d100eu),\nuvec4(0x1b130103u,0x1b1f3b1au,0x1717173du,0x380d0d3eu),\nuvec4(0x1b070414u,0x0d0d3814u,0x5a141414u,0x1d0d1d17u),\nuvec4(0x584c561du,0x58585858u,0x7c596459u,0x6c6c837cu),\nuvec4(0x746e6c6cu,0x6c585874u,0x5391565du,0x43539153u),\nuvec4(0x43430f43u,0x19190122u,0x36161616u,0x75657267u),\nuvec4(0x3f3f6175u,0x46464604u,0x665b4e4eu,0x93939393u),\nuvec4(0x97949393u,0x96969696u,0x5c969698u,0x59595959u),\nuvec4(0x7c7c7c59u,0x7c7c5d7cu,0x6a58585du,0x1a911253u),\nuvec4(0x38050345u,0x3e3e171du,0x1d1d1d1du,0x0d0d1d1du),\nuvec4(0x0d0d0d0du,0x09140d0du,0x08081503u,0x3d141b13u),\nuvec4(0x171b0739u,0x0d0d3838u,0x1a140d1bu,0x1710093bu),\nuvec4(0x0d0d1414u,0x0d141714u,0x1d1d0d0du,0x50915e5eu),\nuvec4(0x50505050u,0x596a6a77u,0x5252537cu,0x536e706cu),\nuvec4(0x586c6a57u,0x454a5e85u,0x0f440349u,0x22194319u),\nuvec4(0x16020201u,0x67331616u,0x65757572u,0x39046161u),\nuvec4(0x4e4e5e56u,0x93936666u,0x94949393u,0x96969697u),\nuvec4(0x98969696u,0x99989698u,0x7c7c5959u,0x7c7c7c7cu),\nuvec4(0x777c6a5du,0x716a5858u,0x1a1d536eu,0x171b1f05u),\nuvec4(0x1d1d3e3eu,0x1d1d3e1du,0x0d0d1d1du,0x0d0d0d0du),\nuvec4(0x08101a1bu,0x3c040e0fu,0x1b0d170du,0x38171003u),\nuvec4(0x1d170d3eu,0x040d3e3eu,0x14171007u,0x14170d0du),\nuvec4(0x380d140du,0x491d173eu,0x91919145u,0x95777777u),\nuvec4(0x95955295u,0x95959595u,0x45056c6cu,0x49506c12u),\nuvec4(0x451d4549u,0x190f4303u,0x0122020fu,0x160f1916u),\nuvec4(0x72722a16u,0x61657575u,0x564a4705u,0x665b5b5eu),\nuvec4(0x93939393u,0x97949493u,0x96969696u,0x9a969696u),\nuvec4(0x59599898u,0x7c7c7c7cu,0x597c7c7cu,0x5f5d527cu),\nuvec4(0x796c6a58u,0x0c450484u,0x3e17380cu,0x1d1d3e3eu),\nuvec4(0x0d1d1d1du,0x0d171d0du,0x0d0d0d0du,0x010f060du),\nuvec4(0x3c173c04u,0x031b0d0du,0x3817173bu,0x1d0d3e1bu),\nuvec4(0x09391d1du,0x1417173bu,0x0d0d1714u,0x1d0d3d1au),\nuvec4(0x498e3e17u,0x9b779191u,0x9f9e9d9cu,0x9f0e9292u),\nuvec4(0x959b929fu,0x0b3b0b9bu,0x491d4503u,0x07451d46u),\nuvec4(0x0f0f0f43u,0x16012202u,0x16160f0fu,0x7572720eu),\nuvec4(0x05616565u,0x5b5e4a47u,0x93665b5bu,0x94939393u),\nuvec4(0x96979494u,0x96969696u,0x9a9a9696u,0x7c7c7c9au),\nuvec4(0x7c7c7c7cu,0x7c597c7cu,0x57586a83u,0x44745258u),\nuvec4(0x050e1f08u,0x3e3e1d0du,0x1d1d1d3eu,0x380d1d1du),\nuvec4(0x38100d0du,0x221b143eu,0x0e030701u,0x0d171a04u),\nuvec4(0x3b050d0du,0x453e1d17u,0x03070539u,0x101f0705u),\nuvec4(0x0d143d3du,0x10391b0du,0xa03b3b10u,0xa03ea1a0u),\nuvec4(0x9e9e9d9bu,0x9e9e9e9fu,0xa2a29e9eu,0x9b9b9d9fu),\nuvec4(0x9b0b3b0bu,0x38494991u,0x021f451du,0x021c0f0fu),\nuvec4(0x0f160118u,0x18161601u,0x65657265u,0x39040565u),\nuvec4(0x5b4e4e46u,0x9493938fu,0x94939394u,0x96969794u),\nuvec4(0x96969696u,0x999a9a9au,0x7c7c7c88u,0x7c7c597cu),\nuvec4(0x83595d7cu,0x60605864u,0x438b6c58u,0x3d11088au),\nuvec4(0x173e3e17u,0x1d1d1d1du,0x170d1d1du,0x170d0d17u),\nuvec4(0x0301090du,0x0905173du,0x3c0d0d39u,0x3b39050du),\nuvec4(0x087e0e05u,0x0e180101u,0x1b39030eu,0x0b0b391bu),\nuvec4(0x1f050b13u,0x9c9f1f0eu,0x9d9ca0a0u,0x9d9f9e9fu),\nuvec4(0x9e9e9e9eu,0xa3a3a3a3u,0x9c9f9ea2u,0x1da0a004u),\nuvec4(0x1d38381du,0x0f020e45u,0x18021c01u,0x011c1601u),\nuvec4(0x65271616u,0x65656572u,0x464a0405u,0x938f4e4eu),\nuvec4(0x94949493u,0x94949493u,0x96969697u,0x96969696u),\nuvec4(0x88999a9au,0x7c887c7cu,0x7c7c7c59u,0x64835d7cu),\nuvec4(0x5b5b605cu,0x7a796457u,0x3d1d030eu,0x1d17171du),\nuvec4(0x1d1d1d1du,0x0d0d0d1du,0x0d0d381bu,0x0d173b39u),\nuvec4(0x03071b0du,0x383d1717u,0x0f0e0303u,0x08011c44u),\nuvec4(0x050c1f18u,0x4504051fu,0x1010450du,0xa11d1d10u),\nuvec4(0x0ba4a1a1u,0x9d9e9e9cu,0xa6a5a59du,0xa7a7a6a6u),\nuvec4(0xa3a3a7a7u,0x9fa2a2a3u,0x1b1a1d0bu,0x103e0d1bu),\nuvec4(0x010f0222u,0x0122021cu,0x16080116u,0x72610816u),\nuvec4(0x3f3f6565u,0x4e4e4539u,0x9393938fu,0x94949494u),\nuvec4(0x97949494u,0x96969696u,0x9a969696u,0x7c88999au),\nuvec4(0x7c7c8888u,0x7c7c7c7cu,0x5c52885du,0x568f4e5fu),\nuvec4(0x124c515bu,0x1d3c1e6eu,0x1d1d3e3eu,0x0d1d1d1du),\nuvec4(0x3e0d0d1du,0x3d171717u,0x1a0d170du,0x3b040517u),\nuvec4(0x091e4a3bu,0x01440108u,0x7e7e0808u,0x08797974u),\nuvec4(0x3d390e7eu,0x3e173d1au,0xa9a8a817u,0x9d9ca480u),\nuvec4(0x9ea3a2a3u,0xacabaaa5u,0xa7ada6acu,0xa3a7a7a7u),\nuvec4(0x9fa2a3aeu,0xa15aa8a0u,0x183b1d1du,0x1c080102u),\nuvec4(0x16012202u,0x160f1808u,0x65725401u,0x4a043f3fu),\nuvec4(0x8f4e4e46u,0x94949393u,0x94949494u,0x96979494u),\nuvec4(0x96969696u,0x9a9a9696u,0x837c8899u,0x7c7c7c83u),\nuvec4(0x5d7c7c7cu,0x585d8388u,0x4e5f605fu,0x055e4e50u),\nuvec4(0x3e1d5653u,0x3e1d1d1du,0x3d1d1d1du,0x0d3d1d17u),\nuvec4(0x391b1010u,0x03050504u,0x03030c1fu,0x087e0e1fu),\nuvec4(0x01437908u,0x79797e08u,0x6e7a018au,0x17173b03u),\nuvec4(0xa13e0d1du,0xa4a9a8a8u,0xa39ea5afu,0xaba6a3a3u),\nuvec4(0xacb1acb0u,0xadadb2acu,0xa7a3a7a7u,0xb3a3a3a7u),\nuvec4(0x1da1a880u,0x0208391bu,0x19011801u,0x08160122u),\nuvec4(0x21160f18u,0x61656755u,0x5e45473fu,0x938f604eu),\nuvec4(0x94949493u,0x94949494u,0x96969794u,0x96969696u),\nuvec4(0x599a9a96u,0x83837c83u,0x7c7c7c83u,0x835d7c7cu),\nuvec4(0x90585987u,0x4e8f5f8fu,0x6e505650u,0x1d3e3c12u),\nuvec4(0x3e171d1du,0x0b0d171du,0x180e090eu,0x22221809u),\nuvec4(0x04030307u,0x0c1e4c04u,0x7974747au,0xb584b401u),\nuvec4(0x8a8a43b4u,0x1e056e7eu,0x1d1d1d45u,0xa8a9a83eu),\nuvec4(0xaaafa4a8u,0xa3a3a6a5u,0xabaca7a3u,0xb2b6b6acu),\nuvec4(0xadb2b2b2u,0xb8b8a7b7u,0xb3a3a3a7u,0x1b0da962u),\nuvec4(0x01020104u,0x22190122u,0x09011901u,0x4821021cu),\nuvec4(0x473f6515u,0x4e4e4a4au,0x94949460u,0x94949494u),\nuvec4(0x94949494u,0x96969697u,0x96969696u,0x83999a9au),\nuvec4(0x83838383u,0x7c647c7cu,0x83887c59u,0x94905d88u),\nuvec4(0x505f5c60u,0x054c564eu,0x1d1d4946u,0x1d1d1d1du),\nuvec4(0x0c040d17u,0x0b0a0c0cu,0x38103b3bu,0x6b49490du),\nuvec4(0x0e0e0546u,0xb9797e0eu,0xb4b5b584u,0x6eb98484u),\nuvec4(0x6b45126cu,0x173e1d85u,0xa9a8a8a1u,0xabaaaabau),\nuvec4(0xa7a7a6a6u,0xb6acaca6u,0xb2b2b2b2u,0xadadadb2u),\nuvec4(0xa7a7b7b7u,0xb3aeb7b7u,0x03a15a80u,0x0e011601u),\nuvec4(0x01220f01u,0x011f0116u,0x650e0f16u,0x4a473f15u),\nuvec4(0x60604e4eu,0x94949494u,0x94949497u,0x97949494u),\nuvec4(0x96bbbb96u,0x9a989696u,0x8383999au,0x83838383u),\nuvec4(0x7c7c6464u,0x8883887cu,0x5860585du,0x5b575f5du),\nuvec4(0x494f4e56u,0x1d3c1d1du,0x0d3e1d1du,0x0d38380du),\nuvec4(0x383e0d3eu,0x490d1d0du,0x535e3c1du,0x7474746eu),\nuvec4(0xb9b9b976u,0x7d7d7d7du,0x6a526e7du,0x4945914fu),\nuvec4(0xa93e3e1du,0xafa4a9a8u,0xa6a6b0aau,0xaca6a6a6u),\nuvec4(0xb6b1acacu,0xb2b2b2b2u,0xadadadb2u,0xb7b7b7adu),\nuvec4(0xb3a7b7b7u,0x162a5aa9u,0x010e1820u,0x02012219u),\nuvec4(0x16080301u,0x153f0816u,0x4e453904u,0x9460608fu),\nuvec4(0x97979494u,0x94949497u,0x96969797u,0x9696bbbbu),\nuvec4(0x9a9a9696u,0x83838399u,0x83838383u,0x7c7c7c64u),\nuvec4(0x59888888u,0x5c586058u,0x665b4e60u,0x3c1d1d56u),\nuvec4(0x1d3c3c6bu,0x1d3e3e3eu,0x3e3e173eu,0x1d1d0d3eu),\nuvec4(0x6b49491du,0x76796a49u,0x73747474u,0xb9b9b976u),\nuvec4(0xb97db976u,0x506a6a71u,0x3e1b3b50u,0xa9a81d17u),\nuvec4(0xbcaaba80u,0xacaca6b0u,0xacacacacu,0xb2acb6b6u),\nuvec4(0xb2b2b2b2u,0xadadb2b2u,0xb7adadadu,0x72a3b7b7u),\nuvec4(0x2016181bu,0x020f090eu,0x01020122u,0x1602180cu),\nuvec4(0x47670501u,0x8f4e4e39u,0x94979760u,0x97979794u),\nuvec4(0x97949394u,0x96969697u,0x969abb96u,0x59999a96u),\nuvec4(0x83888383u,0x83648383u,0x7c7c837cu,0x9abd8888u),\nuvec4(0x60585896u,0x5b574e60u,0x6b6b6b1du,0x1d1d1d3cu),\nuvec4(0x1d0d3e3eu,0x0d381b1du,0x49490d0du,0x121d6b49u),\nuvec4(0x7373b96eu,0x73737373u,0xb9767676u,0x73767d7du),\nuvec4(0x1e046c71u,0x173e1d91u,0xbaa9a81du,0xabbcbcabu),\nuvec4(0xacacacacu,0xacacacacu,0xb2b2b2b6u,0xb2b2b2b2u),\nuvec4(0xadadadb2u,0xadadadadu,0x5433b8b7u,0x1f202025u),\nuvec4(0x7a020f09u,0x0a010201u,0x2102020eu,0x4a3b3906u),\nuvec4(0x94604e4eu,0x97949797u,0x94979797u,0x97979494u),\nuvec4(0x97979497u,0x98969696u,0x839999bbu,0x83838883u),\nuvec4(0x7c838388u,0x88887c83u,0x96bbbd88u,0x605c5d5du),\nuvec4(0x565b5757u,0x1d3c6b1du,0x1d1d1d1du,0x171d0d1du),\nuvec4(0x1d171d0du,0x8e491d49u,0x766e506bu,0x74737373u),\nuvec4(0x74747474u,0xb9767474u,0x76797d7du,0x4991046eu),\nuvec4(0xa83e1d3eu,0xabaaa4a9u,0xb1abbcbcu,0xacacacacu),\nuvec4(0xb6acacacu,0xb2b2b2b2u,0xb2b2b2b2u,0xadadadb2u),\nuvec4(0xb7b7b7adu,0x23aea3a3u,0x1f072020u,0x017a020fu),\nuvec4(0x070a0116u,0x090f020fu,0x4e451039u,0x9794604eu),\nuvec4(0x97979497u,0x94949497u,0x93979697u,0x93939393u),\nuvec4(0x599a9696u,0x887c5c9au,0x8883887cu,0x83838383u),\nuvec4(0x8388887cu,0xbb585988u,0x4e5f5d5du,0x1d565b5fu),\nuvec4(0x1d1d1d1du,0x3e1d1d1du,0x0d1d1d1du,0x490d0d0du),\nuvec4(0x91498e6bu,0x73737d6cu,0x74747676u,0x73747474u),\nuvec4(0xbe767373u,0x53747d8bu,0x173e4950u,0xa4a95a3eu),\nuvec4(0xbcbcaaafu,0xc0bfc0bfu,0xacacacacu,0xb6acacacu),\nuvec4(0xb2b2b2b2u,0xb2b2b2b2u,0xadadadadu,0xb8b7adadu),\nuvec4(0x1620b8b8u,0x0f1f0601u,0x0f012202u,0x0105030fu),\nuvec4(0x04181902u,0x4e664645u,0x94979460u,0x97979794u),\nuvec4(0x97949494u,0x93939797u,0x96949493u,0x989a9898u),\nuvec4(0x7c7c5998u,0x887c887cu,0x7c7c7c83u,0x8888887cu),\nuvec4(0x58bb9abdu,0x5f605f5du,0x1d1d5e5bu,0x1d1d1d1du),\nuvec4(0x3e3e1d1du,0x1d0d0d0du,0x8e493e0du,0xb953918eu),\nuvec4(0x767673b9u,0x74747476u,0x73737874u,0x847d7673u),\nuvec4(0x49127176u,0xa8173e3cu,0xaaafa4a1u,0xbfc1bcbcu),\nuvec4(0xb1c0bfbfu,0xacacacacu,0xb6b6b2acu,0xb2b2b2b2u),\nuvec4(0xb2b2b2b2u,0xadadadadu,0xb8b8adadu,0x18162023u),\nuvec4(0x020f0904u,0x0f0f0122u,0x02080403u,0x46040802u),\nuvec4(0x608f565eu,0x94979794u,0x94979797u,0x94949394u),\nuvec4(0x97939394u,0x9abb9a96u,0x5c989a98u,0x7c8d997cu),\nuvec4(0x887c7c7cu,0x7c7c7c7cu,0xbd88887cu,0x5d9abb9au),\nuvec4(0x665f5f5fu,0x6b1d1d5eu,0x3e3e3c6bu,0x1d3e1d3eu),\nuvec4(0x381d170du,0x49491d0du,0x92767377u,0x74747674u),\nuvec4(0x78747476u,0x74787b78u,0x6e767674u,0x85855053u),\nuvec4(0xa0a8a81du,0xbcaaaf9fu,0xc1c1bfbcu,0xacacacc0u),\nuvec4(0xacacacacu,0xb2b6b6b6u,0xb2b2b2b2u,0xadb2b2b2u),\nuvec4(0xadadadadu,0x20b8a3b7u,0x040e2020u,0x22020f0eu),\nuvec4(0x0c010f08u,0x020f2204u,0x5e1d0c08u,0x9460605bu),\nuvec4(0x94949497u,0x93949497u,0x93949394u,0xc2bb5894u),\nuvec4(0x99bdbdbdu,0x595c9898u,0x7c5d8d59u,0x7c7c7c7cu),\nuvec4(0x59597c88u,0x59598888u,0x585dbbbbu,0x565b8f5fu),\nuvec4(0x6b8e1d6bu,0x3e3e3e1du,0x171d3817u,0x49170d38u),\nuvec4(0x92778e1du,0x76927176u,0x74747474u,0x78747474u),\nuvec4(0x73787878u,0x71717173u,0xa88e4912u,0xaabaa0a8u),\nuvec4(0xc4bcbcc3u,0xa6abc4bcu,0xa6a7a7a7u,0xacacaca6u),\nuvec4(0xb2b2b2b6u,0xb2b2b2b2u,0xadadadadu,0xb7b7adadu),\nuvec4(0x202320b8u,0x0e040320u,0x0822020fu,0x040c0143u),\nuvec4(0x44431c1fu,0x5b565e1fu,0x97976060u,0x97949494u),\nuvec4(0x94949494u,0x58949493u,0x88c288bdu,0x9a59bd88u),\nuvec4(0x59999a5cu,0x59595c5cu,0x7c7c7c59u,0x88597c7cu),\nuvec4(0xbdbd7c88u,0x60909a59u,0x6b565b8fu,0x8e6b8e1du),\nuvec4(0x1d1d3e1du,0x1d491d17u,0x6b49491du,0x73746c50u),\nuvec4(0x74747473u,0x74747474u,0x7b787474u,0x71717b7bu),\nuvec4(0x126e7171u,0xa1a81749u,0xbcbaafbau,0xc4c4c4c4u),\nuvec4(0xa7a6a6b0u,0xaca6a6a7u,0xb6acacacu,0xb2b2b2b2u),\nuvec4(0xadb2b2b2u,0xadadadadu,0xb8b7b7adu,0x24202020u),\nuvec4(0x0f090405u,0x02082216u,0x0c040c08u,0x7a434308u),\nuvec4(0x8f8f1d50u,0x94979460u,0x94979494u,0x93939494u),\nuvec4(0xc2bd5894u,0x8387c2c2u,0x99597c88u,0x90999a99u),\nuvec4(0x5c5c5c90u,0x7c597c59u,0x887c597cu,0xbd888888u),\nuvec4(0x6060909au,0x1d1d565bu,0x1d1d6b8eu,0x3e0d1d3eu),\nuvec4(0x491d1d1du,0x70458549u,0x769273b9u,0x74747376u),\nuvec4(0x74747474u,0x7b7b7878u,0x71706c71u,0x49777192u),\nuvec4(0xa5a0a81au,0xc4c4c3aau,0xabc4c4c4u,0xa7a3a7a6u),\nuvec4(0xacaca6a6u,0xb6b6b6acu,0xb2b2b2b2u,0xadb2b2b2u),\nuvec4(0xadadadadu,0xc523b7b7u,0x13182020u,0x16210e13u),\nuvec4(0x0102080eu,0x7e0c040cu,0x6a084343u,0x94938f56u),\nuvec4(0x94949794u,0x94949494u,0x58939394u,0xc2898759u),\nuvec4(0x83c2c2c2u,0x597c8888u,0x90905999u,0x595c5c5cu),\nuvec4(0x597c7c59u,0x7c7c598du,0x5dbd88bdu,0x5b5f5f58u),\nuvec4(0x6b1d6b56u,0x173c1d6bu,0x3e491d3eu,0x6b1d4917u),\nuvec4(0xb976705eu,0x74767473u,0x74747474u,0x78787474u),\nuvec4(0x897b7b7bu,0x6c739289u,0xa88e4595u,0xaaaaa4a9u),\nuvec4(0xc4c4bcbcu,0xa6abc4c4u,0xa6a7a3a7u,0xacacaca6u),\nuvec4(0xb6b6b6b1u,0xb2b2b2b6u,0xadb2b2b2u,0xb7b7adadu),\nuvec4(0x162323b7u,0x05042a20u,0x0e160f0eu,0x0a1c1908u),\nuvec4(0x431f0c04u,0x5b4d8a43u,0x94949366u,0x94949497u),\nuvec4(0x93949494u,0x525dc693u,0x89878989u,0x8387c2c2u),\nuvec4(0x7c888383u,0x96909059u,0x595d5c5cu,0x5c8d7c7cu),\nuvec4(0xbd597c59u,0x585dbd88u,0x565b605fu,0x6b6b1d1du),\nuvec4(0x3e173c1du,0x1d1d0d17u,0x6c458549u,0x73767db9u),\nuvec4(0x74787476u,0x74747474u,0x7b7b7874u,0x73737b71u),\nuvec4(0x91959276u,0x80a8176bu,0xb0bcaaafu,0xc4c4c4c4u),\nuvec4(0xa6acb0c4u,0xaca6a6a6u,0xb1acacacu,0xb6b6b6b6u),\nuvec4(0xb2b2b2b2u,0xadadb2b2u,0xa3b7adadu,0x24202323u),\nuvec4(0x0e050403u,0x0122160fu,0x04050f0fu,0x43010c03u),\nuvec4(0x66507a43u,0x94979493u,0x94939394u,0x93939394u),\nuvec4(0x89c2bd94u,0xc2c787c2u,0xc2c2c2c2u,0x7c83c2c2u),\nuvec4(0x9090905cu,0x88595d5cu,0x595c5c59u,0x87bd5959u),\nuvec4(0x6058bd52u,0x1d565b8fu,0x1d6b1d1du,0x3c1d3c1du),\nuvec4(0x856b1d3cu,0xb97d6e50u,0x747476b9u,0x74747474u),\nuvec4(0x78787874u,0x717b7b78u,0x92747673u,0x6b6b9195u),\nuvec4(0xafa0a8a8u,0xc4b0bcaau,0xbcc4c4c4u,0xacabb0c4u),\nuvec4(0xacabababu,0xb6b6b1acu,0xb2b2b6b6u,0xb2b2b2b2u),\nuvec4(0xadadb2b2u,0xc5a3b7a7u,0x05182020u,0x0f0e0554u),\nuvec4(0x0f012202u,0x0c040301u,0x43442205u,0x9466648bu),\nuvec4(0x94949794u,0x93949393u,0x58c8c893u,0x89c2c287u),\nuvec4(0x898989c2u,0x7b89c289u,0x7c87c2c7u,0x96909659u),\nuvec4(0x5d88599au,0x5c5d5c58u,0x5288885du,0x8f8f58bdu),\nuvec4(0x561d565bu,0x1d1d3c1du,0x1d1d1d3cu,0x6e916b8eu),\nuvec4(0x74747684u,0x74747676u,0x74747474u,0x7b7b7878u),\nuvec4(0x6e737b7bu,0x45775371u,0x173c856bu,0xafafa0a8u),\nuvec4(0xc4c4c4aau,0xbcbcc4c4u,0xb0b0c4bcu,0xacacacb0u),\nuvec4(0xb6b6b6b1u,0xb2b2b2b6u,0xb2b2b2b2u,0xa7adadb2u),\nuvec4(0x1620b8b7u,0x050503c5u,0x020f0e05u,0x01020122u),\nuvec4(0x0c050503u,0x44430109u,0x93604e6eu,0x93949494u),\nuvec4(0x93c69393u,0x7b59c6c8u,0x89c7c289u,0xc7c78989u),\nuvec4(0x7b7bc789u,0x88c27bc7u,0x9a90c65cu,0x905cbd59u),\nuvec4(0x5c585c5cu,0xbdbd5988u,0x8f4e5f5du,0x1d561d66u),\nuvec4(0x3c3c1d6bu,0x8e49491du,0x73769291u,0x76747d76u),\nuvec4(0x7674747du,0x7b787474u,0x737b7b7bu,0x6a707373u),\nuvec4(0x6b6b1d91u,0x1d3e6b8eu,0xaababaa0u,0xc4c4c4aau),\nuvec4(0xc4c1c1c4u,0xabb0b0c4u,0xb1b1acacu,0xb6b6b6b6u),\nuvec4(0xb2b2b2b6u,0xb2b2b2b2u,0xb7a7a7adu,0x081623b8u),\nuvec4(0x13030404u,0x22020f0eu,0x05080208u,0x04050504u),\nuvec4(0x84434318u,0x96936659u,0x93979394u,0xc9c99493u),\nuvec4(0xc2898890u,0x7b898989u,0xc78989c7u,0x7b7b7b7bu),\nuvec4(0x5c877b7bu,0x59909094u,0x5c5f5cbdu,0x595f5f5cu),\nuvec4(0x5dbdbd5du,0x66668f5fu,0x6b851d56u,0x6b6b1d49u),\nuvec4(0x53507712u,0x76737d7du,0x76767474u,0x74747476u),\nuvec4(0x7b897b74u,0x7b7b7378u,0x564f6a6cu,0x6b1d1d1du),\nuvec4(0x80a11d6bu,0xbcaaafa4u,0xcacabcbcu,0xc4c1bccau),\nuvec4(0xabb0bfc1u,0xb6b6b1b1u,0xacb6b6b6u,0xb2b2b2b2u),\nuvec4(0xadadb2b2u,0xb8a3a7b7u,0x3b030116u,0x090b0415u),\nuvec4(0x0122020fu,0x090e0f02u,0x7e070709u,0x6e8a4344u),\nuvec4(0x9493938fu,0x94949494u,0x5cc9c8c6u,0x89c28987u),\nuvec4(0x89c7c289u,0x7bc78989u,0x7b7b7b7bu,0x5c7c897bu),\nuvec4(0xbd59c690u,0x5c5c905cu,0x595c9090u,0x5f5dbdbdu),\nuvec4(0x6b56664eu,0x1d6b6b1du,0x12496b6bu,0x76766c6au),\nuvec4(0x74747d76u,0x74747474u,0x78747474u,0x717b7874u),\nuvec4(0x77706c7bu,0x6b6b5657u,0x1d6b6b6bu,0xa4a03b1bu),\nuvec4(0xbcbcaabau,0xcacabcbcu,0xc1c1c1bcu,0xc0c0bfbfu),\nuvec4(0xb6b6b1c0u,0xb2b2acb6u,0xb2b2b2b2u,0xb7adadb2u),\nuvec4(0x23c5b8a3u,0x1f031801u,0x0f181f0eu,0x19080e16u),\nuvec4(0x02020f02u,0x020f0219u,0x58844443u,0x94949360u),\nuvec4(0xc6949494u,0x879ac993u,0x89c2c289u,0x898989c2u),\nuvec4(0x7b7bc789u,0xcb7b7b7bu,0x907c877bu,0x5cbd5993u),\nuvec4(0x605c5c90u,0xbdbd5f8fu,0x605c5d59u,0x1d6b5666u),\nuvec4(0x6b6b6b6bu,0x70125e8eu,0x78787d76u,0x74747874u),\nuvec4(0x74787474u,0x74787474u,0x6c716e78u,0x1d565064u),\nuvec4(0x6b6b6b6bu,0x3b496b6bu,0xa4a0a01eu,0xbcbcbcafu),\nuvec4(0xcacacabcu,0xbfc1c1bcu,0xc0b1c0bfu,0xb6b6b1b1u),\nuvec4(0xb2b2b2acu,0xadb2b2b2u,0xb8a7a7adu,0x161620c5u),\nuvec4(0x02160f16u,0x0216160fu,0x02020122u,0x0f19020fu),\nuvec4(0x430f0f02u,0x504d8a44u,0x94979493u,0xc6c69494u),\nuvec4(0xc2879ac8u,0x898989c2u,0xc7898989u,0x7b7b7b7bu),\nuvec4(0x7b7b7b7bu,0x939088c2u,0x905cbd59u,0x93605c5fu),\nuvec4(0x5d595d90u,0x665f5d5du,0x6b6b5656u,0x1d851d1du),\nuvec4(0x74739591u,0x7b78747bu,0x78747478u,0x78787878u),\nuvec4(0x73737878u,0x916a706eu,0x6b6b6b1du,0x3c6b1d1du),\nuvec4(0x0b1e451du,0xafa4a0a0u,0xbcc3c3aau,0xc1cacabcu),\nuvec4(0xc1c1bcc1u,0xc0c0c0bfu,0xacb6b6b1u,0xb2b2b2acu),\nuvec4(0xadadadb2u,0x20b8a7a7u,0x0f0f1620u,0x0f161616u),\nuvec4(0x22021602u,0x09081901u,0x07070707u,0x43410e1fu),\nuvec4(0x6658840fu,0x94949493u,0xc8949394u,0xc2c28398u),\nuvec4(0x8989c789u,0x7bc78989u,0x7b7b7b7bu,0x897b7bcbu),\nuvec4(0x9acc59c2u,0x5f905dbdu,0x90936058u,0x595d5d5fu),\nuvec4(0x5666505du,0x6b6b6b56u,0x6a5e856bu,0x7b737692u),\nuvec4(0x747b7474u,0x78787878u,0x78787474u,0x70737478u),\nuvec4(0x6b6b5677u,0x1d6b856bu,0x493c6b1du,0xa00b1e3bu),\nuvec4(0xbcaabaa4u,0xbcbcc3c3u,0xc1c1bcbcu,0xc1bcbcbcu),\nuvec4(0xc0c0bfbfu,0xacb6b6b6u,0xb2b2b2b2u,0xa7a7b2b2u),\nuvec4(0x202023aeu,0x1f070722u,0x1807071fu,0x010e190fu),\nuvec4(0x0411180fu,0x04050511u,0x430f2205u,0x935b5244u),\nuvec4(0x94949494u,0x9093c693u,0x89c2c288u,0x8989c289u),\nuvec4(0x7b7bc7c7u,0xcb7b7b7bu,0xc77b7b7bu,0xbd585c83u),\nuvec4(0x585f5f5du,0x8f609360u,0x5d5d5d5cu,0x6b565b5cu),\nuvec4(0x856b6b6bu,0x7471776bu,0x78747873u,0x78cb74cbu),\nuvec4(0x74747878u,0x76747474u,0x1d915373u,0x6b6b6b85u),\nuvec4(0x171d3c3cu,0x1e491d3du,0xa4a00404u,0xc3c3aaafu),\nuvec4(0xbcbcbcbcu,0xc1bcc1bcu,0xbfc1bcbcu,0xb1c0bfbfu),\nuvec4(0xb2acb6b6u,0xb2b2b2b2u,0xa3a7a6acu,0x0a0116c5u),\nuvec4(0x050b0404u,0x0f090b04u,0x021c0e19u,0x05040508u),\nuvec4(0x05040a05u,0x0f0f0107u,0x94935d79u,0x94949494u),\nuvec4(0x8894c6c6u,0x898987c2u,0xc789896cu,0xc7c7c7c7u),\nuvec4(0x7bcb7b7bu,0x89c77bcbu,0x5d595c7cu,0x8f5f5f5fu),\nuvec4(0x588f8f66u,0x5d5d5c5du,0xcd6b564eu,0x5f6b856bu),\nuvec4(0x7b737352u,0xcb787478u,0x7874cb74u,0x76747878u),\nuvec4(0x52747676u,0x6b858591u,0x171d3c1du,0x173e3e17u),\nuvec4(0x0b04451du,0xaaa4a00bu,0xc3c3c3aau,0xbcbcbcbcu),\nuvec4(0xbcc1cabcu,0xbfbfc1bcu,0xb1b1c0c0u,0xacacb6b6u),\nuvec4(0xabacacacu,0x20b8a7a7u,0x050b2220u,0x05030505u),\nuvec4(0x160f2205u,0x0843080eu,0x0505110cu,0x05050a0au),\nuvec4(0x02440218u,0x97935b4du,0x93979494u,0x87bdc6c6u),\nuvec4(0x6c89c287u,0xc7c7c7c7u,0x7bc7c7c7u,0xcb7bcb7bu),\nuvec4(0xc27b897bu,0x5f5c595du,0xc8935f5fu,0x58588f93u),\nuvec4(0x50595d5fu,0x6bcd6b5bu,0x7b706085u,0x7b747171u),\nuvec4(0x7b74747bu,0x78787474u,0x76767478u,0x85917076u),\nuvec4(0x3c3c6b85u,0x17173e0du,0x1d17173eu,0x0b0b131bu),\nuvec4(0xaaaaa4a4u,0xc3c3c3c3u,0xbcbcbcc3u,0xcecebcceu),\nuvec4(0xbfbfc1bcu,0xb1c0bfbfu,0xb6b6b6b6u,0xa7abb2acu),\nuvec4(0x0120c5a3u,0x0a053907u,0x0505050bu,0x0e190f0eu),\nuvec4(0x0c080208u,0x11110504u,0x0c0b0505u,0x410f0208u),\nuvec4(0x93936651u,0x93949793u,0x87889a93u,0xc77bc283u),\nuvec4(0xc7c7c7c7u,0x7b7b7bc7u,0xcb747b7bu,0x59c77b89u),\nuvec4(0x5f5f5c5cu,0x93936694u,0x585c6093u,0x8f5c5d5fu),\nuvec4(0x93cd6660u,0x717b89cfu,0x7874787bu,0x78747478u),\nuvec4(0x7b74747bu,0x71767d73u,0x3c1a6b91u,0x3e3d3d1du),\nuvec4(0x3e171717u,0xa117173eu,0xbaa4a00bu,0xbcbcbabau),\nuvec4(0xcecececau,0xcececaceu,0xcecececeu,0xc1bfc1ceu),\nuvec4(0xb1c0bfbfu,0xb2b6b6b6u,0xc5a3a7acu,0x040e2020u),\nuvec4(0x13051313u,0x0e05050au,0x080e020fu,0x040a0802u),\nuvec4(0x05050505u,0x22051105u,0x6e010f1cu,0x938f665fu),\nuvec4(0x93949693u,0x83c2bd96u,0x898989c2u,0xc7c7c789u),\nuvec4(0x7b7b7b7bu,0x7bcbcb7bu,0x5c7cc77bu,0x945f585cu),\nuvec4(0x93669366u,0x93945860u,0x938f585fu,0x897c60cdu),\nuvec4(0x7b78896cu,0x78787478u,0x78787474u,0x737b7874u),\nuvec4(0x6b777073u,0x3e173c3cu,0x17173e1du,0x3e171717u),\nuvec4(0x1b1d1717u,0xbabaa4a0u,0xbcbcc3c3u,0xcecececeu),\nuvec4(0xcecececeu,0xcecececeu,0xbfc1c1bcu,0xb6b1bfc1u),\nuvec4(0xa7adb6b6u,0xc520b8aeu,0x13151f08u,0x0a131313u),\nuvec4(0x0f0e0505u,0x02080e02u,0x05040508u,0x05050505u),\nuvec4(0x18031105u,0x6c8a430fu,0x93949366u,0x97939497u),\nuvec4(0x8783c2bdu,0x898989c2u,0x7bc7c7c7u,0x7bcb7b7bu),\nuvec4(0x7b7bcbcbu,0x5858837bu,0x93935f5cu,0x94936693u),\nuvec4(0x60939360u,0x60c8665fu,0x7b7b897cu,0x787b7b7bu),\nuvec4(0x74787874u,0x74747874u,0x70737878u,0x3c1a1d50u),\nuvec4(0x0d17171du,0x3e171714u,0x173e1717u,0x80a8a8a8u),\nuvec4(0xc3afafa4u,0xcabcc3c3u,0xcecececeu,0xcececaceu),\nuvec4(0xcacececeu,0xc1bcc1bcu,0xb6b1b1bfu,0xb8a7adacu),\nuvec4(0x0e0fc523u,0x13131304u,0x05051313u,0x020f0e05u),\nuvec4(0x0802080eu,0x05050405u,0x05110505u,0x011f1105u),\nuvec4(0x518a4402u,0x93938f56u,0xbbc69394u,0xc2838383u),\nuvec4(0xc7898989u,0x7b7bc7c7u,0xcb7bcb7bu,0x7b7bcbcbu),\nuvec4(0x5c90906cu,0x93939390u,0x60939366u,0x94949460u),\nuvec4(0x7b8360c8u,0x747889c7u,0x7474787bu,0x74747474u),\nuvec4(0x78787878u,0x5e127173u,0x173c6b85u,0x17173e3eu),\nuvec4(0x171d170du,0xa83e1717u,0xba80a8a8u,0xc3bcafafu),\nuvec4(0xc3c3c3c3u,0xced0d0d0u,0xcecececeu,0xcacececeu),\nuvec4(0xbfc1cabcu,0xacacc0bfu,0xc5c5a7acu,0xa00508c5u),\nuvec4(0x13131305u,0x05050513u,0x0e020f0eu,0x05081918u),\nuvec4(0x05050504u,0x05050405u,0x19180a0bu,0x577a4444u),\nuvec4(0x94939366u,0x889ac693u,0x89c28383u,0xc7898989u),\nuvec4(0x7b7b7bc7u,0x74cb7bcbu,0x7b7b7bcbu,0x905c9058u),\nuvec4(0x66939393u,0x5f5f9393u,0x58949393u,0x7bcbc787u),\nuvec4(0x78787b7bu,0x74747878u,0x78747474u,0x71737b7bu),\nuvec4(0x85855e6au,0x3e3d3d1du,0x0d173d3eu,0x173e1d17u),\nuvec4(0xa8a81717u,0xaaafa4a9u,0xbcbcc4aau,0xcabccac3u),\nuvec4(0xced0c3cau,0xcecececeu,0xcacececeu,0xbfc1bcbcu),\nuvec4(0xa6ababbfu,0xc520a3b8u,0x13130403u,0x13131313u),\nuvec4(0x09050505u,0x180e020fu,0x04050819u,0x05110505u),\nuvec4(0x050a1104u,0x02081f11u,0x664d8a8au,0x94949366u),\nuvec4(0x83bd98c6u,0x8989c287u,0xc7898989u,0x7b7b7b7bu),\nuvec4(0xcb78cbcbu,0x5d7bc7c7u,0xc8905c90u,0x93c89393u),\nuvec4(0xc8945f94u,0x7b875cc8u,0x7b7b7b7bu,0x78787b7bu),\nuvec4(0x74747878u,0x7b787874u,0x916a7173u,0x3c1d8585u),\nuvec4(0x3e171717u,0x3e17173eu,0x17171714u,0x80a8a8a8u),\nuvec4(0xb0aaafbau,0xc4c1bfb0u,0xbcbcbcbcu,0xcecacacau),\nuvec4(0xcecececeu,0xc1cececeu,0xabbfbccau,0xc5a3abb0u),\nuvec4(0x1318c5c5u,0x13130a04u,0x05131313u,0x0f0e0505u),\nuvec4(0x19180e02u,0x05040508u,0x05050505u,0x05050511u),\nuvec4(0x44440705u,0x8f518443u,0xc6948f66u,0x87837c96u),\nuvec4(0x8989c2c2u,0x7bc7c789u,0xcb7b7b7bu,0x7bcbcbcbu),\nuvec4(0x907c7b7bu,0x93c8905cu,0x9494c893u,0x5c939394u),\nuvec4(0xcb7b7b87u,0x787b7b78u,0x78787b78u,0x74747478u),\nuvec4(0x92737878u,0x856b9152u,0x3e171d6bu,0x0d3e171du),\nuvec4(0x3e3e1714u,0xa83e1717u,0xafa4a9a8u,0xabb0bcaau),\nuvec4(0xc4bfbfc1u,0xbcbcc4c4u,0xcecacacau,0xcecececeu),\nuvec4(0xbcc1d0ceu,0xababbfbcu,0x20c5c5a7u,0x13130518u),\nuvec4(0x13130513u,0x05051305u,0x020f0e05u,0x0102180eu),\nuvec4(0x05050405u,0x050c0505u,0x0b050c05u,0x43022205u),\nuvec4(0x6658748au,0x90938f4eu,0xc2878359u,0x8989c283u),\nuvec4(0x7bc7c7c7u,0xcb7bc77bu,0x7b7bcbcbu,0x5c90887bu),\nuvec4(0x9393c890u,0x93949493u,0x8cc25c93u,0x7b7b7b7bu),\nuvec4(0x7b7b7b7bu,0x787b787bu,0x78787478u,0x50706e73u),\nuvec4(0x1d6b856bu,0x3c1d1d3cu,0x3e17173eu,0x173e3e14u),\nuvec4(0xa8a83e3eu,0xaaaaa4a9u,0xbcbfb0bcu,0xc4c4c4c1u),\nuvec4(0xbcc1c4c4u,0xcececacau,0xd0cecacau,0xc1c1bcc3u),\nuvec4(0xa2a7aabcu,0x1f0120c5u,0x03050404u,0x05130505u),\nuvec4(0x05050505u,0x0e020f0eu,0x05080218u,0x05050504u),\nuvec4(0x05050505u,0x05050505u,0x4443180cu,0x56577444u),\nuvec4(0x5c908f8fu,0xc287837cu,0xc789c2c2u,0x7b7bc7c7u),\nuvec4(0xcb7b7b7bu,0x7b7b7bcbu,0x905ccc83u,0x93c893c8u),\nuvec4(0x88909394u,0xcb7b7b7bu,0x7b7b7bcbu,0x7878787bu),\nuvec4(0x7878787bu,0x7b7b7b7bu,0x851d776cu,0x3c1d1d6bu),\nuvec4(0x173e1d1du,0x3e3e1717u,0x170d3e17u,0x801aa81du),\nuvec4(0xb0aaaabau,0xbfbfbfb0u,0xc4c4c1c1u,0xc1c4c4c4u),\nuvec4(0xcacacacau,0xd0d0cacau,0xaab0c1bcu,0xc5c5a3a5u),\nuvec4(0x13041f16u,0x130a130bu,0x05110513u,0x0e050505u),\nuvec4(0x180e020fu,0x04050102u,0x05050505u,0x05050505u),\nuvec4(0x0b050505u,0x44021c07u,0x665b6c8au,0x885cc86bu),\nuvec4(0xc2838783u,0xc7c789c2u,0x7b7b7bc7u,0xcbcbcb7bu),\nuvec4(0x877b7b7bu,0xc8939090u,0x6693c893u,0x8c7b8890u),\nuvec4(0x78cbcbcbu,0x78787878u,0x78787878u,0x78787b78u),\nuvec4(0x12717b7bu,0x6b858591u,0x17171d1du,0x3e3e1717u),\nuvec4(0x0d173e3eu,0x1d3d3e17u,0xaf80a81du,0xc1bcaaaau),\nuvec4(0xc1c0bfbfu,0xc1c1bfbfu,0xcecac1c1u,0xd0cececeu),\nuvec4(0xc1c3d0d0u,0xa3a6b3d0u,0x181616a2u,0x13050405u),\nuvec4(0x05130a13u,0x05051105u,0x0f0e0505u,0x02180e02u),\nuvec4(0x05040501u,0x05050505u,0x05050505u,0x0b050505u),\nuvec4(0x43430f09u,0x6b56538bu,0x83595866u,0xc2878387u),\nuvec4(0x7bc78989u,0x7b7b7b7bu,0x7bcbcbcbu,0x5c877b7bu),\nuvec4(0xc8c89390u,0x875c90c8u,0xcb7bcb7bu,0x7878cbcbu),\nuvec4(0x78787878u,0x787b7878u,0x7b7b7b78u,0x1d915389u),\nuvec4(0x1d1d8585u,0x1d1d1d1du,0x1d0d0d0du,0x171d3e3eu),\nuvec4(0xa83e173eu,0xafafa4a8u,0xbfbfbcbcu,0xbfc1bfc1u),\nuvec4(0xc1c1c1bfu,0xcecececau,0xd0d0ceceu,0xc3bcc3d0u),\nuvec4(0xc5a2a3aau,0x04050816u,0x05050a0bu,0x05050505u),\nuvec4(0x05050505u,0x020f0e0bu,0x0102180eu,0x05050406u),\nuvec4(0x05050505u,0x05050505u,0x0b130505u,0x4343440eu),\nuvec4(0xcd576a84u,0x83885d60u,0xc2878387u,0x7b7bc789u),\nuvec4(0xcb7b7b7bu,0x7b7bcbcbu,0x938dc27bu,0x9366c8c9u),\nuvec4(0xcb7b897cu,0xcb7b7b7bu,0x7878787bu,0x78787878u),\nuvec4(0x78787b7bu,0x527b7bc7u,0x6b6b6b5fu,0x1d1d1d1du),\nuvec4(0x173c1d1du,0x17171717u,0x0d1d3c17u,0xa8a83e1du),\nuvec4(0xbcaaafa4u,0xc1bfb0bcu,0xbfc1c1bfu,0xbcc1c1c1u),\nuvec4(0xcececaceu,0xc3c3c3d0u,0xa7aac3c3u,0x0116c5a3u),\nuvec4(0x05040403u,0x05050503u,0x05050505u,0x0b050505u),\nuvec4(0x0e020f09u,0x06010218u,0x05050504u,0x05050505u),\nuvec4(0x05050505u,0x0c0b0a04u,0x8a43447eu,0x5656538bu),\nuvec4(0x877c7c5du,0x8989c287u,0xc77b7bc7u,0xcbcbcb7bu),\nuvec4(0x7bcbcbcbu,0x85c8597bu,0x7b7c5c93u,0x7b7b7b7bu),\nuvec4(0x7b78787bu,0x78787878u,0x7b7b7878u,0x7b7b7bcbu),\nuvec4(0x6b586c7bu,0x1d1d6b85u,0x1d3c1d1du,0x1d1d1d1du),\nuvec4(0x1d1d1d1du,0x1d1d1d1du,0x80a8a83eu,0xbcaaaaafu),\nuvec4(0xb1c4c4c4u,0xc1bfbfbfu,0xcabcc1c1u,0xd1d0cecau),\nuvec4(0xafc3a4d1u,0xc5a2aeafu,0x040e0f20u,0x0a051304u),\nuvec4(0x05050505u,0x05050505u,0x090b0505u,0x180e020fu),\nuvec4(0x04050102u,0x05050505u,0x05050505u,0x0a050505u),\nuvec4(0x0c0a0b04u,0x4343437eu,0x5f566a8bu,0xc2837c7cu),\nuvec4(0xc7898989u,0x7bc77b7bu,0xcbcbcbcbu,0x7b7bcbcbu),\nuvec4(0x7c93cd59u,0xcb747b89u,0x7b7b7b7bu,0x7878787bu),\nuvec4(0x78787878u,0x7b7b7b78u,0x89787b89u,0x6b6bcd77u),\nuvec4(0x1d1d1d8eu,0x49561d1du,0x1d490d0du,0x493c1d1du),\nuvec4(0x1d3e3c1du,0xa4a8a83eu,0xb0aaafbau,0xc0bfc4b0u),\nuvec4(0xc1c1bfc0u,0xcecacac1u,0xd1d1d0d0u,0xae9eaac3u),\nuvec4(0x2020c5a3u,0x130b0b0eu,0x05130505u,0x050c0505u),\nuvec4(0x05050505u,0x0f090b05u,0x02180e02u,0x05040501u),\nuvec4(0x05050505u,0x05050505u,0x041f0505u,0x03110a0bu),\nuvec4(0x438a4308u,0x59576a84u,0xc2c27c83u,0x7bc78989u),\nuvec4(0xcb7bc77bu,0x78cbcbcbu,0x83c7cb78u,0x78cb835du),\nuvec4(0x787878cbu,0x7b7b7878u,0x78787878u,0x7b7b7b78u),\nuvec4(0x6c897b7bu,0xcd7c7b7bu,0x8e6b566bu,0x1d1d1d1du),\nuvec4(0x1d1d4956u,0x1d1d1d1du,0x3c1d1d1du,0xa11d3c6bu),\nuvec4(0xbaa0a8a9u,0xabb0aaaau,0xababc4b0u,0xbcbcc1bfu),\nuvec4(0xd1d0c3cau,0xa5bac3d1u,0xc5c5a29eu,0x1318c5c5u),\nuvec4(0x05130504u,0x05051313u,0x05050c05u,0x05050505u),\nuvec4(0x020f090bu,0x0802180eu,0x05050405u,0x05050505u),\nuvec4(0x05050505u,0x03051305u,0x0c050511u,0x448a4341u),\nuvec4(0x7c586a7du,0xc2c28364u,0x7b7b89c2u,0xcbcb7b7bu),\nuvec4(0x7878cbcbu,0xc7c77bcbu,0x7b7b7478u,0x74cb7b78u),\nuvec4(0x78787878u,0x7b78787bu,0x7b7b7b7bu,0xc2c77b7bu),\nuvec4(0xcd605d64u,0x6b6b6b6bu,0x1d8e6b6bu,0x1d49491du),\nuvec4(0x50915e1du,0x95051212u,0x9c9b9595u,0xa5a5ba9cu),\nuvec4(0xb0b0aaaau,0xc1b0b0b0u,0xcabcbcbcu,0xd1d1c3c3u),\nuvec4(0xc5a39dbau,0xc5c5c5c5u,0x05040b18u,0x05051305u),\nuvec4(0x05050a05u,0x05050505u,0x05050505u,0x0e020f0eu),\nuvec4(0x05080208u,0x05050504u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x030c0505u,0x8a444301u,0x52505384u),\nuvec4(0xc7898364u,0x7b7b7b7bu,0xcb7b7b7bu,0xc77b7878u),\nuvec4(0x7b7b7b7bu,0x7bcbcb7bu,0x78cb7b7bu,0x7b7b7878u),\nuvec4(0x7b7b7b7bu,0xc7c27b7bu,0xd2c2c2c2u,0xcf64d2d2u),\nuvec4(0xcfcfcfcfu,0xcfcfcfcfu,0x777777cfu,0x927095cfu),\nuvec4(0x74737876u,0xd4b9d376u,0x9d9ea2d4u,0xaaabaaaau),\nuvec4(0xbcc4b0b0u,0xc3c3c3bcu,0x9dbaa4c3u,0x20c5c5c5u),\nuvec4(0x04181620u,0x050b0504u,0x05050505u,0x05050505u),\nuvec4(0x05040505u,0x22050505u,0x180e190fu,0x04050802u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x07030a05u,0x8a434308u,0x52126e84u,0xc2837f7fu),\nuvec4(0x7bc77b7bu,0xcbcb7b7bu,0x7b897b7bu,0x7b7b7b7bu),\nuvec4(0xcb7b7b7bu,0xcb78cb78u,0x897b7b7bu,0x89897bc7u),\nuvec4(0x8389c2c7u,0xd589c2d2u,0xd678d6d6u,0xd6d6d6d6u),\nuvec4(0xd6d6d6d6u,0xd7d778d3u,0x7b7b71d7u,0x7b7b7bd7u),\nuvec4(0xd7d7d7d7u,0xd8a59d9du,0xaabad8d8u,0xc3c3d8d8u),\nuvec4(0xa4d1c3c3u,0x20a3afa4u,0x0f0fc5c5u,0x05040522u),\nuvec4(0x05050503u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x0f0e0505u,0x02182202u,0x05040501u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x03110a05u),\nuvec4(0x43434308u,0x64526e8au,0x897b8952u,0x7b7b7bc7u),\nuvec4(0xc7cb74cbu,0x7bc7c789u,0x7b7b7b7bu,0x78787b78u),\nuvec4(0x7b7b7b7bu,0x89c289c7u,0x8989c2c7u,0xd2d2c2c2u),\nuvec4(0x7b7b89d2u,0xd6d67878u,0xd6d6d6d6u,0xd6d6d6d6u),\nuvec4(0x787878d6u,0x7b7b7878u,0x7b787878u,0xd7d7d7d7u),\nuvec4(0xd9d9a59du,0xd8d8d8d8u,0xc3bad8d8u,0xa4a4bac3u),\nuvec4(0x2020c59du,0x13181616u,0x05050504u,0x05050503u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x190f0e05u),\nuvec4(0x0102220eu,0x05050405u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x03040506u,0x43448a08u),\nuvec4(0x5253718au,0x89897b6cu,0xcb7b7b7bu,0xc2c27b74u),\nuvec4(0x787bc77bu,0x787b7b78u,0x7b7b7878u,0x89c77b7bu),\nuvec4(0xc2c28989u,0x83c289c2u,0x8d8d99c2u,0x7bc2d27cu),\nuvec4(0xd6d6d678u,0xd6d6d6d6u,0xd6d6d6d6u,0x78787878u),\nuvec4(0xd6d6d678u,0xd6d6d6d6u,0xdad3d3d6u,0x9dd99ddau),\nuvec4(0xd9d9d99du,0xa5a5d9d9u,0xa29d9ca5u,0x0f0fc5c5u),\nuvec4(0x05040522u,0x03051303u,0x05050505u,0x0a0a0a05u),\nuvec4(0x05050505u,0x05050505u,0x0e190f0eu,0x05010218u),\nuvec4(0x05050504u,0x13131313u,0x13131313u,0x05050505u),\nuvec4(0x05050513u,0x03050505u,0x4343437eu,0x6a71798bu),\nuvec4(0x897b7b52u,0xcb7b7b7bu,0x7bc287c7u,0x787b7bc7u),\nuvec4(0x787b7b7bu,0xc77b7b7bu,0x6c898989u,0x87c2c2c2u),\nuvec4(0x8388c2c2u,0xccc8c8ccu,0x7bd28dccu,0xd6d6db78u),\nuvec4(0xdbdbdbdbu,0xdbdbdbdbu,0xdbdbdbdbu,0xd5d6d6dbu),\nuvec4(0xd6d6d6dbu,0xdadadabeu,0xdadadadau,0xdad9d9dau),\nuvec4(0x9d9ed4dau,0x160fa2a2u,0x04180f16u,0x05050b04u),\nuvec4(0x04050505u,0x05050505u,0x05050505u,0x04050513u),\nuvec4(0x09050505u,0x18220219u,0x04050802u,0x05040413u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x04050505u),\nuvec4(0x0c041105u,0x4343080eu,0x52717d44u,0x7b898970u),\nuvec4(0xc27b7b7bu,0x7b7bc2d2u,0x7b787b7bu,0x7b7b7b7bu),\nuvec4(0x898989c7u,0xc26c6c89u,0x8383c2c2u,0x998d7cc2u),\nuvec4(0xccc89390u,0xd5c783dcu,0xdbdbdbd5u,0xdedddddbu),\nuvec4(0xd5dededeu,0xd5dbdbddu,0xdbdbdbdbu,0xd6dbd6dbu),\nuvec4(0xdadadadbu,0xdfdfdadfu,0xdadadadau,0x0fa2d4d4u),\nuvec4(0x0802191cu,0x0504050eu,0x06050506u,0x05030505u),\nuvec4(0x05050505u,0x05050505u,0x06130605u,0x0f090505u),\nuvec4(0x0f182202u,0x03050308u,0x05050305u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x03030505u,0x0c050303u),\nuvec4(0x43431922u,0x70b98a43u,0x7b897170u,0xc2c27b7bu),\nuvec4(0x7b7b7bc2u,0x7bcbcb7bu,0x89c77b7bu,0x6c898989u),\nuvec4(0xc2c2c2c2u,0x7c8383c2u,0x90995c5cu,0xccc8c893u),\nuvec4(0xe0e0c27cu,0xe1e1e1deu,0xdddde1e1u,0xdee1ddddu),\nuvec4(0xdddddedeu,0xdbdbddddu,0xdddddbdbu,0xdfdfdfdfu),\nuvec4(0xdadfdfdfu,0xd4d3dadau,0x0f44b5b4u,0x050e0119u),\nuvec4(0x06050304u,0x05050505u,0x05050305u,0x05050505u),\nuvec4(0x05050505u,0x05031303u,0x020f0705u,0x02020818u),\nuvec4(0x01010808u,0x0101010fu,0x01010101u,0x01010101u),\nuvec4(0x01010101u,0x01080101u,0x0f01011cu,0x43444402u),\nuvec4(0x73844443u,0x7b7b8970u,0x89c2897bu,0x7b7b7b7bu),\nuvec4(0xc77b7b7bu,0x8989c7c7u,0xc2898989u,0x837cc2c2u),\nuvec4(0x93908887u,0xcc8d7c5cu,0x7cccc8c8u,0xe0e0e0c2u),\nuvec4(0xe1e1e1deu,0xdededee1u,0xe1e1e1e1u,0xdedee1e1u),\nuvec4(0xdde1e1e1u,0xdddde1ddu,0xdfdfe1ddu,0xd3d6dbdfu),\nuvec4(0xb5b5bed4u,0x02190f01u,0x0808010fu,0x0101080fu),\nuvec4(0x01010101u,0x01010108u,0x01010101u,0x01010101u),\nuvec4(0x08011c08u,0x08020f0fu,0x02021902u,0x02190202u),\nuvec4(0x02020202u,0x02020202u,0x02020202u,0x02020202u),\nuvec4(0x020f0202u,0x19020202u,0x44434302u,0x7db54344u),\nuvec4(0x7b897173u,0xc789897bu,0xc77b7bc7u,0xc289c7c7u),\nuvec4(0xc2c2c27bu,0xc2c2c289u,0x7c7c7c83u,0x8dc8c858u),\nuvec4(0xc8905988u,0xd299ccc8u,0xe0e0e289u,0xe1e1dedeu),\nuvec4(0xdededee1u,0xe1e1dedeu,0xdedededeu,0xdde1e1deu),\nuvec4(0xdddddde1u,0xdbdddeddu,0xb4d378d6u,0x430fb4b5u),\nuvec4(0x0219020fu,0x02020202u,0x02020202u,0x02020202u),\nuvec4(0x02020202u,0x02020202u,0x02021902u,0x02020219u),\nuvec4(0x01020202u,0x01010f01u,0x01010801u,0x01010101u),\nuvec4(0x01010101u,0x01010101u,0x01010101u,0x1c0f011cu),\nuvec4(0x1c081c01u,0x431c0801u,0xbeb54443u,0x6c7173b9u),\nuvec4(0xc2c78970u,0xc2c77b89u,0xc27bc2c2u,0xc2c2c2c2u),\nuvec4(0x83838383u,0x935f7c7cu,0x835cc8c8u,0xc6cc987cu),\nuvec4(0xd2838dccu,0xe0e0e2e3u,0xdededee0u,0xdedededeu),\nuvec4(0xdedededeu,0xe1dededeu,0xdddededeu,0xdedee1e1u),\nuvec4(0x7878d5d5u,0x8ab4b5beu,0x01014343u,0x0801010fu),\nuvec4(0x01010108u,0x01010101u,0x01010101u,0x01010101u),\nuvec4(0x01010101u,0x01011c01u,0x0801011cu,0x173d0108u),\nuvec4(0x0d17170du,0x3c3c0d3cu,0x3c3c3c3cu,0x3e173c3cu),\nuvec4(0x17171717u,0x3c171717u,0x3d140d3cu,0x1d17140du),\nuvec4(0x08033b0du,0xb4434444u,0x707092b9u,0xc27b6c70u),\nuvec4(0xc289c2c2u,0xc2c283c2u,0x838383c2u,0x5d7c8888u),\nuvec4(0xc8c8cd58u,0x7c835893u,0x5ccccc8du,0xd2d2e48du),\nuvec4(0xe2e2e2e3u,0xdee0e0e0u,0xdedededeu,0xdedededeu),\nuvec4(0xdedededeu,0xdedededeu,0xd6d5d5deu,0xb5b57dd6u),\nuvec4(0x01434444u,0x17173803u,0x0d0d173du,0x1717170du),\nuvec4(0x17171717u,0x17171717u,0x17171717u,0x170d1717u),\nuvec4(0x0d3c3c3cu,0x3c3c3c17u,0x04040417u,0x381b3810u),\nuvec4(0x1b1b1b1bu,0x1b1b1b1bu,0x1b1b1b1bu,0x1b1b1b1bu),\nuvec4(0x380d381bu,0x04383838u,0x3e3b0413u,0x011f1017u),\nuvec4(0x43448a44u,0x6c7379b4u,0x6c7f6c52u,0x8383c289u),\nuvec4(0x87c2c2c2u,0x83878383u,0xcd605d7cu,0xcdc8cdcdu),\nuvec4(0x8d7c838du,0x838d8d8du,0xe3d2d2d2u,0xe2e2e2e3u),\nuvec4(0xdee0e0e0u,0xdedededeu,0xdedededeu,0xdedededeu),\nuvec4(0xd5d5ded5u,0xbebed678u,0x4344b5b4u,0x100c0843u),\nuvec4(0x05150d0du,0x381d3b0bu,0x1b1b1b1bu,0x1b1b1b1bu),\nuvec4(0x1b1b1b1bu,0x1b1b1b1bu,0x1b381b1bu,0x1b101b1bu),\nuvec4(0x3904043bu,0x07010202u,0x03050605u,0x03030303u),\nuvec4(0x03030303u,0x03030303u,0x03030303u,0x06030c03u),\nuvec4(0x16010303u,0x0b132202u,0x7e1f0505u,0x43434401u),\nuvec4(0x7479018au,0x6c707071u,0xc7c2876cu,0x838787c2u),\nuvec4(0x5d7c8383u,0xcd6bcd5fu,0x8dcdcdcdu,0x997c8383u),\nuvec4(0xd2d2d283u,0xe3e3e3d2u,0xe2e2e2e3u,0xe0e2e2e2u),\nuvec4(0xe0e0e0e0u,0xdededee2u,0xd5dededeu,0x7dd678d5u),\nuvec4(0x43b5b4beu,0x0e014443u,0x03050405u,0x02020103u),\nuvec4(0x03050b0eu,0x03030303u,0x03030303u,0x03030303u),\nuvec4(0x03030303u,0x03030303u,0x22030303u,0x0f080202u),\nuvec4(0x04030119u,0x05030505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x0a050c11u,0x1c160805u),\nuvec4(0x030a0b1fu,0x18050b13u,0x43440108u,0x848a4343u),\nuvec4(0x6c707176u,0x8783837fu,0x83838383u,0x56575864u),\nuvec4(0xcdcd6b6bu,0xd258cdcdu,0xd2d2d2d2u,0xe3e3e3d2u),\nuvec4(0xe3e3e3e3u,0xe2e2e2e3u,0xe0e2e2e2u,0xdee0e0e0u),\nuvec4(0xe0e0dedeu,0xd678d5e0u,0xb5b5b4beu,0x1c434343u),\nuvec4(0x0404037eu,0x0c05030cu,0x220f0f18u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050605u,0x19220505u,0x020f1802u,0x05040301u),\nuvec4(0x05050505u,0x05050505u,0x05060505u,0x05050505u),\nuvec4(0x11050505u,0x130a050cu,0x22021608u,0x050b0404u),\nuvec4(0x03041313u,0x43440122u,0xb5440144u,0x706eb901u),\nuvec4(0x52837f53u,0x506a6452u,0x6b1d5e4fu,0xcdcdcdcdu),\nuvec4(0xc2c2dccdu,0xe3e3e3c2u,0xe3e3e3e3u,0xe3e3e3e3u),\nuvec4(0xe2e2e2e3u,0xe2e2e2e2u,0xded5e0e0u,0xd6d5e0e0u),\nuvec4(0xb4bebed6u,0x194343b5u,0x110c1801u,0x05050404u),\nuvec4(0x08050b13u,0x04090f43u,0x05050304u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05060505u),\nuvec4(0x190f2205u,0x1c020118u,0x05050407u,0x05050505u),\nuvec4(0x05050505u,0x06060606u,0x050a0506u,0x0c110505u),\nuvec4(0x08130a05u,0x04090202u,0x0503030bu,0x0b0b130au),\nuvec4(0x0f08090cu,0x44434343u,0x76848ab5u,0x6a6a526eu),\nuvec4(0x1d5e5012u,0xcd1d5e1du,0xcd6bcdcdu,0xd7c2c28du),\nuvec4(0xe3e3e389u,0xe3e2e2e2u,0xe3e3e3e3u,0xe2e2e2e3u),\nuvec4(0xe0e2e2e2u,0x78d5d5e0u,0xbebebed6u,0x44b5b5b4u),\nuvec4(0x1f081c0fu,0x05050413u,0x05050505u,0x43080505u),\nuvec4(0x0505220fu,0x05050506u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050305u,0x08020f0eu),\nuvec4(0x03010201u,0x05050504u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05060505u,0x02080505u),\nuvec4(0x05110e19u,0x0505050au,0x0b05050au,0x080e0c0bu),\nuvec4(0x43434401u,0x01444343u,0x126c0e79u,0x6b1d3c91u),\nuvec4(0xcd8e858eu,0xdccd6b6bu,0xe07bd7d7u,0xe0e0e0e0u),\nuvec4(0xe2e2e2e0u,0xe3e3e3e3u,0xd7d7e3e3u,0xd3d57b7bu),\nuvec4(0xb4b4be76u,0x4343b5b4u,0x081c44b5u,0x05040407u),\nuvec4(0x05050505u,0x05050c05u,0x19021805u,0x0505130eu),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x0e050505u,0x0118020fu,0x04071c02u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050605u,0x19020805u,0x0a050b0eu),\nuvec4(0x05050505u,0x050a0c05u,0x0e0c0c05u,0x431c087eu),\nuvec4(0x430f4343u,0x0e7e1c44u,0x911e1e05u,0x6b6b8e49u),\nuvec4(0xd7cfcd6bu,0xe07b7b7bu,0x89e0e0e0u,0xd7d7d7d7u),\nuvec4(0xd7d7e3e3u,0xd3787bd7u,0xb5bebebeu,0x44b5b5b5u),\nuvec4(0x01444444u,0x0504050eu,0x05050506u,0x05050505u),\nuvec4(0x05050506u,0x0e190218u,0x05050504u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x0f0e0505u,0x02010802u,0x0504071cu,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050506u,0x09190208u,0x05051104u,0x05050505u),\nuvec4(0x05050505u,0x05040505u,0x017e1f03u,0x44014343u),\nuvec4(0x43434443u,0x6e7e0144u,0x77049503u,0xd3d35277u),\nuvec4(0x787878d3u,0x78d37878u,0x7878d378u,0x7dbed378u),\nuvec4(0xb4b4b4beu,0xb5b4b4b5u,0x01444343u,0x11051f18u),\nuvec4(0x05050511u,0x05050505u,0x06050505u,0x18050505u),\nuvec4(0x040e1902u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x020f0e05u),\nuvec4(0x1c020108u,0x05050407u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x06050505u,0x08050505u),\nuvec4(0x040e0202u,0x05050511u,0x05050c05u,0x0c0a0505u),\nuvec4(0x1105050cu,0x0e070504u,0x43434422u,0x43444343u),\nuvec4(0x43434343u,0x7d84b544u,0xb4b4b4b4u,0xbebebebeu),\nuvec4(0xbebebebeu,0xb4b4b4beu,0xb5b5b4b5u,0xb5b5b5b5u),\nuvec4(0x08b54343u,0x040c1f18u,0x0505051eu,0x05050c0cu),\nuvec4(0x0505050cu,0x05050505u,0x02180505u,0x05130e02u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x08020f0eu,0x071c0201u),\nuvec4(0x05050504u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05060505u,0x02080505u,0x110b0e02u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050c03u),\nuvec4(0x05050511u,0x1c220307u,0x43430f1cu,0x4443020fu),\nuvec4(0x43b54443u,0xb5b5b5b5u,0xb5b5b5b5u,0xb5b5b5b5u),\nuvec4(0xb5b5b5b5u,0x8a4343b5u,0x79084443u,0x04056c0eu),\nuvec4(0x030c1104u,0x05050c03u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x02021805u,0x05051322u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x0e050505u,0x1c08020fu,0x04071c02u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050605u,0x02020805u,0x05110b0eu,0x05050505u),\nuvec4(0x05050c05u,0x05050505u,0x05050505u,0x0c050505u),\nuvec4(0x10040511u,0x22180222u,0x431c0f0fu,0x43434343u),\nuvec4(0x44444443u,0xb4b54343u,0x4344b5b5u,0x44444343u),\nuvec4(0x437e1f08u,0x05043b0eu,0x0c050505u,0x11050505u),\nuvec4(0x05030305u,0x050c0505u,0x05050505u,0x05050505u),\nuvec4(0x0e020218u,0x05050513u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x0f0e0505u),\nuvec4(0x021c0802u,0x0504071cu,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050506u),\nuvec4(0x0e020208u,0x0505110bu,0x05060505u,0x05050505u),\nuvec4(0x06030306u,0x05050505u,0x05040505u,0x0e1a3b07u),\nuvec4(0x053c1b1cu,0x08220707u,0x01010801u,0x8a010101u),\nuvec4(0x0101018au,0x0e7e0841u,0x041f031fu,0x11190b17u),\nuvec4(0x1105391au,0x0c030c05u,0x05030303u,0x0c050505u),\nuvec4(0x05050c0cu,0x05050505u,0x18050505u,0x130e1902u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x020f0e05u,0x1c020108u),\nuvec4(0x05050407u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x06050505u,0x08050505u,0x040e1902u),\nuvec4(0x05050511u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x07050306u,0x43221a04u,0x0606171bu),\nuvec4(0x05050b04u,0x0505050bu,0x05050505u,0x05050511u),\nuvec4(0x04050505u,0x3d04051eu,0x171f1939u,0x05050c05u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x02180505u,0x05040e19u,0x05050505u),\nuvec4(0x05050505u,0x05050505u,0x05050505u,0x05050505u),\nuvec4(0x05050505u,0x08020f0eu,0x00000000u,0x00000000u));\n\nconst vec3 colors[] = vec3[](\nvec3(0xe0,0xe0,0xe0),\nvec3(0xff,0xff,0xff),\nvec3(0x90,0x90,0x90),\nvec3(0x70,0x70,0x70),\nvec3(0x80,0x80,0x80),\nvec3(0x80,0x90,0x90),\nvec3(0x90,0xa0,0x90),\nvec3(0xd0,0xd0,0xd0),\nvec3(0xa0,0xb0,0xa0),\nvec3(0x80,0x90,0x80),\nvec3(0x70,0x80,0x70),\nvec3(0x90,0x90,0x80),\nvec3(0x30,0x30,0x30),\nvec3(0xb0,0xb0,0xb0),\nvec3(0xf0,0xf0,0xf0),\nvec3(0x40,0x50,0x40),\nvec3(0x80,0x80,0x70),\nvec3(0x70,0x70,0x60),\nvec3(0x70,0x80,0x80),\nvec3(0x20,0x30,0x30),\nvec3(0x60,0x60,0x70),\nvec3(0xf0,0xff,0xff),\nvec3(0x20,0x20,0x20),\nvec3(0xc0,0xc0,0xc0),\nvec3(0xf0,0xff,0xf0),\nvec3(0x10,0x10,0x10),\nvec3(0x40,0x40,0x40),\nvec3(0xe0,0xf0,0xe0),\nvec3(0x30,0x30,0x20),\nvec3(0x70,0x60,0x60),\nvec3(0xa0,0xa0,0xa0),\nvec3(0xe0,0xff,0xff),\nvec3(0xe0,0xf0,0xf0),\nvec3(0xb0,0xc0,0xb0),\nvec3(0xd0,0xf0,0xf0),\nvec3(0xc0,0xe0,0xe0),\nvec3(0xc0,0xd0,0xf0),\nvec3(0xd0,0xe0,0xe0),\nvec3(0xb0,0xd0,0xd0),\nvec3(0xa0,0xc0,0xe0),\nvec3(0xb0,0xc0,0xd0),\nvec3(0x90,0xb0,0xb0),\nvec3(0xa0,0xb0,0xd0),\nvec3(0xb0,0xd0,0xe0),\nvec3(0xb0,0xd0,0xf0),\nvec3(0xa0,0xd0,0xf0),\nvec3(0x90,0xc0,0xe0),\nvec3(0xa0,0xc0,0xf0),\nvec3(0x90,0xb0,0xd0),\nvec3(0xa0,0xd0,0xff),\nvec3(0x90,0xa0,0xb0),\nvec3(0xb0,0xd0,0xff),\nvec3(0xb0,0xe0,0xf0),\nvec3(0x80,0xa0,0xa0),\nvec3(0x80,0xa0,0xb0),\nvec3(0x30,0x40,0x40),\nvec3(0x50,0x60,0x50),\nvec3(0x70,0x90,0x90),\nvec3(0x50,0x50,0x50),\nvec3(0x30,0x20,0x20),\nvec3(0x10,0x20,0x20),\nvec3(0x20,0x30,0x20),\nvec3(0x60,0x70,0x70),\nvec3(0xb0,0xe0,0xff),\nvec3(0xe0,0xe0,0xd0),\nvec3(0x70,0x90,0xb0),\nvec3(0xff,0xff,0xf0),\nvec3(0xff,0xf0,0xf0),\nvec3(0x50,0x40,0x40),\nvec3(0x40,0x40,0x30),\nvec3(0x60,0x60,0x60),\nvec3(0x90,0xa0,0xa0),\nvec3(0x40,0x30,0x30),\nvec3(0x50,0x50,0x40),\nvec3(0x60,0x50,0x40),\nvec3(0x70,0x60,0x50),\nvec3(0xb0,0x90,0x90),\nvec3(0x60,0x40,0x30),\nvec3(0x60,0x40,0x40),\nvec3(0x70,0x50,0x40),\nvec3(0x90,0x70,0x70),\nvec3(0xa0,0x80,0x70),\nvec3(0xa0,0x90,0x70),\nvec3(0x70,0x80,0x90),\nvec3(0x70,0x90,0xa0),\nvec3(0x40,0x30,0x20),\nvec3(0x70,0x40,0x40),\nvec3(0x80,0x50,0x40),\nvec3(0x90,0x70,0x50),\nvec3(0x10,0x30,0x30),\nvec3(0x60,0x30,0x30),\nvec3(0x80,0x60,0x40),\nvec3(0x90,0x60,0x50),\nvec3(0x50,0x30,0x30),\nvec3(0x70,0x50,0x30),\nvec3(0x70,0x40,0x30),\nvec3(0x60,0x80,0x80),\nvec3(0x30,0x50,0x50),\nvec3(0x30,0x30,0x40),\nvec3(0xa0,0x80,0x60),\nvec3(0x50,0x70,0x80),\nvec3(0x60,0x30,0x20),\nvec3(0x50,0x60,0x60),\nvec3(0x20,0x30,0x40),\nvec3(0x60,0x80,0xa0),\nvec3(0x90,0x70,0x60),\nvec3(0x30,0x20,0x10),\nvec3(0xb0,0xa0,0x80),\nvec3(0x80,0xa0,0xc0),\nvec3(0xc0,0xb0,0x90),\nvec3(0x60,0x80,0x90),\nvec3(0xb0,0x90,0x80),\nvec3(0xc0,0xa0,0x90),\nvec3(0x50,0x60,0x70),\nvec3(0xd0,0xb0,0xa0),\nvec3(0xd0,0xc0,0xa0),\nvec3(0x60,0x70,0x90),\nvec3(0xe0,0xc0,0xa0),\nvec3(0x70,0x70,0x50),\nvec3(0xd0,0xc0,0x90),\nvec3(0xd0,0xd0,0xc0),\nvec3(0xd0,0xb0,0xb0),\nvec3(0xd0,0xb0,0x80),\nvec3(0xa0,0x70,0x50),\nvec3(0xe0,0xd0,0xb0),\nvec3(0xd0,0xc0,0xc0),\nvec3(0xb0,0x90,0x70),\nvec3(0x30,0x60,0x50),\nvec3(0x40,0x70,0x80),\nvec3(0x10,0x30,0x50),\nvec3(0xb0,0x80,0x60),\nvec3(0xe0,0xd0,0xc0),\nvec3(0x20,0x20,0x10),\nvec3(0xd0,0xb0,0x90),\nvec3(0xb0,0x90,0x60),\nvec3(0xa0,0x80,0x50),\nvec3(0xc0,0xa0,0x70),\nvec3(0xf0,0xe0,0xe0),\nvec3(0xf0,0xd0,0xd0),\nvec3(0xe0,0xb0,0xa0),\nvec3(0x90,0x70,0x40),\nvec3(0x30,0x30,0x10),\nvec3(0x70,0x30,0x30),\nvec3(0x80,0x40,0x30),\nvec3(0x50,0x50,0x30),\nvec3(0xb0,0xb0,0x90),\nvec3(0x70,0x30,0x20),\nvec3(0x80,0x30,0x20),\nvec3(0x90,0x90,0x70),\nvec3(0x90,0x40,0x30),\nvec3(0x80,0x30,0x30),\nvec3(0x90,0x50,0x30),\nvec3(0x90,0x60,0x40),\nvec3(0x90,0x50,0x40),\nvec3(0x90,0xa0,0x80),\nvec3(0x90,0xb0,0x90),\nvec3(0xa0,0xd0,0xa0),\nvec3(0xb0,0xf0,0xb0),\nvec3(0xb0,0xd0,0xb0),\nvec3(0x50,0x70,0x50),\nvec3(0x30,0x50,0x30),\nvec3(0xd0,0xf0,0xd0),\nvec3(0xb0,0xf0,0xd0),\nvec3(0x50,0x90,0x60),\nvec3(0x90,0xd0,0x90),\nvec3(0x90,0xf0,0xb0),\nvec3(0x90,0xf0,0xd0),\nvec3(0x10,0x30,0x10),\nvec3(0x20,0x50,0x30),\nvec3(0x70,0xd0,0x90),\nvec3(0x70,0xe0,0xa0),\nvec3(0x70,0xf0,0xb0),\nvec3(0x80,0xff,0xd0),\nvec3(0x90,0xd0,0xd0),\nvec3(0x70,0xc0,0x90),\nvec3(0x60,0xe0,0x90),\nvec3(0x60,0xf0,0xa0),\nvec3(0x70,0xff,0xd0),\nvec3(0x60,0xb0,0x90),\nvec3(0xf0,0xf0,0xd0),\nvec3(0xff,0xff,0xe0),\nvec3(0x70,0xff,0xc0),\nvec3(0x90,0xff,0xe0),\nvec3(0xb0,0xf0,0xf0),\nvec3(0xd0,0xd0,0xb0),\nvec3(0x60,0xb0,0x80),\nvec3(0xa0,0x50,0x40),\nvec3(0x50,0xd0,0x80),\nvec3(0xb0,0x70,0x50),\nvec3(0xf0,0xf0,0xb0),\nvec3(0x50,0xe0,0x90),\nvec3(0x50,0xe0,0xa0),\nvec3(0x50,0xd0,0x90),\nvec3(0xc0,0x90,0x70),\nvec3(0x50,0xb0,0x70),\nvec3(0x60,0xd0,0x90),\nvec3(0xd0,0xff,0xf0),\nvec3(0x70,0x30,0x10),\nvec3(0xd0,0xa0,0x70),\nvec3(0x60,0x30,0x10),\nvec3(0x60,0x20,0x10),\nvec3(0x40,0xc0,0x80),\nvec3(0xe0,0xc0,0x90),\nvec3(0x70,0x50,0x20),\nvec3(0x50,0x30,0x10),\nvec3(0x40,0xc0,0x70),\nvec3(0x80,0x80,0x50),\nvec3(0x40,0xb0,0x70),\nvec3(0x40,0xa0,0x60),\nvec3(0xb0,0x90,0x50),\nvec3(0xd0,0xd0,0x90),\nvec3(0xd0,0xf0,0xa0),\nvec3(0xd0,0xd0,0x70),\nvec3(0xe0,0xd0,0x90),\nvec3(0xb0,0xb0,0x70),\nvec3(0x70,0xc0,0x70),\nvec3(0xa0,0xe0,0x80),\nvec3(0xd0,0xf0,0x90),\nvec3(0xe0,0xd0,0x80),\nvec3(0x70,0x60,0x30),\nvec3(0xe0,0xd0,0x70),\nvec3(0xe0,0xc0,0x60),\nvec3(0xe0,0xe0,0x70),\nvec3(0xd0,0xc0,0x60),\nvec3(0xe0,0xd0,0x60),\nvec3(0xd0,0xb0,0x60),\nvec3(0xc0,0xb0,0x50),\nvec3(0xa0,0x80,0x40));\n\nvec3 getcolor(int i) {\n  return colors[i%colors.length()]/255.0;\n}\n\nint WIDTH = 155;\nint HEIGHT = 152;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  float ires = iResolution.x*10000.0 + iResolution.y;\n  if (iFrame != 0 && fragColor.w == ires) return; // Check for resize\n  fragColor.w = ires;\n  int row = int(fragCoord.y); // Desired row\n  row = min(row,HEIGHT-1); // Clamp at edges\n  int col = int(fragCoord.x); // Desired column\n  col = min(col,WIDTH-1); // Clamp at edges\n  int ix = row*WIDTH+col;\n  uvec4 entry = data[ix/16];\n  ix %= 16;\n  uint t = entry[ix/4];\n  ix %= 4;\n  t >>= 8*ix;\n  t &= 0xffu;\n  fragColor.rgb = getcolor(int(t)-1);\n}", "buffer_b_inputs": [], "common_code": "uint ihash(uint x) {\n    // From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\nuint xorshift(uint value) {\n  // Xorshift*32\n  // By George Marsaglia: http://www.jstatsoft.org/v08/i14/paper\n  value ^= value << 13;\n  value ^= value >> 17;\n  value ^= value << 5;\n  return value;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVyRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[315, 315, 370, 370, 1200]]}
{"id": "fsKczd", "name": "Directional Flow Bilinear", "author": "gehtsiegarnixan", "description": "Implementation of Catlike Coding's Direction Flow [url]https://catlikecoding.com/unity/tutorials/flow/directional-flow/ [/url]", "tags": ["wave", "water", "flow", "vectorfield", "direction", "directionalflow"], "likes": 6, "viewed": 440, "published": 3, "date": "1655412760", "time_retrieved": "2024-07-30T16:44:20.493361", "image_code": "// The MIT License\n// Copyright © 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nUpdate2: I created an even faster version Square Directional Flow \n(https://www.shadertoy.com/view/7dtBWl).\n\nUpdate: I created a faster version of this shader by using hexagon pattern\nwith 2 less texture lookups (https://www.shadertoy.com/view/fsGyDG).\n\nThis is an implementation of directional flow. It animates and rotates a \ntexture in multiple directions with a flowmap. This means that water wave \ntextures can flow in multiple directions at the same time, while the waves \npoint in the right direction. This is not possible with trational flow \nanimation, which either has only one wind direction or stretches the texture \nwith temporal blending. The directional flow blends in the spatial dimension. \nThe disadvantage is that directional flow costs 4 flow texture plus 4 texture \nlookups in 2D and 8+8 in 3D, while the temporal blending only needs one flow \ntexture lookup and 2 texture in 2D/3D.\n\nThe earliest iteration of directional flow I could find is from 2010:\nhttps://www.rug.nl/society-business/centre-for-information-technology/research/hpcv/publications/watershader/\nBut CatlikeCoding's version is much better explained, so I recommend reading \nit as a guide:\nhttps://catlikecoding.com/unity/tutorials/flow/directional-flow/\n*/\n\n//#define ShowGrid\n\n// generates pixelated directional flow\nvec3 flowCell(sampler2D tex, sampler2D flow, vec2 uv, \n              vec2 offset, float gridRes, float time) {              \n    // pixelation and square grid\n    uv = uv * gridRes + offset;\n    vec2 grid = fract(uv) - 0.5;\n    vec2 id = ((uv - grid) - offset)/gridRes; \n    \n    // sample flowmap with pixelized id values\n    vec2 flowMap = flowMap(flow, id);\n\n    // animate and rotate texture using flowmap\n    return PanDirectionalTex(tex, grid, flowMap, time); // moving and rotating\n}\n\n// 4 pixaled flowing textures their edges get hidden by each other\nvec3 bilinearDirectionalFlow(sampler2D tex, sampler2D flow, vec2 uv, \n                             float gridRes, float time, float contrast) {\n    vec3 a = flowCell(tex, flow, uv, vec2(.0,.0), gridRes, time);\n    vec3 b = flowCell(tex, flow, uv, vec2(.5,.0), gridRes, time);\n    vec3 c = flowCell(tex, flow, uv, vec2(.0,.5), gridRes, time);\n    vec3 d = flowCell(tex, flow, uv, vec2(.5,.5), gridRes, time);\n\n    // generate alpha\n    vec2 zickzack = abs(2.* fract(uv * gridRes) - 1.);    \n\tfloat wA = (1. - zickzack.x) * (1. - zickzack.y);\n\tfloat wB = zickzack.x * (1. - zickzack.y);\n\tfloat wC = (1. - zickzack.x) * zickzack.y;\n\tfloat wD = zickzack.x * zickzack.y;\n    vec4 alpha = vec4(wA, wB, wC, wD); \n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    // interpolate result\n    vec3 col = a * alpha.x + b * alpha.y + c * alpha.z + d * alpha.w;\n    \n#ifdef ShowGrid\n    // overlaying the edges of the alpha mask\n    float lineThickness = 0.03; // must be smaller than 0.1\n    vec4 mask = step(abs(alpha - 0.1), vec4(lineThickness));\n    return max(mask.xyz, col * (1.-mask.w));\n#else\n    return col;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {    \n    float time = iTime* .4; // flow speed multiplier\n    float gridRes = 8.; // the number of subdivisions for the sampling of the flowmap\n    float contrast = 2.;  // 1-inf, increased the contrast between the tiles\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n\n    vec3 bdf = bilinearDirectionalFlow(iChannel0, iChannel1, uv, gridRes, time, contrast);\n    \n#ifndef  ShowGrid   \n    bdf += vec3(0.0,0.2,0.5); //adding arbitrary watery color\n#endif\n    \n    fragColor = vec4(bdf, 0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal {\n    vec2 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec2 id;         // ID values\n    float edgeDist;  // Edge distance from the cell's center to its boundaries\n};\n\n// rotates UV by direction\nvec2 rotateUV(vec2 uv, vec2 direction)\n{\n    // Normalize the direction vector\n    direction = normalize(direction);\n\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2(\n        direction.x, -direction.y,\n        direction.y, direction.x\n    );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// rotates and animates texture in flowmap direction \nvec3 PanDirectionalTex (sampler2D sam, vec2 uv, vec2 flowMap, float time) {  \n    uv += flowMap*time; // add offset with time\n\n    uv = rotateUV(uv, flowMap); // rotate UVs\n    \n    // scale UVs so the entire texture is visible in a tile\n    // the proper range is ~1-3 and artists don't read, so this is hard set to\n    uv *= 2.0;\n    \n    return texture(sam, uv).xyz; // sample texture\n}\n\n// generates a -1-1 smooth flowmap\nvec2 flowMap(sampler2D sam, vec2 uv) {\n    //a random spot in the noise map, normally you use an actual flowmap\n    vec2 flowMap = texture(sam, uv*0.05).xy;\n    return flowMap * 2. -1.; // constant bias scale for -1 to 1 range\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec4 smoothContrast(vec4 alpha, float contrast) {\n    // increase steepness using power\n    vec4 powAlpha = pow(alpha, vec4(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z + powAlpha.w);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKczd.jpg", "access": "api", "license": "mit", "functions": [[2351, 2391, 2501, 2549, 2881], [2883, 2950, 3093, 3093, 4091], [4093, 4093, 4149, 4149, 4657]]}
{"id": "ssyczt", "name": "Hyperbolic Torus", "author": "mla", "description": "To complete the set: the hyperbolic torus. The underlying conic equation used is Au²+Bv²+Cuv = 1, so this one will do oblique ellipses as well. The quartic coefficients get a bit more complex & finding the roots Is harder, so gets flaky here and there.", "tags": ["torus", "quartic", "hyperbolic"], "likes": 10, "viewed": 355, "published": 3, "date": "1655392932", "time_retrieved": "2024-07-30T16:44:21.414898", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Torus\n//\n// <mouse>: change view direction\n// <up/down>: zoom\n// 'a': antialiasing\n// 'e': show oblique ellipsoidal torus \n// 'r': autorotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\n// Lighting\nvec3 light = vec3(1,1,-1);\nfloat ambient = 0.4;\nfloat diffuse = 0.6;\nfloat specular = 0.8;\nfloat specularpow = 10.0;\nvec3 specularcolor = vec3(1);\n\n\nfloat A = 1.0, B = -1.0, C = 0.0, r = 2.0;\nint ctorus (vec3 p, vec3 dir, out vec4 roots) {\n  float A2 = A*A, B2 = B*B, C2 = C*C;\n  float r2 = r*r, r3 = r*r2, r4 = r2*r2;\n  float x0 = p.x, y0 = p.y, z0 = p.z;\n  float x02 = x0*x0, x03 = x02*x0, x04 = x02*x02;\n  float y02 = y0*y0, y03 = y02*y0, y04 = y02*y02;\n  float z02 = z0*z0, z03 = z02*z0, z04 = z02*z02;\n  float x1 = dir.x, y1 = dir.y, z1 = dir.z;\n  float x12 = x1*x1, x13 = x12*x1, x14 = x12*x12;\n  float y12 = y1*y1, y13 = y12*y1, y14 = y12*y12;\n  float z12 = z1*z1, z13 = z12*z1, z14 = z12*z12;\n  float a = (A2*x14 + 2.0*A2*x12*y12 + A2*y14 + 2.0*A*B*x12*z12 - C2*x12*z12 + 2.0*A*B*y12*z12 - C2*y12*z12 + B2*z14);\n  float b = 2.0*(2.0*A2*x0*x13 + 2.0*A2*x12*y0*y1 + 2.0*A2*x0*x1*y12 + 2.0*A2*y0*y13 + A*C*r*x12*z1 + A*C*r*y12*z1 + 2.0*A*B*x12*z0*z1 - C2*x12*z0*z1 + 2.0*A*B*y12*z0*z1 - C2*y12*z0*z1 + 2.0*A*B*x0*x1*z12 - C2*x0*x1*z12 + 2.0*A*B*y0*y1*z12 - C2*y0*y1*z12 - B*C*r*z13 + 2.0*B2*z0*z13);\n  float c = - (2.0*A2*r2*x12 - 6.0*A2*x02*x12 - 2.0*A2*x12*y02 - 8.0*A2*x0*x1*y0*y1 + 2.0*A2*r2*y12 - 2.0*A2*x02*y12 - 6.0*A2*y02*y12 - 2.0*A*C*r*x12*z0 - 2.0*A*C*r*y12*z0 - 2.0*A*B*x12*z02 + C2*x12*z02 - 2.0*A*B*y12*z02 + C2*y12*z02 - 4.0*A*C*r*x0*x1*z1 - 4.0*A*C*r*y0*y1*z1 - 8.0*A*B*x0*x1*z0*z1 + 4.0*C2*x0*x1*z0*z1 - 8.0*A*B*y0*y1*z0*z1 + 4.0*C2*y0*y1*z0*z1 - 2.0*A*B*r2*z12 - C2*r2*z12 - 2.0*A*B*x02*z12 + C2*x02*z12 - 2.0*A*B*y02*z12 + C2*y02*z12 + 6.0*B*C*r*z0*z12 - 6.0*B2*z02*z12 + 2.0*A*x12 + 2.0*A*y12 + 2.0*B*z12);\n  float d = -2.0*(2.0*A2*r2*x0*x1 - 2.0*A2*x03*x1 - 2.0*A2*x0*x1*y02 + 2.0*A2*r2*y0*y1 - 2.0*A2*x02*y0*y1 - 2.0*A2*y03*y1 - 2.0*A*C*r*x0*x1*z0 - 2.0*A*C*r*y0*y1*z0 - 2.0*A*B*x0*x1*z02 + C2*x0*x1*z02 - 2.0*A*B*y0*y1*z02 + C2*y0*y1*z02 + A*C*r3*z1 - A*C*r*x02*z1 - A*C*r*y02*z1 - 2.0*A*B*r2*z0*z1 - C2*r2*z0*z1 - 2.0*A*B*x02*z0*z1 + C2*x02*z0*z1 - 2.0*A*B*y02*z0*z1 + C2*y02*z0*z1 + 3.0*B*C*r*z02*z1 - 2.0*B2*z03*z1 + 2.0*A*x0*x1 + 2.0*A*y0*y1 - C*r*z1 + 2.0*B*z0*z1);\n  float e = A2*r4 + A2*x04 - 2.0*A2*r2*y02 + 2.0*A2*x02*y02 + A2*y04 - 2.0*A*C*r3*z0 + 2.0*A*C*r*x02*z0 + 2.0*A*C*r*y02*z0 + 2.0*A*B*r2*z02 + C2*r2*z02 + 2.0*A*B*x02*z02 - C2*x02*z02 + 2.0*A*B*y02*z02 - C2*y02*z02 - 2.0*B*C*r*z03 + B2*z04 - 2.0*(A2*r2 + A)*x02 - 2.0*A*y02 + 2.0*C*r*z0 - 2.0*B*z02 - 2.0*A*r2 + 1.0;\n  return quartic(a,b,c,d,e,roots);\n}\n\nvec3 ctorusnormal (vec3 p) {\n  float A2 = A*A, B2 = B*B, C2 = C*C;\n  float r2 = r*r, r3 = r*r2;\n  float x = p.x, y = p.y, z = p.z;\n  float x2 = x*x, x3 = x2*x;\n  float y2 = y*y, y3 = y2*y;\n  float z2 = z*z, z3 = z2*z;\n  float dx = 4.0*A2*x3 + 4.0*A2*x*y2 + 4.0*A*C*r*x*z + 2.0*(2.0*A*B - C2)*x*z2 - 4.0*(A2*r2 + A)*x;\n  float dy = 4.0*A2*y3 + 4.0*A*C*r*y*z + 2.0*(2.0*A*B - C2)*y*z2 - 4.0*(A2*r2 - A2*x2 + A)*y;\n  float dz = -2.0*A*C*r3 + 2.0*A*C*r*x2 + 2.0*A*C*r*y2 - 6.0*B*C*r*z2 + 4.0*B2*z3 + 2.0*C*r + 2.0*((2.0*A*B + C2)*r2 + (2.0*A*B - C2)*x2 + (2.0*A*B - C2)*y2 - 2.0*B)*z;\n  return vec3(dx,dy,dz);\n}\n\nint dosurface(vec3 p0, vec3 r, out vec4 roots) {\n  return ctorus(p0,r,roots);\n}\n  \nvec3 donormal(vec3 p) {\n  return ctorusnormal(p);\n}\n  \nint solve(vec3 p0, vec3 r, out vec4 roots) {\n  int nroots = dosurface(p0,r,roots);\n  // Sort the roots\n  if (nroots >= 2) {\n    if (roots.y < roots.x) roots.xy = roots.yx;\n  }\n  if (nroots >= 3) {\n    if (roots.z < roots.y) roots.yz = roots.zy;\n    if (roots.y < roots.x) roots.xy = roots.yx;\n  }\n  if (nroots >= 4) {\n    if (roots.w < roots.z) roots.zw = roots.wz;\n    if (roots.z < roots.y) roots.yz = roots.zy;\n    if (roots.y < roots.x) roots.xy = roots.yx;\n  }\n  return nroots;\n}\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nfloat gridline(vec3 p) {\n  // Draw some gridlines on surface\n  vec3 t = fract(p*4.0);\n  t = min(t,1.0-t);\n  float d = min(t.x,min(t.y,t.z));\n  return smoothstep(0.02,0.025,d);\n}\n\nvec3 scene(vec3 p0, vec3 r) {\n  float time = iTime;\n  float a = 0.3333+ max(0.0,3.0*(1.0-cos(0.1*time)));\n  float b = (3.0*a-1.0)/(3.0-a);\n  vec4 params = vec4(a,b,0,0);\n  vec4 roots;\n  vec3 color = vec3(0);\n  int nroots = solve(p0,r,roots);\n  float rwidth = length(fwidth(r));\n  for (int i = nroots-1; i >= 0; i--) {\n    float t = roots[i];\n    if (t < 0.0) break;\n    vec3 p = p0+t*r;\n    vec3 n = donormal(p);\n    if (dot(n,r) > 0.0) n = -n;\n    n = normalize(n);\n    if (isnan(length(n))) continue;\n    float k = 0.0;\n    k += 0.1*iTime;\n    k += 10.0*p.z;\n    vec3 basecolor = pow(abs(n.bgr),vec3(2.0));\n    basecolor = h2rgb(1.5*atan(p.z*p.z)/PI);\n    float dk = fwidth(k);\n    basecolor = mix(vec3(0),basecolor,smoothstep(0.0,rwidth*t*t/abs(dot(n,r)),abs(k-round(k)) - 0.1));\n    vec3 c = applylighting(basecolor,p,n,r);\n    float fog = 1.0-smoothstep(0.0,200.0,t);\n    c *= fog;\n    color = mix(color,c,0.5);\n  }\n  return color;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = 0.5*iTime;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float scale = 1.0;\n  float camera = 6.0;\n  camera *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  r = 2.0*cos(0.0618*iTime);\n  float t = 0.2*iTime, cost = cos(t), sint = sin(t);\n  if (key(CHAR_E)) { A = 2.0; B = 1.0; }\n  float A1 = A*cost*cost+B*sint*sint;\n  float B1 = A*sint*sint+B*cost*cost;\n  float C1 = 2.0*sint*cost*(A-B);\n  A = A1, B = B1, C = C1;\n\n  vec3 p = vec3(0,0,-camera);\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  int AA = 1;\n  if (key(CHAR_A)) AA = 2;\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv, 2.0);\n      r = transform(r);\n      r = normalize(r);\n      color += scene(p,r);\n    }\n  }\n  color /= float(AA*AA);\n  color /= 1.0+color;\n  color = pow(color,vec3(0.4545));\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    x1 = C/A; x2 = -x1;\n  } else {\n    x1 = C/r; x2 = r/A;\n  }\n  res = vec2(x1,x2);\n  return 2;\n}\n\nint quadratic(vec3 coeffs, out vec2 res) {\n  return quadratic(coeffs[0],coeffs[1],coeffs[2],res);\n}\n  \n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Solve: Ax^3 + Bx^2 + Cx + D == 0\n// Find one real root, then reduce to quadratic.\nint cubic(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  if (A == 0.0) {\n    X = 1e8; A = B; b1 = C; c2 = D;\n  } else if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq,x0;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    x0 = X - s*r;\n    if (x0 != X) {\n      X = x0;\n      for (int i = 0; i < 6; i++) {\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        if (dq == 0.0) break;\n        X -= (q/dq);\n      }\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n    }\n  }\n  res.x = X;\n  return 1 + quadratic(A,b1,c2,res.yz);\n}\n\n// Special wrapper for cubic function for solving quartic.\n// Find largest real root of x**3 + a*x**2 + b*x + c\nfloat qcubic(float a, float b, float c) {\n  vec3 res;\n  int nroots = cubic(1.0,a,b,c,res);\n  if (nroots == 1) return res.x;\n  else return max(res.x,max(res.y,res.z));\n}\n\nint quartic(vec4 coeffs, out vec4 res) {\n  float c1 = coeffs[0];\n  float c2 = coeffs[1];\n  float c3 = coeffs[2];\n  float c4 = coeffs[3];\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int n0 = quadratic(1.0,alpha+a,beta+b,res.xy);\n  int n1 = quadratic(1.0,alpha-a,beta-b,res.zw); \n  if (n0 == 0) res.xy = res.zw;\n  return n0+n1;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // It can be advantageous to use the coefficients in the\n  // opposite order, thus solving for the reciprocal.\n  bool flip = abs(A) < 1e-2 && abs(B) < 1e-2;\n  if (abs(B/A) > abs(D/E)) flip = true;\n  vec4 coeffs = flip ? vec4(D,C,B,A)/E : vec4(B,C,D,E)/A;\n  nroots = quartic(coeffs,roots);\n  if (flip) {\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  return nroots;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[563, 563, 610, 610, 2822], [2824, 2824, 2852, 2852, 3431], [3433, 3433, 3481, 3481, 3512], [3516, 3516, 3539, 3539, 3567], [3571, 3571, 3615, 3615, 4055], [4057, 4057, 4117, 4117, 4354], [4356, 4356, 4380, 4416, 4533], [4535, 4535, 4564, 4564, 5473], [5475, 5475, 5502, 5502, 5850], [5852, 5852, 5909, 5909, 6865]]}
{"id": "ssKyzc", "name": "Purple-Black LowPoly", "author": "adamrichardlimb", "description": "Recoloured version of ice and fire by mattz (https://www.shadertoy.com/view/MdfBzl)\nI would have forked but didn't see the option at the time.", "tags": ["purple", "lowpoly"], "likes": 7, "viewed": 343, "published": 3, "date": "1655326503", "time_retrieved": "2024-07-30T16:44:22.156913", "image_code": "/* \n   This is just a recoloured version of:\n\n   ice and fire, by mattz (https://www.shadertoy.com/view/MdfBzl)\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Demonstrate triangulation of jittered triangular lattice.\n\n   Really nice effect - idk if its actually delauney or not but I like it just the same.\n   (I would have forked )\n\n*/\nconst float s3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 tri2cart = mat2(1.0, 0.0, -0.5, 0.5*s3);\nconst mat2 cart2tri = mat2(1.0, 0.0, i3, 2.0*i3);\n\n//////////////////////////////////////////////////////////////////////\n// cosine based palette \n// adapted from https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t,\n          float distance,\n          in vec4 t0, in vec4 t1, in vec4 t2,\n          in vec2 p) {\n    \n    const vec3 a = vec3(0.25);\n    const vec3 b = vec3(0.5);\n    const vec3 c = vec3(0.3, 0.3, 0.3);\n    const vec3 d = vec3(0.0, 0.25, 0.0);\n    \n    float dots = 0.0;\n    \n    //If point intersects with line between two vertices - set to white\n    if (distance > -0.01)\n        dots = 0.0;\n       \n    if (p == t0.xy)\n        dots = 0.5;\n    \n    return clamp(a + b*cos( 6.28318*(c*t+d) ), dots, 1.0);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);   \n}\n\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//////////////////////////////////////////////////////////////////////\n// compute barycentric coordinates from point differences\n// adapted from https://www.shadertoy.com/view/lslXDf\n\nvec3 bary(vec2 v0, vec2 v1, vec2 v2) {\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y);\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    return vec3(u,v,w);\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to line segment from point differences\n\nfloat dseg(vec2 xa, vec2 ba) {\n    return length(xa - ba*clamp(dot(xa, ba)/dot(ba, ba), 0.0, 1.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// generate a random point on a circle from 3 integer coords (x, y, t)\n\nvec2 randCircle(vec3 p) {\n    \n    vec2 rt = hash23(p);\n    \n    float r = sqrt(rt.x);\n    float theta = 6.283185307179586 * rt.y;\n    \n    return r*vec2(cos(theta), sin(theta));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// make a time-varying cubic spline at integer coords p that stays\n// inside a unit circle\n\nvec2 randCircleSpline(vec2 p, float t) {\n\n    // standard catmull-rom spline implementation\n    float t1 = floor(t);\n    t -= t1;\n    \n    vec2 pa = randCircle(vec3(p, t1-1.0));\n    vec2 p0 = randCircle(vec3(p, t1));\n    vec2 p1 = randCircle(vec3(p, t1+1.0));\n    vec2 pb = randCircle(vec3(p, t1+2.0));\n    \n    vec2 m0 = 0.5*(p1 - pa);\n    vec2 m1 = 0.5*(pb - p0);\n    \n    vec2 c3 = 2.0*p0 - 2.0*p1 + m0 + m1;\n    vec2 c2 = -3.0*p0 + 3.0*p1 - 2.0*m0 - m1;\n    vec2 c1 = m0;\n    vec2 c0 = p0;\n    \n    return (((c3*t + c2)*t + c1)*t + c0) * 0.8;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// perturbed point from index\n\nvec2 triPoint(vec2 p) {\n    float t0 = hash12(p);\n    return tri2cart*p + 0.45*randCircleSpline(p, 0.15*iTime + t0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// main shading function. inputs:\n// \n//   p - current pixel location in scene\n//\n//   tfloor - integer grid coordinates of bottom-left triangle vertex\n//\n//   t0, t1, t2 - displaced cartesian coordinates (xy) and integer\n//                grid offsets (zw) of triangle vertices, relative\n//                to tfloor\n//\n//   scl - pixel size in scene units\n//\n//   cw - pixel accumulator. xyz are rgb color pre-multiplied by\n//        weights, and w is total weight.\n//\n\nvoid tri_color(in vec2 p, \n               in vec4 t0, in vec4 t1, in vec4 t2, \n               in float scl, \n               inout vec4 cw) {\n               \n    // get differences relative to vertex 0\n    vec2 p0 = p - t0.xy;\n    vec2 p10 = t1.xy - t0.xy;\n    vec2 p20 = t2.xy - t0.xy;\n    \n    // get barycentric coords\n    vec3 b = bary(p10, p20, p0);\n    \n    // distances to line segments\n    float d10 = dseg(p0, p10);\n    float d20 = dseg(p0, p20);\n    float d21 = dseg(p - t1.xy, t2.xy - t1.xy);\n    \n    // unsigned distance to triangle boundary\n    float d = min(min(d10, d20), d21);\n\n    // now signed distance (negative inside, positive outside)\n    d *= -sign(min(b.x, min(b.y, b.z))); \n\n    // only wory about coloring if close enough\n    if (d < 0.5*scl) {\n\n        //////////////////////////////////////////////////\n        // generate per-vertex palette entries\n    \n        // sum of all integer grid indices\n        vec2 tsum = t0.zw + t1.zw + t2.zw;\n\n        // generate unique random number in [0, 1] for each vertex of\n        // this triangle\n        vec3 h_tri = vec3(hash12(tsum + t0.zw),\n                          hash12(tsum + t1.zw),\n                          hash12(tsum + t2.zw));\n\n        //////////////////////////////////////////////////\n        // now set up the \"main\" triangle color:\n        \n        // get the cartesian centroid of this triangle\n        vec2 pctr = (t0.xy + t1.xy + t2.xy) / 3.0;\n\n        // angle of scene-wide color gradient\n        float theta = 1.0 + 0.01*iTime;\n        vec2 dir = vec2(cos(theta), sin(theta));\n\n        // how far are we along gradient?\n        float grad_input = dot(pctr, dir) - sin(0.05*iTime);\n\n        // h0 varies smoothly from 0 to 1\n        float h0 = sin(0.7*grad_input)*0.5 + 0.5;\n\n        // now the per-vertex random numbers are all biased towards h\n        // (still in [0, 1] range tho)\n        h_tri = mix(vec3(h0), h_tri, 0.4);\n\n        //////////////////////////////////////////////////\n        // final color accumulation\n        \n        // barycentric interpolation of per-vertex palette indices\n        float h = dot(h_tri, b);\n\n        // color lookup\n        vec3 c = pal(h, d, t0, t1, t2, p);\n        \n        // weight for anti-aliasing is 0.5 at border, 0 just outside,\n        // 1 just inside\n        float w = smoothstep(0.5*scl, -0.5*scl, d);\n\n        // add to accumulator\n        cw += vec4(w*c, w);\n        \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    float scl = 4.1 / iResolution.y;\n    \n    // get 2D scene coords\n    vec2 p = (fragCoord - 0.5 - 0.5*iResolution.xy) * scl;\n    \n    // get triangular base coords\n    vec2 tfloor = floor(cart2tri * p + 0.5);\n\n    // precompute 9 neighboring points\n    vec2 pts[9];\n\n    for (int i=0; i<3; ++i) {\n        for (int j=0; j<3; ++j) {\n            pts[3*i+j] = triPoint(tfloor + vec2(i-1, j-1));\n        }\n    }\n    \n    // color accumulator\n    vec4 cw = vec4(0);\n\n    // for each of the 4 quads:\n    for (int i=0; i<2; ++i) {\n        for (int j=0; j<2; ++j) {\n    \n            // look at lower and upper triangle in this quad\n            vec4 t00 = vec4(pts[3*i+j  ], tfloor + vec2(i-1, j-1));\n            vec4 t10 = vec4(pts[3*i+j+3], tfloor + vec2(i,   j-1));\n            vec4 t01 = vec4(pts[3*i+j+1], tfloor + vec2(i-1, j));\n            vec4 t11 = vec4(pts[3*i+j+4], tfloor + vec2(i,   j));\n          \n            // lower\n            tri_color(p, t00, t10, t11, scl, cw);\n\n            // upper\n            tri_color(p, t00, t11, t01, scl, cw);\n           \n        }\n    }    \n        \n    \n    // final pixel color\n    fragColor = cw / cw.w;\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKyzc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[710, 710, 826, 826, 1242], [1439, 1439, 1461, 1461, 1589], [1591, 1591, 1613, 1613, 1717], [1903, 1903, 1941, 1941, 2161], [2286, 2286, 2316, 2316, 2387], [2532, 2532, 2557, 2557, 2717], [2882, 2882, 2922, 2973, 3435], [3539, 3539, 3562, 3562, 3657], [4201, 4201, 4341, 4401, 6630], [6704, 6704, 6761, 6761, 7916]]}
{"id": "fsVyzc", "name": "test multiplicative cascade", "author": "FabriceNeyret2", "description": "left: base field       right : multiplicative cascade\ntop: value             bottom: transparency", "tags": ["noise", "perlin", "multifractal", "multiplicativenoise"], "likes": 4, "viewed": 274, "published": 3, "date": "1655309392", "time_retrieved": "2024-07-30T16:44:22.963756", "image_code": "//#define f(x) sin(x)\n#define f(x) ( texture(iChannel0, (x)/64. ).rg * 2. - 1. )         // pattern source\n#define C(x) ( 1. + atan(k*f(x))/atan(k) )                         // contrast func: linear to bi-lobe\n#define H(i)  fract(sin( (i)* vec2(12.9898, 78.233)) * 43758.5453)\n#define V(i)  ( H(i) + iTime*H(i+.5) )                             // random offset + velocity\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, \n         U = 20.*( 2.*u - R ) / R.y, C;\n    float k = iMouse.z > 0. ? 16.*iMouse.y/R.y : 4.;               // contrast: const to bi-lobe \n    C = C(U+V(1.));                                                // base shape\n    if (U.x>0.) C *= C(2.*U+V(2.)) * C(4.*U+V(3.))* C(8.*U+V(4.)); // cascade\n    O = vec4( C.x*C.y );\n    if (U.y<0.) O = exp(-O/4.);  // arbitrary tau                  // transparency\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[373, 373, 411, 411, 848]]}
{"id": "7sycz3", "name": "Animated Triangle Grid Weave", "author": "Shane", "description": "An animated triangle grid weave.", "tags": ["grid", "triangle", "simplex", "truchet", "polar", "animate", "weave"], "likes": 48, "viewed": 678, "published": 3, "date": "1655299745", "time_retrieved": "2024-07-30T16:44:23.794535", "image_code": "/*\n\n    Animated Triangle Grid Weave\n    ----------------------------\n    \n    I did this a while ago in preparation for an icosahedral example I \n    was working on. Icosahedrons consist of triangles, so if you can \n    get a random animated weave to work on a flat triangle grid, it \n    should work on the surface of any equilateral triangle based entity.\n    \n    Anyway, the weave pattern itself is pretty straight forward: \n    Construct a triangle grid, create a separate arc around each \n    triangle cell vertex, then render each of them in random order --\n    A quick way to do that is to randomly rotate the local triangle \n    cell coordinates then render the arcs in the same order.\n    \n    The animation didn't present too many problems, but it took me a \n    while to realize that I'd need double arcs containing separate \n    paths running in opposite directions for things to work on a random\n    weave -- The reasoning relates to how animated hexagon Truchets \n    work... It's not important why.\n    \n    The design was rushed, but it's clean looking. I got used to the \n    original flat look and template colors, so left them as is. I'll \n    post the polyhedral example at some stage.\n    \n    \n    Other examples:\n    \n    // A different kind of weave produced in a 3D chainlink style. Very cool.\n    tri truch tralala - flockaroo\n    https://www.shadertoy.com/view/WlS3WV\n\n    // An extruded simplex weave, but with no animation. It takes a while to\n    // compile, but runs well enough... I'll make it compile faster later.\n    Simplex Weave - Shane\n    https://www.shadertoy.com/view/WdlSWl\n\n\n*/\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = 1./5.;\n\n// Rectangle scale.\nconst vec2 rect = (vec2(1./.8660254, 1))*scale;\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n\nfloat gTri;\nvec4 getTriVerts(vec2 p, inout vec2[3] vID, inout vec2[3] v){\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    // Vertex IDs for the quad.\n    const vec2[4] vertID = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5));\n\n    // Vertex IDs for each partitioned triangle.\n    if(gTri<0.){\n        vID = vec2[3](vertID[0], vertID[2], vertID[1]);\n    }\n    else {\n        vID = vec2[3](vertID[2], vertID[0], vertID[3]);\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect, sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr;\n    v[1] -= ctr;\n    v[2] -= ctr;\n    \n    // Specific centered triangle ID.\n    ctr = vID[2]/3.; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.;\n    id += ctr;\n    // Not used here, but for jigsaw pattern creation, etc, the vertex IDs\n    // need to be correctly centered too.\n    //vID[0] -= ctr; vID[1] -= ctr; vID[2] -= ctr; \n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n//////////\n// Rendering a colored distance field onto a background. I'd argue that\n// this one simple function is the key to rendering most vector styled\n// 2D Photoshop effects onto a canvas. I've explained it in more detail\n// before. Here are the key components:\n//\n// bg: background color, fg: foreground color, sf: smoothing factor,\n// d: 2D distance field value, tr: transparency (0 - 1).\nvec3 blend(vec3 bg, vec3 fg, float sf, float d, float tr){\n\n     return mix(bg, fg, (1. - smoothstep(0., sf, d))*tr);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Global scaling and translation.\n    float gSc = 1.;\n    // Smoothing factor, based on global scaling.\n    float sf = 1./iResolution.y*gSc;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north easterly (top right) direction. \n    vec2 p = uv*gSc - vec2(-.57735, -1)*iTime/50.;\n    \n \n    // Cell coordinate, ID and triangle orientation id.\n    // Cell vertices and vertex ID.\n    vec2[3] v, vID;\n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    vec4 p4 = getTriVerts(p, vID, v);\n    p = p4.xy;\n    vec2 triID = p4.zw;\n    float tri = gTri;\n    \n    \n    \n    // Grid triangles. Some are upside down.\n    //vec2 q = tri<0.? p*vec2(1, -1) : p;\n    vec2 q = p*vec2(1, tri); // Equivalent to the line above.\n    float tr = (max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3.);\n\n    // Object direction, based on triangle ID.\n    vec3 dir = tri<0.? vec3(-1, 1, 1) : vec3(1, -1, -1);\n    \n        // Nearest vertex ID.\n    float vert = 1e5;\n    vec3 arc, ang;\n    float sL = length(v[0] - v[1]);\n    \n    // Random value based on the overall triangle ID.\n    float rnd = hash21(triID + .1);\n    \n    // Random rotation, in incrents of 120 degrees to maintain symmetry.\n    p = rot2(floor(rnd*36.)*6.2831/3.)*p;\n\n    // Nearest vertex, vertex-arc and angle (subtended from each vertex) calculations.\n    vec2 vertID;\n    for(int i = 0; i<3; i++){\n        float vDist = length(p - v[i]);\n        if(vDist<vert){\n            vert = vDist; // Nearest vertex.\n            vertID = triID + vID[i]; // Nearest vertex ID.\n        }\n \n        // One of three arcs that loop around each vertex. This is still\n        // circle distance at this point, but the rest of the calculations \n        // are performed outside the loop (see below).\n        arc[i] = (vDist - sL/2.);\n       \n        // Angle of each pixel on each arc. As above, further calculations\n        // are performed outside the loop for speed.\n        vec2 vp = p - v[i];\n        ang[i] = atan(vp.y, vp.x);\n    }\n    \n    \n    // Number of rotating entities on each arc. Due to triangle symmetry, it needs\n    // to be a multiple of 6, and with the two arc setup here, multiples of 12... \n    // Maybe others will work, but the double arc setup complicates things a bit.\n    vec3 aNum = vec3(12);\n    vec3 aNum0 = aNum; // Using a copy of the initial number to scale values later.\n    \n    // Lane direction.\n    vec3 laneDir = dir;\n    // Reverse the direction of inside lanes and halve the number of objects -- Inside\n    // lanes cover less distance, so fewer objects space out better. By the way, there's\n    // probably a cleverer way to write the following, but my mind's feeling lazy. :)\n    if(arc.x<0.){ laneDir.x *= -1.; aNum.x /= 2.; }\n    if(arc.y<0.){ laneDir.y *= -1.; aNum.y /= 2.; }\n    if(arc.z<0.){ laneDir.z *= -1.; aNum.z /= 2.; }\n    arc = abs(arc); // Turning the circle into an arc.\n    arc = abs(arc - .04); // Doubling the arcs. One inside and the other outside.\n    arc -= .036; // Arc thickness.\n    //laneDir = vec3(1);\n \n    \n    // The final figure, \"aNum0\", is a smoothing factor fudge. Since we're repeating by\n    // a factor of \"aNum\", that number needs to be compensated for... There's probably\n    // an exact way to do it (derivatives spring to mind), but this will do.\n    vec3 ani = (abs(fract(ang/6.2831*aNum + iTime*dir*laneDir*.5) - .5)*2. - .66)/aNum0/2.;\n    ang = max(arc + .025, ani);\n    //vec3 ang2 = max(arc + .026, (abs(ani + .25/aNum0/2.) - .2/aNum0/2.));\n \n    \n    \n    // Background, set to black.\n    vec3 col = vec3(0);\n\n    // Rendering some green triangles onto the background, but leaving the edges.\n    col = blend(col, vec3(.7, 1, .4), sf, tr + .0035, 1.);\n    \n    // Triangle grid vertices.\n    vert -= .0225; // Vertex radius.\n    col = blend(col, vec3(0), sf, vert, 1.);\n    col = blend(col, vec3(.8, 1, .2), sf, vert + .005, 1.);\n    col = blend(col, vec3(0), sf, vert + .018, 1.);\n    \n    // Resolution factor for shadow width -- It's a hack to make sure shadows\n    // have the same area influence at different resolutions. If you think it's\n    // confusing, you'll get no arguments from me. :)\n    float resF = iResolution.y/450.;\n    \n    // Rendering the three sets of double arcs.\n    for(int i = 0; i<3; i++){\n        \n        // Arcs: Rails, edges, etc.\n        col = blend(col, vec3(0), sf*8.*resF, arc[i], .5);\n        col = blend(col, vec3(0), sf, arc[i], 1.);\n         \n        col = blend(col, vec3(1, .9, .85), sf, arc[i] + .005, 1.);\n        col = blend(col, vec3(0), sf, arc[i] + .016, 1.);\n        col = blend(col, vec3(1, .15, .3), sf, arc[i] + .016 + .005, 1.);\n        col = blend(col, vec3(0), sf*4.*resF, abs(arc[i] + .016 + .005), .25);\n     \n        // The animated strips.\n        col = blend(col, vec3(0), sf*4.*resF, ang[i], .25);\n        col = blend(col, vec3(0), sf, ang[i], 1.);\n        col = blend(col, vec3(1, .9, .3), sf, ang[i] + .005, 1.);\n        \n        // Hood and trunk, for the overhead cars look. \n        // \"ang2\" needs uncommenting for it to work\n        //col = blend(col, vec3(0), sf, ang2[i], .65);\n        //col = blend(col, vec3(1, .9, .3)*.7, sf, ang2[i] + .005, 1.);\n        \n    } \n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n    // Colored variation.\n    //col = mix(col.zyx, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.));\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sycz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1625, 1658, 1680, 1680, 1738], [1741, 1769, 1790, 1790, 1853], [2077, 2140, 2168, 2168, 2198], [2200, 2265, 2295, 2295, 2334], [4572, 4967, 5025, 5025, 5086]]}
{"id": "NdKcR3", "name": "Walkers", "author": "dr2", "description": "Family trip", "tags": ["gait", "walk", "quadruped"], "likes": 15, "viewed": 328, "published": 3, "date": "1655292568", "time_retrieved": "2024-07-30T16:44:24.727042", "image_code": "// \"Walkers\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  No. 11 in \"Walking\" series\n    \"Octopod\"                     (4tjSDc)\n    \"Spider Ascent\"               (4sd3WX)\n    \"Moebius Strip\"               (lddSW2)\n    \"Moebius Strip 2\"             (MscXWX)\n    \"Controllable Hexapod\"        (4ljfDK)\n    \"Visible Hexapod\"             (Mdtyzj)\n    \"Moebius, Menger, Spiders\"    (wsXyzM)\n    \"Helical Ramps with Spiders\"  (3sscWf)\n    \"Controllable Hexapod 2\"      (3tKBzw)\n    \"Arachnogenesis\"              (Ndc3RH)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_WLK 3\n\nvec3 sunDir, qHit, wPos;\nfloat tCur, dstFar, spd;\nint idObj;\nconst int idLeg = 1, idAx = 2, idPlat = 3, idTur = 4, idBar = 5;\nbool isSh;\nconst float pi = 3.1415927;\n\nstruct Gird {\n  float wid, thk, crv, hol, lFac;\n};\nGird g;\n\nstruct Leg {\n  vec2 cs1, cs2, cs3;\n};\n\nstruct Walker {\n  Leg leg[4];\n  vec3 wPos;\n  vec2 csTur;\n  float szFac;\n};\nWalker wlk[N_WLK];\n\nfloat hPlat, lLeg, bLen, bWid;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GirdDf (vec3 p)\n{\n  return max (length (max (vec2 (length (vec2 (p.x, abs (p.z) - min (abs (p.z),\n     (g.lFac - 1.) * g.wid))), abs (p.y)) - vec2 (g.wid, g.thk), 0.)) - g.crv, g.hol -\n     length (vec2 (p.x, 2. * g.wid * fract (p.z / (2. * g.wid) + fract (g.lFac / 2.)) - 0.25)));\n}\n\nvoid SetWlkConf ()\n{\n  float sDir, tc, t, tH, tt, tV, limT, fUp, limEx, a1, a2, fh;\n  wlk[0].szFac = 1.2;\n  wlk[1].szFac = 0.82;\n  wlk[2].szFac = 0.51;\n  lLeg = 9.;\n  tH = 0.01;\n  tV = 0.3;\n  limT = 0.6;\n  limEx = 0.995;\n  fUp = 1.;\n  g.wid = 0.25;\n  g.hol = (2./3.) * g.wid;\n  g.crv = 0.01;\n  hPlat = 4. * limEx * (lLeg - 1.) * g.wid * cos (atan (limT));\n  for (int j = 0; j < N_WLK; j ++) {\n    tc = tCur * spd / (wlk[j].szFac * hPlat * limT * 2. / 3.);\n    for (int k = 0; k < 4; k ++) {\n      t = mod (tc + float (k), 4.);\n      if (t > 1.) {\n        sDir = -1.;\n        t = (t - 1.) / 3.;\n      } else sDir = 1.;\n      tt = 0.5 - abs (t - 0.5);\n      a1 = atan (limT * (((tt < tH) ? tt * tt / tH : 2. * tt - tH) / (1. - tH) - 1.) *\n         sign (0.5 - t) * sDir);\n      fh = hPlat;\n      if (sDir > 0.) fh -= fUp * smoothstep (0., tV, tt);\n      fh *= 0.5 / cos (a1);\n      a2 = - ((k == 1 || k == 3) ? -1. : 1.) * acos (0.5 * fh / ((lLeg - 1.) * g.wid));\n      wlk[j].leg[k].cs1 = sin (-0.5 * pi + a1 + a2 + vec2 (0.5 * pi, 0.));\n      wlk[j].leg[k].cs2 = sin (-2. * a2 + vec2 (0.5 * pi, 0.));\n      wlk[j].leg[k].cs3 = sin (0.5 * pi - a1 + a2 + vec2 (0.5 * pi, 0.));\n    }\n    wlk[j].csTur = sin (0.6 * pi * (2. * SmoothBump (0.25, 0.75, 0.25,\n       mod (0.2 * tCur / wlk[j].szFac, 1.)) - 1.) - pi + vec2 (0.5 * pi, 0.));\n    wlk[j].wPos = wPos - vec3 (3.5 * float (2 * j - N_WLK + 1), 0., 0.);\n  }\n  bWid = 1.6;\n  bLen = 3.;\n}\n\nfloat WlkDf (vec3 p, float dMin, Walker wk)\n{\n  vec3 pp, q, qq;\n  float d, lGird, qy;\n  p.y -= hPlat;\n  q = p;\n  q.x = abs (q.x) - bWid;\n  q.y -= g.wid;\n  g.lFac = 13.;\n  g.thk = 0.05;\n  q = q.yxz;\n  d = GirdDf (q);\n  DMINQ (idLeg);\n  q = p;\n  q.y -= g.wid;\n  g.lFac = 7.;\n  g.thk = bWid - 0.05;\n  d = GirdDf (q.yxz);\n  DMINQ (idPlat);\n  g.thk = 0.05;\n  q.z = abs (q.z) - 1.;\n  d = PrCylDf (q.zyx, g.hol, bWid + 2. * g.thk);\n  DMINQ (idAx);\n  q = p;\n  q.y -= g.wid + 0.8;\n  d = PrRoundCylDf (q.zxy, 0.7, 0.1, 0.5);\n  DMINQ (idTur);\n  q = p;\n  q.xz = Rot2Cs (q.xz, wk.csTur);\n  q.yz -= vec2 (g.wid + 0.9, -0.7);\n  d = PrCylDf (q, 0.25, 0.7);\n  DMINQ (idBar);\n  g.thk = 0.05;\n  pp = p;\n  for (int k = 0; k < 4; k ++) {\n    p = pp;\n    p.xz += vec2 (bWid * ((k == 0 || k == 1) ? -1. : 1.), bLen * ((k == 1 || k == 3) ? -1. : 1.));\n    p.y -= g.wid;\n    g.lFac = lLeg;\n    lGird = (lLeg - 1.) * g.wid;\n    q = p.yxz;\n    q.xz = Rot2Cs (q.xz, wk.leg[k].cs1);\n    q.z -= lGird;\n    qy = q.y;\n    q.y = abs (q.y) - 3. * g.thk;\n    d = GirdDf (q);\n    DMINQ (idLeg);\n    q.y = qy;\n    d = PrCylDf (vec3 (q.x, abs (q.z) - lGird, q.y), g.hol, 5. * g.thk);\n    DMINQ (idAx);\n    q.z -= lGird;\n    q.xz = Rot2Cs (q.xz, wk.leg[k].cs2);\n    q.z -= lGird;\n    d = GirdDf (q);\n    DMINQ (idLeg);\n    q.z -= lGird;\n    q.xz = Rot2Cs (q.xz, wk.leg[k].cs3);\n    g.lFac = 4.;\n    lGird = (g.lFac - 1.) * g.wid;\n    q.z -= lGird - 2. * g.wid;\n    qy = q.y;\n    q.y = abs (q.y) - 3. * g.thk;\n    d = GirdDf (q);\n    DMINQ (idLeg);\n    q.y = qy;\n    q.z -= g.wid;\n    d = PrCylDf (vec3 (q.xy, abs (q.z) - 2. * g.wid).xzy, g.hol, 5. * g.thk);\n    DMINQ (idAx);\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (int j = VAR_ZERO; j < N_WLK; j ++) {\n    q = p - wlk[j].wPos;\n    d = (isSh) ? 0. : wlk[j].szFac * PrRoundBoxDf (q / wlk[j].szFac - vec3 (0., 4.5, 0.),\n       vec3 (2.5, 4.5, 8.) - 0.1, 0.1);\n    if (d < 0.3) d = wlk[j].szFac * WlkDf (q / wlk[j].szFac, dMin / wlk[j].szFac, wlk[j]);\n    dMin = min (d, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nfloat GrndHt (vec2 p)\n{\n  return 0.7 * Fbm2 (0.2 * p.yx);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, dstGrnd, sh, nDotL;\n  SetWlkConf ();\n  isSh = false;\n  dstGrnd = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n    if (idObj == idLeg) {\n      if (abs (qHit.y) > 0.045) col4 = mix (col4, vec4 (0.2, 0.5, 0.8, 0.2),\n         step (0.4, Fbm2 (16. * qHit.xz)));\n    } else if (idObj == idAx) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n    } else if (idObj == idPlat) {\n      col4 *= 0.9 + 0.1 * SmoothBump (0.1, 0.9, 0.05, fract (4. * qHit.x));\n    } else if (idObj == idTur) {\n      col4 *= 0.9 + 0.1 * SmoothBump (0.1, 0.9, 0.05, fract (4. * qHit.y));\n    } else if (idObj == idBar) {\n      col4 *= 0.2 + 0.8 * step (0.17, length (qHit.xy));\n    }\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, sunDir), 0.);\n    nDotL *= nDotL;\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col4 = 0.6 * mix (vec4 (0.8, 0.6, 0.4, 0.), vec4 (0.9, 1., 0.5, 0.),\n       smoothstep (0.4, 0.6, Fbm2 (0.5 * ro.xz)));\n    vn = GrndNf (ro);\n    vn = VaryNf (ro, vn, 1. - smoothstep (0.3, 0.5, dstGrnd / dstFar));\n    nDotL = max (dot (vn, sunDir), 0.);\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (dstObj < dstFar || rd.y < 0.) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, sunDir), 0.) + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n  }\n  if (rd.y < 0. && dstObj >= dstFar) col = mix (col, vec3 (0.3, 0.4, 0.5),\n     pow (1. + rd.y, 16.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  spd = 3.;\n  wPos = vec3 (0., 0.01, spd * tCur);\n  az = 0.7 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n  }\n  el = clamp (el, -0.35 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = wPos + vuMat * vec3 (0., 3.5, -45.);\n  zmFac = 4.5;\n  dstFar = 150.;\n  sunDir = vuMat * normalize (vec3 (0.5, 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKcR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1548, 1548, 1571, 1571, 1837], [1839, 1839, 1859, 1859, 3275], [3277, 3277, 3322, 3322, 4934], [4936, 4936, 4958, 4958, 5339], [5341, 5341, 5374, 5374, 5558], [5560, 5560, 5581, 5581, 5836], [5838, 5838, 5875, 5875, 6118], [6120, 6120, 6154, 6154, 6911], [6913, 6913, 6936, 6936, 6972], [6974, 6974, 6996, 6996, 7140], [7142, 7142, 7177, 7177, 8841], [8843, 8843, 8899, 8899, 10014], [10016, 10016, 10062, 10062, 10109], [10111, 10111, 10153, 10153, 10204], [10206, 10206, 10263, 10263, 10339], [10341, 10341, 10398, 10398, 10481], [10483, 10483, 10519, 10519, 10725], [10727, 10727, 10757, 10757, 10870], [10872, 10872, 10903, 10903, 10967], [11001, 11001, 11025, 11025, 11078], [11080, 11080, 11104, 11104, 11216], [11218, 11218, 11243, 11243, 11389], [11391, 11391, 11416, 11416, 11602], [11604, 11604, 11626, 11626, 11780], [11782, 11782, 11803, 11803, 11958], [11960, 11960, 11989, 11989, 12201], [12203, 12203, 12242, 12242, 12499]]}
{"id": "sdGyR3", "name": "Plasma knot mosaic", "author": "jarble", "description": "More glowing plasma fractal stuff.", "tags": ["fractal", "knot", "mosaic"], "likes": 4, "viewed": 266, "published": 3, "date": "1655265253", "time_retrieved": "2024-07-30T16:44:25.578764", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.5*2.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float t4 = floor((uv.x+uv.y+iTime)/16.);\n\n    for(int i=1;i<5;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 1; k < 4; k++){\n        \n            uv += (t2.yx);\n            //uv *= (1.+t2.yx/2.);\n            //uv += floor(t2.y+t2.x)/2.;\n            t2 = triangle_wave(uv.yx+1.5,scale)+float(i-k);\n            t3 = triangle_wave(uv-float(i*k),scale);\n            t3.y -= float(i)/8.;\n            //t3.y -= abs(fract(uv.x-.5))*float(i)/4.;\n\n            uv.yx = (t2+t3)/(scale);\n            vec2 uv1 = uv + triangle_wave((uv.yx+iTime/4.)*4.,scale)/16.;\n            col.x = min(((uv1.y-uv1.x)+col.x*sign(uv1.x-uv1.y)),col.x)/sqrt(3.);\n            col = max(col.yzx,abs(col.yzx+vec3(col.x))/sqrt(3.));\n            //col = max(col.yzx,abs(col+vec3(col.x))).yzx/sqrt(3.); //another nice color palette\n        }\n        \n    }\n    fragColor = vec4((col*9.*2.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 1326]]}
{"id": "fdyyR3", "name": "correlated shadows / hotspot", "author": "FabriceNeyret2", "description": "When the view and light directions are very close, shadowed parts are hidden to the view so the object appears globally brighter.\nMouse controls light.\nNB: doing it with cones would be better.\n", "tags": ["raytracing", "raycasting", "shadows", "correlation", "short", "hotspot"], "likes": 14, "viewed": 333, "published": 3, "date": "1655240673", "time_retrieved": "2024-07-30T16:44:26.325767", "image_code": "int   N = 7;      // N^3 spheres of radius r\nfloat r = .4;\n#define hash3(p)      fract(sin(float(p)*vec3(127.1,311.7, 74.7))*4e5 )\n#define rot(a)        mat2(cos(a),-sin(a),sin(a),cos(a))  // rotation\n//#define sphere(i)  ( 2.*hash3(i) - 1. ) * float(N)/2.        \n  #define sphere(i)  ( vec3( i/N/N, (i/N)%N, i%N ) - float(N)/2. + hash3(i)-.5 )       \n\nfloat raycast(vec3 P, vec3 D, inout int _i) { // --- return dist, _i= id\n    float l = 1e5;\n    for ( int i=0; i<N*N*N; i++ ) {                // for each sphere\n        vec3  C = sphere(i) - P;                   // compute intersection\n        float b = dot(C,D), c = dot(C,C)-r*r, d = b*b -c, s = b-sqrt(d);\n        if ( d>0. && s>0. && s < l )\n            if (_i<0) return s;                    // shadow: early exit\n            else      l = s, _i = i;               // keep closest hit (in front)\n    }\n    return l;\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -5.*R.y) - R),         // ray direction\n          P = 30./R,                                      // camera position \n          L = vec3(0,0,1),\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(5,5,0)/1e2*cos(.5*iTime+vec3(0,11,0)); // auto thumbnail\n    \n    L.yz *= rot(-6.*M.y),                                 // rotations\n    L.xz *= rot(-6.*M.x);\n  /*P.yz *= rot(-6.*M.y),                           \n    P.xz *= rot(-6.*M.x);\n    D.yz *= rot(-6.*M.y),                           \n    D.xz *= rot(-6.*M.x);\n  */\n    int i=0,j=-1;\n    float l = raycast(P,D, i),                            // raycast spheres\n          s = raycast(P += (l-1e-2)*D, L , j);            // shadow ray\n    \n    vec3 N = normalize( P - sphere(i) );\n    O =  l == 1e5 ? vec4(.6,.8,1,1)                       // no hit\n                  : ( 1. + dot(N,L) )/2. // max(.0,dot(N,L)) //exp(-.1*(l-25.))   // shading\n                      * ( s == 1e5 ? vec4(0,.8,0,0)       // hit and no shadow\n                                   : vec4(0,.2,0,0) );    // hit and shadow \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 354, 399, 426, 877], [879, 879, 915, 915, 2028]]}
{"id": "fdGyR3", "name": "PerfTest Hexgrid Algorithms", "author": "gehtsiegarnixan", "description": "A quick performance test designed to tank your FPS to see which operation is faster. \nif version is faster", "tags": ["test", "hexagon", "performance", "branchless", "hex", "speed"], "likes": 1, "viewed": 185, "published": 3, "date": "1655237232", "time_retrieved": "2024-07-30T16:44:27.126626", "image_code": "/*\nTesting out different methods to make a Hexagonal Grid for perfromance. \nTo try this test for yourself, increase the \"repeat\" value to tank you fps \nuntil it goes well below 144fps. Then comment in the x value calculation\nfor the function you wish to test. \n\nThere's no one true winner here. If you need the ID values Shanes vec4 \nversion is fastest. If you don't then the BigWIngs if version is faster.\nBut try for yourself with the combination of values you need.\n\nIf you wish to learn how Hextiling works BigWIngs version has a great video \nexplaining how the math works (https://youtu.be/VmrIDyYiJBA).  \nIf you like to read more Shanes version is very well commented \n(https://www.shadertoy.com/view/Xljczw).\n*/\n\n#define sqrt3 \t\t1.7320508075\n#define half_sqrt3\t0.8660254037\n\nconst vec2 r = vec2(1, sqrt3); // 1, sqrt(3)\nconst vec2 h = vec2(0.5,half_sqrt3); // 1/2, sqrt(3) /2\n\n// Hexagonal Distanstance from the 0,0 coords\nfloat hexDist(vec2 p) {\n\tp = abs(p);   \n    return max(dot(p, h), p.x);\n}\n\n// From Amhall \"Cube Pixel Tetrahedron\" (https://www.shadertoy.com/view/7sXyRN)\n// Elegant, but slow, so use the others\nvec4 hexTile_lerp(vec2 uv) {\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n\n    float d1 = dot(a,a);\n    float d2 = dot(b,b);\n\n    vec2 gv = mix(a, b, float(d2 < d1)); // Branch-free!\n    \n    //float eDist = hexDist(gv); // Edge distance\n    // float cDist = dot(gv, gv); // squared distance from center\n    vec2 id = uv-gv; // ID coords\n\n    return vec4(gv, id); // xy hex coords + z distance to edge\n}\n\n// From BigWIngs \"Hexagonal Tiling\" https://www.shadertoy.com/view/3sSGWt\n// If you need the ID use vec4 version\nvec4 hexCoords_if(vec2 uv) {   \n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b; // Branch\n    \n    //float eDist = hexDist(gv); // Edge distance\n    //float cDist = dot(gv, gv); // squared distance from center\n    vec2 id = uv-gv; // ID coords\n    \n    return vec4(gv, id); // xy hex coords + z distance to edge\n}\n\n// From Shanes \"Minimal Hexagonal Grid\" https://www.shadertoy.com/view/Xljczw\n// This one always calculates the ID values, if you don't need those use if version\nvec4 HexCoords_vec4(vec2 p){\n    // hex centers\n    vec4 ab = vec4(p, p - vec2(.5, 1));\n    vec4 hC = floor(ab/r.xyxy) + .5;\n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*r, p - (hC.zw + .5)*r);\n    \n    vec4 uvid = dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n    \n    //float eDist = hexDist(uvid.xy); // Edge distance.\n    //float cDist = dot(uvid.xy, uvid.xy); // Squared distance from center\n\n    //vec2 id = vec2(uvid.z, uvid.w*sqrt3); // square grid Id values otherwise use uvid.zw\n    return vec4(uvid);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y; //centered square UVs\n    vec2 subject = (uv* 2.) + (iTime * 0.2) + 100.; //some arbitrary motion\n    \n    // if you get around 144 fps use a higher repeat value\n    int repeat = 1; //3000 is enough for RTX2070\n    \n    vec4 test;\n    for(int i=0; i<repeat; i++)\n    {\n        vec2 a = subject + float(i); // permutation each iteration\n        \n        // use which ever you wish to test\n        //vec4 x = hexTile_lerp(a); //62fps \n        //vec4 x = hexCoords_if(a); //68fps \n        vec4 x = HexCoords_vec4(a); //70fps\n        \n        test += x; // each iteration adds to final result\n    }        \n    \n    fragColor = vec4(fract(test)); // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[884, 930, 953, 953, 1003], [1005, 1125, 1153, 1153, 1539], [1541, 1654, 1682, 1682, 2024], [2026, 2188, 2216, 2235, 2781], [2783, 2783, 2840, 2840, 3566]]}
{"id": "sdKczV", "name": "3 ringsources circeling", "author": "hk", "description": "3 dots emitting colorful waves circle a common center point", "tags": ["2d"], "likes": 1, "viewed": 74, "published": 3, "date": "1655235142", "time_retrieved": "2024-07-30T16:44:27.882605", "image_code": "float PI = 3.141;\n\n\nvec3 ringy(vec2 center, vec3 color, float time) {\n\tfloat mx    = max(iResolution.x, iResolution.y);\n\tvec2  uv    = gl_FragCoord.xy / mx;\n\t\n\tfloat rings = smoothstep(0.99, 0.991, sin(time - distance(uv, center) * 255.0));\n\tvec3  dotty = vec3(smoothstep(0.0011, 0.001, distance(uv, center)));\n\tvec3  circle_source = dotty + vec3(rings) * color;\n\treturn circle_source;\n}\n\n\nvec2 getCenter(float phase, float t) {\n    float mx = max(iResolution.x, iResolution.y);\n    return vec2(iResolution / mx * 0.5)\n        + vec2(\n            sin(t / 10.0 + 2.0 * PI * phase/(2.0*PI)) * 0.1, \n            cos(t / 10.0 + 2.0 * PI * phase/(2.0*PI)) * 0.1);\n}\n\nvec3 getColor(vec2 r, vec2 g, vec2 b, vec2 c) {\n    float mx = max(iResolution.x, iResolution.y);\n    vec2  uv = gl_FragCoord.xy / mx;\n    \n    return vec3(\n        smoothstep(r.x, r.y, distance(uv, c)),\n        smoothstep(g.x, g.y, distance(uv, c)),\n        smoothstep(b.x, b.y, distance(uv, c)));\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 fragCoord) {\n    float mx = max(iResolution.x, iResolution.y);\n    vec2  uv = gl_FragCoord.xy / mx;\n    float t_wave = iTime * 10.0;\n    float t_spin = iTime *  5.0;\n\t\n    vec2 c1_center = getCenter(2.0/3.0 * PI, t_spin);\n    vec2 c2_center = getCenter(4.0/3.0 * PI, t_spin);\n    vec2 c3_center = getCenter(2.0     * PI, t_spin);\n    \n    vec3 c1_color = getColor(vec2(0.1, 0.05), vec2(0.3, 0.2),  vec2(0.2, 0.1),  c1_center);\n    vec3 c2_color = getColor(vec2(0.3, 0.2),  vec2(0.2, 0.1),  vec2(0.1, 0.05), c2_center);\n    vec3 c3_color = getColor(vec2(0.2, 0.1),  vec2(0.1, 0.05), vec2(0.3, 0.2),  c3_center);\n\n\tvec3 scene = ringy(c1_center, c1_color, t_wave)\n        + ringy(c2_center, c2_color, t_wave)\n        + ringy(c3_center, c3_color, t_wave);\n\tout_color = vec4(scene, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 69, 69, 387], [390, 390, 428, 428, 660], [662, 662, 709, 709, 962], [965, 965, 1020, 1020, 1792]]}
{"id": "7sKczK", "name": "Down the drain", "author": "babopicasso", "description": "Little effect for draining images.", "tags": ["drain"], "likes": 10, "viewed": 276, "published": 3, "date": "1655224879", "time_retrieved": "2024-07-30T16:44:28.639581", "image_code": "#define DELAY 0.\n#define SPEED_MULTIPLIER 0.2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float delayTime = pow(max(mod(iTime, 10.) - DELAY, 0.) * SPEED_MULTIPLIER, 5.);\n\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv *= pow(delayTime * 0.1 + 1.0, 5.);\n    \n    float r = length(uv);\n    \n    float phi = atan(uv.y, uv.x) + delayTime / (r * 0.5);\n       \n    vec2 duv = r * vec2(cos(phi), sin(phi)) + 0.5;\n    \n    vec4 c = texture(iChannel0, duv);\n    \n    float m = 1.0;\n    if (duv.x > 1.0 || duv.y > 1.0 || duv.x < 0.0 || duv.y < 0.0) m = 0.0;\n    \n    fragColor = c * m;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 104, 104, 602]]}
{"id": "NdKyRV", "name": "ropes illusion", "author": "FabriceNeyret2", "description": "ropes are parallel.\nreference: https://twitter.com/gsarcone/status/1467147435889893379", "tags": ["2d", "illusion", "2tweets", "perception", "short", "golf", "reproduction"], "likes": 22, "viewed": 318, "published": 3, "date": "1655206592", "time_retrieved": "2024-07-30T16:44:29.463378", "image_code": "#define S(v) smoothstep(0.,1., abs( fract(v) *2. - 1. ) ).y   // smooth line\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 14.*( u+u - R ) / R.y;\n    O = vec4(   S( U )                                        // ropes\n              * S( U * mat2(3,1, abs(U.y)>6.5 ? -1 : 1 ,3) )  // threads\n            );\n    O = sqrt(O);                                              // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 116, 116, 415]]}
{"id": "sdGyRV", "name": "julia orbits circles", "author": "mds2", "description": "Fork of https://www.shadertoy.com/view/lsKfDV but using concentric circles instead of the x and y axes.", "tags": ["fractal", "julia", "antialias", "pickover", "stalks"], "likes": 19, "viewed": 293, "published": 3, "date": "1655181088", "time_retrieved": "2024-07-30T16:44:30.270221", "image_code": "#define ITERS 128\n\n#define USE_THIN_LINES 1\n\n#define MUL(a, b) (mat2(a, -a.y, a.x) * b)\n// complex number multiplication, Fabrice style.\n\n#define TRIM_EDGES 1\n// set to 0 to let stalks go to infinity -- best with a small number of ITERS\n// for instance, TRIM_EDGES=0 and ITERS=8 works well\n\n#define EXACTLY_TRIM_EDGES 0\n\nfloat ramp(in float minval, in float maxval, in float val) {\n    return clamp((val - minval) / (maxval - minval), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 z = 1.0 * uv;\n    \n    vec2 mouse_norm = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    vec2 axes = vec2(0.0);\n    vec2 c = mouse_norm;\n    \n    float dist1 = abs(length(z) - 0.125);\n    float dist2 = abs(length(z) - 0.25);\n    float min_dist = min(dist1, dist2);\n        \n    vec2 grad = vec2(1.0, 0.0);\n    // so, in addition to wanting to compute iterations of the function f(z) = z^2+c, we\n    // also want it's derivative, so we can estimate the distance in pixel space to the z\n    // such that f^i(z) is zero in either the real or the complex axis.\n    \n    for (int i = 0; i < ITERS; ++i) {\n             \n        vec2 zprime = 2.0 * z;\n        // here's our derivative of the next iteration in terms of this one\n        // now let's compute the derivative of the next iteration with respect to the start point\n        grad = MUL(zprime, grad);\n\n        float gradient_inv_magnitude = 1.0 / length(grad);\n        // thanks, @iq, for the tip on how to save a sqrt\n\n        z = MUL(z,z) + c;\n        // and here we actually perform our julia iteration, which is the tiniest part of the code\n        \n        \n        dist1 = abs(length(z) - 0.125) * gradient_inv_magnitude;\n        dist2 = abs(length(z) - 0.25)  * gradient_inv_magnitude;\n        // see above comment.\n        min_dist = min(min_dist, min(dist1, dist2));\n    \n        \n        if (dot(z,z) > 4.0) {\n#if EXACTLY_TRIM_EDGES            \n            min_dist = 10.0;\n\n#elif !TRIM_EDGES\n            min_dist = 0.0;\n#endif            \n            break;\n        }\n        \n    }\n    \n\n#if USE_THIN_LINES\n    vec3 col = vec3(ramp(0.0 / iResolution.y, 2.0 / iResolution.y, min_dist));\n#else\n    min_dist = min_dist * sqrt(2.0);\n\tvec3 col =\n        vec3(ramp(0.0 / iResolution.y, 2.0 / iResolution.y, min_dist),\n             ramp(1.0 / iResolution.y, 3.0 / iResolution.y, min_dist),\n             ramp(2.0 / iResolution.y, 4.0 / iResolution.y, min_dist));\n    // and here we compute our tricolored line\n#endif\n    // TODO : consider coloring by iteration\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[321, 321, 381, 381, 447], [449, 449, 506, 556, 2715]]}
{"id": "sdGczK", "name": "Laser knot mosaic", "author": "jarble", "description": "A mosaic of pulsing lasers.", "tags": ["fractal", "knot", "mosaic"], "likes": 4, "viewed": 213, "published": 3, "date": "1655177007", "time_retrieved": "2024-07-30T16:44:31.013235", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.5*2.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float t4 = floor((uv.x+uv.y+iTime)/16.);\n\n    for(int i=1;i<4;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 1; k < 4; k++){\n        \n            uv += (t2.yx);\n            //uv *= (1.+t2.yx/2.);\n            //uv += floor(t2.y+t2.x)/2.;\n\n            t2 = triangle_wave(uv.yx+1.5,scale)+float(i-k);\n            //uv += floor(t2.y+t2.x)/2.;\n\n            //t2.y -= float(i)/8.;\n            t3 = triangle_wave(uv-float(i*k),scale);\n            //t3 -= float(k)/3.;\n            uv.yx = (t2+t3)/(scale);\n            vec2 uv1 = uv + triangle_wave((uv.yx+iTime/4.)*4.,scale)/16.;\n            col.x = min(((uv1.y-uv1.x)+col.x*sign(uv1.x-uv1.y)),col.x)/sqrt(3.);\n            col = max(col.yzx,abs(col.yzx+vec3(col.x))/sqrt(3.));\n            //col = max(col.yzx,abs(col+vec3(col.x))).yzx/sqrt(3.); //another nice color palette\n        }\n        \n    }\n    fragColor = vec4((col*9.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 1345]]}
{"id": "7dycRK", "name": "show house v2", "author": "jorge2017a2", "description": "show house v2", "tags": ["showhousev2"], "likes": 6, "viewed": 196, "published": 3, "date": "1655170960", "time_retrieved": "2024-07-30T16:44:31.767218", "image_code": "//----------image\n//por jorge2017a2-\n//show house- v2-13-jun-2022\n//referencia\n//https://iquilezles.org/articles/distfunctions/\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n#define PI 3.14159265\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n { float c = cos(phi);float s = sin(phi); return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);}\nvec3 rotate_y(vec3 p, float phi)\n { float c = cos(phi);float s = sin(phi);\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);}\nvec3 rotate_z(vec3 p, float phi)\n {float c = cos(phi); float s = sin(phi);return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);}\n\nvec2 techoInclinadoA(vec3 p)\n{  vec2 res= vec2(9999.0, -1.0);\n    p.y-=9.0; vec3 p0=p;\n    vec3 p1= rotate_z(p, radians(45.0));\n    float d1a= sdBox(p1,vec3(10.0,10.0,5.5) );  //techo triangulo\n    float d1b= sdBox(p-vec3(0.0,-10.0,0.),vec3(14.0,10.0,7.0) );\n    d1a= Difference(d1a, d1b);\n    res =opU2(res, vec2(d1a,9.0));\n    return res;\n}\n\nvec2 casa01(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n     p.y=p.y-12.0;\n    float d1a= sdBox( p, vec3(12.0,10.0,5.0) );\n    float d1b= sdBox( p-vec3(0.0,-5.0,-5.0), vec3(3.5,5.0,1.0) ); //puerta-marco\n    float d1c= sdBox( p-vec3(0.0,-5.25,-5.0), vec3(3.0,5.0,1.5) ); //puerta\n    float d1d= sdBox( p-vec3(0.0,-5.25,-5.0), vec3(3.0,5.0,0.5) ); //fondo puerta\n    d1a= Difference(d1a, d1c);//hueco casa\n    d1b= Difference(d1b, d1c); //puerta\n    vec2 ti1 =techoInclinadoA(p);\n    res =opU2(res, vec2(d1a,1.0));\n    res =opU2(res, vec2(d1b,8.0));\n    res =opU2(res, vec2(d1d,7.0));\n    res =opU2(res, ti1);\n    return res;\n}\n\nvec2 opScaleCasa02( vec3 p, vec3 s, int opc)\n{\tvec2 res= vec2(9999.0, -1.0);  \n    vec2 c1= casa01(p/s);\n    if (opc==1) c1.x*=s.x;\n    if (opc==2) c1.x*=s.y;\n    if (opc==3) c1.x*=s.z;    \n    res =opU2(res, c1);\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{  vec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n   p.x=opRep1D( p.x, 42.0 );\n   p.z=opRep1D( p.z, 30.0 );\n   \n   \n   float d1= sdBox( p-vec3(0.0,0.0,0.0), vec3(25.0,3.0,10.0) );\n   \n   p.x=abs(p.x)-15.0;\n   vec2 c1= opScaleCasa02(p,vec3(0.35,1.25,1.0),1);\n   vec2 c2= opScaleCasa02(p0,vec3(0.75,0.8,1.0),1);\n   vec2 c3= opScaleCasa02(p0-vec3(0.0,20.0,0.0),vec3(0.45,0.8,0.8),1);\n   res =opU2(res, c1);\n   res =opU2(res, c2);\n   res =opU2(res, c3);\n   res =opU2(res, vec2(d1,57.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n    if (id_color==0)  { colobj=vec3(0,0,0);  return colobj; }\n    if (id_color==1)  { colobj=vec3(1.,1.,1.);  return colobj; }\n    if (id_color==2)  { colobj=vec3(1,0,0);  return colobj; }\n    if (id_color==3)  { colobj=vec3(0,1,0);  return colobj; }\n    if (id_color==4)  { colobj=vec3(0,0,1);  return colobj; }\n    if (id_color==5)  { colobj=vec3(1,1,0);  return colobj; }\n    if (id_color==6)  { colobj=vec3(0,1,1);  return colobj; } \n    if (id_color==7)  { colobj=vec3(1,0,1);  return colobj; }\n    if (id_color==8)  { colobj=vec3(0.7529,0.7529,0.7529);  return colobj; }\n    if (id_color==9)  { colobj=vec3(0.5,0.5,0.5);  return colobj; }\n    if (id_color==10) { colobj=vec3(0.5,0,0);  return colobj; }\n      if (id_color==57) {return pattern( p.xz );}\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=22.0*abs(sin(iTime*0.5));\n \tlight_pos1= vec3(-10.0, 120.0, -25.+t); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, 55.0 +t); light_color2 =vec3(0.5 ); \n   vec3 ro=vec3(0.0,12.0,-40.0);\n   ro.y+=t;\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   light_pos1+=ro;\n   light_pos2+=ro;\n    vec3 col= Render( ro,  rd);    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dycRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[577, 577, 609, 609, 693], [694, 694, 738, 738, 765], [766, 766, 806, 806, 833], [834, 834, 879, 879, 907], [909, 909, 945, 945, 990], [992, 1017, 1052, 1052, 1140], [1141, 1141, 1176, 1176, 1264], [1265, 1265, 1300, 1300, 1387], [1389, 1389, 1419, 1419, 1731], [1733, 1733, 1754, 1754, 2367], [2369, 2369, 2415, 2415, 2600], [2602, 2602, 2627, 2627, 3122], [3124, 3124, 3148, 3148, 3310], [3312, 3312, 3360, 3360, 3639], [3642, 3642, 3686, 3686, 4007], [4009, 4009, 4046, 4046, 4303], [4305, 4305, 4328, 4328, 4473], [4475, 4475, 4565, 4565, 5523], [5526, 5526, 5558, 5558, 5755], [5757, 5805, 5833, 5833, 6021], [6023, 6023, 6093, 6093, 6877], [6879, 6879, 6906, 6906, 6995], [6997, 6997, 7055, 7055, 7103], [7105, 7105, 7128, 7128, 7240], [7242, 7242, 7273, 7273, 7911], [7913, 7913, 7970, 7970, 8411]]}
{"id": "sddcDj", "name": "TRPBG", "author": "Jormala", "description": "something", "tags": ["spiral"], "likes": 6, "viewed": 295, "published": 3, "date": "1655133325", "time_retrieved": "2024-07-30T16:44:32.568077", "image_code": "#define PI acos(-1.0)\n\n#define ZOOM_SPEED 0.046\n#define SPIKE_SPEED 0.063\n#define TWIST_SPEED 0.057\n#define ROT_SPEED 0.0\n#define SPIKE_SIZE 0.05\n#define SPIKE_SIZE_OFFSET 0.05\n#define SPIKE_SIZE_OFFSET_SPEED 0.03\n#define SPIKE_HEIGHT 0.75\n#define SPIKE_HEIGHT_OFFSET 0.5\n#define SPIKE_HEIGHT_OFFSET_SPEED 0.05\n#define HUE_STEPS 9.0\n#define HUE_STEEPNESS 2.0\n#define HUE_RANGE 0.125\n#define HUE_SPEED 0.023\n\nvec3 hsv(float h, float s, float v)\n{\n    vec3 c = vec3(h, s, v);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat noise(vec2 coord)\n{\n    coord /= iResolution.xx;\n    \n    float p = -1./255./2.;\n    vec2[] aa = vec2[](vec2(-p, -p), vec2(p, -p), vec2(p, p), vec2(-p, p));\n    float c = 0.0;\n    for (int i=0; i<4; i++)\n        c += texture(iChannel0, coord*0.5+aa[i]+iTime*0.01).r/4.;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float spikes = 3.+(sin(iTime*SPIKE_SPEED*PI)*0.5+0.5)*4.;\n    \n    vec2 center = vec2(0.5, 0.5*iResolution.y/iResolution.x);\n    vec2 spiral_center = vec2(0.5, center.y);\n    vec2 uv = (fragCoord/iResolution.xx)-spiral_center;\n    uv *= vec2(exp((0.2+cos(PI*iTime*ZOOM_SPEED))*1.25));\n    \n    float dist = length(uv);// * (sin(iTime)*0.5+0.5);\n    float a = (dist+1.0)*2.*PI*sin(iTime*TWIST_SPEED)+iTime*ROT_SPEED;\n    uv = uv*mat2(cos(a), -sin(a), sin(a), cos(a));\n    \n    float ang = acos(clamp(uv.x/dist, -1., 1.))+PI;\n    \n    float spike_size = SPIKE_SIZE+(sin(iTime*PI*SPIKE_SIZE_OFFSET_SPEED)*0.5+0.5)*SPIKE_SIZE_OFFSET;\n    float d = dist + abs(mod(ang/PI*spikes, 2.)-1.)*spike_size;\n    \n    //d *= -5.;\n    //d = clamp(d, 0., center.y)/center.y;\n    \n    float height = 2.0*center.y*(SPIKE_HEIGHT+( sin(iTime*PI*SPIKE_HEIGHT_OFFSET_SPEED)*0.5+0.5 )*SPIKE_HEIGHT_OFFSET);\n    \n    float v = abs(mod(d+iTime*0.001, height*2.0)-height)/height;\n    v = v*0.3+0.6;\n    v = sqrt(v*v);\n    \n    float h = abs(mod(d, height*2.0)-height)/height;\n    \n    //d = 1.-d*d;\n    h = sin(HUE_STEPS*h*PI)*HUE_STEEPNESS/(HUE_STEPS*PI)+h;\n    h = h*HUE_RANGE-iTime*HUE_SPEED;\n    \n    vec3 col = hsv(h, sin(ang*2.+iTime*2.)*0.2+0.8, v);//noise(fragCoord)*0.25+0.6);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddcDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 445, 445, 642], [942, 942, 999, 999, 2301]]}
{"id": "NtBczw", "name": "The Werner Projection", "author": "mla", "description": "The Werner projection, described by Johannes Werner in the early 16th century, after Stabius and also Ptolemy. Projection is equal area and with correct distances along central meridian and the concentric lines of latitude. Mousable.", "tags": ["projection", "werner"], "likes": 11, "viewed": 305, "published": 3, "date": "1655117925", "time_retrieved": "2024-07-30T16:44:34.093000", "image_code": "const float PI = 3.14159;\nconst float TWOPI = 2.0*PI;\nfloat WIDTH = 512.0;\nfloat HEIGHT = 256.0;\n\nfloat cot(float x) { return 1.0/tan(x); }\nfloat sqr(float x) { return x*x; }\n\nvec2 werner(float x, float y) {\n  float r = length(vec2(x,y)); // Concentric circles\n  float theta = atan(x,-y);\n  float phi = 0.5*PI - r; // Colatitude is distance from pole\n  float lambda = r * theta/cos(phi);\n  return vec2(phi,lambda);\n}\n\nvec2 bonne(float x, float y) {\n  float p = 0.3*PI, cotp = 1.0/tan(p);\n  float rho = sqrt(sqr(x) + sqr(cotp - y));\n  float phi,lambda;\n  if (p > 0.0) {\n    phi = cotp + p - rho;\n    lambda = rho * atan(x, cotp - y)/cos(phi);\n  } else if (p < 0.0) {\n    phi = cotp + p + rho;\n    lambda = rho * atan(x, y - cotp)/cos(phi);\n  } else {\n    // Degenerate case - the sinusoidal projection\n    phi = y;\n    lambda = x/cos(phi);\n  }\n  return vec2(phi,lambda);\n}\n\nvec3 sphere(float phi, float lambda) {\n  float y = sin(phi);\n  float x = cos(phi)*cos(lambda);\n  float z = cos(phi)*sin(lambda);\n  return vec3(x,y,z);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nvec3 getcol(float phi, float lambda) {\n  vec3 p = sphere(phi,lambda);\n  if (WIDTH <= iResolution.x) p.zx = rotate(p.zx,0.1*PI*iTime);\n  if (iMouse.z > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  lambda = atan(p.z,p.x);\n  phi = asin(p.y);\n#if 0\n  vec3 col = texture(iChannel1,p).xyz; // Cubemap\n#elif 0\n  vec3 col = texture(iChannel0,vec2(0.5+lambda/TWOPI,0.5+phi/PI)).xyz;\n#else\n  float u = 0.5+lambda/TWOPI;\n  float v = 0.5+phi/PI;\n  v = 1.0-v;\n  u *= WIDTH/iResolution.x;\n  v *= HEIGHT/iResolution.y;\n  vec3 col = texture(iChannel2,vec2(u,v)).xyz;\n  col = pow(col,vec3(0.5));\n#endif\n  if (true) {\n    // Draw grid lines\n    phi *= 12.0/PI;\n    vec3 lcol = vec3(0.2);\n    lambda *= 12.0/PI;\n    col = mix(lcol,col,smoothstep(0.0,fwidth(lambda),abs(lambda-round(lambda))));\n    //if (round(phi) == 0.0) lcol = vec3(0.8,0,0);\n    col = mix(lcol,col,smoothstep(0.0,fwidth(phi),abs(phi-round(phi))));\n  }\n  return col;\n}\n  \nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    vec2 uv = 2.1*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv.y -= 1.1;\n    float x = uv.x, y = uv.y;\n    vec2 latlong = werner(x,y);\n    float phi = latlong.x, lambda = latlong.y;\n    vec3 col = getcol(phi,lambda);\n    // Smooth out the edges - this does produce an annoying\n    // halo further out where the fwidths go awry.\n    col *= 1.0-smoothstep(0.0,fwidth(lambda),abs(lambda)-PI);\n    col *= 1.0-smoothstep(0.0,fwidth(phi),abs(phi)-0.5*PI);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 16 color GIF, cropped, run length encoded and packed into an array of uvec4s\n// Upper 4 bits of each byte is the runlength-1 (we don't need 0 length runs,\n// obviously), lower 4 bits is the color index.\n//\n// Original image by NASA.\n//\n// Does basic coloring here rather than in Image tab to get the benefit\n// of texture filtering.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst uvec4 data[] = uvec4[](\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf07110f0u,0x023120f0u),\nuvec4(0x13010211u,0x45360514u,0xf0110334u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f040f0u),\nuvec4(0xf0f0f0f0u,0x1140f0f0u,0x15040320u,0x64d60506u),\nuvec4(0x3102d021u,0x05262402u,0x66f60506u,0xf0021405u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x031201c0u,0x05360524u),\nuvec4(0x25c60506u,0x03040576u,0x36051422u,0x04050304u),\nuvec4(0x05360403u,0x15f61304u,0x02044524u,0x00012401u),\nuvec4(0x01200102u,0x11120312u,0xf0f0f0f0u,0x1130f0f0u),\nuvec4(0xf0f01130u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f050u),\nuvec4(0xf0f0f0f0u,0x03020170u,0x04110204u,0x04052605u),\nuvec4(0xb6356605u,0x01121405u,0xf6f60322u,0x030456f6u),\nuvec4(0x04058604u,0xf0f00103u,0x80f0f0f0u,0x02114001u),\nuvec4(0x01020304u,0x11101100u,0xf0f00102u,0x01202110u),\nuvec4(0xf0010302u,0xf0f0f0f0u,0xf060f0f0u,0xf0f0f0f0u),\nuvec4(0x0150f0f0u,0x04460504u,0x12040312u,0x05540224u),\nuvec4(0x020405a6u,0xf6040311u,0x16f6f6f6u,0x04050405u),\nuvec4(0xf0f00102u,0x101100f0u,0xf0010011u,0x330201c0u),\nuvec4(0x00010304u,0x03241221u,0x00032401u,0x30f00112u),\nuvec4(0x0100f001u,0xf0015604u,0xf0f0f0f0u,0xf040f0f0u),\nuvec4(0xf0f0f0f0u,0x0100f0f0u,0x01100102u,0x46051402u),\nuvec4(0x12012204u,0x04131807u,0x24154605u,0x21401203u),\nuvec4(0xf6f6f603u,0x040215d6u,0x70f0f002u,0x01020301u),\nuvec4(0x02000109u,0x04030214u,0x01046615u,0x2011b0f0u),\nuvec4(0x30010001u,0xf0110021u,0x0201b0f0u,0x05040214u),\nuvec4(0x05041504u,0xf0f00104u,0xf0f0f0f0u,0xf0f000f0u),\nuvec4(0xf0f0f0f0u,0x05140180u,0x11701204u,0x05140322u),\nuvec4(0x120a4206u,0x16040207u,0x22031405u,0x05023160u),\nuvec4(0xe6f6f6f6u,0x00020405u,0x70f0f002u,0x06050201u),\nuvec4(0x02030405u,0x03042604u,0x11022102u,0xf0f0f0f0u),\nuvec4(0x0210f0f0u,0x06040224u,0x14020105u,0xf0f01112u),\nuvec4(0xf0f0f0f0u,0xf0f0f090u,0x02e0f0f0u,0x04050403u),\nuvec4(0x13014002u,0x02280204u,0x22070400u,0x03020110u),\nuvec4(0x0b112204u,0x04030402u,0x05660312u,0x01100104u),\nuvec4(0xf6f61544u,0x0406f6f6u,0xf0010311u,0x031190f0u),\nuvec4(0x12010a04u,0x01031604u,0xf0020402u,0xf0f0f0f0u),\nuvec4(0x0201c0f0u,0x11002435u,0xf0f0f0f0u,0xf060f0f0u),\nuvec4(0xf0f0f0f0u,0x01001180u,0x15040103u,0x02400104u),\nuvec4(0x00112001u,0x12111011u,0x09300201u,0x03220b20u),\nuvec4(0x07030b02u,0x50010246u,0x14031201u,0xf6f61405u),\nuvec4(0x2203e6f6u,0xf0f00100u,0x031209b0u,0x01040504u),\nuvec4(0x14030220u,0xf0f0f001u,0xe0f0f0f0u,0xf0110211u),\nuvec4(0xf0f0f0f0u,0xf0f080f0u,0x30f0f0f0u,0x04030201u),\nuvec4(0x00011807u,0x30114011u,0x20113011u,0x03140201u),\nuvec4(0x02212002u,0x0c050304u,0x0c171415u,0x01140605u),\nuvec4(0x25140380u,0xf6f6f604u,0x220304d6u,0xd0f0f004u),\nuvec4(0x06040201u,0xf0f0f003u,0x130140f0u,0x40f0f002u),\nuvec4(0x40110201u,0x0803020bu,0x01001132u,0xf0f01100u),\nuvec4(0xf0f0f0f0u,0xf0f0f000u,0x4200f0f0u,0x1102010bu),\nuvec4(0x01102122u,0x00010307u,0x05031001u,0x04050104u),\nuvec4(0x01051605u,0x03240100u,0x03040516u,0x51030231u),\nuvec4(0xb0010214u,0x15060301u,0x03140504u,0xf6f6f614u),\nuvec4(0x01120466u,0xf0f00100u,0xf0f0f0f0u,0x142311e0u),\nuvec4(0x04051605u,0x20f0f003u,0x02112211u,0x121b022bu),\nuvec4(0x13020708u,0xf0014217u,0x200920f0u,0xf0f0f001u),\nuvec4(0xf0f0f050u,0x0160f0f0u,0x05081200u,0x0b081704u),\nuvec4(0x07081201u,0x00020708u,0x05041321u,0x02010c16u),\nuvec4(0x01050403u,0x05260200u,0x04220413u,0x02141615u),\nuvec4(0x0301b0f0u,0x26f6f6f6u,0x00010224u,0xf0f0f001u),\nuvec4(0x90f0f0f0u,0x36050201u,0xf0011214u,0x11900160u),\nuvec4(0x12080722u,0x3208721bu,0xf01b7208u,0x4b0001e0u),\nuvec4(0x0a020605u,0x09100a0bu,0xf0e0f0f0u,0xf0f0f0f0u),\nuvec4(0x3b1221a0u,0x40011041u,0x01020102u,0x05040100u),\nuvec4(0x15010016u,0x460c0416u,0x05260405u,0x01d0f001u),\nuvec4(0xf6f6f603u,0x12040506u,0xf0f0f021u,0x70f0f0f0u),\nuvec4(0x14260401u,0x20f0f001u,0x08328b01u,0xab321b42u),\nuvec4(0xf0f0010au,0x03022a20u,0x09300122u,0x90f0f03au),\nuvec4(0xf0f0f0f0u,0x1b022be0u,0x0112010au,0x020180f0u),\nuvec4(0x12011001u,0x20210203u,0x80f0f021u,0xf6f60501u),\nuvec4(0x221504b6u,0xf0f0f011u,0x80f0f0f0u,0x01022401u),\nuvec4(0x0940f0f0u,0x38026b0au,0x6b222b12u,0x090a4b02u),\nuvec4(0xf0f01a0du,0xf0f00960u,0xf0f060f0u,0x6be0f0f0u),\nuvec4(0x70110b42u,0x20012411u,0x13270201u,0x0c052611u),\nuvec4(0x01100405u,0x02041504u,0x07040201u,0x01440203u),\nuvec4(0x0501c0f0u,0x0556f6f6u,0x010a4224u,0xf0f0f0f0u),\nuvec4(0x0980f0f0u,0x01021302u,0x501110f0u,0x0a094009u),\nuvec4(0x8b527bfbu,0x3b1a4b0au,0x0a40091au,0xf0291a1bu),\nuvec4(0x0a1b0900u,0x30f0f0f0u,0xf0f0f0f0u,0x0b12dbd0u),\nuvec4(0x01121112u,0x20011817u,0x02010203u,0x020b0218u),\nuvec4(0x0a081301u,0x02100102u,0x00041506u,0x11270822u),\nuvec4(0x02040312u,0x09a0f001u,0xf6f6030au,0x03140546u),\nuvec4(0xf0020b22u,0xf0f0f0f0u,0x080b90f0u,0xf00a0304u),\nuvec4(0x0a2b0a10u,0x30191009u,0xfbfb1009u,0x4b0a8bfbu),\nuvec4(0x1d0a0b1au,0xf049e009u,0xf020f0f0u,0xc0f0f0f0u),\nuvec4(0x01223b01u,0x08024b00u,0x01022832u,0x400b0218u),\nuvec4(0x07020b09u,0x0b010b18u,0x05400103u,0x0a01151cu),\nuvec4(0x0827020bu,0x05160432u,0x90f00104u,0x04020b0au),\nuvec4(0x1516f6f6u,0x12240504u,0xf0f0f001u,0x70f0f0f0u),\nuvec4(0xf0320a09u,0x094b0910u,0x0b0a0900u,0x0b022b0au),\nuvec4(0x0a00090au,0x5bfb023bu,0xfb025b3au,0x0d1b027bu),\nuvec4(0x7b0ac009u,0xf01a2b0au,0x0a1ba0f0u,0xf0f0f0f0u),\nuvec4(0x20112bc0u,0x08222b0au,0x0b121802u,0x500a1b22u),\nuvec4(0x00010201u,0x1b020b01u,0x04023002u,0x021a0827u),\nuvec4(0x02081718u,0x04020348u,0xf0021402u,0x02112950u),\nuvec4(0x0305f6f6u,0x04182214u,0xf0f0f0f0u,0x0980f0f0u),\nuvec4(0xe00a2b0au,0x095b0a01u,0x090abb0au,0x0a1e9aebu),\nuvec4(0x0acb120bu,0x0e2b0e3bu,0x096b022bu,0x5d1a0b20u),\nuvec4(0x0b0a0d0eu,0x3e0a6b1au,0x60f0f009u,0x09b0f00au),\nuvec4(0x097a090au,0x0900f0f0u,0x4b0a01d0u,0x1b220b12u),\nuvec4(0x010a3b02u,0x02080170u,0x010b020bu,0x2b420b30u),\nuvec4(0x0b0a3b02u,0x07080712u,0x03341304u,0x0a30f001u),\nuvec4(0xe6f60221u,0x12040204u,0x040b0a10u,0xf0f0f001u),\nuvec4(0x090a29d0u,0x0a0b090au,0xf0f00a0bu,0x012a0110u),\nuvec4(0x098b01b0u,0xbb1dab0au,0xfb1a7e0au,0x0a0e4a0bu),\nuvec4(0x0aab0a7eu,0x2e2b0e1bu,0x4b4afb2au,0xc0f00a0du),\nuvec4(0x1a0970f0u,0x3a8b2a9bu,0x0e59c009u,0x0a100a0bu),\nuvec4(0x08220b90u,0x20011bfbu,0x015b0011u,0x0b0a2150u),\nuvec4(0x1a010a01u,0x2b0a011bu,0x05060502u,0x12240203u),\nuvec4(0x120b10f0u,0x040b010au,0x0514d6f6u,0x01030526u),\nuvec4(0x90f0f0f0u,0x0b0e1a49u,0x2e0a1b0au,0x0900090au),\nuvec4(0x0940f0f0u,0x0a80090au,0x0a3b0a0bu,0x0a1b090du),\nuvec4(0x1e1a1e8bu,0x4b0e9b2au,0x0efedb22u,0x1b0e1d0au),\nuvec4(0x2b0a0b0au,0x1e1bfb0au,0x0b0aeb0du,0x090aa009u),\nuvec4(0x010a0900u,0x60f04059u,0x0a7bfb09u,0x2a190a8bu),\nuvec4(0x0e1d0a3du,0x1a1b0e0au,0x122b0a0bu,0x10090a0bu),\nuvec4(0x7b1a0b01u,0x4b0a091au,0x193b0a31u,0x091b1a0bu),\nuvec4(0x01300100u,0x101b021bu,0x0b010a11u,0x0b023b1au),\nuvec4(0x02140702u,0x0910f001u,0x02011001u,0x0516f6f6u),\nuvec4(0xf0f00103u,0x2d0990f0u,0x4d5e2b0au,0x10f0393eu),\nuvec4(0x0ae00a0bu,0x30090a3bu,0x1e0a0b1au,0x091a0009u),\nuvec4(0x1b4e8b1au,0x0d0a0e0au,0xab1afb0au,0x0b2a2e1au),\nuvec4(0x3e1d5e0au,0x0d0a5b0au,0x0d1ecb2eu,0x0d1e0b1eu),\nuvec4(0x3d7e0d0eu,0x10090a8bu,0x1b090aabu,0xfb0af009u),\nuvec4(0x0a9b3abbu,0x1d0e0d0eu,0x124b8d0eu,0x0a0b025bu),\nuvec4(0x3a392a09u,0x00091019u,0x0a090019u,0x0a191a0bu),\nuvec4(0x021b0a3bu,0x091b3220u,0x0a010031u,0x024b1a01u),\nuvec4(0x20f00123u,0x86f60b29u,0x04152605u,0xf0010203u),\nuvec4(0x0990f0f0u,0x6e3a091du,0x801a3ebdu,0x0a197019u),\nuvec4(0x0a0d1e2du,0x0a0e1d0eu,0x00090a6bu,0x2a0b0a0eu),\nuvec4(0x1b0a0009u,0x2a0e0b19u,0x0a0e0a1bu,0x0b0e0d0eu),\nuvec4(0x3a3d0e0au,0x0a2b0a2bu,0x0d0e0d1eu,0x0a5b1a4eu),\nuvec4(0x1d5e1a4eu,0x4b0a0d3eu,0x4d9e6b6eu,0x0d1e5d0eu),\nuvec4(0x4bfb0a2eu,0x094b2b02u,0x0b0a09e0u,0x2e7aab0au),\nuvec4(0x2e1d2e0au,0x0b1a1e1du,0xab0a0dfdu,0x1910190au),\nuvec4(0x0900090au,0x2b6a4b0au,0x0b026b1au,0x0b0a000au),\nuvec4(0x510a2b12u,0x0b020b12u,0x122b0a01u,0x02041507u),\nuvec4(0x023ae011u,0x210476f6u,0xf0f0f0f0u,0x1b1a0d09u),\nuvec4(0x4e6dfd0eu,0x2e40090du,0x4e191009u,0x3e0a8e0du),\nuvec4(0x0e5a0e4bu,0x0b0a0009u,0x0d090a0eu,0x0b3e1a0eu),\nuvec4(0x090e0d1eu,0x1a0b0e0du,0x0e0a0b2eu,0x0e0a1b0au),\nuvec4(0x0e0a0e0au,0xbb2a2e0du,0x6e0a1e0au,0x0a1d3e0du),\nuvec4(0x3e1a2e2bu,0x1e0a0e4bu,0x3e0d0e0du,0x0e0a0e0au),\nuvec4(0x2e2d2e0du,0x0e0a0b0au,0x2b1a0e0au,0x0802db0au),\nuvec4(0x096b1b02u,0x4ac00900u,0x2a1e0a1eu,0xfd0a5d0eu),\nuvec4(0x09cd0b1du,0x0a6b6a3du,0x0b0a095bu,0x0a8bfb1au),\nuvec4(0x0140016bu,0x0a1b311au,0x0c04220bu,0x0a020406u),\nuvec4(0x1b09a011u,0xf6020b0au,0xf0f00266u,0x0920f0f0u),\nuvec4(0xfd0e3b0du,0x3e6d092du,0x1d092009u,0x4b6efe29u),\nuvec4(0x0d3e0d0eu,0x1b1a0009u,0x0d2e0d0eu,0x0a9e0d7eu),\nuvec4(0x0b0a0b2eu,0x2b2e1a7eu,0x0b0a0b1au,0x3e0d6e5au),\nuvec4(0x0a1b0a1du,0x0a0e1a2eu,0x1a9e4b2eu,0x4e0a5e0bu),\nuvec4(0x02eb8e0bu,0x1b024b3bu,0x50093b0au,0x0d200a19u),\nuvec4(0x1b0a1e0au,0x1e0d1e0au,0x1e5d2e0du,0x0b3d1e4du),\nuvec4(0x1039dd1eu,0x5b5a0e39u,0xfb1a3b1au,0x0a2b0a2bu),\nuvec4(0x601a0b09u,0x1b110029u,0x01000b02u,0x0304034au),\nuvec4(0xa0010314u,0x0b12030bu,0x0504f605u,0xe0011406u),\nuvec4(0x09700109u,0x0970f0f0u,0x4dfd0e3bu,0x10090d09u),\nuvec4(0x10094d19u,0x5e5d1009u,0x5e0d2e0du,0x0a0b1e1du),\nuvec4(0x0d098d0eu,0x1b0e1b0eu,0x4e0d4e0du,0x4a7efe2du),\nuvec4(0x1aae0a6bu,0x0d3e0d0eu,0x0a3e2b0au,0x0a1e0a0bu),\nuvec4(0x2a2e0a4bu,0x1b6e0a8eu,0x0b2e0b2eu,0x022bfb0eu),\nuvec4(0x01ab000au,0x1a5b0a20u,0x7e0d0e3bu,0x3e3d0e0au),\nuvec4(0x0e3d0e0du,0x4e2d2e0bu,0x6d1930cdu,0xbb2acb4au),\nuvec4(0x010a1b1au,0x1960210bu,0x021b0221u,0x0b201a3bu),\nuvec4(0x01020302u,0x13040ab0u,0x2205e605u,0x0a00f001u),\nuvec4(0x1a000a1bu,0xf0f0095bu,0x0e0a0940u,0x298d1e0au),\nuvec4(0x092d099du,0xadfd0960u,0x8d0b0a2eu,0x0d1e1d2eu),\nuvec4(0x1d4e1d1eu,0x2d0e0d3eu,0x2e1a1efeu,0x2b4a0e2au),\nuvec4(0x3e0dce0au,0x0a2b0a1du,0x0b0a0b0eu,0x4b0a1e1au),\nuvec4(0x9e4b0e2au,0x1e0a1e1bu,0x509bfb1au,0x700b022bu),\nuvec4(0x0e0a1e5bu,0x3e1d0e0au,0x3d0a0ecdu,0x7b1a6b0eu),\nuvec4(0x1d395d0au,0x5b7a6d09u,0x8b3a5b1au,0x0b000b0au),\nuvec4(0x010b0208u,0x024b0a60u,0x0a090b08u,0x0109204bu),\nuvec4(0x021b09e0u,0xf00104c6u,0x1b0e0960u,0x22080b02u),\nuvec4(0xf0f0092bu,0x2a0d0920u,0x30097d0eu,0x6009cd09u),\nuvec4(0x0b0eadfdu,0x0e7d0e0au,0x0e1d1e1du,0x0e4d0e0du),\nuvec4(0x4e2d1e0du,0x0efefe2du,0x0e1ade0au,0x0e9b4e0du),\nuvec4(0x0a2b0e3bu,0x3b022b0du,0x1ecb1efeu,0x09700a9bu),\nuvec4(0x1980090au,0x0e100910u,0x0d0e0a0bu,0x0a1dfd0eu),\nuvec4(0x1e0d5e5du,0x1d0e7b0au,0x5d0efd0eu,0x0b8a6b2au),\nuvec4(0x100a5b0au,0x01400a5bu,0x2b0a291au,0x04123b02u),\nuvec4(0x2a10f001u,0xf003b604u,0x0b0e0980u,0x05020b02u),\nuvec4(0xf00a0416u,0x0e2d30f0u,0x093d30adu,0xfd2009adu),\nuvec4(0x1e2d0eddu,0x0e2d0e0du,0x0dfd1e1du,0xfefe6d2eu),\nuvec4(0x1e1d2efeu,0x2a0d3e0au,0x2e6b1a0bu,0x1e4b1e0au),\nuvec4(0x8b0d7e0au,0x5b1e7b0eu,0x100e1b0eu,0x295019b0u),\nuvec4(0xbd1e2900u,0x0e0a0b0eu,0x020b120bu,0x0a1dfd0eu),\nuvec4(0x7dfd3e5bu,0x0e2a4b1eu,0x30097a3du,0x0802090au),\nuvec4(0x020a100au,0x1b0aa001u,0x021a0b02u,0x0102070bu),\nuvec4(0x040210f0u,0x01159605u,0x0a09a0f0u,0xf0090a02u),\nuvec4(0x0d1940f0u,0x2009bd09u,0x090d09edu,0xfdfdfdfdu),\nuvec4(0xfe2d5efdu,0x0d5efefeu,0x2b2e3b2eu,0x1e0a4b0eu),\nuvec4(0x1edb5e0au,0xd00009ebu,0x0b094009u,0x0d2e3b0eu),\nuvec4(0x030b5d1eu,0x0a1b0204u,0x1b0e0a0eu,0x0e1dfd1eu),\nuvec4(0xbd0e4b0au,0x1d195d0eu,0x09004e3au,0x090e090du),\nuvec4(0x0a0d3a2du,0x0b019009u,0x1b0a09e0u,0x09010b02u),\nuvec4(0x30f00b01u,0x0486040au,0xf0f0f002u,0x1d0940f0u),\nuvec4(0x6d3e0d0eu,0x3d0e1d30u,0x1d090d09u,0xfd095d09u),\nuvec4(0x0dfdfdfdu,0xad1e2d0eu,0xfe2d8efeu,0x2b2d2efeu),\nuvec4(0x0b2e0b0eu,0x0b7e0a3eu,0x0a3b0e0au,0x0a2b0a0bu),\nuvec4(0x0e1d0e0bu,0x007b0e6bu,0x0a0920f0u,0x4d6e0b1eu),\nuvec4(0x0a0b0a0bu,0x020a1d0eu,0x0b2d0e0bu,0x0ead0e22u),\nuvec4(0x0a5b0e3du,0x0e0d0e5du,0x1d190e2du,0x0b2e3d29u),\nuvec4(0x5d0a2d0au,0x0d0e2d0eu,0x010ab009u,0x1b100b20u),\nuvec4(0x091a091au,0x120a0940u,0x0b0150f0u,0xf0057605u),\nuvec4(0x0910f0f0u,0x0d0900f0u,0x407d2e3bu,0x095d299du),\nuvec4(0x7d090d00u,0x6dfdfd0eu,0xfd090d09u,0x0d5efefdu),\nuvec4(0x2d3efefeu,0x4b021b0au,0x0e1a4bceu,0x09000e2bu),\nuvec4(0x2b0e7b2eu,0x0920090au,0x0920f000u,0x0d0e0b3eu),\nuvec4(0x0d0e2d3eu,0x0e04120bu,0x030b0e1du,0x0b1a0b14u),\nuvec4(0x0b020312u,0x0e0d0b1du,0x1e0d2e2du,0x0e0b1a0du),\nuvec4(0x09bd0a1du,0x0e0a0900u,0x1e4d1eedu,0x20f0091du),\nuvec4(0x7b0d1009u,0x50f00180u,0x0526020au,0xf0f00426u),\nuvec4(0x1d20f0f0u,0x1e0b120bu,0x0940098du,0x290d194du),\nuvec4(0x093d100du,0xfdfdfd10u,0xfe6dfdfdu,0x1abefefeu),\nuvec4(0x9e0b0e5bu,0x20090a2bu,0x0d0b0a09u,0x1b0a0009u),\nuvec4(0x0a1b1a4eu,0x20f08009u,0x1e1b5e19u,0x04023e1du),\nuvec4(0x0a1d0a0bu,0x09010a04u,0x23020402u,0x0b031514u),\nuvec4(0x4d1e0d0eu,0xbd0e7d0eu,0xcd0e0d09u,0x0a1e3d09u),\nuvec4(0x0d2e1d0eu,0x9b0a60f0u,0x09d0f00au,0x0a090b01u),\nuvec4(0xf0040604u,0x30f0f0f0u,0xbd1b1e0du,0x0e1d4009u),\nuvec4(0xfdfd309du,0xfdfd0e7du,0x1efe3dfdu,0xfe4d0e1du),\nuvec4(0x0a1e0afeu,0x0b1e0a7eu,0x50095b0eu,0x0e09100au),\nuvec4(0x090a7e1bu,0x0900f0a0u,0x3e190b0au,0x120d5e3bu),\nuvec4(0x0b041a00u,0x19200904u,0x0514120bu,0x3b040604u),\nuvec4(0xfdfd0e4du,0x092d097du,0xf00d3e0du,0x5b1a1b80u),\nuvec4(0xf019500au,0xf0120aa0u,0x30f0f0f0u,0x0a1b0d09u),\nuvec4(0x090009ddu,0x191d1900u,0x000d1940u,0xfd096d09u),\nuvec4(0x0e8dfdfdu,0x0d0e3dfdu,0x1d0e5d0eu,0x7dae0d1eu),\nuvec4(0x0d0e1d1eu,0x0abefefeu,0x2e900d1eu,0x20290e0au),\nuvec4(0x70f0c019u,0x2e0b0a09u,0x190b1e0du,0x0910090du),\nuvec4(0x0309e002u,0x12040304u,0x0e2d0903u,0x09bdfd0au),\nuvec4(0x1eed1900u,0x0d70f00du,0x4b0e0a3eu,0xf0091b50u),\nuvec4(0xf0f0f0f0u,0x0d0900f0u,0x097d0e0au,0x2960095du),\nuvec4(0x1e0d190du,0x0edd1ecdu,0xfdfd0e3du,0x2e8dfdfdu),\nuvec4(0x7efefe7du,0x1910890du,0x70091e0du,0x0e0b0e0du),\nuvec4(0x80f070f0u,0x0d190a09u,0x020b1e2au,0x0350f001u),\nuvec4(0x140b0a04u,0x1d0e1d0bu,0x0a0e1d1eu,0x4e2d1eadu),\nuvec4(0x1e0d0a0du,0x191d0eedu,0x5e0930f0u,0x09102a4bu),\nuvec4(0xf0092b0au,0xf0f0f0f0u,0x4db00930u,0x19001d20u),\nuvec4(0x0960092du,0xad193e0du,0x0d091d0eu,0x3d0e2d0eu),\nuvec4(0x7d3e1d7eu,0xfd0e4d1eu,0x0e6dfdfdu,0xfe8d0e0du),\nuvec4(0x09ce0d8eu,0x0b1e80f0u,0x0900090eu,0xf0f050f0u),\nuvec4(0x090b1a0eu,0x60f00d00u,0x030a190du,0x0e1d0a04u),\nuvec4(0x0d0a0e1du,0x2e9d020au,0x0e1d1e4du,0x1d0a1d0au),\nuvec4(0x50f0cd29u,0x0a1e0d0au,0x4b0a4e4bu,0xf0f0f009u),\nuvec4(0x0009d0f0u,0xe00a0b0du,0x0d094009u,0xa02d091eu),\nuvec4(0x6d1e2d3eu,0x2d4e1d2eu,0x0dce0d1eu,0x1d5e1d1eu),\nuvec4(0xfd1e0d2eu,0x1e2d0eadu,0x1e3d0ecdu,0xce0a2eadu),\nuvec4(0xce1d2e0du,0x0970f00du,0x0e0b1e0du,0xf080f009u),\nuvec4(0x101a0ee0u,0x70f01a0eu,0x0900090du,0x2b030205u),\nuvec4(0x0b2d1e0au,0x0e9d0e8du,0x004d092du,0x0a0d2e8du),\nuvec4(0x1e30f019u,0x1e4b0e0du,0x0e4b1e1du,0xf0f0f009u),\nuvec4(0x0009b0f0u,0xf03e0b09u,0x5d100e09u,0x20091009u),\nuvec4(0x09001d09u,0x3dbe5d7eu,0x0d8e0b3eu,0x0d8e1d3eu),\nuvec4(0x1d0e9d9eu,0x8d0e1d0eu,0xfd0e5d0eu,0x1d5e0d0eu),\nuvec4(0x0dae1a0eu,0xf0090dfeu,0x70f08e70u,0x0b0ac0f0u),\nuvec4(0x19f0f009u,0x03020a0du,0x0a0d0a12u,0x1e5d0a0du),\nuvec4(0x2dfd1e2du,0x7d0e9d19u,0x1e0df009u,0x3b4d5e1du),\nuvec4(0xf0f0090du,0x09d0f0f0u,0x091e0b0eu,0x4d202ee0u),\nuvec4(0x0dae5009u,0x0dce3d1eu,0x0efe4d0eu,0x0d9efe0du),\nuvec4(0x2d5e3d0eu,0x1d0e1d2eu,0x0a5eed4eu,0x0a1e0a3eu),\nuvec4(0x09ae2dbeu,0xf09e80f0u,0x1990f070u,0xf0f00a0bu),\nuvec4(0x0d090d30u,0x0d03020au,0x0b4e8d1au,0x0efd09adu),\nuvec4(0x098009cdu,0x5e5d0920u,0x1e0a1e3du,0xf0f0090du),\nuvec4(0x09c0f0f0u,0xd00a2e0du,0x00091e09u,0x091e0d09u),\nuvec4(0x1e1d9e80u,0x0a2efe2du,0x0dce1b2eu,0x1dbefefeu),\nuvec4(0x0d0e1d4eu,0x7d092d0eu,0x0d1e1d0eu,0x1efe0a1eu),\nuvec4(0xf00a6e5du,0x0b5e0990u,0x80f0090eu,0x001a70f0u),\nuvec4(0x50f0f009u,0x0e190d09u,0xed5ebd1au,0x39adfd19u),\nuvec4(0xad0e0950u,0x1d0e3d0eu,0x091d0e1bu,0xf0f0f0f0u),\nuvec4(0x4e003970u,0x090d1ed0u,0xfeb0090eu,0x6efe1d9eu),\nuvec4(0xfe0d2e0du,0x2b2e0b1eu,0x0a1e2dbeu,0x3d1e3d0eu),\nuvec4(0x0d0e7d3eu,0x0a0d000eu,0x099d8efeu,0x7e0da0f0u),\nuvec4(0x20f00950u,0xf01140f0u,0x1b09e0f0u,0x5edd094du),\nuvec4(0x3dfd0e0du,0x300efd09u,0x4d0e0dfdu,0xf0f06d0eu),\nuvec4(0x3e50f0f0u,0xc00a2e20u,0x0910191eu,0x0e0d0930u),\nuvec4(0xfefe0009u,0x2dbe0a7eu,0xbb1e3b9eu,0x0d0e0b9eu),\nuvec4(0x0b0e0d0eu,0x4e9d0e0au,0x090d1e4du,0x0d5efe00u),\nuvec4(0x5d3e1d1eu,0x0990f019u,0x90f0195eu,0x090a10f0u),\nuvec4(0x0de0f0f0u,0x0a0d0910u,0x0b2efd1bu,0x2d4e2b0au),\nuvec4(0x0d5e0d0eu,0xfd093d0eu,0x0e09300du,0x090d090du),\nuvec4(0x094d29ddu,0xf0f0091du,0x4e20f0f0u,0x1b1e0930u),\nuvec4(0x0b5e1990u,0xfefe090eu,0x1b0e0dfeu,0x0b0e1b1eu),\nuvec4(0x0b0e1d1eu,0xaebbfb0eu,0x0a0b0e2du,0x4d1e3d1eu),\nuvec4(0x0d2e0d3eu,0xfe090009u,0x2d0e4dbeu,0x00090d0eu),\nuvec4(0xf0090e0du,0xf0094e50u,0xf001f0b0u,0x0920f0f0u),\nuvec4(0x020a0920u,0x0b1a7d0au,0xeb1e3d0au,0x0d0e0d0eu),\nuvec4(0x0e8dfd09u,0xfd0e200du,0xf0f009edu,0x0900f0f0u),\nuvec4(0x0900093eu,0x090a1b3eu,0x0dde0d40u,0x8efe0bdeu),\nuvec4(0x0e2a2e0au,0x3b0e1b0au,0xdb0e0d1eu,0x0e1bfb0eu),\nuvec4(0x1e0b1e1au,0x0e0a0b3du,0x5e1d2e8du,0x0900090du),\nuvec4(0x5dcefe1du,0x0d0e1d7eu,0x093e10f0u,0xf0f0c0f0u),\nuvec4(0x0980f0f0u,0x2a7d1a0du,0x4b2e1d1bu,0x3b022b02u),\nuvec4(0xfd0e0d5eu,0x20090e5du,0xf009fdfdu,0x00f0f0f0u),\nuvec4(0x5b1e204eu,0x4e092009u,0x1e0d7e0bu,0x0b6efe4bu),\nuvec4(0x1a8e0b0eu,0x1eab0a1bu,0x7b02bbfbu,0x9d0e0a1eu),\nuvec4(0x0b0e4d0eu,0x2e1d2e0au,0x0a9e1d29u,0x1e0d5efeu),\nuvec4(0x1e0d3e1du,0xf00a0e1du,0x091e0910u,0x0930d0f0u),\nuvec4(0xf0f0f0f0u,0x030a0940u,0x0a8d0a0bu,0x2b0d0a1bu),\nuvec4(0x4b421822u,0xfd4e0d0eu,0xfd00096du,0xf0f019fdu),\nuvec4(0x1e09f0f0u,0x2e093009u,0x09200a3bu,0x0b3e0b4eu),\nuvec4(0x0b3e0d3eu,0x0b0e1b0eu,0x6e3b2efeu,0x12cbfbfbu),\nuvec4(0x0a1b021bu,0x3e2d4e2bu,0x2d0e1b2au,0x1d1e2b1eu),\nuvec4(0x0bbe0d29u,0x2e5d5efeu,0x0e192e0du,0x0910f00du),\nuvec4(0xe0f0090eu,0xf0f0f0f0u,0x0b0a1990u,0x2d1a6d22u),\nuvec4(0x3258121bu,0x0e0d5e4bu,0x6dfd195du,0xcd095d09u),\nuvec4(0x090d1009u,0xf0f0f0f0u,0x0b1e0970u,0x1b0a193eu),\nuvec4(0x0d0e1b1eu,0x0bde0b4eu,0x2b1e0d9eu,0x1b0e0b1eu),\nuvec4(0xfb0e0b0eu,0x922b028bu,0x5e4b32abu,0x0a2b0e2du),\nuvec4(0x0b0e0a0bu,0x1b0e2d0eu,0x1b0a6e0au,0x3b4e0d2eu),\nuvec4(0x0e1d3efeu,0x0e0d3e3du,0x0e0d100du,0x30f0f0f0u),\nuvec4(0xf0f0f0f0u,0x191d0990u,0x7d0a020au,0x020e1d0au),\nuvec4(0x32480208u,0x099d6e6bu,0x2099ddfdu,0xf0f0090du),\nuvec4(0x2970f0f0u,0x5efe3b60u,0x7e0b5e1bu,0x0e0b3e1bu),\nuvec4(0x02ab0e0bu,0x08221bfbu,0x1b527bb2u,0x2b0a0d5eu),\nuvec4(0x020b0812u,0x0e020807u,0x0a1b1e0bu,0x4d1e1b6eu),\nuvec4(0x4b122b1eu,0x3d0e1deeu,0x0d100d5eu,0x09f0090eu),\nuvec4(0xf010f0f0u,0xb0f0f0f0u,0x00090d09u,0x120abd09u),\nuvec4(0x32081228u,0x198d4e8bu,0x7d0e3dfdu,0x09501940u),\nuvec4(0xf009002du,0x90f0f0f0u,0x5b0a0019u,0x0b1e0b3eu),\nuvec4(0x0e1b4efeu,0x1b0a1e4bu,0x1a0e0b0au,0x425b32bbu),\nuvec4(0x22c8321bu,0x522b021bu,0x122b4e2bu,0x18070218u),\nuvec4(0x1b020812u,0x2e0a3b12u,0x1e3d0e1bu,0x3208222bu),\nuvec4(0x2e5dde1bu,0x0e0d104du,0xf0f0f00du,0xf0f0f020u),\nuvec4(0x0d09d0f0u,0x6d0a4d09u,0x7b22680au,0x1d1e3b0eu),\nuvec4(0x3d197d0eu,0x0d2e2d0eu,0x0910bd0eu,0x1d70092du),\nuvec4(0xf0092d0eu,0x60f0f0f0u,0x8b090009u,0x2b1e0dbeu),\nuvec4(0x0d3e1d1eu,0x3b0e1b1eu,0x1a0e0b1eu,0x02bb0e3bu),\nuvec4(0x0738e228u,0x0a4bd2b8u,0x281b0a0eu,0x0b220867u),\nuvec4(0x0b027b02u,0x3b2e0d0eu,0x18023802u,0x2dde0b12u),\nuvec4(0x10093d5eu,0xf0f0f00du,0xf0f0f040u,0x2d29e0f0u),\nuvec4(0x5d0e0d1bu,0x0817080bu,0x8b220812u,0x0d1e2b0au),\nuvec4(0x7d404d1eu,0xad0e0d1eu,0x70193d09u,0x0e3d0e0du),\nuvec4(0xf0f0f00du,0xcb0940f0u,0x0b3e3bfeu,0x3b0e1d1eu),\nuvec4(0x0a1bfb1eu,0x0288023bu,0x02c85788u,0x121b5258u),\nuvec4(0x022b0208u,0x07080718u,0x6b121715u,0x2b1e1b32u),\nuvec4(0x0b027832u,0xfe2b0a2eu,0x0d20093du,0x40f0f0f0u),\nuvec4(0xf0f0f0f0u,0x124d09e0u,0x2d0b0208u,0x020e0d0bu),\nuvec4(0x62080208u,0x5e2b0e7bu,0x0970090du,0x4ecd0e5du),\nuvec4(0x29b0091du,0xf0f0f01du,0x0a0950f0u,0xce0b0e2bu),\nuvec4(0x1d2e8b7du,0x0a9b1aabu,0x080b023bu,0x08072807u),\nuvec4(0x18f70827u,0x1b12f807u,0x17020b22u,0x0b020708u),\nuvec4(0x25171802u,0x3b220807u,0x28325802u,0x0b124822u),\nuvec4(0xde4b0a2eu,0xf00d304du,0xf040f0f0u,0xe0f0f0f0u),\nuvec4(0x1d0e0d09u,0x2d0b320bu,0x0a1b0a1eu,0x38020b02u),\nuvec4(0x195eab12u,0x0d0e0900u,0x0e000920u,0x0e0d8eedu),\nuvec4(0x8009400du,0xf0f0f019u,0x6e6b70f0u,0x1a0d0e0au),\nuvec4(0x4e5b2e5du,0x0a5b0e0du,0x0d090a5bu,0x126b0a0bu),\nuvec4(0x12080228u,0x47020b1au,0x07254705u,0x07288715u),\nuvec4(0x18030803u,0x1b321812u,0x12371802u,0x02089708u),\nuvec4(0x0847282bu,0x28073807u,0x1b021807u,0x3b021b1eu),\nuvec4(0x0e405dbeu,0xf0f0f009u,0xf0f0f030u,0x0b3df0f0u),\nuvec4(0x1b0e1b02u,0x1b0d0a1du,0x28020b02u,0x7b220802u),\nuvec4(0x8e0a0b0eu,0x090d3e0du,0x090d290du,0xae1d0e1du),\nuvec4(0x190d5e0du,0x090d0900u,0xf0f0f0f0u,0x2e2b20f0u),\nuvec4(0x0b0d3e0bu,0x3b9e4d0au,0x10094b6eu,0x300a0b1au),\nuvec4(0x225b0a0eu,0x0d0e0218u,0x02011a09u,0x47055708u),\nuvec4(0x17250c25u,0x07035715u,0x02282705u,0x08020a0bu),\nuvec4(0x0c050712u,0xa7180725u,0x2827f705u,0x3b220802u),\nuvec4(0x020b1802u,0xf03dbe1bu,0xf0b0f0f0u,0xf0f0f0f0u),\nuvec4(0x0b0d0e0du,0x0b0e1b12u,0x0b0a3b3du,0x0a1e9b82u),\nuvec4(0x200d7e0bu,0x2d400d0eu,0x0d093ddeu,0xf0f00d2eu),\nuvec4(0x40f0f0f0u,0x0d7e0b0au,0x0a0b1e1au,0x2d000e1bu),\nuvec4(0x2d0e3b4eu,0x30093b2eu,0x090a092bu,0x18227b0eu),\nuvec4(0x0a09200au,0x0c051713u,0x07122c05u,0x05070c35u),\nuvec4(0x0357450cu,0x02083702u,0x1517223bu,0x0817051cu),\nuvec4(0x255745b7u,0x12370507u,0x12180708u,0x0208221bu),\nuvec4(0x0b7e0a1bu,0x09503d1eu,0x50f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0d1e09e0u,0x0d2b0d3bu,0x0b2a3b0au,0x180b0807u),\nuvec4(0x5b121b02u,0x0b3e0b0eu,0x0900096eu,0x1910092eu),\nuvec4(0x2e0dae0du,0x0900091du,0xf0f01d0eu,0x70f0f0f0u),\nuvec4(0x0a7e1b0du,0x2b0e1b0eu,0x5e0d200au,0x025b3e1bu),\nuvec4(0x300e5009u,0x223b3e09u,0x20090208u,0x0c05020au),\nuvec4(0x3c050705u,0x04081205u,0x17050c25u,0xc7050705u),\nuvec4(0x120b0208u,0x1507680bu,0x35574827u,0x250c9517u),\nuvec4(0x3b020857u,0x2b120802u,0x2d1e0b8eu,0xf00e0960u),\nuvec4(0xf040f0f0u,0xe0f0f0f0u,0x120b2d09u,0x0a0b121bu),\nuvec4(0x1a0b221bu,0x2802170bu,0x020b0e02u,0x0009be7bu),\nuvec4(0x00090a3eu,0x0a0b0e0bu,0x2e1d0e39u,0x090d0e0du),\nuvec4(0xf0f01d30u,0x90f0f0f0u,0x1e2b0e0du,0x090d0e3bu),\nuvec4(0x0b1e0910u,0x1e1b2009u,0xe08b4e0du,0x122b2e1du),\nuvec4(0x08300a0bu,0x165c050cu,0x254c0417u,0x081708b7u),\nuvec4(0x28070802u,0x4738322bu,0x17357718u,0x2c450705u),\nuvec4(0x2b022745u,0x1b320802u,0x1d7e0d3eu,0x0d1e0970u),\nuvec4(0xf0f0f019u,0xf0f0f000u,0x0b3de0f0u,0x08220812u),\nuvec4(0x17023b42u,0xce7b1248u,0x0a1b2e10u,0x090a1b09u),\nuvec4(0x0d7e190du,0xf0f0f0f0u,0x1e0960f0u,0x0e1d0e0du),\nuvec4(0x2e0d090du,0x0a19003bu,0x204b4009u,0x7e0b0a09u),\nuvec4(0x0900f05bu,0x0b3e1b1eu,0x4c04400au,0x4c270c26u),\nuvec4(0x07085715u,0x12280708u,0x021b020bu,0x021b027bu),\nuvec4(0x17081218u,0x07040728u,0x2c05c704u,0x07252c15u),\nuvec4(0x08272208u,0x2d8e0b12u,0x70090d1eu,0x1e0d2e09u),\nuvec4(0x00f0f0f0u,0xf0f0f0f0u,0x021b3de0u,0x12080208u),\nuvec4(0x082b2218u,0x18070802u,0x4b220b32u,0x2e0d10ceu),\nuvec4(0x00191a0bu,0xf0f0ae0du,0x70f0f0f0u,0x220b2e0du),\nuvec4(0x1e1b021bu,0x60090e0du,0x503b1019u,0x6e0b1e0au),\nuvec4(0x20f0091bu,0x0d2e0d0eu,0x01501b0eu,0x071c262cu),\nuvec4(0x353c0508u,0x08021837u,0x1b115b02u,0x2b020b22u),\nuvec4(0x08020802u,0x07050407u,0x07250405u,0x07240504u),\nuvec4(0x27052724u,0x27251c65u,0x18020b02u,0x099e1b22u),\nuvec4(0x0e0d29b0u,0x30f0f0f0u,0xf0f0f0f0u,0x0a0d09e0u),\nuvec4(0x3238022bu,0x080b0218u,0x08021847u,0x0bbe3b52u),\nuvec4(0x090a3e19u,0xce0d0900u,0xf0f0f009u,0x0960f0f0u),\nuvec4(0x1b282b0eu,0x091e1b28u,0x0a201960u,0x09300a3bu),\nuvec4(0x2e0a1b1eu,0x29500e2bu,0x7e0d800du,0x0301400bu),\nuvec4(0x02161c04u,0x07080715u,0x37252c05u,0x08129b08u),\nuvec4(0x67180302u,0xf5145502u,0x07152c25u,0x12183705u),\nuvec4(0x0e1d5e8bu,0xf00dd00du,0xf070f0f0u,0xe0f0f0f0u),\nuvec4(0x021b2d09u,0x28021817u,0x021b080cu,0x621b1718u),\nuvec4(0x0e1b0a4bu,0xce1bde0bu,0xf0f0190du,0x80f0f0f0u),\nuvec4(0x021b0e09u,0x07281b18u,0x90010b02u,0x1b094009u),\nuvec4(0x10010b02u,0x0b0e0b09u,0x0b025b0eu,0x0b1e390au),\nuvec4(0x0d0e1b0au,0x0d093009u,0x0b0e1b0eu,0x0b0a1b02u),\nuvec4(0x6c041240u,0x0c050705u,0x32480735u,0x180b0e0bu),\nuvec4(0x0208020bu,0x0c051708u,0xe50c0517u,0x0cb50704u),\nuvec4(0x18271805u,0x0b022802u,0x1d6e3b3eu,0xe0090d0eu),\nuvec4(0xf0f0f009u,0xf0f0f060u,0x0a1de0f0u,0x080b0d0bu),\nuvec4(0x06075807u,0x021b0207u,0x0d1b0218u,0x0a5b520bu),\nuvec4(0xf0f0eefeu,0xb0f0f0f0u,0x024b0e09u,0x1b081b08u),\nuvec4(0x0a601ba0u,0x020b020bu,0x1a3b0900u,0x0a191a20u),\nuvec4(0x020b124bu,0x220b0acbu,0x05200918u,0x050c158cu),\nuvec4(0x5827150cu,0x08021b22u,0x05471802u,0x040c85ccu),\nuvec4(0x07053c55u,0x02081705u,0x6e0b3218u,0x0d5e0a09u),\nuvec4(0x0de0091eu,0xf0f0090eu,0xf0f050f0u,0x0df0f0f0u),\nuvec4(0x020a0d1bu,0x05481708u,0x020b0807u,0x1a1b0708u),\nuvec4(0x6b520b0du,0xf009defeu,0xf0f0f0f0u,0x3b0e0ab0u),\nuvec4(0x08070802u,0x0a300b12u,0x700b0260u,0x0a300a09u),\nuvec4(0x3009021eu,0x023b0e0bu,0x02480708u,0x022b2208u),\nuvec4(0x0208021bu,0x3001281bu,0x050c2501u,0x052c153cu),\nuvec4(0x18523837u,0x150cfc57u,0x2704251cu,0x37250c85u),\nuvec4(0x0e0b2218u,0x0e0b0e1bu,0x0e0b0910u,0xf0093e19u),\nuvec4(0xf00d1e00u,0xf050f0f0u,0xf0f0f0f0u,0x0b0d2b0du),\nuvec4(0x12175817u,0x0e0b0227u,0x720a0b0au,0x0d8efe6bu),\nuvec4(0xf0f0090eu,0xb0f0f0f0u,0x0b222b09u,0x07080708u),\nuvec4(0x0ab00b02u,0x30090e90u,0x0a0b0e0au,0x020b0930u),\nuvec4(0x1857220bu,0x3b120807u,0x02070822u,0x0b02080bu),\nuvec4(0x1c030140u,0x17150c75u,0x02081705u,0x0703023bu),\nuvec4(0x07082708u,0x151cfc08u,0x1507050cu,0x17021817u),\nuvec4(0x08451c05u,0x02183705u,0x10090e7bu,0x0d2e3019u),\nuvec4(0x091e00f0u,0x50f0f0f0u,0xf0f0f0f0u,0x021b00f0u),\nuvec4(0x08020b0eu,0x020b3837u,0x02080705u,0x4b52284bu),\nuvec4(0x0e099efeu,0xf0f0f0f0u,0x120ad0f0u,0x1b02080bu),\nuvec4(0x07080b02u,0x1950f00au,0x090b2a50u,0x021b0910u),\nuvec4(0x17081208u,0x07281705u,0x021b3208u,0x0d280728u),\nuvec4(0x0c060350u,0x0c151705u,0x07350c05u,0x2b022825u),\nuvec4(0x08021722u,0x4c35dc17u,0x02083705u,0x3517081bu),\nuvec4(0x0e2b0867u,0x50190a5bu,0xe00d3e09u,0xf0f01e09u),\nuvec4(0xf0f060f0u,0x10f0f0f0u,0x0b0e120bu,0x02083708u),\nuvec4(0x08020b08u,0x1d0b1807u,0x180b020au,0x6b120b22u),\nuvec4(0x090d8efeu,0xf0f0f0f0u,0x180ad0f0u,0x0248120bu),\nuvec4(0x021b20f0u,0x1b0a700au,0x1b093009u,0x07021b12u),\nuvec4(0x1b080705u,0x0b120802u,0x1b120802u,0x0a280712u),\nuvec4(0x050c0350u,0x25370547u,0x05170507u,0x08120817u),\nuvec4(0x15021827u,0x057c051cu,0x35040704u,0x150c052cu),\nuvec4(0x074b0227u,0x1b186715u,0x0b0e1b02u,0x0a093b0eu),\nuvec4(0x0e094009u,0xc0091e0bu,0xf0091e0du,0xf060f0f0u),\nuvec4(0xf0f0f0f0u,0x08120910u,0x2708020bu,0x07080708u),\nuvec4(0x0b024708u,0x0b0a020au,0x0b4e8b52u,0xf0f02efeu),\nuvec4(0xf0f0f0f0u,0x08010009u,0x50012b12u,0x09000911u),\nuvec4(0x080a091au,0x1b300102u,0x09501a80u,0x0b080b0au),\nuvec4(0x07080b0au,0x080a1b08u,0x1b023837u,0x0b023708u),\nuvec4(0x0a09200au,0x15070208u,0x45070507u,0x153c0507u),\nuvec4(0x08320817u,0x17180702u,0x050c0705u,0x1407152cu),\nuvec4(0x05170527u,0x0507150cu,0x02170517u,0x0b0e1b01u),\nuvec4(0x0b120847u,0x0e2b0802u,0x0a6b0e2bu,0x903e0940u),\nuvec4(0xf0093e19u,0xf060f0f0u,0xf0f0f0f0u,0x0b220b20u),\nuvec4(0x18170827u,0x1708270bu,0x08022b08u,0x1b5e6b42u),\nuvec4(0xf0f02efeu,0xf0f0f0f0u,0x60090a20u,0x28120801u),\nuvec4(0xf0271827u,0x0a100970u,0x10091b20u,0x0517080bu),\nuvec4(0x150c050cu,0x08020817u,0x020e2b57u,0x05070527u),\nuvec4(0x45074517u,0x023b2227u,0x07055714u,0x77043724u),\nuvec4(0x27054705u,0x08020b02u,0x1e020847u,0x0a5b1e6bu),\nuvec4(0x3e903e70u,0xf0f00e0bu,0xf0f070f0u,0x30f0f0f0u),\nuvec4(0x17021802u,0x02182705u,0x18070508u,0x18220817u),\nuvec4(0x2b3e7b32u,0x090d1efeu,0xf0f0f0f0u,0x1a10f0f0u),\nuvec4(0x27080240u,0x17052c05u,0xf0080c35u,0x11a01910u),\nuvec4(0x8c070210u,0x08020815u,0x25170587u,0x18573547u),\nuvec4(0x0b0a2b12u,0x17140312u,0x77251734u,0x07087708u),\nuvec4(0x08022b22u,0x120b0807u,0x120b0a0eu,0x093b4e1bu),\nuvec4(0x403e0970u,0x0e1d0e49u,0xf0f0f01au,0xf0f0f070u),\nuvec4(0x0a30f0f0u,0x2508020bu,0x0b120827u,0x07020827u),\nuvec4(0x4e5b4248u,0x0d1efe2bu,0xf0f0f009u,0x20f0f0f0u),\nuvec4(0x67081b02u,0x2c150c05u,0xf0024c05u,0x0b900120u),\nuvec4(0x07022002u,0x471805acu,0x3c151c05u,0x07150c05u),\nuvec4(0x07085745u,0x1a0e2b02u,0x0408120bu,0x082705c7u),\nuvec4(0x18023817u,0x1e3b1802u,0x024b220bu,0x2e2b0e2bu),\nuvec4(0x0a800e1bu,0x2e40091eu,0x1a0e0a0du,0xf0f0f019u),\nuvec4(0xf0f0f090u,0x0950f0f0u,0x1507120bu,0x2b020817u),\nuvec4(0x58071812u,0x2b021822u,0xf0098efeu,0xf0f0f0f0u),\nuvec4(0x170230f0u,0x1c450708u,0x2c164c15u,0x20f0f002u),\nuvec4(0x048c0709u,0x2817150cu,0x25070527u,0x4507350cu),\nuvec4(0x08270857u,0x0b020807u,0x08120b2eu,0x58e70807u),\nuvec4(0x1e4b025bu,0x2e0d0e1bu,0x1e2b2e0bu,0x3e0b0e0bu),\nuvec4(0x0d09d00au,0x1d090e19u,0xd0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x020970f0u,0x02085708u,0x0207083bu,0x02680708u),\nuvec4(0xfe0d2e4bu,0xf0f0091eu,0xf0f0f0f0u,0x07080b30u),\nuvec4(0x155c1718u,0x071c464cu,0x0210f0f0u,0x07059c07u),\nuvec4(0x1817050cu,0x150c9557u,0x05171837u,0x08072807u),\nuvec4(0x020d1e0bu,0xd7180718u,0x02280708u,0x2e7b020bu),\nuvec4(0x4e4d0b1du,0x1e5b1e0bu,0x9009020bu,0x09001e09u),\nuvec4(0xf0f0090du,0xf000f0f0u,0xf0f0f0f0u,0x07080b80u),\nuvec4(0x27050705u,0x18170238u,0x28070817u,0x0d2e4b02u),\nuvec4(0xf0091efeu,0xf0f0f0f0u,0x570830f0u,0x7c151c15u),\nuvec4(0x08175c26u,0x02017001u,0x09f00207u,0x7c051708u),\nuvec4(0x1c050705u,0x17020817u,0x0c350715u,0x050c5785u),\nuvec4(0x08170518u,0x021e1b02u,0x2807f718u,0x1b0e6b02u),\nuvec4(0x9b7e1d4eu,0x0b0e0b0eu,0x0da00902u,0xf0f0090eu),\nuvec4(0xf030f0f0u,0xf0f0f0f0u,0x0c170290u,0xa7282705u),\nuvec4(0x3e2b2218u,0x3e0bae0du,0xf0f0f0f0u,0x0140f0f0u),\nuvec4(0x45171827u,0x50055cfcu,0x03053c02u,0x0702c002u),\nuvec4(0x078c051cu,0x07151c15u,0x07151708u,0x4c350455u),\nuvec4(0x07051745u,0x1b021805u,0xf708121eu,0x5b023b08u),\nuvec4(0x0d4e2d4eu,0xa00adb3eu,0xf0f00e0du,0xf040f0f0u),\nuvec4(0xf0f0f0f0u,0x07080b90u,0x07050201u,0x07280b02u),\nuvec4(0x27052715u,0x020b0218u,0x9e2d0e2bu,0xf0094e0bu),\nuvec4(0xf0f0f0f0u,0x050740f0u,0x050c1547u,0x02078cfcu),\nuvec4(0x7c022001u,0x00110405u,0x0a0b0a09u,0x07050211u),\nuvec4(0x05cc050cu,0x071c0507u,0x07451708u,0x7c250415u),\nuvec4(0x07252715u,0x0d0e2b18u,0x1817080bu,0x08073857u),\nuvec4(0x1b0a3b02u,0x0d0b0e0au,0x0d1e0a0eu,0x1b0e0d0eu),\nuvec4(0x0b2e2b9eu,0xa0022b1eu,0xf0f0f019u,0xf0f040f0u),\nuvec4(0xa0f0f0f0u,0x17100702u,0x08022b08u,0x18170847u),\nuvec4(0x4efe4b02u,0xf0f0f0f0u,0x0850f0f0u,0xdcfc1557u),\nuvec4(0x05000205u,0x365c060cu,0x070b071cu,0x06ec061cu),\nuvec4(0x2708055cu,0x17050715u,0x1507050cu,0x053c052cu),\nuvec4(0x05171507u,0x2b121807u,0x18020b1eu,0x3b825847u),\nuvec4(0x0d0e0b0au,0x1b1e1d0eu,0x1b0e0b8eu,0x09021b6eu),\nuvec4(0xf0f0f0f0u,0xf0f000f0u,0xa0f0f0f0u,0x0001070bu),\nuvec4(0x02080701u,0x180b0e1bu,0x12370817u,0x400d6e6bu),\nuvec4(0x2e000d09u,0xf0f0f009u,0x40f0f0f0u,0x052c1547u),\nuvec4(0x5cc6bcfcu,0x06050c05u,0x06dc051cu,0x0503122cu),\nuvec4(0x15271537u,0x050c1507u,0x171c250cu,0x27082715u),\nuvec4(0x1e2b0208u,0x0817121au,0x0b122807u,0x221b0802u),\nuvec4(0x08020a0bu,0x0d1b0e1bu,0x2efe0d0bu,0xf00b6e0bu),\nuvec4(0xf0f0f0f0u,0xf0f0f010u,0x01b0f0f0u,0x17000b07u),\nuvec4(0x0b0e1b08u,0x02083712u,0x0e5b0218u,0x190d0930u),\nuvec4(0xf00d1e80u,0xf0f0f0f0u,0x170830f0u,0x1cfcfc25u),\nuvec4(0x4c760c36u,0x1c020c15u,0x150c0507u,0x052003dcu),\nuvec4(0x08170547u,0x14550407u,0x2c07051cu,0x17251705u),\nuvec4(0x0a1e4b18u,0x12080712u,0x020b220bu,0x020b222bu),\nuvec4(0x0a1b0804u,0x0d0a0d0bu,0xf00aaefeu,0xf0f0f0f0u),\nuvec4(0xf0f0f010u,0x01c0f0f0u,0x07000108u,0x1b1e0b08u),\nuvec4(0x08170802u,0x280b0207u,0xf0091b12u,0x091b0a10u),\nuvec4(0xf0f0f0f0u,0x200990f0u,0x35011001u,0x4cfc25dcu),\nuvec4(0x1c961c26u,0x03051c05u,0x1c070807u,0x0120ec05u),\nuvec4(0x27151705u,0x25040708u,0x0c046504u,0x2c170507u),\nuvec4(0x12082715u,0x220b0e3bu,0x42481703u,0x12030b1au),\nuvec4(0xfe1d1a0bu,0xf07e0b2eu,0xf0f0f0f0u,0xf0f0f020u),\nuvec4(0x01b0f0f0u,0x10020503u,0x0a1e020bu,0x0708020bu),\nuvec4(0x02081708u,0x0b022807u,0x0b0a30f0u,0xf0f0090eu),\nuvec4(0xe0f0f0f0u,0x050c0502u,0xfc050cfcu,0x0c05074cu),\nuvec4(0x1c162c16u,0x06054c16u,0x0207050cu,0x05170801u),\nuvec4(0x200306dcu,0x27350702u,0x0c152415u,0x0c053745u),\nuvec4(0x17051c05u,0x0b3e3b58u,0x04020402u,0x12030208u),\nuvec4(0x2e0a0204u,0x1e1b020bu,0x0abefe0du,0xf0f0f0f0u),\nuvec4(0xf0f020f0u,0xc0f0f0f0u,0x0b070402u,0x0b1e1b10u),\nuvec4(0x08270812u,0x02171807u,0x0930f00bu,0x01100e1bu),\nuvec4(0xf0f0f0f0u,0x052cb0f0u,0xfc056c07u,0x260c17dcu),\nuvec4(0x161c161cu,0x051c260cu,0x1001071cu,0x5c253c27u),\nuvec4(0x02300326u,0x17020425u,0x34050c05u,0x05270425u),\nuvec4(0x1227252cu,0x1b181708u,0x2b0e0b22u,0x1e0a0b1eu),\nuvec4(0x1e1b1e1bu,0x0e2b2e1bu,0xfe0b2e0bu,0xf0f0092eu),\nuvec4(0x30f0f0f0u,0xf0f0f0f0u,0x0201e0f0u,0x0b0a1001u),\nuvec4(0x07081b1eu,0x07180705u,0x0b081702u,0x1e0a40f0u),\nuvec4(0xf0090120u,0xf0f0f0f0u,0x1c050170u,0xac157c05u),\nuvec4(0x2c252725u,0x46056c05u,0x162c060cu,0x0c05362cu),\nuvec4(0x01100207u,0x07151705u,0x02268c05u,0x10113009u),\nuvec4(0x05640704u,0x0c050724u,0x27251c05u,0x22281708u),\nuvec4(0x2b02281bu,0x1b0e1b08u,0x0e0a4b0eu,0x1b2e0a1bu),\nuvec4(0x1efe0b4eu,0xf0f0f00au,0xf040f0f0u,0xf0f0f0f0u),\nuvec4(0x011012f0u,0x020b1e1bu,0x07150708u,0x07080208u),\nuvec4(0x50f00208u,0x21000b0du,0xf0f0f0f0u,0x7c0580f0u),\nuvec4(0x0705fc06u,0x0517151cu,0x668c051cu,0x063c063cu),\nuvec4(0x150c060cu,0x04100107u,0x08070407u,0x168c1507u),\nuvec4(0x40020403u,0x03010008u,0x353c1504u,0x170c050cu),\nuvec4(0x07081735u,0x18320708u,0x08071802u,0x08120807u),\nuvec4(0x1e0b1e3bu,0x0b0a020au,0x0b5e5b0eu,0xf0091efeu),\nuvec4(0xf0f0f0f0u,0xf0f0f040u,0x02f0f0f0u,0x0b200107u),\nuvec4(0x08021b1eu,0x120b1817u,0x50f00108u,0x0100090au),\nuvec4(0xf0110003u,0xf0f0f0f0u,0x063c1660u,0x062c255cu),\nuvec4(0x356c152cu,0x06bc46bcu,0x2002151cu,0x168c1547u),\nuvec4(0x0430021cu,0x02015005u,0x10010011u,0x070c0501u),\nuvec4(0x07250705u,0x02280718u,0x27281228u,0x3e2b1218u),\nuvec4(0x1e2b0e6bu,0x0b2efe2bu,0xf00a100au,0xf0f0f0f0u),\nuvec4(0xf0f0f020u,0x00f0f0f0u,0x0a200112u,0x020b0d0eu),\nuvec4(0x2b082718u,0x030190f0u,0xf0f0f00au,0x0570f0f0u),\nuvec4(0x6c061c06u,0x8c05bc15u,0x0c166c15u,0x160cfc06u),\nuvec4(0x0107150cu,0x17050210u,0x03368c25u,0x0c051201u),\nuvec4(0x01d00205u,0x050c1517u,0x18022817u,0x18074832u),\nuvec4(0x1e4b1817u,0x0e0b0e5bu,0x0a0b1a0bu,0x0b1efe1bu),\nuvec4(0x0d0a1009u,0xf0f0f0f0u,0xf0f020f0u,0xf0f0f0f0u),\nuvec4(0x30020110u,0x17180b2eu,0x1b0a0208u,0x0013a0f0u),\nuvec4(0xf0f0f011u,0x0430f0f0u,0xfc159c06u,0x061c250cu),\nuvec4(0x151c267cu,0x070c06ecu,0x2002051cu,0x05170401u),\nuvec4(0x174c569cu,0x02b00108u,0x38372517u,0x18220802u),\nuvec4(0x38020802u,0x8b1e5b02u,0x6b0e0a0eu,0x0b8e1b1eu),\nuvec4(0x0d0b300au,0xf0f0f0f0u,0xf0f020f0u,0xf0f0f0f0u),\nuvec4(0x1e400120u,0x0817081bu,0x30f02b02u,0x0a1e0a09u),\nuvec4(0x10211009u,0xf0f0f001u,0x0100f0f0u,0x25dc05ecu),\nuvec4(0x151c16bcu,0x074c06bcu,0x2001250cu,0x4c051703u),\nuvec4(0x6c463c05u,0x01b00127u,0x18170847u,0x58422802u),\nuvec4(0x1b1e5b12u,0x0a0e6b08u,0x0e8b0e3bu,0x090a0e2bu),\nuvec4(0xf0090e40u,0xf0f0f0f0u,0xf0f0f020u,0x90f0f0f0u),\nuvec4(0x07081b1eu,0x20f03b08u,0x1a01090au,0x00010b2eu),\nuvec4(0xf0011001u,0xf0f0f0f0u,0x15ec0500u,0x055cfc07u),\nuvec4(0x06bc256cu,0x042c153cu,0x02100105u,0x0c26ac17u),\nuvec4(0xc0059c06u,0x1b02b802u,0x08021b02u,0x1b120807u),\nuvec4(0x0b022b02u,0x080b0a1eu,0x1b0a5b02u,0x2e1a1b0au),\nuvec4(0x093b0e2bu,0xf0f00970u,0x30f0f0f0u,0xf009e0f0u),\nuvec4(0x90f0f0f0u,0x08022b1eu,0x090b1e0bu,0x190a09a0u),\nuvec4(0x20010940u,0x50091e01u,0xf0f00102u,0x01b0f0f0u),\nuvec4(0x164cfc06u,0x17156cfcu,0x253cfc05u,0x02100307u),\nuvec4(0x150c0405u,0x069c050cu,0x022c065cu,0x022822d0u),\nuvec4(0x120b4228u,0x0a1b1228u,0x00190a02u,0x0b0e0b09u),\nuvec4(0xeb080702u,0x0a090a0eu,0xf0090a1bu,0xf0f0f0f0u),\nuvec4(0x00f0f0f0u,0xf0f0f009u,0x4b3e70f0u,0x4e800a1eu),\nuvec4(0x0a09a009u,0xf00d0b0eu,0xf0f0f0f0u,0xfcfc0520u),\nuvec4(0x052705dcu,0x0c054cfcu,0x05200705u,0x069c0527u),\nuvec4(0x065c060cu,0x0af0041cu,0x8218220bu,0x02180208u),\nuvec4(0x0a600b18u,0x0807021bu,0x091b0ebbu,0xf0f00b20u),\nuvec4(0xf0f0f0f0u,0x10f0f020u,0xf0f0f00au,0x1b6e60f0u),\nuvec4(0x090e0b02u,0xc0093e70u,0x0e0d0e09u,0xf009100au),\nuvec4(0xe0f0f0f0u,0x0c053c0au,0xfc365c26u,0x062c061cu),\nuvec4(0x0705074cu,0x5c06fc05u,0x17083017u,0x6c167c05u),\nuvec4(0x30f00236u,0x1b123802u,0x08020b62u,0x082b8002u),\nuvec4(0x1b0e3b02u,0x20090b5eu,0xf0f01a09u,0xf0f0f0f0u),\nuvec4(0x10f0f010u,0xf0f0f019u,0x2b7e60f0u,0x3e09600eu),\nuvec4(0x0a30f009u,0x0e0b0e0bu,0xf0f0f0f0u,0x067c02a0u),\nuvec4(0x5cfc464cu,0xfc155c16u,0x4007155cu,0x064c1527u),\nuvec4(0x010c367cu,0x480b30f0u,0x1b082b02u,0xebb02b18u),\nuvec4(0x0120091eu,0xf0f0091eu,0xf0f0f0f0u,0xf0f0f010u),\nuvec4(0xb0f0f0f0u,0x1e1b6e09u,0x0a092009u,0x20f00a3eu),\nuvec4(0x0b1e1b29u,0xf0f0f00au,0x66ac90f0u,0x960c25fcu),\nuvec4(0x25cc169cu,0x17013007u,0x0526dc15u,0x0940f001u),\nuvec4(0x020b0238u,0x22080208u,0xc0020b08u,0x0b2ebb09u),\nuvec4(0x1e01200au,0xf0f009e0u,0x20f0f0f0u,0xf0f0f0f0u),\nuvec4(0x09d0f0f0u,0x0b1e1b4eu,0x09d00a8eu,0x400a600au),\nuvec4(0xf0f0f029u,0x8c0550f0u,0xfc361c06u,0xcc661c25u),\nuvec4(0x3c059c06u,0x07050705u,0xac270830u,0x0c160c06u),\nuvec4(0x60f00107u,0x28123802u,0x0ae02b12u,0x0ebb021bu),\nuvec4(0x0a20f009u,0xf0f0f01eu,0xf010f0f0u,0xf0f0f0f0u),\nuvec4(0x0d09f0f0u,0x0abe0b2eu,0xf0f0f0f0u,0x0550f0f0u),\nuvec4(0x8cfc351cu,0x1c050705u,0x0c061c66u,0xfc054c04u),\nuvec4(0x04151c05u,0x07300207u,0x4c050708u,0x02056c05u),\nuvec4(0x020b80f0u,0x12081748u,0x0af00a0bu,0x9b0e1b22u),\nuvec4(0x0a20f00au,0xf0f0f01eu,0xf010f0f0u,0xf0f0f0f0u),\nuvec4(0x1910f0f0u,0x09ae0b1eu,0xf0f0f0f0u,0x0140f0f0u),\nuvec4(0x150c1507u,0x359c3527u,0x962c055cu,0x27556cfcu),\nuvec4(0x170a0120u,0x01049c05u,0x021bb0f0u,0x02083718u),\nuvec4(0x0b00f01bu,0x0a010208u,0x0eab0e0bu,0xf02e10f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f010u,0xf0f0f0f0u,0x090d0940u),\nuvec4(0x596e0910u,0xf0f0f0f0u,0x1702f0f0u,0x47082725u),\nuvec4(0x07550c25u,0x7c450c05u,0xec052c96u,0x17251725u),\nuvec4(0x1701101au,0x1c353c05u,0x09c0f001u,0x0807180bu),\nuvec4(0x090b2807u,0x0b0a10f0u,0x3b125b20u,0x0b09f02eu),\nuvec4(0xf0f0f00eu,0xf020f0f0u,0xf0f0f0f0u,0xceb0f0f0u),\nuvec4(0xf0f0f009u,0x0930f0f0u,0xc7187780u,0x05074c25u),\nuvec4(0x166c0507u,0x351c163cu,0x377c074cu,0x0a282708u),\nuvec4(0x02070910u,0x054c0708u,0xf0010207u,0x080b0ae0u),\nuvec4(0x28070807u,0x029b80f0u,0x09e02e1bu,0xf0f00e0bu),\nuvec4(0x20f0f0f0u,0xf0f0f0f0u,0xc0f0f0f0u,0x0a3e0b6eu),\nuvec4(0xf0f0f0f0u,0x1701c0f0u,0x020b0248u,0x0c258748u),\nuvec4(0x07051c05u,0x2c252c05u,0x47155c05u,0x3c150705u),\nuvec4(0x07250c05u,0x321b0228u,0x07100805u,0x0517080bu),\nuvec4(0xf0010817u,0x180b20f0u,0x80f02817u,0x0b1eab0au),\nuvec4(0x0b09f00eu,0xf0f0f0f0u,0xf0f020f0u,0xf0f0f0f0u),\nuvec4(0x3e09e0f0u,0xf0f03e0bu,0xe0f0f0f0u,0x1228020bu),\nuvec4(0x5597284bu,0x052c1507u,0x45023507u,0x1c150887u),\nuvec4(0x12180755u,0x121b0e1bu,0x22000217u,0x01020718u),\nuvec4(0x1b40f0f0u,0xf0182708u,0x1e7b0980u,0x19f0094bu),\nuvec4(0xf0f00e0du,0xf0f0f0f0u,0xf0f0f0f0u,0x20f0f0f0u),\nuvec4(0xf0f04b09u,0xe0f0f0f0u,0x127b023bu,0x67081238u),\nuvec4(0x47155705u,0x37080b08u,0x05070b78u,0x12770507u),\nuvec4(0x120b2e1bu,0x02080708u,0xf0021701u,0x0b0a80f0u),\nuvec4(0xf0120728u,0x0a091b90u,0x0e0b0e5bu,0x09e0091bu),\nuvec4(0xf019100eu,0xe0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf03b0a30u,0xf0f00b01u,0x2bc0f0f0u,0x6b0e2b12u),\nuvec4(0x17182b02u,0x47080228u,0x07084718u,0x080b1268u),\nuvec4(0x870b1802u,0x1b021812u,0x07084b1eu,0x02d00218u),\nuvec4(0x220bd0f0u,0xf0020b08u,0x0e0b0180u,0x0b0e0a20u),\nuvec4(0x1b0e0b0eu,0x09f0091eu,0x0e000910u,0xf0f0f0f0u),\nuvec4(0xf0f0f0d0u,0xf0f0f0f0u,0x090e40f0u,0x080ae01bu),\nuvec4(0x0902000au,0xf0f0f0f0u,0x1e5b0a90u,0x020b028bu),\nuvec4(0x0b12080bu,0x08020b02u,0x38170807u,0x08021817u),\nuvec4(0x080b081bu,0x0257187bu,0x1e2b122bu,0x0807084bu),\nuvec4(0x01700102u,0xf0f00702u,0x2b0e0a10u,0x80f00a02u),\nuvec4(0x300a0b01u,0x1e4b0e09u,0x100920f0u,0xf0f0f019u),\nuvec4(0xf0f0c0f0u,0xf0f0f0f0u,0x0e50f0f0u,0x2e0ab01bu),\nuvec4(0xf01b121bu,0x90f0f0f0u,0x0e3b0a09u,0x621b026bu),\nuvec4(0x2b583b08u,0x08021b18u,0x483b0e7bu,0x2e7b0807u),\nuvec4(0x0e0b0e1bu,0x05071802u,0x08111001u,0xf0170517u),\nuvec4(0x020b20f0u,0xf00b0218u,0x40090b90u,0xf00a4b0eu),\nuvec4(0x090e0920u,0xf0f00d00u,0xf0d0f0f0u,0xf0f0f0f0u),\nuvec4(0x50f0f0f0u,0x90090b1eu,0x0b2e0b09u,0x0b020b0au),\nuvec4(0x0e0b0a0eu,0x191e0d19u,0xf0f0f0f0u,0x0e4b0a10u),\nuvec4(0x125b0e1bu,0x3b08220bu,0x08020802u,0x08023b02u),\nuvec4(0x120b020bu,0x2bfb0e6bu,0x27084b3eu,0x3c350705u),\nuvec4(0x20f0f008u,0x0a121b0au,0x600a90f0u,0x090b1e09u),\nuvec4(0x393009f0u,0xf0f0f0f0u,0xf0f0f0d0u,0xf0f0f0f0u),\nuvec4(0x091e70f0u,0x0a301920u,0x0b002e1bu,0x2b0e3b2eu),\nuvec4(0xf0f0091eu,0x0910f0f0u,0x2e0b1e1bu,0x0218128bu),\nuvec4(0x2b18122bu,0x0b020b02u,0x2b8e8b02u,0x5b0e0b0eu),\nuvec4(0x3b0e0b3eu,0x5c350722u,0x20f0f001u,0x08020b09u),\nuvec4(0xf00a010au,0x60010e80u,0xf00a0b0eu,0x190e4009u),\nuvec4(0xf0f00900u,0xf0c0f0f0u,0xf0f0f0f0u,0x80f0f0f0u),\nuvec4(0x0a0e092eu,0x00090b09u,0x4e0b3e2bu,0x0e2b023bu),\nuvec4(0xf0f00a0bu,0x0e10f0f0u,0x0e0b1e3bu,0x024b089bu),\nuvec4(0xbb22085bu,0x0b3e3b8eu,0x08026b5eu,0x073c0537u),\nuvec4(0x0e40f0f0u,0x09000108u,0x60f0090eu,0x0a601e09u),\nuvec4(0x800900f0u,0xf0090e09u,0xb0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x0a0e1990u,0x0e0b0910u,0x1e0b3e1bu),\nuvec4(0x1e6b2e0bu,0xf0f01e0du,0x0a00f0f0u,0x0b3e0b0eu),\nuvec4(0x4b12db0eu,0x1b4e1b32u,0x0b8e0d5eu,0x08223bbeu),\nuvec4(0xf0012567u,0x100150f0u,0x70f01e0au,0xf00a0b0au),\nuvec4(0x0d0e09e0u,0xf0f0f02eu,0xf0f0b0f0u,0xf0f0f0f0u),\nuvec4(0x0ac0f0f0u,0x1e1b0a20u,0x8e0b0e0du,0x4e0b0a3bu),\nuvec4(0xf0f0f0f0u,0x0b2e0a00u,0x5b02eb2eu,0xfefe0b12u),\nuvec4(0x27085b5eu,0xf0084718u,0x1e0990f0u,0x0a70f009u),\nuvec4(0x19d0f00bu,0xf02e0900u,0xb0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x0a0b10f0u,0x3b2e1b3eu,0xf0f0f0ceu),\nuvec4(0x1b0a10f0u,0x1b0e7b0au,0x08021b0eu,0x0b185b02u),\nuvec4(0x0b1efefeu,0x2b0e1b3eu,0x05172827u,0xf0f00507u),\nuvec4(0x091e09a0u,0x091e80f0u,0x500d40f0u,0x0e091009u),\nuvec4(0xf0f0f009u,0xf0f0c0f0u,0xf0f0f0f0u,0x10f0f0f0u),\nuvec4(0x0e0b3e1bu,0x6e3b0e0bu,0x0a193e3du,0xf0f0f00eu),\nuvec4(0x1e9b0ad0u,0x2b400a2bu,0xfe0b0802u,0x1e3b1efeu),\nuvec4(0x121b1e0bu,0x15170837u,0xb0f0f007u,0x0990f019u),\nuvec4(0x20f00d1eu,0x0d09802du,0xf0f0f0f0u,0xf0f0f0c0u),\nuvec4(0xf0f0f0f0u,0x1b10f0f0u,0x1d0e8b2eu,0x4d5e0d3eu),\nuvec4(0xf0f0f01eu,0x0e1a09c0u,0x0a2b1a2bu,0x1b0a6009u),\nuvec4(0x0b5e1b02u,0x023b9efeu,0x0517186bu,0xf0f0f057u),\nuvec4(0x302910f0u,0x0e0d0e09u,0x2d00f00du,0xf0f0091eu),\nuvec4(0x50f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x0e2b10f0u),\nuvec4(0x3e0d1e8bu,0x2e1b0e1du,0x0e0d0e4du,0xf0f0f00au),\nuvec4(0xf0091ac0u,0x1e1a2b00u,0x0d1efe1bu,0x0b381baeu),\nuvec4(0x27022b02u,0xf0024708u,0x20f0f0f0u,0x0e20092du),\nuvec4(0x4d09e02du,0xf0f0f009u,0xf060f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x6d4e8b10u,0x2d2e1b1eu,0x091e1d1eu),\nuvec4(0xf0f0f0f0u,0x0b0a40f0u,0x1d8e1d7eu,0x02181baeu),\nuvec4(0x08220b18u,0x02074817u,0xf0f0f0f0u,0x090e1d40u),\nuvec4(0x1e0d0910u,0x3d0e09d0u,0xf0f0f009u,0xf070f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x2b0e3b10u,0x1b4e3d5eu),\nuvec4(0x1d0e2d3eu,0xf0f0091eu,0x50f0f0f0u,0x4e0b1e0bu),\nuvec4(0x1e0d2e3du,0x2e0b3e6du,0x0205020bu,0x480b1807u),\nuvec4(0x07020b02u,0xf0f00208u,0x0960f0f0u,0xc02e102eu),\nuvec4(0x094d0e09u,0xf0f0f0f0u,0xf0f070f0u,0xf0f0f0f0u),\nuvec4(0x0af0f0f0u,0x7e1b0e0bu,0x3e3d2e0du,0x1e0b0e0bu),\nuvec4(0x1e0d0e3du,0xf0090e0du,0xf0f0f0f0u,0x6e3d7e40u),\nuvec4(0x2e0b0e9du,0x0208071bu,0x02380207u,0x020b0208u),\nuvec4(0xf0f00208u,0x3e80f0f0u,0x90091e19u,0xf07d0e0du),\nuvec4(0xf0f0f0f0u,0xf0f0f070u,0xf0f0f0f0u,0x0a3bf0f0u),\nuvec4(0x2d2e1d6eu,0x2d0e1d9eu,0x0b0e0d1eu,0xf0f0f002u),\nuvec4(0x6e30f0f0u,0x0e9d3e7du,0x020b3e09u,0x4b183718u),\nuvec4(0xf0f0f0f0u,0x0d1e1db0u,0x29601e09u,0xf0f08d0eu),\nuvec4(0x70f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x7e2b0ae0u),\nuvec4(0x1e4d0eedu,0x0a081e4du,0xf0f0f0f0u,0x6e0910f0u),\nuvec4(0x5e9d2e7du,0x020b1e0bu,0x02182708u,0xf0f0f02bu),\nuvec4(0x1009a0f0u,0x091a3e0du,0x1e0d0e50u,0x19202e6du),\nuvec4(0x19200920u,0xf0f0f0f0u,0xf0f0f080u,0xf0f0f0f0u),\nuvec4(0x0b03d0f0u,0x3e0a0b0eu,0x1b0efdfdu,0xf0f0f008u),\nuvec4(0x0910f0f0u,0xdd0e0b3eu,0x0d5e4d1eu,0x17220b2eu),\nuvec4(0x0a0b0218u,0xf0f0f0f0u,0x1e0d0ee0u,0x600a0e0du),\nuvec4(0x1e5d2e0du,0x19302960u,0xf0f0f0f0u,0xf0f0f080u),\nuvec4(0xf0f0f0f0u,0x01d009d0u,0x4e0a1b02u,0x1d0ebdfdu),\nuvec4(0xf00d0b3eu,0xf0f0f0f0u,0x0e0d7e00u,0x091e3dfdu),\nuvec4(0x1b1e0910u,0x1b28020eu,0xf0f0f00au,0x0e00f0f0u),\nuvec4(0x090a2e0du,0x3d2e1d50u,0x9009202eu,0xf0f0f009u),\nuvec4(0xf0f090f0u,0xf0f0f0f0u,0xd009d0f0u,0x6e0b120bu),\nuvec4(0xf09ecdfdu,0xc0f0f0f0u,0x2e0d2e09u,0x0e0d1e0bu),\nuvec4(0x201b1efdu,0x184b0e09u,0xf0f00e1bu,0x20f0f0f0u),\nuvec4(0x0950094eu,0x0e0d5e1du,0x100d200au,0x2d099029u),\nuvec4(0xf0f0f009u,0xf0f000f0u,0xf0f0f0f0u,0x0bc0f0f0u),\nuvec4(0x0d0b0203u,0x1d1e0d0eu,0xfd0e2d0eu,0x0e0d6e2du),\nuvec4(0xf00a5e0du,0xb0f0f0f0u,0x1d0e1d0eu,0xfd1e1b0eu),\nuvec4(0x101b0e1du,0x0b186b09u,0xf0f0f00eu,0x0d30f0f0u),\nuvec4(0x400a094eu,0x0e0d4e09u,0x2d300e0du,0x80092009u),\nuvec4(0x090d0e09u,0xf0f01930u,0xf0f0a0f0u,0xf0f0f0f0u),\nuvec4(0x0bc0f0f0u,0x2d0a0203u,0x8d1e1d0eu,0x0d0ecd0eu),\nuvec4(0xf0091aeeu,0x90f0f0f0u,0x2e2b2e2du,0x091e0bfdu),\nuvec4(0x021b0a01u,0x0e02083bu,0xf0f0f0f0u,0x5e0d50f0u),\nuvec4(0x3e093009u,0x09203e0du,0x0d19e02du,0x0d1e0d20u),\nuvec4(0xf0f0f019u,0xf0f0f070u,0xf0f0f0f0u,0x1e03d0f0u),\nuvec4(0x0e8d0e2du,0x0d0e2dfdu,0x0ade0d3eu,0xf0f0f0f0u),\nuvec4(0x3e2b4e60u,0x0e0b1eddu,0x024b121bu,0xf0f00b08u),\nuvec4(0x60f0f0f0u,0x0a4e0d09u,0x0a200900u,0x092e2d09u),\nuvec4(0x000e0d20u,0x0009501du,0x0e091039u,0x1d00090du),\nuvec4(0x1d0e0d2eu,0xf0f0f009u,0xf0f0f040u,0xf0f0f0f0u),\nuvec4(0x0b0ac0f0u,0xaefdfd2eu,0x0e0b8e0du,0xf0f0f001u),\nuvec4(0x0b0940f0u,0x5d4e0b3eu,0x0b093d3eu,0x28020b1eu),\nuvec4(0x0a0b023bu,0xf0f0f0f0u,0x3e0970f0u,0x0ea0010au),\nuvec4(0x000e4009u,0x09500d09u,0x8d000d70u,0xf0090d3eu),\nuvec4(0xf010f0f0u,0xf0f0f0f0u,0xb0f0f0f0u,0x0e1d0e1bu),\nuvec4(0x2d0eddfdu,0x0bee0d4eu,0xf0f0f001u,0x1e0940f0u),\nuvec4(0x1e4d6e2bu,0x0b093e0du,0x5b221b1eu,0xf0f0f0f0u),\nuvec4(0x0d0990f0u,0x010a0b0eu,0x100e10f0u,0x10f0090du),\nuvec4(0x0e0a1e09u,0x092d2e1du,0xf0f01980u,0xf0f0f050u),\nuvec4(0xf0f0f0f0u,0x0801b0f0u,0x4dfdfd2eu,0x0b024bfeu),\nuvec4(0xf0f0f00au,0x0e1b20f0u,0x1e0b4e1bu,0x0e0a0e3du),\nuvec4(0x0d092e0bu,0x090e8b1eu,0xf0f0f0f0u,0x0e0db0f0u),\nuvec4(0x10f0010au,0xf00d200eu,0x0a2b0930u,0x60094d1eu),\nuvec4(0x70f0f00du,0xf0f0f0f0u,0xf0f0f0f0u,0x0b0501b0u),\nuvec4(0x0e3d0b0eu,0x1d0efdfdu,0x1b124bbeu,0xf0f0f0f0u),\nuvec4(0x3b6e0920u,0x2b3e0d0eu,0x1e090d2eu,0x1e1b024bu),\nuvec4(0xf0f0f009u,0x29d0f0f0u,0x0e50f0f0u,0x1a0b0930u),\nuvec4(0x0e3d0e1bu,0x0900090du,0x40090e0du,0x20f0f009u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x0e0201c0u,0xfd0e1d0bu),\nuvec4(0x2e0baefdu,0x025b0e0bu,0xf0f0091bu,0x4e20f0f0u),\nuvec4(0x4e0b1e1du,0x000d3e3bu,0x3e026b0du,0xf0f0f0f0u),\nuvec4(0x2e0dd0f0u,0x0a09100au,0x400af0f0u,0x1d1e1a4eu),\nuvec4(0x09a0090eu,0xf010f0f0u,0xf0f0f0f0u,0xd0f0f0f0u),\nuvec4(0x0d0e1b01u,0x0dfdfd0eu,0x1b0e4b5eu,0xf00a9b0au),\nuvec4(0x20f0f0f0u,0x5e0b4e0au,0x5e2b1e0au,0x0b025b09u),\nuvec4(0xf0f0f03eu,0x09e0f0f0u,0x090a5e1du,0x0910f0f0u),\nuvec4(0x1a2e1d0eu,0xf00d0e1bu,0xf0f0e0f0u,0xf0f0f0f0u),\nuvec4(0x2be0f0f0u,0x2d0eedfdu,0x0b2e2b4eu,0x090e9b1eu),\nuvec4(0xf0f0f0f0u,0x0e0d0e30u,0x6e2b9e0bu,0x4b020e09u),\nuvec4(0xf0f0f04eu,0x30f0f0f0u,0x0d3e0d09u,0x0201e0f0u),\nuvec4(0x1e2d091eu,0x1d19000au,0xf009e009u,0xf0f0f0c0u),\nuvec4(0xf0f0f0f0u,0x1b02f0f0u,0x9dfd1e1du,0x0b2e4d0eu),\nuvec4(0x0b0e2b0eu,0x023b0a1eu,0xf0f00e3bu,0x0b40f0f0u),\nuvec4(0x6e0b2e0du,0x1e1b0e0du,0x0e1d0e0bu,0x5e4b0a0du),\nuvec4(0xf0f0f0f0u,0x09c0f0f0u,0x3900190du,0xf0091d30u),\nuvec4(0x1e0d0e20u,0x1d092009u,0xf0c0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x0e0d1b02u,0x4ecd1e9du,0x0e0b2e3du),\nuvec4(0x222b0e4bu,0xf0090e3bu,0x30f0f0f0u,0x0b0e0b09u),\nuvec4(0x098e2b5eu,0x1b0e1b1eu,0x2e0d0b0du,0xf0090e0bu),\nuvec4(0xf0f0f0f0u,0x4019f0f0u,0x50f00e09u,0x1d094031u),\nuvec4(0xf009d009u,0xf0f0f0b0u,0xf0f0f0f0u,0x0200f0f0u),\nuvec4(0x3d1ead1bu,0x0b3e4d2eu,0x0b4e0d1eu,0x0a0e3b0au),\nuvec4(0xf00a0e8bu,0x50f0f0f0u,0x1e1d3e0bu,0x1e1d4e0au),\nuvec4(0x0b1a2e0bu,0x090e0a0eu,0xf0f06e0du,0xf0f0f0f0u),\nuvec4(0x300910f0u,0x2170f00au,0xf0f03950u,0xf0f0f090u),\nuvec4(0xf0f0f0f0u,0x0200f0f0u,0x6d0e0d1bu,0x2d2e6d1eu),\nuvec4(0x4b4e1d6eu,0x5b022b1eu,0xf0f0f00au,0x0b0960f0u),\nuvec4(0x0a1e0d3eu,0x0b5e1d3eu,0x1a0b1e0au,0x2b2e0a09u),\nuvec4(0xf0f00d0eu,0xf0f0f0f0u,0x0af0f0f0u,0xf0f0f001u),\nuvec4(0xf0f0f030u,0xf0f0f0f0u,0x0210f0f0u,0x3e0dfd1bu),\nuvec4(0x1e0d2e1du,0x1e0a1e2du,0x0e8b0a5bu,0xf0f0f0f0u),\nuvec4(0x2b0e0970u,0x2e1a2e0au,0x2e1d1e0du,0x0b0a0d0bu),\nuvec4(0x000d1b0eu,0x090e2b2eu,0xf0f0f0f0u,0xe0f0f0f0u),\nuvec4(0x090a011au,0x0d700120u,0xf0f0f001u,0xf0f0f030u),\nuvec4(0xf0f0f0f0u,0x1210f0f0u,0x2d2ead1bu,0x0d0e2d2eu),\nuvec4(0x2d0e0b0eu,0x5b024b3eu,0xf00e1b1eu,0x80f0f0f0u),\nuvec4(0x4e2b1e0au,0x6e2d0a0bu,0x2b0e0a0du,0x0a3b2e19u),\nuvec4(0xf0f0f0f0u,0xe0f0f0f0u,0x2a3b0a01u,0x0e095009u),\nuvec4(0xf0f0f009u,0xf0f0f030u,0xf0f0f0f0u,0x2220f0f0u),\nuvec4(0x2d5e7d0bu,0x0b0e0d5eu,0x2a1e1d0eu,0x023b024bu),\nuvec4(0x0e1b0e0bu,0xf0f0f009u,0x1e5b70f0u,0x4e1b2e0bu),\nuvec4(0x1e0b0e1du,0x0a2b0e0bu,0x0e0d0e09u,0x0aa00a3bu),\nuvec4(0xf0f0f00bu,0xf0f0f0f0u,0x0a6b0a10u,0x0d0e0960u),\nuvec4(0x30f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x080220f0u),\nuvec4(0x2b0a1b02u,0x2e2d5e3du,0x2e0b0e2bu,0x0a2b0e2bu),\nuvec4(0xf0090eabu,0x80f0f0f0u,0x1a3e4b02u,0x1e0d4e2bu),\nuvec4(0x094b0e1bu,0x900a2b3eu,0xf00b0e09u,0xf0f0f0f0u),\nuvec4(0x0900f0f0u,0x50090a7bu,0x010e0b0au,0x20f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x070120f0u,0x0b023b12u),\nuvec4(0x1e4d4e2du,0x3b025bfbu,0xf0f0090eu,0x0170f0f0u),\nuvec4(0x1b0a3b02u,0x1e0a0e0au,0x1e2b0e2bu,0x0e1b1e1bu),\nuvec4(0x2e0b0a1bu,0x1d0b903bu,0xf0f0f009u,0x90f0f0f0u),\nuvec4(0x01002b01u,0x5009018bu,0xf01a1b0au,0xf010f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x08070130u,0x0b221802u),\nuvec4(0x4e4d2e3du,0x090e7bfbu,0xf0f0f0f0u,0xfb120870u),\nuvec4(0x1e0a3e5bu,0x0e1b0e1bu,0x0a800e1bu,0xf0090d1bu),\nuvec4(0xf0f0f0f0u,0x1b0180f0u,0x320b0802u,0x4b60015bu),\nuvec4(0x09d0f009u,0xf0f010f0u,0xf0f0f0f0u,0x40f0f0f0u),\nuvec4(0x02180201u,0x0b010b18u,0x3e2d1e3du,0x5bfb0e1bu),\nuvec4(0x0d0e0b0eu,0xf0f0f0f0u,0xbb080770u,0x1b0efb02u),\nuvec4(0x60091b3eu,0xf0193b0au,0xf0f0f0f0u,0x022b80f0u),\nuvec4(0x016b4218u,0x0d3b0240u,0x00f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x170160f0u,0x2d0a1228u,0xfbbe0d0eu),\nuvec4(0x0e0b0a1bu,0xf0090e0bu,0x60f0f0f0u,0x1b080501u),\nuvec4(0x1b122b32u,0x6b0a6b02u,0x095e0b0au,0x0b023b50u),\nuvec4(0xf0f0f01du,0x60f0f0f0u,0x121b0109u,0x080b1208u),\nuvec4(0x4b020802u,0x00211b02u,0x0b022b01u,0xe0f0f00au),\nuvec4(0xf0f0f019u,0xf0f0f0f0u,0x0180f0f0u,0x0e1b4807u),\nuvec4(0x1e1b1e0du,0x0e2d0e0du,0x0a1bfb0au,0x0e0b0e0bu),\nuvec4(0xf0f0f009u,0x070160f0u,0x1b521822u,0x6b0a6b02u),\nuvec4(0x3e0b0a0eu,0x2b096009u,0x090e1b02u,0xf0f0f0f0u),\nuvec4(0x1b60f0f0u,0x08024832u,0x1b124b02u,0x4b121102u),\nuvec4(0xf0f0f009u,0xf0f0f0f0u,0xf0f0f0f0u,0x170190f0u),\nuvec4(0x0b122708u,0x3d2e1b1eu,0x2b1a2bfbu,0xf0f0010eu),\nuvec4(0x0160f0f0u,0x08272805u,0x4b221b42u,0x805e5b02u),\nuvec4(0xf00d5b09u,0xf0f0f0f0u,0x483270f0u,0x08321822u),\nuvec4(0x08020822u,0x020b0802u,0x0d0b120bu,0x1db0f0f0u),\nuvec4(0xf0f0f010u,0xf0f0f0f0u,0x07b0f0f0u,0x2b181708u),\nuvec4(0x3d4e0b0du,0x3b0e1bfbu,0xf0f0f00au,0x070880f0u),\nuvec4(0x32080718u,0x320b2208u,0x0a4b023bu,0x4b09904eu),\nuvec4(0xf0f0f01du,0x60f0f0f0u,0x4822880bu,0x1b328802u),\nuvec4(0xf0f0f00du,0xf0f0f0f0u,0xf0f0f0f0u,0x1807b0f0u),\nuvec4(0x0b020827u,0x0a5e1b0eu,0x0e0a2bfbu,0xf00a0e1bu),\nuvec4(0x90f0f0f0u,0x1b121817u,0x0a0b0238u,0x0b127b22u),\nuvec4(0x0ab0092eu,0xf0f01d3bu,0xf0f0f0f0u,0xb8f80150u),\nuvec4(0x090a4b12u,0xf0d0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x170827b0u,0x0e0a0802u,0x1e1b3e2bu,0x2b0e0bfbu),\nuvec4(0xf0f0f00eu,0x2802a0f0u,0x27021b02u,0x020b6218u),\nuvec4(0x020b022bu,0xc00a1e0au,0x090d3b0au,0xf0f0f0f0u),\nuvec4(0x0a20f0f0u,0x9827280bu,0x48029807u,0xf0f00a5bu),\nuvec4(0xf0f0f0c0u,0xf0f0f0f0u,0x08b0f0f0u,0x12070527u),\nuvec4(0x6e2b0e0du,0x091a3bfbu,0xf0f0f0f0u,0x081708b0u),\nuvec4(0x17226812u,0x020b1208u,0x0b0e0a3bu,0x0b09b00au),\nuvec4(0x1e0b0208u,0xf0f0f0f0u,0x1b01f0f0u,0x02b82778u),\nuvec4(0x02181788u,0x50f00a4bu,0xf040f009u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x080508b0u,0x2b1a1827u,0x9b0acb4eu),\nuvec4(0xf0f0f0f0u,0x050702c0u,0x07183208u,0x0a5b5248u),\nuvec4(0x1bb00e0bu,0x0d0e0b12u,0xf0f0f0f0u,0xf80be0f0u),\nuvec4(0x07a81278u,0x0e0b3228u,0x0950f009u,0xf0f030f0u),\nuvec4(0xf0f0f0f0u,0xb0f0f0f0u,0x08270508u,0x0e0d0207u),\nuvec4(0x3e1b0e2bu,0x1a0e2afbu,0xf0f0f0f0u,0x070c04d0u),\nuvec4(0x32782208u,0x0e5b220bu,0x4b099009u,0xf0f0090eu),\nuvec4(0xc0f0f0f0u,0xa832180au,0x0b027807u,0x07080758u),\nuvec4(0x22280728u,0xf0010a1bu,0x20f00950u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x0b67b0f0u,0x0e0a2b0du,0x0a5b4e1bu),\nuvec4(0x0a0e4b0eu,0xf01a0d0eu,0xf0f0f0f0u,0x08070c02u),\nuvec4(0x18027802u,0x0e0a5b52u,0x121ba009u,0xf0f00e0bu),\nuvec4(0xd0f0f0f0u,0x021b0248u,0x023802b8u,0x27580208u),\nuvec4(0x12480708u,0xf0f0094bu,0xf0f0f080u,0xf0f0f0f0u),\nuvec4(0x01a0f0f0u,0x2b0e0a67u,0x4e1a0e0au,0x3b0e1a5bu),\nuvec4(0xf0f00d0eu,0x30f0f0f0u,0x48050c02u,0x0b326807u),\nuvec4(0xa0097b02u,0x0d0e220bu,0xf0f0f0f0u,0x5801c0f0u),\nuvec4(0x4842f822u,0x0b225837u,0xf00a1b02u,0xf0f080f0u),\nuvec4(0xf0f0f0f0u,0xa0f0f0f0u,0x08170501u,0x0a1d0217u),\nuvec4(0x4b9e0a0bu,0xf0091d3eu,0xf0f0f0f0u,0x07050250u),\nuvec4(0x02183748u,0x09cb0208u,0x1b180ba0u,0xf0f0f009u),\nuvec4(0x02c0f0f0u,0x58f80718u,0x58376822u,0x0b024b02u),\nuvec4(0x70f0f00au,0xf0f0f0f0u,0xf0f0f0f0u,0x1701a0f0u),\nuvec4(0x0b081708u,0x0ade0a0du,0xf02d0a3eu,0xf0f0f0f0u),\nuvec4(0x77082780u,0x124b0218u,0x01c00a4bu,0xf00a0b12u),\nuvec4(0xf0f0f0f0u,0x171801d0u,0x2857d8f8u,0x3b0d1b22u),\nuvec4(0x60f0f01au,0xf0f0f0f0u,0xf0f0f0f0u,0x3801a0f0u),\nuvec4(0x1a0b0807u,0x3e0a2e0bu,0x1e0d7e0au,0xf0f0f00du),\nuvec4(0x1790f0f0u,0x22087718u,0x1a0b122bu,0x00f00a0bu),\nuvec4(0xf0f0f001u,0x09f0f0f0u,0xd80208f8u,0x08270537u),\nuvec4(0x3b221807u,0x0d0a1b02u,0xf050f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x081701a0u,0x0e0b0817u,0x2e0a0e0bu),\nuvec4(0x0a0e1b0au,0x0e0d0a1eu,0xf0f04d1au,0x90f0f0f0u),\nuvec4(0x48870c07u,0xf00a2b52u,0xf0f0f0f0u,0x0a10f0f0u),\nuvec4(0x68125802u,0x28122802u,0x15174802u,0x08270507u),\nuvec4(0x1b221807u,0x0d0a2b12u,0xf050f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x080728a0u,0x1e1b0a17u,0x0a0e2b0au),\nuvec4(0x1d0e1a1eu,0xf0f04d1eu,0x90f0f0f0u,0x18270c01u),\nuvec4(0x08121837u,0xf00a2b52u,0xf0f0f0f0u,0x0b20f0f0u),\nuvec4(0xf8029802u,0x171c1718u,0x02283705u,0x0d2b222bu),\nuvec4(0xf050f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x170807a0u),\nuvec4(0x0a080208u,0x1e2b0a2bu,0x1e1d0e0au,0x0e0a0b2au),\nuvec4(0xf0f0f02du,0x17a0f0f0u,0x37081708u,0x18020b12u),\nuvec4(0xf0093b32u,0xf0f0f0f0u,0x0a20f0f0u,0xf802480bu),\nuvec4(0x371c3748u,0x020b1268u,0xf03b020bu,0xf0f050f0u),\nuvec4(0xf0f0f0f0u,0x90f0f0f0u,0x12071809u,0x1b1a0708u),\nuvec4(0x1a1d1b0au,0x1a5b0e1du,0xf0090d0eu,0xf0f0f0f0u),\nuvec4(0x670807b0u,0x22182208u,0xf0f0f04bu,0xf0f0f0f0u),\nuvec4(0x28120b40u,0xf8220812u,0x05171537u,0x18170807u),\nuvec4(0x3b221802u,0xf0090d0au,0xf0f040f0u,0xf0f0f0f0u),\nuvec4(0x90f0f0f0u,0x0807080bu,0x1b0a1b22u,0x0b1a1b0au),\nuvec4(0x0e0a6b0au,0xf0f0092du,0xd0f0f0f0u,0x22085708u),\nuvec4(0x1a2b3208u,0xf0f0f0f0u,0x50f0f0f0u,0x0b020b0au),\nuvec4(0x1b120b02u,0x02180b02u,0x050c37c8u,0x08470507u),\nuvec4(0x0e0d4b52u,0xf050f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x07020190u,0x4b020812u,0x0e2b0a0du,0x0d0a2e7bu),\nuvec4(0xf0f0f0f0u,0x0802e0f0u,0x38071817u,0xf00a3b32u),\nuvec4(0xf0f0f0f0u,0x0960f0f0u,0x025b021bu,0x520b180bu),\nuvec4(0x27056778u,0x12081228u,0xf0f01d4bu,0xf0f0f050u),\nuvec4(0xf0f0f0f0u,0x0b90f0f0u,0x4b023802u,0x1a1b0a0eu),\nuvec4(0x090b1e8bu,0xf0f0f0f0u,0x9801e0f0u,0xf0093b32u),\nuvec4(0xf0f0f0f0u,0x1b70f0f0u,0x022b0802u,0x1218324bu),\nuvec4(0x47082788u,0x021b0228u,0x0d2b0a1bu,0x50f0f009u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x180b90f0u,0x3b02180bu),\nuvec4(0x1b0adb02u,0xf0f0f00au,0x00f0f0f0u,0x5812080bu),\nuvec4(0xf00a3b22u,0xf0f0f0f0u,0x0a80f0f0u,0x526b221bu),\nuvec4(0x0738123bu,0x07081738u,0x022b0228u,0x0e1b0a1bu),\nuvec4(0xf0f0090du,0xf0f0f050u,0xf0f0f0f0u,0x0a90f0f0u),\nuvec4(0x08020802u,0x023b0807u,0x090b0adbu,0xf0f0f0f0u),\nuvec4(0x7220f0f0u,0x092b220bu,0xf0f0f0f0u,0x90f0f0f0u),\nuvec4(0x021b0e09u,0x0a6b0a4bu,0x121b0a40u,0x68121807u),\nuvec4(0x1d0a7b02u,0xf060f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x040b0990u,0x0b122b32u,0x090abb02u,0xf0f0f0f0u),\nuvec4(0x1b30f0f0u,0x28020b02u,0x090a3b02u,0xf0f0f0f0u),\nuvec4(0xa0f0f0f0u,0x120b0d09u,0x0a0d1a2bu,0x09a0091bu),\nuvec4(0x020b122bu,0x1d6b1258u,0xf0f0090eu,0xf0f0f060u),\nuvec4(0xf0f0f0f0u,0x0d90f0f0u,0x020b040bu,0x1e3b322bu),\nuvec4(0xf00d0e6bu,0xf0f0f0f0u,0x121b40f0u,0x0a4b021bu),\nuvec4(0xf0f0f0f0u,0xc0f0f0f0u,0x021b0d09u,0x0e1b0e1bu),\nuvec4(0x09d0090du,0x081b0a2bu,0x1812081bu,0x091d5b02u),\nuvec4(0xf070f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x040a0e90u),\nuvec4(0x6b223b02u,0xf01a4b0eu,0xf0f0f0f0u,0x0a0950f0u),\nuvec4(0xf0390a2bu,0xf0f0f0f0u,0x0df0f0f0u,0x192b0a0eu),\nuvec4(0x00f01900u,0x1b190b0au,0x1b120b02u,0xf01d5b22u),\nuvec4(0xf0f080f0u,0xf0f0f0f0u,0x80f0f0f0u,0x04020e09u),\nuvec4(0x3b023b02u,0x1a6b0e0au,0xf0f0f009u,0x80f0f0f0u),\nuvec4(0xf0f0f009u,0xf0f0f0f0u,0x0d0970f0u,0x60f0090eu),\nuvec4(0x090a0019u,0x223b021bu,0xf0090d5bu,0xf0f080f0u),\nuvec4(0xf0f0f0f0u,0x80f0f0f0u,0x12140e0du,0x0a5b020bu),\nuvec4(0x090b4a0eu,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x0a1920f0u,0x0a1b028bu,0xf0090b0du),\nuvec4(0x700d09f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x0e0970f0u),\nuvec4(0x2204050au,0x0a5b020bu,0xf03e0d0eu,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x0e9b0a60u),\nuvec4(0xf00d0a0du,0x601910f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x021d70f0u,0x2b020804u,0x1e1a8b02u,0xf0f0f009u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x0e60f0f0u),\nuvec4(0x0d0a4b1au,0xf0f01d19u,0xf0501920u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x421d0960u,0x1a1b0aabu,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x2e0a70f0u),\nuvec4(0x0d192e0au,0x20f0f029u,0x40090e09u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x1d0960f0u,0x5b1a4b42u,0xf0f0f01au),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x09a0f0f0u),\nuvec4(0x0e191e0au,0xf0f0090du,0x2d0e0950u,0xf0f01009u),\nuvec4(0xf0f0f0f0u,0x70f0f0f0u,0x04020d0eu,0x2b1a4b22u),\nuvec4(0xf0f0090au,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x1dc0f0f0u,0xf0f02029u,0xf0f0f0f0u),\nuvec4(0x70f0f0f0u,0x2b020a0du,0x1b1a3b12u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0d0e09f0u,0xf0f0300au,0xf0f0f0f0u,0x60f0f0f0u),\nuvec4(0x020b0e09u,0x0a4b023bu,0xf0f0f01bu,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x1e00f0f0u),\nuvec4(0xf0f0f040u,0xf0f0f0f0u,0x0d60f0f0u,0x197b1209u),\nuvec4(0xf0f0090au,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x19001960u,0x2910f0f0u,0x40090e00u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x521960f0u,0xf001022bu),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0d1990f0u,0xf0f00d0eu,0x0a0d1900u,0xf0f0f070u),\nuvec4(0xf0f0f0f0u,0x0960f0f0u,0x121b0200u,0x093b0208u),\nuvec4(0xf0f0f00au,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x80f0f0f0u,0x090e0d09u,0x0900f0f0u,0xf0f0801au),\nuvec4(0xf0f0f0f0u,0x70f0f0f0u,0x422b0301u,0xf0f0f01bu),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xa0f0f0f0u),\nuvec4(0x01f0f029u,0xf0901a02u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0b120b70u,0x0b121812u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x0b1209c0u),\nuvec4(0xf090090au,0xf0f0f0f0u,0xf0f0f0f0u,0x0b000950u),\nuvec4(0x083b0804u,0xf0f01b02u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x02b0f0f0u,0xf0b00a2bu),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x3b121950u,0xf0f00b12u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x09c0f0f0u,0xc01b080bu,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0a1940f0u,0x1b020304u,0xf0f01b02u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x09c0f0f0u),\nuvec4(0xc0092e0du,0xf0f0f0f0u,0xf0f0f0f0u,0x050950f0u),\nuvec4(0x1b021b24u,0xf0f0f009u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xe009e0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x050250f0u,0x0b421814u,0xf0f0f00au),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0c0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x03020940u),\nuvec4(0x22080715u,0x090b0208u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0c0f0u),\nuvec4(0xf0f0f0f0u,0x30f0f0f0u,0x06030b09u,0x02180504u),\nuvec4(0x0a0b0208u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f00100u,0xf0f0f0f0u,0xc0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x030240f0u,0x02280406u,0xf00b020bu),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x10f0f0f0u,0xf0f00103u),\nuvec4(0xf0f0f0f0u,0xb0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x040140f0u,0x08030405u,0x090a1b02u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x40f0f0f0u,0x04060201u),\nuvec4(0xf02b0208u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f010f0u,0xf0f0f0f0u),\nuvec4(0x40f0f0f0u,0x5b040901u,0x0a0ba001u,0xf0f0090bu),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x10f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x090140f0u),\nuvec4(0xb00a2b32u,0xf0f0f009u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf030f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x02041150u,0x012b090au,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f00170u,0xf0f0f0f0u),\nuvec4(0x60f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x040160f0u),\nuvec4(0x01090302u,0xf0f0092bu,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xe0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x030180f0u,0x1b020314u,0x70f0f009u),\nuvec4(0xf0f01201u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f020f0u,0xf0f0f0f0u,0xa0f0f0f0u),\nuvec4(0x1a0b0211u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0e0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x90f0f0f0u,0xf0f0f001u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x40f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf00190f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f040f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x80f0f0f0u,0xf0f0f001u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x50f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x11b0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f010f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x01400190u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0e0u,0xf0f0f0f0u,0xa0f0f0f0u),\nuvec4(0xf0112201u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xe0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0140f0f0u,0x02000100u,0xf0f01224u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xa0f0f0f0u,0xf0f0f001u,0xf0f0f0f0u),\nuvec4(0xf0f0f040u,0xf0f0f0f0u,0x40f0f0f0u,0x03140312u),\nuvec4(0xf0f0f002u,0xf0f0f0f0u,0xf0f0f0f0u,0x02b0f0f0u),\nuvec4(0x01600104u,0xf0f0f0f0u,0xf0c0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x000110f0u,0x24050401u,0xf0f0f003u),\nuvec4(0xf0f0f0f0u,0x00f0f0f0u,0xc0f0f021u,0x0224a001u),\nuvec4(0x21120100u,0x01d021b0u,0x02032403u,0xf0f0f001u),\nuvec4(0xf0f070f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x05040110u),\nuvec4(0xf0140514u,0xf0f0f0f0u,0xf0f0f0f0u,0x040309c0u),\nuvec4(0x04260506u,0xf0f00102u,0x02200120u,0x10012403u),\nuvec4(0x04030251u,0x22030403u,0x21331403u,0x14030b20u),\nuvec4(0x70110406u,0x56140211u,0x16052403u,0x03040604u),\nuvec4(0xf0f01104u,0xf0f090f0u,0xf0f0f0f0u,0xd0f0f0f0u),\nuvec4(0x34051213u,0xf0010415u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x03100160u,0x24020102u,0x140c160cu,0xf0f00102u),\nuvec4(0x04050601u,0x25140506u,0x05267504u,0x05440354u),\nuvec4(0x53941304u,0x05461534u,0x44057604u,0xf0321425u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xd0f0f0f0u,0x04020002u),\nuvec4(0x01034425u,0xf0f0f0f0u,0xf0f0f0f0u,0x020120f0u),\nuvec4(0x03040514u,0x25060514u,0x1c050426u,0x02140514u),\nuvec4(0x02113214u,0x150201e0u,0x060c0504u,0x140516e5u),\nuvec4(0x05164405u,0x640506f4u,0x7415a605u,0x14050435u),\nuvec4(0xf0020405u,0xf0f0e0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x54152401u,0xf0f0f001u,0xf0f0f0f0u,0x702110f0u),\nuvec4(0x36040301u,0x1416050cu,0x26250405u,0x26452c15u),\nuvec4(0x04251405u,0x01900102u,0x253c0604u,0x1506e50cu),\nuvec4(0x25164506u,0x453605e4u,0x357405a6u,0x1625061cu),\nuvec4(0x02030405u,0xf0023124u,0xf0f030f0u,0xf0f0f0f0u),\nuvec4(0x80f0f0f0u,0x00031402u,0x44251411u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x12242201u,0x56040140u,0x0c06050cu),\nuvec4(0x360c3516u,0x550c162cu,0x0344153cu,0x11200102u),\nuvec4(0x0c050402u,0x06e54c15u,0x16850625u,0x0c05d6e4u),\nuvec4(0x54250615u,0x0516f625u,0x12040524u,0xf0d0f011u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x04220130u,0x04132405u),\nuvec4(0x06052c05u,0xf0011405u,0xf0f0f0f0u,0x12040230u),\nuvec4(0x02311031u,0x64310201u,0x21302132u,0x01122402u),\nuvec4(0x13240604u,0x15040311u,0x0c860506u,0x04259c05u),\nuvec4(0x24032475u,0x24020412u,0xa5f54c75u,0xe615d436u),\nuvec4(0x0514050cu,0x960c2544u,0x05660c05u,0x14160524u),\nuvec4(0xf0010405u,0xf0f0f0a0u,0xf0f0f0f0u,0x0130f0f0u),\nuvec4(0x64251402u,0x34050615u,0xf0f0f001u,0x220160f0u),\nuvec4(0x16f54403u,0x94130405u,0x03040203u,0x03040314u),\nuvec4(0x03040304u,0x650c2534u,0x0cc60546u,0x1c661c16u),\nuvec4(0x02032415u,0x2213120bu,0x1c252c25u,0x14c56c05u),\nuvec4(0xd4156655u,0x3435d615u,0x1c861c45u,0x45363506u),\nuvec4(0x060c050cu,0x04020315u,0xf010f051u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x25023120u,0x65340504u,0xf0f0f014u),\nuvec4(0x040240f0u,0x05140c05u,0x351c0506u,0x453c0534u),\nuvec4(0x03242504u,0x03141534u,0x25045594u,0x04030204u),\nuvec4(0x561ce615u,0x051c161cu,0x0224451cu,0x5504421au),\nuvec4(0x65ac052cu,0x15565564u,0x05041544u,0x06f62504u),\nuvec4(0x2504850cu,0x050c260cu,0x051cd526u,0x0516050cu),\nuvec4(0x44120406u,0x01020405u,0xf0f0f0e0u,0xd0f0f0f0u),\nuvec4(0x24053401u,0x34c0f002u,0x44353445u,0xf0f0f0f0u),\nuvec4(0x03141201u,0x05263c06u,0x0504052cu,0x050c152cu),\nuvec4(0x0514650cu,0x25340504u,0x32040344u,0x05040203u),\nuvec4(0x01540504u,0x1cb50402u,0xa4357c35u,0x021b1a02u),\nuvec4(0x4514020bu,0x050c0504u,0x752c363cu,0x35362594u),\nuvec4(0xf60c6524u,0x14351c16u,0x04450425u,0x54450445u),\nuvec4(0x050c2675u,0x02040284u,0xf0f0c001u,0xf0f0f0f0u),\nuvec4(0x0c2504c0u,0x44260c15u,0x11122403u,0x05040190u),\nuvec4(0x10110304u,0x15043501u,0x050c062cu,0xf0f00144u),\nuvec4(0x030170f0u,0x04551402u,0x2c461c05u,0x2c160c05u),\nuvec4(0x95049536u,0x35541334u,0x02040544u,0x84b5f514u),\nuvec4(0x09012203u,0x14131201u,0x14050405u,0x2c465c05u),\nuvec4(0x447584b5u,0x4cf61c25u,0x1445c425u,0x2c455455u),\nuvec4(0x04150c06u,0x34250405u,0xf0f0d012u,0x02a0f0f0u),\nuvec4(0xe0f00103u,0x36350401u,0x15160425u,0x152c0504u),\nuvec4(0x01102104u,0x02040503u,0x05041504u,0x060c3544u),\nuvec4(0x440c1605u,0xf0f0f002u,0x0c450470u,0x066c1506u),\nuvec4(0x060c152cu,0x0c35f51cu,0x1c060c15u,0x04753465u),\nuvec4(0xb5f52435u,0x29114264u,0x1c15a402u,0x2c260c16u),\nuvec4(0x1554f4b5u,0x155cf61cu,0x15740504u,0x9504d514u),\nuvec4(0x6405245cu,0xf0f0e001u,0x3150f0f0u,0x14350c04u),\nuvec4(0x04050605u,0x02030405u,0x04020304u,0x12a03103u),\nuvec4(0x561c2504u,0x0c361504u,0x24151c06u,0x74053403u),\nuvec4(0x44551425u,0x10f0f0f0u,0x02011211u,0x03045504u),\nuvec4(0xf52c7504u,0x0c052ca5u,0x1c058c16u,0xe5f50485u),\nuvec4(0x35c472a4u,0x1c06051cu,0x3544f4b5u,0x2c06f60cu),\nuvec4(0x64050455u,0x250cb5f5u,0x2412350cu,0xf020f011u),\nuvec4(0x3190f0f0u,0x0c152402u,0x06650605u,0x54050405u),\nuvec4(0x34151415u,0x02010405u,0x02040506u,0x23012001u),\nuvec4(0x0c051402u,0x14051415u,0x260c0402u,0x0514151cu),\nuvec4(0x03540524u,0x35042504u,0x0534250cu,0xf0f00104u),\nuvec4(0x950110f0u,0x0445f506u,0x9c950ca5u,0xd5f55c05u),\nuvec4(0xf4f40534u,0xb53c2564u,0x4c3524f4u,0xd4351ce6u),\nuvec4(0x2245f5f5u,0xf040f011u,0x1211d0f0u,0x04033403u),\nuvec4(0x15061506u,0x15042504u,0x050c4504u,0x05e405a4u),\nuvec4(0x55b40514u,0x453c1504u,0x05940544u,0x35344514u),\nuvec4(0xf0010204u,0x0302b0f0u,0xb5542504u,0x55140514u),\nuvec4(0x1415f504u,0x3c050c35u,0x2c252c05u,0x04756495u),\nuvec4(0x54051435u,0xf4033213u,0x551475a4u,0x3c3544f4u),\nuvec4(0xf5f54ce6u,0x1403c465u,0x40f02102u,0x01a0f0f0u),\nuvec4(0x16150403u,0x05042605u,0x050c0526u,0x051c0514u),\nuvec4(0x1c250c06u,0x1514f405u,0x75260504u,0xc5740564u),\nuvec4(0x250405d4u,0x031425e4u,0xf0f00102u,0x13121130u),\nuvec4(0x05044594u,0xf50c3564u,0x052c15f5u,0x150c151cu),\nuvec4(0x65d4651cu,0xf4f40374u,0x25040504u,0x7504f4f4u),\nuvec4(0x2504b5bcu,0x15149514u,0x45241504u,0xf00114f4u),\nuvec4(0x41e0f070u,0x04020130u,0x56051c25u,0x0c054c95u),\nuvec4(0x1403c425u,0x14252435u,0x14050415u,0x34453405u),\nuvec4(0x84850405u,0x0203a425u,0x5213e403u,0x01a0f011u),\nuvec4(0x03240312u,0x04f40324u,0xf5f50425u,0x650c050cu),\nuvec4(0x4445f52cu,0x041564f5u,0x84f4f425u,0xf574f403u),\nuvec4(0x44050405u,0xf4258405u,0x15943514u,0x01130224u),\nuvec4(0xa0f060f0u,0x24053631u,0x96251405u,0x14150405u),\nuvec4(0x25e4f495u,0x073425d4u,0xf4130403u,0x12040374u),\nuvec4(0x54030204u,0x1203e213u,0x12215001u,0x32012031u),\nuvec4(0x23042394u,0x050465a4u,0x05042504u,0x06c5f536u),\nuvec4(0x84c5f50cu,0x14b51c65u,0xf4f4f415u,0x0504f574u),\nuvec4(0x34f4f4f4u,0x11020435u,0x02100112u,0x14050405u),\nuvec4(0x12034415u,0x03842001u,0x24021192u,0x06154455u),\nuvec4(0xf4b50405u,0x55d4f4f4u,0x03021384u,0x03740234u),\nuvec4(0xf2140284u,0x34021192u,0x01630223u,0x32133412u),\nuvec4(0xe4136423u,0x04c51cb5u,0x06b51405u,0xf50c051cu),\nuvec4(0x0c2524f4u,0xf4e50c16u,0xc5b4f4f4u,0x05840504u),\nuvec4(0x7405f4f4u,0x14250405u,0x02032405u,0x14031201u),\nuvec4(0x0c051405u,0x2c25a506u,0x04050485u,0xf4051635u),\nuvec4(0x0544f4f4u,0xa5f445d4u,0x440322f4u,0x22030413u),\nuvec4(0x03e2f213u,0x04124344u,0x03640203u,0x02040312u),\nuvec4(0x04022364u,0x24233403u,0x2c053403u,0xf56475f5u),\nuvec4(0x1524f485u,0xf4f4f4f4u,0x0504d5f4u,0x45240514u),\nuvec4(0xf415e4f4u,0x15348534u,0x25241504u,0x85043514u),\nuvec4(0xf4f40524u,0xf4f403a4u,0x0594f455u,0x22240374u),\nuvec4(0x04033403u,0xf2033203u,0x243211b2u,0x12242305u),\nuvec4(0x04035403u,0xa4031203u,0x04031403u,0x54030413u),\nuvec4(0x1c050432u,0x04550485u,0xa534f435u,0xf4f4f4f4u),\nuvec4(0x1514f4f4u,0x2415f534u,0xf4350405u,0x250425f4u),\nuvec4(0x04220334u,0xf4556413u,0xc4f435e4u,0x24130403u),\nuvec4(0xf4f40203u,0x44f4f4f4u,0xf2131433u,0x13c20432u),\nuvec4(0x24335422u,0x32434403u,0x04130403u,0x13040223u),\nuvec4(0x54120312u,0x34453435u,0xf4351405u,0xf4f4f4f4u),\nuvec4(0x74f4f4f4u,0x840504f5u,0xe4f4f405u,0x11121405u),\nuvec4(0x94f41312u,0x0384f4f4u,0x541332f2u,0xf4f4f413u),\nuvec4(0xf203b4f4u,0x03621332u,0x03b45312u,0x12012322u),\nuvec4(0x04630203u,0x24030403u,0x32030203u,0x350c6524u),\nuvec4(0xf4f41504u,0xf4f4f4f4u,0x44f4f4f4u,0x34050435u),\nuvec4(0xf4f4f405u,0x130413b4u,0x24030402u,0xf4d4f403u),\nuvec4(0x033453f4u,0x32f20302u,0xf4032433u,0xa4f4f4f4u),\nuvec4(0x24037213u,0x234453f3u,0x22210234u,0x02130453u),\nuvec4(0x94134463u,0x0c750405u,0x04151c15u,0xf4f4f425u),\nuvec4(0xf4f4f4f4u,0xf405f4f4u,0x140564f4u,0x0394f405u),\nuvec4(0x24030284u,0xf4130403u,0x73c4f444u,0x03122304u),\nuvec4(0x140322f2u,0xf4134403u,0xa4f4f4f4u,0x24034433u),\nuvec4(0x020302d3u,0x04030203u,0x04134403u,0x12210213u),\nuvec4(0x44031203u,0xf4232403u,0x050465b4u,0xf4f4f4f4u),\nuvec4(0xf4f4f4f4u,0x04f4f4f4u,0xf4359445u,0x032413a4u),\nuvec4(0x13120112u,0x23d47304u,0x13040304u,0xf3f41304u),\nuvec4(0x245324a3u,0x84f4f453u,0x0384f425u,0x03049304u),\nuvec4(0x23322374u,0x05640342u,0x02f20334u,0xf4f4f4f4u),\nuvec4(0xf4f4f4f4u,0xf4f4f4f4u,0xf435e4f4u,0x223364f4u),\nuvec4(0x12040314u,0x12030213u,0xf3435463u,0x54739473u),\nuvec4(0x14134483u,0xf4130413u,0x24f4f4f4u,0x0302f203u),\nuvec4(0x53022354u,0x01020304u,0x24f40204u,0x64037243u),\nuvec4(0x24f41302u,0x54038403u,0x04231473u,0xf4f4f433u),\nuvec4(0xf4f4f4f4u,0xf4f4f4f4u,0x0374f4f4u,0x23020332u),\nuvec4(0x33142302u,0x03122304u,0x63220322u,0xf3040314u),\nuvec4(0x030493f3u,0xc4f42304u,0xa4130213u,0x04252405u),\nuvec4(0x23727425u,0x03340344u,0x03140304u,0x04432112u),\nuvec4(0xf4032403u,0x137405d4u,0xf4030204u,0x02140274u),\nuvec4(0xf4f41204u,0xf4f4f4f4u,0x94f4f4f4u,0x02035403u),\nuvec4(0x74f4f413u,0x4244f465u,0x02131231u,0x43041214u),\nuvec4(0x22110314u,0x13023413u,0xd4120302u,0x343332a3u),\nuvec4(0x94032403u,0x04131403u,0x04037403u,0xf4f4f413u),\nuvec4(0x030443e4u,0x03840314u,0x040524f4u,0x54051485u),\nuvec4(0x14053415u,0xd4150455u,0xf4032403u,0xf4f4f4f4u),\nuvec4(0xf4f4f4f4u,0xf4f4f4f4u,0x034475f5u,0x03220312u),\nuvec4(0x03020312u,0x0c4584a4u,0x02031425u,0x02040201u),\nuvec4(0x21030403u,0x03320102u,0x13020302u,0x05241214u),\nuvec4(0x13b40504u,0x13040304u,0x94f45544u,0x06050485u),\nuvec4(0x15060504u,0x13c405d4u,0x14f47304u,0x04050405u),\nuvec4(0x04052405u,0x06050465u,0x0504150cu,0x042584f4u),\nuvec4(0xf4251435u,0xf4f4f4f4u,0xf4f4f4f4u,0xd4f4f4f4u),\nuvec4(0x04050425u,0x050495f5u,0x135405b4u,0x24040314u),\nuvec4(0x2413d4a5u,0x04232415u,0x06043312u,0xf4f41504u),\nuvec4(0x1c1514f4u,0x05760c06u,0x15045506u,0x15140504u),\nuvec4(0x13542554u,0x23040304u,0xf4f40304u,0xa5145514u),\nuvec4(0x15043524u,0x45c46504u,0x45041504u,0xf4f42514u),\nuvec4(0xf4f4f4f4u,0xf4f4f4f4u,0xf5f5c4f4u,0xf544f475u),\nuvec4(0x252435f5u,0x65045504u,0x450405f4u,0xa5740534u),\nuvec4(0x061c060cu,0x16050c15u,0x35f50c15u,0x34f4f4f4u),\nuvec4(0xf5f504e5u,0x260516c5u,0xf4b50615u,0xf4f4f4f4u),\nuvec4(0xf5f5f5b4u,0x34f4f455u,0x14c5f5f5u,0xf5ec95a5u),\nuvec4(0x4cf50c95u,0x64b53c25u,0x3c752495u,0xa5f5f5f5u),\nuvec4(0x1c55f50cu,0x4c060ce5u,0xa6f61c16u,0x34e5f50cu),\nuvec4(0x04350405u,0x0415f5f5u,0xf5f50405u,0xd5f5f5f5u),\nuvec4(0xf5f5e4f4u,0x050c15d5u,0x057c152cu,0xfcfc051cu),\nuvec4(0x25fc158cu,0x04f5f52cu,0x2c45b475u,0xf5f51cb5u),\nuvec4(0xf67c251cu,0xf60c35e6u,0x363c066cu,0x35dc15ccu),\nuvec4(0x061c153cu,0x051c852cu,0x350c254cu,0xf50c650cu),\nuvec4(0xf5f5f5f5u,0xf5f5f5f5u,0x650c152cu,0xfcfcfc1cu),\nuvec4(0x9c06acfcu,0xf65cfcc6u,0xf6f61ce6u,0xf61c66f6u),\nuvec4(0x0c169cc6u,0xfcfcfc16u,0x550c157cu,0xfcfcd59cu),\nuvec4(0xfcfcfcfcu,0xfcfcfcfcu,0x0000007cu,0x00000000u));\nconst int lines[] = int[](\n0,32,64,96,128,160,192,224,256,288,334,385,461,539,623,718,805,895,982,1077,1185,1291,1376,1450,1544,1643,1754,1869,1984,2118,2267,2422,2594,2725,2880,3019,3150,3276,3383,3512,3641,3766,3877,3986,4082,4190,4303,4412,4505,4604,4692,4780,4889,4990,5086,5188,5296,5395,5501,5609,5712,5819,5945,6075,6204,6339,6469,6596,6728,6843,6981,7098,7223,7352,7474,7615,7767,7882,7997,8113,8220,8327,8435,8527,8654,8758,8869,8977,9085,9202,9316,9435,9557,9665,9770,9866,9961,10060,10161,10245,10337,10413,10492,10571,10651,10725,10807,10884,10970,11047,11128,11217,11314,11403,11497,11591,11676,11754,11820,11894,11965,12036,12107,12175,12250,12325,12388,12457,12525,12594,12662,12746,12821,12905,12979,13053,13124,13200,13271,13338,13405,13483,13557,13629,13697,13773,13845,13924,14000,14079,14150,14220,14305,14388,14465,14532,14599,14673,14747,14814,14892,14969,15038,15108,15172,15243,15323,15395,15470,15546,15623,15693,15760,15829,15895,15965,16035,16098,16158,16212,16264,16315,16364,16414,16458,16502,16545,16592,16637,16686,16727,16771,16815,16856,16900,16940,16979,17022,17068,17112,17154,17194,17236,17275,17316,17356,17398,17434,17466,17498,17530,17564,17598,17632,17664,17696,17728,17762,17797,17832,17873,17915,17970,18054,18130,18214,18298,18383,18485,18587,18697,18810,18922,19030,19135,19239,19340,19441,19538,19638,19734,19820,19912,19988,20063,20137,20215,20283,20356,20448,20533,20639,20719,20781,20837,20909,20953);\n\nconst int WIDTH = 512;\nconst int HEIGHT = 256;\n\nconst vec3 colors[] = vec3[](\nvec3(0x10,0x10,0x30),\nvec3(0x30,0x30,0x40),\nvec3(0x70,0x60,0x60),\nvec3(0x70,0x80,0x80),\nvec3(0xa0,0xa0,0xa0),\nvec3(0xd0,0xc0,0xa0),\nvec3(0xe0,0xe0,0xe0),\nvec3(0xb0,0x90,0x70),\nvec3(0x90,0x70,0x50),\nvec3(0x20,0x30,0x20),\nvec3(0x30,0x50,0x30),\nvec3(0x50,0x50,0x30),\nvec3(0xe0,0xd0,0xb0),\nvec3(0x30,0x40,0x10),\nvec3(0x30,0x50,0x10));\n\nvec3 getcolor(int i) {\n  return colors[i%colors.length()]/255.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  float ires = iResolution.x*10000.0 + iResolution.y;\n  if (fragColor.w == ires) return; // Check for resize\n  fragColor.w = ires;\n  // wraparound at edges to avoid mipmap discontinuities\n  int row = int(fragCoord.y)%HEIGHT;\n  int col = int(fragCoord.x)%WIDTH;\n  //if (row >= HEIGHT || col >= WIDTH) return;\n  int rstart = lines[row];\n  int rend = lines[row+1];\n  int c = -1;\n  int colcount = 0;\n  for (int index = rstart; index < rend; index++) {\n    int i = index;\n    uvec4 entry = data[i/16];\n    i %= 16;\n    uint t = entry[i/4];\n    i %= 4;\n    t >>= 8*i;\n    int count = (int(t >> 4)&15)+1;\n    colcount += count;\n    if (col < colcount) {\n      c = int(t)&15;\n      break;\n    }\n  }\n  if (c >= 0) fragColor.rgb = getcolor(c);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 118, 118, 139], [140, 140, 160, 160, 174], [176, 176, 207, 207, 416], [418, 418, 448, 448, 871], [873, 873, 911, 911, 1025], [1027, 1058, 1088, 1088, 1133], [1135, 1135, 1173, 1173, 2210], [2214, 2214, 2268, 2268, 2759]]}
{"id": "NsVczy", "name": "RLE Earth", "author": "mla", "description": "The Earth, 512x256, run length encoded from a 16-color GIF. Original image by NASA.", "tags": ["earth", "runlengthencoding"], "likes": 11, "viewed": 526, "published": 3, "date": "1655110651", "time_retrieved": "2024-07-30T16:44:35.351635", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// RLE Earth. mla, 2022\n//\n////////////////////////////////////////////////////////////////////////////////\n// Fill the window with an irregularly sized image from buffer.\n////////////////////////////////////////////////////////////////////////////////\n\nconst float WIDTH = 512.0;\nconst float HEIGHT = 256.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord/iResolution.xy;\n  if (iMouse.z > 0.0) uv -= (iMouse.xy-0.5*iResolution.xy)/iResolution.xy;\n  uv.y = 1.0-uv.y;\n  if (WIDTH <= iResolution.x) uv.x += 0.05*iTime;\n  uv = fract(uv);\n  uv.x *= WIDTH/max(WIDTH,iResolution.x);\n  uv.y *= HEIGHT/max(HEIGHT,iResolution.y);\n  vec3 col = texture(iChannel0,uv).rgb;\n  col = pow(col,vec3(0.6));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 16 color GIF, cropped, run length encoded and packed into an array of uvec4s\n// Upper 4 bits of each byte is the runlength-1 (we don't need 0 length runs,\n// obviously), lower 4 bits is the color index.\n//\n// Original image by NASA.\n//\n// Does basic coloring here rather than in Image tab to get the benefit\n// of texture filtering.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst uvec4 data[] = uvec4[](\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf07110f0u,0x023120f0u),\nuvec4(0x13010211u,0x45360514u,0xf0110334u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f040f0u),\nuvec4(0xf0f0f0f0u,0x1140f0f0u,0x15040320u,0x64d60506u),\nuvec4(0x3102d021u,0x05262402u,0x66f60506u,0xf0021405u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x031201c0u,0x05360524u),\nuvec4(0x25c60506u,0x03040576u,0x36051422u,0x04050304u),\nuvec4(0x05360403u,0x15f61304u,0x02044524u,0x00012401u),\nuvec4(0x01200102u,0x11120312u,0xf0f0f0f0u,0x1130f0f0u),\nuvec4(0xf0f01130u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f050u),\nuvec4(0xf0f0f0f0u,0x03020170u,0x04110204u,0x04052605u),\nuvec4(0xb6356605u,0x01121405u,0xf6f60322u,0x030456f6u),\nuvec4(0x04058604u,0xf0f00103u,0x80f0f0f0u,0x02114001u),\nuvec4(0x01020304u,0x11101100u,0xf0f00102u,0x01202110u),\nuvec4(0xf0010302u,0xf0f0f0f0u,0xf060f0f0u,0xf0f0f0f0u),\nuvec4(0x0150f0f0u,0x04460504u,0x12040312u,0x05540224u),\nuvec4(0x020405a6u,0xf6040311u,0x16f6f6f6u,0x04050405u),\nuvec4(0xf0f00102u,0x101100f0u,0xf0010011u,0x330201c0u),\nuvec4(0x00010304u,0x03241221u,0x00032401u,0x30f00112u),\nuvec4(0x0100f001u,0xf0015604u,0xf0f0f0f0u,0xf040f0f0u),\nuvec4(0xf0f0f0f0u,0x0100f0f0u,0x01100102u,0x46051402u),\nuvec4(0x12012204u,0x04131807u,0x24154605u,0x21401203u),\nuvec4(0xf6f6f603u,0x040215d6u,0x70f0f002u,0x01020301u),\nuvec4(0x02000109u,0x04030214u,0x01046615u,0x2011b0f0u),\nuvec4(0x30010001u,0xf0110021u,0x0201b0f0u,0x05040214u),\nuvec4(0x05041504u,0xf0f00104u,0xf0f0f0f0u,0xf0f000f0u),\nuvec4(0xf0f0f0f0u,0x05140180u,0x11701204u,0x05140322u),\nuvec4(0x120a4206u,0x16040207u,0x22031405u,0x05023160u),\nuvec4(0xe6f6f6f6u,0x00020405u,0x70f0f002u,0x06050201u),\nuvec4(0x02030405u,0x03042604u,0x11022102u,0xf0f0f0f0u),\nuvec4(0x0210f0f0u,0x06040224u,0x14020105u,0xf0f01112u),\nuvec4(0xf0f0f0f0u,0xf0f0f090u,0x02e0f0f0u,0x04050403u),\nuvec4(0x13014002u,0x02280204u,0x22070400u,0x03020110u),\nuvec4(0x0b112204u,0x04030402u,0x05660312u,0x01100104u),\nuvec4(0xf6f61544u,0x0406f6f6u,0xf0010311u,0x031190f0u),\nuvec4(0x12010a04u,0x01031604u,0xf0020402u,0xf0f0f0f0u),\nuvec4(0x0201c0f0u,0x11002435u,0xf0f0f0f0u,0xf060f0f0u),\nuvec4(0xf0f0f0f0u,0x01001180u,0x15040103u,0x02400104u),\nuvec4(0x00112001u,0x12111011u,0x09300201u,0x03220b20u),\nuvec4(0x07030b02u,0x50010246u,0x14031201u,0xf6f61405u),\nuvec4(0x2203e6f6u,0xf0f00100u,0x031209b0u,0x01040504u),\nuvec4(0x14030220u,0xf0f0f001u,0xe0f0f0f0u,0xf0110211u),\nuvec4(0xf0f0f0f0u,0xf0f080f0u,0x30f0f0f0u,0x04030201u),\nuvec4(0x00011807u,0x30114011u,0x20113011u,0x03140201u),\nuvec4(0x02212002u,0x0c050304u,0x0c171415u,0x01140605u),\nuvec4(0x25140380u,0xf6f6f604u,0x220304d6u,0xd0f0f004u),\nuvec4(0x06040201u,0xf0f0f003u,0x130140f0u,0x40f0f002u),\nuvec4(0x40110201u,0x0803020bu,0x01001132u,0xf0f01100u),\nuvec4(0xf0f0f0f0u,0xf0f0f000u,0x4200f0f0u,0x1102010bu),\nuvec4(0x01102122u,0x00010307u,0x05031001u,0x04050104u),\nuvec4(0x01051605u,0x03240100u,0x03040516u,0x51030231u),\nuvec4(0xb0010214u,0x15060301u,0x03140504u,0xf6f6f614u),\nuvec4(0x01120466u,0xf0f00100u,0xf0f0f0f0u,0x142311e0u),\nuvec4(0x04051605u,0x20f0f003u,0x02112211u,0x121b022bu),\nuvec4(0x13020708u,0xf0014217u,0x200920f0u,0xf0f0f001u),\nuvec4(0xf0f0f050u,0x0160f0f0u,0x05081200u,0x0b081704u),\nuvec4(0x07081201u,0x00020708u,0x05041321u,0x02010c16u),\nuvec4(0x01050403u,0x05260200u,0x04220413u,0x02141615u),\nuvec4(0x0301b0f0u,0x26f6f6f6u,0x00010224u,0xf0f0f001u),\nuvec4(0x90f0f0f0u,0x36050201u,0xf0011214u,0x11900160u),\nuvec4(0x12080722u,0x3208721bu,0xf01b7208u,0x4b0001e0u),\nuvec4(0x0a020605u,0x09100a0bu,0xf0e0f0f0u,0xf0f0f0f0u),\nuvec4(0x3b1221a0u,0x40011041u,0x01020102u,0x05040100u),\nuvec4(0x15010016u,0x460c0416u,0x05260405u,0x01d0f001u),\nuvec4(0xf6f6f603u,0x12040506u,0xf0f0f021u,0x70f0f0f0u),\nuvec4(0x14260401u,0x20f0f001u,0x08328b01u,0xab321b42u),\nuvec4(0xf0f0010au,0x03022a20u,0x09300122u,0x90f0f03au),\nuvec4(0xf0f0f0f0u,0x1b022be0u,0x0112010au,0x020180f0u),\nuvec4(0x12011001u,0x20210203u,0x80f0f021u,0xf6f60501u),\nuvec4(0x221504b6u,0xf0f0f011u,0x80f0f0f0u,0x01022401u),\nuvec4(0x0940f0f0u,0x38026b0au,0x6b222b12u,0x090a4b02u),\nuvec4(0xf0f01a0du,0xf0f00960u,0xf0f060f0u,0x6be0f0f0u),\nuvec4(0x70110b42u,0x20012411u,0x13270201u,0x0c052611u),\nuvec4(0x01100405u,0x02041504u,0x07040201u,0x01440203u),\nuvec4(0x0501c0f0u,0x0556f6f6u,0x010a4224u,0xf0f0f0f0u),\nuvec4(0x0980f0f0u,0x01021302u,0x501110f0u,0x0a094009u),\nuvec4(0x8b527bfbu,0x3b1a4b0au,0x0a40091au,0xf0291a1bu),\nuvec4(0x0a1b0900u,0x30f0f0f0u,0xf0f0f0f0u,0x0b12dbd0u),\nuvec4(0x01121112u,0x20011817u,0x02010203u,0x020b0218u),\nuvec4(0x0a081301u,0x02100102u,0x00041506u,0x11270822u),\nuvec4(0x02040312u,0x09a0f001u,0xf6f6030au,0x03140546u),\nuvec4(0xf0020b22u,0xf0f0f0f0u,0x080b90f0u,0xf00a0304u),\nuvec4(0x0a2b0a10u,0x30191009u,0xfbfb1009u,0x4b0a8bfbu),\nuvec4(0x1d0a0b1au,0xf049e009u,0xf020f0f0u,0xc0f0f0f0u),\nuvec4(0x01223b01u,0x08024b00u,0x01022832u,0x400b0218u),\nuvec4(0x07020b09u,0x0b010b18u,0x05400103u,0x0a01151cu),\nuvec4(0x0827020bu,0x05160432u,0x90f00104u,0x04020b0au),\nuvec4(0x1516f6f6u,0x12240504u,0xf0f0f001u,0x70f0f0f0u),\nuvec4(0xf0320a09u,0x094b0910u,0x0b0a0900u,0x0b022b0au),\nuvec4(0x0a00090au,0x5bfb023bu,0xfb025b3au,0x0d1b027bu),\nuvec4(0x7b0ac009u,0xf01a2b0au,0x0a1ba0f0u,0xf0f0f0f0u),\nuvec4(0x20112bc0u,0x08222b0au,0x0b121802u,0x500a1b22u),\nuvec4(0x00010201u,0x1b020b01u,0x04023002u,0x021a0827u),\nuvec4(0x02081718u,0x04020348u,0xf0021402u,0x02112950u),\nuvec4(0x0305f6f6u,0x04182214u,0xf0f0f0f0u,0x0980f0f0u),\nuvec4(0xe00a2b0au,0x095b0a01u,0x090abb0au,0x0a1e9aebu),\nuvec4(0x0acb120bu,0x0e2b0e3bu,0x096b022bu,0x5d1a0b20u),\nuvec4(0x0b0a0d0eu,0x3e0a6b1au,0x60f0f009u,0x09b0f00au),\nuvec4(0x097a090au,0x0900f0f0u,0x4b0a01d0u,0x1b220b12u),\nuvec4(0x010a3b02u,0x02080170u,0x010b020bu,0x2b420b30u),\nuvec4(0x0b0a3b02u,0x07080712u,0x03341304u,0x0a30f001u),\nuvec4(0xe6f60221u,0x12040204u,0x040b0a10u,0xf0f0f001u),\nuvec4(0x090a29d0u,0x0a0b090au,0xf0f00a0bu,0x012a0110u),\nuvec4(0x098b01b0u,0xbb1dab0au,0xfb1a7e0au,0x0a0e4a0bu),\nuvec4(0x0aab0a7eu,0x2e2b0e1bu,0x4b4afb2au,0xc0f00a0du),\nuvec4(0x1a0970f0u,0x3a8b2a9bu,0x0e59c009u,0x0a100a0bu),\nuvec4(0x08220b90u,0x20011bfbu,0x015b0011u,0x0b0a2150u),\nuvec4(0x1a010a01u,0x2b0a011bu,0x05060502u,0x12240203u),\nuvec4(0x120b10f0u,0x040b010au,0x0514d6f6u,0x01030526u),\nuvec4(0x90f0f0f0u,0x0b0e1a49u,0x2e0a1b0au,0x0900090au),\nuvec4(0x0940f0f0u,0x0a80090au,0x0a3b0a0bu,0x0a1b090du),\nuvec4(0x1e1a1e8bu,0x4b0e9b2au,0x0efedb22u,0x1b0e1d0au),\nuvec4(0x2b0a0b0au,0x1e1bfb0au,0x0b0aeb0du,0x090aa009u),\nuvec4(0x010a0900u,0x60f04059u,0x0a7bfb09u,0x2a190a8bu),\nuvec4(0x0e1d0a3du,0x1a1b0e0au,0x122b0a0bu,0x10090a0bu),\nuvec4(0x7b1a0b01u,0x4b0a091au,0x193b0a31u,0x091b1a0bu),\nuvec4(0x01300100u,0x101b021bu,0x0b010a11u,0x0b023b1au),\nuvec4(0x02140702u,0x0910f001u,0x02011001u,0x0516f6f6u),\nuvec4(0xf0f00103u,0x2d0990f0u,0x4d5e2b0au,0x10f0393eu),\nuvec4(0x0ae00a0bu,0x30090a3bu,0x1e0a0b1au,0x091a0009u),\nuvec4(0x1b4e8b1au,0x0d0a0e0au,0xab1afb0au,0x0b2a2e1au),\nuvec4(0x3e1d5e0au,0x0d0a5b0au,0x0d1ecb2eu,0x0d1e0b1eu),\nuvec4(0x3d7e0d0eu,0x10090a8bu,0x1b090aabu,0xfb0af009u),\nuvec4(0x0a9b3abbu,0x1d0e0d0eu,0x124b8d0eu,0x0a0b025bu),\nuvec4(0x3a392a09u,0x00091019u,0x0a090019u,0x0a191a0bu),\nuvec4(0x021b0a3bu,0x091b3220u,0x0a010031u,0x024b1a01u),\nuvec4(0x20f00123u,0x86f60b29u,0x04152605u,0xf0010203u),\nuvec4(0x0990f0f0u,0x6e3a091du,0x801a3ebdu,0x0a197019u),\nuvec4(0x0a0d1e2du,0x0a0e1d0eu,0x00090a6bu,0x2a0b0a0eu),\nuvec4(0x1b0a0009u,0x2a0e0b19u,0x0a0e0a1bu,0x0b0e0d0eu),\nuvec4(0x3a3d0e0au,0x0a2b0a2bu,0x0d0e0d1eu,0x0a5b1a4eu),\nuvec4(0x1d5e1a4eu,0x4b0a0d3eu,0x4d9e6b6eu,0x0d1e5d0eu),\nuvec4(0x4bfb0a2eu,0x094b2b02u,0x0b0a09e0u,0x2e7aab0au),\nuvec4(0x2e1d2e0au,0x0b1a1e1du,0xab0a0dfdu,0x1910190au),\nuvec4(0x0900090au,0x2b6a4b0au,0x0b026b1au,0x0b0a000au),\nuvec4(0x510a2b12u,0x0b020b12u,0x122b0a01u,0x02041507u),\nuvec4(0x023ae011u,0x210476f6u,0xf0f0f0f0u,0x1b1a0d09u),\nuvec4(0x4e6dfd0eu,0x2e40090du,0x4e191009u,0x3e0a8e0du),\nuvec4(0x0e5a0e4bu,0x0b0a0009u,0x0d090a0eu,0x0b3e1a0eu),\nuvec4(0x090e0d1eu,0x1a0b0e0du,0x0e0a0b2eu,0x0e0a1b0au),\nuvec4(0x0e0a0e0au,0xbb2a2e0du,0x6e0a1e0au,0x0a1d3e0du),\nuvec4(0x3e1a2e2bu,0x1e0a0e4bu,0x3e0d0e0du,0x0e0a0e0au),\nuvec4(0x2e2d2e0du,0x0e0a0b0au,0x2b1a0e0au,0x0802db0au),\nuvec4(0x096b1b02u,0x4ac00900u,0x2a1e0a1eu,0xfd0a5d0eu),\nuvec4(0x09cd0b1du,0x0a6b6a3du,0x0b0a095bu,0x0a8bfb1au),\nuvec4(0x0140016bu,0x0a1b311au,0x0c04220bu,0x0a020406u),\nuvec4(0x1b09a011u,0xf6020b0au,0xf0f00266u,0x0920f0f0u),\nuvec4(0xfd0e3b0du,0x3e6d092du,0x1d092009u,0x4b6efe29u),\nuvec4(0x0d3e0d0eu,0x1b1a0009u,0x0d2e0d0eu,0x0a9e0d7eu),\nuvec4(0x0b0a0b2eu,0x2b2e1a7eu,0x0b0a0b1au,0x3e0d6e5au),\nuvec4(0x0a1b0a1du,0x0a0e1a2eu,0x1a9e4b2eu,0x4e0a5e0bu),\nuvec4(0x02eb8e0bu,0x1b024b3bu,0x50093b0au,0x0d200a19u),\nuvec4(0x1b0a1e0au,0x1e0d1e0au,0x1e5d2e0du,0x0b3d1e4du),\nuvec4(0x1039dd1eu,0x5b5a0e39u,0xfb1a3b1au,0x0a2b0a2bu),\nuvec4(0x601a0b09u,0x1b110029u,0x01000b02u,0x0304034au),\nuvec4(0xa0010314u,0x0b12030bu,0x0504f605u,0xe0011406u),\nuvec4(0x09700109u,0x0970f0f0u,0x4dfd0e3bu,0x10090d09u),\nuvec4(0x10094d19u,0x5e5d1009u,0x5e0d2e0du,0x0a0b1e1du),\nuvec4(0x0d098d0eu,0x1b0e1b0eu,0x4e0d4e0du,0x4a7efe2du),\nuvec4(0x1aae0a6bu,0x0d3e0d0eu,0x0a3e2b0au,0x0a1e0a0bu),\nuvec4(0x2a2e0a4bu,0x1b6e0a8eu,0x0b2e0b2eu,0x022bfb0eu),\nuvec4(0x01ab000au,0x1a5b0a20u,0x7e0d0e3bu,0x3e3d0e0au),\nuvec4(0x0e3d0e0du,0x4e2d2e0bu,0x6d1930cdu,0xbb2acb4au),\nuvec4(0x010a1b1au,0x1960210bu,0x021b0221u,0x0b201a3bu),\nuvec4(0x01020302u,0x13040ab0u,0x2205e605u,0x0a00f001u),\nuvec4(0x1a000a1bu,0xf0f0095bu,0x0e0a0940u,0x298d1e0au),\nuvec4(0x092d099du,0xadfd0960u,0x8d0b0a2eu,0x0d1e1d2eu),\nuvec4(0x1d4e1d1eu,0x2d0e0d3eu,0x2e1a1efeu,0x2b4a0e2au),\nuvec4(0x3e0dce0au,0x0a2b0a1du,0x0b0a0b0eu,0x4b0a1e1au),\nuvec4(0x9e4b0e2au,0x1e0a1e1bu,0x509bfb1au,0x700b022bu),\nuvec4(0x0e0a1e5bu,0x3e1d0e0au,0x3d0a0ecdu,0x7b1a6b0eu),\nuvec4(0x1d395d0au,0x5b7a6d09u,0x8b3a5b1au,0x0b000b0au),\nuvec4(0x010b0208u,0x024b0a60u,0x0a090b08u,0x0109204bu),\nuvec4(0x021b09e0u,0xf00104c6u,0x1b0e0960u,0x22080b02u),\nuvec4(0xf0f0092bu,0x2a0d0920u,0x30097d0eu,0x6009cd09u),\nuvec4(0x0b0eadfdu,0x0e7d0e0au,0x0e1d1e1du,0x0e4d0e0du),\nuvec4(0x4e2d1e0du,0x0efefe2du,0x0e1ade0au,0x0e9b4e0du),\nuvec4(0x0a2b0e3bu,0x3b022b0du,0x1ecb1efeu,0x09700a9bu),\nuvec4(0x1980090au,0x0e100910u,0x0d0e0a0bu,0x0a1dfd0eu),\nuvec4(0x1e0d5e5du,0x1d0e7b0au,0x5d0efd0eu,0x0b8a6b2au),\nuvec4(0x100a5b0au,0x01400a5bu,0x2b0a291au,0x04123b02u),\nuvec4(0x2a10f001u,0xf003b604u,0x0b0e0980u,0x05020b02u),\nuvec4(0xf00a0416u,0x0e2d30f0u,0x093d30adu,0xfd2009adu),\nuvec4(0x1e2d0eddu,0x0e2d0e0du,0x0dfd1e1du,0xfefe6d2eu),\nuvec4(0x1e1d2efeu,0x2a0d3e0au,0x2e6b1a0bu,0x1e4b1e0au),\nuvec4(0x8b0d7e0au,0x5b1e7b0eu,0x100e1b0eu,0x295019b0u),\nuvec4(0xbd1e2900u,0x0e0a0b0eu,0x020b120bu,0x0a1dfd0eu),\nuvec4(0x7dfd3e5bu,0x0e2a4b1eu,0x30097a3du,0x0802090au),\nuvec4(0x020a100au,0x1b0aa001u,0x021a0b02u,0x0102070bu),\nuvec4(0x040210f0u,0x01159605u,0x0a09a0f0u,0xf0090a02u),\nuvec4(0x0d1940f0u,0x2009bd09u,0x090d09edu,0xfdfdfdfdu),\nuvec4(0xfe2d5efdu,0x0d5efefeu,0x2b2e3b2eu,0x1e0a4b0eu),\nuvec4(0x1edb5e0au,0xd00009ebu,0x0b094009u,0x0d2e3b0eu),\nuvec4(0x030b5d1eu,0x0a1b0204u,0x1b0e0a0eu,0x0e1dfd1eu),\nuvec4(0xbd0e4b0au,0x1d195d0eu,0x09004e3au,0x090e090du),\nuvec4(0x0a0d3a2du,0x0b019009u,0x1b0a09e0u,0x09010b02u),\nuvec4(0x30f00b01u,0x0486040au,0xf0f0f002u,0x1d0940f0u),\nuvec4(0x6d3e0d0eu,0x3d0e1d30u,0x1d090d09u,0xfd095d09u),\nuvec4(0x0dfdfdfdu,0xad1e2d0eu,0xfe2d8efeu,0x2b2d2efeu),\nuvec4(0x0b2e0b0eu,0x0b7e0a3eu,0x0a3b0e0au,0x0a2b0a0bu),\nuvec4(0x0e1d0e0bu,0x007b0e6bu,0x0a0920f0u,0x4d6e0b1eu),\nuvec4(0x0a0b0a0bu,0x020a1d0eu,0x0b2d0e0bu,0x0ead0e22u),\nuvec4(0x0a5b0e3du,0x0e0d0e5du,0x1d190e2du,0x0b2e3d29u),\nuvec4(0x5d0a2d0au,0x0d0e2d0eu,0x010ab009u,0x1b100b20u),\nuvec4(0x091a091au,0x120a0940u,0x0b0150f0u,0xf0057605u),\nuvec4(0x0910f0f0u,0x0d0900f0u,0x407d2e3bu,0x095d299du),\nuvec4(0x7d090d00u,0x6dfdfd0eu,0xfd090d09u,0x0d5efefdu),\nuvec4(0x2d3efefeu,0x4b021b0au,0x0e1a4bceu,0x09000e2bu),\nuvec4(0x2b0e7b2eu,0x0920090au,0x0920f000u,0x0d0e0b3eu),\nuvec4(0x0d0e2d3eu,0x0e04120bu,0x030b0e1du,0x0b1a0b14u),\nuvec4(0x0b020312u,0x0e0d0b1du,0x1e0d2e2du,0x0e0b1a0du),\nuvec4(0x09bd0a1du,0x0e0a0900u,0x1e4d1eedu,0x20f0091du),\nuvec4(0x7b0d1009u,0x50f00180u,0x0526020au,0xf0f00426u),\nuvec4(0x1d20f0f0u,0x1e0b120bu,0x0940098du,0x290d194du),\nuvec4(0x093d100du,0xfdfdfd10u,0xfe6dfdfdu,0x1abefefeu),\nuvec4(0x9e0b0e5bu,0x20090a2bu,0x0d0b0a09u,0x1b0a0009u),\nuvec4(0x0a1b1a4eu,0x20f08009u,0x1e1b5e19u,0x04023e1du),\nuvec4(0x0a1d0a0bu,0x09010a04u,0x23020402u,0x0b031514u),\nuvec4(0x4d1e0d0eu,0xbd0e7d0eu,0xcd0e0d09u,0x0a1e3d09u),\nuvec4(0x0d2e1d0eu,0x9b0a60f0u,0x09d0f00au,0x0a090b01u),\nuvec4(0xf0040604u,0x30f0f0f0u,0xbd1b1e0du,0x0e1d4009u),\nuvec4(0xfdfd309du,0xfdfd0e7du,0x1efe3dfdu,0xfe4d0e1du),\nuvec4(0x0a1e0afeu,0x0b1e0a7eu,0x50095b0eu,0x0e09100au),\nuvec4(0x090a7e1bu,0x0900f0a0u,0x3e190b0au,0x120d5e3bu),\nuvec4(0x0b041a00u,0x19200904u,0x0514120bu,0x3b040604u),\nuvec4(0xfdfd0e4du,0x092d097du,0xf00d3e0du,0x5b1a1b80u),\nuvec4(0xf019500au,0xf0120aa0u,0x30f0f0f0u,0x0a1b0d09u),\nuvec4(0x090009ddu,0x191d1900u,0x000d1940u,0xfd096d09u),\nuvec4(0x0e8dfdfdu,0x0d0e3dfdu,0x1d0e5d0eu,0x7dae0d1eu),\nuvec4(0x0d0e1d1eu,0x0abefefeu,0x2e900d1eu,0x20290e0au),\nuvec4(0x70f0c019u,0x2e0b0a09u,0x190b1e0du,0x0910090du),\nuvec4(0x0309e002u,0x12040304u,0x0e2d0903u,0x09bdfd0au),\nuvec4(0x1eed1900u,0x0d70f00du,0x4b0e0a3eu,0xf0091b50u),\nuvec4(0xf0f0f0f0u,0x0d0900f0u,0x097d0e0au,0x2960095du),\nuvec4(0x1e0d190du,0x0edd1ecdu,0xfdfd0e3du,0x2e8dfdfdu),\nuvec4(0x7efefe7du,0x1910890du,0x70091e0du,0x0e0b0e0du),\nuvec4(0x80f070f0u,0x0d190a09u,0x020b1e2au,0x0350f001u),\nuvec4(0x140b0a04u,0x1d0e1d0bu,0x0a0e1d1eu,0x4e2d1eadu),\nuvec4(0x1e0d0a0du,0x191d0eedu,0x5e0930f0u,0x09102a4bu),\nuvec4(0xf0092b0au,0xf0f0f0f0u,0x4db00930u,0x19001d20u),\nuvec4(0x0960092du,0xad193e0du,0x0d091d0eu,0x3d0e2d0eu),\nuvec4(0x7d3e1d7eu,0xfd0e4d1eu,0x0e6dfdfdu,0xfe8d0e0du),\nuvec4(0x09ce0d8eu,0x0b1e80f0u,0x0900090eu,0xf0f050f0u),\nuvec4(0x090b1a0eu,0x60f00d00u,0x030a190du,0x0e1d0a04u),\nuvec4(0x0d0a0e1du,0x2e9d020au,0x0e1d1e4du,0x1d0a1d0au),\nuvec4(0x50f0cd29u,0x0a1e0d0au,0x4b0a4e4bu,0xf0f0f009u),\nuvec4(0x0009d0f0u,0xe00a0b0du,0x0d094009u,0xa02d091eu),\nuvec4(0x6d1e2d3eu,0x2d4e1d2eu,0x0dce0d1eu,0x1d5e1d1eu),\nuvec4(0xfd1e0d2eu,0x1e2d0eadu,0x1e3d0ecdu,0xce0a2eadu),\nuvec4(0xce1d2e0du,0x0970f00du,0x0e0b1e0du,0xf080f009u),\nuvec4(0x101a0ee0u,0x70f01a0eu,0x0900090du,0x2b030205u),\nuvec4(0x0b2d1e0au,0x0e9d0e8du,0x004d092du,0x0a0d2e8du),\nuvec4(0x1e30f019u,0x1e4b0e0du,0x0e4b1e1du,0xf0f0f009u),\nuvec4(0x0009b0f0u,0xf03e0b09u,0x5d100e09u,0x20091009u),\nuvec4(0x09001d09u,0x3dbe5d7eu,0x0d8e0b3eu,0x0d8e1d3eu),\nuvec4(0x1d0e9d9eu,0x8d0e1d0eu,0xfd0e5d0eu,0x1d5e0d0eu),\nuvec4(0x0dae1a0eu,0xf0090dfeu,0x70f08e70u,0x0b0ac0f0u),\nuvec4(0x19f0f009u,0x03020a0du,0x0a0d0a12u,0x1e5d0a0du),\nuvec4(0x2dfd1e2du,0x7d0e9d19u,0x1e0df009u,0x3b4d5e1du),\nuvec4(0xf0f0090du,0x09d0f0f0u,0x091e0b0eu,0x4d202ee0u),\nuvec4(0x0dae5009u,0x0dce3d1eu,0x0efe4d0eu,0x0d9efe0du),\nuvec4(0x2d5e3d0eu,0x1d0e1d2eu,0x0a5eed4eu,0x0a1e0a3eu),\nuvec4(0x09ae2dbeu,0xf09e80f0u,0x1990f070u,0xf0f00a0bu),\nuvec4(0x0d090d30u,0x0d03020au,0x0b4e8d1au,0x0efd09adu),\nuvec4(0x098009cdu,0x5e5d0920u,0x1e0a1e3du,0xf0f0090du),\nuvec4(0x09c0f0f0u,0xd00a2e0du,0x00091e09u,0x091e0d09u),\nuvec4(0x1e1d9e80u,0x0a2efe2du,0x0dce1b2eu,0x1dbefefeu),\nuvec4(0x0d0e1d4eu,0x7d092d0eu,0x0d1e1d0eu,0x1efe0a1eu),\nuvec4(0xf00a6e5du,0x0b5e0990u,0x80f0090eu,0x001a70f0u),\nuvec4(0x50f0f009u,0x0e190d09u,0xed5ebd1au,0x39adfd19u),\nuvec4(0xad0e0950u,0x1d0e3d0eu,0x091d0e1bu,0xf0f0f0f0u),\nuvec4(0x4e003970u,0x090d1ed0u,0xfeb0090eu,0x6efe1d9eu),\nuvec4(0xfe0d2e0du,0x2b2e0b1eu,0x0a1e2dbeu,0x3d1e3d0eu),\nuvec4(0x0d0e7d3eu,0x0a0d000eu,0x099d8efeu,0x7e0da0f0u),\nuvec4(0x20f00950u,0xf01140f0u,0x1b09e0f0u,0x5edd094du),\nuvec4(0x3dfd0e0du,0x300efd09u,0x4d0e0dfdu,0xf0f06d0eu),\nuvec4(0x3e50f0f0u,0xc00a2e20u,0x0910191eu,0x0e0d0930u),\nuvec4(0xfefe0009u,0x2dbe0a7eu,0xbb1e3b9eu,0x0d0e0b9eu),\nuvec4(0x0b0e0d0eu,0x4e9d0e0au,0x090d1e4du,0x0d5efe00u),\nuvec4(0x5d3e1d1eu,0x0990f019u,0x90f0195eu,0x090a10f0u),\nuvec4(0x0de0f0f0u,0x0a0d0910u,0x0b2efd1bu,0x2d4e2b0au),\nuvec4(0x0d5e0d0eu,0xfd093d0eu,0x0e09300du,0x090d090du),\nuvec4(0x094d29ddu,0xf0f0091du,0x4e20f0f0u,0x1b1e0930u),\nuvec4(0x0b5e1990u,0xfefe090eu,0x1b0e0dfeu,0x0b0e1b1eu),\nuvec4(0x0b0e1d1eu,0xaebbfb0eu,0x0a0b0e2du,0x4d1e3d1eu),\nuvec4(0x0d2e0d3eu,0xfe090009u,0x2d0e4dbeu,0x00090d0eu),\nuvec4(0xf0090e0du,0xf0094e50u,0xf001f0b0u,0x0920f0f0u),\nuvec4(0x020a0920u,0x0b1a7d0au,0xeb1e3d0au,0x0d0e0d0eu),\nuvec4(0x0e8dfd09u,0xfd0e200du,0xf0f009edu,0x0900f0f0u),\nuvec4(0x0900093eu,0x090a1b3eu,0x0dde0d40u,0x8efe0bdeu),\nuvec4(0x0e2a2e0au,0x3b0e1b0au,0xdb0e0d1eu,0x0e1bfb0eu),\nuvec4(0x1e0b1e1au,0x0e0a0b3du,0x5e1d2e8du,0x0900090du),\nuvec4(0x5dcefe1du,0x0d0e1d7eu,0x093e10f0u,0xf0f0c0f0u),\nuvec4(0x0980f0f0u,0x2a7d1a0du,0x4b2e1d1bu,0x3b022b02u),\nuvec4(0xfd0e0d5eu,0x20090e5du,0xf009fdfdu,0x00f0f0f0u),\nuvec4(0x5b1e204eu,0x4e092009u,0x1e0d7e0bu,0x0b6efe4bu),\nuvec4(0x1a8e0b0eu,0x1eab0a1bu,0x7b02bbfbu,0x9d0e0a1eu),\nuvec4(0x0b0e4d0eu,0x2e1d2e0au,0x0a9e1d29u,0x1e0d5efeu),\nuvec4(0x1e0d3e1du,0xf00a0e1du,0x091e0910u,0x0930d0f0u),\nuvec4(0xf0f0f0f0u,0x030a0940u,0x0a8d0a0bu,0x2b0d0a1bu),\nuvec4(0x4b421822u,0xfd4e0d0eu,0xfd00096du,0xf0f019fdu),\nuvec4(0x1e09f0f0u,0x2e093009u,0x09200a3bu,0x0b3e0b4eu),\nuvec4(0x0b3e0d3eu,0x0b0e1b0eu,0x6e3b2efeu,0x12cbfbfbu),\nuvec4(0x0a1b021bu,0x3e2d4e2bu,0x2d0e1b2au,0x1d1e2b1eu),\nuvec4(0x0bbe0d29u,0x2e5d5efeu,0x0e192e0du,0x0910f00du),\nuvec4(0xe0f0090eu,0xf0f0f0f0u,0x0b0a1990u,0x2d1a6d22u),\nuvec4(0x3258121bu,0x0e0d5e4bu,0x6dfd195du,0xcd095d09u),\nuvec4(0x090d1009u,0xf0f0f0f0u,0x0b1e0970u,0x1b0a193eu),\nuvec4(0x0d0e1b1eu,0x0bde0b4eu,0x2b1e0d9eu,0x1b0e0b1eu),\nuvec4(0xfb0e0b0eu,0x922b028bu,0x5e4b32abu,0x0a2b0e2du),\nuvec4(0x0b0e0a0bu,0x1b0e2d0eu,0x1b0a6e0au,0x3b4e0d2eu),\nuvec4(0x0e1d3efeu,0x0e0d3e3du,0x0e0d100du,0x30f0f0f0u),\nuvec4(0xf0f0f0f0u,0x191d0990u,0x7d0a020au,0x020e1d0au),\nuvec4(0x32480208u,0x099d6e6bu,0x2099ddfdu,0xf0f0090du),\nuvec4(0x2970f0f0u,0x5efe3b60u,0x7e0b5e1bu,0x0e0b3e1bu),\nuvec4(0x02ab0e0bu,0x08221bfbu,0x1b527bb2u,0x2b0a0d5eu),\nuvec4(0x020b0812u,0x0e020807u,0x0a1b1e0bu,0x4d1e1b6eu),\nuvec4(0x4b122b1eu,0x3d0e1deeu,0x0d100d5eu,0x09f0090eu),\nuvec4(0xf010f0f0u,0xb0f0f0f0u,0x00090d09u,0x120abd09u),\nuvec4(0x32081228u,0x198d4e8bu,0x7d0e3dfdu,0x09501940u),\nuvec4(0xf009002du,0x90f0f0f0u,0x5b0a0019u,0x0b1e0b3eu),\nuvec4(0x0e1b4efeu,0x1b0a1e4bu,0x1a0e0b0au,0x425b32bbu),\nuvec4(0x22c8321bu,0x522b021bu,0x122b4e2bu,0x18070218u),\nuvec4(0x1b020812u,0x2e0a3b12u,0x1e3d0e1bu,0x3208222bu),\nuvec4(0x2e5dde1bu,0x0e0d104du,0xf0f0f00du,0xf0f0f020u),\nuvec4(0x0d09d0f0u,0x6d0a4d09u,0x7b22680au,0x1d1e3b0eu),\nuvec4(0x3d197d0eu,0x0d2e2d0eu,0x0910bd0eu,0x1d70092du),\nuvec4(0xf0092d0eu,0x60f0f0f0u,0x8b090009u,0x2b1e0dbeu),\nuvec4(0x0d3e1d1eu,0x3b0e1b1eu,0x1a0e0b1eu,0x02bb0e3bu),\nuvec4(0x0738e228u,0x0a4bd2b8u,0x281b0a0eu,0x0b220867u),\nuvec4(0x0b027b02u,0x3b2e0d0eu,0x18023802u,0x2dde0b12u),\nuvec4(0x10093d5eu,0xf0f0f00du,0xf0f0f040u,0x2d29e0f0u),\nuvec4(0x5d0e0d1bu,0x0817080bu,0x8b220812u,0x0d1e2b0au),\nuvec4(0x7d404d1eu,0xad0e0d1eu,0x70193d09u,0x0e3d0e0du),\nuvec4(0xf0f0f00du,0xcb0940f0u,0x0b3e3bfeu,0x3b0e1d1eu),\nuvec4(0x0a1bfb1eu,0x0288023bu,0x02c85788u,0x121b5258u),\nuvec4(0x022b0208u,0x07080718u,0x6b121715u,0x2b1e1b32u),\nuvec4(0x0b027832u,0xfe2b0a2eu,0x0d20093du,0x40f0f0f0u),\nuvec4(0xf0f0f0f0u,0x124d09e0u,0x2d0b0208u,0x020e0d0bu),\nuvec4(0x62080208u,0x5e2b0e7bu,0x0970090du,0x4ecd0e5du),\nuvec4(0x29b0091du,0xf0f0f01du,0x0a0950f0u,0xce0b0e2bu),\nuvec4(0x1d2e8b7du,0x0a9b1aabu,0x080b023bu,0x08072807u),\nuvec4(0x18f70827u,0x1b12f807u,0x17020b22u,0x0b020708u),\nuvec4(0x25171802u,0x3b220807u,0x28325802u,0x0b124822u),\nuvec4(0xde4b0a2eu,0xf00d304du,0xf040f0f0u,0xe0f0f0f0u),\nuvec4(0x1d0e0d09u,0x2d0b320bu,0x0a1b0a1eu,0x38020b02u),\nuvec4(0x195eab12u,0x0d0e0900u,0x0e000920u,0x0e0d8eedu),\nuvec4(0x8009400du,0xf0f0f019u,0x6e6b70f0u,0x1a0d0e0au),\nuvec4(0x4e5b2e5du,0x0a5b0e0du,0x0d090a5bu,0x126b0a0bu),\nuvec4(0x12080228u,0x47020b1au,0x07254705u,0x07288715u),\nuvec4(0x18030803u,0x1b321812u,0x12371802u,0x02089708u),\nuvec4(0x0847282bu,0x28073807u,0x1b021807u,0x3b021b1eu),\nuvec4(0x0e405dbeu,0xf0f0f009u,0xf0f0f030u,0x0b3df0f0u),\nuvec4(0x1b0e1b02u,0x1b0d0a1du,0x28020b02u,0x7b220802u),\nuvec4(0x8e0a0b0eu,0x090d3e0du,0x090d290du,0xae1d0e1du),\nuvec4(0x190d5e0du,0x090d0900u,0xf0f0f0f0u,0x2e2b20f0u),\nuvec4(0x0b0d3e0bu,0x3b9e4d0au,0x10094b6eu,0x300a0b1au),\nuvec4(0x225b0a0eu,0x0d0e0218u,0x02011a09u,0x47055708u),\nuvec4(0x17250c25u,0x07035715u,0x02282705u,0x08020a0bu),\nuvec4(0x0c050712u,0xa7180725u,0x2827f705u,0x3b220802u),\nuvec4(0x020b1802u,0xf03dbe1bu,0xf0b0f0f0u,0xf0f0f0f0u),\nuvec4(0x0b0d0e0du,0x0b0e1b12u,0x0b0a3b3du,0x0a1e9b82u),\nuvec4(0x200d7e0bu,0x2d400d0eu,0x0d093ddeu,0xf0f00d2eu),\nuvec4(0x40f0f0f0u,0x0d7e0b0au,0x0a0b1e1au,0x2d000e1bu),\nuvec4(0x2d0e3b4eu,0x30093b2eu,0x090a092bu,0x18227b0eu),\nuvec4(0x0a09200au,0x0c051713u,0x07122c05u,0x05070c35u),\nuvec4(0x0357450cu,0x02083702u,0x1517223bu,0x0817051cu),\nuvec4(0x255745b7u,0x12370507u,0x12180708u,0x0208221bu),\nuvec4(0x0b7e0a1bu,0x09503d1eu,0x50f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0d1e09e0u,0x0d2b0d3bu,0x0b2a3b0au,0x180b0807u),\nuvec4(0x5b121b02u,0x0b3e0b0eu,0x0900096eu,0x1910092eu),\nuvec4(0x2e0dae0du,0x0900091du,0xf0f01d0eu,0x70f0f0f0u),\nuvec4(0x0a7e1b0du,0x2b0e1b0eu,0x5e0d200au,0x025b3e1bu),\nuvec4(0x300e5009u,0x223b3e09u,0x20090208u,0x0c05020au),\nuvec4(0x3c050705u,0x04081205u,0x17050c25u,0xc7050705u),\nuvec4(0x120b0208u,0x1507680bu,0x35574827u,0x250c9517u),\nuvec4(0x3b020857u,0x2b120802u,0x2d1e0b8eu,0xf00e0960u),\nuvec4(0xf040f0f0u,0xe0f0f0f0u,0x120b2d09u,0x0a0b121bu),\nuvec4(0x1a0b221bu,0x2802170bu,0x020b0e02u,0x0009be7bu),\nuvec4(0x00090a3eu,0x0a0b0e0bu,0x2e1d0e39u,0x090d0e0du),\nuvec4(0xf0f01d30u,0x90f0f0f0u,0x1e2b0e0du,0x090d0e3bu),\nuvec4(0x0b1e0910u,0x1e1b2009u,0xe08b4e0du,0x122b2e1du),\nuvec4(0x08300a0bu,0x165c050cu,0x254c0417u,0x081708b7u),\nuvec4(0x28070802u,0x4738322bu,0x17357718u,0x2c450705u),\nuvec4(0x2b022745u,0x1b320802u,0x1d7e0d3eu,0x0d1e0970u),\nuvec4(0xf0f0f019u,0xf0f0f000u,0x0b3de0f0u,0x08220812u),\nuvec4(0x17023b42u,0xce7b1248u,0x0a1b2e10u,0x090a1b09u),\nuvec4(0x0d7e190du,0xf0f0f0f0u,0x1e0960f0u,0x0e1d0e0du),\nuvec4(0x2e0d090du,0x0a19003bu,0x204b4009u,0x7e0b0a09u),\nuvec4(0x0900f05bu,0x0b3e1b1eu,0x4c04400au,0x4c270c26u),\nuvec4(0x07085715u,0x12280708u,0x021b020bu,0x021b027bu),\nuvec4(0x17081218u,0x07040728u,0x2c05c704u,0x07252c15u),\nuvec4(0x08272208u,0x2d8e0b12u,0x70090d1eu,0x1e0d2e09u),\nuvec4(0x00f0f0f0u,0xf0f0f0f0u,0x021b3de0u,0x12080208u),\nuvec4(0x082b2218u,0x18070802u,0x4b220b32u,0x2e0d10ceu),\nuvec4(0x00191a0bu,0xf0f0ae0du,0x70f0f0f0u,0x220b2e0du),\nuvec4(0x1e1b021bu,0x60090e0du,0x503b1019u,0x6e0b1e0au),\nuvec4(0x20f0091bu,0x0d2e0d0eu,0x01501b0eu,0x071c262cu),\nuvec4(0x353c0508u,0x08021837u,0x1b115b02u,0x2b020b22u),\nuvec4(0x08020802u,0x07050407u,0x07250405u,0x07240504u),\nuvec4(0x27052724u,0x27251c65u,0x18020b02u,0x099e1b22u),\nuvec4(0x0e0d29b0u,0x30f0f0f0u,0xf0f0f0f0u,0x0a0d09e0u),\nuvec4(0x3238022bu,0x080b0218u,0x08021847u,0x0bbe3b52u),\nuvec4(0x090a3e19u,0xce0d0900u,0xf0f0f009u,0x0960f0f0u),\nuvec4(0x1b282b0eu,0x091e1b28u,0x0a201960u,0x09300a3bu),\nuvec4(0x2e0a1b1eu,0x29500e2bu,0x7e0d800du,0x0301400bu),\nuvec4(0x02161c04u,0x07080715u,0x37252c05u,0x08129b08u),\nuvec4(0x67180302u,0xf5145502u,0x07152c25u,0x12183705u),\nuvec4(0x0e1d5e8bu,0xf00dd00du,0xf070f0f0u,0xe0f0f0f0u),\nuvec4(0x021b2d09u,0x28021817u,0x021b080cu,0x621b1718u),\nuvec4(0x0e1b0a4bu,0xce1bde0bu,0xf0f0190du,0x80f0f0f0u),\nuvec4(0x021b0e09u,0x07281b18u,0x90010b02u,0x1b094009u),\nuvec4(0x10010b02u,0x0b0e0b09u,0x0b025b0eu,0x0b1e390au),\nuvec4(0x0d0e1b0au,0x0d093009u,0x0b0e1b0eu,0x0b0a1b02u),\nuvec4(0x6c041240u,0x0c050705u,0x32480735u,0x180b0e0bu),\nuvec4(0x0208020bu,0x0c051708u,0xe50c0517u,0x0cb50704u),\nuvec4(0x18271805u,0x0b022802u,0x1d6e3b3eu,0xe0090d0eu),\nuvec4(0xf0f0f009u,0xf0f0f060u,0x0a1de0f0u,0x080b0d0bu),\nuvec4(0x06075807u,0x021b0207u,0x0d1b0218u,0x0a5b520bu),\nuvec4(0xf0f0eefeu,0xb0f0f0f0u,0x024b0e09u,0x1b081b08u),\nuvec4(0x0a601ba0u,0x020b020bu,0x1a3b0900u,0x0a191a20u),\nuvec4(0x020b124bu,0x220b0acbu,0x05200918u,0x050c158cu),\nuvec4(0x5827150cu,0x08021b22u,0x05471802u,0x040c85ccu),\nuvec4(0x07053c55u,0x02081705u,0x6e0b3218u,0x0d5e0a09u),\nuvec4(0x0de0091eu,0xf0f0090eu,0xf0f050f0u,0x0df0f0f0u),\nuvec4(0x020a0d1bu,0x05481708u,0x020b0807u,0x1a1b0708u),\nuvec4(0x6b520b0du,0xf009defeu,0xf0f0f0f0u,0x3b0e0ab0u),\nuvec4(0x08070802u,0x0a300b12u,0x700b0260u,0x0a300a09u),\nuvec4(0x3009021eu,0x023b0e0bu,0x02480708u,0x022b2208u),\nuvec4(0x0208021bu,0x3001281bu,0x050c2501u,0x052c153cu),\nuvec4(0x18523837u,0x150cfc57u,0x2704251cu,0x37250c85u),\nuvec4(0x0e0b2218u,0x0e0b0e1bu,0x0e0b0910u,0xf0093e19u),\nuvec4(0xf00d1e00u,0xf050f0f0u,0xf0f0f0f0u,0x0b0d2b0du),\nuvec4(0x12175817u,0x0e0b0227u,0x720a0b0au,0x0d8efe6bu),\nuvec4(0xf0f0090eu,0xb0f0f0f0u,0x0b222b09u,0x07080708u),\nuvec4(0x0ab00b02u,0x30090e90u,0x0a0b0e0au,0x020b0930u),\nuvec4(0x1857220bu,0x3b120807u,0x02070822u,0x0b02080bu),\nuvec4(0x1c030140u,0x17150c75u,0x02081705u,0x0703023bu),\nuvec4(0x07082708u,0x151cfc08u,0x1507050cu,0x17021817u),\nuvec4(0x08451c05u,0x02183705u,0x10090e7bu,0x0d2e3019u),\nuvec4(0x091e00f0u,0x50f0f0f0u,0xf0f0f0f0u,0x021b00f0u),\nuvec4(0x08020b0eu,0x020b3837u,0x02080705u,0x4b52284bu),\nuvec4(0x0e099efeu,0xf0f0f0f0u,0x120ad0f0u,0x1b02080bu),\nuvec4(0x07080b02u,0x1950f00au,0x090b2a50u,0x021b0910u),\nuvec4(0x17081208u,0x07281705u,0x021b3208u,0x0d280728u),\nuvec4(0x0c060350u,0x0c151705u,0x07350c05u,0x2b022825u),\nuvec4(0x08021722u,0x4c35dc17u,0x02083705u,0x3517081bu),\nuvec4(0x0e2b0867u,0x50190a5bu,0xe00d3e09u,0xf0f01e09u),\nuvec4(0xf0f060f0u,0x10f0f0f0u,0x0b0e120bu,0x02083708u),\nuvec4(0x08020b08u,0x1d0b1807u,0x180b020au,0x6b120b22u),\nuvec4(0x090d8efeu,0xf0f0f0f0u,0x180ad0f0u,0x0248120bu),\nuvec4(0x021b20f0u,0x1b0a700au,0x1b093009u,0x07021b12u),\nuvec4(0x1b080705u,0x0b120802u,0x1b120802u,0x0a280712u),\nuvec4(0x050c0350u,0x25370547u,0x05170507u,0x08120817u),\nuvec4(0x15021827u,0x057c051cu,0x35040704u,0x150c052cu),\nuvec4(0x074b0227u,0x1b186715u,0x0b0e1b02u,0x0a093b0eu),\nuvec4(0x0e094009u,0xc0091e0bu,0xf0091e0du,0xf060f0f0u),\nuvec4(0xf0f0f0f0u,0x08120910u,0x2708020bu,0x07080708u),\nuvec4(0x0b024708u,0x0b0a020au,0x0b4e8b52u,0xf0f02efeu),\nuvec4(0xf0f0f0f0u,0x08010009u,0x50012b12u,0x09000911u),\nuvec4(0x080a091au,0x1b300102u,0x09501a80u,0x0b080b0au),\nuvec4(0x07080b0au,0x080a1b08u,0x1b023837u,0x0b023708u),\nuvec4(0x0a09200au,0x15070208u,0x45070507u,0x153c0507u),\nuvec4(0x08320817u,0x17180702u,0x050c0705u,0x1407152cu),\nuvec4(0x05170527u,0x0507150cu,0x02170517u,0x0b0e1b01u),\nuvec4(0x0b120847u,0x0e2b0802u,0x0a6b0e2bu,0x903e0940u),\nuvec4(0xf0093e19u,0xf060f0f0u,0xf0f0f0f0u,0x0b220b20u),\nuvec4(0x18170827u,0x1708270bu,0x08022b08u,0x1b5e6b42u),\nuvec4(0xf0f02efeu,0xf0f0f0f0u,0x60090a20u,0x28120801u),\nuvec4(0xf0271827u,0x0a100970u,0x10091b20u,0x0517080bu),\nuvec4(0x150c050cu,0x08020817u,0x020e2b57u,0x05070527u),\nuvec4(0x45074517u,0x023b2227u,0x07055714u,0x77043724u),\nuvec4(0x27054705u,0x08020b02u,0x1e020847u,0x0a5b1e6bu),\nuvec4(0x3e903e70u,0xf0f00e0bu,0xf0f070f0u,0x30f0f0f0u),\nuvec4(0x17021802u,0x02182705u,0x18070508u,0x18220817u),\nuvec4(0x2b3e7b32u,0x090d1efeu,0xf0f0f0f0u,0x1a10f0f0u),\nuvec4(0x27080240u,0x17052c05u,0xf0080c35u,0x11a01910u),\nuvec4(0x8c070210u,0x08020815u,0x25170587u,0x18573547u),\nuvec4(0x0b0a2b12u,0x17140312u,0x77251734u,0x07087708u),\nuvec4(0x08022b22u,0x120b0807u,0x120b0a0eu,0x093b4e1bu),\nuvec4(0x403e0970u,0x0e1d0e49u,0xf0f0f01au,0xf0f0f070u),\nuvec4(0x0a30f0f0u,0x2508020bu,0x0b120827u,0x07020827u),\nuvec4(0x4e5b4248u,0x0d1efe2bu,0xf0f0f009u,0x20f0f0f0u),\nuvec4(0x67081b02u,0x2c150c05u,0xf0024c05u,0x0b900120u),\nuvec4(0x07022002u,0x471805acu,0x3c151c05u,0x07150c05u),\nuvec4(0x07085745u,0x1a0e2b02u,0x0408120bu,0x082705c7u),\nuvec4(0x18023817u,0x1e3b1802u,0x024b220bu,0x2e2b0e2bu),\nuvec4(0x0a800e1bu,0x2e40091eu,0x1a0e0a0du,0xf0f0f019u),\nuvec4(0xf0f0f090u,0x0950f0f0u,0x1507120bu,0x2b020817u),\nuvec4(0x58071812u,0x2b021822u,0xf0098efeu,0xf0f0f0f0u),\nuvec4(0x170230f0u,0x1c450708u,0x2c164c15u,0x20f0f002u),\nuvec4(0x048c0709u,0x2817150cu,0x25070527u,0x4507350cu),\nuvec4(0x08270857u,0x0b020807u,0x08120b2eu,0x58e70807u),\nuvec4(0x1e4b025bu,0x2e0d0e1bu,0x1e2b2e0bu,0x3e0b0e0bu),\nuvec4(0x0d09d00au,0x1d090e19u,0xd0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x020970f0u,0x02085708u,0x0207083bu,0x02680708u),\nuvec4(0xfe0d2e4bu,0xf0f0091eu,0xf0f0f0f0u,0x07080b30u),\nuvec4(0x155c1718u,0x071c464cu,0x0210f0f0u,0x07059c07u),\nuvec4(0x1817050cu,0x150c9557u,0x05171837u,0x08072807u),\nuvec4(0x020d1e0bu,0xd7180718u,0x02280708u,0x2e7b020bu),\nuvec4(0x4e4d0b1du,0x1e5b1e0bu,0x9009020bu,0x09001e09u),\nuvec4(0xf0f0090du,0xf000f0f0u,0xf0f0f0f0u,0x07080b80u),\nuvec4(0x27050705u,0x18170238u,0x28070817u,0x0d2e4b02u),\nuvec4(0xf0091efeu,0xf0f0f0f0u,0x570830f0u,0x7c151c15u),\nuvec4(0x08175c26u,0x02017001u,0x09f00207u,0x7c051708u),\nuvec4(0x1c050705u,0x17020817u,0x0c350715u,0x050c5785u),\nuvec4(0x08170518u,0x021e1b02u,0x2807f718u,0x1b0e6b02u),\nuvec4(0x9b7e1d4eu,0x0b0e0b0eu,0x0da00902u,0xf0f0090eu),\nuvec4(0xf030f0f0u,0xf0f0f0f0u,0x0c170290u,0xa7282705u),\nuvec4(0x3e2b2218u,0x3e0bae0du,0xf0f0f0f0u,0x0140f0f0u),\nuvec4(0x45171827u,0x50055cfcu,0x03053c02u,0x0702c002u),\nuvec4(0x078c051cu,0x07151c15u,0x07151708u,0x4c350455u),\nuvec4(0x07051745u,0x1b021805u,0xf708121eu,0x5b023b08u),\nuvec4(0x0d4e2d4eu,0xa00adb3eu,0xf0f00e0du,0xf040f0f0u),\nuvec4(0xf0f0f0f0u,0x07080b90u,0x07050201u,0x07280b02u),\nuvec4(0x27052715u,0x020b0218u,0x9e2d0e2bu,0xf0094e0bu),\nuvec4(0xf0f0f0f0u,0x050740f0u,0x050c1547u,0x02078cfcu),\nuvec4(0x7c022001u,0x00110405u,0x0a0b0a09u,0x07050211u),\nuvec4(0x05cc050cu,0x071c0507u,0x07451708u,0x7c250415u),\nuvec4(0x07252715u,0x0d0e2b18u,0x1817080bu,0x08073857u),\nuvec4(0x1b0a3b02u,0x0d0b0e0au,0x0d1e0a0eu,0x1b0e0d0eu),\nuvec4(0x0b2e2b9eu,0xa0022b1eu,0xf0f0f019u,0xf0f040f0u),\nuvec4(0xa0f0f0f0u,0x17100702u,0x08022b08u,0x18170847u),\nuvec4(0x4efe4b02u,0xf0f0f0f0u,0x0850f0f0u,0xdcfc1557u),\nuvec4(0x05000205u,0x365c060cu,0x070b071cu,0x06ec061cu),\nuvec4(0x2708055cu,0x17050715u,0x1507050cu,0x053c052cu),\nuvec4(0x05171507u,0x2b121807u,0x18020b1eu,0x3b825847u),\nuvec4(0x0d0e0b0au,0x1b1e1d0eu,0x1b0e0b8eu,0x09021b6eu),\nuvec4(0xf0f0f0f0u,0xf0f000f0u,0xa0f0f0f0u,0x0001070bu),\nuvec4(0x02080701u,0x180b0e1bu,0x12370817u,0x400d6e6bu),\nuvec4(0x2e000d09u,0xf0f0f009u,0x40f0f0f0u,0x052c1547u),\nuvec4(0x5cc6bcfcu,0x06050c05u,0x06dc051cu,0x0503122cu),\nuvec4(0x15271537u,0x050c1507u,0x171c250cu,0x27082715u),\nuvec4(0x1e2b0208u,0x0817121au,0x0b122807u,0x221b0802u),\nuvec4(0x08020a0bu,0x0d1b0e1bu,0x2efe0d0bu,0xf00b6e0bu),\nuvec4(0xf0f0f0f0u,0xf0f0f010u,0x01b0f0f0u,0x17000b07u),\nuvec4(0x0b0e1b08u,0x02083712u,0x0e5b0218u,0x190d0930u),\nuvec4(0xf00d1e80u,0xf0f0f0f0u,0x170830f0u,0x1cfcfc25u),\nuvec4(0x4c760c36u,0x1c020c15u,0x150c0507u,0x052003dcu),\nuvec4(0x08170547u,0x14550407u,0x2c07051cu,0x17251705u),\nuvec4(0x0a1e4b18u,0x12080712u,0x020b220bu,0x020b222bu),\nuvec4(0x0a1b0804u,0x0d0a0d0bu,0xf00aaefeu,0xf0f0f0f0u),\nuvec4(0xf0f0f010u,0x01c0f0f0u,0x07000108u,0x1b1e0b08u),\nuvec4(0x08170802u,0x280b0207u,0xf0091b12u,0x091b0a10u),\nuvec4(0xf0f0f0f0u,0x200990f0u,0x35011001u,0x4cfc25dcu),\nuvec4(0x1c961c26u,0x03051c05u,0x1c070807u,0x0120ec05u),\nuvec4(0x27151705u,0x25040708u,0x0c046504u,0x2c170507u),\nuvec4(0x12082715u,0x220b0e3bu,0x42481703u,0x12030b1au),\nuvec4(0xfe1d1a0bu,0xf07e0b2eu,0xf0f0f0f0u,0xf0f0f020u),\nuvec4(0x01b0f0f0u,0x10020503u,0x0a1e020bu,0x0708020bu),\nuvec4(0x02081708u,0x0b022807u,0x0b0a30f0u,0xf0f0090eu),\nuvec4(0xe0f0f0f0u,0x050c0502u,0xfc050cfcu,0x0c05074cu),\nuvec4(0x1c162c16u,0x06054c16u,0x0207050cu,0x05170801u),\nuvec4(0x200306dcu,0x27350702u,0x0c152415u,0x0c053745u),\nuvec4(0x17051c05u,0x0b3e3b58u,0x04020402u,0x12030208u),\nuvec4(0x2e0a0204u,0x1e1b020bu,0x0abefe0du,0xf0f0f0f0u),\nuvec4(0xf0f020f0u,0xc0f0f0f0u,0x0b070402u,0x0b1e1b10u),\nuvec4(0x08270812u,0x02171807u,0x0930f00bu,0x01100e1bu),\nuvec4(0xf0f0f0f0u,0x052cb0f0u,0xfc056c07u,0x260c17dcu),\nuvec4(0x161c161cu,0x051c260cu,0x1001071cu,0x5c253c27u),\nuvec4(0x02300326u,0x17020425u,0x34050c05u,0x05270425u),\nuvec4(0x1227252cu,0x1b181708u,0x2b0e0b22u,0x1e0a0b1eu),\nuvec4(0x1e1b1e1bu,0x0e2b2e1bu,0xfe0b2e0bu,0xf0f0092eu),\nuvec4(0x30f0f0f0u,0xf0f0f0f0u,0x0201e0f0u,0x0b0a1001u),\nuvec4(0x07081b1eu,0x07180705u,0x0b081702u,0x1e0a40f0u),\nuvec4(0xf0090120u,0xf0f0f0f0u,0x1c050170u,0xac157c05u),\nuvec4(0x2c252725u,0x46056c05u,0x162c060cu,0x0c05362cu),\nuvec4(0x01100207u,0x07151705u,0x02268c05u,0x10113009u),\nuvec4(0x05640704u,0x0c050724u,0x27251c05u,0x22281708u),\nuvec4(0x2b02281bu,0x1b0e1b08u,0x0e0a4b0eu,0x1b2e0a1bu),\nuvec4(0x1efe0b4eu,0xf0f0f00au,0xf040f0f0u,0xf0f0f0f0u),\nuvec4(0x011012f0u,0x020b1e1bu,0x07150708u,0x07080208u),\nuvec4(0x50f00208u,0x21000b0du,0xf0f0f0f0u,0x7c0580f0u),\nuvec4(0x0705fc06u,0x0517151cu,0x668c051cu,0x063c063cu),\nuvec4(0x150c060cu,0x04100107u,0x08070407u,0x168c1507u),\nuvec4(0x40020403u,0x03010008u,0x353c1504u,0x170c050cu),\nuvec4(0x07081735u,0x18320708u,0x08071802u,0x08120807u),\nuvec4(0x1e0b1e3bu,0x0b0a020au,0x0b5e5b0eu,0xf0091efeu),\nuvec4(0xf0f0f0f0u,0xf0f0f040u,0x02f0f0f0u,0x0b200107u),\nuvec4(0x08021b1eu,0x120b1817u,0x50f00108u,0x0100090au),\nuvec4(0xf0110003u,0xf0f0f0f0u,0x063c1660u,0x062c255cu),\nuvec4(0x356c152cu,0x06bc46bcu,0x2002151cu,0x168c1547u),\nuvec4(0x0430021cu,0x02015005u,0x10010011u,0x070c0501u),\nuvec4(0x07250705u,0x02280718u,0x27281228u,0x3e2b1218u),\nuvec4(0x1e2b0e6bu,0x0b2efe2bu,0xf00a100au,0xf0f0f0f0u),\nuvec4(0xf0f0f020u,0x00f0f0f0u,0x0a200112u,0x020b0d0eu),\nuvec4(0x2b082718u,0x030190f0u,0xf0f0f00au,0x0570f0f0u),\nuvec4(0x6c061c06u,0x8c05bc15u,0x0c166c15u,0x160cfc06u),\nuvec4(0x0107150cu,0x17050210u,0x03368c25u,0x0c051201u),\nuvec4(0x01d00205u,0x050c1517u,0x18022817u,0x18074832u),\nuvec4(0x1e4b1817u,0x0e0b0e5bu,0x0a0b1a0bu,0x0b1efe1bu),\nuvec4(0x0d0a1009u,0xf0f0f0f0u,0xf0f020f0u,0xf0f0f0f0u),\nuvec4(0x30020110u,0x17180b2eu,0x1b0a0208u,0x0013a0f0u),\nuvec4(0xf0f0f011u,0x0430f0f0u,0xfc159c06u,0x061c250cu),\nuvec4(0x151c267cu,0x070c06ecu,0x2002051cu,0x05170401u),\nuvec4(0x174c569cu,0x02b00108u,0x38372517u,0x18220802u),\nuvec4(0x38020802u,0x8b1e5b02u,0x6b0e0a0eu,0x0b8e1b1eu),\nuvec4(0x0d0b300au,0xf0f0f0f0u,0xf0f020f0u,0xf0f0f0f0u),\nuvec4(0x1e400120u,0x0817081bu,0x30f02b02u,0x0a1e0a09u),\nuvec4(0x10211009u,0xf0f0f001u,0x0100f0f0u,0x25dc05ecu),\nuvec4(0x151c16bcu,0x074c06bcu,0x2001250cu,0x4c051703u),\nuvec4(0x6c463c05u,0x01b00127u,0x18170847u,0x58422802u),\nuvec4(0x1b1e5b12u,0x0a0e6b08u,0x0e8b0e3bu,0x090a0e2bu),\nuvec4(0xf0090e40u,0xf0f0f0f0u,0xf0f0f020u,0x90f0f0f0u),\nuvec4(0x07081b1eu,0x20f03b08u,0x1a01090au,0x00010b2eu),\nuvec4(0xf0011001u,0xf0f0f0f0u,0x15ec0500u,0x055cfc07u),\nuvec4(0x06bc256cu,0x042c153cu,0x02100105u,0x0c26ac17u),\nuvec4(0xc0059c06u,0x1b02b802u,0x08021b02u,0x1b120807u),\nuvec4(0x0b022b02u,0x080b0a1eu,0x1b0a5b02u,0x2e1a1b0au),\nuvec4(0x093b0e2bu,0xf0f00970u,0x30f0f0f0u,0xf009e0f0u),\nuvec4(0x90f0f0f0u,0x08022b1eu,0x090b1e0bu,0x190a09a0u),\nuvec4(0x20010940u,0x50091e01u,0xf0f00102u,0x01b0f0f0u),\nuvec4(0x164cfc06u,0x17156cfcu,0x253cfc05u,0x02100307u),\nuvec4(0x150c0405u,0x069c050cu,0x022c065cu,0x022822d0u),\nuvec4(0x120b4228u,0x0a1b1228u,0x00190a02u,0x0b0e0b09u),\nuvec4(0xeb080702u,0x0a090a0eu,0xf0090a1bu,0xf0f0f0f0u),\nuvec4(0x00f0f0f0u,0xf0f0f009u,0x4b3e70f0u,0x4e800a1eu),\nuvec4(0x0a09a009u,0xf00d0b0eu,0xf0f0f0f0u,0xfcfc0520u),\nuvec4(0x052705dcu,0x0c054cfcu,0x05200705u,0x069c0527u),\nuvec4(0x065c060cu,0x0af0041cu,0x8218220bu,0x02180208u),\nuvec4(0x0a600b18u,0x0807021bu,0x091b0ebbu,0xf0f00b20u),\nuvec4(0xf0f0f0f0u,0x10f0f020u,0xf0f0f00au,0x1b6e60f0u),\nuvec4(0x090e0b02u,0xc0093e70u,0x0e0d0e09u,0xf009100au),\nuvec4(0xe0f0f0f0u,0x0c053c0au,0xfc365c26u,0x062c061cu),\nuvec4(0x0705074cu,0x5c06fc05u,0x17083017u,0x6c167c05u),\nuvec4(0x30f00236u,0x1b123802u,0x08020b62u,0x082b8002u),\nuvec4(0x1b0e3b02u,0x20090b5eu,0xf0f01a09u,0xf0f0f0f0u),\nuvec4(0x10f0f010u,0xf0f0f019u,0x2b7e60f0u,0x3e09600eu),\nuvec4(0x0a30f009u,0x0e0b0e0bu,0xf0f0f0f0u,0x067c02a0u),\nuvec4(0x5cfc464cu,0xfc155c16u,0x4007155cu,0x064c1527u),\nuvec4(0x010c367cu,0x480b30f0u,0x1b082b02u,0xebb02b18u),\nuvec4(0x0120091eu,0xf0f0091eu,0xf0f0f0f0u,0xf0f0f010u),\nuvec4(0xb0f0f0f0u,0x1e1b6e09u,0x0a092009u,0x20f00a3eu),\nuvec4(0x0b1e1b29u,0xf0f0f00au,0x66ac90f0u,0x960c25fcu),\nuvec4(0x25cc169cu,0x17013007u,0x0526dc15u,0x0940f001u),\nuvec4(0x020b0238u,0x22080208u,0xc0020b08u,0x0b2ebb09u),\nuvec4(0x1e01200au,0xf0f009e0u,0x20f0f0f0u,0xf0f0f0f0u),\nuvec4(0x09d0f0f0u,0x0b1e1b4eu,0x09d00a8eu,0x400a600au),\nuvec4(0xf0f0f029u,0x8c0550f0u,0xfc361c06u,0xcc661c25u),\nuvec4(0x3c059c06u,0x07050705u,0xac270830u,0x0c160c06u),\nuvec4(0x60f00107u,0x28123802u,0x0ae02b12u,0x0ebb021bu),\nuvec4(0x0a20f009u,0xf0f0f01eu,0xf010f0f0u,0xf0f0f0f0u),\nuvec4(0x0d09f0f0u,0x0abe0b2eu,0xf0f0f0f0u,0x0550f0f0u),\nuvec4(0x8cfc351cu,0x1c050705u,0x0c061c66u,0xfc054c04u),\nuvec4(0x04151c05u,0x07300207u,0x4c050708u,0x02056c05u),\nuvec4(0x020b80f0u,0x12081748u,0x0af00a0bu,0x9b0e1b22u),\nuvec4(0x0a20f00au,0xf0f0f01eu,0xf010f0f0u,0xf0f0f0f0u),\nuvec4(0x1910f0f0u,0x09ae0b1eu,0xf0f0f0f0u,0x0140f0f0u),\nuvec4(0x150c1507u,0x359c3527u,0x962c055cu,0x27556cfcu),\nuvec4(0x170a0120u,0x01049c05u,0x021bb0f0u,0x02083718u),\nuvec4(0x0b00f01bu,0x0a010208u,0x0eab0e0bu,0xf02e10f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f010u,0xf0f0f0f0u,0x090d0940u),\nuvec4(0x596e0910u,0xf0f0f0f0u,0x1702f0f0u,0x47082725u),\nuvec4(0x07550c25u,0x7c450c05u,0xec052c96u,0x17251725u),\nuvec4(0x1701101au,0x1c353c05u,0x09c0f001u,0x0807180bu),\nuvec4(0x090b2807u,0x0b0a10f0u,0x3b125b20u,0x0b09f02eu),\nuvec4(0xf0f0f00eu,0xf020f0f0u,0xf0f0f0f0u,0xceb0f0f0u),\nuvec4(0xf0f0f009u,0x0930f0f0u,0xc7187780u,0x05074c25u),\nuvec4(0x166c0507u,0x351c163cu,0x377c074cu,0x0a282708u),\nuvec4(0x02070910u,0x054c0708u,0xf0010207u,0x080b0ae0u),\nuvec4(0x28070807u,0x029b80f0u,0x09e02e1bu,0xf0f00e0bu),\nuvec4(0x20f0f0f0u,0xf0f0f0f0u,0xc0f0f0f0u,0x0a3e0b6eu),\nuvec4(0xf0f0f0f0u,0x1701c0f0u,0x020b0248u,0x0c258748u),\nuvec4(0x07051c05u,0x2c252c05u,0x47155c05u,0x3c150705u),\nuvec4(0x07250c05u,0x321b0228u,0x07100805u,0x0517080bu),\nuvec4(0xf0010817u,0x180b20f0u,0x80f02817u,0x0b1eab0au),\nuvec4(0x0b09f00eu,0xf0f0f0f0u,0xf0f020f0u,0xf0f0f0f0u),\nuvec4(0x3e09e0f0u,0xf0f03e0bu,0xe0f0f0f0u,0x1228020bu),\nuvec4(0x5597284bu,0x052c1507u,0x45023507u,0x1c150887u),\nuvec4(0x12180755u,0x121b0e1bu,0x22000217u,0x01020718u),\nuvec4(0x1b40f0f0u,0xf0182708u,0x1e7b0980u,0x19f0094bu),\nuvec4(0xf0f00e0du,0xf0f0f0f0u,0xf0f0f0f0u,0x20f0f0f0u),\nuvec4(0xf0f04b09u,0xe0f0f0f0u,0x127b023bu,0x67081238u),\nuvec4(0x47155705u,0x37080b08u,0x05070b78u,0x12770507u),\nuvec4(0x120b2e1bu,0x02080708u,0xf0021701u,0x0b0a80f0u),\nuvec4(0xf0120728u,0x0a091b90u,0x0e0b0e5bu,0x09e0091bu),\nuvec4(0xf019100eu,0xe0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf03b0a30u,0xf0f00b01u,0x2bc0f0f0u,0x6b0e2b12u),\nuvec4(0x17182b02u,0x47080228u,0x07084718u,0x080b1268u),\nuvec4(0x870b1802u,0x1b021812u,0x07084b1eu,0x02d00218u),\nuvec4(0x220bd0f0u,0xf0020b08u,0x0e0b0180u,0x0b0e0a20u),\nuvec4(0x1b0e0b0eu,0x09f0091eu,0x0e000910u,0xf0f0f0f0u),\nuvec4(0xf0f0f0d0u,0xf0f0f0f0u,0x090e40f0u,0x080ae01bu),\nuvec4(0x0902000au,0xf0f0f0f0u,0x1e5b0a90u,0x020b028bu),\nuvec4(0x0b12080bu,0x08020b02u,0x38170807u,0x08021817u),\nuvec4(0x080b081bu,0x0257187bu,0x1e2b122bu,0x0807084bu),\nuvec4(0x01700102u,0xf0f00702u,0x2b0e0a10u,0x80f00a02u),\nuvec4(0x300a0b01u,0x1e4b0e09u,0x100920f0u,0xf0f0f019u),\nuvec4(0xf0f0c0f0u,0xf0f0f0f0u,0x0e50f0f0u,0x2e0ab01bu),\nuvec4(0xf01b121bu,0x90f0f0f0u,0x0e3b0a09u,0x621b026bu),\nuvec4(0x2b583b08u,0x08021b18u,0x483b0e7bu,0x2e7b0807u),\nuvec4(0x0e0b0e1bu,0x05071802u,0x08111001u,0xf0170517u),\nuvec4(0x020b20f0u,0xf00b0218u,0x40090b90u,0xf00a4b0eu),\nuvec4(0x090e0920u,0xf0f00d00u,0xf0d0f0f0u,0xf0f0f0f0u),\nuvec4(0x50f0f0f0u,0x90090b1eu,0x0b2e0b09u,0x0b020b0au),\nuvec4(0x0e0b0a0eu,0x191e0d19u,0xf0f0f0f0u,0x0e4b0a10u),\nuvec4(0x125b0e1bu,0x3b08220bu,0x08020802u,0x08023b02u),\nuvec4(0x120b020bu,0x2bfb0e6bu,0x27084b3eu,0x3c350705u),\nuvec4(0x20f0f008u,0x0a121b0au,0x600a90f0u,0x090b1e09u),\nuvec4(0x393009f0u,0xf0f0f0f0u,0xf0f0f0d0u,0xf0f0f0f0u),\nuvec4(0x091e70f0u,0x0a301920u,0x0b002e1bu,0x2b0e3b2eu),\nuvec4(0xf0f0091eu,0x0910f0f0u,0x2e0b1e1bu,0x0218128bu),\nuvec4(0x2b18122bu,0x0b020b02u,0x2b8e8b02u,0x5b0e0b0eu),\nuvec4(0x3b0e0b3eu,0x5c350722u,0x20f0f001u,0x08020b09u),\nuvec4(0xf00a010au,0x60010e80u,0xf00a0b0eu,0x190e4009u),\nuvec4(0xf0f00900u,0xf0c0f0f0u,0xf0f0f0f0u,0x80f0f0f0u),\nuvec4(0x0a0e092eu,0x00090b09u,0x4e0b3e2bu,0x0e2b023bu),\nuvec4(0xf0f00a0bu,0x0e10f0f0u,0x0e0b1e3bu,0x024b089bu),\nuvec4(0xbb22085bu,0x0b3e3b8eu,0x08026b5eu,0x073c0537u),\nuvec4(0x0e40f0f0u,0x09000108u,0x60f0090eu,0x0a601e09u),\nuvec4(0x800900f0u,0xf0090e09u,0xb0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x0a0e1990u,0x0e0b0910u,0x1e0b3e1bu),\nuvec4(0x1e6b2e0bu,0xf0f01e0du,0x0a00f0f0u,0x0b3e0b0eu),\nuvec4(0x4b12db0eu,0x1b4e1b32u,0x0b8e0d5eu,0x08223bbeu),\nuvec4(0xf0012567u,0x100150f0u,0x70f01e0au,0xf00a0b0au),\nuvec4(0x0d0e09e0u,0xf0f0f02eu,0xf0f0b0f0u,0xf0f0f0f0u),\nuvec4(0x0ac0f0f0u,0x1e1b0a20u,0x8e0b0e0du,0x4e0b0a3bu),\nuvec4(0xf0f0f0f0u,0x0b2e0a00u,0x5b02eb2eu,0xfefe0b12u),\nuvec4(0x27085b5eu,0xf0084718u,0x1e0990f0u,0x0a70f009u),\nuvec4(0x19d0f00bu,0xf02e0900u,0xb0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x0a0b10f0u,0x3b2e1b3eu,0xf0f0f0ceu),\nuvec4(0x1b0a10f0u,0x1b0e7b0au,0x08021b0eu,0x0b185b02u),\nuvec4(0x0b1efefeu,0x2b0e1b3eu,0x05172827u,0xf0f00507u),\nuvec4(0x091e09a0u,0x091e80f0u,0x500d40f0u,0x0e091009u),\nuvec4(0xf0f0f009u,0xf0f0c0f0u,0xf0f0f0f0u,0x10f0f0f0u),\nuvec4(0x0e0b3e1bu,0x6e3b0e0bu,0x0a193e3du,0xf0f0f00eu),\nuvec4(0x1e9b0ad0u,0x2b400a2bu,0xfe0b0802u,0x1e3b1efeu),\nuvec4(0x121b1e0bu,0x15170837u,0xb0f0f007u,0x0990f019u),\nuvec4(0x20f00d1eu,0x0d09802du,0xf0f0f0f0u,0xf0f0f0c0u),\nuvec4(0xf0f0f0f0u,0x1b10f0f0u,0x1d0e8b2eu,0x4d5e0d3eu),\nuvec4(0xf0f0f01eu,0x0e1a09c0u,0x0a2b1a2bu,0x1b0a6009u),\nuvec4(0x0b5e1b02u,0x023b9efeu,0x0517186bu,0xf0f0f057u),\nuvec4(0x302910f0u,0x0e0d0e09u,0x2d00f00du,0xf0f0091eu),\nuvec4(0x50f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x0e2b10f0u),\nuvec4(0x3e0d1e8bu,0x2e1b0e1du,0x0e0d0e4du,0xf0f0f00au),\nuvec4(0xf0091ac0u,0x1e1a2b00u,0x0d1efe1bu,0x0b381baeu),\nuvec4(0x27022b02u,0xf0024708u,0x20f0f0f0u,0x0e20092du),\nuvec4(0x4d09e02du,0xf0f0f009u,0xf060f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x6d4e8b10u,0x2d2e1b1eu,0x091e1d1eu),\nuvec4(0xf0f0f0f0u,0x0b0a40f0u,0x1d8e1d7eu,0x02181baeu),\nuvec4(0x08220b18u,0x02074817u,0xf0f0f0f0u,0x090e1d40u),\nuvec4(0x1e0d0910u,0x3d0e09d0u,0xf0f0f009u,0xf070f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x2b0e3b10u,0x1b4e3d5eu),\nuvec4(0x1d0e2d3eu,0xf0f0091eu,0x50f0f0f0u,0x4e0b1e0bu),\nuvec4(0x1e0d2e3du,0x2e0b3e6du,0x0205020bu,0x480b1807u),\nuvec4(0x07020b02u,0xf0f00208u,0x0960f0f0u,0xc02e102eu),\nuvec4(0x094d0e09u,0xf0f0f0f0u,0xf0f070f0u,0xf0f0f0f0u),\nuvec4(0x0af0f0f0u,0x7e1b0e0bu,0x3e3d2e0du,0x1e0b0e0bu),\nuvec4(0x1e0d0e3du,0xf0090e0du,0xf0f0f0f0u,0x6e3d7e40u),\nuvec4(0x2e0b0e9du,0x0208071bu,0x02380207u,0x020b0208u),\nuvec4(0xf0f00208u,0x3e80f0f0u,0x90091e19u,0xf07d0e0du),\nuvec4(0xf0f0f0f0u,0xf0f0f070u,0xf0f0f0f0u,0x0a3bf0f0u),\nuvec4(0x2d2e1d6eu,0x2d0e1d9eu,0x0b0e0d1eu,0xf0f0f002u),\nuvec4(0x6e30f0f0u,0x0e9d3e7du,0x020b3e09u,0x4b183718u),\nuvec4(0xf0f0f0f0u,0x0d1e1db0u,0x29601e09u,0xf0f08d0eu),\nuvec4(0x70f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x7e2b0ae0u),\nuvec4(0x1e4d0eedu,0x0a081e4du,0xf0f0f0f0u,0x6e0910f0u),\nuvec4(0x5e9d2e7du,0x020b1e0bu,0x02182708u,0xf0f0f02bu),\nuvec4(0x1009a0f0u,0x091a3e0du,0x1e0d0e50u,0x19202e6du),\nuvec4(0x19200920u,0xf0f0f0f0u,0xf0f0f080u,0xf0f0f0f0u),\nuvec4(0x0b03d0f0u,0x3e0a0b0eu,0x1b0efdfdu,0xf0f0f008u),\nuvec4(0x0910f0f0u,0xdd0e0b3eu,0x0d5e4d1eu,0x17220b2eu),\nuvec4(0x0a0b0218u,0xf0f0f0f0u,0x1e0d0ee0u,0x600a0e0du),\nuvec4(0x1e5d2e0du,0x19302960u,0xf0f0f0f0u,0xf0f0f080u),\nuvec4(0xf0f0f0f0u,0x01d009d0u,0x4e0a1b02u,0x1d0ebdfdu),\nuvec4(0xf00d0b3eu,0xf0f0f0f0u,0x0e0d7e00u,0x091e3dfdu),\nuvec4(0x1b1e0910u,0x1b28020eu,0xf0f0f00au,0x0e00f0f0u),\nuvec4(0x090a2e0du,0x3d2e1d50u,0x9009202eu,0xf0f0f009u),\nuvec4(0xf0f090f0u,0xf0f0f0f0u,0xd009d0f0u,0x6e0b120bu),\nuvec4(0xf09ecdfdu,0xc0f0f0f0u,0x2e0d2e09u,0x0e0d1e0bu),\nuvec4(0x201b1efdu,0x184b0e09u,0xf0f00e1bu,0x20f0f0f0u),\nuvec4(0x0950094eu,0x0e0d5e1du,0x100d200au,0x2d099029u),\nuvec4(0xf0f0f009u,0xf0f000f0u,0xf0f0f0f0u,0x0bc0f0f0u),\nuvec4(0x0d0b0203u,0x1d1e0d0eu,0xfd0e2d0eu,0x0e0d6e2du),\nuvec4(0xf00a5e0du,0xb0f0f0f0u,0x1d0e1d0eu,0xfd1e1b0eu),\nuvec4(0x101b0e1du,0x0b186b09u,0xf0f0f00eu,0x0d30f0f0u),\nuvec4(0x400a094eu,0x0e0d4e09u,0x2d300e0du,0x80092009u),\nuvec4(0x090d0e09u,0xf0f01930u,0xf0f0a0f0u,0xf0f0f0f0u),\nuvec4(0x0bc0f0f0u,0x2d0a0203u,0x8d1e1d0eu,0x0d0ecd0eu),\nuvec4(0xf0091aeeu,0x90f0f0f0u,0x2e2b2e2du,0x091e0bfdu),\nuvec4(0x021b0a01u,0x0e02083bu,0xf0f0f0f0u,0x5e0d50f0u),\nuvec4(0x3e093009u,0x09203e0du,0x0d19e02du,0x0d1e0d20u),\nuvec4(0xf0f0f019u,0xf0f0f070u,0xf0f0f0f0u,0x1e03d0f0u),\nuvec4(0x0e8d0e2du,0x0d0e2dfdu,0x0ade0d3eu,0xf0f0f0f0u),\nuvec4(0x3e2b4e60u,0x0e0b1eddu,0x024b121bu,0xf0f00b08u),\nuvec4(0x60f0f0f0u,0x0a4e0d09u,0x0a200900u,0x092e2d09u),\nuvec4(0x000e0d20u,0x0009501du,0x0e091039u,0x1d00090du),\nuvec4(0x1d0e0d2eu,0xf0f0f009u,0xf0f0f040u,0xf0f0f0f0u),\nuvec4(0x0b0ac0f0u,0xaefdfd2eu,0x0e0b8e0du,0xf0f0f001u),\nuvec4(0x0b0940f0u,0x5d4e0b3eu,0x0b093d3eu,0x28020b1eu),\nuvec4(0x0a0b023bu,0xf0f0f0f0u,0x3e0970f0u,0x0ea0010au),\nuvec4(0x000e4009u,0x09500d09u,0x8d000d70u,0xf0090d3eu),\nuvec4(0xf010f0f0u,0xf0f0f0f0u,0xb0f0f0f0u,0x0e1d0e1bu),\nuvec4(0x2d0eddfdu,0x0bee0d4eu,0xf0f0f001u,0x1e0940f0u),\nuvec4(0x1e4d6e2bu,0x0b093e0du,0x5b221b1eu,0xf0f0f0f0u),\nuvec4(0x0d0990f0u,0x010a0b0eu,0x100e10f0u,0x10f0090du),\nuvec4(0x0e0a1e09u,0x092d2e1du,0xf0f01980u,0xf0f0f050u),\nuvec4(0xf0f0f0f0u,0x0801b0f0u,0x4dfdfd2eu,0x0b024bfeu),\nuvec4(0xf0f0f00au,0x0e1b20f0u,0x1e0b4e1bu,0x0e0a0e3du),\nuvec4(0x0d092e0bu,0x090e8b1eu,0xf0f0f0f0u,0x0e0db0f0u),\nuvec4(0x10f0010au,0xf00d200eu,0x0a2b0930u,0x60094d1eu),\nuvec4(0x70f0f00du,0xf0f0f0f0u,0xf0f0f0f0u,0x0b0501b0u),\nuvec4(0x0e3d0b0eu,0x1d0efdfdu,0x1b124bbeu,0xf0f0f0f0u),\nuvec4(0x3b6e0920u,0x2b3e0d0eu,0x1e090d2eu,0x1e1b024bu),\nuvec4(0xf0f0f009u,0x29d0f0f0u,0x0e50f0f0u,0x1a0b0930u),\nuvec4(0x0e3d0e1bu,0x0900090du,0x40090e0du,0x20f0f009u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x0e0201c0u,0xfd0e1d0bu),\nuvec4(0x2e0baefdu,0x025b0e0bu,0xf0f0091bu,0x4e20f0f0u),\nuvec4(0x4e0b1e1du,0x000d3e3bu,0x3e026b0du,0xf0f0f0f0u),\nuvec4(0x2e0dd0f0u,0x0a09100au,0x400af0f0u,0x1d1e1a4eu),\nuvec4(0x09a0090eu,0xf010f0f0u,0xf0f0f0f0u,0xd0f0f0f0u),\nuvec4(0x0d0e1b01u,0x0dfdfd0eu,0x1b0e4b5eu,0xf00a9b0au),\nuvec4(0x20f0f0f0u,0x5e0b4e0au,0x5e2b1e0au,0x0b025b09u),\nuvec4(0xf0f0f03eu,0x09e0f0f0u,0x090a5e1du,0x0910f0f0u),\nuvec4(0x1a2e1d0eu,0xf00d0e1bu,0xf0f0e0f0u,0xf0f0f0f0u),\nuvec4(0x2be0f0f0u,0x2d0eedfdu,0x0b2e2b4eu,0x090e9b1eu),\nuvec4(0xf0f0f0f0u,0x0e0d0e30u,0x6e2b9e0bu,0x4b020e09u),\nuvec4(0xf0f0f04eu,0x30f0f0f0u,0x0d3e0d09u,0x0201e0f0u),\nuvec4(0x1e2d091eu,0x1d19000au,0xf009e009u,0xf0f0f0c0u),\nuvec4(0xf0f0f0f0u,0x1b02f0f0u,0x9dfd1e1du,0x0b2e4d0eu),\nuvec4(0x0b0e2b0eu,0x023b0a1eu,0xf0f00e3bu,0x0b40f0f0u),\nuvec4(0x6e0b2e0du,0x1e1b0e0du,0x0e1d0e0bu,0x5e4b0a0du),\nuvec4(0xf0f0f0f0u,0x09c0f0f0u,0x3900190du,0xf0091d30u),\nuvec4(0x1e0d0e20u,0x1d092009u,0xf0c0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x0e0d1b02u,0x4ecd1e9du,0x0e0b2e3du),\nuvec4(0x222b0e4bu,0xf0090e3bu,0x30f0f0f0u,0x0b0e0b09u),\nuvec4(0x098e2b5eu,0x1b0e1b1eu,0x2e0d0b0du,0xf0090e0bu),\nuvec4(0xf0f0f0f0u,0x4019f0f0u,0x50f00e09u,0x1d094031u),\nuvec4(0xf009d009u,0xf0f0f0b0u,0xf0f0f0f0u,0x0200f0f0u),\nuvec4(0x3d1ead1bu,0x0b3e4d2eu,0x0b4e0d1eu,0x0a0e3b0au),\nuvec4(0xf00a0e8bu,0x50f0f0f0u,0x1e1d3e0bu,0x1e1d4e0au),\nuvec4(0x0b1a2e0bu,0x090e0a0eu,0xf0f06e0du,0xf0f0f0f0u),\nuvec4(0x300910f0u,0x2170f00au,0xf0f03950u,0xf0f0f090u),\nuvec4(0xf0f0f0f0u,0x0200f0f0u,0x6d0e0d1bu,0x2d2e6d1eu),\nuvec4(0x4b4e1d6eu,0x5b022b1eu,0xf0f0f00au,0x0b0960f0u),\nuvec4(0x0a1e0d3eu,0x0b5e1d3eu,0x1a0b1e0au,0x2b2e0a09u),\nuvec4(0xf0f00d0eu,0xf0f0f0f0u,0x0af0f0f0u,0xf0f0f001u),\nuvec4(0xf0f0f030u,0xf0f0f0f0u,0x0210f0f0u,0x3e0dfd1bu),\nuvec4(0x1e0d2e1du,0x1e0a1e2du,0x0e8b0a5bu,0xf0f0f0f0u),\nuvec4(0x2b0e0970u,0x2e1a2e0au,0x2e1d1e0du,0x0b0a0d0bu),\nuvec4(0x000d1b0eu,0x090e2b2eu,0xf0f0f0f0u,0xe0f0f0f0u),\nuvec4(0x090a011au,0x0d700120u,0xf0f0f001u,0xf0f0f030u),\nuvec4(0xf0f0f0f0u,0x1210f0f0u,0x2d2ead1bu,0x0d0e2d2eu),\nuvec4(0x2d0e0b0eu,0x5b024b3eu,0xf00e1b1eu,0x80f0f0f0u),\nuvec4(0x4e2b1e0au,0x6e2d0a0bu,0x2b0e0a0du,0x0a3b2e19u),\nuvec4(0xf0f0f0f0u,0xe0f0f0f0u,0x2a3b0a01u,0x0e095009u),\nuvec4(0xf0f0f009u,0xf0f0f030u,0xf0f0f0f0u,0x2220f0f0u),\nuvec4(0x2d5e7d0bu,0x0b0e0d5eu,0x2a1e1d0eu,0x023b024bu),\nuvec4(0x0e1b0e0bu,0xf0f0f009u,0x1e5b70f0u,0x4e1b2e0bu),\nuvec4(0x1e0b0e1du,0x0a2b0e0bu,0x0e0d0e09u,0x0aa00a3bu),\nuvec4(0xf0f0f00bu,0xf0f0f0f0u,0x0a6b0a10u,0x0d0e0960u),\nuvec4(0x30f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x080220f0u),\nuvec4(0x2b0a1b02u,0x2e2d5e3du,0x2e0b0e2bu,0x0a2b0e2bu),\nuvec4(0xf0090eabu,0x80f0f0f0u,0x1a3e4b02u,0x1e0d4e2bu),\nuvec4(0x094b0e1bu,0x900a2b3eu,0xf00b0e09u,0xf0f0f0f0u),\nuvec4(0x0900f0f0u,0x50090a7bu,0x010e0b0au,0x20f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x070120f0u,0x0b023b12u),\nuvec4(0x1e4d4e2du,0x3b025bfbu,0xf0f0090eu,0x0170f0f0u),\nuvec4(0x1b0a3b02u,0x1e0a0e0au,0x1e2b0e2bu,0x0e1b1e1bu),\nuvec4(0x2e0b0a1bu,0x1d0b903bu,0xf0f0f009u,0x90f0f0f0u),\nuvec4(0x01002b01u,0x5009018bu,0xf01a1b0au,0xf010f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x08070130u,0x0b221802u),\nuvec4(0x4e4d2e3du,0x090e7bfbu,0xf0f0f0f0u,0xfb120870u),\nuvec4(0x1e0a3e5bu,0x0e1b0e1bu,0x0a800e1bu,0xf0090d1bu),\nuvec4(0xf0f0f0f0u,0x1b0180f0u,0x320b0802u,0x4b60015bu),\nuvec4(0x09d0f009u,0xf0f010f0u,0xf0f0f0f0u,0x40f0f0f0u),\nuvec4(0x02180201u,0x0b010b18u,0x3e2d1e3du,0x5bfb0e1bu),\nuvec4(0x0d0e0b0eu,0xf0f0f0f0u,0xbb080770u,0x1b0efb02u),\nuvec4(0x60091b3eu,0xf0193b0au,0xf0f0f0f0u,0x022b80f0u),\nuvec4(0x016b4218u,0x0d3b0240u,0x00f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x170160f0u,0x2d0a1228u,0xfbbe0d0eu),\nuvec4(0x0e0b0a1bu,0xf0090e0bu,0x60f0f0f0u,0x1b080501u),\nuvec4(0x1b122b32u,0x6b0a6b02u,0x095e0b0au,0x0b023b50u),\nuvec4(0xf0f0f01du,0x60f0f0f0u,0x121b0109u,0x080b1208u),\nuvec4(0x4b020802u,0x00211b02u,0x0b022b01u,0xe0f0f00au),\nuvec4(0xf0f0f019u,0xf0f0f0f0u,0x0180f0f0u,0x0e1b4807u),\nuvec4(0x1e1b1e0du,0x0e2d0e0du,0x0a1bfb0au,0x0e0b0e0bu),\nuvec4(0xf0f0f009u,0x070160f0u,0x1b521822u,0x6b0a6b02u),\nuvec4(0x3e0b0a0eu,0x2b096009u,0x090e1b02u,0xf0f0f0f0u),\nuvec4(0x1b60f0f0u,0x08024832u,0x1b124b02u,0x4b121102u),\nuvec4(0xf0f0f009u,0xf0f0f0f0u,0xf0f0f0f0u,0x170190f0u),\nuvec4(0x0b122708u,0x3d2e1b1eu,0x2b1a2bfbu,0xf0f0010eu),\nuvec4(0x0160f0f0u,0x08272805u,0x4b221b42u,0x805e5b02u),\nuvec4(0xf00d5b09u,0xf0f0f0f0u,0x483270f0u,0x08321822u),\nuvec4(0x08020822u,0x020b0802u,0x0d0b120bu,0x1db0f0f0u),\nuvec4(0xf0f0f010u,0xf0f0f0f0u,0x07b0f0f0u,0x2b181708u),\nuvec4(0x3d4e0b0du,0x3b0e1bfbu,0xf0f0f00au,0x070880f0u),\nuvec4(0x32080718u,0x320b2208u,0x0a4b023bu,0x4b09904eu),\nuvec4(0xf0f0f01du,0x60f0f0f0u,0x4822880bu,0x1b328802u),\nuvec4(0xf0f0f00du,0xf0f0f0f0u,0xf0f0f0f0u,0x1807b0f0u),\nuvec4(0x0b020827u,0x0a5e1b0eu,0x0e0a2bfbu,0xf00a0e1bu),\nuvec4(0x90f0f0f0u,0x1b121817u,0x0a0b0238u,0x0b127b22u),\nuvec4(0x0ab0092eu,0xf0f01d3bu,0xf0f0f0f0u,0xb8f80150u),\nuvec4(0x090a4b12u,0xf0d0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x170827b0u,0x0e0a0802u,0x1e1b3e2bu,0x2b0e0bfbu),\nuvec4(0xf0f0f00eu,0x2802a0f0u,0x27021b02u,0x020b6218u),\nuvec4(0x020b022bu,0xc00a1e0au,0x090d3b0au,0xf0f0f0f0u),\nuvec4(0x0a20f0f0u,0x9827280bu,0x48029807u,0xf0f00a5bu),\nuvec4(0xf0f0f0c0u,0xf0f0f0f0u,0x08b0f0f0u,0x12070527u),\nuvec4(0x6e2b0e0du,0x091a3bfbu,0xf0f0f0f0u,0x081708b0u),\nuvec4(0x17226812u,0x020b1208u,0x0b0e0a3bu,0x0b09b00au),\nuvec4(0x1e0b0208u,0xf0f0f0f0u,0x1b01f0f0u,0x02b82778u),\nuvec4(0x02181788u,0x50f00a4bu,0xf040f009u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x080508b0u,0x2b1a1827u,0x9b0acb4eu),\nuvec4(0xf0f0f0f0u,0x050702c0u,0x07183208u,0x0a5b5248u),\nuvec4(0x1bb00e0bu,0x0d0e0b12u,0xf0f0f0f0u,0xf80be0f0u),\nuvec4(0x07a81278u,0x0e0b3228u,0x0950f009u,0xf0f030f0u),\nuvec4(0xf0f0f0f0u,0xb0f0f0f0u,0x08270508u,0x0e0d0207u),\nuvec4(0x3e1b0e2bu,0x1a0e2afbu,0xf0f0f0f0u,0x070c04d0u),\nuvec4(0x32782208u,0x0e5b220bu,0x4b099009u,0xf0f0090eu),\nuvec4(0xc0f0f0f0u,0xa832180au,0x0b027807u,0x07080758u),\nuvec4(0x22280728u,0xf0010a1bu,0x20f00950u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x0b67b0f0u,0x0e0a2b0du,0x0a5b4e1bu),\nuvec4(0x0a0e4b0eu,0xf01a0d0eu,0xf0f0f0f0u,0x08070c02u),\nuvec4(0x18027802u,0x0e0a5b52u,0x121ba009u,0xf0f00e0bu),\nuvec4(0xd0f0f0f0u,0x021b0248u,0x023802b8u,0x27580208u),\nuvec4(0x12480708u,0xf0f0094bu,0xf0f0f080u,0xf0f0f0f0u),\nuvec4(0x01a0f0f0u,0x2b0e0a67u,0x4e1a0e0au,0x3b0e1a5bu),\nuvec4(0xf0f00d0eu,0x30f0f0f0u,0x48050c02u,0x0b326807u),\nuvec4(0xa0097b02u,0x0d0e220bu,0xf0f0f0f0u,0x5801c0f0u),\nuvec4(0x4842f822u,0x0b225837u,0xf00a1b02u,0xf0f080f0u),\nuvec4(0xf0f0f0f0u,0xa0f0f0f0u,0x08170501u,0x0a1d0217u),\nuvec4(0x4b9e0a0bu,0xf0091d3eu,0xf0f0f0f0u,0x07050250u),\nuvec4(0x02183748u,0x09cb0208u,0x1b180ba0u,0xf0f0f009u),\nuvec4(0x02c0f0f0u,0x58f80718u,0x58376822u,0x0b024b02u),\nuvec4(0x70f0f00au,0xf0f0f0f0u,0xf0f0f0f0u,0x1701a0f0u),\nuvec4(0x0b081708u,0x0ade0a0du,0xf02d0a3eu,0xf0f0f0f0u),\nuvec4(0x77082780u,0x124b0218u,0x01c00a4bu,0xf00a0b12u),\nuvec4(0xf0f0f0f0u,0x171801d0u,0x2857d8f8u,0x3b0d1b22u),\nuvec4(0x60f0f01au,0xf0f0f0f0u,0xf0f0f0f0u,0x3801a0f0u),\nuvec4(0x1a0b0807u,0x3e0a2e0bu,0x1e0d7e0au,0xf0f0f00du),\nuvec4(0x1790f0f0u,0x22087718u,0x1a0b122bu,0x00f00a0bu),\nuvec4(0xf0f0f001u,0x09f0f0f0u,0xd80208f8u,0x08270537u),\nuvec4(0x3b221807u,0x0d0a1b02u,0xf050f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x081701a0u,0x0e0b0817u,0x2e0a0e0bu),\nuvec4(0x0a0e1b0au,0x0e0d0a1eu,0xf0f04d1au,0x90f0f0f0u),\nuvec4(0x48870c07u,0xf00a2b52u,0xf0f0f0f0u,0x0a10f0f0u),\nuvec4(0x68125802u,0x28122802u,0x15174802u,0x08270507u),\nuvec4(0x1b221807u,0x0d0a2b12u,0xf050f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x080728a0u,0x1e1b0a17u,0x0a0e2b0au),\nuvec4(0x1d0e1a1eu,0xf0f04d1eu,0x90f0f0f0u,0x18270c01u),\nuvec4(0x08121837u,0xf00a2b52u,0xf0f0f0f0u,0x0b20f0f0u),\nuvec4(0xf8029802u,0x171c1718u,0x02283705u,0x0d2b222bu),\nuvec4(0xf050f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x170807a0u),\nuvec4(0x0a080208u,0x1e2b0a2bu,0x1e1d0e0au,0x0e0a0b2au),\nuvec4(0xf0f0f02du,0x17a0f0f0u,0x37081708u,0x18020b12u),\nuvec4(0xf0093b32u,0xf0f0f0f0u,0x0a20f0f0u,0xf802480bu),\nuvec4(0x371c3748u,0x020b1268u,0xf03b020bu,0xf0f050f0u),\nuvec4(0xf0f0f0f0u,0x90f0f0f0u,0x12071809u,0x1b1a0708u),\nuvec4(0x1a1d1b0au,0x1a5b0e1du,0xf0090d0eu,0xf0f0f0f0u),\nuvec4(0x670807b0u,0x22182208u,0xf0f0f04bu,0xf0f0f0f0u),\nuvec4(0x28120b40u,0xf8220812u,0x05171537u,0x18170807u),\nuvec4(0x3b221802u,0xf0090d0au,0xf0f040f0u,0xf0f0f0f0u),\nuvec4(0x90f0f0f0u,0x0807080bu,0x1b0a1b22u,0x0b1a1b0au),\nuvec4(0x0e0a6b0au,0xf0f0092du,0xd0f0f0f0u,0x22085708u),\nuvec4(0x1a2b3208u,0xf0f0f0f0u,0x50f0f0f0u,0x0b020b0au),\nuvec4(0x1b120b02u,0x02180b02u,0x050c37c8u,0x08470507u),\nuvec4(0x0e0d4b52u,0xf050f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x07020190u,0x4b020812u,0x0e2b0a0du,0x0d0a2e7bu),\nuvec4(0xf0f0f0f0u,0x0802e0f0u,0x38071817u,0xf00a3b32u),\nuvec4(0xf0f0f0f0u,0x0960f0f0u,0x025b021bu,0x520b180bu),\nuvec4(0x27056778u,0x12081228u,0xf0f01d4bu,0xf0f0f050u),\nuvec4(0xf0f0f0f0u,0x0b90f0f0u,0x4b023802u,0x1a1b0a0eu),\nuvec4(0x090b1e8bu,0xf0f0f0f0u,0x9801e0f0u,0xf0093b32u),\nuvec4(0xf0f0f0f0u,0x1b70f0f0u,0x022b0802u,0x1218324bu),\nuvec4(0x47082788u,0x021b0228u,0x0d2b0a1bu,0x50f0f009u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x180b90f0u,0x3b02180bu),\nuvec4(0x1b0adb02u,0xf0f0f00au,0x00f0f0f0u,0x5812080bu),\nuvec4(0xf00a3b22u,0xf0f0f0f0u,0x0a80f0f0u,0x526b221bu),\nuvec4(0x0738123bu,0x07081738u,0x022b0228u,0x0e1b0a1bu),\nuvec4(0xf0f0090du,0xf0f0f050u,0xf0f0f0f0u,0x0a90f0f0u),\nuvec4(0x08020802u,0x023b0807u,0x090b0adbu,0xf0f0f0f0u),\nuvec4(0x7220f0f0u,0x092b220bu,0xf0f0f0f0u,0x90f0f0f0u),\nuvec4(0x021b0e09u,0x0a6b0a4bu,0x121b0a40u,0x68121807u),\nuvec4(0x1d0a7b02u,0xf060f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x040b0990u,0x0b122b32u,0x090abb02u,0xf0f0f0f0u),\nuvec4(0x1b30f0f0u,0x28020b02u,0x090a3b02u,0xf0f0f0f0u),\nuvec4(0xa0f0f0f0u,0x120b0d09u,0x0a0d1a2bu,0x09a0091bu),\nuvec4(0x020b122bu,0x1d6b1258u,0xf0f0090eu,0xf0f0f060u),\nuvec4(0xf0f0f0f0u,0x0d90f0f0u,0x020b040bu,0x1e3b322bu),\nuvec4(0xf00d0e6bu,0xf0f0f0f0u,0x121b40f0u,0x0a4b021bu),\nuvec4(0xf0f0f0f0u,0xc0f0f0f0u,0x021b0d09u,0x0e1b0e1bu),\nuvec4(0x09d0090du,0x081b0a2bu,0x1812081bu,0x091d5b02u),\nuvec4(0xf070f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x040a0e90u),\nuvec4(0x6b223b02u,0xf01a4b0eu,0xf0f0f0f0u,0x0a0950f0u),\nuvec4(0xf0390a2bu,0xf0f0f0f0u,0x0df0f0f0u,0x192b0a0eu),\nuvec4(0x00f01900u,0x1b190b0au,0x1b120b02u,0xf01d5b22u),\nuvec4(0xf0f080f0u,0xf0f0f0f0u,0x80f0f0f0u,0x04020e09u),\nuvec4(0x3b023b02u,0x1a6b0e0au,0xf0f0f009u,0x80f0f0f0u),\nuvec4(0xf0f0f009u,0xf0f0f0f0u,0x0d0970f0u,0x60f0090eu),\nuvec4(0x090a0019u,0x223b021bu,0xf0090d5bu,0xf0f080f0u),\nuvec4(0xf0f0f0f0u,0x80f0f0f0u,0x12140e0du,0x0a5b020bu),\nuvec4(0x090b4a0eu,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x0a1920f0u,0x0a1b028bu,0xf0090b0du),\nuvec4(0x700d09f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x0e0970f0u),\nuvec4(0x2204050au,0x0a5b020bu,0xf03e0d0eu,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x0e9b0a60u),\nuvec4(0xf00d0a0du,0x601910f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x021d70f0u,0x2b020804u,0x1e1a8b02u,0xf0f0f009u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x0e60f0f0u),\nuvec4(0x0d0a4b1au,0xf0f01d19u,0xf0501920u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x421d0960u,0x1a1b0aabu,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x2e0a70f0u),\nuvec4(0x0d192e0au,0x20f0f029u,0x40090e09u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x1d0960f0u,0x5b1a4b42u,0xf0f0f01au),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x09a0f0f0u),\nuvec4(0x0e191e0au,0xf0f0090du,0x2d0e0950u,0xf0f01009u),\nuvec4(0xf0f0f0f0u,0x70f0f0f0u,0x04020d0eu,0x2b1a4b22u),\nuvec4(0xf0f0090au,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x1dc0f0f0u,0xf0f02029u,0xf0f0f0f0u),\nuvec4(0x70f0f0f0u,0x2b020a0du,0x1b1a3b12u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0d0e09f0u,0xf0f0300au,0xf0f0f0f0u,0x60f0f0f0u),\nuvec4(0x020b0e09u,0x0a4b023bu,0xf0f0f01bu,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x1e00f0f0u),\nuvec4(0xf0f0f040u,0xf0f0f0f0u,0x0d60f0f0u,0x197b1209u),\nuvec4(0xf0f0090au,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x19001960u,0x2910f0f0u,0x40090e00u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x521960f0u,0xf001022bu),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0d1990f0u,0xf0f00d0eu,0x0a0d1900u,0xf0f0f070u),\nuvec4(0xf0f0f0f0u,0x0960f0f0u,0x121b0200u,0x093b0208u),\nuvec4(0xf0f0f00au,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x80f0f0f0u,0x090e0d09u,0x0900f0f0u,0xf0f0801au),\nuvec4(0xf0f0f0f0u,0x70f0f0f0u,0x422b0301u,0xf0f0f01bu),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xa0f0f0f0u),\nuvec4(0x01f0f029u,0xf0901a02u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0b120b70u,0x0b121812u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x0b1209c0u),\nuvec4(0xf090090au,0xf0f0f0f0u,0xf0f0f0f0u,0x0b000950u),\nuvec4(0x083b0804u,0xf0f01b02u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x02b0f0f0u,0xf0b00a2bu),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x3b121950u,0xf0f00b12u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x09c0f0f0u,0xc01b080bu,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0a1940f0u,0x1b020304u,0xf0f01b02u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x09c0f0f0u),\nuvec4(0xc0092e0du,0xf0f0f0f0u,0xf0f0f0f0u,0x050950f0u),\nuvec4(0x1b021b24u,0xf0f0f009u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xe009e0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x050250f0u,0x0b421814u,0xf0f0f00au),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0c0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x03020940u),\nuvec4(0x22080715u,0x090b0208u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0c0f0u),\nuvec4(0xf0f0f0f0u,0x30f0f0f0u,0x06030b09u,0x02180504u),\nuvec4(0x0a0b0208u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f00100u,0xf0f0f0f0u,0xc0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x030240f0u,0x02280406u,0xf00b020bu),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x10f0f0f0u,0xf0f00103u),\nuvec4(0xf0f0f0f0u,0xb0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x040140f0u,0x08030405u,0x090a1b02u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x40f0f0f0u,0x04060201u),\nuvec4(0xf02b0208u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f010f0u,0xf0f0f0f0u),\nuvec4(0x40f0f0f0u,0x5b040901u,0x0a0ba001u,0xf0f0090bu),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x10f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x090140f0u),\nuvec4(0xb00a2b32u,0xf0f0f009u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf030f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x02041150u,0x012b090au,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f00170u,0xf0f0f0f0u),\nuvec4(0x60f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x040160f0u),\nuvec4(0x01090302u,0xf0f0092bu,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xe0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x030180f0u,0x1b020314u,0x70f0f009u),\nuvec4(0xf0f01201u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f020f0u,0xf0f0f0f0u,0xa0f0f0f0u),\nuvec4(0x1a0b0211u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0e0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x90f0f0f0u,0xf0f0f001u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x40f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf00190f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f040f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x80f0f0f0u,0xf0f0f001u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x50f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x11b0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f010f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x01400190u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xf0f0f0e0u,0xf0f0f0f0u,0xa0f0f0f0u),\nuvec4(0xf0112201u,0xf0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xe0f0f0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x0140f0f0u,0x02000100u,0xf0f01224u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0xa0f0f0f0u,0xf0f0f001u,0xf0f0f0f0u),\nuvec4(0xf0f0f040u,0xf0f0f0f0u,0x40f0f0f0u,0x03140312u),\nuvec4(0xf0f0f002u,0xf0f0f0f0u,0xf0f0f0f0u,0x02b0f0f0u),\nuvec4(0x01600104u,0xf0f0f0f0u,0xf0c0f0f0u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x000110f0u,0x24050401u,0xf0f0f003u),\nuvec4(0xf0f0f0f0u,0x00f0f0f0u,0xc0f0f021u,0x0224a001u),\nuvec4(0x21120100u,0x01d021b0u,0x02032403u,0xf0f0f001u),\nuvec4(0xf0f070f0u,0xf0f0f0f0u,0xf0f0f0f0u,0x05040110u),\nuvec4(0xf0140514u,0xf0f0f0f0u,0xf0f0f0f0u,0x040309c0u),\nuvec4(0x04260506u,0xf0f00102u,0x02200120u,0x10012403u),\nuvec4(0x04030251u,0x22030403u,0x21331403u,0x14030b20u),\nuvec4(0x70110406u,0x56140211u,0x16052403u,0x03040604u),\nuvec4(0xf0f01104u,0xf0f090f0u,0xf0f0f0f0u,0xd0f0f0f0u),\nuvec4(0x34051213u,0xf0010415u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x03100160u,0x24020102u,0x140c160cu,0xf0f00102u),\nuvec4(0x04050601u,0x25140506u,0x05267504u,0x05440354u),\nuvec4(0x53941304u,0x05461534u,0x44057604u,0xf0321425u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0xd0f0f0f0u,0x04020002u),\nuvec4(0x01034425u,0xf0f0f0f0u,0xf0f0f0f0u,0x020120f0u),\nuvec4(0x03040514u,0x25060514u,0x1c050426u,0x02140514u),\nuvec4(0x02113214u,0x150201e0u,0x060c0504u,0x140516e5u),\nuvec4(0x05164405u,0x640506f4u,0x7415a605u,0x14050435u),\nuvec4(0xf0020405u,0xf0f0e0f0u,0xf0f0f0f0u,0xf0f0f0f0u),\nuvec4(0x54152401u,0xf0f0f001u,0xf0f0f0f0u,0x702110f0u),\nuvec4(0x36040301u,0x1416050cu,0x26250405u,0x26452c15u),\nuvec4(0x04251405u,0x01900102u,0x253c0604u,0x1506e50cu),\nuvec4(0x25164506u,0x453605e4u,0x357405a6u,0x1625061cu),\nuvec4(0x02030405u,0xf0023124u,0xf0f030f0u,0xf0f0f0f0u),\nuvec4(0x80f0f0f0u,0x00031402u,0x44251411u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x12242201u,0x56040140u,0x0c06050cu),\nuvec4(0x360c3516u,0x550c162cu,0x0344153cu,0x11200102u),\nuvec4(0x0c050402u,0x06e54c15u,0x16850625u,0x0c05d6e4u),\nuvec4(0x54250615u,0x0516f625u,0x12040524u,0xf0d0f011u),\nuvec4(0xf0f0f0f0u,0xf0f0f0f0u,0x04220130u,0x04132405u),\nuvec4(0x06052c05u,0xf0011405u,0xf0f0f0f0u,0x12040230u),\nuvec4(0x02311031u,0x64310201u,0x21302132u,0x01122402u),\nuvec4(0x13240604u,0x15040311u,0x0c860506u,0x04259c05u),\nuvec4(0x24032475u,0x24020412u,0xa5f54c75u,0xe615d436u),\nuvec4(0x0514050cu,0x960c2544u,0x05660c05u,0x14160524u),\nuvec4(0xf0010405u,0xf0f0f0a0u,0xf0f0f0f0u,0x0130f0f0u),\nuvec4(0x64251402u,0x34050615u,0xf0f0f001u,0x220160f0u),\nuvec4(0x16f54403u,0x94130405u,0x03040203u,0x03040314u),\nuvec4(0x03040304u,0x650c2534u,0x0cc60546u,0x1c661c16u),\nuvec4(0x02032415u,0x2213120bu,0x1c252c25u,0x14c56c05u),\nuvec4(0xd4156655u,0x3435d615u,0x1c861c45u,0x45363506u),\nuvec4(0x060c050cu,0x04020315u,0xf010f051u,0xf0f0f0f0u),\nuvec4(0xf0f0f0f0u,0x25023120u,0x65340504u,0xf0f0f014u),\nuvec4(0x040240f0u,0x05140c05u,0x351c0506u,0x453c0534u),\nuvec4(0x03242504u,0x03141534u,0x25045594u,0x04030204u),\nuvec4(0x561ce615u,0x051c161cu,0x0224451cu,0x5504421au),\nuvec4(0x65ac052cu,0x15565564u,0x05041544u,0x06f62504u),\nuvec4(0x2504850cu,0x050c260cu,0x051cd526u,0x0516050cu),\nuvec4(0x44120406u,0x01020405u,0xf0f0f0e0u,0xd0f0f0f0u),\nuvec4(0x24053401u,0x34c0f002u,0x44353445u,0xf0f0f0f0u),\nuvec4(0x03141201u,0x05263c06u,0x0504052cu,0x050c152cu),\nuvec4(0x0514650cu,0x25340504u,0x32040344u,0x05040203u),\nuvec4(0x01540504u,0x1cb50402u,0xa4357c35u,0x021b1a02u),\nuvec4(0x4514020bu,0x050c0504u,0x752c363cu,0x35362594u),\nuvec4(0xf60c6524u,0x14351c16u,0x04450425u,0x54450445u),\nuvec4(0x050c2675u,0x02040284u,0xf0f0c001u,0xf0f0f0f0u),\nuvec4(0x0c2504c0u,0x44260c15u,0x11122403u,0x05040190u),\nuvec4(0x10110304u,0x15043501u,0x050c062cu,0xf0f00144u),\nuvec4(0x030170f0u,0x04551402u,0x2c461c05u,0x2c160c05u),\nuvec4(0x95049536u,0x35541334u,0x02040544u,0x84b5f514u),\nuvec4(0x09012203u,0x14131201u,0x14050405u,0x2c465c05u),\nuvec4(0x447584b5u,0x4cf61c25u,0x1445c425u,0x2c455455u),\nuvec4(0x04150c06u,0x34250405u,0xf0f0d012u,0x02a0f0f0u),\nuvec4(0xe0f00103u,0x36350401u,0x15160425u,0x152c0504u),\nuvec4(0x01102104u,0x02040503u,0x05041504u,0x060c3544u),\nuvec4(0x440c1605u,0xf0f0f002u,0x0c450470u,0x066c1506u),\nuvec4(0x060c152cu,0x0c35f51cu,0x1c060c15u,0x04753465u),\nuvec4(0xb5f52435u,0x29114264u,0x1c15a402u,0x2c260c16u),\nuvec4(0x1554f4b5u,0x155cf61cu,0x15740504u,0x9504d514u),\nuvec4(0x6405245cu,0xf0f0e001u,0x3150f0f0u,0x14350c04u),\nuvec4(0x04050605u,0x02030405u,0x04020304u,0x12a03103u),\nuvec4(0x561c2504u,0x0c361504u,0x24151c06u,0x74053403u),\nuvec4(0x44551425u,0x10f0f0f0u,0x02011211u,0x03045504u),\nuvec4(0xf52c7504u,0x0c052ca5u,0x1c058c16u,0xe5f50485u),\nuvec4(0x35c472a4u,0x1c06051cu,0x3544f4b5u,0x2c06f60cu),\nuvec4(0x64050455u,0x250cb5f5u,0x2412350cu,0xf020f011u),\nuvec4(0x3190f0f0u,0x0c152402u,0x06650605u,0x54050405u),\nuvec4(0x34151415u,0x02010405u,0x02040506u,0x23012001u),\nuvec4(0x0c051402u,0x14051415u,0x260c0402u,0x0514151cu),\nuvec4(0x03540524u,0x35042504u,0x0534250cu,0xf0f00104u),\nuvec4(0x950110f0u,0x0445f506u,0x9c950ca5u,0xd5f55c05u),\nuvec4(0xf4f40534u,0xb53c2564u,0x4c3524f4u,0xd4351ce6u),\nuvec4(0x2245f5f5u,0xf040f011u,0x1211d0f0u,0x04033403u),\nuvec4(0x15061506u,0x15042504u,0x050c4504u,0x05e405a4u),\nuvec4(0x55b40514u,0x453c1504u,0x05940544u,0x35344514u),\nuvec4(0xf0010204u,0x0302b0f0u,0xb5542504u,0x55140514u),\nuvec4(0x1415f504u,0x3c050c35u,0x2c252c05u,0x04756495u),\nuvec4(0x54051435u,0xf4033213u,0x551475a4u,0x3c3544f4u),\nuvec4(0xf5f54ce6u,0x1403c465u,0x40f02102u,0x01a0f0f0u),\nuvec4(0x16150403u,0x05042605u,0x050c0526u,0x051c0514u),\nuvec4(0x1c250c06u,0x1514f405u,0x75260504u,0xc5740564u),\nuvec4(0x250405d4u,0x031425e4u,0xf0f00102u,0x13121130u),\nuvec4(0x05044594u,0xf50c3564u,0x052c15f5u,0x150c151cu),\nuvec4(0x65d4651cu,0xf4f40374u,0x25040504u,0x7504f4f4u),\nuvec4(0x2504b5bcu,0x15149514u,0x45241504u,0xf00114f4u),\nuvec4(0x41e0f070u,0x04020130u,0x56051c25u,0x0c054c95u),\nuvec4(0x1403c425u,0x14252435u,0x14050415u,0x34453405u),\nuvec4(0x84850405u,0x0203a425u,0x5213e403u,0x01a0f011u),\nuvec4(0x03240312u,0x04f40324u,0xf5f50425u,0x650c050cu),\nuvec4(0x4445f52cu,0x041564f5u,0x84f4f425u,0xf574f403u),\nuvec4(0x44050405u,0xf4258405u,0x15943514u,0x01130224u),\nuvec4(0xa0f060f0u,0x24053631u,0x96251405u,0x14150405u),\nuvec4(0x25e4f495u,0x073425d4u,0xf4130403u,0x12040374u),\nuvec4(0x54030204u,0x1203e213u,0x12215001u,0x32012031u),\nuvec4(0x23042394u,0x050465a4u,0x05042504u,0x06c5f536u),\nuvec4(0x84c5f50cu,0x14b51c65u,0xf4f4f415u,0x0504f574u),\nuvec4(0x34f4f4f4u,0x11020435u,0x02100112u,0x14050405u),\nuvec4(0x12034415u,0x03842001u,0x24021192u,0x06154455u),\nuvec4(0xf4b50405u,0x55d4f4f4u,0x03021384u,0x03740234u),\nuvec4(0xf2140284u,0x34021192u,0x01630223u,0x32133412u),\nuvec4(0xe4136423u,0x04c51cb5u,0x06b51405u,0xf50c051cu),\nuvec4(0x0c2524f4u,0xf4e50c16u,0xc5b4f4f4u,0x05840504u),\nuvec4(0x7405f4f4u,0x14250405u,0x02032405u,0x14031201u),\nuvec4(0x0c051405u,0x2c25a506u,0x04050485u,0xf4051635u),\nuvec4(0x0544f4f4u,0xa5f445d4u,0x440322f4u,0x22030413u),\nuvec4(0x03e2f213u,0x04124344u,0x03640203u,0x02040312u),\nuvec4(0x04022364u,0x24233403u,0x2c053403u,0xf56475f5u),\nuvec4(0x1524f485u,0xf4f4f4f4u,0x0504d5f4u,0x45240514u),\nuvec4(0xf415e4f4u,0x15348534u,0x25241504u,0x85043514u),\nuvec4(0xf4f40524u,0xf4f403a4u,0x0594f455u,0x22240374u),\nuvec4(0x04033403u,0xf2033203u,0x243211b2u,0x12242305u),\nuvec4(0x04035403u,0xa4031203u,0x04031403u,0x54030413u),\nuvec4(0x1c050432u,0x04550485u,0xa534f435u,0xf4f4f4f4u),\nuvec4(0x1514f4f4u,0x2415f534u,0xf4350405u,0x250425f4u),\nuvec4(0x04220334u,0xf4556413u,0xc4f435e4u,0x24130403u),\nuvec4(0xf4f40203u,0x44f4f4f4u,0xf2131433u,0x13c20432u),\nuvec4(0x24335422u,0x32434403u,0x04130403u,0x13040223u),\nuvec4(0x54120312u,0x34453435u,0xf4351405u,0xf4f4f4f4u),\nuvec4(0x74f4f4f4u,0x840504f5u,0xe4f4f405u,0x11121405u),\nuvec4(0x94f41312u,0x0384f4f4u,0x541332f2u,0xf4f4f413u),\nuvec4(0xf203b4f4u,0x03621332u,0x03b45312u,0x12012322u),\nuvec4(0x04630203u,0x24030403u,0x32030203u,0x350c6524u),\nuvec4(0xf4f41504u,0xf4f4f4f4u,0x44f4f4f4u,0x34050435u),\nuvec4(0xf4f4f405u,0x130413b4u,0x24030402u,0xf4d4f403u),\nuvec4(0x033453f4u,0x32f20302u,0xf4032433u,0xa4f4f4f4u),\nuvec4(0x24037213u,0x234453f3u,0x22210234u,0x02130453u),\nuvec4(0x94134463u,0x0c750405u,0x04151c15u,0xf4f4f425u),\nuvec4(0xf4f4f4f4u,0xf405f4f4u,0x140564f4u,0x0394f405u),\nuvec4(0x24030284u,0xf4130403u,0x73c4f444u,0x03122304u),\nuvec4(0x140322f2u,0xf4134403u,0xa4f4f4f4u,0x24034433u),\nuvec4(0x020302d3u,0x04030203u,0x04134403u,0x12210213u),\nuvec4(0x44031203u,0xf4232403u,0x050465b4u,0xf4f4f4f4u),\nuvec4(0xf4f4f4f4u,0x04f4f4f4u,0xf4359445u,0x032413a4u),\nuvec4(0x13120112u,0x23d47304u,0x13040304u,0xf3f41304u),\nuvec4(0x245324a3u,0x84f4f453u,0x0384f425u,0x03049304u),\nuvec4(0x23322374u,0x05640342u,0x02f20334u,0xf4f4f4f4u),\nuvec4(0xf4f4f4f4u,0xf4f4f4f4u,0xf435e4f4u,0x223364f4u),\nuvec4(0x12040314u,0x12030213u,0xf3435463u,0x54739473u),\nuvec4(0x14134483u,0xf4130413u,0x24f4f4f4u,0x0302f203u),\nuvec4(0x53022354u,0x01020304u,0x24f40204u,0x64037243u),\nuvec4(0x24f41302u,0x54038403u,0x04231473u,0xf4f4f433u),\nuvec4(0xf4f4f4f4u,0xf4f4f4f4u,0x0374f4f4u,0x23020332u),\nuvec4(0x33142302u,0x03122304u,0x63220322u,0xf3040314u),\nuvec4(0x030493f3u,0xc4f42304u,0xa4130213u,0x04252405u),\nuvec4(0x23727425u,0x03340344u,0x03140304u,0x04432112u),\nuvec4(0xf4032403u,0x137405d4u,0xf4030204u,0x02140274u),\nuvec4(0xf4f41204u,0xf4f4f4f4u,0x94f4f4f4u,0x02035403u),\nuvec4(0x74f4f413u,0x4244f465u,0x02131231u,0x43041214u),\nuvec4(0x22110314u,0x13023413u,0xd4120302u,0x343332a3u),\nuvec4(0x94032403u,0x04131403u,0x04037403u,0xf4f4f413u),\nuvec4(0x030443e4u,0x03840314u,0x040524f4u,0x54051485u),\nuvec4(0x14053415u,0xd4150455u,0xf4032403u,0xf4f4f4f4u),\nuvec4(0xf4f4f4f4u,0xf4f4f4f4u,0x034475f5u,0x03220312u),\nuvec4(0x03020312u,0x0c4584a4u,0x02031425u,0x02040201u),\nuvec4(0x21030403u,0x03320102u,0x13020302u,0x05241214u),\nuvec4(0x13b40504u,0x13040304u,0x94f45544u,0x06050485u),\nuvec4(0x15060504u,0x13c405d4u,0x14f47304u,0x04050405u),\nuvec4(0x04052405u,0x06050465u,0x0504150cu,0x042584f4u),\nuvec4(0xf4251435u,0xf4f4f4f4u,0xf4f4f4f4u,0xd4f4f4f4u),\nuvec4(0x04050425u,0x050495f5u,0x135405b4u,0x24040314u),\nuvec4(0x2413d4a5u,0x04232415u,0x06043312u,0xf4f41504u),\nuvec4(0x1c1514f4u,0x05760c06u,0x15045506u,0x15140504u),\nuvec4(0x13542554u,0x23040304u,0xf4f40304u,0xa5145514u),\nuvec4(0x15043524u,0x45c46504u,0x45041504u,0xf4f42514u),\nuvec4(0xf4f4f4f4u,0xf4f4f4f4u,0xf5f5c4f4u,0xf544f475u),\nuvec4(0x252435f5u,0x65045504u,0x450405f4u,0xa5740534u),\nuvec4(0x061c060cu,0x16050c15u,0x35f50c15u,0x34f4f4f4u),\nuvec4(0xf5f504e5u,0x260516c5u,0xf4b50615u,0xf4f4f4f4u),\nuvec4(0xf5f5f5b4u,0x34f4f455u,0x14c5f5f5u,0xf5ec95a5u),\nuvec4(0x4cf50c95u,0x64b53c25u,0x3c752495u,0xa5f5f5f5u),\nuvec4(0x1c55f50cu,0x4c060ce5u,0xa6f61c16u,0x34e5f50cu),\nuvec4(0x04350405u,0x0415f5f5u,0xf5f50405u,0xd5f5f5f5u),\nuvec4(0xf5f5e4f4u,0x050c15d5u,0x057c152cu,0xfcfc051cu),\nuvec4(0x25fc158cu,0x04f5f52cu,0x2c45b475u,0xf5f51cb5u),\nuvec4(0xf67c251cu,0xf60c35e6u,0x363c066cu,0x35dc15ccu),\nuvec4(0x061c153cu,0x051c852cu,0x350c254cu,0xf50c650cu),\nuvec4(0xf5f5f5f5u,0xf5f5f5f5u,0x650c152cu,0xfcfcfc1cu),\nuvec4(0x9c06acfcu,0xf65cfcc6u,0xf6f61ce6u,0xf61c66f6u),\nuvec4(0x0c169cc6u,0xfcfcfc16u,0x550c157cu,0xfcfcd59cu),\nuvec4(0xfcfcfcfcu,0xfcfcfcfcu,0x0000007cu,0x00000000u));\n\n// RLE data is divided into rows.\n// Index of start pixel for each row is stored here.\nconst int rowindex[] = int[](\n0,32,64,96,128,160,192,224,256,288,334,385,461,539,623,718,805,895,982,1077,1185,1291,1376,1450,1544,1643,1754,1869,1984,2118,2267,2422,2594,2725,2880,3019,3150,3276,3383,3512,3641,3766,3877,3986,4082,4190,4303,4412,4505,4604,4692,4780,4889,4990,5086,5188,5296,5395,5501,5609,5712,5819,5945,6075,6204,6339,6469,6596,6728,6843,6981,7098,7223,7352,7474,7615,7767,7882,7997,8113,8220,8327,8435,8527,8654,8758,8869,8977,9085,9202,9316,9435,9557,9665,9770,9866,9961,10060,10161,10245,10337,10413,10492,10571,10651,10725,10807,10884,10970,11047,11128,11217,11314,11403,11497,11591,11676,11754,11820,11894,11965,12036,12107,12175,12250,12325,12388,12457,12525,12594,12662,12746,12821,12905,12979,13053,13124,13200,13271,13338,13405,13483,13557,13629,13697,13773,13845,13924,14000,14079,14150,14220,14305,14388,14465,14532,14599,14673,14747,14814,14892,14969,15038,15108,15172,15243,15323,15395,15470,15546,15623,15693,15760,15829,15895,15965,16035,16098,16158,16212,16264,16315,16364,16414,16458,16502,16545,16592,16637,16686,16727,16771,16815,16856,16900,16940,16979,17022,17068,17112,17154,17194,17236,17275,17316,17356,17398,17434,17466,17498,17530,17564,17598,17632,17664,17696,17728,17762,17797,17832,17873,17915,17970,18054,18130,18214,18298,18383,18485,18587,18697,18810,18922,19030,19135,19239,19340,19441,19538,19638,19734,19820,19912,19988,20063,20137,20215,20283,20356,20448,20533,20639,20719,20781,20837,20909,20953);\n\nconst int WIDTH = 512;\nconst int HEIGHT = 256;\n\nconst vec3 colors[] = vec3[](\nvec3(0x10,0x10,0x30),\nvec3(0x30,0x30,0x40),\nvec3(0x70,0x60,0x60),\nvec3(0x70,0x80,0x80),\nvec3(0xa0,0xa0,0xa0),\nvec3(0xd0,0xc0,0xa0),\nvec3(0xe0,0xe0,0xe0),\nvec3(0xb0,0x90,0x70),\nvec3(0x90,0x70,0x50),\nvec3(0x20,0x30,0x20),\nvec3(0x30,0x50,0x30),\nvec3(0x50,0x50,0x30),\nvec3(0xe0,0xd0,0xb0),\nvec3(0x30,0x40,0x10),\nvec3(0x30,0x50,0x10));\n\nvec3 getcolor(int i) {\n  return colors[i%colors.length()]/255.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n  float ires = iResolution.x*10000.0 + iResolution.y;\n  if (iFrame != 0 && fragColor.w == ires) return; // Check for resize\n  fragColor.w = ires;\n  int row = int(fragCoord.y); // Desired row\n  row = min(row,HEIGHT-1); // Clamp at edges\n  int col = int(fragCoord.x); // Desired column\n  col = min(col,WIDTH-1); // Clamp at edges\n  // Find the index of the start of the row\n  int rstart = rowindex[row];\n  // And of the next row\n  int rend = rowindex[row+1];\n  int c = -1;\n  int colcount = 0; // column count\n  for (int index = rstart; index < rend; index++) {\n    int i = index;\n    uvec4 entry = data[i/16];\n    i %= 16;\n    uint t = entry[i/4];\n    i %= 4;\n    t >>= 8*i;\n    int count = (int(t >> 4)&15)+1;\n    colcount += count;\n    if (col < colcount) {\n      c = int(t)&15; // Found it!\n      break;\n    }\n  }\n  if (c < 0) fragColor.rgb = vec3(1,0,0); // Shouldn't happen\n  else fragColor.rgb = getcolor(c);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVczy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 394, 449, 449, 832]]}
{"id": "fdVczG", "name": "show house", "author": "jorge2017a2", "description": "show house", "tags": ["showhouse"], "likes": 4, "viewed": 215, "published": 3, "date": "1655088500", "time_retrieved": "2024-07-30T16:44:36.101629", "image_code": "//----------image\n//por jorge2017a2-\n//show house--12-jun-2022\n//referencia\n//https://iquilezles.org/articles/distfunctions/\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n//-------common\n#define PI 3.14159265\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n { float c = cos(phi);float s = sin(phi); return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);}\nvec3 rotate_y(vec3 p, float phi)\n { float c = cos(phi);float s = sin(phi);\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);}\nvec3 rotate_z(vec3 p, float phi)\n {float c = cos(phi); float s = sin(phi);return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);}\n\nvec2 techoInclinadoA(vec3 p)\n{  vec2 res= vec2(9999.0, -1.0);\n    p.y-=9.0; vec3 p0=p;\n    vec3 p1= rotate_z(p, radians(45.0));\n    float d1a= sdBox(p1,vec3(10.0,10.0,5.5) );  //techo triangulo\n    float d1b= sdBox(p-vec3(0.0,-10.0,0.),vec3(14.0,10.0,7.0) );\n    d1a= Difference(d1a, d1b);\n    res =opU2(res, vec2(d1a,9.0));\n    return res;\n}\n\nvec2 casa01(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n     p.y=p.y-12.0;\n    float d1a= sdBox( p, vec3(12.0,10.0,5.0) );\n    float d1b= sdBox( p-vec3(0.0,-5.0,-5.0), vec3(3.5,5.0,1.0) ); //puerta-marco\n    float d1c= sdBox( p-vec3(0.0,-5.25,-5.0), vec3(3.0,5.0,1.5) ); //puerta\n    float d1d= sdBox( p-vec3(0.0,-5.25,-5.0), vec3(3.0,5.0,0.5) ); //fondo puerta\n    d1a= Difference(d1a, d1c);//hueco casa\n    d1b= Difference(d1b, d1c); //puerta\n    vec2 ti1 =techoInclinadoA(p);\n    res =opU2(res, vec2(d1a,1.0));\n    res =opU2(res, vec2(d1b,8.0));\n    res =opU2(res, vec2(d1d,7.0));\n    res =opU2(res, ti1);\n    return res;\n}\n   \nvec2 opScaleCasa01( vec3 p, float s)\n{\tvec2 res= vec2(9999.0, -1.0);  \n    vec2 c1= casa01(p/s);\n    c1.x*=s;\n    res =opU2(res, c1);\n    return res;\n}\n\nvec2 RepetirCasa(vec3 p)\n{  vec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n   vec3 pnew;\n   vec2 c1,c2,c3;\n   for(float i=0.0;i<3.0;i++) \n   {   pnew=p-vec3(0.0,(i-1.0)*25.0,i*15.0);\n       c1= opScaleCasa01(pnew,1.0);\n       c2= opScaleCasa01(pnew-vec3(0.0,0.0,-5.0),0.5);\n       c3= opScaleCasa01(pnew-vec3(0.0,14.0,-6.6),0.25); //chica\n       res =opU2(res, c1);\n       res =opU2(res, c2);\n       res =opU2(res, c3);\n    }\n    return res;\n}\n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    //p.x= opRep1D(p.x, 30.0 );\n   vec2 r1= RepetirCasa(p);\n   res =opU2(res, r1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    //float d = pow(rd.z+0.3,2.)*pow(rd.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n\treturn sky;\n    //return sky*d;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     //if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n    if (id_color==0)  { colobj=vec3(0,0,0);  return colobj; }\n    if (id_color==1)  { colobj=vec3(1.,1.,1.);  return colobj; }\n    if (id_color==2)  { colobj=vec3(1,0,0);  return colobj; }\n    if (id_color==3)  { colobj=vec3(0,1,0);  return colobj; }\n    if (id_color==4)  { colobj=vec3(0,0,1);  return colobj; }\n    if (id_color==5)  { colobj=vec3(1,1,0);  return colobj; }\n    if (id_color==6)  { colobj=vec3(0,1,1);  return colobj; } \n    if (id_color==7)  { colobj=vec3(1,0,1);  return colobj; }\n    if (id_color==8)  { colobj=vec3(0.7529,0.7529,0.7529);  return colobj; }\n    if (id_color==9)  { colobj=vec3(0.5,0.5,0.5);  return colobj; }\n    if (id_color==10) { colobj=vec3(0.5,0,0);  return colobj; }\n\n\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=30.0*abs(sin(iTime*0.125));\n \tlight_pos1= vec3(-10.0, 120.0, -25.+t); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, 55.0 +t); light_color2 =vec3(0.5 ); \n   vec3 ro=vec3(0.0,-15.0+t*2.0,-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   light_pos1+=ro;\n   light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[590, 590, 622, 622, 706], [707, 707, 751, 751, 778], [779, 779, 819, 819, 846], [847, 847, 892, 892, 920], [922, 922, 958, 958, 1003], [1005, 1030, 1065, 1065, 1153], [1154, 1154, 1189, 1189, 1277], [1278, 1278, 1313, 1313, 1400], [1402, 1402, 1432, 1432, 1744], [1746, 1746, 1767, 1767, 2380], [2385, 2385, 2423, 2423, 2536], [2538, 2538, 2564, 2564, 2976], [2979, 2979, 3004, 3004, 3147], [3149, 3149, 3173, 3173, 3335], [3337, 3337, 3385, 3385, 3664], [3667, 3667, 3711, 3711, 4032], [4034, 4034, 4071, 4071, 4328], [4331, 4331, 4354, 4354, 4499], [4501, 4501, 4591, 4591, 5549], [5552, 5552, 5584, 5584, 5876], [5878, 5878, 5948, 5948, 6754], [6756, 6756, 6783, 6783, 6872], [6874, 6874, 6932, 6932, 6980], [6982, 6982, 7005, 7005, 7117], [7121, 7121, 7152, 7152, 7790], [7792, 7792, 7849, 7849, 8290]]}
{"id": "NsKczG", "name": "Neon glass mosaic", "author": "jarble", "description": "A stained-glass mosaic with glowing neon lines.", "tags": ["fractal", "knot", "mosaic", "neon"], "likes": 4, "viewed": 306, "published": 3, "date": "1655087342", "time_retrieved": "2024-07-30T16:44:36.846637", "image_code": "//#define animate\n\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float t4 = floor((uv.x+uv.y+iTime));\n\n    for(int i=1;i<4;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 1; k < 5; k++){\n            uv.x -= float(k+i);\n\n            uv += (t2.yx)/(scale);\n            t2 = triangle_wave(uv.yx-1.5,scale);\n            #ifdef animate\n            float num = 3.+float(k);\n            t2 += t4/num;\n            #endif\n            t3 = triangle_wave(uv,scale);\n            //t3 -= float(k)/3.;\n            uv.yx = (t2-t3)/(scale);\n            vec2 uv1 = uv + triangle_wave((uv.yx+iTime/4.)*4.,scale)/16.;\n\n            col.x = max(((uv1.y-uv1.x)-col.x),col.x)/sqrt(3.);\n            col = min(col.yzx,abs(col+vec3(col.x)/sqrt(3.)).yzx);\n        }\n        \n    }\n    fragColor = vec4((col*9.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 87, 87, 132], [134, 134, 191, 191, 1207]]}
{"id": "7dyyRy", "name": "Neonwave sunrise", "author": "mrange", "description": "CC0 - Neonwave sunrise\nInspired by a tweet by I wanted to create something that looked\na bit like the tweet. This is the result.\n", "tags": ["neonwave"], "likes": 130, "viewed": 4585, "published": 3, "date": "1655060306", "time_retrieved": "2024-07-30T16:44:37.824024", "image_code": "// CC0 - Neonwave sunrise\n//  Inspired by a tweet by I wanted to create something that looked\n//  a bit like the tweet. This is the result.\n\n#define RESOLUTION    iResolution\n#define TIME          iTime\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n\n#define SHOW_FFT\n\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n  float a = dot (p, vec2 (127.1, 311.7));\n  return fract(sin(a)*43758.5453123);\n}\n\n// Value noise: https://iquilezles.org/articles/morenoise\nfloat vnoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n    \n  vec2 u = f*f*(3.0-2.0*f);\n//  vec2 u = f;\n\n  float a = hash(i + vec2(0.0,0.0));\n  float b = hash(i + vec2(1.0,0.0));\n  float c = hash(i + vec2(0.0,1.0));\n  float d = hash(i + vec2(1.0,1.0));\n  \n  float m0 = mix(a, b, u.x);\n  float m1 = mix(c, d, u.x);\n  float m2 = mix(m0, m1, u.y);\n  \n  return m2;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0);\n  h = sqrt( h );\n  return vec2(-b - h, -b + h);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\nfloat hifbm(vec2 p) {\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return sum;\n}\n\nfloat lofbm(vec2 p) {\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 2; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return sum;\n}\n\nfloat hiheight(vec2 p) {\n  return hifbm(p)-1.8;\n}\n\nfloat loheight(vec2 p) {\n  return lofbm(p)-2.15;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 npp, vec3 off, float n) {\n  float h = hash(n);\n  float s = mix(0.05, 0.25, h);\n\n  vec3 hn;\n  vec2 p = (pp-off*2.0*vec3(1.0, 1.0, 0.0)).xy;\n\n  const vec2 stp = vec2(0.5, 0.33); \n  float he    = hiheight(vec2(p.x, pp.z)*stp);\n  float lohe  = loheight(vec2(p.x, pp.z)*stp);\n\n  float d = p.y-he;\n  float lod = p.y - lohe;\n\n  float aa = distance(pp, npp)*sqrt(1.0/3.0);\n  float t = smoothstep(aa, -aa, d);\n\n  float df = exp(-0.1*(distance(ro, pp)-2.));  \n  vec3 acol = hsv2rgb(vec3(mix(0.9, 0.6, df), 0.9, mix(1.0, 0.0, df)));\n  vec3 gcol = hsv2rgb(vec3(0.6, 0.5, tanh_approx(exp(-mix(2.0, 8.0, df)*lod))));\n  \n  vec3 col = vec3(0.0);\n  col += acol;\n  col += 0.5*gcol;\n  \n  return vec4(col, t);\n}\n\nvec3 stars(vec2 sp, float hh) {\n  const vec3 scol0 = HSV2RGB(vec3(0.85, 0.8, 1.0));\n  const vec3 scol1 = HSV2RGB(vec3(0.65, 0.5, 1.0));\n  vec3 col = vec3(0.0);\n  \n  const float m = 6.0;\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = sp+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(sp.x);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*1667.0);\n    float h2 = fract(h.x*1887.0);\n    float h3 = fract(h.x*2997.0);\n\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*mix(scol0, scol1, h1*h1);\n\n    vec3 ccol = col + exp(-(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    ccol *= mix(0.125, 1.0, smoothstep(1.0, 0.99, sin(0.25*TIME+TAU*h.y)));\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nconst vec3 lpos   = 1E6*vec3(0., -0.15, 1.0);\nconst vec3 ldir   = normalize(lpos);\n\nvec4 moon(vec3 ro, vec3 rd) {\n  const vec4 mdim   = vec4(1E5*vec3(0., 0.4, 1.0), 20000.0);\n  const vec3 mcol0  = HSV2RGB(vec3(0.75, 0.7, 1.0));\n  const vec3 mcol3  = HSV2RGB(vec3(0.75, 0.55, 1.0));\n\n  vec2 md     = raySphere(ro, rd, mdim);\n  vec3 mpos   = ro + rd*md.x;\n  vec3 mnor   = normalize(mpos-mdim.xyz);\n  float mdif  = max(dot(ldir, mnor), 0.0);\n  float mf    = smoothstep(0.0, 10000.0, md.y - md.x);\n  float mfre  = 1.0+dot(rd, mnor); \n  float imfre = 1.0-mfre;\n\n  vec3 col = vec3(0.0);\n  col += mdif*mcol0*4.0;\n\n#if defined(SHOW_FFT)\n  vec3 fcol = vec3(0.0);\n  vec2 msp    = toSpherical(-mnor.zxy).yz;\n  vec2 omsp   = msp;\n  float msf   = sin(msp.x);\n  msp.x       -= PI*0.5;\n  const float mszy = (TAU/(4.0))*0.125; \n  float msny  = mod1(msp.y, mszy);\n  msp.y *= msf;\n\n  const int limit = 1;\n  for (int i = -limit; i <= limit; ++i) {\n    vec2 pp     = msp+vec2(0.0, mszy*float(i));\n    float d0    = abs(pp.y);\n    vec2 cp     = vec2(0.055*abs(msny-float(i)), 0.25);\n    float fft   = texture(iChannel0, cp).x;\n    float d1    = length(pp)-0.05*fft;\n    float h     =mix(0.66, 0.99, fft);\n    vec3 mcol1  = hsv2rgb(vec3(h, 0.55, 1.0));\n    vec3 mcol2  = hsv2rgb(vec3(h, 0.85, 1.0));\n    fcol += mcol1*0.5*tanh_approx(0.0025/max(d0, 0.0))*imfre*pow(msf, mix(100.0, 10.0, fft));\n    fcol += mcol2*5.0*tanh_approx(0.00025/(max(d1, 0.0)*max(d1, 0.0)))*imfre*msf;\n  }\n  float d0   = abs(msp.x);\n  fcol += mcol3*0.5*tanh_approx(0.0025/max(d0, 0.0))*imfre;\n  \n  const float start = 18.0;\n  col += fcol*smoothstep(start, start+6.0+2.0*abs(omsp.y), TIME);\n\n#endif\n\n  return vec4(col, mf);\n}\n\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 acol   = HSV2RGB(vec3(0.6, 0.9, 0.075));\n  const vec3 lpos   = 1E6*vec3(0., -0.15, 1.0);\n  const vec3 lcol   = HSV2RGB(vec3(0.75, 0.8, 1.0));\n\n  vec2 sp     = toSpherical(rd.xzy).yz;\n\n  float lf    = pow(max(dot(ldir, rd), 0.0), 80.0);\n  float li    = 0.02*mix(1.0, 10.0, lf)/(abs((rd.y+0.055))+0.025);\n  float lz    = step(-0.055, rd.y);\n\n  vec4 mcol   = moon(ro, rd);\n\n  vec3 col = vec3(0.0);\n  col += stars(sp, 0.25)*smoothstep(0.5, 0.0, li)*lz;  \n  col  = mix(col, mcol.xyz, mcol.w);\n  col += smoothstep(-0.4, 0.0, (sp.x-PI*0.5))*acol;\n  col += tanh(lcol*li);\n  return col;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 2.0/RESOLUTION.y;\n//  float rdd = (2.0-1.0*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n  float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0;\n  const int furthest = 12;\n  const int fadeFrom = max(furthest-2, 0);\n\n  const float fadeDist = planeDist*float(fadeFrom);\n  const float maxDist  = planeDist*float(furthest);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    vec3 pp = ro + rd*pd;\n    \n    if (pp.y < 0. && pd > 0.0 && acol.w < cutOff) {\n      vec3 npp = ro + nrd*pd;\n\n      vec3 off = vec3(0.0);\n\n      vec4 pcol = plane(ro, rd, pp, npp, off, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(maxDist, fadeDist, pd);\n      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);\n//      pcol.w *= fadeOut;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm= TIME*0.25;\n  vec3 ro = vec3(0.0, 0.0, tm);\n  vec3 dro= normalize(vec3(0.0, 0.09, 1.0));  \n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)), ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  \n  return col;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, q);\n  col *= smoothstep(0.0, 8.0, TIME-abs(q.y));\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 29109, "src": "https://soundcloud.com/didlybom/vangelis-memories-of-green", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyyRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 462, 462, 608], [903, 963, 1003, 1003, 1162], [1164, 1224, 1264, 1264, 1306], [1308, 1368, 1396, 1462, 1538], [1540, 1600, 1622, 1622, 1670], [1672, 1732, 1752, 1752, 1834], [1836, 1894, 1916, 1916, 2266], [2268, 2386, 2430, 2430, 2628], [2630, 2716, 2755, 2755, 2880], [2882, 2968, 3004, 3004, 3098], [3100, 3160, 3180, 3180, 3292], [3294, 3294, 3315, 3315, 3513], [3515, 3515, 3536, 3536, 3734], [3736, 3736, 3760, 3760, 3785], [3787, 3787, 3811, 3811, 3837], [3839, 3839, 3907, 3907, 4573], [4575, 4575, 4606, 4606, 5467], [5469, 5469, 5495, 5495, 5604], [5690, 5690, 5719, 5719, 7282], [7285, 7285, 7318, 7318, 7911], [7913, 7913, 7969, 7969, 9499], [9501, 9501, 9530, 9530, 9821], [9823, 9923, 9944, 9944, 10017], [10018, 10118, 10140, 10140, 10189], [10191, 10298, 10324, 10324, 10508], [10510, 10510, 10565, 10565, 10831]]}
{"id": "sdyyzG", "name": "Knot mosaic 2", "author": "jarble", "description": "A mosaic with knot patterns.", "tags": ["fractal", "knot", "mosaic"], "likes": 5, "viewed": 239, "published": 3, "date": "1655052842", "time_retrieved": "2024-07-30T16:44:38.730600", "image_code": "//#define animate\n\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.5*4.*8.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float t4 = floor((uv.x+uv.y+iTime)/16.);\n\n    for(int i=1;i<4;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 1; k < 5; k++){\n        \n            uv += (t2.yx);\n            t2 = triangle_wave(uv.yx-1.5+float(i*k),scale);\n            //t2.y -= float(i)/32.;\n            #ifdef animate\n            float num = 3.+float(k);\n            t2 += t4/num;\n            #endif\n            t3 = triangle_wave(uv,scale);\n            //t3 -= float(k)/3.;\n            uv.yx = (t2-t3)/(scale);\n            col.x = min(((uv.y-uv.x)+col.x),col.x)/sqrt(3.);\n            col = abs(col.yzx+vec3(col.x))/sqrt(3.);\n            //col = max(col.yzx,abs(col+vec3(col.x))).yzx/sqrt(3.); //another nice color palette\n        }\n        \n    }\n    fragColor = vec4((col*9.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyyzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 87, 87, 132], [134, 134, 191, 191, 1240]]}
{"id": "NsGczy", "name": "my ladder v2", "author": "jorge2017a2", "description": "ladder v2", "tags": ["myladder"], "likes": 11, "viewed": 275, "published": 3, "date": "1655042988", "time_retrieved": "2024-07-30T16:44:39.542431", "image_code": "//----------image\n//por jorge2017a2-\n//my ladder v2....12-jun-2022\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d/\n//https://iquilezles.org/articles/distfunctions/\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    // base\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    // steps repetition\n#if 1\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float lid = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - lid*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n#else\n    float dia2 = dot(wh,wh);\n    p = mat2(wh.x,-wh.y,wh.y,wh.x)*p;\n    float lid = clamp(round(p.x/dia2),0.0,n-1.0);\n    p.x = p.x - lid*dia2;\n    p = mat2(wh.x,wh.y,-wh.y,wh.x)*p/dia2;\n#endif    \n\n    // single step\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    \n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (lid<0.5 || p.x>0.0) ? p : -p;\n\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\nfloat opScaleEscalera( in vec3 p )\n{   float s=0.125;\n    return sdStairs(p.xy/s, vec2(10.0,10.0), 10.0 )*s;\n}\n\nvec2 DosParedes(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n   float d1=opScaleEscalera( p-vec3(-5.0,5.0,0.0));\n    float d2= sdBox(p-vec3(0.0,15.0,0.0), vec3(10.0,10.0,2.0) );\n    float d3= sdBox(p-vec3(0.0,-4.0,0.0), vec3(7.5,10.0,2.0) );\n    d1= Intersect(d1, d2);\n    d1= Union(d1, d3);\n    res =opU2(res, vec2(d1,100.0));\n    return res;\n}\n\nvec2 UnCuarto(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n     p.x=abs(p.x)-5.0;\n    p.z=abs(p.z)-10.0;\n    vec2 dp1= DosParedes(p);\n    p=p0;\n    p.z=abs(p.z)-5.0;\n    p.x=abs(p.x)-10.0;\n    vec2 dp2= DosParedes(p.zyx);\n    res =opU2(res, dp1);\n    res =opU2(res, dp2);\n    return res;\n}\n\nvec2 cuartoEscala(vec3 p, float s,float pmat)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    vec2 r2= UnCuarto(p/s);\n    r2.x*=s;r2.y=pmat;\n    res =opU2(res, r2);\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+14.0;  //piso inf\n    \n    vec2 uc1= UnCuarto(p);\n    vec2 uc2=cuartoEscala(p-vec3(0.0,10.0,0.0), 3./4.0,101.);\n    vec2 uc3=cuartoEscala(p-vec3(0.0,20.0,0.0), 2./4.0,102.);\n    //vec2 uc3=cuartoEscala(rotate_y( p-vec3(0.0,20.0,0.0) , 0.79) , 2./4.0,102.);\n    res =opU2(res, uc1);\n    res =opU2(res, uc2);\n    res =opU2(res, uc3);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 )\n        { col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) \n        { col=tex3D(iChannel0, p/32., nor); return hsv(col*vec3(0.7,0.7,0.3)+0.05)*4.0; }\n\tif (i==102 ) \n        { col=tex3D(iChannel0, p/32., nor); return hsv(col*vec3(0.2,0.9,0.6))*3.0; }\n}\n\nvec3 chequer(vec2 uv) \n{    \n    return vec3(sin(uv.x*3.1416*3.),sin(uv.x*3.1416*2.),sin(uv.x*3.1416*1.5*sin(fract(iTime)))); }\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, 1.2), 1.0 - rd.y);\n    sky= chequer(sky.xy*0.5);\n    return sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color>=100 ){ return  getColorTextura( p, nor,id_color); }      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float t=iTime*0.5;\n   float r=30.0-abs(10.0*sin(t));\n   float veltime=30.0;  \n    float tt = radians( -t*veltime);\n    vec3  pos=vec3(0.0,0.0,25.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1; \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n \tlight_pos1= vec3(-10.0, 50.0, 25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n    vec3 ro=vec3(0.0,20.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3 hsv(vec3 c)\n{ vec4 k=vec4(1.,2./3.,1./3.,3.);\n  vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n  return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGczy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[607, 607, 639, 639, 723], [726, 726, 770, 770, 797], [798, 798, 838, 838, 865], [866, 866, 911, 911, 939], [941, 941, 977, 977, 1022], [1024, 1024, 1058, 1058, 1154], [1155, 1155, 1189, 1189, 1280], [1281, 1281, 1315, 1315, 1406], [1408, 1408, 1433, 1433, 1452], [1453, 1453, 1478, 1478, 1497], [1498, 1498, 1534, 1534, 1562], [1565, 1565, 1618, 1630, 2510], [2512, 2512, 2548, 2548, 2622], [2624, 2624, 2649, 2649, 2976], [2978, 2978, 3001, 3001, 3274], [3276, 3276, 3323, 3323, 3458], [3460, 3460, 3485, 3485, 3901], [3903, 3903, 3927, 3927, 4089], [4091, 4091, 4139, 4139, 4418], [4421, 4421, 4465, 4465, 4786], [4788, 4788, 4825, 4825, 5082], [5084, 5084, 5174, 5174, 6134], [6136, 6136, 6185, 6185, 6481], [6483, 6483, 6507, 6507, 6610], [6612, 6612, 6644, 6644, 6875], [6877, 6877, 6947, 6947, 7042], [7044, 7044, 7071, 7071, 7160], [7162, 7162, 7220, 7220, 7268], [7270, 7270, 7293, 7293, 7405], [7407, 7407, 7438, 7438, 8067], [8069, 8069, 8106, 8106, 8409], [8412, 8412, 8469, 8469, 8966]]}
{"id": "7dyyWm", "name": "kaleidoscope variations", "author": "hnh", "description": "The three possible variations of the 3-mirror kaleidoscope - see code comments.\nBrightness is attenuated by the number of reflections.\nUse mouse to manually scroll the texture.", "tags": ["reflection", "interactive", "folding", "kaleidoscope", "tiling", "symmetry"], "likes": 7, "viewed": 293, "published": 3, "date": "1655035972", "time_retrieved": "2024-07-30T16:44:40.284446", "image_code": "\n// The three possible variations of the 3-mirror kaleidoscope [1,2].\n// The image is composed by reflections of a base triangle, tiling the plane.\n// Here, I adopted the folding scheme [3,4] for the Euclidean plane whereas\n// in general it also works for the spherical and hyperbolic case. \n// A similar example with good comments is also found in [5]. \n// You may also try using the webcam in iChannel0\n// (don't forget setting Filter->mipmap and Wrap->repeat).\n// Note: lines marked by '//o' are comment-switchable (optional).\n// '//p' indicates parameters for manual tuning.\n// Shadertoy plugin: use R/L arrows to switch modes\n//\n// See also https://www.shadertoy.com/view/ssyyRG for a visualization of the folding scheme.\n//\n// [1] https://en.wikipedia.org/wiki/Kaleidoscope#Different_versions_suggested_by_Brewster\n// [2] https://en.wikipedia.org/wiki/Triangle_group\n// [3] mla, Wythoffian Tiling Generator, https://shadertoy.com/view/wlGSWc\n// [4] knighty, Tilings, https://www.shadertoy.com/view/4sf3zX\n// [5] TotallyReal, Euclidean triangle groups, https://www.shadertoy.com/view/7lV3Wy\n// [6] Artleet, The most compact hueshift, https://www.shadertoy.com/view/3tjGWm\n// [7] https://de.wikipedia.org/wiki/Datei:Kaleidoscope-abc.jpg\n\n#define PI 3.14159265\n#define R iResolution\n\n// The angles are defined by divisors of PI in each row (1st row: classical kaleidoscope, [1]).\n// In the Euclidean plane their inverses must sum to one.\nconst mat3 D = mat3(3,3,3,\n                    2,4,4,\n                    2,3,6);\n\nvec3 hs(vec3 c, float s) {  // hue shift [5]\n    vec3 m = vec3(cos(s), s=sin(s)*.5774, -s);\n    return c*mat3(m+=(1.-m.x)/3., m.zxy, m.yzx);\n}\n\n// Iterative folding/reflection adopted from [2,3] and streamlined for the Euclidean case.\n// The fold count (nf) can be useful, e.g. to attenuate reflections as in a real kaleidoscope [6].\nvec4 fold(vec2 p, float sc, vec3 ang, out int nf) {\n    vec3 c = cos(ang), s = sin(ang);\n    mat3 N = mat3(1, 0, .0,  //p .0 -> .1: show unit cells\n                 -c.x, s.x, 0,\n                 -c.z, -(c.y+c.x*c.z)/s.x, 1);  // normals\n    sc *= s.z;  // set longest edge to unit length\n    vec3 u, q = vec3(p,sc);\n    nf = 0;  // fold counter\n    for(int i=0; i<9999; i++) {\n        for(int j=0; j<3; j++) {\n            u[j] = dot(q, N[j]);\n            if(u[j] < 0.) {q -= 2.*u[j]*N[j]*vec3(1,1,0); nf++;}\n        }\n        if(i >= nf) break;  // central (proto-) triangle is reached\n    }\n    return vec4(q.xy, u.yz);  // q.xy: cartesian coords, u.xyz: trilinear coords, note that u.x = q.x\n}\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime*.1;\n    \n    int m = 0;  //p reflection mode (0,1,2)\n    m = int(t)%3;  //o cycle modes\n    //m = int(U.x*3./R.x);  //o simultaneous view\n        \n    float sc = 10., a = .8, b = R.y*.075;  //p scale, bounce interval\n    sc = sqrt(b*a)*pow(b/a, .5*cos(2.*PI*t));  //o bouncing zoom\n            \n    U = sc*(U*2. - R.xy)/R.y;\n    \n    int nf;\n    O = fold(U, 1., PI/D[m], nf);\n    U = O.xy;\n    vec3 u = O.xzw;\n    \n    if(iMouse.z>0.) U -= (iMouse.xy*2.-R.xy)/R.y; else U -= t; //o scrolling\n    //U += vec2(nf)*.01;  //o reflection shift\n    O = texture(iChannel0,U);\n    O.rgb = hs((O.bgr-.35)*3., PI*(1.-.5*float(m)));  //o color modes\n    \n    //O = u.xyzz;  //o RGB = trilinear coordinates\n    //O = vec4(.75);  //o blank background\n\n    O *= exp(-float(nf)/sc*.5)*1.5;  //o attenuate reflections\n    //O *= .5 + .5*float(nf%2);  //o 'checkerboard'\n    O *= smoothstep(-1.,1.,(min(u.x,min(u.y,u.z))-.01)*R.y/(sc*2.));  //o edges\n    \n    O.a= 1.;  // who knows...\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1524, 1524, 1550, 1568, 1666], [1668, 1858, 1909, 1909, 2554], [2557, 2557, 2593, 2593, 3584]]}
{"id": "Nt2fzc", "name": "God's Front Porch (4Kb)", "author": "dean_the_coder", "description": "A 4Kb Graphics Executable for Shadow Party 2022.\n(2nd Place - Newschool Graphics)\nInspired by the song 'God's Front Porch' by The British IBM and Apollo 11.\n", "tags": ["3d", "raymarching", "4k", "demoscene", "space", "stars", "moon", "apollo", "4kb", "cineshader"], "likes": 51, "viewed": 4383, "published": 3, "date": "1655027715", "time_retrieved": "2024-07-30T16:44:41.281779", "image_code": "// 'God's Front Porch' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/Nt2fzc (YouTube: https://youtu.be/VXBp4hXvNG0)\n//\n// A 4Kb Graphics Executable for Shadow Party 2022.\n// (2nd Place - Newschool Graphics)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Inspired by the song 'God's Front Porch' by The British IBM\n// and Apollo 11.\n// Michael Collins waited in moon orbit whilst the others got to\n// land on the moon, so was the most isolated human in existence.\n//\n// The quote is actually from Gene Cernan on Apollo 17, but I\n// figure I can be 'inspired' by what I like. :p\n//\n// As always, trying to improve my shader skillz. This time\n// trying out some subtle effects such as glass shine,\n// moon/light glare, and the 'viewing window'.\n//\n// Tricks to aid performance:\n//   - Precalculate function results and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - The SDF function only adds fine details if the ray\n//     is near the surface of the ship.\n//   - Shadow calculations exclude the moon.\n//   - The window frame is a 2D effect.\n//   - AA only applied on pixels where the neighbouring\n//     pixel is a significantly different color.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n#define AA\t// Disable if your GPU is melting.\n\n#define MIN_DIST\t.0015\n#define MAX_DIST\t380.\n#define MAX_STEPS\t90.\n#define MAX_RDIST\t320.\n#define MAX_RSTEPS\t40.\n#define SHADOW_STEPS\t30.\n#define LIGHT_RGB\tvec3(2)\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, c, i)\t{ float h_ = a; if (h_ < h.d) h = Hit(h_, c, i); }\n\nfloat t;\nstruct Hit {\n\tfloat d;\n\tvec3 p;\n\tint id;\n};\n\nvec2 h22(vec2 p) {\n\tvec3 v = fract(p.xyx * vec3(.1031, .103, .0973));\n\tv += dot(v, v.yzx + 333.33);\n\treturn fract((v.xx + v.yz) * v.zy);\n}\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, 270) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nvec3 n3331(vec3 p, vec3 s) {\n    vec3 ns;\n    for (int i = I0; i < 3; i++)\n        ns[i] = n31(p * s[i]);\n    return ns;\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 5.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat opRep(float p, float c) {\n\tfloat c2 = c * .5;\n\treturn mod(p + c2, c) - c2;\n}\n\nvec3 opModPolar(vec3 p, float n, float o) {\n\tfloat angle = 3.141 / n,\n\t      a = mod(atan(p.y, p.z) + angle + o, 2. * angle) - angle;\n\treturn vec3(p.x, length(p.yz) * vec2(cos(a), sin(a)));\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat cone(vec3 p, float h, float r1, float r2) {\n\tvec2 q = vec2(length(p.yz), p.x),\n\t     k1 = vec2(r2, h),\n\t     k2 = vec2(r2 - r1, 2. * h),\n\t     ca = vec2(q.x - min(q.x, (q.y < 0.) ? r1 : r2), abs(q.y) - h),\n\t     cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot(k2, k2), 0., 1.);\n\treturn ((cb.x < 0. && ca.y < 0.) ? -1. : 1.) * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(-ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 sky(vec2 rd) {\n\tfloat n,\n\t      b = sat(1. - dot(rd, rd));\n\trd *= 32.;\n\tn = h21(floor(rd));\n\tvec2 uv = fract(rd) + n * 1.6 - 1.3;\n\treturn S(n * .001, 0., dot(uv, uv)) * .2 * n + vec3(pow(b, 12.));\n}\n\nfloat jet(vec3 q, float x) {\n\tfloat d = cone(q, .15, 0., .08 - .007 * (sin(x * 148.5) * .5 + .5));\n\tq.x -= .15;\n\treturn max(d, .05 - length(q));\n}\n\n#define BODY_ID\t1\n#define BODYG_ID\t2\n#define CONE_ID\t3\n#define RADSEPS_ID\t4\n#define WINDOW_ID\t5\n#define ABOVE_ARE_REFLECTIVE\t6\n#define NOZZLE_ID\t7\n#define RADIATORS_ID\t8\n#define MOON_ID\t9\n#define WHITE_ID\t10\n\nHit ship(vec3 p) {\n\tvec3 q;\n\tp.y -= .5;\n\tp.z += 8.;\n\tp.xy *= mat2(.99875, -.04998, .04998, .99875);\n\tp.xz *= mat2(.99022, .13954, -.13954, .99022);\n\tp.yz *= rot(1.3 + t / 60.);\n\tp.y += mix(3.5, 0., t / 20.);\n\n\t// Main body.\n\tfloat f, a,\n\t      d = cyl(p, vec2(2, 2.25));\n\n\t// Scimitar antenna.\n\tHit h = Hit(cyl(p.zyx + vec3(0, 1.9, -.2), vec2(.34, .03)), p, WHITE_ID);\n\n    if (d < 2.) {\n\t\t// We're near the main body - Add details.\n        \n        // Body bumps.\n        q = p.zxy;\n        q.xz *= rot(0.52);\n        q.y = abs(abs(q.y + .48) - .36) - .36;\n        minH(cyl(q, vec2(.15, 2.004)), p, BODYG_ID);\n        \n\t\t// Rivets.\n\t\tq = p;\n\t\tq.x = opRep(q.x, .08);\n\t\tq = opModPolar(q, 18., 0.);\n\t\tq.z = abs(q.z) - .03;\n\t\tq.y -= 1.992;\n\t\tf = length(q) - .012;\n\t\tf = max(f, abs(p.x - .35) - 1.9);\n\t\td = min(d, f);\n\n\t\t// Radiator separators.\n\t\ta = atan(p.y, p.z);\n\t\tf = cos(a * 8.);\n\t\tq = p;\n\t\tq.x += 1.9;\n\t\tminH(cyl(q, vec2(step(f + .5, 0.) * .03 + 1.99, .3)), p, RADSEPS_ID);\n\n\t\t// Radiator grills.\n\t\ta = abs(abs(p.x + .4) - 1.7) - .5;\n\t\ta += step(0., p.x) * step(a + 4.5, 2.1);\n\t\tf = min(1., step(0., f + .25) + step(2., q.x));\n\t\tfloat ox = q.x;\n\t\tq.x = opRep(q.x, .2);\n\t\tf = cyl(q, vec2(1.89 + (f - sat(a)) * .12, .015));\n\t\tf = min(max(f, abs(ox) - .3), max(f, abs(ox - 3.2) - .5));\n\t\td = min(d, f);\n\n\t\t// RCS modules (aka steering thrusters).\n\t\tq = p;\n\t\tq.xzy = opModPolar(q, 4., .78);\n\t\tq.x++;\n\t\tq.z -= 2.;\n\t\tf = box(q, vec3(.24 - q.z * .3, .14 - q.z * .3, .2)); // Base\n\t\tminH(f, p, WHITE_ID);\n\t\tq.z -= .12;\n\t\tvec3 qq = q;\n\t\tq.x = abs(q.x) - .28;\n\t\td = min(d, jet(q, p.x)); // Nozzle pair 1.\n\t\tq = qq.yxz;\n\t\tq.x = abs(q.x) - .14;\n\t\td = min(d, jet(q, q.x)); // Nozzle pair 2.\n\t}\n\n\t// Nose cone.\n\tf = abs(abs(p.x + 3.3) - .9);\n\tf = step(.01, f) * .004;\n\ta = cone(p + vec3(3.7, 0, 0), 1.45, .55 - f, 2.01 - f);\n\td = min(d, a);\n\tif (a < 1.)     {\n\t\t// We're near the nose cone - Add details.\n\t\td += step(abs(p.x + 2.8), .01) * .004;\n\n\t\t// Pitch engines.\n\t\tq = p;\n\t\tq.x += 2.6;\n\t\tq = opModPolar(q, 5., -.22);\n\t\tq.z = abs(q.z) - .16;\n\t\td += .004 * S(.12, .1, length(q.xz));\n\n\t\t// Nose windows.\n\t\tq = p + vec3(3.55 - .3 * step(-1., p.z), 0, 0);\n\t\tf = box(opModPolar(q, 5., .2), vec3(.18, 9, .18));\n\t\td = min(max(d, .15 - f), a + .004);\n\t\td = max(d, .05 - f);\n\t\tminH(a + .05, p, WINDOW_ID);\n\n\t\t// Docking point.\n\t\tq = p;\n\t\tq.x += 5.8;\n\t\tf = length(q) - .1; // End ball.\n\t\tq.x -= .35;\n\t\tf = min(f, cyl(q, vec2(.04, .3))); // Center rod.\n\t\tq.xzy = opModPolar(q, 4., 0.);\n\t\tq.z -= .4;\n\t\tq.x = -sqrt(q.x * q.x + .005);\n\t\tq.xz *= mat2(.70721, .707, -.707, .70721);\n\t\tf = min(f, max(cyl(q, vec2(.03, .5)), q.x)); // Slopey bits.\n\t\td = min(d, f);\n\t}\n\n\t// Exhaust nozzle.\n\tq = p;\n\tq.x -= 3.7;\n\tf = .06 * S(.05, -.05, abs(q.x - .7));\n\td = min(d, cone(q, 1.5, .5 + S(-1.2, 2., q.x), 1.25) - f);\n\tif (p.x > 0.) {\n\t\t// Directional antenna.\n\t\tq = p;\n\t\tq.xz -= 2.;\n\t\tf = cyl(q.zyx, vec2(.06, 1));\n\t\tq.x += .2;\n\t\tq.z--;\n\t\tfloat b = S(-.2, -.5, q.x) * .05 + .06;\n\t\tf = min(f, box(q, vec3(.5, b, b)));\n\t\td = min(d, f);\n\t\tq.x += .5;\n\t\tq.yz = abs(q.yz) - .3;\n\t\tf = abs(length(q) - .53) - .015;\n\t\tf = max(f, .46 - q.x);\n\t\td = min(d, f);\n\t}\n\n\tminH(d, p, BODY_ID);\n\treturn h;\n}\n\nfloat moonSDF(vec3 p) {\n\tp += vec3(118, 164, -460);\n\n\t// Base moon radius.\n\tfloat r = length(p) - 4e2,\n\t      f = 0.;\n\tif (r > 10.) return r;\n\n\t// Add surface details.\n\tfor (float c = .01; c <= .03; c += .01) {\n\t\tvec2 uv = p.xy * c,\n\t\t     dxy = h22(floor(uv)) * .5;\n\t\tuv = fract(uv) - .5 + dxy;\n\t\tfloat d = S(-.1, 0., length(uv) + (max2(dxy) - .5));\n\t\td *= 3.1 - 127. * c + 17e2 * c * c;\n\t\tf += d;\n\t}\n\n\treturn r - f - fbm(p * .1) * 4.;\n}\n\nHit map(vec3 p) {\n\tHit h = ship(p);\n\tminH(moonSDF(p), p, MOON_ID);\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .25;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .05,\n\t      mxt = length(p - vec3(-25, 45, -40));\n\tvec3 ld = normalize(vec3(-25, 45, -40) - p);\n\tfor (float i = Z0; i < SHADOW_STEPS; i++) {\n\t\td = ship(t * ld + p).d;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.02, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nvec2 aof(vec3 p, vec3 n, vec2 h) {\n    vec2 ao;\n    for (int i = I0; i < 2; i++)\n        ao[i] = ship(h[i] * n + p).d;\n    return sat(ao / h);\n}\n\nbool reflecting = false;\nvec3 lights(vec3 p, vec3 rd, inout vec3 n, Hit h, inout float r) {\n\tfloat ao, l1, l2, fre, spec,\n\t      freCutOff = .95,\n\t      sha = 1.,\n\t      l3c = 1.;\n\tvec3 c,\n\t     ld = normalize(vec3(-25, 45, -40) - p),\n\t     freRGB = vec3(0);\n\tvec2 spe = vec2(10, 1);\n\tif (h.id == MOON_ID) {\n\t\tl3c = 0.;\n\t\tspe.y = .04;\n\t\tc = vec3(49, 48, 46) / 85e2;\n\t\tc -= .004 * S(.7, 1., -n.z);\n\t\tfreRGB = vec3(1);\n\t\tfreCutOff = .5;\n\t\tif (reflecting) {\n\t\t\t// Less harsh fresnel when rendering a reflection.\n\t\t\tc *= 10.;\n\t\t\tfreRGB = vec3(.2);\n\t\t\tfreCutOff = .05;\n\t\t}\n\t}\n\telse {\n\t\tsha = shadow(p);\n\t\tfloat a = atan(h.p.y, h.p.z) / 6.28318 + .5;\n        vec3 ns = n3331(h.p, vec3(4, 15, 40));\n\t\tif (h.p.x > 3.) {\n\t\t\t// Exhaust Nozzle\n\t\t\tif (h.p.x > 4.35) c = vec3(4.9, 4.8, 4.15) / 255.;\n\t\t\telse {\n\t\t\t\tfloat f = S(.2, 0., abs(fract(a * 12.) - .5)) * .2;\n\t\t\t\tf += S(4.4, 3., h.p.x);\n\t\t\t\tc = mix(vec3(176, 141, 87) / 85e2, vec3(176, 141, 87) / 2550., f);\n\t\t\t\tspe = vec2(5, 4);\n\t\t\t}\n\n\t\t\tc *= .7 + .3 * ns.y;\n\t\t}\n\t\telse {\n\t\t\tif (h.id != RADSEPS_ID) { if ((length(h.p.yz) < 2.1 && abs(h.p.x - 1.3) < .5) || abs(h.p.x + 1.9) < .3) h.id = WHITE_ID; }\n\n\t\t\telse if (abs(h.p.x + 1.8) + step(.22, fract(a * 8. + .6)) < .06) h.id = WHITE_ID;\n\n\t\t\tif (h.id == WINDOW_ID) {\n\t\t\t\tr = 1.;\n\t\t\t\tc = vec3(.01, .01, .013) * .24;\n\t\t\t\tspe = vec2(3, 30);\n\t\t\t}\n\t\t\telse if (h.p.x < -2.3) {\n\t\t\t\t// Nose cone.\n\t\t\t\tr = .8;\n\t\t\t\tfloat f = .1 * sin(a * 2e2);\n\t\t\t\tn.y += f * f;\n\t\t\t\tn += (ns.x - .5 + .1 * ns.y - .05) * .03;\n\t\t\t\tspe = vec2(50, 20);\n\t\t\t\tc = vec3(.001);\n\t\t\t\tc += pow(sat(dot(rd, reflect(ld, n))), 5.) * .03;\n\t\t\t\tc *= .7 + .15 * (ns.y + ns.z);\n\t\t\t}\n\t\t\telse if (h.id == WHITE_ID) {\n\t\t\t\t// White panels.\n\t\t\t\tc = vec3(.45);\n\t\t\t\tc *= .9 + .05 * (ns.y + ns.z);\n\t\t\t\tl3c = .1;\n\t\t\t\tsha = .6 + .4 * sha;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Main body.\n\t\t\t\tr = .1;\n\t\t\t\tn += (ns.x - .5) * .03;\n\t\t\t\tspe = vec2(2, 3);\n\t\t\t\tc = vec3(27, 23, 21) / 255.;\n\t\t\t\tc += pow(sat(dot(rd, reflect(ld, n))), 5.) * .2;\n\t\t\t\tc *= .7 + .15 * (ns.y + ns.z);\n\n\t\t\t\t// Fake paneling.\n\t\t\t\tif (h.id == BODY_ID) {\n\t\t\t\t\tfloat fr, fb,\n\t\t\t\t\t      f = h21(floor(vec2(a * 18., h.p.x * 2.)));\n\t\t\t\t\tc += .04 * (f - .5);\n\t\t\t\t\tspe.y += f;\n\n\t\t\t\t\t// Flag.\n\t\t\t\t\th.p.x += .65;\n\t\t\t\t\th.p.z += .2;\n\t\t\t\t\th.p.xz *= 1.5;\n\t\t\t\t\tf = S(.02, 0., max(abs(h.p.z - .35) - .32, abs(h.p.x + 1.1) - .2));\n\t\t\t\t\tfr = S(-.25, .25, sin(h.p.x * 1e2 - 1.));\n\t\t\t\t\tfb = S(.01, 0., h.p.x + 1.09) * S(.02, 0., .38 - h.p.z);\n\t\t\t\t\tc = mix(c, vec3(.1, 0, 0), fr * f);\n\t\t\t\t\tc = mix(c, vec3(0, 0, .03), fb * f);\n\t\t\t\t\tl3c *= (1. - fr * f);\n\t\t\t\t\tl3c *= (1. - fb * f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n    vec2 ao2 = aof(p, n, vec2(0.05, .5));\n\tao = mix(ao2.x, ao2.y, .7);\n\tl1 = sat(.1 + .9 * dot(ld, n));\n\tl2 = sat(.3 + .7 * dot(-vec3(.23487, .32642, -.91558), n));\n\tfre = S(1., freCutOff, 1. + dot(rd, n));\n\tspec = pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y;\n\tfloat spec2 = pow(sat(dot(rd, -n)), 40.) * l3c;\n\tl1 += spec;\n\tl1 *= .01 + .99 * sha;\n\tl2 *= ao;\n\tc = mix(freRGB, (l1 + l2) * c * LIGHT_RGB + spec2 * vec3(.14, .13, .1), fre);\n\tif (!reflecting) c += pow(sat(dot(rd, vec3(-.89443, .44721, 0))), 4.) * .2; // Glare.\n\treturn c;\n}\n\nvec3 scene(vec3 p, vec3 rd) {\n\t// March the scene.\n\tfloat i,\n\t      d = 3.,\n\t      r = 0.;\n\tHit h;\n\tfor (i = Z0; i < MAX_STEPS; i++) {\n\t\th = map(p);\n\t\tif (abs(h.d) < MIN_DIST || d > MAX_DIST) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tvec3 col,\n\t     n = N(p, d);\n\tif (d > MAX_DIST) return sky(rd.xy);\n\tcol = lights(p, rd, n, h, r);\n\tif (r > 0.) {\n\t\t// We hit a reflective surface, so march reflection.\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\td = 0.;\n\t\tfor (i = Z0; i < MAX_RSTEPS; i++) {\n\t\t\th = map(p);\n\t\t\tif (abs(h.d) < MIN_DIST * d || d > MAX_RDIST) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tif (d < MAX_RDIST) {\n\t\t\tn = N(p, d);\n\t\t\treflecting = true;\n\t\t\tcol += r * lights(p, rd, n, h, i);\n\t\t}\n\t}\n\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tt = mod(iTime, 35.);\n\tvec3 ro = vec3(-t / 15., 1. - t / 15., -20),\n\t     col = vec3(1);\n\tvec2 uv = (fc - .5 * R.xy) / R.y,\n\t     v = fc.xy / R.xy,\n\t     cp = vec2(uv.y * .4 - uv.x + .85, uv.x - uv.y + 1.1);\n\tcol *= S(0., .05, min2(cp));\n\tif (col.r > 0.) {\n\t\t// Main scene.\n\t\tvec3 aa = scene(ro, rayDir(ro, uv));\n#ifdef AA\n\t\tif (fwidth(aa.g) > .1) {\n\t\t\tfor (float dx = -.5; dx <= .5; dx++) {\n\t\t\t\tfor (float dy = -.5; dy <= .5; dy++)\n\t\t\t\t\taa += scene(ro, rayDir(ro, uv + vec2(dx, dy) / R.xy));\n\t\t\t}\n\n\t\t\taa *= 0.2;\n\t\t}\n#endif\n\n\t\tcol *= aa;\n\t\tcp = uv * mat2(.95534, -.29552, .29552, .95534);\n\n\t\t// Screen glare.\n\t\tcol += pow(S(-.5, .1, uv.y) * S(.15, 0., abs(cp.x - .72) * (1.5 - uv.y)), 1.3) * vec3(.5, .8, 1) * .025;\n\t}\n\telse {\n\t\t// Viewing window.\n\t\tcol = vec3(.03, .01, .01) * S(.1, -.1, min2(abs(cp + .1)));\n\t\tcol += S(.03, -.03, abs(cp.x + .06)) * S(-.5, 0., uv.y) * vec3(.08, .04, .002);\n\t}\n    \n\tcol *= .5 + .5 * pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = vec4(pow(max(vec3(0), col), vec3(.45)) * sat(t), 0);\n}", "image_inputs": [{"id": 29052, "src": "https://soundcloud.com/thebritishibm/aidy-gods-front-porch", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2fzc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2044, 2044, 2062, 2062, 2182], [2184, 2184, 2204, 2204, 2303], [2305, 2305, 2324, 2324, 2345], [2347, 2347, 2366, 2366, 2701], [2703, 2703, 2731, 2731, 2825], [2827, 2827, 2846, 2846, 2978], [2980, 2980, 3000, 3000, 3024], [3026, 3026, 3046, 3046, 3070], [3072, 3072, 3092, 3092, 3126], [3128, 3128, 3147, 3147, 3214], [3216, 3216, 3247, 3247, 3298], [3300, 3300, 3343, 3343, 3491], [3493, 3493, 3520, 3520, 3591], [3593, 3593, 3621, 3621, 3721], [3723, 3723, 3772, 3772, 4092], [4094, 4094, 4125, 4125, 4253], [4255, 4255, 4274, 4274, 4458], [4460, 4460, 4488, 4488, 4606], [4817, 4817, 4835, 4835, 7970], [7972, 7972, 7995, 7995, 8410], [8412, 8412, 8429, 8429, 8491], [8493, 8493, 8518, 8518, 8726], [8728, 8728, 8750, 8750, 9061], [9063, 9099, 9133, 9133, 9243], [9270, 9270, 9336, 9336, 12350], [12352, 12352, 12381, 12402, 13108], [13110, 13110, 13155, 13155, 14193]]}
{"id": "WtjczR", "name": "Complex Atanh Made Simple", "author": "mla", "description": "When looking at [url]https://www.shadertoy.com/view/tsBXRW[/url] again I had difficulty understanding what was going on, so here is a version that tries to simplify & explain.\n\nMouse changed degree of spiralling, 'a','l','x',and 'z' also do things.", "tags": ["complex", "atanh"], "likes": 28, "viewed": 504, "published": 3, "date": "1655027495", "time_retrieved": "2024-07-30T16:44:42.094606", "image_code": "/*\nCopyright (c) 2022 Matthew Arcus\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this \nsoftware and associated documentation files (the \"Software\"), to deal in the Software \nwithout restriction, including without limitation the rights to use, copy, modify, \nmerge, publish, distribute, sublicense, and/or sell copies of the Software, and to \npermit persons to whom the Software is furnished to do so, subject to the following \nconditions:\n\nThe above copyright notice and this permission notice shall be included in all \ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, \nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A \nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT \nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\nOR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/ \n\n// Complex Atanh Made Simple, Matthew Arcus, mla, 2022\n// Draw a grid, rotate and transform with atanh.\n//\n// Complex log, and functions derived from it, like atanh,\n// produce results that have discontinuities in the imaginary\n// part, jumping between -PI and PI for clog, and -PI/2\n// and PI/2 for atanh. To hide these discontinuities, we\n// need to ensure that the colouring function produces the\n// same value for both these values, which we can do this\n// by making it periodic.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  int A = 2, B = 7; // Rotation angle is atan(B,A)\n  float alpha = 1.0;\n  if (!key(CHAR_A)) alpha += 0.618*sin(iTime);\n  vec2 ar = vec2(alpha,1.0/alpha);\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m = floor(20.0*m);\n    // Ensure A is positive\n    if (m.x < 0.0) m = -m;\n    A = max(1,int(m.x)), B = int(m.y);\n  }\n  vec2 rot = 0.5*ar.yx*vec2(float(A),-B);\n  float scale = 2.0;\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n  if (!key(CHAR_X)) {\n    //z = 2.0*catanh(z);\n    z = clog(z) + 2.0*catanh(z+vec2(0,1)) + 2.0*catanh(-z+vec2(0,1));\n    z /= PI;\n  }\n  vec2 z0 = z;\n  z.y += 0.2*iTime;\n  //z.y = mod(z.y,2.0); // Check periodicity - this should have no effect\n  float px = fwidth(z.x);\n  z = cmul(rot,z); // Transform z to skewed square grid\n  px *= length(rot); // Adjust pixel width\n  z /= ar;\n  ivec2 index = ivec2(floor(z)); // Index of grid square\n\n  // Want color(rot*(x-i)) = color(rot*(x+i)) so:\n  // color(rot*x-rot*i) = color(rot*x+rot*i) so:\n  // color(z) = color(z+(B+iA)) ie.\n  // coloring function should be periodic, period B+iA.\n  // Note that we only need to repeat in one direction.\n  int k = idiv(index.y,A); // Integer divide, but fixed for -ve values\n  index -= k*ivec2(B,A);\n\n  float h = float(ihash(uint(index.x)^ihash(uint(index.y))))/pow(2.0,32.0);\n  vec3 col = getcol(h);\n  z = fract(z);\n  z *= ar;\n  z = min(z,ar-z);\n  float d = min(z.x,z.y);\n  if (!key(CHAR_L)) {\n    // Draw a pattern in each cell - just a line for now.\n    z -= 0.5*ar;\n    d = min(d,abs(z[int(h<0.5)])); // Iverson brackets are cool.\n  }\n  col *= smoothstep(-px,px,d-0.02);\n  float px0 = fwidth(length(z0));\n  if (key(CHAR_Z)) {\n    // Show borders of repeating area.\n    col = mix(vec3(1,0,0),col,smoothstep(-px0,px0,abs(abs(z0.y)-1.0)-0.01));\n  }\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_L = 76;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nconst float PI = 3.14159;\n\nvec2 cmul(vec2 z, vec2 w) {\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return rgb;\n}\n\nint idiv(int a,int b) {\n  if (b < 0) { b = -b; a = -a; }\n  if (a < 0) return -((-a+b-1)/b); // Careful with bracket here!\n  else return a/b;\n}\n\nint imod(int a, int b) {\n  int d = idiv(a,b);\n  return a-d*b;\n}\n\n// iq's palette function\nvec3 pal( float t, vec3 a, vec3 b, vec3 c, vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 getcol(float t) {\n  vec3 rgb = pal(t,vec3(0.8), vec3(0.2), vec3(1), vec3(0,0.1,0.2));\n  return rgb;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjczR.jpg", "access": "api", "license": "mit", "functions": [[1559, 1559, 1616, 1616, 3504]]}
{"id": "7sVyDm", "name": "Knot mosaic", "author": "jarble", "description": "A mosaic with knot patterns.", "tags": ["fractal", "knot", "mosaic"], "likes": 5, "viewed": 250, "published": 3, "date": "1655016038", "time_retrieved": "2024-07-30T16:44:42.928377", "image_code": "//#define animate\n\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float t4 = floor((uv.x+uv.y+iTime)/16.);\n\n    for(int i=0;i<2;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){\n            //t2.yx *= sign(uv.x-uv.y);\n\n            uv += (t2.yx);\n            t2 = triangle_wave(uv.yx-.5,scale);\n            //t2.y -= float(i)/4.;\n            #ifdef animate\n            float num = 3.+float(k);\n            t2 += t4/num;\n            #endif\n            t3 = triangle_wave(uv,scale);\n            //t3 -= float(k)/3.;\n            uv.yx = (t2-t3)/(scale);\n            col.x = min(((uv.y-uv.x)-col.x),-col.x)/sqrt(3.);\n            col = abs(col.yzx+vec3(col.x))/sqrt(3.);\n        }\n        \n    }\n    fragColor = vec4((col*9.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVyDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 87, 87, 132], [134, 134, 191, 191, 1153]]}
{"id": "sdKyWm", "name": "Covfefe", "author": "zovox", "description": "Official covfefe shader.", "tags": ["covfefe"], "likes": 3, "viewed": 257, "published": 3, "date": "1654998745", "time_retrieved": "2024-07-30T16:44:43.720259", "image_code": "#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define FAR (10.)\n#define TAO (2.*PI)\n\nvec2 Rotate(in vec2 v, float angle) {return v*mat2(cos(angle),sin(angle),-sin(angle),cos(angle));}\nvec2 Kaleido(in vec2 v,float power){return Rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat smooth_floor(float x) {\n    return smoothstep(0.5, 1., fract(x))+floor(x);\n}\n\nfloat dfScene(in vec3 z0){\n    float mind = 1E32;\n    const float detail = 4.;\n    for(float vert = 0.; vert < detail; vert += 1.) {\n        for(float horiz = 0.; horiz < detail; horiz += 1.) {\n            z0.xy=Kaleido(z0.xy, 2.+saw(iTime/PI/E)*4.);\n            z0.yz=Rotate(z0.yz, (.25+1.5*saw(iTime/GR/PI))*PI);\n            float d = sdBox(z0, vec3(.125));\n            z0.y -= .125;\n            if(d < mind) mind = d;\n        }   \n    }\n\n\treturn mind;\n}\n\nvec3 surfaceNormal(vec3 p) { \n    vec2 e = vec2(5.0 / 1024., 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//main march\nvec4 marchScene(vec2 uv) {\n    \n    float movement = iTime/PI;\n    //camera\n    vec3 rd = normalize(vec3(uv, -1./GR));\n    vec3 ro = vec3(0.0, 0., 2.);\n    \n    //rotate camera\n    rd.xz *= rot(-movement);\n    ro.xz *= rot(-movement);\n    ro += rd/512.;\n    \n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n   \tfloat ns;\n    vec3 p;\n    for (int i = 0; i <16; i++) {\n        rp = ro + rd * d;\n        p = rp;\n        ns = dfScene(p);\n        d += ns;\n        if(d > FAR)\n        {\n            break;\n        }\n        \n    }\n    float fog = smoothstep(.75, .9, d/FAR);\n    vec3 n = surfaceNormal(p);\n    return vec4(n, 1.)*(1.-fog);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 t1 = marchScene(uv);\n    fragColor = t1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 112, 149, 149, 210], [211, 211, 247, 247, 310], [448, 448, 467, 467, 519], [521, 521, 552, 552, 639], [640, 640, 669, 669, 722], [724, 724, 750, 750, 1180], [1182, 1182, 1210, 1210, 1504], [1506, 1519, 1545, 1545, 2183], [2185, 2185, 2242, 2266, 2441]]}
{"id": "NsKcDm", "name": "simple comic book effect", "author": "cedric_h", "description": "tiles it, rotates it, uses a really basic SDF for the gradient of the tiles", "tags": ["paper", "print", "nostalgia", "comicbook"], "likes": 1, "viewed": 289, "published": 3, "date": "1654985880", "time_retrieved": "2024-07-30T16:44:44.461278", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = vec2(\n        fragCoord.x * cos(0.3) - fragCoord.y * sin(0.3),\n        fragCoord.x * sin(0.3) + fragCoord.y * cos(0.3)\n    );\n    \n    float x = mod(uv.x * 0.14, 2.0) / 2.0;\n    float y = mod(uv.y * 0.14, 2.0) / 2.0;\n\n\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy) *\n        (1.0 - abs(0.5 - x) * abs(0.5 - y));\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKcDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 398]]}
{"id": "fdKcDw", "name": "my second raymarching", "author": "SONENEIS", "description": "...", "tags": ["3d", "raymarching"], "likes": 7, "viewed": 321, "published": 3, "date": "1654975295", "time_retrieved": "2024-07-30T16:44:45.384810", "image_code": "/*settings*/\n#define AA 1\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define STEPS 256\n#define EPSILON 0.001\n/*end settings*/\n\n#define pi 3.14159265\n#define tau pi * 2.0\n\n//random\nfloat hash(float v){return fract(sin(v*dot(vec2(737.873,777.873),vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec2 uv){return fract(sin(dot(uv,vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec3 uv){return fract(sin(dot(uv,vec3(173.873,515.526,726.873)))*82723.782);}\n\n//noise 1d\nfloat noise(float a){\n\tfloat f = fract(a);\n\tfloat h = f*f*(3.0-2.0*f);\n\treturn mix(hash(a),hash(a + 1.0),h);\n}\n\n//noise 2d\nfloat noise(vec2 uv){\n\tvec2 e = vec2(0.0,1.0);\n\tvec2 p = floor(uv);\n\tvec2 f = smoothstep(0.0,1.0,fract(uv));\n\treturn mix(\n\t\tmix(hash(p + e.xx),hash(p + e.yx),f.x),\n\t\tmix(hash(p + e.xy),hash(p + e.yy),f.x),\n\t\tf.y\n\t);\n}\n\n//noise 3d\nfloat noise(vec3 uv3d){\n\tvec2 e = vec2(0.0,1.0);\n\tvec3 s = vec3(110.0,241.0,171.0);\n\tvec3 i = floor(uv3d);\n\tvec3 f = fract(uv3d);\n\tfloat n = dot(i,s);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\tfloat x1 = mix(hash(n + dot(s,e.xxx)),hash(n + dot(s,e.yxx)),u.x);\n\tfloat x2 = mix(hash(n + dot(s,e.xyx)),hash(n + dot(s,e.yyx)),u.x);\n  float y1 = mix(hash(n + dot(s,e.xxy)),hash(n + dot(s,e.yxy)),u.x);\n  float y2 = mix(hash(n + dot(s,e.xyy)),hash(n + dot(s,e.yyy)),u.x);\n\treturn mix(mix(x1,x2,u.y),mix(y1,y2,u.y),u.z);\n}\n\n//clamp zero one\n#define czo(a) clamp(a,0.0,1.0)\n\n//integer mix\n#define imix(a,b,k) mix(float(a),float(b),k)\n\n//vector min\nfloat vmin(vec2 a){return min(a.x,a.y);}\nfloat vmin(vec3 a){return min(min(a.x,a.y),a.z);}\nfloat vmin(vec4 a){return min(min(a.x,a.y),min(a.z,a.w));}\n\n//vector max\nfloat vmax(vec2 a){return max(a.x,a.y);}\nfloat vmax(vec3 a){return max(max(a.x,a.y),a.z);}\nfloat vmax(vec4 a){return max(max(a.x,a.y),max(a.z,a.w));}\n\n//square\nfloat sq(float a){return pow(a,2.0);}\nvec2 sq(vec2 a){return pow(a,vec2(2.0));}\nvec3 sq(vec3 a){return pow(a,vec3(2.0));}\nvec4 sq(vec4 a){return pow(a,vec4(2.0));}\n\n//length square\n//length square\n#define lsq(a) dot(a,a)\n\n//smooth min\nfloat smin(float a,float b,float k){\n\tfloat h = czo(0.5 + 0.5*(b-a)/k);\n\treturn mix(b,a,h) - k*h*(1.0-h);\n}\n\n//smooth max\n#define smax(a,b,k) -smin(-a,-b,k)\n\nstruct Object{\n  float f;\n  vec3 p;\n\tfloat id;\n\tvec3 col;\n};\n\n//3d sdf primitives\nObject fSphere(float id,vec3 uv3d,float rad,vec3 col){\n\tfloat sphere = length(uv3d) - rad;\n\treturn Object(sphere,uv3d,id,col);\n}\nObject fEllipsoid(float id,vec3 uv3d,vec3 rad,vec3 col){\n  float p1 = length(uv3d/rad);\n  float p2 = length(uv3d/sq(rad));\n  float elli = p1*(p1-1.0)/p2;\n\treturn Object(elli,uv3d,id,col);\n}\nObject fCube(float id,vec3 uv3d,float size,vec3 col){\n\tvec3 p = abs(uv3d) - size;\n\tfloat cube = length(max(p,0.0)) + min(vmax(p),0.0);\n\treturn Object(cube,uv3d,id,col);\n}\nObject fBox(float id,vec3 uv3d,vec3 size,vec3 col){\n\tvec3 p = abs(uv3d) - size;\n\tfloat box = length(max(p,0.0)) + min(vmax(p),0.0);\n\treturn Object(box,uv3d,id,col);\n}\nObject fBoxInfinity(float id,vec3 uv3d,vec2 size,vec3 col){\n\tvec2 p = abs(uv3d.xy) - size;\n\tfloat box = length(max(p,0.0)) + min(vmax(p),0.0);\n\treturn Object(box,uv3d,id,col);\n}\nObject fTorus(float id,vec3 uv3d,vec2 t,vec3 col){\n\tfloat torus = length(vec2(length(uv3d.xz)-t.x,uv3d.y))-t.y;;\n\treturn Object(torus,uv3d,id,col);\n}\nObject fCylinder(float id,vec3 uv3d,vec2 h,vec3 col){\n  vec2 p = abs(vec2(length(uv3d.xz),uv3d.y)) - h;\n  float cylin = min(max(p.x,p.y),0.0) + length(max(p,0.0));\n\treturn Object(cylin,uv3d,id,col);\n}\nObject fLine(float id,vec3 uv3d,float rad,vec3 v1,vec3 v2,vec3 col){\n\tvec3 a = uv3d-v1,b = v2-v1;\n\tfloat line = length(a - b*czo(dot(a,b)/lsq(b))) - rad;\n\treturn Object(line,uv3d,id,col);\n}\nObject fConeRound(float id,vec3 uv3d,float d,float r1,float r2,vec3 col){\n  vec2 p = vec2(length(uv3d.xz),uv3d.y);\n\n  float b = (r1-r2)/d;\n  float a = sqrt(1.0-sq(b));\n  float k = dot(p,vec2(-b,a));\n\n  float cone;\n  if(k < 0.0) cone = length(p) - r1;\n  else if(k > a*d) cone = length(p-vec2(0.0,d)) - r2;\n  else cone = dot(p,vec2(a,b)) - r1;\n\n\treturn Object(cone,uv3d,id,col);\n}\nObject fPlane(float id,vec3 uv3d,float d,vec3 n,vec3 col){\n\tfloat plane = dot(uv3d,n) - (-d);\n\treturn Object(plane,uv3d,id,col);\n}\n\n//3d sdf operations\n//union\nObject fOpUnion(Object a,Object b){\n  if(a.f < b.f) return a;\n  else return b;\n}\nObject fOpUnionSmooth(Object a,Object b,float k,float div){\n  Object res;\n  float h = czo(0.5 + 0.5*(a.f-b.f)/k);\n  res.f = smin(a.f,b.f,k);\n  res.col = mix(a.col,b.col,czo(0.5+0.5*(a.f-b.f)/k));\n  res.id = mix(a.id,b.id,h) < div ? a.id : b.id;\n  res.p = mix(a.p,b.p,h) == a.p ? a.p : b.p;\n\treturn res;\n}\n//intersection\nObject fOpIntersection(Object a,Object b){\n  if(a.f > b.f) return a;\n  else return b;\n}\nObject fOpIntersectionSmooth(Object a,Object b,float k,float div){\n  Object res;\n  float h = czo(0.5 - 0.5*(b.f-a.f)/k);\n  res.f = smax(a.f,b.f,k);\n  res.col = mix(a.col,b.col,czo(0.5+0.5*(a.f-b.f)/k));\n  res.id = mix(a.id,b.id,h) < div ? a.id : b.id;\n  res.p = mix(a.p,b.p,h) == a.p ? a.p : b.p;\n\treturn res;\n}\n//difference\nObject fOpDifference(Object a,Object b){\n\ta.f = -a.f;\n\treturn fOpIntersection(a,b);\n}\nObject fOpDifferenceSmooth(Object a,Object b,float k,float div){\n  Object res;\n  float h = czo(0.5 - 0.5*(a.f+b.f)/k);\n  res.f = smax(-a.f,b.f,k);\n  res.col = mix(a.col,b.col,czo(0.5+0.5*(a.f-b.f)/k));\n  res.id = mix(b.id,a.id,h) < div ? a.id : b.id;\n  res.p = mix(b.p,a.p,h) == a.p ? a.p : b.p;\n\treturn res;\n}\n\n//rotation matrices\nmat3 rotateX(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(1,0,0),\n\t\tvec3(0,c,-s),\n\t\tvec3(0,s,c)\n\t);\n}\nmat3 rotateY(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(c,0,s),\n\t\tvec3(0,1,0),\n\t\tvec3(-s,0,c)\n\t);\n}\nmat3 rotateZ(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(c,-s,0),\n\t\tvec3(s,c,0),\n\t\tvec3(0,0,1)\n\t);\n}\n\n/*texture mapping algorithms*/\n//triplanar mapping\nvec3 fTextureTP(sampler2D tex,vec3 uv3d,vec3 normal){\n  normal = uv3d;\n  normal = abs(normal);\n  normal = pow(normal,vec3(5.0));\n  normal /= normal.x + normal.y + normal.z;\n  return\n  texture(tex,uv3d.xy + 0.5).rgb * normal.z +\n  texture(tex,uv3d.xz + 0.5).rgb * normal.y +\n  texture(tex,uv3d.yz + 0.5).rgb * normal.x;\n}\n//bump mapping\nvec3 fTextureBP(sampler2D tex,vec3 uv3d){\n  return vec3(0.0);\n}\n\n//background\nvec3 bgCol(){return vec3(0.2,0.6,1.0);}\nvec3 mist(){return vec3(0.85,0.9,1.0);}\nvec3 background(vec3 rd){\n\tvec3 bg = vec3(0.0);\n\n  bg += bgCol() - 0.7*rd.y;\n  bg = mix(bg,mist(),exp(-10.0*rd.y));\n\n  if(rd.y < 0.0) bg = mist();\n\n\treturn bg;\n}\n\nObject scene(vec3 uv3d){\n\tObject dist = Object(1.0,uv3d,-1.0,vec3(0.0));\n\n\tObject ball;\n\t{\n\t  vec3 p = uv3d;\n\t  p *= rotateX(iTime);\n\t  p *= rotateY(iTime);\n\t  p *= rotateZ(iTime);\n\n\t  ball = fSphere(-1.0,\n\t\t  p,0.6,\n\t\t  vec3(1.0,0.0,0.0)\n\t  );\n\n\t  ball.f += sin(p.x*5.0)*sin(p.y*5.0)*sin(p.z*5.0) * 0.2;\n\t  ball.f += sin(p.x*20.0)*sin(p.y*20.0)*sin(p.z*20.0) * 0.02;\n  }\n\n\tObject elli = fEllipsoid(-1.0,\n\t\tuv3d,vec3(0.6,0.3,0.1),\n\t\tvec3(1.0,0.5,0.0)\n\t);\n\n\tObject cube = fCube(-1.0,\n\t\tuv3d,0.45,\n\t\tvec3(0.9,0.35,0.1)\n\t);\n\tcube.f -= 0.1;\n\n\n\tObject torus = fTorus(-1.0,\n\t\tuv3d,vec2(0.5,0.2),\n\t\tvec3(1.0,0.6,0.1)\n\t);\n\n\t{\n\t\tvec3 p = uv3d.zyx;\n\n    Object door;\n\t  {\n\t  \tvec3 p = uv3d;\n\n\t  \tp.z = abs(p.z) - 1.5;\n\n\t  \tp.x = mod(p.x,2.0) - 1.0;\n\n\t    Object box = fBox(-1.0,\n\t    \tp,vec3(0.3,0.5,0.4),\n\t    \tvec3(1.0) //vec3(0.1,0.4,1.0)\n  \t  );\n  \t  Object cylin = fCylinder(-1.0,\n  \t  \tp.xzy - vec3(0.0,0.0,0.5),\n  \t  \tvec2(0.3,0.4),\n  \t  \tvec3(1.0) //vec3(0.1,0.4,1.0)\n\t    );\n\n      door = fOpUnion(cylin,box);\n    }\n\n\t\tp.x = abs(p.x) - 1.5;\n\n    Object wall = fBoxInfinity(-1.0,\n\t  \tp,vec2(0.1,1.0) - 0.1,\n\t  \tvec3(1.0)\n\t  );\n\t  wall.f -= 0.1;\n\n    //dist = wall;\n    //dist = door;\n    dist = fOpDifferenceSmooth(door,wall,0.05,0.0);\n    //dist = fOpDifference(door,wall);\n  }\n\n\tObject line = fLine(2.0,\n\t\tuv3d,0.05,\n\t\tvec3(0.0,0.0,0.0),\n\t\tvec3(0.5,0.5,0.5),\n\t\tvec3(1.0)\n\t);\n\n\tObject rcone = fConeRound(-1.0,\n\t\tuv3d,0.35,0.4,0.3,\n\t\tvec3(1.0,0.45,0.5)\n\t);\n\n\t/*rotating cube*/ {\n\t\tvec3 p = uv3d;\n\t\tp *= rotateX(iTime)*rotateY(iTime)*rotateZ(iTime);\n\n    float rad = 0.5;\n    rad += sin(p.x*10.0)*sin(p.y*10.0)*sin(p.z*10.0) * 0.05;\n\n    vec3 color = normalize(p)*0.5 + 0.5;\n\n\t  Object cube = fCube(-1.0,p,rad,color);\n\n\t  //dist = cube;\n  }\n\n  /*texture cube*/ {\n\t\tvec3 p = uv3d;\n\t\tp *= rotateX(iTime)*rotateY(iTime)*rotateZ(iTime);\n\n    float round = 0.0;\n    float rad = 0.5 - round;\n    //rad += sin(p.x*10.0)*sin(p.y*10.0)*sin(p.z*10.0) * 0.05;\n\n\t  Object cube = fCube(0.0,p,rad,vec3(0.0));\n\t  cube.f -= round;\n\n\t  //dist = cube;\n  }\n\n\tObject ground = fPlane(-1.0,\n\t\tuv3d,0.6,vec3(0.0,1.0,0.0),\n\t\ttexture(iChannel0,uv3d.zx*0.5).rgb\n\t\t//vec3(0.5+0.5*mod(floor(uv3d.x*5.0)+floor(uv3d.y*5.0)+floor(uv3d.z*5.0),2.0))\n\t);\n\n  //dist = fOpDifferenceSmooth(ball,cube,0.1,5.0);\n  //dist = fOpUnionSmooth(cube,ball,0.025,9.0);//,0.025);\n  dist = fOpUnion(dist,ball);\n\n  dist = fOpUnionSmooth(dist,ground,0.75,0.0);\n  //dist = fOpUnionSmooth(dist,ground,0.5,0.001);\n\n  //dist = fOpIntersection(dist,ground);\n  //dist = fOpIntersectionSmooth(dist,ground,0.5,6.0);\n\n  //dist = fOpDifference(dist,ground);\n  //dist = fOpDifferenceSmooth(dist,ground,0.5,0.75);\n\n  //dist = fOpDifference(ground,dist);\n  //dist = fOpDifferenceSmooth(ground,dist,0.5,0.1);\n\n  return dist;\n}\n\nObject raymarch(vec3 ro,vec3 rd){\n\tfloat dist = MIN_DIST;\n\tObject hit;\n\n\tfor(int i=0;i<STEPS;i++){\n\t\tvec3 uv3d = ro + dist*rd;\n\t\thit = scene(uv3d);\n\t\tif(abs(hit.f) < EPSILON || dist > MAX_DIST) break;\n\t\tdist += hit.f;\n\t}\n\n\treturn Object(dist,hit.p,hit.id,hit.col);\n}\n\nfloat getShadow(vec3 ro,vec3 rd){\n\tfloat start = 0.0, end = 3.0;\n\tfloat k = 10.0;\n\tfloat shadow = 1.0;\n\n\tfor(float d=start;d<end;){\n\t\tfloat hit = scene(ro + d*rd).f;\n\n\t\tif(hit < 0.001) return 0.0;\n\t\tshadow = min(shadow,k*hit/d);\n\n\t\td += hit;\n\t}\n\n\treturn shadow;\n}\n\nfloat getAmbOcc(vec3 ro,vec3 rd){\n  float occ = 0.0;\n  float w = 1.0;\n\n  for(float i=0.0;i<8.0;i++){\n  \tfloat len = 0.1 + 0.01*sq(i);\n  \tfloat dist = scene(ro + len*rd).f;\n  \tocc += (len - dist) * w;\n  \tw *= 0.85;\n  }\n\n  return 1.0 - czo(0.5 * occ);\n}\n\nvec3 getNormal(vec3 uv3d){\n\tvec2 e = vec2(1.0,-1.0) * EPSILON;\n\treturn normalize(vec3(\n\t\te.xyy * scene(uv3d + e.xyy).f +\n\t\te.yyx * scene(uv3d + e.yyx).f +\n\t\te.yxy * scene(uv3d + e.yxy).f +\n\t\te.xxx * scene(uv3d + e.xxx).f\n\t));\n}\n\nvec3 getMaterial(Object obj,vec3 normal){\n\tvec3 m = vec3(0.0);\n\n  switch(int(obj.id)){\n  \tdefault:\n  \t  m += vec3(1.0);\n  \t  break;\n\n  \tcase -1:\n  \t  m += obj.col;\n  \t  break;\n\n  \tcase 0:\n  \t  m += fTextureTP(iChannel1,obj.p,normal);\n  \t  break;\n  \tcase 1:\n  \t  m += texture(iChannel0,obj.p.zx).rgb;\n  \t  break;\n  }\n\n\treturn m;\n}\n\nstruct Light{\n\tvec3 pos;\n\tvec3 col;\n\tvec3 add;\n};\nLight light(vec3 uv3d,vec3 ro,vec3 rd,Object obj,vec3 pos,vec3 col){\n  Light res;\n\tres.pos = pos;\n\tres.col = col;\n\n  vec3 L = normalize(pos - uv3d);\n  vec3 N = getNormal(uv3d);\n  vec3 R = reflect(-L,N);\n  vec3 V = -rd;\n\n  vec3 color = getMaterial(obj,N);\n\tvec3 bg = background(rd);\n\n  //phong\n  vec3 speCol = vec3(1.0,1.0,1.0) * 0.5;\n  vec3 ambient = color * 0.05;\n  vec3 diffuse = color * czo(dot(L,N));\n  vec3 specular = speCol * pow(czo(dot(R,V)),10.0);\n\n  vec3 fresnel = 0.25 * color * pow(1.0 + dot(rd,N),3.0);\n\n  //shadow\n  float shadow = getShadow(uv3d+N*0.02,normalize(pos));\n  //float shadow = raymarch(uv3d+N*0.02,normalize(pos)).f;\n  //length(L)\n  //if(shadow < MAX_DIST && obj.id != Light_ID)\n  //  return Light(pos,col,ambient + fresnel);\n\n  //ambient occlusion\n  float occ = getAmbOcc(uv3d,N);\n\n  //back\n  vec3 back = 0.05 * color * czo(dot(N,-L));\n\n  //res.add = pow(abs(N),vec3(5.0));\n  //res.add = back;\n  //res.add = 0.9 * vec3(1.0) * occ;\n  res.add = (back + ambient + fresnel) * occ + (diffuse * occ + specular) * shadow;\n  //res.add = (ambient + fresnel) * occ + (diffuse * occ + specular) * shadow;\n  //res.add = ambient + (diffuse + specular) * shadow;\n  //res.add = ambient + diffuse + specular;\n\n\treturn res;\n}\n\nmat3 lookAt(vec3 ro,vec3 la){\n\tvec3 cf = normalize(ro - la);\n\tvec3 cr = normalize(cross(vec3(0,1,0),cf));\n\tvec3 cu = normalize(cross(cf,cr));\n\n\treturn mat3(cr,cu,cf);\n}\n\nvec2 getUV(vec2 offset,vec2 fragCoord){\n\treturn (2.0 * (fragCoord - offset) - iResolution.xy)/iResolution.y;\n}\n\nvec3 render(vec2 uv){\n  vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n\n  //camera\n  float fov = 1.0;\n  vec3 la = vec3(0.0,0.0,0.0);\n  vec3 ro = vec3(0.0,0.5,3.0);\n\n  ro *= rotateX(mouse.y * pi * 0.5 - 0.5);\n  ro *= rotateY(-mouse.x * tau * 2.0 + 1.0);\n\n  vec3 rd = lookAt(ro,la) * normalize(vec3(uv,-fov));\n\n  Object obj = raymarch(ro,rd);\n  {\n    vec3 uv3d = ro + obj.f*rd;\n    vec3 normal = getNormal(uv3d);\n\n    vec3 bg = background(rd);\n    vec3 material = vec3(0.0);\n\n\t  Light sun = light(uv3d,ro,rd,obj,\n  \t  vec3(30.0,40.0,-30.0),\n\t    vec3(1.0,1.0,1.0)\n  \t);\n    material  += sun.add;\n\n    if(obj.f < MAX_DIST){\n      col += material;\n\n      //gamma correction\n      col = pow(col,vec3(1.0/2.2));\n      //mist\n      col = mix(col,mist(),1.0-exp(-1e-5*pow(obj.f,3.0)));\n    }else{\n    \tcol = bg;\n    }\n  }\n\n  return col;\n}\n\nvoid renderAAx4(inout vec3 color,vec2 c){\n\tvec4 e = vec4(0.125,-0.125,0.375,-0.375);\n\tvec3 colAA = render(getUV(e.xz,c)) + render(getUV(e.yw,c)) + render(getUV(e.wx,c)) + render(getUV(e.zy,c));\n\tcolor += colAA / 4.0;\n}\nvoid renderAAx1(inout vec3 color,vec2 c){\n\tcolor += render(getUV(vec2(0.0),c));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n  vec3 col = vec3(0.0);\n\n  if(AA == 1) renderAAx1(col,fragCoord);\n  else if(AA == 4) renderAAx4(col,fragCoord);\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKcDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 181, 201, 201, 282], [283, 283, 303, 303, 363], [364, 364, 384, 384, 452], [454, 465, 486, 486, 575], [577, 588, 609, 609, 805], [807, 818, 841, 841, 1327], [1439, 1452, 1471, 1471, 1492], [1493, 1493, 1512, 1512, 1542], [1543, 1543, 1562, 1562, 1601], [1603, 1616, 1635, 1635, 1656], [1657, 1657, 1676, 1676, 1706], [1707, 1707, 1726, 1726, 1765], [1767, 1776, 1794, 1794, 1813], [1814, 1814, 1830, 1830, 1855], [1856, 1856, 1872, 1872, 1897], [1898, 1898, 1914, 1914, 1939], [1998, 2011, 2047, 2047, 2118], [2231, 2251, 2305, 2305, 2379], [2380, 2380, 2436, 2436, 2569], [2570, 2570, 2623, 2623, 2740], [2741, 2741, 2792, 2792, 2907], [2908, 2908, 2967, 2967, 3085], [3086, 3086, 3136, 3136, 3235], [3236, 3236, 3289, 3289, 3436], [3437, 3437, 3505, 3505, 3626], [3627, 3627, 3700, 3700, 4005], [4006, 4006, 4064, 4064, 4136], [4138, 4166, 4201, 4201, 4246], [4247, 4247, 4306, 4306, 4551], [4552, 4567, 4609, 4609, 4654], [4655, 4655, 4721, 4721, 4966], [4967, 4980, 5020, 5020, 5065], [5066, 5066, 5130, 5130, 5376], [5378, 5398, 5424, 5424, 5535], [5536, 5536, 5562, 5562, 5673], [5674, 5674, 5700, 5700, 5811], [5813, 5864, 5917, 5917, 6184], [6185, 6200, 6241, 6241, 6263], [6265, 6278, 6291, 6291, 6317], [6318, 6318, 6330, 6330, 6357], [6358, 6358, 6383, 6383, 6519], [6521, 6521, 6545, 6545, 9278], [9280, 9280, 9313, 9313, 9546], [9548, 9548, 9581, 9581, 9811], [9813, 9813, 9846, 9846, 10064], [10066, 10066, 10092, 10092, 10293], [10295, 10295, 10336, 10336, 10624], [10676, 10676, 10744, 10744, 11911], [11913, 11913, 11942, 11942, 12081], [12083, 12083, 12122, 12122, 12193], [12195, 12195, 12216, 12216, 13061], [13063, 13063, 13104, 13104, 13281], [13282, 13282, 13323, 13323, 13363], [13365, 13365, 13418, 13418, 13562]]}
{"id": "NdKyDw", "name": "Hex marching", "author": "mrange", "description": "License CC0: Hex Marching\nResults from saturday afternoon tinkering\n", "tags": ["hexes"], "likes": 263, "viewed": 10206, "published": 3, "date": "1654970647", "time_retrieved": "2024-07-30T16:44:46.269444", "image_code": "// License CC0: Hex Marching\n//  Results from saturday afternoon tinkering\n#define TIME iTime\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n\n  vec4 pcol = texture(iChannel0, q);\n  vec3 col = pcol.xyz;\n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 2.0, TIME);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// License CC0: Hex Marching\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define BPM         30.0\n\nconst float planeDist = 1.0-0.2;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.15*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.05;\n  return 0.5*(offset(z + eps) - offset(z - eps))/(2.0*eps);\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.05;\n  return 0.5*(doffset(z + eps) - doffset(z - eps))/(2.0*eps);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nvec4 effect(vec2 p, float aa, float h) {\n  vec2 hhn = hextile(p);\n  const float w = 0.02;\n  vec2 pp = toPolar(p);\n  float a = pp.y;\n  float hn = mod1(pp.y, TAU/6.0);\n  vec2 hp = toRect(pp);\n  float hd = hp.x-(w*10.0);\n  \n  float x = hp.x-0.5*w;\n  float n = mod1(x, w);\n  float d = abs(x)-(0.5*w-aa);\n  \n  float h0 = hash(10.0*(hhn.x+hhn.y)+2.0*h+n);\n  float h1 = fract(8667.0*h0);\n  float cut = mix(-0.5, 0.999, 0.5+0.5*sin(TIME+TAU*h0));\n  const float coln = 6.0;\n  float t = smoothstep(aa, -aa, d)*smoothstep(cut, cut-0.005, sin(a+2.0*(h1-0.5)*TIME+h1*TAU))*exp(-150.0*abs(x));\n  vec3 col = hsv2rgb(vec3(floor(h0*coln)/coln, 0.8, 1.0))*t*1.75;\n\n  t = mix(0.9, 1.0, t);\n  t *= smoothstep(aa, -aa, -hd);\n  if (hd < 0.0) {\n    col = vec3(0.0);\n    t = 15.*dot(p, p);\n  }\n  return vec4(col, t);\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 npp, vec3 off, float n) {\n  float h0 = hash(n);\n  float h1 = fract(8667.0*h0);\n\n  vec3 hn;\n  vec2 p  = (pp-off*vec3(1.0, 1.0, 0.0)).xy;\n  p *= ROT(TAU*h0);\n  p.x -= 0.25*h1*(pp.z-ro.z);\n  const float z = 1.0;\n  p /= z;\n  float aa = distance(pp,npp)*sqrt(1.0/3.0)/z;\n  vec4 col = effect(p, aa, h1);\n\n  return col;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  return vec3(0.0);\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n  vec2 np = p + 2.0/RESOLUTION.y;\n  float rdd = (2.-0.5*tanh_approx(lp));  // Playing around with rdd can give interesting distortions\n//  float rdd = 2.;\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(np.x*uu + np.y*vv + rdd*ww);\n\n  const int furthest = 5;\n  const int fadeFrom = max(furthest-2, 0);\n\n  const float fadeDist = planeDist*float(furthest - fadeFrom);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);\n\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.95;\n  bool cutOut = false;\n\n  float maxpd = 0.0;\n\n  // Steps from nearest to furthest plane and accumulates the color \n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 pp = ro + rd*pd;\n      maxpd = pd;\n      vec3 npp = ro + nrd*pd;\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, npp, off, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(planeDist*float(furthest), planeDist*float(fadeFrom), nz);\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n//      pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);\n      pcol.w *= fadeOut*fadeIn;\n      pcol = clamp(pcol, 0.0, 1.0);\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm  = planeDist*TIME*BPM/60.0;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = cross(ww, uu);\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// License CC0: Hex Marching\n#define RESOLUTION  iResolution\n#define TIME        iTime\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 brot = ROT(2.399);\n//  simplyfied version of Dave Hoskins blur\nvec3 dblur(vec2 q,float rad) {\n  vec3 acc=vec3(0);\n  const float m = 0.002;\n  vec2 pixel=vec2(m*RESOLUTION.y/RESOLUTION.x,m);\n  vec2 angle=vec2(0,rad);\n  rad=1.;\n  const int iter = 30;\n  for (int j=0; j<iter; ++j) {  \n    rad += 1./rad;\n    angle*=brot;\n    vec4 col=texture(iChannel1,q+pixel*(rad-1.)*angle);\n    acc+=col.xyz;\n  }\n  return acc*(1.0/float(iter));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0+2.0*q;\n  vec4 pcol = texture(iChannel0,q);\n  vec3 bcol = dblur(q, .75);\n  \n  vec3 col = pcol.xyz;\n  col += vec3(0.9, .8, 1.2)*mix(0.5, 0.66, length(p))*(0.05+bcol);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKyDw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[94, 94, 149, 149, 365]]}
{"id": "fdGcDm", "name": "concentric circles without 'e'", "author": "FabriceNeyret2", "description": "variant of https://www.shadertoy.com/view/NdKcWD\nwithout using the letter 'e'\n- but for the mainImage() API ( no choice )\n- and the uniform iResolution ( or we couln't be resolution independant )\n", "tags": ["2d", "illusion", "fake3d", "2tweets", "perception", "short", "golf", "reproduction", "lipogrammatic"], "likes": 15, "viewed": 699, "published": 3, "date": "1654936679", "time_retrieved": "2024-07-30T16:44:47.107204", "image_code": "// Variant of https://www.shadertoy.com/view/NdKcWD\n// without using the letter 'e'\n// - but for the mainImage() API ( no choice )\n// - and the uniform iResolution ( or we couln't be resolution independant )\n// - Maybe we should allow iTime too. e.g. put these 3 as #defined in Common.\n// - really forbid #define ?\n//   ( would permit #def V(x,y) mat2(x,y,0,0)[0]  to emulate vec2\n//                  #def L(v)   sqrt(dot(v,v))    for length\n//   ) \n//   somehow we need either return or define or code will really be long.\n\nfloat L(mat2 v) { return sqrt(dot(v[0],v[0])); }\n\nvoid mainImage( out vec4 O, vec2 u ) { mat2 R = mat2(iResolution,1); // 'e' only in this line\n\n    O += 1.-O;\n    for (float i=0.; ++i < 6.; )\n        O = min(O, abs( L(mat2(  ( u+u - R[0] ) / R[0][1]\n                               + (.5-i/20.)*cos(mat2(4,37,0,0)[0])\n                              ,0,0)) -i/20.\n                      ) *R[0][1]/2. ),\n        O = min(O, abs( L(mat2(  ( u+u - R[0] ) / R[0][1]\n                               + (.25+i/20.)*cos(mat2(4,37,0,0)[0])\n                              ,0,0)) -.25-i/20.\n                      ) *R[0][1]/2. );\n  \n    for (float i=0.; ++i < 11.; )\n        O = min(O, abs( L(mat2(  ( u+u - R[0] ) / R[0][1]\n                               + (.5-i/20.)*cos(mat2(4,37,0,0)[0])\n                              ,0,0)) -.5-i/20.\n                      ) *R[0][1]/2. );\n   \n    O = sqrt(O);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGcDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[525, 525, 542, 542, 573], [575, 575, 613, 613, 1409]]}
{"id": "NllBWj", "name": "Radial repeat", "author": "El_Sargo", "description": "Radial repaet", "tags": ["2d", "sdf"], "likes": 6, "viewed": 305, "published": 3, "date": "1654927414", "time_retrieved": "2024-07-30T16:44:47.858196", "image_code": "#define w float \n#define v iResolution\nw x(vec2 p,w d,w r)\n{p = abs(p);return length(p-min(p.x+p.y,d)*0.5) - r;}\nmat2 r(w a){w s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\nvec3 s(w a,w b,vec3 k){return-log(exp(-k*a)+exp(-k*b))/k;}\nconst w z=5.,q=3.14,j=q*2.;void mainImage(out vec4 o,vec2 m){\nvec2 uv = m/v.xy,l=vec2(0,-.2),p=(uv-0.5)*vec2(1.,v.y/v.x)*.9,\nu=p*r(-4.*iTime);p*=r(iTime*1.1);p = mod(p+.3, .6)-.3;\nw k=.02,a=atan(p.x,p.y),f=length(u-l)-0.01,\nb=(a+q)/j-fract(a*z/q/2.)/z,d=abs(x(p*r(b*j+q/z)-l,0.05,0.)-k);\no=vec4(smoothstep(0.005,.01,s(d,f,vec3(10,7,8)*2.)),1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 60, 60, 112], [113, 113, 125, 125, 168], [169, 169, 192, 192, 227], [255, 255, 289, 289, 572]]}
{"id": "7dKyWD", "name": "Menger Sponge Construction", "author": "Ptyonic", "description": "Menger Sponge Construction by Animated Mirror Planes", "tags": ["raymarching"], "likes": 7, "viewed": 279, "published": 3, "date": "1654912029", "time_retrieved": "2024-07-30T16:44:48.597220", "image_code": "struct RayHit {\n    bool hit;\n    vec3 pos;\n    int id;\n};\n\nstruct ObjectDistance {\n    float dist;\n    int id;\n};\n\nconst float pseudoInfty = 3.4e38;\nconst int boxId = 0;\n\n// Coordinate Transformations\nvec3 mengerSponge(vec3 p, int iterations, int step, float t) {\n\tif (iterations == 0) {\n\t\treturn p;\n\t}\n\tfloat mirrorPlaneDistance = 3.5;\n\tmirrorPlaneDistance *= 2.0;\n\tp = p * 0.5 + 0.5;\n\tif (step >= 6) {\n\t\tif (p.y > mix(mirrorPlaneDistance + 0.5, 0.5, t)) {\n\t\t\tp.y = mix(2.0 * mirrorPlaneDistance + 1.0, 1.0, t) - p.y;\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 5) {\n\t\tif (p.x > mix(mirrorPlaneDistance + 0.5, 0.5, t)) {\n\t\t\tp.x = mix(2.0 * mirrorPlaneDistance + 1.0, 1.0, t) - p.x;\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 4) {\n\t\tif (p.z > mix(mirrorPlaneDistance + 0.5, 0.5, t)) {\n\t\t\tp.z = mix(2.0 * mirrorPlaneDistance + 1.0, 1.0, t) - p.z;\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 3) {\n\t\tif (p.x - mix(mirrorPlaneDistance, 0.0, t) > p.z) {\n\t\t\tp.xz = vec2(p.z + mix(mirrorPlaneDistance, 0.0, t), p.x - mix(mirrorPlaneDistance, 0.0, t));\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 2) {\n\t\tif (p.y - mix(mirrorPlaneDistance, 0.0, t) > p.z) {\n\t\t\tp.yz = vec2(p.z + mix(mirrorPlaneDistance, 0.0, t), p.y - mix(mirrorPlaneDistance, 0.0, t));\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 1) {\n\t\tif (p.z > (mix(mirrorPlaneDistance + 1.0, 1.0, t) / 3.0)) {\n\t\t\tp.z = (mix(2.0 * mirrorPlaneDistance + 2.0, 2.0, t) / 3.0) - p.z;\n\t\t}\n\t\tt = 1.0;\n\t}\n\tif (step >= 0) {\n\t\tp *= mix(1.0, 3.0, t);\n\t\tt = 1.0;\n\t}\n\tfor (int i = 0; i < iterations - 1; i++) {\n\t\tif (p.y > 0.5) {\n\t\t\tp.y = 1.0 - p.y;\n\t\t}\n\t\tif (p.x > 0.5) {\n\t\t\tp.x = 1.0 - p.x;\n\t\t}\n\t\tif (p.z > 0.5) {\n\t\t\tp.z = 1.0 - p.z;\n\t\t}\n\t\tif (p.x  > p.z) {\n\t\t\tp.xz = vec2(p.z, p.x);\n\t\t}\n\t\tif (p.y > p.z) {\n\t\t\tp.yz = vec2(p.z, p.y);\n\t\t}\n\t\tif (p.z > (1.0 / 3.0)) {\n\t\t\tp.z = (2.0 / 3.0) - p.z;\n\t\t}\n\t\tp *= 3.0;\n\t}\n\tp = p * 2.0 - 1.0;\n\treturn p;\n}\n\nfloat scaleFactor(int iterations, int step, float t) {\n\tif (step == 0) {\n\t\treturn pow(3.0, float(iterations - 1)) * mix(1.0, 3.0, t);\n\t}\n\treturn pow(3.0, float(iterations));\n}\n\nfloat gain(float x, float k) {\n\tfloat a = 0.5 * pow(2.0 * ((x < 0.5) ? x : 1.0 - x), k);\n\treturn (x < 0.5) ? a : 1.0 - a;\n}\n\nvec2 gain(vec2 v, float k) {\n\treturn vec2(gain(v.x, k), gain(v.y, k));\n}\n\nfloat sdBox(vec3 pos, vec3 b) {\n\tvec3 posCorner = abs(pos) - b;\n\treturn length(max(posCorner, 0.0)) + min(max(posCorner.x, max(posCorner.y, posCorner.z)), 0.0);\n}\n\n\nObjectDistance sceneDistance(vec3 pos) {\n\tint MAX_ITERATIONS = 7;\n    float time = iTime * 0.9;\n\tint iterations = int(time) / 8 + 1;\n\tint step = int(time) % 8;\n\tfloat k = 8.0;\n\tfloat t = gain(fract(time) * 0.5 + 0.5, k);\n    \n    if (iterations > MAX_ITERATIONS && fract(time) < 0.5 && int(time) % 8 == 0) {\n        iterations = MAX_ITERATIONS + 1;\n    } else {\n        iterations = min(iterations, MAX_ITERATIONS);\n    }\n    \n\tif (step == 0) {\n\t\tt = gain(fract(time), k);\n\t}\n\tif (step == 7) {\n\t\tt = 1.0;\n\t}\n    \n\tfloat d = sdBox(mengerSponge(pos, iterations, step, t), vec3(1.0)) / scaleFactor(iterations, step, t);\n    return ObjectDistance(d, boxId);\n}\n\nRayHit rayMarch(vec3 rayOrigin, vec3 rayDirection) {\n    int maxIterations = 512;\n    float maxT = 25.0;\n    float epsilon = 1.0e-5;\n    \n    float t = 0.0;\n    vec3 pos;\n    ObjectDistance objDist;\n    for (int i = 0; i <= maxIterations; i++) {\n        pos = rayOrigin + t * rayDirection;\n        objDist = sceneDistance(pos);\n        t += objDist.dist / 4.0;\n        if (objDist.dist < epsilon) {\n            return RayHit(true, pos, objDist.id);\n        }\n        if (t > maxT) {\n            return RayHit(false, pos, objDist.id);\n        }\n    }\n    return RayHit(false, pos, objDist.id);\n}\n\nvec3 calculateNormal(vec3 pos) {\n    vec2 epsilon = vec2(1.0e-5, 0.0);\n    vec3 normal = vec3(0.0);\n    normal.x = sceneDistance(pos + epsilon.xyy).dist - sceneDistance(pos - epsilon.xyy).dist;\n    normal.y = sceneDistance(pos + epsilon.yxy).dist - sceneDistance(pos - epsilon.yxy).dist;\n    normal.z = sceneDistance(pos + epsilon.yyx).dist - sceneDistance(pos - epsilon.yyx).dist;\n    return normalize(normal);\n}\n\nvec3 triplanarMap(sampler2D sampler, vec3 n, float k) {\n    vec3 w = pow(abs(n), vec3(k));\n    vec3 tex = (w.x * texture(sampler, 3.0 * (normalize(n).yz * 0.5 + 0.5)) + \n                w.y * texture(sampler, 3.0 * (normalize(n).zx * 0.5 + 0.5)) + \n                w.z * texture(sampler, 3.0 * (normalize(n).xy * 0.5 + 0.5))).rgb;\n    tex /= w.x + w.y + w.z;\n    return tex;\n}\n\nvec4 render(vec2 fragCoord) {\n    vec4 fragColor;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 screenPos = (fragCoord.xy - iResolution.xy / 2.0) / max(iResolution.y, iResolution.x) * 2.0;\n    \n\tfloat animate = 0.1 * iTime;\n\tvec3 cameraPosition = vec3(2.0 * sin(animate), 2.1, 3.0 * cos(animate));\n    // vec3 cameraPosition = vec3(1.0, 3.0, 3.0);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    float fov = radians(100.0);\n    \n    vec3 rayOrigin = cameraPosition;\n    vec3 cameraDirection = normalize(cameraTarget - cameraPosition);\n    vec3 screenHorizontal = normalize(vec3(-cameraDirection.z, 0.0, cameraDirection.x));\n    vec3 screenVertical = normalize(cross(screenHorizontal, cameraDirection));\n    vec3 rayDirection = normalize(tan(fov / 2.0) * screenPos.x * screenHorizontal + tan(fov / 2.0) * screenPos.y * screenVertical + cameraDirection);\n    \n    vec3 albedo = vec3(1.0);\n    vec3 lightDirection = normalize(vec3(2.0, 3.0, 1.0));\n    \n    RayHit rayHit = rayMarch(rayOrigin, rayDirection);\n    if (!rayHit.hit) {\n        // Background\n        return vec4(pow(triplanarMap(iChannel0, rayDirection, 8.0) * 0.4, vec3(2.0)), 1.0);\n    }\n    \n    vec3 normal = calculateNormal(rayHit.pos);\n    if (rayHit.id == boxId) {\n        albedo = vec3(0.7, 0.2, 1.0) * 1.4;\n    }\n    vec3 color;\n    rayHit = rayMarch(rayHit.pos + 0.0001 * normal, lightDirection);\n    if (rayHit.hit) {\n        // Shadow\n        color = dot(normal, lightDirection) * albedo * albedo * 0.1;\n    } else {\n        // Light\n        color = clamp(dot(normal, lightDirection), 0.0, 1.0) * albedo;\n    }\n    \n    color = clamp(color, 0.0, 1.0);\n    // Output to screen\n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    \n    // Set higher if your computer allows:\n    int MULTISAMPLE = 1;\n    // Samples MULTISAMPLE x MULTISAMPLE so 4 is plenty\n    \n    for (int x = 0; x < MULTISAMPLE; x++) {\n        for (int y = 0; y < MULTISAMPLE; y++) {\n            fragColor += render(fragCoord + (vec2(x, y) / float(MULTISAMPLE)) - 0.5) / (float(MULTISAMPLE) * float(MULTISAMPLE));\n        }\n    }\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 202, 264, 264, 1814], [1816, 1816, 1870, 1870, 1991], [1993, 1993, 2023, 2023, 2116], [2118, 2118, 2146, 2146, 2190], [2192, 2192, 2223, 2223, 2354], [2357, 2357, 2397, 2397, 3012], [3014, 3014, 3066, 3066, 3608], [3610, 3610, 3642, 3642, 4023], [4025, 4025, 4080, 4080, 4401], [4403, 4403, 4432, 4432, 6094]]}
{"id": "7sKcDR", "name": "The Tensor", "author": "nonsense", "description": "Inspired by a certain famous movie", "tags": ["text"], "likes": 8, "viewed": 340, "published": 3, "date": "1654898279", "time_retrieved": "2024-07-30T16:44:49.422015", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor += 0.05* texture(iChannel0, uv + vec2( 0.000, -0.012));\n    fragColor += 0.1 * texture(iChannel0, uv + vec2( 0.000, -0.008));\n    fragColor += 0.3 * texture(iChannel0, uv + vec2( 0.000, -0.004));\n    fragColor += 0.8 * texture(iChannel0, uv + vec2( 0.000,  0.000));\n    \n    fragColor += 0.3 * texture(iChannel0, uv + vec2(-0.003,  0.000));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// CC BY-NC-SA 3.0 Unported nonsense @ ShaderToy\n\nvec3 rand(vec2 co)\n{\n    return texture(iChannel1, 2.313122*co).rgb;\n}\n\nvec3 rand16(vec2 co)\n{\n    return (1./16.)*round(16.*rand(co));\n}\n\nvec3 getchar(vec2 block, float t)\n{\n    return rand16(block + 0.00005*vec2(t, 0.));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.y *= iResolution.y / iResolution.x;\n    \n    uv *= 3.;\n    \n    \n    float xblock = (1./16.)*floor(uv.x*16.);\n    \n    uv.y += 0.14*iTime*(rand(vec2(xblock,0.)).x+0.001);\n    \n    \n    vec2 block = vec2(xblock, (1./16.)*floor(uv.y*16.));\n    \n    vec3 char = getchar(block, iTime);\n    vec3 old  = getchar(block, iTime - 0.18);\n    \n    vec2 charuv = uv - block;\n    \n    float col = char.b*round(texture(iChannel0, charuv + char.rg).r);\n    \n    if (char == old)\n        col *= 0.7;\n    \n    fragColor = vec4(0.,col,0.,1.);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKcDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 455]]}
{"id": "ssKyDW", "name": "Mosaic flower tiles", "author": "jarble", "description": "Another interesting series of mosaic patterns.", "tags": ["fractal", "flower", "mosaic"], "likes": 5, "viewed": 233, "published": 3, "date": "1654893501", "time_retrieved": "2024-07-30T16:44:52.300319", "image_code": "#define animate\n\n#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    float t4 = floor((iTime/8.+uv.x));\n\n    for(int i=0;i<2;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 4; k++){\n        \n            uv += (t2.yx)/scale;\n            t2 = triangle_wave(uv.yx-.5,scale);\n            //t2.y -= float(i)/8.;\n            #ifdef animate\n            float num = 3.+float(k+i);\n            t2 += t4/num;\n            #endif\n            t3 = triangle_wave(uv,scale);\n            //t3 -= float(k)/3.;\n            uv.yx = (t2-t3)/(scale);\n            col.x = min(((uv.y-uv.x)+col.x),col.x)/sqrt(3.);\n            col = (col.yzx+vec3(col.x))/sqrt(3.);\n        }\n        \n    }\n    fragColor = vec4(-vec3(col*3.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 85, 85, 130], [132, 132, 189, 189, 1122]]}
{"id": "sdKyDW", "name": "Fractal lace pattern", "author": "jarble", "description": "A lace-like fractal pattern.", "tags": ["fractal", "lace"], "likes": 4, "viewed": 252, "published": 3, "date": "1654892248", "time_retrieved": "2024-07-30T16:44:53.135087", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.*8.*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<3;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 6; k++){\n            uv += 1.+(t2.yx)/scale;\n            t2 = triangle_wave(uv.yx-.5,scale);\n            t3 = triangle_wave(uv,scale);\n            uv.yx = (t2-t3)/(scale);\n            col.x = min(((uv.y+uv.x)+col.x),col.x)/sqrt(3.);\n            col = (col+vec3(col.x))/sqrt(3.);\n        }\n        \n    }\n    fragColor = vec4(-vec3(col*3.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 885]]}
{"id": "NdKcWD", "name": "concentric circles (233 chars)", "author": "FabriceNeyret2", "description": "reproducing https://twitter.com/gsarcone/status/1535030655817601039\n", "tags": ["2d", "illusion", "fake3d", "2tweets", "perception", "short", "golf", "reproduction"], "likes": 22, "viewed": 401, "published": 3, "date": "1654881421", "time_retrieved": "2024-07-30T16:44:53.930959", "image_code": "// vec2 p;   // --- Shane octogon variant\n// #define length(q) ( p = abs(q), max(max(p.x, p.y), (p.x + p.y)*.7) )\n\n\n\n#define C(I,J,n)                                                  \\\n    for (float i=0.; ++i < n; )                                   \\\n        O = min(O, abs( length(  ( u+u - R ) / R.y                \\\n                               + (.5-I/20.)*cos(iTime+vec2(0,33)) \\\n                              ) -J/20.                            \\\n                      ) *R.y/2. );\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    O = 1.-O*0.;                // O += 1.-O; no longer work on some machines\n    C(    i,     i , 6.)\n    C(.25+i, .25-i , 6.)\n    C(    i, .5 -i ,11.)\n    O = sqrt(O);\n}\n\n\n\n\n\n\n/**\n\n// --- 239 chars\n\n#define C(i,j) O = min(O, abs( length(  ( u+u - R ) / R.y                \\\n                                      + (.5-i/20.)*cos(iTime+vec2(0,33)) \\\n                                     ) -j/20.                            \\\n                             ) *R.y/2. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    O += 1.-O;\n    for (float i=0.; ++i < 6.; )\n         C(    i,     i ),\n         C(.25+i, .25-i ),\n         C(    i, .5 -i ),\n         C(.25-i, .75-i );\n        \n    O = sqrt(O);\n}\n\n/**/\n\n\n\n\n\n\n/* // --- 247 chars\n\n#define C(i,j) O = min(O, abs( length(U+(.5-i/20.)*D) -j/20. ) *R.y/2. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y,\n         D = cos(iTime+vec2(0,33));\n\n    O += 1.-O;\n    for (float i=0.; ++i < 6.; )\n         C(    i,     i ),\n         C(.25+i, .25-i ),\n         C(    i, .5 -i ),\n         C(.25-i, .75-i );\n        \n    O = sqrt(O);\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKcWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "ssyyDD", "name": "Cursed Wazowski (Secret Brother)", "author": "tsutsen", "description": "Secret brother of Mike Wazowski which can be found here: https://www.shadertoy.com/view/MsXGWr", "tags": ["3d", "raymarching", "distancefield", "audio", "cursed", "wazowski", "stolenmercilessly"], "likes": 2, "viewed": 342, "published": 3, "date": "1654867288", "time_retrieved": "2024-07-30T16:44:54.849503", "image_code": "// Copyright Inigo Quilez, 2013 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n\n// Made with love after a famous movie character. Modeling is pretty\n// arbitrary and was done by visual inspiration from the first picture\n// you get in google images when you type \"mike wazowski\".\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*50.50);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.9000*noise( p ); p = m2*p*1.0;\n    f += 0.500*noise( p ); p = m2*p*2.03;\n    f += 0.250*noise( p ); p = m2*p*2.01;\n    f += 0.5*noise( p );\n\n    return f/0.1;\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//----------------------------------------------------------------\n// https://iquilezles.org/articles/distfunctions\nvec2 sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length(p/r) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n#define ZERO (min(iFrame,0))\n\n//----------------------------------------------------------------\n\nvec2 map( vec3 p )\n{\n\tp.y -= 1.8;\n\tp.x = abs(p.x)-0.2;\n\n\tvec3 q = p*(0.6);\n\tq.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);\n\tq.y *= 1.05;\n\tq.z *= 1.0 + 0.1*smoothstep( 0.0, 0.9, q.z )*smoothstep( -0.5, 0.5, p.y );\n    float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );\n\tfloat am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );\n\tfloat fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;\n    float dd2 = length( (p - vec3(0.0,0.1,0.8))*vec3(1.0,0.25,1.0) );\n\tfloat am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );\n\tfloat fo2 = -0.085*(1.0-smoothstep( 0.0, 0.8*am2, abs(dd2-0.42) ))*am2;\n    q.y += -0.05+0.05*length(q.x);\n\t\n\tfloat d1 = length( q ) - 0.6 + fo + fo2;\n    vec2 res = vec2( d1, 0.5 );\n\n\t// arms\n\t//vec2 h = sdSegment( p, vec3(1,-0.12,0.3), vec3(1.4,-0.9,-0.1) );\n\t//float d2 = h.x - 0.2;\n\t//res.x = smin( res.x, d2, 0.1 );\n\t//h = sdSegment( p, vec3(0.1,1,-.1), vec3(0.9,-1.2,0.1) );\n\t//d2 = h.x - 0.1 + h.y*0.1;\n\t//res.x = smin( res.x, d2, 0.5 );\n    \n    // arms\n\tvec2 h = sdSegment( p, vec3(1,0.11,0.3), vec3(1.5,-0.8,-.1) );\n\tfloat d2 = h.x - 0.07;\n\tres.x = smin( res.x, d2, 0.1 );\n\th = sdSegment( p, vec3(1.5,-0.6,-.1), vec3(0.95,-1.2,0.1) );\n\td2 = h.x - 0.07 + h.y*0.02;\n\tres.x = smin( res.x, d2, 0.5 );\n\t\n\t// hands\n\tif( p.y<-1.0 )\n\t{\n    float fa = sin(3.0*iTime);\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(0.97,-1.5,0.0) );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.01 );\n\th = sdSegment( p, vec3(0.97,-1.5,0.0), vec3(0.95,-1.7,0.0)-0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(1.05,-1.5,0.1) );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( p, vec3(1.05,-1.5,0.1), vec3(1.0,-1.75,0.1)-0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(0.98,-1.5,0.2) );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( p, vec3(0.98,-1.5,0.2), vec3(0.95,-1.7,0.15)-0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(0.85,-1.4,0.2) );\n\td2 = h.x - 0.04 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.05 );\n\th = sdSegment( p, vec3(0.85,-1.4,0.2), vec3(0.85,-1.63,0.15)+0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\t}\n\t\n\t// legs\n\tif( p.y<0.0 )\n\t{\n\th = sdSegment( p, vec3(0.5,-0.1,0.0), vec3(0.6,-1.2,0.1) );\n\td2 = h.x - 0.14 + h.y*0.08;\n\tres.x = smin( res.x, d2, 0.1 );\n\th = sdSegment( p, vec3(0.6,-1.2,0.1), vec3(0.5,-1.8,0.0) );\n\td2 = h.x - 0.06;\n\tres.x = smin( res.x, d2, 0.51 );\n\t}\n\n    // feet\n\tif( p.y<-0.5 )\n\t{\n\th = sdSegment( p, vec3(0.5,-1.8,0.0), vec3(0.6,-1.8,0.4) );\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\th = sdSegment( p, vec3(0.5,-1.8,0.0), vec3(0.77,-1.8,0.35) );\n\td2 = h.x - 0.1 + 0.1*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\th = sdSegment( p, vec3(0.5,-1.8,0.0), vec3(0.9,-1.8,0.2) );\n\td2 = h.x - 0.07 + 0.02*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\t}\n\t\n\t// horns\n\tvec3 hp = p - vec3(1,0.8,0.0);\n    hp.xy = mat2(0.6,0.8,-0.8,0.6)*hp.xy;\n    hp.x += 0.8*hp.y*hp.y;\n    float d4 = sdEllipsoid( hp, vec3(0.13,0.5,0.16) );\n\tif( d4<res.x ) res = vec2( d4, 3.0 );\n    \n\t// eyes\n\tfloat d3 = length( (p - vec3(0.0,0.5,0.8))*vec3(1.0,0.8,1.0) ) - 0.5;\n\tif( d3<res.x ) res = vec2( d3, 2.0 );\n    \n    //float d03 = length( (p - vec3(0.0,0.1,0.5))*vec3(1.0,0.8,1.0) ) - 0.5;\n\t//if( d03<res.x ) res = vec2( d03, 2.0 );\n\n\t// mouth\n\tfloat mo = length( (q-vec3(0.0,-0.5,1.4))*vec3(1.0,0.9,-0.01)/1.2 ) -0.3/1.2;\n\tfloat of = 0.1*pow(smoothstep( 0.0, 0.8, abs(p.x-0.3) ),0.5);\n\tmo = max( mo, -q.y-0.35-of );\n\n\tfloat li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );\n\tres.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );\n\t\n\tif( -mo > res.x )\n\t\tres = vec2( -mo, 4.0 );\n\n    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));\n\n    // teeth\t\n    if( p.x<0.3 )\n\t{\n    p.x = mod( p.x, 0.16 )-0.08;\t\n    float d5 = length( (p-vec3(0.0,-0.45,0.65))*vec3(1.5,0.7,1.5))-0.07;\n\tif( d5<res.x )\n\t\tres = vec2( d5, 4.0 );\n\t}\n    \n    if( p.x<0.3 )\n\t{\n    p.x = mod( p.x, 0.16 )-0.08;\t\n    float d5 = length( (p-vec3(0.0,-0.23,0.79))*vec3(1.5,0.75,1.5))-0.08;\n\tif( d5<res.x )\n\t\tres = vec2( d5, 4.0 );\n\t}\n\t\n\treturn vec2(res.x*0.8,res.y);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.002*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 10.0;\n\n    // floor\t\n\tfloat tf = (0.0-ro.y)/rd.y;\n\tif( tf>0.0 ) { mint = tf; m = 0.0; }\n\t\n\t// mike\n\tfloat maxd = min(5.0,mint);\n\tfloat precis = 0.001;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=ZERO; i<128; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        float h = res.x;\n\t\td = res.y;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 0.2;\n    float t = mint;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nconst vec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = sin(-0.25 + 0.31416*iTime);\n\tvec3 ro = vec3(3.5*sin(an),1.8,3.5*cos(an));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = vec3(1.0);\n\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(1.0,1.0);\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tnor = vec3(0.0,1.0,0.0);\n\t\t    ref = reflect( rd, nor );\n\t\t\tmate.xyz = vec3(1.0);\n            mate2.y = 1.0 - 0.9*(2.0/(2.0+dot(pos.xz,pos.xz)));\n\t\t}\n\t\telse if( tmat.z<1.5 )\n\t\t{\n            mate2.x = 4.0;\n\t\t\tmate = vec4(1.0,0.0,0.0,0.9);\n\n            float f = texturize( iChannel0, 0.5*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.56*mate.xyz, vec3(0.21,0.28,0.0), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.5,0.28,0.0), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t}\n\t\telse if( tmat.z<2.5 )\n\t\t{\n\t\t\tvec3 q = pos-vec3(0.0,1.8,0.0) - vec3(0.0,0.44,0.35);\n\n\t\t\tfloat an2 = an + 0.015*(-1.0+2.0*noise( 6.0*iTime ));\n            vec3 oq = q;\t\t\t\n\t\t\tq.x += -2.0*0.2*clamp(sin(an2),-0.42,0.42);\n            \n            \n            //q.x = fract(sin(q.x)*1.0);\n\t\t\tfloat f = length( q.xy );\n\t\t\t\n\t\t\tmate2.y = 1.0-smoothstep(0.24,0.35,length( oq.xy-vec2(0.0,0.035) ));\n\t\t\tmate = vec4(0.5,0.5,0.5,1.0);\n\t\t\tmate.xyz = mix( mate.xyz, vec3(0.6,0.4,0.3), 0.5*smoothstep(0.1,0.4,f) );\n\t\t\t\n            vec3 c1 = vec3(0.0,0.15,0.05)*(1.0-0.85*f/0.19);\n\t\t\tfloat a = atan(q.y,-q.x);\n            float te = fbm( 50.0*vec2(0.9*a,1.2*f) );\n\t\t\tc1 *= 0.3 + 5.0*te;\n            \n            c1 += vec3(0.9,1.0,0.1)*0.35*(0.1+te)*\n                (1.0-smoothstep( 0.3,1.2,abs(a+0.5)))*\n                (1.0-smoothstep( 0.0, 0.06, abs(f-0.125) ));\n            \n\t\t\tmate.xyz = mix( mate.xyz, c1, 1.0-smoothstep( 0.50, -0.1, f ) );\n\n\t\t\toq.x += -2.0*0.19*clamp(sin(an2),-0.42,0.42);\n\t\t\tf = length( oq.xy );\n\t\t\tmate.xyz *= smoothstep( 0.02, 0.15, f );\n            mate.xyz *= 1.2-0.2*vec3(0.5,0.9,1.0)*smoothstep( 0.2, 0.4, f );\n            \n\t\t\tmate.w = 2.0;\n            mate2.x = 64.0;\n\t\t}\n\t\telse if( tmat.z<3.5 )\n\t\t{\n\t\t\tmate = 0.8*vec4(0.85,0.7,0.1,0.0);\n            mate2.x = 0.0;\n\t\t\tfloat f = smoothstep( 0.0, 0.1, 0.5*abs(pos.x)+pos.y-3.02 );\n\t\t\tmate.xyz *= 1.0 - 0.8*vec3( f );\n\t\t\tmate.xyz *= 0.2 + 0.8*smoothstep( 0.0, 1.0, texturize( iChannel0, 0.1*2.1*pos*vec3(4.0,0.1,4.0), nor ).x );\n\t\t}\n\t\telse if( tmat.z<4.5 )\n\t\t{\n\t\t\tfloat z = smoothstep( 0.0, 2.0, pos.z+0.5 );\n\t\t\tmate = 0.5*vec4(0.5,0.25,0.1,0.0);\n\t\t\tmate.x += 0.1*(1.0-z);\n\t\t\tmate2.y = z;\n\t\t}\n\n\t\t// lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.5;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.001, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        vec3  hal = normalize(lig-rd);\n        float spe = max(pow( clamp( dot(nor,hal), 0.0, 1.0), mate2.x*4.0 ),0.0 );\n\t\t\n\t\t// lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\t\tcol = mate.xyz*lin;\n\t\tcol += 4.0*spe*vec3(2.0)*mate.w*dif*sha*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t// vigneting\n\tvec2 q = fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.5 );\n\t   \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "sound_code": "// Trying to sync by using AND's code from\n// https://www.shadertoy.com/view/4sSSWz\n#define WARMUP_TIME     (2.0)\n\nconst float loopSpeed   = .1;\nconst float loopTime    = 5.;\nconst float impactTime  = 1.;\nconst float impactFade  = .3;\nconst float fadeOutTime = .1;\nconst float fadeInTime  = .1;\nconst float whiteTime   = .3; // fade to white\n    \n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\n/*\n\t\n\tFrom https://www.shadertoy.com/view/MdfXWX\n\n*/\n\nfloat n2f(float note)\n{\n   return 55.0*pow(2.0,(note-3.0)/12.); \n}\n\nvec2 bass(float time, float tt, float note)\n{\n    if (tt<0.0)\n      return vec2(0.0);\n\n    float freqTime = 6.2831*time*n2f(note);\n    \n    return vec2(( sin(     freqTime\n                      +sin(freqTime)*7.0*exp(-2.0*tt)\n                     )+\n                  sin(     freqTime*2.0\n                      +cos(freqTime*2.0)*1.0*sin(time*3.14)\n                      +sin(freqTime*8.0)*0.25*sin(1.0+time*3.14)\n                    )*exp(-2.0*tt)+\n                  cos(     freqTime*4.0\n                      +cos(freqTime*2.0)*3.0*sin(time*3.14+0.3)\n                    )*exp(-2.0*tt)\n                )\n                \n                *exp(-1.0*tt) );\n}\n\n\n/*\n\t\n\tFrom https://www.shadertoy.com/view/4ts3z2\n\n*/\n\n//Audio by Dave_Hoskins\n\nvec2 add = vec2(1.0, 0.0);\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in ...\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\t//p  = fract(p * MOD3);\n    vec3 p3 = fract(vec3(p) * MOD3);\n    p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec2(p3.x * p3.y, p3.z*p3.x))-.5;\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 Noise21(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return  mix( hash21(p), hash21(p + 1.0), f)-.5;\n    \n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nfloat Noise11(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash11(p), hash11(p + 1.0), f)-.5;\n\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 2 in...\nvec2 Noise22(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( hash22(p),          hash22(p + add.xy),f.x),\n                    mix( hash22(p + add.yx), hash22(p + add.xx),f.x),f.y);\n    return res-.5;\n}\n\n//----------------------------------------------------------------------------------------\n// Fractal Brownian Motion...\nvec2 FBM21(float v)\n{\n    vec2 r = vec2(0.0);\n    vec2 x = vec2(v, v*1.3+23.333);\n    float a = .6;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += Noise22(x * a) / a;\n        a += a;\n    }\n     \n    return r;\n}\n\n//----------------------------------------------------------------------------------------\n// Fractal Brownian Motion...\nvec2 FBM22(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    \n    float a = .6;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += Noise22(x * a) / a;\n        a += a;\n    }\n     \n    return r;\n}\n\n\n/*\n\n\tFROM @LukeXI\n\n*/\n\n#define PI              (3.1415)\n#define TWOPI           (6.2832)\n\n\nfloat square(float time, float freq) {\n    \n    return sin(time * TWOPI * freq) > 0.0 ? 1.0 : -1.0;\n}\n\nfloat sine(float time, float freq) {\n    \n    return sin(time * TWOPI * freq);\n}\n\nvec2 sineLoop(float time, float freq, float rhythm) {\n    vec2 sig =vec2( 0.);\n    float loop = fract(time * rhythm);\n    \n    float modFreq = freq + (sine(time, 7.0));\n    \n    sig += vec2( sine(time, freq) * exp(-3.0*loop) );\n  //  sig += vec2( square(time, freq/2.0) * exp(-3.0*loop) ) *0.2;\n    \n    float panfreq = rhythm * 0.3;\n    float panSin = sine(time, panfreq);\n    float pan = (panSin + 1.0) / 2.0;\n    sig.x *= pan;\n    sig.y *= (1.0 - pan);\n    \n    return sig;\n}\n\nvec2 chimeTrack(float time) {\n    vec2 sig = vec2( 0. );\n    sig += sineLoop(time, 1730.0, 0.44) * 0.2;\n    sig += sineLoop(time, 880.0, 1.0);\n    sig += sineLoop(time, 990.0, 0.3) * 0.4;\n    sig += sineLoop(time, 330.0, 0.4);\n    sig += sineLoop(time, 110.0, 0.1);\n    sig += sineLoop(time, 60.0, 0.05);\n    \n    sig /= 6.0;\n    \n    return sig;\n}\n\n\n// Choreography:\n\n// total peace \n// When comet arrives, start ominous music\n// ominous music builds\n// when fade to white, ominouse\n\n\nfloat tone( float freq , float time  ){\n    \n    return sin(6.2831* freq *time);\n    \n}\n\nfloat chord( float base , float time ){\n    \n\n    float f = 0.;\n    \n    f += tone( base , time )           * (1. + .1 * sin( time * 5.2 )) ;\n    f += tone( base , time * 1.26  ) * .6 * (1. + .3 * sin( time * 10.02)) ;\n    f += tone( base , time * 1.498 ) * .4 * (1. + .3 * sin( time * 23.4)) ;\n    f += tone( base , time * 2.* 1.498 ) * .2 * (1. + .3* sin( time * 43.4)) ;\n    f += tone( base , time * 2.* 1.26 ) * .2 * (1. + .3* sin( time * 10.4)) ;\n    //f += tone( base , time * 4. ) * .3 * (1. + .1 * sin( time * .1)) ;\n    //f += tone( base , time * 5. ) * .2 * (1. + .1 * sin( time * .04)) ;\n    //f += tone( base , time * 6. ) * .1 * (1. + .1 * sin( time * .08)) ;\n    \n    return f / 2.;\n    \n}\n\nvec2 mainSound( in int samp,float time)\n{\n    \n    \n \ttime = max(0.0, time - WARMUP_TIME);\n\n    float tInput = time;\n    float timeInLoop = loopTime - time * loopSpeed;\n    \n\n   \tfloat per = ( (loopTime - timeInLoop) / loopTime ); \n    \n     // Fading in / fading out\n    float fadeIn = ((loopTime - clamp( timeInLoop , loopTime - fadeInTime , loopTime ))) / fadeInTime;\n    \n    float fadeOut = ((loopTime - clamp( (loopTime- timeInLoop) , loopTime - fadeOutTime , loopTime ))) / fadeOutTime;\n    \n    \n    // Gives us a straight fade to white\n\n    if( timeInLoop < impactTime + whiteTime ){\n        \n    \n    }\n    \n    \n     // TEXT\n    if( timeInLoop < impactTime ){ \n        \n        float textFade = pow( max( 0. , timeInLoop - (impactTime - impactFade) ) / impactFade , 2. );\n\n    }\n    \n    \n    float peaceTone = 0.;\n    float cometTone = 0.;\n    float textTone = 0.;\n    float explosionTone = 0.;\n    float finalTone = 0.;\n      \n    \n    peaceTone = smoothstep( .0 , .1 , per );\n    if( per > .6 ){\n     peaceTone = smoothstep( .8 , .6 , per);\n    }\n    \n  \n    if( per > .41 ){\n        cometTone = smoothstep( .41 , .49 , per ); \n        if( per > .49  && per < .75){\n          cometTone = 1. +  pow( (per - .49) /  ( .75 - .49 ) , 3.);\n        }\n        if( per > .75 ){\n          cometTone = smoothstep( .84 , .75  , per) * 2.;\n        }\n    }\n    \n    \n    explosionTone = pow( cometTone , 5. );\n    textTone = smoothstep( .76 , .9 , per );\n    finalTone = pow( smoothstep( .93 , .96 , per ), 2.) / max( 1. , exp( (per - .96)* 80. ));\n\n  \n    \n    vec2 noiseT = vec2( rand( vec2(time , 20.51) ) ,  rand( vec2(time*4. , 2.51) ));\n    \n    vec2 noiseFBM =  FBM22(time*(Noise21(time*.4)+900.0))*abs(Noise21(time*1.5));\n    //261.63\n    //329.63\n    //392.00\n    \n    //float cornT = 0.;\n    vec2 comet = vec2( chord( 55. , time))* cometTone;\n    //vec2 comet = vec2( 0. );\n    vec2 peace = chimeTrack(  time ) * peaceTone;\n    vec2 text  = chimeTrack(time*20.0) * textTone;\n   \n    vec2 final  =  vec2( chord( 110. , time))* 3.  * finalTone;\n      \n    vec2 explosion = ( noiseT + noiseFBM * 5. ) * .03  * explosionTone;\n\n    \n    vec2 b =  bass( time , 1.7 , 15. );\n    b += bass( time , 1.7 , 10.);\n    b *= textTone * 3.;\n    \n\n\n    vec2  a = min( fadeOut , fadeIn ) * (b + (comet + peace + text + explosion + final)  * .4);\n    //a2 =vec2( pow( a.x , 2. ),pow( a.y , 2. ));\n    return clamp( a ,-.8 , .8 );\n    \n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyyDD.jpg", "access": "api", "license": "proprietary-license", "functions": [[843, 843, 863, 863, 933], [935, 935, 958, 958, 992], [994, 994, 1021, 1021, 1143], [1145, 1145, 1171, 1171, 1393], [1445, 1445, 1466, 1466, 1658], [1660, 1660, 1708, 1708, 1861], [1863, 1979, 2030, 2030, 2151], [2153, 2202, 2245, 2245, 2303], [2305, 2345, 2386, 2386, 2472], [2474, 2523, 2556, 2556, 2582], [2682, 2682, 2702, 2702, 6993], [6995, 7041, 7073, 7073, 7622], [7624, 7624, 7666, 7666, 8145], [8147, 8192, 8257, 8257, 8531], [8582, 8582, 8639, 8639, 13261]]}
{"id": "NdyyWD", "name": "Infinite Xor Golf", "author": "shyshokayu", "description": "i see you @Xor with all of your golfing, this is the perfect shader for you. :>", "tags": ["fractal", "zoom", "loop", "xor", "gif", "golf", "seamless"], "likes": 9, "viewed": 298, "published": 3, "date": "1654833629", "time_retrieved": "2024-07-30T16:44:55.842847", "image_code": "/* @Xor - 239 chars: */\n\nvoid mainImage(out vec4 o, vec2 I)\n{\n    vec2 r=iResolution.xy,\n         u=(I-r*.5)/r.y+.5,\n         c=r-r+exp2(fract(iTime)),\n         i=u/c,\n         b=i*512.;\n    \n    for(c *= vec2(int(b) ^ int(b.y),0)*i/b; c.y++<9.; i+=i)\n        b = smoothstep(.5,.0,abs(fract(i)-.5)),\n        c.x *= .8+.2*b.x*b.y;\n    \n    o = c.x*vec4(u.x<1.);\n}\n\n/* @Xor - 255 chars:\n\n#define s smoothstep(.0,.5,fract(\n\nvoid mainImage(out vec4 o, vec2 I)\n{\n    vec2 r=iResolution.xy,\n         u=(I-r*.5)/r.y+.5,\n         c=r-r+exp2(fract(iTime)),\n         i=u/c,\n         b=i*512.;\n    \n    b = vec2(int(b) ^ int(b.y))/512.;\n    \n    \n    for(int j=0;j++<9;i+=i)\n        r=s i))*s-i)),\n        b*=.8+.2*r.x*r.y;\n    \n    o=b.x*c.x*vec4(u.x<1.);\n}\n\n*/\n\n/* @shyshokayu - 286 chars, original:\n\n#define s smoothstep(.0,.5,fract(\n\nvoid mainImage(out vec4 o,vec2 i){\n    vec2 r=iResolution.xy,\n    // Scale uv\n         u=(i-r*.5)/r.y+.5,\n         c;\n    \n    // Time\n    c+=exp2(fract(iTime));\n    \n    // Zoom\n    i=u/c;\n    \n    // Xor pattern\n    ivec2 e=ivec2(i*512.);\n    c.y=float(e.x^e.y)/512.;\n    \n    // Pattern smoothing - this isnt exactly correct, slight change of brightness on every loop, but it works\n    for(int j=0;j<9;++j,i*=2.)\n        c.y*=.8+.2*s i.x))*s-i.x))*s i.y))*s-i.y));\n    \n    // Swap lines if you have problems viewing this shader:\n    \n    // Multiply with time & square view\n    o+=c.y*c.x*step(abs(u.x-.5),.5);\n    \n    // ---\n\n    //o=vec4(c.y*c.x*step(abs(u.x-.5),.5));\n}\n\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 61, 61, 362]]}
{"id": "NsyyDW", "name": "Friendly Tree", "author": "wyatt", "description": "tree", "tags": ["tree"], "likes": 40, "viewed": 467, "published": 3, "date": "1654822555", "time_retrieved": "2024-07-30T16:44:56.590847", "image_code": "Main {\n    U = 2.*(U-.5*R)/R.y;\n    Q = vec4(0);\n    float d = 1e9; \n    U.y -= -1.;\n    float r = 0.;\n    for (float i = 0.; i < 15.; i++) {\n        \n        float s = segment(U,vec2(0),vec2(0,.6));\n        d = min(d,s);\n        U.y -= .6;\n        float h = -.5+hash(vec2(i,1+iFrame)).x;\n        h = sign(h);\n        r += h*exp2(i);\n        vec3 f = hash(vec2(r));\n        U *= 1.1+.5*f.y;\n        if (h!=0.)\n        U.x = h*U.x;\n        U.xy *= ei(-1.+.5*f.x);\n    }\n    vec3 hh = hash(vec2(r));\n    Q = step(d,.05)*.15*vec4(4,3,2,1);\n    U.y -= -.5;\n    U *= .3;\n    U = vec2(atan(U.y,U.x),length(U));\n    U.x += .1*fbm(vec2(10.*U.y,round(U.x/5.))).x;\n    U.y += (.5+.5*abs(sin(5.*U.x)))*-sin(U.x);\n    U.y += .5*fbm(r+10.*U.xx).x;\n    if (U.y<.5) Q = sin(.5*(hh.x*2.-1.)+.5+U.y+vec4(1,2,3,4));\n    if (length(Q)==0.) discard;\n}", "image_inputs": [], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat segment (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvec3 hash (vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nvec3 noise(vec2 p)\n{\n    vec4 w = vec4(\n        floor(p),\n        ceil (p)  );\n    vec3 \n        _00 = hash(w.xy),\n        _01 = hash(w.xw),\n        _10 = hash(w.zy),\n        _11 = hash(w.zw),\n    _0 = mix(_00,_01,fract(p.y)),\n    _1 = mix(_10,_11,fract(p.y));\n    return mix(_0,_1,fract(p.x));\n}\nvec3 fbm (vec2 p)\n{\n    vec3 w = vec3(0);\n    float N = 5.;\n    for (float i = 1.; i < N; i++)\n    {\n        p *= 1.7*ei(.5);\n        w += noise(p)/N/i;\n    }\n    return w;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "sdVyWh", "name": "Ripples, with simplex textures", "author": "AShaderBeginner", "description": "Learnt from\nhttps://thebookofshaders.com/11/\nthough I didn't use any random.\n\nOh and, I don't know how to change the previews of a shader.", "tags": ["simplex", "ripple"], "likes": 2, "viewed": 243, "published": 3, "date": "1654821251", "time_retrieved": "2024-07-30T16:44:57.426613", "image_code": "#define FREQ 30.0\n#define SPD 0.05\n\nvec2 skew(float x, float y){\n    return vec2(1.1547 * x, 0.5 * x + y);\n}\n\nvec2 unskew(float x, float y){\n    return vec2(0.86602 * x , y - 0.43302 * x);\n}\n\nbool inWave(vec2 p){\n    float d = length(p);\n    return sin((d - iTime * SPD) * FREQ) > 0.7;\n}\n\nfloat paint(vec2 pos){\n    // if(inWave(pos)) return 1.0;\n    \n    float sidelen = 1.0 / (10.0 + iTime * (3.0 + iTime / 100.0) * 2.0);\n    vec2 pos2 = skew(pos.x, pos.y) / sidelen;\n    \n    float ix = floor(pos2.x) * sidelen;\n    float iy = floor(pos2.y) * sidelen;\n    float cx = ceil(pos2.x) * sidelen;\n    float cy = ceil(pos2.y) * sidelen;\n    float fx = fract(pos2.x);\n    float fy = fract(pos2.y);\n    \n    vec2 p1 = unskew(ix, iy);\n    vec2 p2 = unskew(cx, cy);\n    \n    //NOTE: This is probably a bad idea.\n    //      But it'll all be sorted out by the compiler and hardware optimizations, so don't worry.\n    float s = step(fy - fx, 0.0);\n    vec2 p3 = unskew(ix * (1.0 - s) + cx * s,\n                     cy * (1.0 - s) + iy * s);\n    \n    return pow((inWave(p1) ? 0.5 : 0.0)\n               + (inWave(p2) ? 0.5 : 0.0)\n               + (inWave(p3) ? 0.5 : 0.0),\n               1.7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 norm = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n    fragColor.rgb = vec3(1.0 - paint(norm));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 64, 64, 108], [110, 110, 140, 140, 190], [192, 192, 212, 212, 287], [289, 289, 311, 346, 1183], [1185, 1185, 1242, 1242, 1377]]}
{"id": "NsyyWW", "name": "Fountains * ", "author": "wyatt", "description": "3 fountains", "tags": ["fluid", "automata"], "likes": 16, "viewed": 424, "published": 3, "date": "1654814438", "time_retrieved": "2024-07-30T16:44:58.252405", "image_code": "// Fork of \"In Air\" by wyatt. https://shadertoy.com/view/7tVXDw\n// 2022-06-09 22:26:36\n\n// Fork of \"Water Fall\" by wyatt. https://shadertoy.com/view/NtKGWD\n// 2021-12-30 04:31:49\n\nMain \n{\n    vec4 f = A(U),b=B(U);\n    Q = .6*f.wwww*vec4(1,2,3,4);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define box for(int x=-1;x<=1;x++)for(int y=-1;y<=1;y++)\n#define r2 0.70710678118\n// oneshade:\n//https://www.shadertoy.com/view/7sKSRh\nfloat std;\nfloat erf(in float x) {\n    x *= std;\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\nfloat erfstep (float a, float b, float x) {\n    return .5*(erf(b-x)-erf(a-x));\n}", "buffer_a_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b=B(U+u);\n        float f = 0.05*(a.w*(a.w-.8)+.2*b.w);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    Q.y -= .1/R.y;\n    Q = clamp(Q,-2.,2.);\n    vec2 M = 1.5*R;\n    if (iMouse.z>0.) M = iMouse.xy;\n    if(length(U-M)<.02*R.y)Q = vec4(0,0,0.*sin(iTime),1.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0);\n    \n    if (abs(U.x-.5*R.x)<.005*R.x&&U.y<.3*R.y)\n        Q.x = 0.,Q.w = .2, Q.y = 1.;\n    if (abs(U.x-.25*R.x)<.005*R.x&&U.y<.2*R.y)\n        Q.x = 0.,Q.w = .2, Q.y = 1.;\n    if (abs(U.x-.75*R.x)<.005*R.x&&U.y<.2*R.y)\n        Q.x = 0.,Q.w = .2, Q.y = 1.;\n    \n    if (U.x<1.||U.y<1.||R.y-U.y<1.) Q.xy*=0.;\n    if(R.x-U.x<1.)Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       {\n           float j = 1.;\n           float k = 1.;\n           float wa = 0.25*Q.w*min(i,j)/j;\n           float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n            dQ.w += wa+wb;\n      }\n      {\n           float j = 1.;\n           float k = 1.;\n           float wa = 0.25*Q.w*min(i,j)/j;\n           float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n            dQ.xyz += Q.xyz*wa+q.xyz*wb;\n      }\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Forces 🦜\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 a = A(U+u),b=B(U+u);\n        float f = 0.1*(a.w+b.w);\n        dQ.xy -= f*u;\n    }\n    Q += dQ;\n    Q = clamp(Q,-2.,2.);\n    if (length(Q.xy)>.5) Q.xy = .5*normalize(Q.xy);\n    if (iFrame < 1) Q = vec4(0,0,0,.1);\n    if (U.x<1.||U.y<1.||R.y-U.y<1.) Q.xy*=0.;\n    if(R.x-U.x<1.)Q.xy *= 0.;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Advect 🐿\nMain\n{\n    Q = A(U);\n    vec4 dQ = vec4(0);\n    box if(abs(x)!=abs(y))\n    {\n        vec2 u = vec2(x,y);\n        vec4 q = A(U+u);\n        vec2 a = Q.xy,\n             b = q.xy+u;\n       float ab = dot(u,b-a);\n       float i = dot(u,(0.5*u-a))/ab;\n       float j = .6;\n       float k = .6;\n       float wa = 0.25*Q.w*min(i,j)/j;\n       float wb = 0.25*q.w*max(k+i-1.,0.)/k;\n        dQ.xyz += Q.xyz*wa+q.xyz*wb;\n        dQ.w += wa+wb;\n        \n    }\n    if (dQ.w>0.)dQ.xyz/=dQ.w;\n    Q = dQ;\n    \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsyyWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "7sKyWh", "name": "Random Slabs", "author": "dr2", "description": "Random slabs (see source)", "tags": ["lattice", "percolation", "slab"], "likes": 10, "viewed": 304, "published": 3, "date": "1654792158", "time_retrieved": "2024-07-30T16:44:58.991429", "image_code": "// \"Random Slabs\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Based on \"Lattice Percolation\", with the random bonds in a cubic lattice\n  replaced by thin perpendicular slabs, all bounded by a sphere; pattern\n  changes periodically.\n*/\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv3 (vec3 p);\n\nvec3 ltDir[4], ltCol[4], cId;\nfloat tCur, dstFar, pVal, cMax, rSeed;\nbool cOcc, cOccN[6];\nconst float pi = 3.1415927;\n\nbool IsOcc (vec3 c)\n{\n  return (length (c + 0.5) < cMax && pVal + 0.5 * (Hashfv3 (c + rSeed + vec3 (0.21, 0.31, 0.41)) +\n     Hashfv3 (c.yzx + rSeed + vec3 (0.21, 0.31, 0.41))) > 1.);\n}\n\nvoid SetConf ()\n{\n  vec2 dc;\n  cOcc = IsOcc (cId);\n  dc = vec2 (1., 0.);\n  for (int k = 0; k < 2; k ++) {\n    dc.x = - dc.x;\n    cOccN[3 * k + 0] = IsOcc (cId + dc.xyy);\n    cOccN[3 * k + 1] = IsOcc (cId + dc.yxy);\n    cOccN[3 * k + 2] = IsOcc (cId + dc.yyx);\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec2 sz, dc;\n  float d, bl;\n  d = dstFar;\n  bl = 0.5;\n  sz = vec2 (0.05, 0.99) * bl;\n  if (cOcc) {\n    p -= cId + 0.5;\n    dc = vec2 (1., 0.);\n    for (int k = 0; k < 2; k ++) {\n      dc.x = - dc.x;\n      if (cOccN[3 * k + 0]) d = min (d, PrRoundBoxDf (p - dc.xyy * bl, sz.xyy, 0.01 * bl));\n      if (cOccN[3 * k + 1]) d = min (d, PrRoundBoxDf (p - dc.yxy * bl, sz.yxy, 0.01 * bl));\n      if (cOccN[3 * k + 2]) d = min (d, PrRoundBoxDf (p - dc.yyx * bl, sz.yyx, 0.01 * bl));\n    }\n  }\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, s, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p);\n    if (cId != cIdP) {\n      SetConf ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    s = (cId + step (0., rd) - p) * rdi;\n    d = min (d, abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec4 ObjNfL (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  float s;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  s = dot (v, vec4 (1.));\n  return vec4 (normalize (2. * v.yzw - s), (s - 2. * v.x - 4. * ObjDf (p)) / (e.x * e.x));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, vn4;\n  vec3 col, vn, sumD, sumS;\n  float dstObj, nDotL, att;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn4 = ObjNfL (ro);\n    vn = vn4.xyz;\n    col4 = vec4 (1., 1., 1., 0.2) * (1. - 0.5 * smoothstep (4., 8., abs (vn4.w))) *\n       (0.1 + 0.9 * length (cId + 0.5) / cMax);\n    sumD = vec3 (0.);\n    sumS = vec3 (0.);\n    for (int k = VAR_ZERO; k < 4; k ++) {\n      nDotL = max (dot (vn, ltDir[k]), 0.);\n      att = smoothstep (0.85, 0.95, dot (normalize (50. * ltDir[k] - ro), ltDir[k]));\n      sumD += ltCol[k] * att * col4.rgb * nDotL * nDotL;\n      sumS += ltCol[k] * att * col4.a * pow (max (0., dot (ltDir[k], reflect (rd, vn))), 32.);\n    }\n    col = sumD + sumS;\n  } else col = vec3 (0.1);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1\n  \nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, e;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  cMax = 16.;\n  pVal = 0.45;\n  rSeed = 11.111 * floor (tCur / 30.);\n  az = 0.15 * pi;\n  el = -0.2 * pi;\n  zmFac = 2.4;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n    zmFac += 2. * abs (az - 0.15 * pi) * smoothstep (0.2, 0.5, abs (az - 0.15 * pi));\n  } else {\n    az += 0.2 * pi * sin (0.01 * pi * tCur);\n    el += 0.1 * pi * sin (0.007 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -45.);\n  e = vec2 (1., -1.);\n  for (int k = VAR_ZERO; k < 4; k ++) {\n    ltDir[k] = normalize ((k < 2) ? ((k == 0) ? e.xxx : e.xyy) : ((k == 2) ? e.yxy : e.yyx));\n    ltDir[k].xy = Rot2D (ltDir[k].xy, 0.13 * pi * tCur);\n    ltDir[k].xz = Rot2D (ltDir[k].xz, 0.17 * pi * tCur);\n  }\n  ltCol[0] = vec3 (1., 0.1, 0.1);\n  ltCol[1] = ltCol[0].gbr;\n  ltCol[2] = ltCol[0].brg;\n  ltCol[3] = 0.8 * ltCol[0].rrg;\n  dstFar = 80.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKyWh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[649, 649, 670, 670, 834], [836, 836, 853, 853, 1101], [1103, 1103, 1125, 1125, 1626], [1628, 1628, 1661, 1661, 2233], [2235, 2235, 2257, 2257, 2586], [2588, 2588, 2623, 2623, 3402], [3421, 3421, 3474, 3474, 5044], [5046, 5046, 5092, 5092, 5139], [5141, 5141, 5163, 5163, 5201], [5203, 5203, 5239, 5239, 5445], [5447, 5447, 5477, 5477, 5590], [5624, 5624, 5648, 5648, 5713]]}
{"id": "Nd3cWj", "name": "Parabolic Torus", "author": "mla", "description": "A Parabolic Torus, drawn by solving the quartic equation of intersection. ", "tags": ["torus", "quartic", "parabolic"], "likes": 15, "viewed": 375, "published": 3, "date": "1654771144", "time_retrieved": "2024-07-30T16:44:59.880053", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Parabolic Torus\n// Another nice quartic solid of revolution - a parabolic torus.\n//\n// <mouse>: change view direction\n// <up/down>: zoom\n// <left/right>: torus radius\n// 'a': antialiasing\n// 'r': autorotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\n// Lighting\nvec3 light = vec3(1,1,-1);\nfloat ambient = 0.4;\nfloat diffuse = 0.6;\nfloat specular = 0.8;\nfloat specularpow = 10.0;\nvec3 specularcolor = vec3(1);\n\nfloat torusr = 1.0;\n\nint paratorus (vec3 p, vec3 d, out vec4 roots) {\n  float r = torusr;\n  float r2 = r*r;\n  float x0 = p.x, y0 = p.y, z0 = p.z;\n  //if (abs(z0) < 1e-2) z0 = sgn(z0)*1e-2;\n  float x02 = x0*x0, x03 = x02*x0, x04 = x02*x02;\n  float y02 = y0*y0, y03 = y02*y0, y04 = y02*y02;\n  float z02 = z0*z0, z03 = z02*z0, z04 = z02*z02;\n  float x1 = d.x, y1 = d.y, z1 = d.z;\n  float x12 = x1*x1, x13 = x12*x1, x14 = x12*x12;\n  float y12 = y1*y1, y13 = y12*y1, y14 = y12*y12;\n  float z12 = z1*z1, z13 = z12*z1, z14 = z12*z12;\n  float A = z14;\n  float B = 4.0*z0*z13;\n  float C = 6.0*z02*z12 + 2.0*r*z12 - x12 - y12;\n  float D = 2.0*(2.0*z03*z1 + 2.0*r*z0*z1 - x0*x1 - y0*y1);\n  float E = z04 + 2.0*r*z02 + r2 - x02 - y02;\n  return quartic(A,B,C,D,E,roots);\n}\n\nvec3 paratorusnormal(vec3 p) {\n  //return z4 + 2.0*r*z2 + r2 - x2 - y2;\n  float r = torusr; //sin(iTime);\n  float x = p.x, y = p.y, z = p.z;\n  return vec3(-2.0*x,-2.0*y,4.0*z*(z*z+r));\n}\n\nint dosurface(vec3 p0, vec3 r, out vec4 roots) {\n  return paratorus(p0,r,roots);\n}\n  \nvec3 donormal(vec3 p) {\n  return paratorusnormal(p);\n}\n  \nint solve(vec3 p0, vec3 r, out vec4 roots) {\n  int nroots = dosurface(p0,r,roots);\n  // Sort the roots\n  if (nroots >= 2) {\n    if (roots.y < roots.x) roots.xy = roots.yx;\n  }\n  if (nroots >= 3) {\n    if (roots.z < roots.y) roots.yz = roots.zy;\n    if (roots.y < roots.x) roots.xy = roots.yx;\n  }\n  if (nroots >= 4) {\n    if (roots.w < roots.z) roots.zw = roots.wz;\n    if (roots.z < roots.y) roots.yz = roots.zy;\n    if (roots.y < roots.x) roots.xy = roots.yx;\n  }\n  return nroots;\n}\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nfloat gridline(vec3 p) {\n  // Draw some gridlines on surface\n  vec3 t = fract(p*4.0);\n  t = min(t,1.0-t);\n  float d = min(t.x,min(t.y,t.z));\n  return smoothstep(0.02,0.025,d);\n}\n\nvec3 scene(vec3 p0, vec3 r) {\n  float time = iTime;\n  float a = 0.3333+ max(0.0,3.0*(1.0-cos(0.1*time)));\n  float b = (3.0*a-1.0)/(3.0-a);\n  vec4 params = vec4(a,b,0,0);\n  vec4 roots;\n  vec3 color = vec3(0);\n  int nroots = solve(p0,r,roots);\n  float rwidth = length(fwidth(r));\n  for (int i = nroots-1; i >= 0; i--) {\n    float t = roots[i];\n    if (t < 0.0) break;\n    vec3 p = p0+t*r;\n    vec3 n = donormal(p);\n    if (dot(n,r) > 0.0) n = -n;\n    n = normalize(n);\n    if (isnan(length(n))) continue;\n    float k = 0.0;\n    k += 2.0*iTime;\n    k += 0.5*atan(p.x,p.y)/PI; // Hum!\n    //if (length(p.xy) > torusr) k = -k;\n    k += 10.0*p.z;\n    vec3 basecolor = pow(abs(n.bgr),vec3(2.0));\n    basecolor = h2rgb(1.5*atan(p.z*p.z)/PI);\n    float dk = fwidth(k);\n    //assert(fwidth(k) < 0.5);\n    //if (abs(k-round(k)) < 0.1) basecolor = vec3(0);\n    basecolor = mix(vec3(0),basecolor,smoothstep(0.0,5.0*rwidth*t/abs(dot(n,r)),abs(k-round(k)) - 0.1));\n    //if (abs(length(p)-sqrt(a)) < 0.01) basecolor = vec3(1,0,0);\n    //if (min(abs(p.x),min(abs(p.y),abs(p.z))) < 0.01) basecolor = vec3(0.5);\n    vec3 c = applylighting(basecolor,p,n,r);\n    float fog = 1.0-smoothstep(0.0,200.0,t);\n    c *= fog;\n    color = mix(color,c,0.5);\n  }\n  return color;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float scale = 1.0;\n  float camera = 4.0;\n  camera *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  torusr = 0.1*float(keycount(KEY_RIGHT)-keycount(KEY_LEFT));\n  \n  vec3 p = vec3(0,0,-camera);\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  int AA = 1;\n  if (key(CHAR_A)) AA = 2;\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv, 2.0);\n      r = transform(r);\n      r = normalize(r);\n      color += scene(p,r);\n    }\n  }\n  color /= float(AA*AA);\n  color /= 1.0+color;\n  color = pow(color,vec3(0.4545));\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    x1 = C/A; x2 = -x1;\n  } else {\n    x1 = C/r; x2 = r/A;\n  }\n  res = vec2(x1,x2);\n  return 2;\n}\n\nint quadratic(vec3 coeffs, out vec2 res) {\n  return quadratic(coeffs[0],coeffs[1],coeffs[2],res);\n}\n  \n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Solve: Ax^3 + Bx^2 + Cx + D == 0\n// Find one real root, then reduce to quadratic.\nint cubic(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  if (A == 0.0) {\n    X = 1e8; A = B; b1 = C; c2 = D;\n  } else if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq,x0;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    x0 = X - s*r;\n    if (x0 != X) {\n      X = x0;\n      for (int i = 0; i < 6; i++) {\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        if (dq == 0.0) break;\n        X -= (q/dq);\n      }\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n    }\n  }\n  res.x = X;\n  return 1 + quadratic(A,b1,c2,res.yz);\n}\n\n// Special wrapper for cubic function for solving quartic.\n// Find largest real root of x**3 + a*x**2 + b*x + c\nfloat qcubic(float a, float b, float c) {\n  vec3 res;\n  int nroots = cubic(1.0,a,b,c,res);\n  if (nroots == 1) return res.x;\n  else return max(res.x,max(res.y,res.z));\n}\n\nint quartic(vec4 coeffs, out vec4 res) {\n  float c1 = coeffs[0];\n  float c2 = coeffs[1];\n  float c3 = coeffs[2];\n  float c4 = coeffs[3];\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int n0 = quadratic(1.0,alpha+a,beta+b,res.xy);\n  int n1 = quadratic(1.0,alpha-a,beta-b,res.zw); \n  if (n0 == 0) res.xy = res.zw;\n  return n0+n1;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  int nroots;\n  // It can be advantageous to use the coefficients in the\n  // opposite order, thus solving for the reciprocal.\n  bool flip = abs(A) < 1e-2 && abs(B) < 1e-2;\n  if (abs(B/A) > abs(D/E)) flip = true;\n  vec4 coeffs = flip ? vec4(D,C,B,A)/E : vec4(B,C,D,E)/A;\n  nroots = quartic(coeffs,roots);\n  if (flip) {\n    for (int i = 0; i < nroots; i++) {\n      roots[i] = 1.0/roots[i];\n    }\n  }\n  return nroots;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3cWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[594, 594, 642, 642, 1332], [1334, 1334, 1364, 1405, 1520], [1522, 1522, 1570, 1570, 1604], [1608, 1608, 1631, 1631, 1662], [1666, 1666, 1710, 1710, 2150], [2152, 2152, 2212, 2212, 2449], [2451, 2451, 2475, 2511, 2628], [2630, 2630, 2659, 2659, 3879], [3881, 3881, 3908, 3908, 4252], [4254, 4254, 4311, 4311, 5072]]}
{"id": "7dGcD1", "name": "new473563479", "author": "Igger", "description": ":/", "tags": ["hbfhjfvbf"], "likes": 0, "viewed": 197, "published": 3, "date": "1654768214", "time_retrieved": "2024-07-30T16:45:00.624064", "image_code": "#define myPi 3.141592654f \n#define Eps 1e-8 \n#define maxZ 100.0 \n \nconst int n = 5; \nvec3 colVec[n] = vec3[n](vec3(0.98, 0.23, 0.20), vec3(0.0, 0.1, 0.57), vec3(0.99, 0.93, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.9, 0.4, 0.05));\nvec3 BGcol = vec3(0.0, 0.0, 0.0);\n\n \nint sizes[n] = int[n](3, 3, 4, 3, 5), inds[n] = int[n](0, 3, 6, 10, 13); const int m = 18; \nvec2 polygonsXY[m]; float polygonsZ[m]; \n \nvoid initPolygons(out vec2 polygonsXY[m], out float  polygonsZ[m], in float time){ \n// 0 -- triangle \n    polygonsXY[0] = vec2(0.02, 0.05); polygonsZ[0] = 0.9;  \n    polygonsXY[1] = vec2(0.5, 0.95); polygonsZ[1] = 0.8; \n    polygonsXY[2] = vec2(0.02, 0.95); polygonsZ[2] = 0.9; \n// 1 -- triangle \n    polygonsXY[3] = vec2(0.0, 0.0); polygonsZ[3] = 0.09; \n    polygonsXY[4] = vec2(1.0, 0.85); polygonsZ[4] = 0.11; \n    polygonsXY[5] = vec2(0.85, 1.0); polygonsZ[5] = 0.09; \n \n// 3 -- rotated square \n    float w = 2.0; \n    vec3 center = vec3(0.64, 0.5 + 0.2*cos(time*w) , 0.1); float r = 0.2; \n    int i; float j =0.0, phi = myPi/7.0; \n    float ang = 2.0*myPi/4.0;  \n    vec3 tmpVec; \n    mat3 rot = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(phi), sin(phi)), vec3(0.0, -sin(phi), cos(phi)) ); \n    for (i = 6; i < 10; i++){ \n        tmpVec = rot*(r*vec3(cos(j*ang + time), sin(j*ang + time), 0.0));  \n        polygonsXY[i] = tmpVec.xy + center.xy; \n        polygonsZ[i] = tmpVec.z + center.z; \n        j = j + 1.0; \n    } \n     \n// 4 -- rotated triangle \n    float w2 = 3.0; \n    vec3 center2 = vec3(0.64, 0.5 + 0.2*cos(time*w) , 0.1); float R = 0.35; \n    int k; float t =0.0, phi2 = myPi/4.0;\n    float ang2 = 2.0*myPi/7.0;  \n    vec3 tmpVec2; \n    mat3 rot2 = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(phi2), sin(phi2)), vec3(0.0, -sin(phi2), cos(phi2)) ); \n    for (k = 10; k < 13; k++){ \n        tmpVec2 = rot2*(R*vec3(cos(t*ang2 + time), sin(t*ang2 + time), 0.0));  \n        polygonsXY[k] = tmpVec2.xy + center2.xy; \n        polygonsZ[k] = tmpVec2.z + center2.z; \n        t = t + 1.0; \n    } \n    \n// 5 -- pentagon\n    polygonsXY[13] = vec2(0.1, 0.05); polygonsZ[3] = 0.9;\n    polygonsXY[14] = vec2(0.95, 0.05); polygonsZ[4] = 0.9;\n    polygonsXY[15] = vec2(0.95, 0.4); polygonsZ[5] = 0.9;\n    polygonsXY[16] = vec2(0.75, 0.4); polygonsZ[6] = 0.9;\n    polygonsXY[17] = vec2(0.6, 0.63); polygonsZ[7] = 0.9;\n     \n} \n \n \n \nint leftTurn(in vec2 a, in vec2 b, in vec2 c) \n{ \n    float tmp = (c.x - a.x)*(b.y - a.y) - (c.y - a.y)*(b.x - a.x); \n    if (abs(tmp) < Eps)  \n        return 0; \n    else  \n        return tmp > 0.0 ? 1: -1; \n} \n \n \nbool inPolygon(in int ind0, in int size, in vec2 vert[m], in vec2 p) // vertices in counter clockwise order \n{ \n    bool res = leftTurn(vert[ind0 + size-1], vert[ind0], p) <= 0; int i = ind0; \n    while(res && (i < ind0 + size -1)) \n    { \n        res = res && (leftTurn(vert[i], vert[i+1], p) <= 0); i++; \n    } \n    return res; \n} \n \nfloat zInPlane(in vec3 a, in vec3 b, in vec3 c, in vec2 p) // z coordinate for (x,y) point of a plane (a-b, c-b) \n{ \n    vec3 nrm = cross(a-b, c-b); \n    //float D = - dot(nrm, b); \n    if (abs(nrm.z) < Eps) return a.z; \n    else return (dot(nrm, b) - nrm.x*p.x - nrm.y*p.y)/nrm.z; \n} \n \n \n// vec3 normalize(vec3), vec3 cross(vec3, vec3) are predefined \nvoid initColours (float time, vec2 uv){\n    \n    int i;\n    vec3 col;\n    float b = uv.x + uv.y;\n    float j = 0.0;\n    for (i = 0; i < 100; i++){\n        if ((b > j*0.02) && (b < (j + 1.5)*0.02))\n            if (i % 3 == 0){\n                col = 0.06 + 0.3*cos(uv.xyx+vec3(0,3,8));\n                colVec[4] = vec3(col);\n            }\n        j+= 1.0;\n        } \n        \n    \n    float w = 2.0;\n    \n    vec3 center = vec3(0.75, 0.58 + 0.4*cos(time*w) , 0.89);\n    colVec[3] = vec3(center);\n    \n    colVec[2] = vec3(1.0, 0.93, cos(3.0*time)); \n    \n} \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    // Normalized pixel coordinates (from 0 to 1) \n    vec2 uv = fragCoord/iResolution.xy; \n    float time = iTime, tmp; //iTime;\n    initPolygons(polygonsXY, polygonsZ, time); \n    initColours(time, uv); \n    vec3 col = BGcol; float z = maxZ;  \n    int i; \n    for (i =0; i < n; i++){ \n        if ( inPolygon(inds[i], sizes[i], polygonsXY, uv) ){ \n            tmp = zInPlane(vec3(polygonsXY[inds[i]].x, polygonsXY[inds[i]].y, polygonsZ[inds[i]]), \n            vec3(polygonsXY[inds[i]+1].x, polygonsXY[inds[i]+1].y, polygonsZ[inds[i]+1]), \n            vec3(polygonsXY[inds[i]+2].x, polygonsXY[inds[i]+2].y, polygonsZ[inds[i]+2]), uv); \n            if (tmp < z){ \n                z = tmp; col = colVec[i];  \n            } \n        } \n    } \n \n \n    // Output to screen \n    fragColor = vec4(col,1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGcD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[395, 395, 477, 496, 2311], [2319, 2319, 2367, 2367, 2529], [2535, 2535, 2645, 2645, 2867], [2871, 2871, 2986, 2986, 3155], [3161, 3225, 3264, 3264, 3779], [3783, 3783, 3841, 3893, 4645]]}
{"id": "ssyyDh", "name": "Cube and Square Root", "author": "iq", "description": "One way that I've developed to compute the square and cube root of a number without using sqrt(), pow() or exp(log(x)/n). Grey,: hardware implementation. Colored: the technique here.", "tags": ["2d", "cube", "newton", "exponent", "root", "cbrt", "cuberoot", "7544"], "likes": 23, "viewed": 1114, "published": 3, "date": "1654762344", "time_retrieved": "2024-07-30T16:45:01.418938", "image_code": "// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// One way to compute roots without using sqrt(), pow()\n// or exp(log(x)/n). I'm not claiming this is the fastest \n// (in modern hardware) nor the best method.\n//\n// I based it on extracing the exponent of the number and\n// dividing it by 2 or 3 and then applying two Newton-Raphson\n// iterations. As mla pointed out in the comments, you can do\n// this to the whole number, not just the exponent.\n//\n// 709973695 and 532545536 minimize the error in the\n// interval 0 to 1000. I found them by looking in the\n// neigborhood of (127-127/3)*(2^23) and (127-127/2)*(2^23),\n// which are the adjustment to the exponent bias needed\n// after the raw division by 3 and 2 respectivelly.\n\nfloat my_cbrt( float x )\n{\n    float y = uintBitsToFloat(709973695u+floatBitsToUint(x)/3u);\n    y = y*(2.0/3.0) + (1.0/3.0)*x/(y*y);\n    y = y*(2.0/3.0) + (1.0/3.0)*x/(y*y);\n    return y;\n}\n\nfloat my_sqrt( float x )\n{\n    float y = uintBitsToFloat(532545536u+(floatBitsToUint(x)>>1));\n    y = 0.5*(y+x/y);\n    y = 0.5*(y+x/y);\n    return y;\n}\n\n// exactly the same as above, but with a single division\nfloat my_sqrt_single_division( float x )\n{\n    float y = uintBitsToFloat(532545536u+(floatBitsToUint(x)>>1));\n    float y2 = y*y, x2=x*x;\n    return (y2*(y2+6.0*x)+x2) / (4.0*y*(y2+x));\n}\n\n//------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2  p  = 4.0*fragCoord/iResolution.x;\n    float px = 4.0/iResolution.x;\n\n    float al = smoothstep(-0.1,0.1,sin(6.283185*iTime));\n\n    vec3 col = vec3( 0.1 + 0.05*mod(floor(p.x)+floor(p.y),2.0) );\n    \n    // hardware pow()\n    {\n    float y = pow( p.x, 1.0/3.0 );\n    float d = abs(p.y-y)/sqrt(1.0+pow(p.x,-4.0/3.0)/9.0 ); // https://iquilezles.org/articles/distance/\n    col = mix( col, vec3(0.5,0.5,0.5), 1.0-smoothstep(0.0,1.5*px,d) );\n    }\n    // my implementation\n    {\n    float y = my_cbrt( p.x );\n    float d = abs(p.y-y)/sqrt( 1.0+pow(p.x,-4.0/3.0)/9.0 ); // https://iquilezles.org/articles/distance/\n    col = mix( col, vec3(1.0,1.0,0.0), al*(1.0-smoothstep(0.0,1.5*px,d)) );\n    }    \n    // hardware sqrt()\n    {\n    float y = sqrt( p.x );\n    float d = abs(p.y-y)/sqrt(1.0+1.0/(4.0*p.x) ); // https://iquilezles.org/articles/distance/\n    col = mix( col, vec3(0.5,0.5,0.5), 1.0-smoothstep(0.0,1.5*px,d) );\n    }\n    // my implementation\n    {\n    float y = my_sqrt( p.x );\n    float d = abs(p.y-y)/sqrt(1.0+1.0/(4.0*p.x) ); // https://iquilezles.org/articles/distance/\n    col = mix( col, vec3(0.0,1.0,1.0), al*(1.0-smoothstep(0.0,1.5*px,d)) );\n    }    \n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyyDh.jpg", "access": "api", "license": "mit", "functions": [[1755, 1755, 1781, 1781, 1944], [1946, 1946, 1972, 1972, 2097], [2099, 2156, 2198, 2198, 2343], [2427, 2427, 2484, 2484, 3702]]}
{"id": "sdycDh", "name": "Hexagonal Lattice", "author": "AShaderBeginner", "description": "After finding out that I can warp the coordinate system using matrices, I successfully did hexagons. Took long because I forgot how to properly invert a matrix.\n\nThis is inspired by https://thebookofshaders.com/09/geometricpatters.png", "tags": ["hexagon", "shapes", "lattice"], "likes": 2, "viewed": 316, "published": 3, "date": "1654760144", "time_retrieved": "2024-07-30T16:45:02.206832", "image_code": "#define HALF_SQRT3 0.66025403\n#define INV_SQRT3 0.5773502691\n#define SIDELEN (iResolution.y / (iTime * 5.0))\n\nvec2 getHexagonCenter(in vec2 pos){\n    // Label\n    int x = int(mod(floor(pos.x) - floor(pos.y), 3.0));\n    \n    switch(x){\n        case 0:\n            return vec2(ceil(pos.x), floor(pos.y));\n        case 2:\n            return vec2(floor(pos.x), ceil(pos.y));\n        case 1:\n            if(fract(pos.x) + fract(pos.y) < 1.0){\n                return vec2(floor(pos.x), floor(pos.y));\n            } else {\n                return vec2(ceil(pos.x), ceil(pos.y));\n            }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat2 toHexagons = mat2(HALF_SQRT3, HALF_SQRT3,\n                           -0.5      , 0.5      );\n    mat2 fromHexagons = mat2(INV_SQRT3, INV_SQRT3,\n                             -1.0     , 1.0);\n    vec2 center = fromHexagons * fragCoord / SIDELEN;\n    center = getHexagonCenter(center);\n    center = toHexagons * center * SIDELEN;\n    \n    // normalize\n    center /= iResolution.xy;\n    \n    float invcol = distance(center, vec2(-0.5, 0.5));\n    fragColor.r = 1.0 - invcol;\n    fragColor.g = 1.0 - 2.0 * invcol;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdycDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 145, 158, 592], [594, 594, 651, 651, 1170]]}
{"id": "fdycD1", "name": "werid sphere", "author": "fl0a1e", "description": "apply fbm to sphere", "tags": ["raymarch", "sdf", "fbm", "sphere"], "likes": 3, "viewed": 318, "published": 3, "date": "1654753086", "time_retrieved": "2024-07-30T16:45:02.965803", "image_code": "// \n// try fbm \n//\n// Created by fl0a1e 06/09/2022\n// \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// sdf and noise from shaders by inigo quilez, https://iquilezles.org/articles/distfunctions/\n\n#define PI 3.14159265359\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION  0.001\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x ){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n\nfloat fbm (vec3 p)\n{\n    float f = 0.0;\n    float freq = 4.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float n = 4. * noise(p * freq) / freq;\n        f += n;\n        freq *= 1.5;\n    }\n    return f;\n}\n\n\n\nfloat sdSphere( vec3 p, float r)\n{\n    return length(p)-(r+fbm(p));\n}\n\n\n\n\nfloat map( vec3 p )\n{\n    float d = sdSphere(p, 1.0);\n    return d;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n\nfloat calcAO( vec3 pos, vec3 nor)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 4; i++)\n    {\n        float h = .001 + 0.015 * float(i);\n        float d = map(pos + nor * h);\n        occ = (h - d) * sca;\n        sca *= .95;\n        if( occ > 0.35 ) break;\n    }\n    \n    return clamp( 1.0 - 1.0*occ, 0.0, 1.0 );\n}\n\nfloat raymarch( vec3 ro, vec3 rd)\n{\n    float dist = 0.0;\n\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + rd * dist;\n        float d = map(p);\n        if(abs(d) < 0.001 || d > MAX_DIST) break;\n        dist += d*0.75;\n    }\n\n\n    return dist;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    \n    vec3 col;\n    vec3 background = vec3(.01, .01, .01);\n    // raymarch\n    float d = raymarch(ro, rd);\n    \n    if(d > MAX_DIST)\n    {\n        \n    }\n    else // if hit something\n    {\n        vec3 pos = ro + rd * d;\n        vec3 nor = calcNormal(pos);\n        \n        // shadow\n            pos += nor * PRECISION * 2.0; \n            float ao = calcAO(pos, nor);\n        \n        // sun\n        {\n            vec3 sunPos = vec3(13.*sin(iTime*.5), 7., 5.*cos(iTime*.5));\n            vec3 ld = normalize(sunPos - pos);\n            float dif = clamp( dot( nor, ld ), 0.0, 1.0 );\n            \n            \n            float spe = pow( clamp( dot( nor, ld ), 0.0, 1.0 ),16.0);\n            spe *= dif;\n            spe *= 0.04+0.96*pow(clamp(1.0-dot(ld, sunPos),0.0,1.0),5.0);\n            \n            col += 1.2*dif * vec3(.6, .6, 1.);\n        }\n        col *= ao;\n        \n    }\n    \n    // fog\n    col = mix(col, background, 1.0 - exp(-0.0001 * d * d * d));\n    \n    return col;\n}\n\nmat3 camera(vec3 campos, vec3 camtar)\n{\n    float roll = 0.0;\n    vec3 cw = normalize(camtar - campos); // camera watch\n    vec3 cr = normalize(cross(cw, vec3(sin(roll), cos(roll), 0.0))); // camera right\n    vec3 cu = normalize(cross(cr, cw));   // camera up\n    \n    return mat3(cr, cu, -cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    float time = iTime*.2;\n    vec2 mouse = PI * (-1.0 + 2.0 * iMouse.xy / iResolution.xy);\n    \n    // camera\n    vec3 ro = vec3(0.0+sin(mouse.x)*15., 2.0, 15.0-15.*(cos(mouse.x)+1.));\n    vec3 camtar = vec3(0.0, 0.0, 0.0);\n    mat3 cam = camera(ro, camtar);\n    vec3 rd = normalize(cam*vec3(uv, -1.3)); // ray direction\n    \n    vec3 col = render(ro, rd);\n    \n    // gamma\n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdycD1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[367, 367, 390, 390, 429], [432, 432, 457, 457, 817], [821, 821, 841, 841, 1026], [1030, 1030, 1064, 1064, 1099], [1104, 1104, 1125, 1125, 1173], [1175, 1175, 1207, 1207, 1408], [1411, 1411, 1446, 1446, 1745], [1747, 1747, 1782, 1782, 2019], [2022, 2022, 2061, 2061, 3046], [3048, 3048, 3087, 3087, 3344], [3346, 3346, 3403, 3403, 3940]]}
{"id": "7dKcWR", "name": "BritneyInFocus", "author": "Sergeindamix", "description": "Infinite shadow && SDF. Mask video", "tags": ["2d", "video", "sdf", "transition", "repeat"], "likes": 7, "viewed": 449, "published": 3, "date": "1654733020", "time_retrieved": "2024-07-30T16:45:03.765664", "image_code": "#define SHADOW_ANGLE -50.0\n#define SHADOW_COLOR vec3(1, 0, 0);\n#define LIGHT_DIR vec2(1, 1)\n#define LIGHT_INTENSITY 0.3\n\n#define EPS 0.01\n#define ITER 30\n\n#define T iTime\n#define S(a,b,t) smoothstep(a,b,t)\n#define pi 3.1415926535898\n\nvec2 rot(vec2 uv, float t) {\n    float c = cos(t), s = sin(t);\n    return mat2(c, -s, s, c) * uv;\n}\nvec3 RotateY(vec3 v, float degree)\n{\n    float rad = 0.0174532925*degree;\n    float cosY = cos(rad);\n    float sinY = sin(rad);\n    return vec3(cosY*v.x - sinY * v.z, v.y, sinY*v.x + cosY * v.z);\n}\n\nfloat sdCircle(vec2 p, float radius) {\n    return length(p) - radius;\n}\n// Copied from iq's article\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\nfloat radius =.5;\nfloat angle =.1;\nfloat width =.5;\nvec2 size = vec2(0.4,.24);\nvec2 start = vec2(0,0);\nvec2 end = vec2(1,0);\nfloat map(vec2 p) {\n    //p = rot(p, iTime);\n    p += vec2(sin(iTime), cos(iTime)*.5);\n    float a1 = 5., a2 = a1 + 5., a3 = a2 + 5., a4 = a3 + 5., a5 = a4 + 5., a6 = a5 + 5., a7 = a6 + 5., a8 = a7 + 5.;    \n    float gTime = mod(iTime,  a8 + 1.);//time after animations\n    \n    float Circ = sdCircle(p, 0.3);\n    float tria = triangleDist(p, radius);\n    float box = boxDist(p, size, radius-.45);\n    float star = sdStar5(p, 0.4, 0.5);\n    float scir = semiCircleDist(p, radius, angle, width);\n    float lin = lineDist(p, start, end, width-.45);\n        for (int i = 0; i < 4; i++)\n        {\n            vec3 p3;\n            p3=RotateY(p3, -22.5 * float(i)) + vec3(float(i)*sin(T)*.75, float(i)*cos(T)*.75, float(i)*pi);\n            float circAdd = sdCircle(p-p3.xy, 0.3);\n            float triaAdd = triangleDist(p-p3.xy, radius);\n            Circ = min(Circ, circAdd);\n            tria = min(tria, triaAdd);\n            float boxAdd = boxDist(p-p3.xy, size, radius-.45);\n            box = min(box, boxAdd);\n            float starAdd = sdStar5(p-p3.xy,0.4, 0.5);\n            star = min(star, starAdd);\n            float scirAdd = semiCircleDist(p-p3.xy, radius, angle, width);\n            scir = min(scir, scirAdd);\n            float linAdd = lineDist(p-p3.xy, start, end, width-.45);\n            lin = min(lin, linAdd);\n        }\n        \n    if (gTime < a1){\n        float t0 = gTime-2.;\n        \n\t\treturn Circ;//sdCircle(p, 0.3);\n    } else if (gTime < a2) {\n        float t0 = gTime-a1;\n        \n        return tria; \n    } else if (gTime < a3 ){\n     \tfloat t0 = gTime - a2;\n        \n        return box;\n    } else if (gTime < a4) { \n        float t0 = gTime-a3;\n        \n        return star;\n    } else if (gTime < a5) {\n    \n       return Circ;     \n    } else if (gTime < a5) {\n    \n       return tria;       \n    \n    } else if (gTime < a6) {\n    \n       return scir;       \n    } else if (gTime < a7){\n    \n       return box;\n    } else if  (gTime < a8) {\n    \n       return  lin;\n    }\n    \n    \n    \n}\n\nvec2 getNormal(vec2 p) {\n    vec2 d = vec2(1, 0) * EPS;\n    return normalize(vec2(\n        map(p + d.xy) - map(p - d.xy),\n        map(p + d.yx) - map(p - d.yx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y; // fix aspect ratio\n\n    vec3 col;\n    \n    // Draw BG\n    float a = floor((uv.x - uv.y * 0.5 - iTime * .08) * 8.) - iTime * 2.;\n    col = vec3(sin(a), sin(a + 2.), sin(a + 3.)) * 0.2 + 0.7;\n    \n    // Draw infinite shadow by raymarching\n    float angle = radians(SHADOW_ANGLE);\n    vec2 dir = -vec2(cos(angle), sin(angle));\n    float d;\n    float t = 0.;\n    vec2 p2;\n    \n    for (int i = 0; i < ITER; i++) {\n        p2 = p + dir * t;\n        d = map(p2);\n        if (d < EPS) {\n            vec2 n = getNormal(p2);\n            float shade = dot(n, normalize(LIGHT_DIR));\n            col = SHADOW_COLOR;\n            col *= 1. + shade * LIGHT_INTENSITY;\n        }\n        t += d;\n    }    \n\n    // Draw foreground\n    d = map(p);\n    float inside = step(d, EPS);\n    if (d < EPS) {\n        col = vec3(step(d, -EPS));\n        //uv = rot(uv, iTime);\n        \n            \n        uv/=vec2(.75);\n        uv+=vec2(.75);\n        uv += vec2(sin(iTime), cos(iTime));\n        col=min(col, texture(iChannel0,uv).rgb);\n    }    \n    //col*=rectangle(uv, vec2(0.5, 0.51));//\n    // vignette\n    col -= smoothstep(0.5, 3.0, length(p));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29123, "src": "https://soundcloud.com/believer/test-2022-06-03-at-19h25m40s?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 234, 262, 262, 333], [334, 334, 370, 370, 531], [533, 533, 571, 571, 604], [605, 633, 684, 684, 1062], [1063, 1063, 1105, 1105, 1187], [1188, 1188, 1225, 1225, 1249], [1250, 1250, 1282, 1282, 1389], [1390, 1390, 1430, 1430, 1460], [1462, 1462, 1532, 1532, 1644], [1645, 1645, 1693, 1693, 1809], [1810, 1810, 1869, 1869, 2057], [2184, 2184, 2203, 2228, 4200], [4202, 4202, 4226, 4226, 4371], [4373, 4373, 4430, 4430, 5703]]}
{"id": "sdVcDR", "name": "2D Water Reflection", "author": "Xorberax", "description": "A simple 2D water reflection shader. Mouse X Axis = Field of View, Mouse Y = Water Line Offset", "tags": ["reflection", "water"], "likes": 3, "viewed": 522, "published": 3, "date": "1654727488", "time_retrieved": "2024-07-30T16:45:04.608411", "image_code": "const vec4 waterTint = vec4(0.5, 0.5, 0.5, 1.0);\nconst float waterRippleStrength = 10.25;\nconst float waterRippleSpeed = 0.015;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float waterLineOffset = iMouse.y / iResolution.y;\n\n    if (uv.y >= waterLineOffset)\n    {\n        fragColor = texture(iChannel0, uv);\n    }\n    else\n    {\n        float fieldOfViewScalar = (iMouse.x / iResolution.x) * 10.0;\n        vec2 vanishingPoint = vec2(0.5, waterLineOffset + fieldOfViewScalar);\n        float distanceToVanishingPoint = length(uv - vanishingPoint);\n        float distanceToWaterLine = waterLineOffset - uv.y + 0.2;\n        float fadedWaterRippleStrength = waterRippleStrength * distanceToWaterLine;\n        vec4 noiseColor = texture(\n            iChannel1,\n            vec2(\n                uv.x + iTime * waterRippleSpeed, \n                uv.y - iTime * waterRippleSpeed\n            ) * distanceToVanishingPoint\n        );\n        noiseColor *= texture(\n            iChannel2,\n            vec2(\n                uv.x - iTime * waterRippleSpeed,\n                uv.y + iTime * waterRippleSpeed\n            ) * distanceToVanishingPoint\n        );\n        noiseColor *= fadedWaterRippleStrength * distanceToWaterLine;\n        fragColor = texture(\n            iChannel0, \n            vec2(\n                uv.x,\n                -uv.y + waterLineOffset\n            ) + \n            vec2(\n                0.0,\n                waterLineOffset\n            ) +\n            vec2(\n                noiseColor.g * noiseColor.b * noiseColor.r,\n                noiseColor.r * noiseColor.g * noiseColor.b\n            )\n        ) * waterTint;\n    }\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVcDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 186, 186, 1690]]}
{"id": "sdKcDz", "name": "Face in the clouds", "author": "mrange", "description": "License CC0: Face in the clouds\nSymmetry around y-axis can often create an illusion of a face\nor a human body. I was playing around with smeared FBM\nand added some glowing points to mislead the brain to think it's eyes\nof a malevolent cloud being.", "tags": ["fbm"], "likes": 29, "viewed": 886, "published": 3, "date": "1654721292", "time_retrieved": "2024-07-30T16:45:05.416251", "image_code": "// License CC0: Face in the clouds\n//  Symmetry around y-axis can often create an illusion of a face\n//  or a human body. I was playing around with smeared FBM\n//  and added some glowing points to mislead the brain to think it's eyes\n//  of a malevolent cloud being\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define TTIME       (TIME*TAU)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)     dot(x, x)\n#define RESOLUTION  iResolution\n\nconst mat2 frot = ROT(PI/3.33);\n\nvec2 g_vx = vec2(0.0, 0.0);\nvec2 g_vy = vec2(3.2, 1.3);\n\nvec2 g_wx = vec2(1.7, 9.2);\nvec2 g_wy = vec2(8.3, 2.8);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat vesica(vec2 p, vec2 sz) {\n  if (sz.x < sz.y) {\n    sz = sz.yx;\n  } else {\n    p  = p.yx; \n  }\n  vec2 sz2 = sz*sz;\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\n  float r  = sqrt(sz2.x+d*d);\n  float b  = sz.x;\n  p = abs(p);\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                           : length(p-vec2(-d,0.0))-r;\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\nfloat fbm(vec2 p) {    \n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= 0.5;\n  }\n  return f/s;\n}\n\nvec2 df(vec2 p) {\n  vec2 p0 = p;\n  p0.x = abs(p0.x);\n  p0 -= vec2(0.75, 0.4);\n  p0 *= ROT(PI/9.0);\n  float d0 = vesica(p0, vec2(0.45, 0.2));\n  float g0 = length(p0);\n\n  float d = d0;\n  float g = g0;\n\n  return vec2(d, g);\n}\n\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\n  float d = df(p).x-0.1;\n  p.x = -pabs(p.x, 0.125);\n\n  v = vec2(fbm(p + g_vx), fbm(p + g_vy));\n  w = vec2(fbm(p + 3.0*v + g_wx), fbm(p + 3.0*v + g_wy));\n\n  float h = fbm(p + 2.25*w);\n\n  float aa = 0.2;\n  h *= mix(1.0, 0.05, smoothstep(aa, -aa, d));\n\n  return h*smoothstep(2.5, 0.15, abs(p.x+0.5*p.y));\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  float eps = 2.0/RESOLUTION.y;\n  vec2 e = vec2(eps, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvec3 smear(vec2 p, vec2 q) {\n  float aa = 2.0/RESOLUTION.y;\n  g_vx *= ROT(TTIME/1000.0);\n  g_vy *= ROT(TTIME/900.0);\n  g_wx *= ROT(TTIME/800.0);\n  g_wy *= ROT(TTIME/700.0);\n\n  vec2 v;\n  vec2 w;\n \n  vec2 d2 = df(p);\n  float d = abs(d2.x) - 2.0*aa;\n  float g = d2.y;\n  float h = warp(p, v, w);\n  vec3 n  = normal(p);\n\n  vec3 ld1  = normalize(vec3(0.5, 0.2, 0.4));\n  vec3 ld2  = normalize(vec3(-0.5, 0.2, -0.4));\n  vec3 lcol1= HSV2RGB(vec3(0.9, 0.333, 1.0));\n  vec3 lcol2= HSV2RGB(vec3(0.6, 0.125, 2.0));\n  vec3 acol = HSV2RGB(vec3(0.6, 0.0, 0.3));\n\n  float dif1 = pow(max(dot(ld1, n), .0), 1.0);\n  float dif2 = pow(max(dot(ld2, n), .0), 2.0);\n\n  const vec3 col11 = HSV2RGB(vec3(0.9, 0.9, 0.5));\n  const vec3 col21 = HSV2RGB(vec3(0.4, 0.9, 0.5));\n  const vec3 col12 = HSV2RGB(vec3(0.6, 0.9, 1.5));\n  const vec3 col22 = HSV2RGB(vec3(0.0, 0.9, 1.5));\n\n  vec3 col1 = mix(col11, col12, q.x);\n  vec3 col2 = mix(col21, col22, q.y);\n  \n  vec3 col = vec3(0.0);\n  float lv = length(v);\n  float lw = length(w);\n  col += lv*col1*dif1*lcol1;\n  col += lw*col2*dif1*lcol1;\n  col += lv*col1*dif2*lcol2;\n  col += lw*col2*dif2*lcol2;\n  col += lv*col1*acol;\n  col += lw*col2*acol;\n  col *= smoothstep(0.0, 1., (h*h+0.05+0.75*0.125*(1.0+p.y)));\n//  col *= smoothstep(0.0, 1., (h*h+0.125));\n  col *= smoothstep(2.0, 8.0, TIME-length(p));\n  col += mix(5.0, 1.0, 0.5+0.5*sin(TTIME/8.0))*HSV2RGB(vec3(0.6, 0.8, 1.0))*exp(-40.0*g);\n  col *= smoothstep(0.0, 4.0, TIME);\n//  col = mix(col, vec3(1.0), smoothstep(aa, -aa, d));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = smear(p, q);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 29088, "src": "https://soundcloud.com/shadowofthebeatofficial/scared-away", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKcDz.jpg", "access": "api", "license": "cc0-1.0", "functions": [[805, 805, 827, 827, 973], [1268, 1368, 1389, 1389, 1462], [1463, 1563, 1585, 1585, 1634], [1636, 1743, 1769, 1769, 1953], [1955, 2055, 2094, 2094, 2179], [2181, 2181, 2212, 2212, 2510], [2512, 2512, 2542, 2542, 2570], [2572, 2572, 2593, 2593, 2715], [2717, 2717, 2736, 2736, 2936], [2938, 2938, 2955, 2955, 3160], [3162, 3162, 3206, 3206, 3510], [3512, 3512, 3533, 3533, 3774], [3776, 3776, 3804, 3804, 5288], [5290, 5290, 5346, 5346, 5548]]}
{"id": "ssKcWz", "name": "Easy Shedr 387", "author": "Igger", "description": "Shader with no perspective. We're trying out the z-buffer.", "tags": ["zbuffer"], "likes": 0, "viewed": 170, "published": 3, "date": "1654717618", "time_retrieved": "2024-07-30T16:45:06.160262", "image_code": "#define myPi 3.141592654f\n#define Eps 1e-8\n#define maxZ 100.0\n\nconst int n = 3;\nvec3 colVec[n] = vec3[n](vec3(0.6, 0.6, 0.9), vec3(0.0, 0.8, 0.7), vec3(0.3, 0.1, 0.6));\nvec3 BGcol = vec3(1.0, 1.0, 1.0);\n//float zVec[n] = float[n](3.0, 2.0, 1.0);\n\nint sizes[n] = int[n](3, 3, 4), inds[n] = int[n](0, 3, 6); const int m = 10;\nvec2 polygonsXY[m]; float polygonsZ[m];\n\nvoid initPolygons(out vec2 polygonsXY[m], out float  polygonsZ[m], in float time){\n// 0 -- triangle\n    polygonsXY[0] = vec2(0.0, 0.0); polygonsZ[0] = 0.1; \n    polygonsXY[1] = vec2(1.0, 0.0); polygonsZ[1] = 0.1;\n    polygonsXY[2] = vec2(1.0, 1.0); polygonsZ[2] = 0.1;\n// 1 -- triangle\n    polygonsXY[3] = vec2(0.3, 0.2); polygonsZ[3] = 0.09;\n    polygonsXY[4] = vec2(0.7, 0.5); polygonsZ[4] = 0.11;\n    polygonsXY[5] = vec2(0.8, 0.9); polygonsZ[5] = 0.09;\n// 2 -- rotated square\n    float w = 2.0;\n    vec3 center = vec3(0.55, 0.5, 0.1 + 0.05*sin(time*w)); float r = 0.4;\n    int i; float j =0.0, phi = myPi/6.0;\n    float ang = 2.0*myPi/4.0; \n    vec3 tmpVec;\n    mat3 rot = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(phi), sin(phi)), vec3(0.0, -sin(phi), cos(phi)) );\n    for (i = 6; i < 9; i++){\n        tmpVec = rot*(r*vec3(cos(j*ang + time), sin(j*ang + time), 0.0)); \n        polygonsXY[i] = tmpVec.xy + center.xy;\n        polygonsZ[i] = tmpVec.z + center.z;\n        j = j + 1.0;\n    }\n    \n}\n\n\n\nint leftTurn(in vec2 a, in vec2 b, in vec2 c)\n{\n    float tmp = (c.x - a.x)*(b.y - a.y) - (c.y - a.y)*(b.x - a.x);\n    if (abs(tmp) < Eps) \n        return 0;\n    else \n        return tmp > 0.0 ? 1: -1;\n}\n\n\nbool inPolygon(in int ind0, in int size, in vec2 vert[m], in vec2 p) // vertices in counter clockwise order\n{\n    bool res = leftTurn(vert[ind0 + size-1], vert[ind0], p) <= 0; int i = ind0;\n    while(res && (i < ind0 + size -1))\n    {\n        res = res && (leftTurn(vert[i], vert[i+1], p) <= 0); i++;\n    }\n    return res;\n}\n\nfloat zInPlane(in vec3 a, in vec3 b, in vec3 c, in vec2 p) // z coordinate for (x,y) point of a plane (a-b, c-b)\n{\n    vec3 nrm = cross(a-b, c-b);\n    //float D = - dot(nrm, b);\n    if (abs(nrm.z) < Eps) return a.z;\n    else return (dot(nrm, b) - nrm.x*p.x - nrm.y*p.y)/nrm.z;\n}\n\n\n// vec3 normalize(vec3), vec3 cross(vec3, vec3) are predefined\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime, tmp; //iTime;\n    initPolygons(polygonsXY, polygonsZ, time);\n    //initColors(colVec, time);\n    vec3 col = BGcol; float z = maxZ; \n    int i;\n    for (i =0; i < n; i++){\n        if ( inPolygon(inds[i], sizes[i], polygonsXY, uv) ){\n            tmp = zInPlane(vec3(polygonsXY[inds[i]].x, polygonsXY[inds[i]].y, polygonsZ[inds[i]]), \\\n            vec3(polygonsXY[inds[i]+1].x, polygonsXY[inds[i]+1].y, polygonsZ[inds[i]+1]), \\\n            vec3(polygonsXY[inds[i]+2].x, polygonsXY[inds[i]+2].y, polygonsZ[inds[i]+2]), uv);\n            if (tmp < z){\n                z = tmp; col = colVec[i]; \n            }\n        }\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n//нужно 5 фигур 2 из которых вращаются , затем 5-угольник и кого-то из них в полосочку в зависимости от координат\n//по сути в полоску я могу сделать именно этот 5-угольник он и так градиентом, а вот еще однеу фигуру добавить хз как \n//и еще - используй тот где код свята это 123 ERR\n//НАПИШИ ЧТО-ТО(((\n//я создала новый проект new и сейчас там все делаю", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 447, 464, 1361], [1365, 1365, 1412, 1412, 1568], [1571, 1571, 1680, 1680, 1895], [1897, 1897, 2011, 2011, 2175], [2243, 2243, 2300, 2350, 3092]]}
{"id": "sdKcWz", "name": "shishka", "author": "lalalka228", "description": "triangles", "tags": ["triangles"], "likes": 0, "viewed": 188, "published": 3, "date": "1654716957", "time_retrieved": "2024-07-30T16:45:06.962118", "image_code": "#define myPi 3.141592654f\n#define Eps 1e-8\n#define maxZ 100.0\n\nconst int n = 4;\nvec3 colVec[n] = vec3[n](vec3(0.6, 0.1, 0.9), vec3(0.0, 0.8, 0.7), vec3(0.3, 0.1, 0.6),vec3(0.3, 0.1, 1.0));\nvec3 BGcol = vec3(1.0, 1.0, 1.0);\n//float zVec[n] = float[n](3.0, 2.0, 1.0);\n\nint sizes[n] = int[n](4, 3, 4, 6), inds[n] = int[n](0, 4, 7,11); const int m = 17;\nvec2 polygonsXY[m]; float polygonsZ[m];\n\nvoid initPolygons(out vec2 polygonsXY[m], out float  polygonsZ[m], in float time){\n// 0 -- triangle\n    polygonsXY[0] = vec2(0.0, 0.0); polygonsZ[0] = 2.1; \n    polygonsXY[1] = vec2(1.0, 0.0); polygonsZ[1] = 2.1;\n    polygonsXY[2] = vec2(0.9, 0.9); polygonsZ[2] = 5.1;\n    polygonsXY[3] = vec2(0.1, 0.9); polygonsZ[3] = 5.1;\n// 1 -- triangle\n    polygonsXY[4] = vec2(0.1*cos(time),0.5*sin(time)); polygonsZ[4] = 0.009;\n    polygonsXY[5] = vec2(0.5, 0.3); polygonsZ[5] = 0.009;\n    polygonsXY[6] = vec2(0.5, 0.9); polygonsZ[6] = 0.009;\n// 2 -- rotated square\n    float w = 2.0;\n    vec3 center = vec3(0.55, 0.5, 0.1 + 0.05*sin(time*w)); float r = 0.4;\n    int i; float j =0.0, phi = myPi/6.0;\n    float ang = 2.0*myPi/4.0; \n    vec3 tmpVec;\n    mat3 rot = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(phi), sin(phi)), vec3(0.0, -sin(phi), cos(phi)) );\n    for (i = 7; i < 11; i++){\n        tmpVec = rot*(r*vec3(cos(j*ang + time), sin(j*ang + time), 0.0)); \n        polygonsXY[i] = tmpVec.xy + center.xy;\n        polygonsZ[i] = tmpVec.z + center.z;\n        j = j + 1.0;\n    }\n    float ang2 = myPi/3.0;\n    \n    for (i = 11; i < 17; i++){\n        tmpVec = rot*(r*vec3(cos(j*ang2), sin(j*ang2), 0.0)); \n        polygonsXY[i] = tmpVec.xy + center.xy;\n        polygonsZ[i] = tmpVec.z + center.z+1.0;\n        j = j + 1.0;\n    }\n}\n\n\n\nint leftTurn(in vec2 a, in vec2 b, in vec2 c)\n{\n    float tmp = (c.x - a.x)*(b.y - a.y) - (c.y - a.y)*(b.x - a.x);\n    if (abs(tmp) < Eps) \n        return 0;\n    else \n        return tmp > 0.0 ? 1: -1;\n}\n\n\nbool inPolygon(in int ind0, in int size, in vec2 vert[m], in vec2 p) // vertices in counter clockwise order\n{\n    bool res = leftTurn(vert[ind0 + size-1], vert[ind0], p) <= 0; int i = ind0;\n    while(res && (i < ind0 + size -1))\n    {\n        res = res && (leftTurn(vert[i], vert[i+1], p) <= 0); i++;\n    }\n    return res;\n}\n\nfloat zInPlane(in vec3 a, in vec3 b, in vec3 c, in vec2 p) // z coordinate for (x,y) point of a plane (a-b, c-b)\n{\n    vec3 nrm = cross(a-b, c-b);\n    //float D = - dot(nrm, b);\n    if (abs(nrm.z) < Eps) return a.z;\n    else return (dot(nrm, b) - nrm.x*p.x - nrm.y*p.y)/nrm.z;\n}\n\n\n// vec3 normalize(vec3), vec3 cross(vec3, vec3) are predefined\nvec3 initColors2(in vec2  uv) {\nreturn vec3((uv.x),(uv.y),(uv.x)*(uv.y));}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime, tmp; //iTime;\n    initPolygons(polygonsXY, polygonsZ, time);\n    //initColors(colVec, time);\n    vec3 col = BGcol; float z = maxZ; \n    int i;\n    for (i =0; i < n; i++){\n        if ( inPolygon(inds[i], sizes[i], polygonsXY, uv) ){\n            tmp = zInPlane(vec3(polygonsXY[inds[i]].x, polygonsXY[inds[i]].y, polygonsZ[inds[i]]), \\\n            vec3(polygonsXY[inds[i]+1].x, polygonsXY[inds[i]+1].y, polygonsZ[inds[i]+1]), \\\n            vec3(polygonsXY[inds[i]+2].x, polygonsXY[inds[i]+2].y, polygonsZ[inds[i]+2]), uv);\n            if (tmp < z){\n            if (i==3)   col =initColors2( uv);else{\n                z = tmp; col = colVec[i]; }\n            }\n\n        }\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 391, 473, 490, 1709], [1713, 1713, 1760, 1760, 1916], [1919, 1919, 2028, 2028, 2243], [2245, 2245, 2359, 2359, 2523], [2526, 2589, 2620, 2620, 2663], [2667, 2667, 2724, 2774, 3570]]}
{"id": "7sVyWz", "name": "psychedelics - rainbow effect", "author": "Zyphery", "description": "Rainbow, my eyes hurt", "tags": ["rainbow"], "likes": 1, "viewed": 210, "published": 3, "date": "1654716665", "time_retrieved": "2024-07-30T16:45:07.717099", "image_code": "vec3 hue(float val) {\n    vec3 col;\n    float h = mod(val, 1.0);\n    float X = -abs(6.0 * mod(h, 1.0 / 3.0) - 1.0) + 1.0;\n    \n    if(h < 1.0 / 6.0)\n        col = vec3(1.0,X,0.0);\n    else if(h < 2.0 / 6.0)\n        col = vec3(X,1.0,0.0);\n    else if(h < 3.0 / 6.0)\n        col = vec3(0.0,1.0,X);\n    else if(h < 4.0 / 6.0)\n        col = vec3(0.0,X,1.0);\n    else if(h < 5.0 / 6.0)\n        col = vec3(X,0.0,1.0);\n    else\n        col = vec3(1.0,0.0,X);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n\n    // Time varying pixel color\n    vec3 col = hue(0.1 * iTime - .002 * length((iResolution.xy / 2.0) - uv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 474], [476, 476, 533, 588, 782]]}
{"id": "ssKyWz", "name": "Box Signed Distance Field (SDF)", "author": "Zyphery", "description": "signed distance field of a box", "tags": ["sdf"], "likes": 0, "viewed": 236, "published": 3, "date": "1654715851", "time_retrieved": "2024-07-30T16:45:08.501003", "image_code": "float distToBox(vec2 pos, float rotation, vec2 size, vec2 uv) {\n    float cr = cos(rotation);\n    float sr = sin(rotation);\n    \n    uv -= pos;\n    uv = vec2(uv.x * cr - uv.y * sr, uv.x * sr + uv.y * cr);\n    \n    vec2 q = abs(uv) - size;\n    return length(max(q,0.0f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    \n    float b0 = distToBox(iMouse.xy, iTime, vec2(100,50), uv);\n    \n    vec3 col = vec3(sin(0.1 * b0));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKyWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 272], [274, 274, 331, 331, 498]]}
{"id": "fsKyDz", "name": "123ERRR", "author": "Igger", "description": "12345", "tags": ["12"], "likes": 0, "viewed": 163, "published": 3, "date": "1654707357", "time_retrieved": "2024-07-30T16:45:09.330785", "image_code": "#define myPi 3.141592654f\n#define Eps 1e-8\n#define maxZ 100.0\n\nconst int n = 4;\nvec3 colVec[n] = vec3[n](vec3(0.6, 0.6, 0.9), vec3(0.9, 0.1, 0.7), vec3(0.9, 0.9, 0.6),vec3(0.9, 0.9, 0.2));\nvec3 BGcol = vec3(0.5, 0.9, 1.0);\n//float zVec[n] = float[n](3.0, 2.0, 1.0);\n//век3 - цвет треугольника\nint sizes[n] = int[n](3, 3, 4,6), inds[n] = int[n](0, 3, 6,10); const int m = 16;\nvec2 polygonsXY[m]; float polygonsZ[m];\n\nvoid initPolygons(out vec2 polygonsXY[m], out float polygonsZ[m], in float time){\n// 0 — triangle\npolygonsXY[0] = vec2(0.0, 0.0); polygonsZ[0] = 0.1;\npolygonsXY[1] = vec2(1.0, 0.0); polygonsZ[1] = 0.1;\npolygonsXY[2] = vec2(1.0, 0.0); polygonsZ[2] = 0.1;\n// 1 — triangle\npolygonsXY[3] = vec2(0.3*cos(time), 0.9*cos(time)); polygonsZ[3] = 0.1;\npolygonsXY[4] = vec2(0.2*cos(time), 0.7*sin(time)); polygonsZ[4] = 0.11;\npolygonsXY[5] = vec2(0.6*cos(time), 0.2*cos(time)); polygonsZ[5] = 0.09;\n// 2 — rotated square\nfloat w = 2.0;\nvec3 center = vec3(0.55, 0.2, 0.1 + 0.05*sin(time*w)); float r = 0.2;\nint i; float j =0.0, phi = myPi/6.0;\nfloat ang = 2.0*myPi/4.0;\nvec3 tmpVec;\nmat3 rot = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(phi), sin(phi)), vec3(0.0, -sin(phi), cos(phi)) );\nfor (i = 6; i < 10; i++){\ntmpVec = rot*(r*vec3(cos(j*ang + time), sin(j*ang + time), .0));\npolygonsXY[i] = tmpVec.xy + center.xy;\npolygonsZ[i] = tmpVec.z + center.z;\nj = j + 1.0;\n}\n\n\n\n\n// 3 — 6angle\nang = myPi/3.0;\nfloat rr = 0.1;\nfor (i = 10; i < 16; i++){\ntmpVec = rot*(rr*vec3(cos(j+ang ), sin(j+ang), 0.1));\npolygonsXY[i] = tmpVec.xy + (center.xy + 0.1);\npolygonsZ[i] = tmpVec.z - center.z;\nj = j + 1.0;\ncolVec[3]=vec3(polygonsXY[i][0],polygonsXY[i][1],polygonsZ[i]);\n}\n\n\n\n;\n}\n\n\n\nint leftTurn(in vec2 a, in vec2 b, in vec2 c)\n{\nfloat tmp = (c.x - a.x)*(b.y - a.y) - (c.y - a.y)*(b.x - a.x);\nif (abs(tmp) < Eps)\nreturn 0;\nelse\nreturn tmp > 0.0 ? 1: -1;\n}\n\n\nbool inPolygon(in int ind0, in int size, in vec2 vert[m], in vec2 p) // vertices in counter clockwise order\n{\nbool res = leftTurn(vert[ind0 + size-1], vert[ind0], p) <= 0; int i = ind0;\nwhile(res && (i < ind0 + size -1))\n{\nres = res && (leftTurn(vert[i], vert[i+1], p) <= 0); i++;\n}\nreturn res;\n}\n\nfloat zInPlane(in vec3 a, in vec3 b, in vec3 c, in vec2 p) // z coordinate for (x,y) point of a plane (a-b, c-b)\n{\nvec3 nrm = cross(a-b, c-b);\n//float D = - dot(nrm, b);\nif (abs(nrm.z) < Eps) return a.z;\nelse return (dot(nrm, b) - nrm.x*p.x - nrm.y*p.y)/nrm.z;\n}\n\n\n// vec3 normalize(vec3), vec3 cross(vec3, vec3) are predefined\nvoid initColors(in float polygonsZ[m]) {\nfloat w = 2.0;\n\n\ncolVec[2] = vec3(polygonsZ[8]*15.5, 1.0, 411.7);\n\n}\n\n\n\n// vec3 normalize(vec3), vec3 cross(vec3, vec3) are predefined\nvec3 initColors2(in vec2 uv) {\nreturn vec3((uv.x),(uv.y),(uv.x)*(uv.y));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// Normalized pixel coordinates (from 0 to 1)\nvec2 uv = fragCoord/iResolution.xy;\nfloat time = iTime, tmp; //iTime;\ninitPolygons(polygonsXY, polygonsZ, time);\nvec3 col = BGcol; float z = maxZ;\nint i;\ninitColors( polygonsZ);\nfor (i =0; i < n; i++){\n\nif ( inPolygon(inds[i], sizes[i], polygonsXY, uv) ){\ntmp = zInPlane(vec3(polygonsXY[inds[i]].x, polygonsXY[inds[i]].y, polygonsZ[inds[i]]), \\\nvec3(polygonsXY[inds[i]+1].x, polygonsXY[inds[i]+1].y, polygonsZ[inds[i]+1]), \\\nvec3(polygonsXY[inds[i]+2].x, polygonsXY[inds[i]+2].y, polygonsZ[inds[i]+2]), uv);\nif (tmp < z){\nif (i==3) col =initColors2( uv);else{\nz = tmp; col = colVec[i]; }\n} }\n\n}\n\n// Output to screen\nfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 435, 516, 534, 1696], [1700, 1700, 1747, 1747, 1873], [1876, 1876, 1985, 1985, 2172], [2174, 2174, 2288, 2288, 2436], [2439, 2502, 2542, 2542, 2611], [2615, 2678, 2708, 2708, 2751], [2753, 2753, 2810, 2856, 3501]]}
{"id": "sd3yWS", "name": "Elliptical Torus", "author": "mla", "description": "An elliptical torus.See code for details, controls etc.", "tags": ["torus", "quartic", "elliptical"], "likes": 15, "viewed": 278, "published": 3, "date": "1654704727", "time_retrieved": "2024-07-30T16:45:10.294209", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Elliptical Torus\n//\n// Another nice quartic surface - a surface of revolution generated by\n// an ellipse, ie. an elliptical torus.\n//\n// Analytic solution to intersection & gradient. Calculation of\n// coefficients done mostly by Sage algebra.\n//\n// <mouse>: change view direction\n// <up/down>: zoom in/out\n// <left/right>: change torus radius\n// 'a': antialiasing\n// 'r': autorotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\n// Lighting\nvec3 light = vec3(1,1,-1);\nfloat ambient = 0.4;\nfloat diffuse = 0.6;\nfloat specular = 0.8;\nfloat specularpow = 10.0;\nvec3 specularcolor = vec3(1);\n\nfloat torusr = 1.0;\n\nint elliptotorus (vec3 p, vec3 d, out vec4 roots) {\n  // A = (b4*z14 + 2*b2*x12*z12 + 2*b2*y12*z12 + x14 + 2*x12*y12 + y14)\n  // B = 4*(b4*z0*z13 + b2*x12*z0*z1 + b2*y12*z0*z1 + b2*x0*x1*z12 + b2*y0*y1*z12 + x0*x13 + x12*y0*y1 + x0*x1*y12 + y0*y13)\n  // C = 2*(3*b4*z02*z12 + b2*x12*z02 + b2*y12*z02 + 4*b2*x0*x1*z0*z1 + 4*b2*y0*y1*z0*z1 - b4*z12 + b2*r2*z12 + b2*x02*z12 + b2*y02*z12 - b2*x12 - r2*x12 + 3*x02*x12 + x12*y02 + 4*x0*x1*y0*y1 - b2*y12 - r2*y12 + x02*y12 + 3*y02*y12)\n  // D = 4*(b4*z03*z1 + b2*x0*x1*z02 + b2*y0*y1*z02 - b4*z0*z1 + b2*r2*z0*z1 + b2*x02*z0*z1 + b2*y02*z0*z1 - b2*x0*x1 - r2*x0*x1 + x03*x1 + x0*x1*y02 - b2*y0*y1 - r2*y0*y1 + x02*y0*y1 + y03*y1)\n  // E = b4*z04 - 2*b4*z02 + 2*b2*r2*z02 + 2*b2*x02*z02 + 2*b2*y02*z02 + b4 - 2*b2*r2 + r4 + x04 - 2*b2*y02 - 2*r2*y02 + 2*x02*y02 + y04 - 2*(b2 + r2)*x02\n  float x0 = p.x, y0 = p.y, z0 = p.z;\n  float x02 = x0*x0, x03 = x02*x0, x04 = x02*x02;\n  float y02 = y0*y0, y03 = y02*y0, y04 = y02*y02;\n  float z02 = z0*z0, z03 = z02*z0, z04 = z02*z02;\n  float x1 = d.x, y1 = d.y, z1 = d.z;\n  float x12 = x1*x1, x13 = x12*x1, x14 = x12*x12;\n  float y12 = y1*y1, y13 = y12*y1, y14 = y12*y12;\n  float z12 = z1*z1, z13 = z12*z1, z14 = z12*z12;\n  float b2 = 0.25, b4 = b2*b2;\n  float r = torusr;\n  float r2 = r*r, r4 = r2*r2;\n  float A = x14 + y14 + b4*z14 + 2.0*(x12*y12 + b2*x12*z12 + b2*y12*z12);\n  float B = 4.0*(x0*x13 + y0*y13 + x0*x1*y12 + x12*y0*y1 + b4*z0*z13 + b2*x12*z0*z1 + b2*y12*z0*z1 + b2*x0*x1*z12 + b2*y0*y1*z12);\n  float C = 2.0*(3.0*b4*z02*z12 + b2*x12*z02 + b2*y12*z02 + 4.0*b2*x0*x1*z0*z1 + 4.0*b2*y0*y1*z0*z1 - b4*z12 + b2*r2*z12 + b2*x02*z12 + b2*y02*z12 - b2*x12 - r2*x12 + 3.0*x02*x12 + x12*y02 + 4.0*x0*x1*y0*y1 - b2*y12 - r2*y12 + x02*y12 + 3.0*y02*y12);\n  float D = 4.0*(b4*z03*z1 + b2*x0*x1*z02 + b2*y0*y1*z02 - b4*z0*z1 + b2*r2*z0*z1 + b2*x02*z0*z1 + b2*y02*z0*z1 - b2*x0*x1 - r2*x0*x1 + x03*x1 + x0*x1*y02 - b2*y0*y1 - r2*y0*y1 + x02*y0*y1 + y03*y1);\n  float E = b4*z04 - 2.0*b4*z02 + 2.0*b2*r2*z02 + 2.0*b2*x02*z02 + 2.0*b2*y02*z02 + b4 - 2.0*b2*r2 + r4 + x04 - 2.0*b2*y02 - 2.0*r2*y02 + 2.0*x02*y02 + y04 - 2.0*(b2 + r2)*x02;\n  return quartic(A,B,C,D,E,roots);\n}\n\nvec3 elliptotorusnormal (vec3 p) {\n  // b4*z4 + b4 - 2*b2*r2 + r4 + x4 + y4 - 2*(b2 + r2)*x2 - 2*(b2 + r2 - x2)*y2 - 2*(b4 - b2*r2 - b2*x2 - b2*y2)*z2\n  float x = p.x, y = p.y, z = p.z;\n  float x2 = x*x, x3 = x2*x;\n  float y2 = y*y, y3 = y2*y;\n  float z2 = z*z, z3 = z2*z;\n  float b2 = 0.25, b4 = b2*b2;\n  float r = torusr;\n  float r2 = r*r;\n  // b4*z4 + x4 + y4 - 2*(b2 + r2)*x2 - 2*(b2 + r2 - x2)*y2 - 2*(b4 - b2*r2 - b2*x2 - b2*y2)*z2\n  float dx = 4.0*x3 - 4.0*(b2 + r2)*x + 4.0*x*y2 + 4.0*b2*x*z2;\n  float dy = 4.0*y3 - 4.0*(b2 + r2 - x2)*y + 4.0*b2*y*z2;\n  float dz = 4.0*b4*z3 - 4.0*(b4 - b2*r2 - b2*x2 - b2*y2)*z;\n  return vec3(dx,dy,dz);\n}\n\nint dosurface(vec3 p0, vec3 r, out vec4 roots) {\n  return elliptotorus(p0,r,roots);\n}\n  \nvec3 donormal(vec3 p) {\n  return elliptotorusnormal(p);\n}\n  \nint solve(vec3 p0, vec3 r, float tmin, out vec4 roots) {\n  int nroots = dosurface(p0,r,roots);\n  // Sort the roots\n  if (nroots >= 2) {\n    if (roots.y < roots.x) roots.xy = roots.yx;\n  }\n  if (nroots >= 3) {\n    if (roots.z < roots.y) roots.yz = roots.zy;\n    if (roots.y < roots.x) roots.xy = roots.yx;\n  }\n  if (nroots >= 4) {\n    if (roots.w < roots.z) roots.zw = roots.wz;\n    if (roots.z < roots.y) roots.yz = roots.zy;\n    if (roots.y < roots.x) roots.xy = roots.yx;\n  }\n  return nroots;\n}\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*specularcolor;\n  return c;\n}\n\nvec3 scene(vec3 p0, vec3 r) {\n  float tmin = 0.0;\n  tmin = -dot(p0,r);\n  p0 += tmin*r;\n  vec4 roots;\n  vec3 color = vec3(0,0,0.1);\n  int nroots = solve(p0,r,-tmin,roots);\n  for (int i = nroots-1; i >= 0; i--) {\n    float t = roots[i];\n    if (t < -tmin) break;\n    vec3 p = p0+t*r;\n    vec3 n = donormal(p);\n    if (isnan(length(n))) continue;\n    if (dot(n,r) > 0.0) n = -n;\n    n = normalize(n);\n    vec3 basecolor = pow(abs(n),vec3(2.0));\n    float k = iTime;\n    //k += 10.0*atan(p.x,p.y)/PI; // Hum!\n    if (length(p.xy) > torusr) k = -k;\n    k += 10.0*p.z;\n    if (abs(k-round(k)) < 0.1) basecolor = vec3(0);\n    //if (abs(length(p)-sqrt(a)) < 0.01) basecolor = vec3(1,0,0);\n    //if (min(abs(p.x),min(abs(p.y),abs(p.z))) < 0.01) basecolor = vec3(0.5);\n    vec3 c = applylighting(basecolor,p,n,r);\n    float dist = t + tmin;\n    float fog = 1.0-smoothstep(0.0,100.0,dist);\n    //c *= fog;\n    color = mix(color,c,0.5);\n  }\n  return color;\n}\n\n// GUI related code starts here\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (!key(CHAR_R)) {\n    float t = iTime;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float scale = 1.0;\n  float camera = 2.0;\n  camera *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  torusr = 0.5;\n  torusr *= exp(0.1*float(keycount(KEY_LEFT)-keycount(KEY_RIGHT)));\n  //torusr += 0.99*sin(iTime);\n  \n  vec3 p = vec3(0.0, 0.0, -camera);\n  p = transform(p);\n  light = transform(light);\n  light = normalize(light);\n  int AA = 1;\n  if (key(CHAR_A)) AA = 2;\n  vec3 color = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 uv = scale*(2.0*(fragCoord.xy+vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv, 2.0);\n      r = transform(r);\n      r = normalize(r);\n      color += scene(p,r);\n    }\n  }\n  color /= float(AA*AA);\n  color = pow(color,vec3(0.4545));\n  if (alert) color.x = 1.0;\n  fragColor = vec4(color,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Debug\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nbool eq(float x, float y) {\n  return abs(x-y) < 1e-4;\n}\n\nbool eq(vec4 p, vec4 q) {\n  return eq(p.x,q.x) && eq(p.y,q.y) && eq(p.z,q.z) && eq(p.w,q.w);\n}\n\nbool eq(mat4 m, mat4 n) {\n  return eq(m[0],n[0]) && eq(m[1],n[1]) && eq(m[2],n[2]) && eq(m[3],n[3]);\n}\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81; // Dodgy approximation\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_X = 88;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    x1 = C/A; x2 = -x1;\n  } else {\n    x1 = C/r; x2 = r/A;\n  }\n  res = vec2(x1,x2);\n  return 2;\n}\n\nint quadratic(vec3 coeffs, out vec2 res) {\n  return quadratic(coeffs[0],coeffs[1],coeffs[2],res);\n}\n  \n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Solve: Ax^3 + Bx^2 + Cx + D == 0\n// Find one real root, then reduce to quadratic.\nint cubic(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  if (A == 0.0) {\n    X = 1e8; A = B; b1 = C; c2 = D;\n  } else if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq,x0;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    x0 = X - s*r;\n    if (x0 != X) {\n      X = x0;\n      for (int i = 0; i < 6; i++) {\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        if (dq == 0.0) break;\n        X -= (q/dq);\n      }\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n    }\n  }\n  res.x = X;\n  return 1 + quadratic(A,b1,c2,res.yz);\n}\n\n// Special wrapper for cubic function for solving quartic.\n// Find largest real root of x**3 + a*x**2 + b*x + c\nfloat qcubic(float a, float b, float c) {\n  vec3 res;\n  int nroots = cubic(1.0,a,b,c,res);\n  if (nroots == 1) return res.x;\n  else return max(res.x,max(res.y,res.z));\n}\n\nint quartic(vec4 coeffs, out vec4 res) {\n  float c1 = coeffs[0];\n  float c2 = coeffs[1];\n  float c3 = coeffs[2];\n  float c4 = coeffs[3];\n  float alpha = 0.5*c1;\n  float A = c2-alpha*alpha;\n  float B = c3-alpha*A;\n  float a,b,beta,psi;\n  psi = qcubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n  psi = max(0.0,psi);\n  a = sqrt(psi);\n  beta = 0.5*(A + psi);\n  if (psi <= 0.0) {\n    b = sqrt(max(beta*beta-c4,0.0));\n  } else {\n    b = 0.5*a*(alpha-B/psi);\n  }\n  int n0 = quadratic(1.0,alpha+a,beta+b,res.xy);\n  int n1 = quadratic(1.0,alpha-a,beta-b,res.zw); \n  if (n0 == 0) res.xy = res.zw;\n  return n0+n1;\n}\n\nint quartic(float A, float B, float C, float D, float E, out vec4 roots) {\n  vec4 coeffs = vec4(B,C,D,E)/A;\n  return quartic(coeffs,roots);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3yWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[770, 770, 821, 1600, 2927], [2929, 2929, 2963, 3079, 3576], [3578, 3578, 3626, 3626, 3663], [3667, 3667, 3690, 3690, 3724], [3728, 3728, 3784, 3784, 4224], [4226, 4226, 4286, 4286, 4523], [4525, 4525, 4554, 4554, 5471], [5473, 5505, 5532, 5532, 5876], [5878, 5878, 5935, 5935, 6733]]}
{"id": "NsKcWz", "name": "Menger Sponge Fractal 2D", "author": "Hitthesurf", "description": "A fractal of a 2D Menger Sponge\nBut when iterations are high strange visual effects occur.", "tags": ["2dfractalmengersponge"], "likes": 1, "viewed": 212, "published": 3, "date": "1654703868", "time_retrieved": "2024-07-30T16:45:11.032235", "image_code": "float its = 7.0; //Iterations\n\nfloat sdSquare(in vec2 p)\n{\n    vec2 d = abs(p)-vec2(0.5,0.5);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat map(in vec2 p)\n{\n    float sd = sdSquare(p);\n    for (float it = 1.; it < its; it++)\n    {\n        vec2 mod_d = mod(p*pow(3.,it)+1.5,3.)-1.5;\n        float d = sdSquare(mod_d);\n        sd = max(sd, -d);\n    }\n    return sd;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)y\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    //rotate\n    float th = iTime*0.5;\n    mat2 Rot = mat2(cos(th),sin(th),-sin(th), cos(th));\n    uv = Rot*uv;\n    \n    // Output to screen\n    fragColor = vec4(smoothstep(0.0005,-0.0005,map(uv)),0.0,0.0,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 58, 58, 150], [153, 153, 175, 175, 385], [388, 388, 445, 501, 778]]}
{"id": "ssycDR", "name": "Pseudo Realtime Path Tracing", "author": "Shane", "description": "Using a pseudo path tracing technique to produce a simple realtime scene lit up with multiple emitters.", "tags": ["global", "illumination", "tracing", "realtime", "path", "quad", "faux", "emissive"], "likes": 134, "viewed": 3817, "published": 3, "date": "1654695877", "time_retrieved": "2024-07-30T16:45:12.022587", "image_code": "/*\n\n    Pseudo Realtime Path Tracing\n    ----------------------------\n    \n    See \"Buffer A\" for an explanation.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // The other buffer has a maximum Y-resolution of 540 set, which \n    // means any pixels outside that are not rendered. On a 1980x1080\n    // fullscreen resolution, this means roughly a quarter of the pixels\n    // are rendered, which is a huge saving. Of course, this also means\n    // that the scene needs to be upscaled, which will make things less\n    // crisp, but you can't have everything. :)\n    //\n    // By the way, this tip came from Shadertoy user, Spalmer, who has\n    // a heap of interesting work for anyone interested:\n    // https://www.shadertoy.com/user/spalmer\n    //\n    float maxRes = 540.;\n    vec2 uv = fragCoord/iResolution.xy;\n    // If the resolution exceeds the maximum, upscale.\n    if(iResolution.y>maxRes) uv = (uv - .5)*maxRes/iResolution.y + .5;\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, uv);\n    \n    // I should probably tone map here, but the lighting isn't exactly\n    // realistic, plus I like the contrast here.\n\n    // Rough gamma correction and screen presentation.\n    fragColor = pow(col, vec4(1./2.2));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Pseudo Realtime Path Tracing\n    ----------------------------\n    \n    Using a pseudo path tracing technique to produce a simple realtime scene \n    lit up with multiple emitters. Basically, this was an excuse to play \n    around with pretty colors. :)\n    \n    At this stage, I'm sure most have seen those cool looking faux realtime \n    path traced examples at demo competitions and on Shadertoy. All of them\n    use a simple trick, which I'm sure has been around for ages, but I first\n    saw it in Shadertoy user W23's \"Path Racer\" example.\n    \n    Path tracing involves multiple bounces with random surface reflections \n    based on surface properties. The results are great -- fuzzy reflections,\n    soft lighting, shadows, etc, but require a heap of random samples to look\n    right. Regular purely reflected multiple bounce examples require just the \n    one sample, but look too sharp and unnatural.\n    \n    This particular example uses random surface reflections, but restricts the\n    randomness to a fairly narrow cone-like domain around the purely reflected\n    ray. That way, you're still getting the fuzzy shadows, lights, etc from\n    the surrounding scene. However, due to the narrowness of the random spread\n    around the rays, fewer samples are required for things to converge.\n    \n    The resultant lighting is not entirely realistic, but it looks nice. The \n    weird bounce angles can also be mitigated by using small tiles with \n    variable roughness values. Because of the narrow beams used, smaller \n    roughness values tend to look better, which is fine by me, because it \n    makes everything look more sparkly. :)\n    \n    Geometrically speaking, the scene is about as basic as it gets. The tiling \n    was made up on the spot and contains random emitters, which act as multiple \n    light sources. The multi-emitter color bleeding effect would be near \n    impossible to emulate using cheaper Blinn-Phong methods. By the way, I \n    settled on the \"Organic 2\" texture, but it works with others. I almost went\n    with the \"Stars\" texture, which gives things a slight planetarium feel.\n    \n    \n    \n    Other examples:\n    \n    // A lot of the realtime path tracing demos out there\n    // are based on elements from this example.\n    past racer by jetlag - w23\n    https://www.shadertoy.com/view/Wts3W7\n\n    // Simple, but georgeous lighting and colors.\n\tCorridor Travel - NuSan\n    https://www.shadertoy.com/view/3sXyRN\n\n*/\n\n\n// Sample number and blend number: The trick is to find a balance between the\n// two, or use a faster computer. :)\n\n// Number of samples: My computer can handle more. If yours is struggling, you \n// can lower this. Naturally, sample number is proportional to noise quality.\n#define sampNum 16\n\n// The blended samples per frame: Higher numbers give the impression of more\n// samples, which boosts quality. However, there's a price to pay, and that's \n// ghosting effects. Larger numbers will result in noticeable ghosting.\n#define blendNum 4.\n\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n\n// Random seed.\nvec2 seed = vec2(.13, .27);\n\n// Vec2 to vec2 hash function.\nvec2 hash22() {\n    \n    seed = fract(seed + vec2(.7123, .6247));\n     \n    return fract(sin(vec2(dot(seed.xy, vec2(12.989, 78.233)), dot(seed.xy, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n\n/*\n// Vec2 to vec3 hash function.\nvec3 hash23(){\n    \n    seed = fract(seed + vec2(.7123, .6247));\n     \n    return fract(sin(vec3(dot(seed.xy, vec2(12.989, 78.233)), dot(seed.xy, vec2(39.687, 78.233)),\n                          dot(seed.xy, vec2(41.898, 57.263))))*vec3(43758.5453, 23421.6361, 28234.8477));\n}\n*/\n\n// IQ's box routine.\nfloat sBox(in vec2 p, in vec2 b, float r){\n\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n\n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir( in float seed, in vec3 n){\n\n    vec2 rnd = hash22();\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n\n\n\n// Sphere normal.\nvec3 sphereNorm(vec3 p, float id, vec4 sph){\n   \n    return (p - sph.xyz)/sph.w; \n    \n}\n \n// Hitting a number of walls from the inside: You could simply raytrace four\n// planes, but this is a little more concise. I was too lazy to write my own\n// routine, so quickly adapted a working one (sadly, not many of those around) \n// from one of PublicIntI's examples. At some stage, I'll get in amongst it and \n// rewrite one, or find one of my older routines. Alternatively, if someone\n// knows of a concise reliable function or sees a way to tidy the following up, \n// feel free to let me know. :)\n//\n// crystal exhibit(pathtraced) - public_int_i \n// https://www.shadertoy.com/view/wljSRz\n//\n// Ray-box intersection: The function takes in the ray origin (offset if needed),\n// the unit direction ray and the box dimensions, then returns the distance and \n// normal.\n//\nvec4 boxIntersect(vec3 ro, vec3 rd, vec3 dim) {\n\n    const float maxT = 1e8;\n \n    vec3 minD = (ro + dim)/rd, maxD = (ro - dim)/rd;\n\tminD = -(minD - step(vec3(-1e-6), minD)*(minD + maxT));\n\tmaxD = -(maxD - step(vec3(-1e-6), maxD)*(maxD + maxT));\n\tminD = min(minD, maxD);\n    \n    // Result: Distance and normal.\n    vec4 res = vec4(maxT, 0, 0, 0);\n\n    // Performing some ray-plane intersections, modified to handle\n    // two planes at once. I'd imagine you could cleverly combine this\n    // into just one test, but I'm not clever, so I'll leave that to \n    // someone else. :D\n     \n    // We don't need the left and right walls for this example.\n    //if (minD.x<maxT){\n        //vec2 pd = abs(ro.zy + rd.zy*minD.x) - dim.zy;\n        //if (max(pd.x, pd.y) < 0.) res = vec4(minD.x, -sign(rd.x), 0, 0);\n    //}\n    \n    // Top and bottom surfaces, or ceiling and floor, if you prefer.\n    if (minD.y<maxT){\n        vec2 pd = abs(ro.xz + rd.xz*minD.y) - dim.xz;\n        if (max(pd.x, pd.y) < 0.) res = vec4(minD.y, 0., -sign(rd.y), 0.);\n    }\n    \n    // Front and back walls.\n    if (minD.z<maxT){\n        vec2 pd = abs(ro.xy + rd.xy*minD.z) - dim.xy;\n        if (max(pd.x, pd.y) < 0.) res = vec4(minD.z, 0., 0., -sign(rd.z));\n       \n    }\n    \n    // Return the distance and normal.\n    return res;\n}\n \n \n// Sphere intersection: Pretty standard, and adapted from one\n// of IQ's formulae.\nvec2 sphereIntersect(in vec3 ro, in vec3 rd, in vec4 sph){\n\n    vec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n    if(b > 0.) return vec2(1e8, 0.);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif(h<0.) return vec2(1e8, 0.);\n\treturn vec2(-b - sqrt(h), 1.); \n    \n}\n\n\n// Sphere position and radius.\nconst vec4 sph4 = vec4(0, -.32, 1.35, .68);\n\n// Hacking in a normal for the box equation.\nvec3 boxNrm;\n\n// Scene normal logic: Not that exciting for this example. :)\nvec3 getNorm(vec3 p, float id){\n    \n    return (id<.5)? sphereNorm(p, id, sph4) : boxNrm; \n}\n\n\n// Intersection logic for all objects.\nvec3 intersect(vec3 ro, vec3 rd){\n    \n    // Containers for two objects. Usually there'd be more.\n    vec2[2] q;\n    \n    // The sphere.\n    q[0] = sphereIntersect(ro, rd, sph4);//vec2(1e5);//\n    //q[0].x = 1e5;\n \n    // The box tube object, or 4 walls at once, if you prefer. :)\n    vec4 bx = boxIntersect(ro - vec3(0, 1, -.5), rd, vec3(1e8, 2, 3.5));\n    q[1] = vec2(bx.x, 1);\n    boxNrm = bx.yzw; \n   \n    \n    // Returning the object distance, a hit ID (inside surface, etc, and redundant \n    // for this example) and the object ID used for materials and so forth.\n    return q[0].x<q[1].x? vec3(q[0], 0) : vec3(q[1], 1);\n    \n    /*\n    // For more objects, you need to do a little more work.\n    vec3 d = vec3(1e5);\n    \n    for(int i = 0; i<2; i++){\n       if(q[i].x< d.x) d = vec3(q[i], i);\n    }\n        \n    return d;\n    */\n    \n}\n\n// The wall and floor pattern, which is just something quick and effective.\n// It's an offset row square grid pattern with some random subdivision.\nvec3 distField(vec2 p){\n    \n    // Scale.\n    vec2 sc = vec2(1)/5.;//vec2(6./5., 4./5.)/5.;\n    \n    // Edge width.\n    const float ew = .0125;\n    \n    vec2 q = p;\n    // Partitioning into cells and providing the local cell ID\n    // and local coordinates.\n    //p.x += floor(hash21(floor(p.yy/sc.yy))*1.9999)/2.*sc.x;\n    // Offset alternate rows.\n    if(mod(floor(p.y/sc.y), 2.)<.5) p.x += sc.x/2.;\n    // Cell ID and local coordinates.\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n    \n    // Random subdivision.\n    if(hash21(ip + .1/sc)<.5){\n        sc /= 2.;\n        p = q;\n        ip = floor(p/sc);\n        p -= (ip + .5)*sc;\n         \n        /*\n        // Extra subdivision.\n        if(hash21(ip + .1/sc)<.666){\n            sc /= 2.;\n            p = q;\n            ip = floor(p/sc);\n            p -= (ip + .5)*sc;\n             \n        }*/\n    }     \n    \n    // Rounded square.\n    float sh = sBox(p, sc/2. - ew, .15*sc.x);//1.5*sc.x*sc.x\n    //float sh = length(p) - sc.x/2. + ew;\n \n    // Producing a rounded circle.\n    float d = sh; \n    \n    // Putting a hole in it just to break things up.\n    //d = max(d, -(length(p) - .2*sc.x));\n    \n    // Rings.\n    //d = abs(d + .125*sc.x) - .125*sc.x;\n    \n    // Returning the distance and local cell ID. Note that the \n    // distance has been rescaled by the scaling factor.\n    return vec3(d, ip*sc);\n}\n\n// IQ's signed square formula with some roundness thrown in. \nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\n// I have a much better version of this that I'll have to find.\nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);\n    \n}\n\n \n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    \n    // Setting a maximum resolution, then upscaling. I picked up this tip when\n    // looking at one of Spalmer's examples, here:\n    // https://www.shadertoy.com/view/sdKXD3\n    float maxRes = 540.;\n    float iRes = min(iResolution.y, maxRes);\n    //ivec2 iR = ivec2(fragCoord);\n    //if(iR.y > 0 || iR.x>3){\n    fragColor = vec4(0, 0, 0, 1);\n    vec2 uv2 = abs(fragCoord - iResolution.xy*.5) - iRes/2.*vec2(iResolution.x/iResolution.y, 1.);\n    if(any(greaterThan(uv2, vec2(0)))) return;  // if(uv2.x>0. || uv2.y>0.) return;\n    //} \n    \n    float sf = 1./iResolution.y;\n        \n    // Screen pixel coordinates.\n    vec2 seed0 = fract(iTime/vec2(111.13, 57.61))*vec2(-.143, .457);\n    vec2 uv0 = (fragCoord - iResolution.xy*.5)/iRes;\n    \n  \n    float FOV = 1.; // FOV - Field of view.\n    vec3 ro = vec3(0, .25, -2);\n    // \"Look At\" position.\n    vec3 lk = ro + vec3(0, -.01, .25);\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n    // Camera.\n    mat3 mCam = mat3(rgt, up, fwd);\n    mCam *= rot(vec3(0, .05, 0)); \n    mCam *= rot(vec3(0, 0, -sin(iTime/6.)*.125)); \n    \n    // Accumulative color.\n    vec3 aCol = vec3(0);\n    \n    \n    for(int j = min(0, iFrame); j<sampNum; j++){\n        \n        // Seed value and jitter.\n        seed = uv0 + seed0 + vec2(j*57, j*27)/1321.;\n        vec2 jit = hash22()*2. - 1.;\n        \n        // Jittered UV coordinate.\n        vec2 uv = uv0 - jit/iResolution.y;\n\n        // Using the above to produce the unit ray-direction vector.\n        vec3 rd = mCam*normalize(vec3(uv, 1./FOV));\n\n        // Camera position. Initially set to the ray origin.\n        vec3 cam = ro;\n        // Surface postion. Also initially set to the ray origin.\n        vec3 sp = ro;\n\n        vec3 col = vec3(0);\n        \n        // Emissive, throughput and sample colors.\n        vec3 emissive = vec3(0);\n        vec3 through = vec3(1);\n        vec3 sCol = vec3(0);\n        \n        // Fog.\n        float fogD = 1e8;\n       \n        \n        // Just four bounces. More looks better, but the extra randomess\n        // requires more samples. For static scenes, that's not a problem,\n        // but this is a realtime one.\n        for(int i = min(0, iFrame); i<4; i++){\n\n            \n            vec3 scene = intersect(sp, rd); // Scene intersection.\n\n            float t = scene.x; // Scene distance.\n            float retVal = scene.y; // Redundant here, but used when refraction is involved.\n            float id = scene.z;// Object ID.\n            \n            // Set the fog distance on the first pass.\n            if(i==0) fogD = t;\n\n            sp += rd*t; // Advance the ray position.\n\n  \n            if(t<1e8){\n\n                \n                vec3 sn = getNorm(sp, id); // Normal.\n\n                vec3 oCol = vec3(0), emissive = vec3(0); // Object color, and emissivity.\n\n                emissive = vec3(0);\n                float rough = 0.;\n\n               \n                if(id<.5) { \n                   \n                    // Placing an offset subdivided grid pattern on the sphere,\n                    // then randomly lighting up random cells.\n \n                    // Texture coordinates.\n                    vec3 txP = sp - sph4.xyz;\n                    // Rotation.\n                    txP.xy *= rot2(-3.14159/12.);\n                    txP.xz *= rot2(-iTime/4.);\n                    \n                    // Using spherical coordinates to put some latitudinal squares\n                    // around the longitudinal direction... Not much different to the\n                    // way you'd put a square grid on a plane, but with spherical\n                    // coordinates.\n                    \n                    float aNum = 32.; // Scale.\n                    \n                    // Spherical longitudinal and latitudinal angles.\n                    vec2 sphA = vec2(atan(txP.z, txP.x), atan(length(txP.xz), txP.y))/6.2831;\n                    vec2 sphID = (floor(sphA*aNum) + .5)/aNum;\n                    \n                    // Offsetting alternate rows just for fun.\n                    if(mod(sphID.y*aNum - .5, 2.)<.5){\n                        \n                        sphA.x = fract(sphA.x + .5/aNum);\n                        // The above is the same as:\n                        //txP.xz *= rot2(3.14159/aNum);\n                        //sphA.x = atan(txP.z, txP.x)/6.2831;\n                        //sphID.x = (floor(sphA.x*aNum) + .5)/aNum;\n                        sphID.x = (floor(sphA.x*aNum) + .5)/aNum;\n                    }\n                    \n                    // Original scale and latitudinal dimension.\n                    float aNum0 = aNum, y0 = sphID.y;\n                    \n                    // Local X and Y square grid coordinates.\n                    vec2 sph = mod(sphA, 1./aNum) - .5/aNum;\n                  \n                    // Random subdivision.\n                    if(hash21(sphID + .3)<.5 && abs(y0 - .25)<4./aNum/2.){\n                        aNum *= 2.;\n                        sph = mod(sphA, 1./aNum) - .5/aNum;\n                        sphID = (floor(sphA*aNum) + .5)/aNum;\n                    } \n                    \n                    \n                    // Rounded square.\n                    float d = sBoxS(sph, vec2(.5/aNum) - .0025, .15/aNum);\n                    // Distance field isoline boundary.\n                    d = smoothstep(0., sf, d);\n\n                    \n                    // Render the pattern onto the sphere.\n                    oCol = mix(vec3(1), vec3(.1), d);\n                    \n                    // Emissivity.\n                    // Using a texture to color the emissive lights.\n                    vec3 tx = texture(iChannel1, sphID + iTime/128.).xyz; tx *= tx;\n                    // Fade out emissivity higher up the walls.\n                    float st = clamp(sp.y/1.25 - 1., 0., 1.);\n                    float rnd = smoothstep(st, 1., dot(tx, vec3(.299, .587, .114)));\n              \n        \n                    // Emissivity.\n                    emissive = vec3(0);\n                    // Color a limited set of bands around the equator.\n                    //if(abs(b0 - .25)<6./aNum0/2.) { emissive = oCol*(rnd*.99 + .01)*2.;  }\n                    if(abs(y0 - .25)<4./aNum0/2.) { emissive = oCol*tx*tx*rnd*16.;  }\n                    emissive = mix(emissive, vec3(0), d);\n                    emissive = mix(emissive, emissive.zyx, clamp((sp.y + .5)*3., 0., 1.));\n                    \n                    \n                    // Roughness.\n                    rough = hash21(vec2(sphID.x*aNum, sphID.y) + .23)*.5; //(clamp(.5 - d3.x/.2, 0., 1.))*\n                \n               }\n               else {\n\n                   \n                    // Producing a wall and floor pattern, coloring it, and using\n                    // parts to act as emitters.\n                    \n                    // Back wall or not.\n                    float sgn = (abs(sn.z)>.5)? 1. : -1.;\n                    \n                    // UV coordinates for the walls and floors.\n                    vec2 uv = sgn>.5? sp.xy : abs(sn.x)>.5? sp.yz : sp.xz;\n\n                    // Distance field pattern:\n                    // Returns the distance field and cell ID.\n                    vec3 d3 = distField(uv);\n                    // Distance field isoline boundary.\n                    d3.x = smoothstep(0., sf, d3.x);\n \n                    // Render the pattern on the walls, ceiling and floor.\n                    oCol = mix(vec3(1), vec3(.1), d3.x);\n                    \n                    // Emissivity.\n                    // Using a texture to color the emissive lights.\n                    vec3 tx = texture(iChannel1, d3.yz/16. - vec2(-1, 2)*iTime/64.).xyz; tx *= tx;\n                    // Fade out emissivity higher up the walls.\n                    float st = clamp(d3.z/1.25 - 1., 0., 1.);\n                    float rnd = smoothstep(st, 1., dot(tx, vec3(.299, .587, .114)));\n                    if(sgn<.5) rnd = 0.; // No lights on the floor or ceiling.\n                    //if(sn.z>.5) rnd = 0.;\n                    // Pattern based emissivity -- It doesn't always have to be object based.\n                    emissive = mix(oCol*tx*tx*rnd*16., vec3(0), d3.x);\n                    emissive = mix(emissive, emissive.zyx, clamp(sp.y, 0., 1.));\n                    \n                    // Roughness.\n                    rough = hash21(d3.yz + .1)*.5; //(clamp(.5 - d3.x/.2, 0., 1.))*\n \n                  \n                }\n                \n                \n                // I definitely like the more natural way in which colors are applied\n                // when rendering this way. We only add surface color when it's been\n                // hit by a ray that has visited a light source at some point.\n                sCol += emissive*through;\n                // Applying this bounce's color to future bounces. For instance, if we\n                // hit a pink emitter then hit another surface later, that surface will\n                // incorporate a bit of pink into it.\n                through *= oCol;\n\n\n                vec3 ref = reflect(rd, sn); // Purely reflected vector.\n                vec3 rrd = cosDir(0., sn); // Random half hemisphere vector.\n                //vec3 rrd = normalize(hash23() - .5); // Less evenly distributed.\n\n\n                // Mimicking surface inconsistancies with fuzzy reflections.\n                // Rougher surfaces have a greater chance of randomly reflecting at any direction\n                // and smoother surfaces are more likely to purely reflect.\n                //float rChance = step(rough, hash21(uv + vec2(i*277, j*113) + fract(iTime*.977 + .137)));\n                //rd = (mix(rrd, ref, rChance));\n                //rd = normalize(mix(ref, rrd, rough));\n                rd = normalize(ref + rrd*rough);\n                if(dot(rd, sn)<0.) rd = -rd; // Not sure this line really matters.\n\n\n                sp += sn*1e-5;\n                //rd = ref; // Pure reflection override. Not as effective at all.\n\n            } \n            \n            \n             if(aCol.x>1e5) break; // Attempting to reduce compile time. \n        }\n        \n        // Applying some fog, if necessary. You don't actually see this, but\n        // I want it there for completeness.\n        sCol = mix(vec3(0), sCol, 1./(1. + fogD*fogD*.02));\n\n        \n        // Accumulate the sample color.\n        aCol += sCol;\n        \n        if(sCol.x>1e5) break; // Attempting to reduce compile time.\n        \n        \n    }\n    \n    // Average color over all samples.\n    aCol /= float(sampNum);\n    \n   \n    /////\n    \n\n    \n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./blendNum; \n    fragColor = mix(preCol, vec4(clamp(aCol, 0., 1.), 1), blend);\n    \n    // No reprojection or temporal blur, for comparisson.\n    //fragColor = vec4(max(aCol, 0.), 1);\n    \n}", "buffer_a_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssycDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 177, 772, 1271]]}
{"id": "NdKyDR", "name": "Webcam Glitch", "author": "leon", "description": "I'm about to show off for my next videoconference", "tags": ["glitch", "webcam"], "likes": 21, "viewed": 1363, "published": 3, "date": "1654695757", "time_retrieved": "2024-07-30T16:45:12.810481", "image_code": "// Webcam Glitch\n// By Leon Denise 08-06-2022\n// Simple and handy glitch effect for digital screen\n\nvec3 hash33(vec3 p3) // Dave Hoskins https://www.shadertoy.com/view/4djSRW\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // zoom out\n    uv = (uv-.5)*1.1+.5;\n    \n    // animation\n    float speed = 10.;\n    float t = floor(iTime*speed);\n    \n    // randomness\n    vec2 lod = iResolution.xy/hash21(t)/200.;\n    vec2 p = floor(uv*lod);\n    vec3 rng = hash33(vec3(p,t));\n    \n    // displace uv\n    vec2 offset = vec2(cos(rng.x*6.283),sin(rng.x*6.283))*rng.y;\n    float fade = sin(fract(iTime*speed)*3.14);\n    vec2 scale = 50. / iResolution.xy;\n    float threshold = step(0.9, rng.z) ;\n    uv += offset * threshold * fade * scale;\n    \n    // chromatic abberation\n    vec2 rgb = 10./iResolution.xy * fade * threshold;\n    fragColor.r = texture(iChannel0, uv+rgb).r;\n    fragColor.g = texture(iChannel0, uv).g;\n    fragColor.b = texture(iChannel0, uv-rgb).b;\n    fragColor.a = 1.0;\n    \n    // crop\n    fragColor.rgb *= step(0.,uv.x) * step(uv.x,1.) * step(0.,uv.y) * step(uv.y,1.);\n    \n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 176, 176, 300], [301, 301, 323, 323, 451], [453, 453, 510, 510, 1425]]}
{"id": "ssGcDR", "name": "more objects and shadow", "author": "fl0a1e", "description": "try to render Multiple objects\nand apply soft shadow & AO to render", "tags": ["sdf", "shadow", "geometry"], "likes": 5, "viewed": 231, "published": 3, "date": "1654693125", "time_retrieved": "2024-07-30T16:45:13.557484", "image_code": "// \n// Created by fl0a1e 06/08/2022\n// \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// sdf from shaders by inigo quilez, https://iquilezles.org/articles/distfunctions/\n\n#define PI 3.14159265359\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION  0.001\n\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y + 0.3;\n}\n\nfloat sdSphere( vec3 p, float r, vec3 offset)\n{\n    return length(p - offset)-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// min\nfloat opU( float a, float b )\n{\n    return (a < b) ? a : b;\n}\n\nfloat sdSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat map( vec3 p )\n{\n    float d = sdSphere(p, .3, vec3(2.*sin(iTime),0.,0.));\n    d = sdSmoothUnion( d, sdTorus(p + vec3(0., .1, 0. ), vec2(0.8,0.2)), 0.2);\n    d = sdSmoothUnion(d, sdSphere(p, .3, vec3(0. , 0., 2.*cos(iTime))), 0.2);\n    \n    d = sdSmoothUnion(d, sdBoxFrame(p - vec3(2., 0., 0.), vec3(0.3,0.3,0.3), 0.03), .1);\n    d = sdSmoothUnion(d, sdBoxFrame(p - vec3(0., 0., -2.), vec3(0.3,0.3,0.3), 0.03), .1);\n    d = sdSmoothUnion(d, sdBoxFrame(p - vec3(-2., 0., 0.), vec3(0.3,0.3,0.3), 0.03), .1);\n    d = sdSmoothUnion(d, sdBoxFrame(p - vec3(0., 0., 2.), vec3(0.3,0.3,0.3), 0.03), .1);\n    d = opU(d, sdPlane(p));\n    return d;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nfloat raymarch( vec3 ro, vec3 rd)\n{\n    float dist = 0.0;\n\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = ro + rd * dist;\n        float d = map(p);\n        if(d < 0.001 || d > MAX_DIST) break;\n        dist += d;\n    }\n\n\n    return dist;\n}\n\n\nfloat calcAO( vec3 pos, vec3 nor)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++)\n    {\n        float h = .01 + 0.015 * float(i);\n        float d = map(pos + nor * h);\n        occ = (h - d) * sca;\n        sca *= .95;\n        if( occ > 0.35 ) break;\n    }\n    \n    return clamp( 1.0 - 5.0*occ, 0.1, 1.0 );\n}\n\n\nfloat calcSoftshadow( vec3 ro, vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = .02;\n    for( int i = 0; i < 24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        float s = smoothstep(0.0, 1.0, clamp(k*h/t,0.0,1.0));\n        res = min( res, s );\n        t += clamp( h, 0.02, 0.2 );\n        if( res < 0.004 || t > 2.5 ) break;\n    }\n    return clamp( res, 0.2, 1.0 );\n}\n\n\nmat3 camera(vec3 campos, vec3 camtar)\n{\n    float roll = 0.0;\n    vec3 cw = normalize(camtar - campos); // camera watch\n    vec3 cr = normalize(cross(cw, vec3(sin(roll), cos(roll), 0.0))); // camera right\n    vec3 cu = normalize(cross(cr, cw));   // camera up\n    \n    return mat3(cr, cu, -cw);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    // background\n    vec3 col;\n    \n    // raymarch\n    float d = raymarch(ro, rd);\n    \n    if(d > MAX_DIST)\n    {\n        col = vec3(.4, .5, .9);\n    }\n    else // if hit something\n    {\n        vec3 pos = ro + rd * d;\n        vec3 nor = calcNormal(pos);\n        \n        float ao = calcAO(pos, nor);\n        \n        // sun\n        {\n            vec3 sunPos = vec3(13., 7., 5.);\n            vec3 ld = normalize(sunPos - pos);\n            float dif = clamp( dot( nor, ld ), 0.0, 1.0 );\n            // shadow\n            pos += nor * PRECISION * 2.0; // add offset\n            dif *= calcSoftshadow(pos, ld, 8.0);\n            \n            \n            float spe = pow( clamp( dot( nor, ld ), 0.0, 1.0 ),16.0);\n            spe *= dif;\n            spe *= 0.04+0.96*pow(clamp(1.0-dot(ld, sunPos),0.0,1.0),5.0);\n            \n            col += dif * vec3(.6, .6, 1.);\n        }\n        \n        \n        col *= ao;\n        \n        \n    }\n    \n    // fog\n    col = mix(col, vec3(.4, .5, .9), 1.0 - exp(-0.0001 * d * d * d));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.x;\n    \n    float time = iTime*.2;\n    vec3 ro = vec3(0.0, 2.0, 10.0);\n    vec3 camtar = vec3(0.0, 0.0, 0.0);\n    float cameraRadius = 10.;\n    ro.x = cameraRadius * cos(time) + camtar.x; // convert x-component to polar and add offset\n    // camera\n    ro.z = cameraRadius * sin(time) + camtar.z; // convert z-component to polar and add offset\n    mat3 cam = camera(ro, camtar);\n    vec3 rd = normalize(cam*vec3(uv, -1.5)); // ray directionvec3 ro = vec3(0.0, 2.0, 10.0);\n    \n\n\n    vec3 col = render(ro, rd);\n    \n    // gamma\n    col = pow(col, vec3(1.0/2.2));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGcDR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[343, 343, 368, 368, 389], [391, 391, 438, 438, 473], [475, 475, 508, 508, 577], [579, 579, 624, 624, 911], [913, 920, 951, 951, 981], [983, 983, 1036, 1036, 1136], [1138, 1138, 1159, 1159, 1781], [1784, 1784, 1816, 1816, 2017], [2019, 2019, 2054, 2054, 2281], [2284, 2284, 2319, 2319, 2617], [2620, 2620, 2671, 2671, 2995], [2998, 2998, 3037, 3037, 3294], [3296, 3296, 3335, 3353, 4381], [4383, 4383, 4440, 4440, 5132]]}
{"id": "fdKyWR", "name": "Gamma Ray Anatomy", "author": "xenn", "description": "remember to travel forward in time only", "tags": ["hue", "feedback", "hypnosis"], "likes": 3, "viewed": 314, "published": 3, "date": "1654690106", "time_retrieved": "2024-07-30T16:45:14.486999", "image_code": "// Fork of \"glowdoodle interdimensional\" by ericrosenbizzle. https://shadertoy.com/view/fsycDR\n// 2022-06-08 12:07:34\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 img = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n   \tfragColor = vec4(img, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rgbToGray(vec3 rgb) {\n\tconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n\nvec3 hueShift2(vec3 color, float hue)\n{\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // mirror reverse the camera input\n    vec2 pos = fragCoord/iResolution.xy;\n    pos = vec2(1.0 - pos.x, pos.y);\n    \n    vec3 cam = texture(iChannel0,pos).xyz;\n    \n    vec2 offsetPos = fragCoord/iResolution.xy;\n    //offsetPos /= 1.01;\n\n    vec2 center = vec2(0.5, 0.5);\n    vec2 v2 = (fragCoord/iResolution.xy) - center;\n    v2 *= 0.99;\n    offsetPos = v2 + center;\n\n    vec3 image = texture(iChannel1,offsetPos).xyz;\n    \n    float camBrightness = rgbToGray(cam);\n    float imageBrightness = rgbToGray(image);\n    \n    //vec3 shifted = hueShift2(cam, iTime); \n    vec3 shifted = cam;\n    \n    if (camBrightness > imageBrightness) {\n\t    fragColor = vec4(shifted, 1.);\n    } else {\n\t    fragColor = vec4(image, 1.);    \n    }\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec3 hueShift(vec3 color, float hue)\n{\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 filtered = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    // hue shift\n    vec3 shifted = hueShift(filtered, 0.1);\n    //vec3 shifted = filtered;\n    \n    // Slow fade\n    //fragColor = vec4(filtered * 0.999, 1.);\n    fragColor = vec4(shifted * 0.999, 1.);\n    //fragColor = vec4(shifted, 1.);\n    \n    // Click to clear\n    vec4 m = iMouse / iResolution.xxxx;\n    if(m.z>0.0 ) {\n        fragColor = vec4(0.,0.,0.,1.);\n    }\n}", "buffer_b_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define BACKGROUND_COLOR vec3(0.5f, 0.5f, 1.0f)\n\n// The amount of metaballs\n// The more there are, the quicker the same one will reach the same position again\n// This is because the noise texture is finite and sampled based on the ball and time\n// Doesn't actally control the amount of blobs (unrolled loop) but still used in calculations\n#define METABALLS 8\n\n#define METABALL_MIN_RADIUS 0.0625f\n#define METABALL_MAX_RADIUS 0.125f\n\n#define FLOW_TIME_SCALE 0.015625f\n#define UP_FLOW_TIME_SCALE 0.0625f\n#define ROTATION_TIME_SCALE 0.0981747705f\n\n#define CAMERA_OFFSET -2.0f\n#define SPHERE_RADIUS 0.375f\n\n#define MAX_ITERATIONS 8\n#define SDF_EPSILON 1e-6\n\n#define SPECULAR_HIGHLIGHT 1\n#define POINT_LIGHT_POSITION vec3(1.0f, 0.5f, 0.0f)\n#define SPECULAR_DEGREE 6\n\n\n// Cubic interpolation http://paulbourke.net/miscellaneous/interpolation/\nfloat mixCubic(float y0, float y1, float y2, float y3, float mu)\n{\n   float a0, a1, a2, a3, mu2;\n\n   mu2 = mu * mu;\n   a0 = y3 - y2 - y0 + y1;\n   a1 = y0 - y1 - a0;\n   a2 = y2 - y0;\n   a3 = y1;\n\n   return a0 * mu * mu2 + a1 * mu2 + a2 * mu + a3;\n}\n\nvec4 mixCubic(vec4 z, vec4 a, vec4 b, vec4 c, float t){\n    return vec4(\n        mixCubic(z.x, a.x, b.x, c.x, t),\n        mixCubic(z.y, a.y, b.y, c.y, t),\n        mixCubic(z.z, a.z, b.z, c.z, t),\n        mixCubic(z.w, a.w, b.w, c.w, t)\n    );\n}\n\n\n// https://gist.github.com/h3r/3a92295517b2bee8a82c1de1456431dc\nfloat hash(float x, float y){\n    return fract(1e4 * sin(17.0 * x + y * 0.1) * (0.1 + abs(sin(y * 13.0 + x))));\n}\n\nvec4 hash4(float x, float y){\n    return vec4(\n        -0.25f + 0.5f * hash(x + 0.75f, y),\n        -0.25f + 0.5f * hash(x + 0.5f, y),\n        -0.25f + 0.5f * hash(x + 0.25f, y),\n        hash(x, y));\n}\n\n\n// Inigo Quilez MIT licence https://www.shadertoy.com/view/lt3BW2\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\n\n// Samples the color from a gradient\nvec3 colorGradient(float x){\n    return vec3(smoothstep(0.25f, 0.4f, x), smoothstep(0.4f, 0.6f, x), smoothstep(0.65f, 0.875f, x));\n}\n\n\n// Samples the noise texture at the given index\nvec4 noiseAtId(int i){\n    return texture(iChannel0, vec3(float(i >> 10) / 32.0f, float(i << 5 >> 10) / 32.0f, float(i << 10 >> 10) / 32.0f));\n}\n\n\n// Samples the noise texture at the given time for the given metaball\nvec4 noise(int ballId, float time){\n    \n    float flooredTime = floor(time);    \n    // int stride = 32768 / METABALLS;\n    //int t = int(flooredTime);\n\n    // vec4 z = noiseAtId(stride * ballId + (t + stride - 1) % stride);\n    // vec4 a = noiseAtId(stride * ballId + t % stride);\n    // vec4 b = noiseAtId(stride * ballId + (t + 1) % stride);\n    // vec4 c = noiseAtId(stride * ballId + (t + 2) % stride);\n\n    vec4 z = hash4(float(ballId), flooredTime - 1.0f);\n    vec4 a = hash4(float(ballId), flooredTime);\n    vec4 b = hash4(float(ballId), flooredTime + 1.0f);\n    vec4 c = hash4(float(ballId), flooredTime + 2.0f);\n\n    return mixCubic(z, a, b, c, time - flooredTime);\n}\n\n\n// Gets the position and radius at a given time for the given metaball\nvec4 getBallInfo(int ballId, float time){\n\n    vec4 res = noise(ballId, time);\n\n    // Scale [0;1] -> [-1;1]\n    res.xyz *= 2.0f;\n    res.xyz += vec3(-1.0f, -1.0f, -1.0f);\n    \n    // Fit noise better\n    // For some reason it's actually on [-0.5,0.5] by now, so rescale\n    // with also some squeezing towards the center for a better look\n    res.x = res.x * res.x + res.x;\n    res.y *= 2.0f;\n    res.z = res.z * res.z + res.z;\n\n    // Updraft\n    res.y += 1.0f + iTime * UP_FLOW_TIME_SCALE;\n    res.y = fract(res.y);\n    res.y = -2.0f + 4.0f * res.y;\n\n    // Density\n    res.w = mix(METABALL_MIN_RADIUS, METABALL_MAX_RADIUS, res.w);\n    res.w *= min(mix(1.0f, 0.0f, res.y), mix(1.0f, 0.0f, -1.0f + 2.0f * length(res.xyz)));\n\n    // Scale to sphere\n    res.xyz *= SPHERE_RADIUS;\n    \n    // Rotate sphere\n    float angle = iTime * ROTATION_TIME_SCALE;\n    float c = cos(angle);\n    float s = sin(angle);\n    res.xyz = mat3(c, 0.0f, -s, 0.0f, 1.0f, 0.0f, s, 0.0f, c) * res.xyz;\n\n    return res;\n}\n\n\n// Samples the SDF at the given coordinates at the given time\nfloat sdfAt(vec3 coords, float time){\n\n    float value = abs(CAMERA_OFFSET) + 2.0 * SPHERE_RADIUS;\n\n    vec4 ballInfoA, ballInfoB;\n\n    ballInfoA = getBallInfo(0, time);\n    ballInfoB = getBallInfo(1, time);\n    float s0 = opSmoothUnion(\n        length(ballInfoA.xyz - coords) - ballInfoA.w,\n        length(ballInfoB.xyz - coords) - ballInfoB.w,\n        0.25f);\n    \n    ballInfoA = getBallInfo(2, time);\n    ballInfoB = getBallInfo(3, time);\n    float s1 = opSmoothUnion(\n        length(ballInfoA.xyz - coords) - ballInfoA.w,\n        length(ballInfoB.xyz - coords) - ballInfoB.w,\n        0.25f);\n    \n    ballInfoA = getBallInfo(4, time);\n    ballInfoB = getBallInfo(5, time);\n    float s2 = opSmoothUnion(\n        length(ballInfoA.xyz - coords) - ballInfoA.w,\n        length(ballInfoB.xyz - coords) - ballInfoB.w,\n        0.25f);\n    \n    ballInfoA = getBallInfo(6, time);\n    ballInfoB = getBallInfo(7, time);\n    float s3 = opSmoothUnion(\n        length(ballInfoA.xyz - coords) - ballInfoA.w,\n        length(ballInfoB.xyz - coords) - ballInfoB.w,\n        0.25f);\n    \n    float t0 = opSmoothUnion(s0, s1, 0.25f);\n    float t1 = opSmoothUnion(s2, s3, 0.25f);\n\n    value = opSmoothUnion(t0, t1, 0.25f);\n    \n    // For some reason I have to unroll this loop (see above)\n    // because (at least on my system) I get artifacts otherwise\n    // The smoothing factor is different for cosmetic reasons\n    // for (int i = 0; i < METABALLS; ++i){\n    // \n    //     vec4 ballInfo = getBallInfo(i, time);\n    //     vec3 delta = ballInfo.xyz - coords;\n    //     \n    //     value = opSmoothUnion(value, length(delta) - ballInfo.w, 0.25f);\n    // }\n        \n    return value;\n}\n\n\n// Gets the full-alpha color of the sphere by sphere-marching\nvec3 getSphereColor(vec3 start, vec3 end, vec3 backgroundColor){\n    \n    vec3 diff = end - start;\n    float maxDist = length(diff);\n    vec3 dir = diff / maxDist;\n    \n    float sdf;\n    float dist = 0.0f;\n    vec3 color = backgroundColor;\n\n    for (int i = 0; dist < maxDist && i < MAX_ITERATIONS; ++i){\n        \n        sdf = sdfAt(start + dist * dir, iTime * FLOW_TIME_SCALE);\n        \n        if (abs(sdf) <= SDF_EPSILON){\n            color = mix(color, colorGradient(0.75f), 1.0f - dist / SPHERE_RADIUS);\n            break;\n        }\n        \n        color = mix(color, colorGradient(0.5f - 2.0f * sdf), 1.0f - dist);\n        \n        dist += sdf;\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resolution = min(iResolution.x, iResolution.y);\n    \n    // The location of the pixel on the XY plane\n    vec2 viewPlaneLocation = (fragCoord - iResolution.xy* 0.5f) / vec2(resolution, resolution);\n\n    vec3 cameraPosition = vec3(0.0f, 0.0f, CAMERA_OFFSET);\n\n    // The direction of the pixel from the camera\n    vec3 dir = normalize(vec3(viewPlaneLocation, 0.0f) - cameraPosition);\n    \n    // The vector from the camera to the closest point on the ray from the origin\n    vec3 toClosest = dir * dot(dir, -cameraPosition);\n\n    // The distance from the camera to the closest point on the ray from the origin\n    float tcd = sqrt(dot(toClosest, toClosest));\n    \n    // The vector from the origin to the closest point on the ray\n    vec3 closest = cameraPosition + toClosest;\n    \n    // The square distance from the origin to the closest point on the ray\n    float csd = dot(closest, closest);\n    \n    // The distance from the origin to the closest point on the ray\n    float cd = sqrt(csd);\n    \n    // The distance travelled by the ray inside of the sphere to the point\n    // closest to the origin, which is half the distance it travels there total\n    float ttcd = sqrt(abs(SPHERE_RADIUS * SPHERE_RADIUS - csd));\n\n    // The start and end of the ray through the sphere\n    vec3 start = cameraPosition + dir * (tcd - ttcd);\n    vec3 end   = cameraPosition + dir * (tcd + ttcd);\n\n    vec3 backgroundColor = BACKGROUND_COLOR;\n    vec3 color = cd <= SPHERE_RADIUS ? getSphereColor(start, end, backgroundColor) : backgroundColor;\n\n    // Previous version, marching with a fixed stride\n    // vec3 color = backgroundColor;\n    // for (float depth = 3.0f; depth > 1.0f; depth -= 0.0625)\n    //     color = march(color, cameraPosition + depth * dir);\n\n    // Take account of sphere depth\n    color = mix(backgroundColor, color, ttcd / SPHERE_RADIUS);\n\n#if SPECULAR_HIGHLIGHT != 0\n    float plAngle = -iTime * ROTATION_TIME_SCALE;\n    float plc = cos(plAngle);\n    float pls = sin(plAngle);\n\n    vec3 pointLightPosition = mat3(plc, 0.0f, -pls, 0.0f, 1.0f, 0.0f, pls, 0.0f, plc) * POINT_LIGHT_POSITION;\n    vec3 pointLightDirection = -normalize(pointLightPosition - start);\n    vec3 normal = normalize(start);\n    float nDotPLD = dot(normal, pointLightDirection);\n    vec3 reflection = nDotPLD * 2.0f * normal - pointLightDirection;\n\n    float specularAmount = nDotPLD <= 0.0f ? dot(dir, reflection) : 0.0f;\n    for (int i = 0; i < SPECULAR_DEGREE - 1; ++i)\n        specularAmount *= specularAmount;\n    color = cd <= SPHERE_RADIUS ? mix(color, vec3(1.0f, 1.0f, 1.0f), specularAmount) : color;\n#endif\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "buffer_c_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .0025;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .005;\nconst float iFeedbackColorShiftImpact = 0.0005;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .01;\nconst float iBlobEdgeSmoothing        = .001;\nconst float iBlob1Radius              = .5;\nconst float iBlob1PowFactor           = 20.;\nconst float iBlob1ColorPulseSpeed     = -.033;\nconst float iBlob2Radius              = .75;\nconst float iBlob2PowFactor           = 20.;\nconst float iBlob2ColorPulseSpeed     =- .0234;\nconst float iBlob2ColorPulseShift     = 0.0750;\nconst float iColorShiftOfRadius       = -.25;\nconst float iFeedbackMouseShiftFactor = .003;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.br/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = mix(repeatedTexture(iChannel2, uv - stShift).rgb,repeatedTexture(iChannel3, uv - stShift).rgb,repeatedTexture(iChannel0, uv - stShift).rgb);\n     vec3 prevColor2 = mix(repeatedTexture(iChannel2, uv - stShift).rgb,repeatedTexture(iChannel3, uv - stShift).rgb , repeatedTexture(iChannel0, uv - stShift).rgb/256.);\n    prevColor +=prevColor2/512.;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define iFeedbackColorShiftZoom 0.2\n//#define iFeedbackColorShiftImpact 0.001\n//#define iBlob1ColorPulseSpeed 0.03456\n//#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n#define iTime iTime / 1.0\n\n#define PI 3.14159265359\n\nvec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1./16.) + vec2(float(x) / 16., float(y) / 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) / 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n//    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\n//vec3 hsv2rgb(vec3 cc)\n//{\n//    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n//    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n//    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n//}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKyWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 176, 176, 277]]}
{"id": "7sGcDz", "name": "Interactive Grid Thing", "author": "Bricktronic", "description": "Simple grid with colors, based on distance to mouse with time", "tags": ["2d", "grid"], "likes": 0, "viewed": 247, "published": 3, "date": "1654687696", "time_retrieved": "2024-07-30T16:45:15.228017", "image_code": "vec2 tg(vec2 p, float s)\n{\n    return vec2(floor(p.x / s) * s, floor(p.y / s) * s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mc = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord/mc;\n    vec4 m = iMouse / mc;\n    \n    vec2 gp = tg(uv , 0.01);\n    \n    float d;\n    \n    d = (distance(m.xy, gp) * distance(abs(m.zw), gp)) * 25.;\n    \n    vec3 col = vec3(\n    sin(d + (iDate.w * 0.3)), \n    cos(d + (iDate.w * 0.4)), \n    sin(d + (iDate.w * 0.5)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 85], [87, 87, 144, 144, 520]]}
{"id": "ssGcWz", "name": "11 Bezier Curve(quadratic/Cubic)", "author": "ccc9527", "description": "quadratic-bezier //二次Bezier曲线\nCubic-bezier  //三次Bezier曲线\nsimulation how the Bezier curve is generated //模拟Bezier曲线是如何生成的", "tags": ["quadraticbezier"], "likes": 3, "viewed": 291, "published": 3, "date": "1654680097", "time_retrieved": "2024-07-30T16:45:15.990978", "image_code": "#define S(size,d) smoothstep(size, size-1.5/iResolution.y, d)\n\n//画线函数,p为uv,即屏幕上任意一点,ab为线段两端点,size是线段宽,\n//size-1.5/iResolution.y是线段边缘模糊百分比,color是线段颜色\nvec3 DrawLine(vec2 uv,vec2 a,vec2 b,float size,vec3 color)\n{\n    vec2 ap = uv-a;\n    vec2 ab = b-a;\n    \n    float t = dot(ap,ab)/dot(ab,ab);//点p在线段上投影占ab的百分比\n    t = clamp(t,0.0,1.0);\n    \n    //ap-ab*t表示点p到线段ab的垂点,即d是点p到线段的距离\n    float d = length(ap-ab*t);\n    float s = S(size,d);\n    \n    return s*color;\n}\nvec3 DrawPoint(vec2 uv,vec2 p,float size,vec3 color)\n{\n    float d = length(uv-p);\n    d = S(size,d);\n    \n    return d*color;\n}\n//画Beizer曲线,abc为二次Bezier曲线的三个控制点，通过一个个点表示曲线,\n//size为距离点的大小以及模糊程度,color为每个点的颜色\nvec3 Bezier(vec2 uv,vec2 a,vec2 b,vec2 c,float size,vec3 color)\n{\n    vec2 p1 = vec2(0.0);\n    vec2 p2 = vec2(0.0);\n    vec2 p = vec2(0.0);\n    vec3 col = vec3(0.0);\n    for(float t = 0.0;t<=1.0;t+=0.003)\n    {\n        p1 = mix(a,b,t);\n        p2 = mix(b,c,t);\n        p = mix(p1,p2,t);\n        col += DrawPoint(uv,p,size,color);\n    }\n    return col;\n}\n//画Beizer曲线,abcd为三次Bezier曲线的三个控制点，通过一个个点表示曲线,\n//size为距离点的大小,color为每个点的颜色\nvec3 Bezier(vec2 uv,vec2 a,vec2 b,vec2 c,vec2 d,float size,vec3 color)\n{\n    vec2 p1 = vec2(0.0);\n    vec2 p2 = vec2(0.0);\n    vec2 p3 = vec2(0.0);\n    \n    vec2 p11 = vec2(0.0);\n    vec2 p12 = vec2(0.0);\n    \n    vec2 p = vec2(0.0);\n    vec3 col = vec3(0.0);\n    \n    for(float t = 0.0;t<=1.0;t+=0.003)\n    {\n        p1 = mix(a,b,t);\n        p2 = mix(b,c,t);\n        p3 = mix(c,d,t);\n        \n        p11 = mix(p1,p2,t);\n        p12 = mix(p2,p3,t);\n        \n        p = mix(p11,p12,t);\n        col += DrawPoint(uv,p,size,color);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float w = iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.0f);\n    float size = 0.015;\n    \n    if(false) //为True画二次Bezier曲线\n    {\n        //Draw Three Point,三个控制点\n        vec2 a = vec2(0.1*w,0.15);\n        vec2 b = vec2(0.5*w,0.8);\n        vec2 c = vec2(0.8*w,0.25);\n\n        col += DrawPoint(uv,a,size,vec3(1.0));\n        col += DrawPoint(uv,b,size,vec3(1.0));\n        col += DrawPoint(uv,c,size,vec3(1.0));\n\n        //Draw Two Line,三个控制的形成的两条直线\n        col += DrawLine(uv,a,b,size/3.0,vec3(1.0,0.0,1.0));\n        col += DrawLine(uv,b,c,size/3.0,vec3(1.0,0.0,1.0));\n\n        float t = fract(iTime/5.0);//Time,每五秒一个循环\n\n        //两条直线上的某一个点,随t的变化而变化(用t值进行插值得到)\n        vec2 p1 = mix(a,b,t);\n        col += DrawPoint(uv,p1,size,vec3(1.0));\n        vec2 p2 = mix(b,c,t);\n        col += DrawPoint(uv,p2,size,vec3(1.0));\n\n        //画出p1与p2的连线\n        col += DrawLine(uv,p1,p2,size/3.0,vec3(1.0,1.0,0.0));\n\n        //同样用t在直线p1与p2直接进行插值得到的点就是Bezier曲线上的点\n        vec2 p = mix(p1,p2,t);\n        col += DrawPoint(uv,p,size,vec3(1.0));\n\n        //用相同的方法画出Bezier曲线用于对比\n        col += Bezier(uv,a,b,c,size/3.0,vec3(1.0));\n    }\n    else  //否则画三次Bezier曲线\n    {\n        //Draw Four Point,四个控制点\n        vec2 a = vec2(0.1*w,0.15);\n        vec2 b = vec2(0.3*w,0.85);\n        vec2 c = vec2(0.65*w,0.8);\n        vec2 d = vec2(0.8*w,0.25);\n\n        col += DrawPoint(uv,a,size,vec3(1.0));\n        col += DrawPoint(uv,b,size,vec3(1.0));\n        col += DrawPoint(uv,c,size,vec3(1.0));\n        col += DrawPoint(uv,d,size,vec3(1.0));\n\n        //Draw Three Line,四个控制的形成的三条直线\n        col += DrawLine(uv,a,b,size/3.0,vec3(1.0,0.0,1.0));\n        col += DrawLine(uv,b,c,size/3.0,vec3(1.0,0.0,1.0));\n        col += DrawLine(uv,c,d,size/3.0,vec3(1.0,0.0,1.0));\n\n        float t = fract(iTime/5.0);//Time,每五秒一个循环\n\n        //三条直线上的某一个点,随t的变化而变化(用t值进行插值得到)\n        vec2 p1 = mix(a,b,t);\n        col += DrawPoint(uv,p1,size,vec3(1.0));\n        vec2 p2 = mix(b,c,t);\n        col += DrawPoint(uv,p2,size,vec3(1.0));\n        vec2 p3 = mix(c,d,t);\n        col += DrawPoint(uv,p3,size,vec3(1.0));\n\n        //画出p1,p2,p3的连线\n        col += DrawLine(uv,p1,p2,size/3.0,vec3(1.0,1.0,0.0));\n        col += DrawLine(uv,p2,p3,size/3.0,vec3(1.0,1.0,0.0));\n\n        //同样用t在直线p1,p2,p3直接进行插值得到两个点\n        vec2 p11 = mix(p1,p2,t);\n        col += DrawPoint(uv,p11,size,vec3(1.0));\n        vec2 p12 = mix(p2,p3,t);\n        col += DrawPoint(uv,p12,size,vec3(1.0));\n        //画得到的这两个点的曲线\n        col += DrawLine(uv,p11,p12,size/3.0,vec3(0.0,1.0,1.0));\n        \n        //同样用t在直线p11与p12直接进行插值得到的点就是Bezier曲线上的点\n        vec2 p = mix(p11,p12,t);\n        col += DrawPoint(uv,p,size,vec3(1.0));\n        \n        //用相同的方法画出Bezier曲线用于对比\n        col += Bezier(uv,a,b,c,d,size/3.0,vec3(1.0));\n    }\n    \n    col = pow(col,vec3(1.0/2.2));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 225, 285, 285, 595], [596, 596, 650, 650, 724], [725, 893, 958, 958, 1246], [1247, 1398, 1470, 1470, 1951], [1953, 1953, 2010, 2010, 5316]]}
{"id": "ssyyDR", "name": "Frost fractal pattern", "author": "jarble", "description": "A fractal with frost patterns.", "tags": ["fractal", "frost"], "likes": 5, "viewed": 282, "published": 3, "date": "1654678991", "time_retrieved": "2024-07-30T16:45:16.738978", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 16.*16.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<6;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 3; k++){\n            //t2.yx /= scale; //this makes another nice pattern\n\n            uv += 1.+(t2.yx);\n            t2 = triangle_wave(uv.yx-.5,scale);\n            t3 = triangle_wave(uv,scale);\n            uv.yx = (t2-t3)/(scale);\n        }\n        col.x = (((uv.y+uv.x)+col.x))/sqrt(3.);\n        col = abs(col+vec3(col.x))/sqrt(3.);\n    }\n    fragColor = vec4((col*3.),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 915]]}
{"id": "sdyyzw", "name": "Cheddar", "author": "El_Sargo", "description": "Fake lighting for some cheese;", "tags": ["3d", "raymarching"], "likes": 23, "viewed": 433, "published": 3, "date": "1654675302", "time_retrieved": "2024-07-30T16:45:17.556791", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    float totalFrames = col.w;\n    col *= smoothstep(.85,0.3,length(uv-0.5));\n\n         col = pow(col/totalFrames, vec4(.9, 1., .95, 1.));\n         col *= 0.93;\n    fragColor = sqrt(col);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float Earth = 63.71;\nconst float AtRad = 64.01;\nconst float directScatterCoef = .001;\nconst float inDirectScatterCoef = .3;\nconst float sunCoef = .1;\nconst vec3 rgbScatter = vec3(1,2,4);\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 getSky(vec3 rd, vec3 sun){\n//Distances, proportaional to the real world\n    const vec3 pos = vec3(0.,Earth,0.);\n    float atDist = sphIntersect(pos, rd, vec3(0), AtRad).y;\n    float snDist = sphIntersect(pos, sun,vec3(0), AtRad).y-1.1;\n    \n    float rds = dot(sun, rd);\n\n    vec3 light = vec3(smoothstep(0.995, .996, rds))*2.;\n         light += (1.-exp(-rgbScatter*atDist*inDirectScatterCoef*(atDist*5.*.5+.5)));\n         light *= exp(-rgbScatter*(atDist*directScatterCoef+snDist*sunCoef));\n         \n     return pow(light, vec3(2.));\n}\n\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n", "buffer_a_code": "const int raymarchsteps = 150;\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\nfloat sdHoles(vec3 p){\n    const float c = .17;\n    p += vec3(.4163,1.62,1.46);\n    p = mod(p+c, 2.*c)-c;\n    return sdSphere(p,.14);\n}\nfloat sdCheeze(vec3 p, out float h){\n    p.z = -p.z;\n    p -= vec3(-0.4,-0.65,0.);\n    p.xz *= rot(0.65);\n    float base;\n    {\n        float d = sdTri(p.xz, vec2(.5, 1.3));\n        vec2 w = vec2( d, abs(p.y) - .35 );\n        base =  min(max(w.x,w.y),0.0) + length(max(w,0.0))-0.02;\n    }\n    h = sdHoles(p);\n    float d = ssub(h, base,0.02);\n    return d;\n}\n\nfloat sdOlive(vec3 p){\n    p -= vec3(.4,-0.82,0.);\n    p.x = abs(p.x)-0.12;\n    float l = length(p.xy);\n    return sdEllipse(vec2(l,p.z), vec2(.13,0.2));\n}\n\nfloat map(vec3 p){\n    float _;\n    float d = sdCheeze(p,_);\n    d = smin(d, p.y+1.,0.02);\n    d = min(d,sdOlive(p));\n    return d;\n}\n\nfloat intersection(vec3 ro, vec3 rd){\n    float T=0.;\n    for(int i=0;i<raymarchsteps;i++){\n        float d = map(ro+rd*T);\n        T += d;\n        if (abs(d) < 0.001*T  || T > 20.){\n            break;\n        }\n    }\n    return T;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\nvec3 calcNormal( in vec3 p , in float T){\n    float h = 0.01*T;\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h);\n    }\n    return normalize(n);\n}\nfloat calcAO(vec3 pos, vec3 nor){\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=0; i<5; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = map( pos+h*nor);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 triTex(vec3 p, vec3 nor, sampler2D tex){\n    vec3 x = texture(tex, p.yz).xyz;\n    vec3 y = texture(tex, p.xz).xyz;\n    vec3 z = texture(tex, p.xy).xyz;\n\n    return x*nor.x + y*nor.y + z*nor.z;\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    float T = intersection(ro, rd);\n    vec3 p = ro+rd*T;\n    float dist = map(p);\n    float holes;\n    vec3 col = vec3(0.);\n    float chez = sdCheeze(p, holes);\n    float olive = sdOlive(p);\n    vec3 sun = normalize(vec3(5,5.,-1.4));\n    vec3 scl = vec3(0.925,0.906,0.792);\n    vec3 ccl = vec3(0.949,0.831,0.251);\n    vec3 gcl = vec3(0.867,0.851,0.851);\n    vec3 ocl = vec3(0.463,0.867,0.192);\n    bool isCheeze = chez < p.y+1.005;\n    float fisCheeze = float (isCheeze);\n    vec3 bcl = isCheeze ? ccl : gcl;\n    bool isOlive = false;\n    if (olive < chez && p.y > -.9){\n        bcl = ocl;\n        isOlive = true;\n    }\n    if (dist < 1.2){\n    \n        vec3 nor = calcNormal(p, T);\n        float occ = calcAO(p, nor);\n        float sha = softshadow(p, sun, 0.1, 5., 10.);\n        float nds = sqrt(max(0., dot(nor, sun)));\n        vec3 hvc = normalize(sun - rd);\n        vec3 ref = reflect(rd, nor);\n        float frez = .5+.5*dot(rd, ref);\n        float inchez = clamp(1.-15.*chez, 0., 1.);\n        \n        vec3 tex = triTex(p, nor, iChannel1);\n        \n        bcl += isCheeze ? tex*0.3 : tex*-0.1;\n        col += 6.*bcl*scl*nds*sha*scl;\n        col += 2.*max(0.00001, pow(dot(nor, hvc),3.))*sha;\n        col += 3.*max(0.5,dot(nor, -sun))*gcl*bcl*scl*occ;\n        col += 3.*clamp(getSky(ref,sun),0.,1.)*occ*0.75*(.5+.5*dot(nor,vec3(0,1,0)))*frez;\n        col += frez*( !isOlive ? vec3(0.902,0.176,0.176): vec3(0.000,0.000,0.000) )*sha*3.;\n        col += 3.5*vec3(0.878,0.278,0.024)*(max(0.5,1.-20.*holes))*inchez;\n        col += scl*ocl*smoothstep(.5, 0., olive);\n    } else {\n        col = getSky(rd, sun)*5.;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 prev = texture(iChannel0, uv);\n    float frame = float(iFrame);\n    float dx = mod(frame, 3.)/3.-0.25;\n    float dy = mod(frame, 9.)/9.-0.25;\n    vec2 off = vec2(dx,dy)/iResolution.xy;\n    vec2 nuv = (uv-0.5+off)*vec2(1.,iResolution.y/iResolution.x);\n    \n    vec3 ro = vec3(0., 0.5, 1.75);\n    vec3 rd = normalize(vec3(nuv, -0.9));\n         rd.yz *= rot(-0.45);\n    vec3 col = render(ro, rd);\n    \n    col /= 8.;\n    col = smoothstep(0., 1., col);\n    fragColor = prev+vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyyzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 326]]}
{"id": "7syyDR", "name": "Web of Lights", "author": "jarble", "description": "An interconnected web of glowing rings.", "tags": ["fractal", "web"], "likes": 6, "viewed": 265, "published": 3, "date": "1654673224", "time_retrieved": "2024-07-30T16:45:18.294817", "image_code": "#define c1 vec3(1.,0.5,1.5)\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = c1.z;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n    for(int i=0;i<6;i++)\n    {\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 2; k++){\n            uv += 1.+(t2.yx);\n            t2 = triangle_wave(uv.yx-.5,scale);\n            \n            //float num = 4.;\n            //t2.x += floor((fract(uv.x)*num))/num;\n            \n            t3 = triangle_wave(uv,scale);\n            //t3 *= -1.; //makes a star pattern\n            uv.yx = (t2-t3)/(scale);\n        }\n        col.x = min(((uv.y-uv.x)+col.x),col.x)/sqrt(2.);\n        col = (col+vec3(col.x))/sqrt(2.);\n    }\n    fragColor = vec4(-vec3(col),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 68, 68, 113], [115, 115, 172, 172, 1006]]}
{"id": "slBSzc", "name": "Photon Mapped Caustics", "author": "SpinningCube", "description": "(Click and Drag)\nI wanted to render caustics, so I used buffers to apply forward rendered refracted light paths to a texture which is mapped to the plane. It's a rather strange method, and it's pretty biased, but it creates really good-looking caustics.", "tags": ["3d", "raytracing", "glass"], "likes": 20, "viewed": 850, "published": 3, "date": "1654619336", "time_retrieved": "2024-07-30T16:45:19.220343", "image_code": "// Hash by Dave_Hoskins\n// Filmic tonemapping curve by milesWaugh\n\nvec3 Texture0(vec2 uv) {\n    // Multiplying the texture by various values to maintain consistency. Also there's a hand-picked constant.\n    return (lightIntensity * 100. * texture(iChannel0, ((uv/scale)/2. + 0.5)).rgb)/float(attempts);\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 rayOrigin, vec3 surfNormal, float f) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n    vec3 finalCol = vec3(0.);\n    \n    if (abs(ray.y - (-1. - epsilon)) < 0.05) {\n        diffuse += float(Texture0(ray.xz));\n    }\n    \n    if (surfType == 0) {\n        finalCol = mix(surfCol * (diffuse + ambient), vec3(specular), f);\n    }\n    else if (surfType == 1) {\n        finalCol = mix(surfCol * specular, vec3(specular), f);\n    }\n    else if (surfType == 2) {\n        finalCol = vec3(specular) * f;\n    }\n    \n    return finalCol;\n}\n\nvec3 renderFromBackwardRay(vec3 rayDir, vec3 rayOrigin) {\n    vec3 contribution = vec3(1.0);\n    vec3 combinedCol;\n    float totalDepth = 0.;\n    float foga;\n    bool newMedium = false;\n    for (int i = 0; i < bounces; i++) {\n        vec4 rayData = shootRay( rayDir, rayOrigin, renderDist, true );\n\n        if (rayData.x == 1.) {\n            totalDepth += distance(rayData.yzw, rayOrigin);\n            float f = fresnel(1.5, surfRoughness, surfNormal, -rayDir);\n            combinedCol += contribution * lighting(rayData.yzw, rayDir, rayOrigin, surfNormal, f);\n            if (surfType == 0) {\n                break;\n                //contribution *= f;\n            }\n            else if (surfType == 1) {\n                vec4 rayData1 = shootRay( reflect(rayDir, surfNormal), rayData.yzw + epsilon * surfNormal, renderDist, true );\n                combinedCol += f * lighting(rayData1.yzw, rayDir, rayData.yzw + epsilon * surfNormal, surfNormal, f);\n                break;\n                //contribution *= mix(surfCol, vec3(1.), vec3(f));\n            }\n            if (surfType == 2) {\n                vec3 rayDir0 = rayDir;\n                vec3 surfNormal0 = surfNormal;\n                contribution *= surfCol * (1. - f);\n                // One bounce of glossy reflections\n                vec4 rayData1 = shootRay( reflect(rayDir, surfNormal), rayData.yzw + epsilon * surfNormal, renderDist, true );\n                combinedCol += f * lighting(rayData1.yzw, rayDir, rayData.yzw + epsilon * surfNormal, surfNormal, f);\n                rayDir = rayDir0;\n                surfNormal = surfNormal0;\n                \n                rayDir = refract(rayDir, surfNormal, mix(1./1.5, 1.5, newMedium));\n                newMedium = !newMedium;\n                \n                rayOrigin = rayData.yzw - epsilon * surfNormal;\n            }\n            else {\n                break;\n            }\n        }\n        else {\n            combinedCol += contribution * ambient;\n            break;\n        }\n    }\n    return combinedCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cosTime = cos(iTime/2.);\n    cosTime = 6.*-cosTime+6.;\n    camera = vec3(0, 0, -7);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5);\n    \n    if (mouse == vec2(-0.5)) {\n        mouse = vec2(-0.15, -0.12);\n    }\n    \n    mouse.y = min(0.03, mouse.y); // Constrain camera rotation\n    \n    camera.yz *= rotate(pi * -mouse.y);\n    camera.xz *= rotate(2. * pi * -mouse.x);\n    \n    camera.y = max(-1., camera.y);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    vec2 UV = fragCoord/iResolution.xy;\n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    rayDir.yz *= rotate(pi * -mouse.y);\n    rayDir.xz *= rotate(2. * pi * -mouse.x);\n    \n    vec3 col = renderFromBackwardRay(rayDir, camera);\n    \n    //col = Texture0(10. * (UV - 0.5)); // The caustics texture\n    \n    // Output to screen, filmic tonemapping, and gamma correction.\n    col = filmic(col);\n    fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Casting forward rays from the light source\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int id = int(fragCoord.x) + int(iResolution.x) * int(fragCoord.y) + 50;\n    if (id > samples && id > 0) {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    else {\n        vec2 uv = fragCoord/iResolution.xy;\n        mat3 render;\n        for (int i = 0; i < attempts; i++) { // Rejection sampling, converges much faster but even more bias\n            float seed = 10.23 * (float(iFrame) + 10.4341 * float(i));\n            vec3 rayDir = randInSphere(vec3(uv * 10. * seed, seed/1.));\n            render = renderFromForwardRay(rayDir, lightPos);\n            if (render[1].x > 0.) {\n                break;\n            }\n        }\n        vec3 hit = vec3(render[1].x, render[2].xz); // vec3(brightness, hit position x, hit position z)\n        fragColor = vec4(hit,render[0].x); // vec4(brightness, hit position x, hit position z, hit glass?)\n    }\n}", "buffer_a_inputs": [], "common_code": "// Hash by Dave_Hoskins\n// Filmic tonemapping curve by milesWaugh\n\nconst float epsilon = 0.001;\nconst float focalLength = 0.8;\nconst float renderDist = 850.;\nconst float pi = 3.141592653589793;\nconst int bounces = 5;\n\nconst int samples = 1000; // Number of fragments used to sample paths per frame\nconst int attempts = 200; // Number of attempts per fragment\nconst float sampleRadius = 0.002;\nconst vec3 lightPos = vec3(-2, 3.5, -3);\nconst float lightIntensity = 2.;\nconst float scale = 6.;\nconst float bumpStrength = 0.2;\n\nvec3 camera;\nfloat nearestDist;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfRoughness;\nint surfType; // 0=dielectric, 1=metallic, 2=glass\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = vec3(0.1);\n\nmat2 rotate(float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return mat2(cosA, -sinA, sinA, cosA);\n}\n\nvec3 rand(vec3 p3) // Hash by Dave_Hoskins\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// Smooth tricubic interpolated 3D noise\nvec3 noise(vec3 p3) {\n\n    vec3 p31 = floor(p3);\n    p3 = smoothstep(0., 1., fract(p3));\n    \n    // Corner points\n    vec3 p000 = p31 + vec3(0);\n    vec3 p001 = p31 + vec3(0, 0, 1);\n    vec3 p010 = p31 + vec3(0, 1, 0);\n    vec3 p011 = p31 + vec3(0, 1, 1);\n    vec3 p100 = p31 + vec3(1, 0, 0);\n    vec3 p101 = p31 + vec3(1, 0, 1);\n    vec3 p110 = p31 + vec3(1, 1, 0);\n    vec3 p111 = p31 + vec3(1);\n    \n    \n    // Tricubic interpolation\n    vec3 v000 = rand(p000);\n    vec3 v001 = rand(p001);\n    vec3 v010 = rand(p010);\n    vec3 v011 = rand(p011);\n    vec3 v100 = rand(p100);\n    vec3 v101 = rand(p101);\n    vec3 v110 = rand(p110);\n    vec3 v111 = rand(p111);\n    \n    vec3 vX00 = mix(v000, v100, p3.x);\n    vec3 vX01 = mix(v001, v101, p3.x);\n    vec3 vX10 = mix(v010, v110, p3.x);\n    vec3 vX11 = mix(v011, v111, p3.x);\n    \n    vec3 vXY0 = mix(vX00, vX10, p3.y);\n    vec3 vXY1 = mix(vX01, vX11, p3.y);\n\n    return mix(vXY0, vXY1, p3.z);\n}\n\nvec3 randInSphere(vec3 p3) {\n    for (int i = 0; i < 50; i++) {\n        vec3 rand1 = 2. * (rand(p3) - 0.5);\n        if (length(rand1) <= 1.) {\n            return normalize(rand1);\n        }\n    }\n    return vec3(0, -1, 0);\n}\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n\n// Intersectors\n\nvec4 Sphere( vec3 rayOrigin, vec3 rayDir, vec3 pos, float radius, bool negative) {\n    vec3 offset = pos - rayOrigin;\n    float dot1 = dot(offset, rayDir);\n    float dot2 = dot(offset, offset);\n\n    if (dot2 - dot1 * dot1 < radius * radius) {\n        float near = sqrt(radius * radius - (dot2 - (dot1 * dot1)));\n        float intersectSign = mix(-1., 1., float(negative));\n        return vec4(dot1 + intersectSign * near, intersectSign * (pos - (rayOrigin + (rayDir * (dot1 + intersectSign * near)))));\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvec4 Plane( vec3 rayOrigin, vec3 rayDir, vec3 normal, float dist ) {\n    float dot1 = dot(normal, rayDir);\n    float near = (dot(normal, rayOrigin) + dist)/dot1;\n    if (!(dot1 == 0.) && near < 0.)\n    {\n        return vec4(-near, normal);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvec4 Plane2( vec3 rayOrigin, vec3 rayDir, vec3 normal, float dist ) {\n    float dot1 = dot(normal, rayDir);\n    float near = (dot(normal, rayOrigin) + dist)/dot1;\n    if (!(dot1 == 0.) && near < 0. && length((rayOrigin + rayDir * -near).xz + vec2(2., 0.)) < 1.5)\n    {\n        return vec4(-near, normal);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvoid addIntersector( vec4 surface, vec3 col, float roughness, int type /* 0=dielectric, 1=metallic, 2=glass */, int textureType, vec3 textureScale, vec3 rayDir, vec3 start) {\n    float dist = surface.x;\n    if ( dist < nearestDist && dist > 0. ) {\n        nearestDist = dist;\n        if (updateMat) {\n            surfCol = col;\n            if (textureType == 0) {\n            \n            }\n            else if (textureType == 1) {\n                vec3 uvw = rayDir * dist + start;\n                vec3 rUVW = round(textureScale * uvw);\n                float checker = mod(rUVW.x + rUVW.y + rUVW.z, 2.);\n                surfCol = col * mix(0.4, 1., checker);\n            }\n            surfRoughness = roughness*roughness;\n            surfNormal = normalize(surface.yzw);\n            surfType = type;\n        }\n    }\n}\n\nfloat scene( vec3 rayOrigin, vec3 rayDir, vec3 start)\n{\n    \n    addIntersector( Sphere( rayOrigin, rayDir, vec3(1, 0, 0), 1., false), vec3(1.,1., 1.), .05, 2, 0, vec3(1.), rayDir, start);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(1, 0, 0), 1., true), vec3(1.,1., 1.), .05, 2, 0, vec3(1.), rayDir, start);\n    \n    //addIntersector( Sphere( rayOrigin, rayDir, vec3(-3, 0.2, 0), 1., false), vec3(1.,1., 1.), .05, 2, 0, vec3(1.), rayDir, start);\n    //addIntersector( Sphere( rayOrigin, rayDir, vec3(-3, 0.2, 0), 1., true), vec3(1.,1., 1.), .05, 2, 0, vec3(1.), rayDir, start);\n    \n    addIntersector( Plane( rayOrigin, rayDir, vec3(0, 1, 0), 1. + epsilon), vec3(0.3, 1., 0.3), 1., 0, 1, vec3(0.55), rayDir, start);\n    //addIntersector( Plane( rayOrigin, rayDir, vec3(0, 1, 0), 1. + epsilon), vec3(1., 0.6, 0.2), 1., 0, 1, vec3(0.55), rayDir, start);\n    \n    addIntersector( Plane2( rayOrigin, rayDir, vec3(0, 1, 0), -.5), vec3(1.,1., 1.), .05, 2, 0, vec3(1.), rayDir, start);\n    \n    return nearestDist;\n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    \n    nearestDist = renderDist;\n        \n    scene(start, rayDir, start);\n    \n    vec3 hitPos = rayDir * nearestDist + start;\n    \n    if (updateMaterial) {\n        if (surfType == 2) {\n            surfNormal += bumpStrength * noise(7. * hitPos);\n            surfNormal = normalize(surfNormal);\n        }\n        //surfCol = 1. * fract(noise(1. * hitPos));\n    }\n    \n    \n    return vec4(nearestDist < renderDist, hitPos);\n}\n\nfloat GGX (float halfDot, float roughness) {\n    float r2 = roughness*roughness;\n    float a = halfDot * halfDot * (r2 - 1.) + 1.;\n    return r2 / (a * a);\n}\n\nvoid directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * epsilon), lightDist, false).x == 0. ) {\n        float lambertian = dot(surfNormal, lightDir);\n        diffuse += max(intensity * lambertian, 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n        float halfDot = dot(surfNormal, halfway);\n    \tspecular += max(lambertian * intensity * GGX(halfDot, surfRoughness), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    pointLight( ray, rayDir, lightPos, lightIntensity, surfNormal);\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec3 filmic(vec3 color) {\n    return 1. - (1./(5. * pow(color, vec3(2.)) + 1.));\n}\n\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));\n}\n\nmat3 renderFromForwardRay(vec3 rayDir, vec3 rayOrigin) {\n    vec3 remainingCol = vec3(1.);\n    float totalDepth = 0.;\n    float foga;\n    bool newMedium = false;\n    bool hitGlass = false;\n    for (int i = 0; i < bounces; i++) {\n        vec4 rayData = shootRay( rayDir, rayOrigin, renderDist, true );\n\n        if (rayData.x == 1.) {\n            totalDepth += distance(rayData.yzw, rayOrigin);\n            float f = fresnel(1.5, surfRoughness, surfNormal, -rayDir);\n            if (surfType == 2) {\n                hitGlass = true;\n                remainingCol *= surfCol * (1. - f);\n\n                rayDir = refract(rayDir, surfNormal, mix(1./1.5, 1.5, newMedium));\n                newMedium = !newMedium;\n\n                rayOrigin = rayData.yzw - epsilon * surfNormal;\n            }\n            else {\n                return mat3(vec3(rayData.x), remainingCol * dot(-rayDir, surfNormal) * float(hitGlass), rayData.yzw);\n            }\n        }\n        else {\n            return mat3(0);\n        }\n    }\n    return mat3(0);\n}\n\n", "buffer_b_code": "// Uses the crude approach of looping through Buffer A to find the correct path, I couldn't figure out a better way to do this.\n// Fragment shaders are clearly not built for this\n\nvec3 sampleSamples(vec2 uv, float radius) {\n    vec3 total = vec3(0);\n    int num = 0;\n    for (int i = 0; i < samples; i++) {\n        vec4 c = texelFetch(iChannel0, ivec2(mod(float(i), iResolution.x), float(i) / iResolution.x), 0);\n        if (c.w == 1.) {\n            float light = c.x;\n            vec2 pos = c.yz;\n            vec2 diff = (pos / scale) - uv;\n            if (length(diff) < radius) {\n                total += c.xxx;\n                num++;\n            }\n        }\n    }\n    // A hand-picked constant\n    return 0.0006 * total/(pi * radius * radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 prevCol = texture(iChannel1, uv).rgb;\n    vec3 col = (prevCol * float(iFrame) + sampleSamples(uv * 2. - 1., sampleRadius))/float(iFrame + 1);\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBSzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 91, 202, 304], [306, 306, 386, 386, 919], [921, 921, 978, 978, 2947], [2949, 2949, 3006, 3006, 4007]]}
{"id": "fsKcRw", "name": "Custom Halley's Fractal", "author": "Fraktoler", "description": "Halley's fractal is generated using Halley's method", "tags": ["fractal", "iteration"], "likes": 1, "viewed": 217, "published": 3, "date": "1654613435", "time_retrieved": "2024-07-30T16:45:19.964353", "image_code": "precision highp float;\n\nvec3 HSLtoRGB(vec3 hsl) {\n    //0 <= h <= 360\n    //0 <= s <= 1\n    //0 <= l <= 1\n    float chroma = hsl.y * (1.0 - abs(2.0 * hsl.z - 1.0));\n    float h_prime = hsl.x / 60.0;\n    float x = chroma * (1.0 - abs(mod(h_prime, 2.0) - 1.0));\n    vec3 rgb;\n    if (0.0 <= h_prime && h_prime < 1.0) {\n        rgb = vec3(chroma, x, 0.0);\n    } else if (1.0 <= h_prime && h_prime < 2.0) {\n        rgb = vec3(x, chroma, 0.0);\n    } else if (2.0 <= h_prime && h_prime < 3.0) {\n        rgb = vec3(0.0, chroma, x);\n    } else if (3.0 <= h_prime && h_prime < 4.0) {\n        rgb = vec3(0.0, x, chroma);\n    } else if (4.0 <= h_prime && h_prime < 5.0) {\n        rgb = vec3(x, 0.0, chroma);\n    } else {\n        rgb = vec3(chroma, 0.0, x);\n    }\n    float m = hsl.z - 0.5 * chroma;\n    return rgb + m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 3.0;\n    vec2 center = vec2(0.0);\n    vec2 z = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x * zoom + center;\n    float p = 2.0 + iTime * 0.2;\n    float iter = 0.0;\n    const float max_iter = 256.0;\n    while (iter < max_iter) {\n        vec2 oldz = z;\n        vec2 f = power(z, p) - vec2(1.0, 0.0); //Function f(z)\n        vec2 df = p * power(z, p - 1.0); //f'(z)\n        vec2 ddf = p * (p - 1.0) * power(z, p - 2.0); //f\"(z)\n        z = z - div(2.0 * mul(f, df), 2.0 * sqr(df) - mul(f, ddf));\n\n        float r = mag2(z - oldz);\n        if (r < 1.0e-6) {\n            break;\n        }\n        iter += 1.0;\n    }\n\n    if (iter >= max_iter) {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } else {\n        float h = arg(z) / pi;\n        if (h < 0.0) {\n            h = h + 2.0;\n        }\n        vec3 col = HSLtoRGB(vec3(h * 180.0, 1.0, 0.5));\n        fragColor = vec4(col, 1.0);\n    }\n}", "image_inputs": [], "common_code": "/*\nConstants\n\n one = vec2(1., 0.)\n i = vec2(0., 1.\n pi = 3.14159265358979\n e = 2.718281828459045\n\nComplex functions\n\n mag2(z) = |z|^2 = dot(z, z)\n arg(z) = atan2(z.y, z.x)\n conj(z) = (z.x, -z.y)\n flip(z) = (-z.x, z.y)\n rabs(z) = (abs(z.x), z.y)\n iabs(z) = (z.x, abs(z.y))\n cis(x) = (cos(x), sin(x))\n mul(z, w) = z * w (Complex multiplication)\n mulI(z) = i * z\n div(z, w) = z / w (Complex division)\n recip(z) = 1 / z (Complex reciprocal)\n sqr(z) = z^2\n normalizesqr(z) = normalize(z^2)\n cube(z) = z^3\n power5(z) = z^5\n power7(z) = z^7\n power(z, x) = z^x (Complex exponentiation)\n powervec2(z, w) = z^w (Principal complex exponentiation)\n powerfv(x, z) = x^z (Complex exponentiation)\n sqrtp(z) = sqrt(z) (Principal square root)\n cbrt(z) = z^(1/3) (Principal cube root)\n powexp(z) = e^z (Complex exponential)\n ln(z) = log(z) (Complex logarithm)\n logb(z, w) = log(z) / log(w)\n sine(z) = sin(z) (Trig functions)\n cosine(z) = cos(z)\n tangent(z) = tan(z)\n cot(z) = 1 / tan(z)\n sec(z) = 1 / cos(z)\n csc(z) = 1 / sin(z)\n arcsin(z) = asin(z) (Inverse trig functions)\n arccos(z) = acos(z)\n arctan(z) = atan(z)\n arccot(z) = pi/2 - atan(z)\n arcsec(z) = acos(1 / z)\n arccsc(z) = asin(1 / z)\n sinhyp(z) = sinh(z) (Hyperbolic functions)\n coshyp(z) = cosh(z)\n tanhyp(z) = tanh(z)\n coth(z) = 1 / tanh(z)\n sech(z) = 1 / cosh(z)\n csch(z) = 1 / sinh(z)\n arcsinh(z) = asinh(z) (Inverse hyperbolic functions)\n arccosh(z) = acosh(z)\n arctanh(z) = atanh(z)\n arccoth(z) = acoth(z)\n arcsech(z) = asech(z)\n arccsch(z) = acsch(z)\n linear(z, a, b) = a * z + b\n quadratic(z, a, b, c) = a * z^2 + b * z + c\n cubic(z, a, b, c, d) = a * z^3 + b * z^2 + c * z + d\n gamma(z) (Gamma function)\n productlog(k, z) (Lambert W function (kth branch))\n digamma(z) (Digamma function)\n trigamma(z) (Trigamma function)\n*/\n#define one vec2(1., 0.)\n#define two vec2(2., 0.)\n#define i vec2(0., 1.)\n#define pi 3.14159265358979\n#define e 2.718281828459045\n//const float[] B = float[](1., .5, 1./6., 0., -1./30., 0., 1./42., 0., -1./30., 0., 5./66., 0., -691./2730., 0., 7./6.);\n\nfloat mag2(in vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(in vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(in vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(in vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 rabs(in vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(in vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(in float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(in vec2 z, in vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(in vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(in vec2 z, in vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / dot(w, w);\n}\n\nvec2 recip(in vec2 z) {\n    return conj(z) / dot(z, z);\n}\n\nvec2 sqr(in vec2 z) {\n    return z.x * z + z.y * vec2(-z.y, z.x);\n}\n\nvec2 normalizesqr(in vec2 z) {\n    return one - conj(z.yx) * (z.y + z.y) / dot(z, z);\n}\n\nvec2 cube(in vec2 z) {\n    vec2 z2 = z * z;\n    return z * (vec2(z2.x - z2.y) + vec2(-2.0, 2.0) * z2.yx);\n}\n\nvec2 power5(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z4 = z2 * z2;\n    return z * (z4 + 5. * z4.yx - 10. * z2.x * z2.y);\n}\n\nvec2 power7(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z6 = z2 * z2 * z2;\n    return conj(z) * (z6 - 7. * z6.yx - z2.x * z2.y * (21. * z2 - 35. * z2.yx));\n}\n\nvec2 power(in vec2 z, in float p) {\n    return pow(dot(z, z), p * .5) * cis(p * arg(z));\n}\n\nvec2 powervec2(in vec2 z, in vec2 w) {\n    float argz = arg(z);\n    float lnr = .5 * log(dot(z, z));\n    return exp(dot(w, vec2(lnr, -argz))) * cis(dot(w, vec2(argz, lnr)));\n}\n\nvec2 powerfv(in float x, in vec2 z) {\n    float lnr = log(x);\n    return exp(z.x * lnr) * cis(z.y * lnr);\n}\n\nvec2 sqrtp(in vec2 z) {\n    float r = length(z);\n    return vec2(1., sign(z.y)) * sqrt(.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 cbrt(in vec2 z) {\n    return power(z, .333333333333);\n}\n\nvec2 powexp(in vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(in vec2 z) {\n    return vec2(log(mag2(z)) * .5, arg(z));\n}\n\nvec2 logb(in vec2 z, in vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(in vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(in vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) + one) - i;\n}\n\nvec2 tangent(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) - one) + i;\n}\n\nvec2 cot(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(in vec2 z) {\n    return recip(cosine(z));\n}\n\nvec2 csc(in vec2 z) {\n    return recip(sine(z));\n}\n\nvec2 arcsin(in vec2 z) {\n    return mulI(ln(sqrtp(one - sqr(z)) - mulI(z)));\n}\n\nvec2 arccos(in vec2 z) {\n    return -mulI(ln(mulI(sqrtp(one - sqr(z))) + z));\n}\n\nvec2 arctan(in vec2 z) {\n    return -0.5 * mulI(ln(div(i - z, i + z)));\n}\n\nvec2 arccot(in vec2 z) {\n    return -0.5 * mulI(ln(div(z + i, z - i)));\n}\n\nvec2 arcsec(in vec2 z) {\n    return arccos(recip(z));\n}\n\nvec2 arccsc(in vec2 z) {\n    return arcsin(recip(z));\n}\n\nvec2 sinhyp(in vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(in vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(in vec2 z) {\n    return one - div(two, powexp(z + z) + one);\n}\n\nvec2 tanhyp(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(in vec2 z) {\n    return one + div(two, powexp(z + z) - one);\n}\n\nvec2 coth(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(in vec2 z) {\n    return recip(coshyp(z));\n}\n\nvec2 csch(in vec2 z) {\n    return recip(sinhyp(z));\n}\n\nvec2 arcsinh(in vec2 z) {\n    return ln(z + sqrtp(sqr(z) + one));\n}\n\nvec2 arccosh(in vec2 z) {\n    return ln(z + mul(sqrtp(z + one), sqrtp(z - one)));\n}\n\nvec2 arctanh(in vec2 z) {\n    return .5 * ln(div(one + z, one - z));\n}\n\nvec2 arccoth(in vec2 z) {\n    return .5 * ln(div(z + one, z - one));\n}\n\nvec2 arcsech(in vec2 z) {\n    return arccosh(recip(z));\n}\n\nvec2 arccsch(in vec2 z) {\n    return arcsinh(recip(z));\n}\n\nvec2 linear(in vec2 z, in vec2 a, in vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(in vec2 z, in vec2 a, in vec2 b, in vec2 c) {\n    return mul(z, mul(z, a) + b) + c;\n}\n\nvec2 cubic(in vec2 z, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return mul(z, mul(z, mul(z, a) + b) + c) + d;\n}\n\nvec2 gamma(in vec2 z) {\n    //https://www.shadertoy.com/view/WtlGDN\n    const float[6] p = float[] (2.506628275635, 225.525584619175, -268.295973841305, 80.9030806934622, -5.007578639705, 0.0114684895435);\n    vec2 zz = z.x > 1. ? z : one - z;\n    vec2 m = vec2(p[0], 0.);\n    for (int k = 1; k < p.length(); k++) {\n        m = m + p[k] * recip(zz + vec2(k, 0.));\n    }\n    vec2 zh = zz + vec2(5.65, 0.0);\n    vec2 w = powexp(ln(m) + mul(zz + vec2(.5, 0.), ln(zh)) - ln(zz) - zh);\n    return z.x > 1. ? w : pi * recip(mul(w, sine(pi * z)));\n}\n\nvec2 productlog(in int k, in vec2 z) {\n    vec2 m, w, mw, w2;\n    if (k == 0) {\n        //https://www.shadertoy.com/view/3lsGD4\n        m = sqrtp(2. * e * z + vec2(2., 0.));\n        w = 2. * ln(one + .8842 * m);\n        w = div(w - ln(one + .9294 * ln(one + .5106 * m)) - vec2(1.213, 0.), one + recip(w + vec2(4.69483568, 0.)));\n    } else {\n        w = ln(z) + float(2 * k) * pi * i;\n        w -= ln(w);\n    }\n    for (int k = 0; k < 8; k++) {\n        m = powexp(w);\n        mw = mul(m, w);\n        w2 = w + two;\n        w = div(mul(mw, sqr(w)) + mul(sqr(w2) - two, z), mul(mw + z, w2) + (m + m));\n    }\n    return w;\n}\n\nvec2 digamma(in vec2 z) {\n    vec2 zz = z.x < .5 ? one - z : z, a = vec2(0.), w = zz;\n    while (w.x < 8.) {\n        a += recip(w);\n        w += one;\n    }\n    vec2 zinv = recip(w);\n    w = ln(w) - 0.5 * zinv;\n    zinv = sqr(zinv);\n    w -= zinv / 12. - sqr(zinv) / 120. + cube(zinv) / 252. + a;\n    return (z.x < .5 ? pi * cot(pi * zz) + w : w);\n}\n\nvec2 trigamma(in vec2 z) {\n    vec2 zz = z.x < .5 ? one - z : z, a = vec2(0.), w = zz;\n    while (w.x < 8.) {\n        a += recip(sqr(w));\n        w += one;\n    }\n    w = recip(w) + 0.5 * recip(sqr(w)) + recip(cube(w)) / 6. - recip(power5(w)) / 30. + recip(power7(w)) / 42. + a;\n    return z.x < .5 ? sqr(pi * recip(sine(pi * zz))) - w : w;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 49, 105, 809], [811, 811, 868, 868, 1777]]}
{"id": "NsKyRw", "name": "Britney Inside", "author": "Sergeindamix", "description": "Just a simple chroma key shader for greenscreens.", "tags": ["simple", "chroma", "screen", "greenscreen", "shader", "green", "key", "mask", "alpha"], "likes": 1, "viewed": 187, "published": 3, "date": "1654610160", "time_retrieved": "2024-07-30T16:45:20.723324", "image_code": "#define s(x) smoothstep(0.15, 0.3, x * 1.1 - 0.1)\n\nvec3 chromaKey(vec3 x, vec3 y){\n\tvec2 c = s(vec2(x.g - x.r * x.y, x.g));\n    \n    return mix(x, y, c.x * c.y);\n}\n\nvec3 getTexture(vec2 p){\n\tvec4 s = texture(iChannel0, p);\n    return s.xyz * s.w;\n}\n\nvec3 getTexture1(vec2 p){\n\tvec4 s = texture(iChannel1, p);\n    return s.xyz * s.w;\n}\nconst mat2 rot = mat2( 0.6,  0.2, -0.2,  0.6 );\n\nvec2 hash( float n )\n{\n    float sn = sin(n);\n    return fract(vec2(sn,sn*42125.13));\n}\n\nfloat circleNoise( vec2 uv )\n{\n    float uv_y = floor(uv.y);\n    uv.x += uv_y*.31;\n    vec2 f = fract(uv);\n    vec2 h = hash(floor(uv.x)*uv_y);\n    float m = (length(f-.25-(h.x*.5)));\n    float r = h.y*.25;\n    return m = smoothstep(r-.10*r,r,h.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= sin(iTime*.5)+2.0;\n    uv += iTime*.4;\n    vec2 orig=uv;\n    vec2 offset=vec2(cos(iTime)*.5,sin(iTime)*.25);\n    uv=orig+=offset;\n    \n    \n    float m = 1.0;\n    for(float i=1.;i<=3.;i++)\n    {\n    \tuv = uv*rot*2.0+1121.13;\n    \tm *= clamp(circleNoise(uv)+.25*i,0.,1.);  \n    }    \n    fragColor = vec4(m);\n    if(fragColor.x>=.125)fragColor=texture(iChannel0,orig);\n\tif(fragColor.x>=.075 && fragColor.x<=.09375)fragColor=mix(fragColor,texture(iChannel3,orig),offset.x);\n\tif(fragColor.x>=.5)fragColor=texture(iChannel2,orig);\n\t//if(fragColor.x<=.06)fragColor=texture(iChannel1,orig);\n\t\n  \n    \n    vec3 background = getTexture1(uv);\n    \n    \n    uv=(fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    float mask = smoothstep(0.,.1,1.-length(uv)-.5);\n    \n    vec3 color = getTexture(uv);\n         color = chromaKey(color, background);\n         \n         vec2 LEFTTOP =vec2(.5,.5);\n         vec4 lt;\n         vec4 lb;\n         vec4 rt;\n         vec4 rb;\n         \n         //LT\n        if(orig.x>=LEFTTOP.x || orig.y<=LEFTTOP.y){lt=texture(iChannel0,orig/LEFTTOP);}\n        //LB \n        if(orig.x>=LEFTTOP.x || orig.y>=LEFTTOP.y){lb=texture(iChannel1,orig/LEFTTOP);}\n        //RT\n        if(orig.x<=LEFTTOP.x || orig.y<=LEFTTOP.y){rt=texture(iChannel2,orig/LEFTTOP);}\n        //RB\n        if(orig.x<=LEFTTOP.x || orig.y>=LEFTTOP.y){rb=texture(iChannel3,orig/LEFTTOP);}\n        \n        \n        \n        if( lt.x==0. )color=chromaKey(texture(iChannel0,orig/LEFTTOP).rgb, lb.rgb);\n        if( rt.x==0. )color=chromaKey(texture(iChannel0,orig/LEFTTOP).rgb, rb.rgb);\n        if( lb.x==0.)color=chromaKey(texture(iChannel2,orig/LEFTTOP).rgb, rb.rgb);\n        if( rb.x==0.)color=chromaKey(texture(iChannel2,orig*.5+.0125).rgb, lb.rgb);\n    \n\t//fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKyRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 82, 82, 163], [165, 165, 189, 189, 248], [250, 250, 275, 275, 334], [384, 384, 406, 406, 471], [473, 473, 503, 503, 723], [724, 724, 781, 781, 2607]]}
{"id": "sdGcRw", "name": "Artistic Beauty", "author": "LF1783", "description": "Art.", "tags": ["arty"], "likes": 1, "viewed": 187, "published": 3, "date": "1654593399", "time_retrieved": "2024-07-30T16:45:21.469330", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float time = iTime;\n for(int n=1; n<20; n++)\n   {\n      float i = float(n);\n      uv += vec2(\n        cos (0.7+sin(i+uv.y+time+0.3)+0.4),\n       atan     (0.4*sin(i*uv.x+time+0.3)+1.6)\n      );\n   }\n   vec3 res = vec3(0.5+sin(uv.x)+0.5,\n       0.5+sin(uv.y)+0.5,\n       sin(uv.x+uv.y));\n   fragColor = vec4(\n       res/res.b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 573]]}
{"id": "ssVczD", "name": "Split RGB", "author": "AShaderBeginner", "description": "My second shader.", "tags": ["colors"], "likes": 7, "viewed": 375, "published": 3, "date": "1654568322", "time_retrieved": "2024-07-30T16:45:22.208354", "image_code": "float f(float x){\n    return 1.0 - pow(cos(3.141 * x), 3.0);\n}\n\nfloat circ(float x, float y, float r){\n    return f(clamp(1.0 - pow(pow(mod(x, 2.0*r)/r-1.0, 2.0) + pow(mod(y,2.0*r)/r-1.0, 2.0), 0.5), 0.0, 1.0));\n}\n\nfloat distorted(float x, float y, float r, float cx ,float cy, float intensity){\n    return circ(\n               (x - cx) * intensity + cx,\n               (y - cy) * intensity + cy,\n               r\n           );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = iResolution.x / 20.0;\n    float x = fragCoord.x + iTime * r;\n    float y = fragCoord.y;\n    float cx = iResolution.x / 2.0 + iTime * r;\n    float cy = iResolution.y / 2.0;\n    \n    fragColor.r = distorted(x, y, r, cx, cy, 1.05);\n    fragColor.g = distorted(x, y, r, cx, cy, 1.10);\n    fragColor.b = distorted(x, y, r, cx, cy, 1.15);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVczD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 62], [64, 64, 102, 102, 213], [215, 215, 295, 295, 429], [431, 431, 488, 488, 837]]}
{"id": "NsKyzD", "name": "thermochronology", "author": "FabriceNeyret2", "description": "Floor undergo a daily cycle of temperature, plus the yearly cycle of seasons, plus the longer climatologic variations  ( Milankovic , etc ).\nThe heat diffusion propagates the filtered information in depth, which can be measured to read the past.\n", "tags": ["simulation", "earth", "short"], "likes": 7, "viewed": 289, "published": 3, "date": "1654541851", "time_retrieved": "2024-07-30T16:45:22.959346", "image_code": "// reference: https://en.wikipedia.org/wiki/Thermochronology\n// variant of https://shadertoy.com/view/NdVyzW\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R;\n    O = T(u);                     // red = hot, blue = cold\n    O.b = 1.-O.r;\n                                  // temperature curve with height\n    float v = .5 + (O.r-.5) / exp(4.*(U.y-1.)) - U.x; // amplifying the signal with depth\n    O = mix(O, vec4(0,1,0,1), smoothstep(1.5,0., abs(v)/fwidth(v)) ); \n    \n    if ( int(u)==int(R)/2 ) O++;  // ref axis\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "buffer_a_code": "#define S(n) ( .5+.5*sin(n*iTime) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R;\n    O = textureLod(iChannel0, U,floor(log2(R.y)-6.) ); // diffusion\n        if ( U.y>.95 ) O.r = (  S(10.)                 // daily temperature variations\n                          + S( 1.)                     // \"seasonal\" temperature variations\n                          + S( .1) ) /3.;              // \"climatologic\" temperature variations\n    if (iFrame<1) O.r=.5;                              // initialization\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKyzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 148, 148, 525]]}
{"id": "7sKcz1", "name": "Evenly Spaced Grid", "author": "pyBlob", "description": "All big dots are draggable.\nMapping between image and plane coordinates with a single matrix using:\n- Image of origin\n- Image of main directions\n- Screen space ratio to image of first units", "tags": ["grid", "geometry", "projective"], "likes": 9, "viewed": 274, "published": 3, "date": "1654541608", "time_retrieved": "2024-07-30T16:45:23.704354", "image_code": "// Rough version using one axis in 2D-space: https://www.shadertoy.com/view/fdVcR1\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    initView(iResolution);\n    vec2 uv = fromView(O);\n    vec2 click = fromView(abs(iMouse.zw));\n    vec2 mouse = fromView(abs(iMouse.xy));\n    \n    vec2 o = getPoint(0); // zero\n    vec2 u = getPoint(1); // u-infinity\n    vec2 v = getPoint(2); // v-infinity\n\n    // g = distance(zero, one) / distance(zero, infinity)\n    vec2 g  = getPoint(3);\n    vec2 gu = mix(o, u, g.x); // u-one\n    vec2 gv = mix(o, v, g.y); // v-one\n\n    // gf = distance(zero, one) / distance(zero, infinity)\n    vec2 gf = g / (1. - g);\n\n    // Those are homogenous matrices, their scale does not matter:\n    //   As long as you keep all signs, you can skip multiplication\n    //   with the determinant during inversion\n    mat3 T = mat3(vec3(u, 1.) * gf.x, vec3(v, 1) * gf.y, vec3(o, 1));\n    mat3 Ti = inverse(T);\n\n    vec2 ij = P(Ti * vec3(uv, 1));\n\n    C = vec4(1);\n\n    // Grid\n    vec2 grid = abs(ij - round(ij)) / fwidth(ij);\n    if ((T * vec3(ij, 1)).z > 0.)\n    {\n        C = pow(texture(iChannel1, ij, -1.), vec4(2));\n        C = blend(C, vec3(0), min(grid.x, grid.y));\n    }\n\n    // Dots at grid junctions\n    vec3 z = T * vec3(round(ij), 1);\n    if (z.z > 0.)\n        C = blend(C, vec3(0), distance(uv, P(z)) / f - 1.5);\n\n    // One unit in u/v directions\n    C = blend2(C, colors[1], distance(uv, gu) / f - 3.);\n    C = blend2(C, colors[2], distance(uv, gv) / f - 3.);\n\n    // Horizon\n    float fuv = clamp(dot(uv-u, v-u) / dot(v-u, v-u), 0., 1.);\n    C = blend(C, mix(colors[1], colors[2], fuv), sdLine(uv, u, v, -inf, inf) / f - .5);\n\n    // Handles\n    for (int i=0 ; i<3 ; ++i)\n        C = blend2(C, colors[i], distance(uv, getPoint(i)) / f - 3.);\n    C = blend2(C, colors[3], distance(O, getPoint(3)*iResolution.xy) - 3.);\n\n    C = sqrt(C);\n}\n", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 C, in vec2 O)\n{\n    ivec2 I = ivec2(O);\n    C = texelFetch(iChannel0, I, 0);\n\n    initView(iResolution);\n    vec2 click = fromView(abs(iMouse.zw));\n    vec2 mouse = fromView(abs(iMouse.xy));\n    vec2 absMouse = abs(iMouse.xy);\n    bool down = iMouse.z > 0.;\n    bool pressed = iMouse.w > 0.;\n    bool init = iFrame == 0;\n    float demo = float(iMouse == vec4(0));\n    int activeIndex = getActiveIndex();\n\n    vec2 o  = getPoint(0);\n    vec2 du = getPoint(1) - o;\n    vec2 dv = getPoint(2) - o;\n\n    vec2 g  = getPoint(3);\n    vec2 gu = o + du * g.x;\n    vec2 gv = o + dv * g.y;\n    \n    if (I == ivec2(0, 1))\n    {\n        if (init)\n        {\n            activeIndex = -1;\n        }\n        else if (pressed)\n        {\n            activeIndex = -1;\n            float best = 30. * f;\n            for (int i=0 ; i<3 ; ++i)\n            { float r = distance(mouse, getPoint(i)); if (r < best) activeIndex = i, best = r; }\n            { float r = distance(mouse, fromView(g*iResolution.xy)); if (r < best) activeIndex = 3, best = r; }\n            { float r = distance(mouse, gu); if (r < best) activeIndex = -2, best = r; }\n            { float r = distance(mouse, gv); if (r < best) activeIndex = -3, best = r; }\n        }\n        else if (!down)\n        {\n            activeIndex = -1;\n        }\n        C = vec4(activeIndex);\n    }\n    else if (I.y == 0 && I.x < npoints)\n    {\n        if (init || demo!=0.)\n        {\n            //C = vec4(.5, .5, 0, 0);\n            if (I.x == 0) C = vec4(.5 + 0.3 * demo * sin(iTime), .2, 0, 0);\n            if (I.x == 1) C = vec4(.8, .6 + 0.1 * demo * cos(iTime), 0, 0);\n            if (I.x == 2) C = vec4(.2, .6 - 0.1 * demo * cos(iTime), 0, 0);\n            if (I.x == 3) C = vec4(.15, .2, 0, 0) + 0.1 * demo * vec4(cos(iTime/5.), sin(iTime/5.), 0, 0);\n            if (I.x != 3)\n            {\n                C.xy *= iResolution.xy;\n                C.xy = fromView(C.xy);\n            }\n        }\n        else if (down)\n        {\n            if (activeIndex == I.x)\n            {\n                if (activeIndex == 3)\n                    C = vec4(absMouse / iResolution.xy, 0, 0);\n                else\n                    C = vec4(mouse, 0, 0);\n            }\n            else if (activeIndex == -2 && I.x == 3)\n                C.x = dot(mouse - o, du) / dot(du, du);\n            else if (activeIndex == -3 && I.x == 3)\n                C.y = dot(mouse - o, dv) / dot(dv, dv);\n        }\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define getActiveIndex() int(texelFetch(iChannel0, ivec2(0, 1), 0).x)\n#define getPoint(i) texelFetch(iChannel0, ivec2(i, 0), 0).xy\n\nconst int npoints = 4;\n\nfloat f;\nvec2 cResolution;\n\nvoid initView(vec3 iResolution)\n{\n    f = 5. / iResolution.y;\n    cResolution = iResolution.xy;\n}\n\nvec2 fromView(vec2 O)\n{\n    vec2 uv = O;\n    uv.x -= cResolution.x / 2.;\n    uv.y -= cResolution.y / 2.;\n    uv *= f;\n    return uv;\n}\n\nfloat inf = 1e3;\n\nfloat sdLine(vec2 p, vec2 a, vec2 b, float i, float j)\n{\n    vec2 v = b - a;\n    vec2 l = p - a;\n    float h = dot(l, v) / dot(v, v);\n    return length(l - v * clamp(h, i, j));\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n    return sdLine(p, a, b, 0., 1.);\n}\n\nvec4 blend(vec4 C, vec3 c, float r)\n{\n    return mix(C, vec4(c, 1), clamp(1. - r, 0., 1.));\n}\n\nvec4 blend2(vec4 C, vec3 c, float r)\n{\n    return blend(blend(C, vec3(0), r-1.), c, r);\n}\n\nvec2 perp(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nconst vec3 colors[] = vec3[](\n    vec3(0,.2,1),\n    vec3(1,.2,0),\n    vec3(0,0.5,0),\n    vec3(0.5)\n);\n\nvec2 P(vec3 x)\n{\n    return x.xy / x.z;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKcz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 123, 123, 1858]]}
{"id": "fdVcR1", "name": "Evenly Spaced Line", "author": "pyBlob", "description": "Click-Position = Blue line\nDrag-Position = Orange line", "tags": ["visualization", "geometry", "projective"], "likes": 8, "viewed": 232, "published": 3, "date": "1654541600", "time_retrieved": "2024-07-30T16:45:24.453351", "image_code": "/*\nStreamlined version using two directions in 3D-space: https://www.shadertoy.com/view/7sKcz1\n\n# Problem\n\nGiven the directions to following points in 2D-space:\n    - Zero (blue dot)\n    - Unit (orange dot)\n    - Infinity (end of green line)\nWhere are integer multiples of Unit (green dots)?\n\n# Solution\n\nNote: 0 is the projection center. It is different from Zero of the sought line.\n\n1. Choose an arbitrary point Zero != 0 on the Zero-direction\n2. Find Unit by intersecting two lines:\n    - Line(via=Zero, to=Infinity)\n    - Line(via=0   , to=Unit)\n3. Multiples = Zero + i * (Unit - Zero)\n*/\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    initView(iResolution);\n    vec2 uv = fromView(O - .5);\n    vec2 click = fromView(abs(iMouse.zw));\n    vec2 mouse = fromView(abs(iMouse.xy));\n    if (iMouse == vec4(0))\n        click = vec2(-.5+sin(iTime), -2.), mouse = vec2(.3+sin(iTime), -1.);\n    \n    vec2 a = click;\n    vec2 b = mouse;\n    vec2 bw = perp(b);\n    vec2 v = b - a;\n    v = vec2(cos(cos(iTime)*.5), sin(cos(iTime)*.5));\n    vec2 w = perp(v);\n    float vf = -dot(a, bw) / dot(v, bw);\n\n    C = vec4(1);\n    float af = dot(uv, w) / dot(a, w);\n    float i = -dot(a * af - uv, v) / (vf * af * dot(v, v));\n    i = round(i);\n    {\n        vec2 x = a + i * vf * v;\n        C = blend(C, vec3(0), sdLine(uv, vec2(0), x, 0., inf) / f);\n        vec3 color = colors[2];\n        float size = 2.;\n        if (round(i) == 0.)\n            color = colors[0], size = 3.;\n        if (round(i) == 1.)\n            color = colors[1], size = 3.;\n        C = blend(C, color, length(uv - x) / f - size);\n    }\n    C = blend(C, vec3(0,0.5,0), sdLine(uv, vec2(0), v, -inf, inf) / f - .5);\n    C = blend(C, vec3(0,.2,1), sdLine(uv, vec2(0), a, 0., inf) / f - .5);\n    C = blend(C, vec3(1,.2,0), sdLine(uv, vec2(0), b, 0., inf) / f - .5);\n    C = blend(C, vec3(1,.2,0), length(uv - b) / f - 4.5);\n    C = blend(C, vec3(1), length(uv - b) / f - 2.5);\n    C = sqrt(C);\n}\n", "image_inputs": [], "common_code": "float inf = 1e3;\n\nfloat sdLine(vec2 p, vec2 a, vec2 b, float i, float j)\n{\n    vec2 v = b - a;\n    vec2 l = p - a;\n    float h = dot(l, v) / dot(v, v);\n    return length(l - v * clamp(h, i, j));\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n    return sdLine(p, a, b, 0., 1.);\n}\n\nvec4 blend(vec4 C, vec3 c, float r)\n{\n    return mix(C, vec4(c, 1), clamp(1. - r, 0., 1.));\n}\n\nfloat f;\nvec2 cResolution;\n\nvoid initView(vec3 iResolution)\n{\n    f = 5. / iResolution.y;\n    cResolution = iResolution.xy;\n}\n\nvec2 fromView(vec2 O)\n{\n    vec2 uv = O;\n    uv.x -= cResolution.x / 2.;\n    uv.y -= cResolution.y / 2.;\n    uv *= f;\n    return uv;\n}\n\nconst vec3 colors[] = vec3[](vec3(0,.2,1), vec3(1,.2,0), vec3(0,0.5,0));\n\nvec2 perp(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVcR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[595, 595, 634, 634, 1944]]}
{"id": "NsVczW", "name": "threepointcurve", "author": "Del", "description": "a slight remix of Arc from three points (https://www.shadertoy.com/view/NdycRW) - using IQ's\nsdCutDisk (https://www.shadertoy.com/view/ftVXRc)", "tags": ["curve"], "likes": 10, "viewed": 248, "published": 3, "date": "1654537273", "time_retrieved": "2024-07-30T16:45:25.194370", "image_code": "// a slight remix of Arc from three points (https://www.shadertoy.com/view/NdycRW)\n// using IQ's sdCutDisk (https://www.shadertoy.com/view/ftVXRc)\n\n\n// r=radius, h=height\nfloat sdCutDisk( in vec2 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for a given shape\n    \n    p.x = abs(p.x);\n    \n    // select circle or segment\n    float s = max( (h-r)*p.x*p.x+w*w*(h+r-2.0*p.y), h*p.x-w*p.y );\n\n    return (s<0.0) ? length(p)-r :        // circle\n           (p.x<w) ? h - p.y     :        // segment line\n                     length(p-vec2(w,h)); // segment corner\n}\n\nvec2 project(in vec2 a, in vec2 b)\n{\n    return b * (dot(a, b) / dot(b, b));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    //arc from three points\n    vec2 a = vec2(-0.4,0.0);\n    vec2 b = vec2(0.0, 0.5);\n    if (iMouse.z>0.5)\n        b = m;\n    vec2 c = (vec2(0.4, 0.2) + vec2(sin(iTime), cos(iTime)) * 0.3);\n    \n    //based on https://mathopenref.com/arcradius.html\n    vec2 dir = c - a;\n    vec2 mid = mix(a, c, 0.5);\n    float w = length(dir);\n    vec2 normal = normalize(b - (project(b - a, dir) + a));\n    float h = length(mid - b);\n    float rad = max(w*0.5, h*0.5 + (w*w) / (8.0*h));\n   \n    //re-align b to match the arc top\n    b = mid + normal * h;\n\n    // show arc distance (using IQs sdCutDisk)\n    dir/=w;\n    vec2 pp = b - (normal * (rad));\n    pp = mat2(dir.x,-dir.y,dir.y,dir.x) * (p-pp);\n    pp.y *= sign(normal.y);\n    float d = sdCutDisk(pp,rad,rad-h);\n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.5,0.85,1.0);\n    col *= 1.0 - exp(-7.0*abs(d));\n    col *= 0.8 + 0.2*cos(128.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    //draw points A,B,C\n    float distToPoint = min(min(length(p - a), length(p - b)), length(p - c));\n    col = mix(vec3(1.0,0.0,0.0),col,smoothstep(0.0,0.015,distToPoint-0.025));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 171, 225, 225, 586], [588, 588, 624, 624, 666], [669, 669, 726, 762, 2088]]}
{"id": "NdKyRD", "name": "Neural CA fork", "author": "silvestru", "description": "Created for AIAIART #8 (https://colab.research.google.com/drive/1Qpx_4wWXoiwTRTCAP1ohpoPGwDIrp9z-?usp=sharing) - currently a WIP, lesson comes out properly this weekend :)", "tags": ["clip", "nca"], "likes": 3, "viewed": 235, "published": 3, "date": "1654534471", "time_retrieved": "2024-07-30T16:45:26.113911", "image_code": "// Fork of \"Neural CA Demo\" by johnowhitaker. https://shadertoy.com/view/ftSfzG\n// 2022-06-06 16:53:51\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Apply zoom (can't figure out how to re-size buffers \n    // so this wastes a lot of compute updating the offscreen parts)\n    uv = uv/2.;\n\n    // Read the buffer\n    vec3 col = (texture(iChannel0, uv).xyz-vec3(0.5))*10. + vec3(0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Paste your weights hre:\nconst int nh = 16;\nfloat b1[16] = float[16](-0.03493387997150421,-0.10716474056243896,0.3282867670059204,-0.1208450049161911,0.1560712605714798,0.05483105778694153,-0.05130641162395477,-0.048943594098091125,0.12394221127033234,0.07236608117818832,-0.10005078464746475,0.0866173580288887,0.10229668766260147,0.12560752034187317,0.029041897505521774,-0.1220850422978401);\nfloat w1[256] = float[256](-0.3977280855178833,0.10077136754989624,-0.1696157604455948,-0.02370043285191059,0.3227560818195343,0.16628700494766235,0.021654894575476646,-0.13723382353782654,-0.0428946353495121,-0.15965507924556732,-0.24806667864322662,-0.11035522818565369,0.005852674134075642,0.1373792141675949,-0.105523020029068,0.07499191164970398,-0.0020828035194426775,-0.011740612797439098,-0.24516360461711884,-0.016380181536078453,-0.3515242040157318,0.21215514838695526,0.20363038778305054,0.2092709243297577,-0.0634683147072792,0.03718245401978493,-0.15398837625980377,0.04632727801799774,0.11724033951759338,0.001949547789990902,0.47529658675193787,-0.19606049358844757,-0.2939988076686859,-0.22758153080940247,-0.06444992125034332,-0.037138067185878754,0.017914628610014915,0.16452132165431976,-0.05846777185797691,0.13793019950389862,0.05386471003293991,-0.24677370488643646,0.17700843513011932,-0.22743450105190277,0.17458108067512512,-0.17231743037700653,-0.07548206299543381,0.2870756685733795,0.12965868413448334,0.0821027085185051,0.04580215737223625,-0.06107872352004051,0.1768023818731308,-0.052107084542512894,0.15958517789840698,-0.094985730946064,-0.048802271485328674,0.03243787959218025,0.33224406838417053,0.144126757979393,-0.04608708247542381,0.25092536211013794,-0.03714563697576523,0.16364307701587677,-0.06535161286592484,-0.10936438292264938,-0.0032730104867368937,0.08396880328655243,0.28338176012039185,0.02589745819568634,0.28387197852134705,-0.14194457232952118,-0.39022231101989746,0.29011470079421997,-0.2553168535232544,0.07650812715291977,-0.1123335137963295,-0.031892284750938416,0.0835525318980217,-0.14506898820400238,-0.1488645374774933,0.09700801223516464,-0.17523863911628723,-0.14796055853366852,-0.20786601305007935,-0.14043325185775757,0.09612595289945602,-0.03260720148682594,0.2327413260936737,-0.24866364896297455,0.0588473342359066,-0.2568831443786621,0.10121035575866699,-0.05432509630918503,-0.17823414504528046,-0.2608868181705475,0.055601999163627625,0.33188939094543457,-0.09271840751171112,0.050815608352422714,-0.015439629554748535,-0.08063589781522751,-0.08342310786247253,0.0506211593747139,0.05467955768108368,-0.16247037053108215,-0.09010499715805054,0.14705918729305267,-0.23720023036003113,-0.03375853970646858,-0.30959653854370117,0.03209728002548218,0.11714625358581543,-0.08765064179897308,0.2126082479953766,-0.12496152520179749,-0.12936192750930786,0.17036810517311096,-0.06433917582035065,0.03042437881231308,-0.12154068052768707,0.03164992108941078,-0.013636874966323376,-0.10836279392242432,0.1419989913702011,0.12159768491983414,-0.1481722593307495,-0.3693365752696991,0.03972162306308746,0.2999219596385956,-0.03962958976626396,0.10690027475357056,0.1488490104675293,0.10628245025873184,0.04798061400651932,0.03348063305020332,0.05058204010128975,0.17883922159671783,0.19839176535606384,0.14659644663333893,0.09289384633302689,0.046946000307798386,0.016967816278338432,-0.24599415063858032,-0.22083035111427307,-0.23827692866325378,-0.20355288684368134,-0.09406838566064835,-0.02671331726014614,-0.02685202844440937,0.10968207567930222,0.0538632869720459,-0.1967705339193344,-0.190314382314682,-0.1381479650735855,0.2598235607147217,-0.0978485494852066,-0.22819964587688446,-0.15840190649032593,-0.1430305689573288,-0.33116862177848816,0.23568186163902283,0.05436043068766594,0.011860264465212822,0.16557109355926514,-0.36186686158180237,0.02463310956954956,-0.1996515393257141,0.09327997267246246,-0.17235471308231354,0.13313257694244385,-0.04175050929188728,0.17693153023719788,-0.08876563608646393,-0.17364217340946198,-0.17678724229335785,0.31514349579811096,0.025052759796380997,0.04145249351859093,-0.06055590882897377,-0.16541403532028198,0.19785647094249725,-0.006905845366418362,-0.06857794523239136,-0.01297837495803833,-0.014715751633048058,-0.0765470638871193,-0.22209611535072327,0.32330676913261414,-0.14500194787979126,0.1254693865776062,0.11155153065919876,-0.007389431819319725,-0.2382853776216507,-0.03194563835859299,0.030663205310702324,-0.13928428292274475,0.1281270980834961,-0.07726286351680756,-0.25983670353889465,0.22858379781246185,0.17520421743392944,0.1302463263273239,0.09278559684753418,0.04652721807360649,-0.007974999956786633,0.020420923829078674,-0.15794144570827484,0.1087065115571022,-0.02570623904466629,0.09485962241888046,-0.23127031326293945,0.10229451209306717,0.09409064799547195,0.031797394156455994,0.2075047791004181,0.010021625086665154,-0.055906496942043304,-0.06868503242731094,0.1187545508146286,-0.3361269533634186,-0.17113858461380005,-0.02865631878376007,-0.16911807656288147,-0.37431448698043823,-0.07040221989154816,0.00295406486839056,0.1399047076702118,0.10285413265228271,-0.012248911894857883,-0.10740359127521515,0.14315006136894226,0.007016888819634914,-0.2389175146818161,-0.2690475285053253,-0.07614410668611526,0.1920141577720642,0.20697186887264252,-0.2964780032634735,0.294106662273407,0.22312653064727783,-0.0966089516878128,0.27073124051094055,-0.20478402078151703,0.10303756594657898,0.06680048257112503,0.027842942625284195,-0.05004475265741348,0.19907864928245544,0.002264474518597126,-0.20953263342380524,0.13965140283107758,-0.16396641731262207,0.10652535408735275,0.12624235451221466,0.24580858647823334);\nfloat w2[64] = float[64](-0.037627652287483215,-0.04721059650182724,0.10331153869628906,-0.003279761876910925,0.018483910709619522,-0.07728970050811768,0.0023611593060195446,-0.1081169918179512,-0.031953245401382446,-0.0011707200901582837,0.15796048939228058,0.05362563207745552,0.04315163195133209,-0.030300322920084,0.047273024916648865,-0.06979307532310486,-0.11747297644615173,0.07404306530952454,-0.007222822867333889,0.033472415059804916,-0.07653094828128815,-0.10037235915660858,0.08676105737686157,0.059604711830616,-0.02251582406461239,-0.013360588811337948,-0.0878024771809578,-0.02854633331298828,0.02425902709364891,0.027499059215188026,0.05838710442185402,0.014263704419136047,0.028584493324160576,0.09932110458612442,-0.09932925552129745,0.06605923920869827,0.0420692153275013,-0.1443200707435608,0.058018770068883896,0.08876988291740417,0.0020808011759072542,0.04425524175167084,0.010630695149302483,-0.04017648845911026,-0.024900995194911957,-0.03725288435816765,-0.017006555572152138,-0.0008521393756382167,0.07511387765407562,-0.050601519644260406,0.09272532165050507,0.008488296531140804,0.011780519038438797,-0.015431687235832214,0.02026827447116375,-0.06025946885347366,-0.0035887188278138638,0.07429978996515274,-0.1464838683605194,-0.10232546180486679,-0.04530342295765877,-0.037816908210515976,-0.024610430002212524,0.05378115922212601);\n\n//Try this one:\n//const int nh = 16;\n//float b1[16] = float[16](-0.12456363439559937,0.0014599391724914312,-0.12625542283058167,0.05571504682302475,-0.1598033756017685,-0.08626449108123779,0.07393699884414673,0.0771358460187912,0.11873732507228851,-0.17219682037830353,-0.001982270972803235,0.2054184228181839,-0.08368118107318878,-0.2386559247970581,0.015173559077084064,-0.0485927201807498);\n//float w1[256] = float[256](0.29878896474838257,-0.01218341663479805,0.21580684185028076,0.007059651892632246,0.13408909738063812,0.03354993835091591,-0.35135456919670105,-0.23545853793621063,0.14670734107494354,-0.1725963056087494,-0.20654956996440887,0.10031343996524811,0.27579233050346375,0.07302017509937286,-0.00532222306355834,0.014191029593348503,-0.02150343731045723,0.1765517294406891,-0.10739174485206604,0.21030758321285248,-0.010910941287875175,0.2540366053581238,0.06531855463981628,-0.2630201280117035,-0.19651105999946594,-0.08421865850687027,0.00426778057590127,-0.24097266793251038,-0.15228746831417084,-0.1968274712562561,-0.1300676017999649,0.1935960352420807,0.014995880424976349,-0.10440982133150101,0.27504652738571167,0.2397836148738861,0.03602788224816322,0.06728735566139221,0.22330553829669952,0.07884912192821503,0.05646572634577751,-0.20508337020874023,0.16997914016246796,0.10849592834711075,-0.01899620145559311,0.11630455404520035,-0.1491909772157669,0.1897490918636322,0.17633457481861115,-0.29445508122444153,-0.030528217554092407,0.048705488443374634,0.310365229845047,0.057619597762823105,-0.07535679638385773,-0.1397850066423416,-0.26017892360687256,0.2149643450975418,0.20088770985603333,-0.20902326703071594,-0.03420129045844078,-0.26269063353538513,-0.0253387950360775,-0.010661919601261616,0.10321572422981262,0.12564872205257416,-0.07548441737890244,-0.2623882591724396,-0.05894380435347557,0.16490323841571808,-0.1613217443227768,0.20617260038852692,0.13020744919776917,-0.040533646941185,-0.22535401582717896,-0.2245151549577713,0.16697479784488678,-0.17086300253868103,0.10498687624931335,0.2541685104370117,-0.13744774460792542,-0.05267626419663429,0.25038236379623413,-0.22175106406211853,-0.2730776071548462,-0.1694387048482895,0.10514041036367416,-0.02866409160196781,-0.1387905478477478,-0.12291198968887329,0.09265997260808945,-0.24002069234848022,-0.08158763498067856,0.15747614204883575,-0.09706073999404907,-0.14679589867591858,0.07758203893899918,-0.16400744020938873,0.10406982153654099,-0.031934838742017746,0.18125997483730316,-0.06274227052927017,-0.14909091591835022,0.1020122542977333,-0.23082520067691803,0.13469554483890533,0.19411182403564453,0.23168238997459412,-0.1090119257569313,-0.24981936812400818,0.1696825474500656,-0.011052995920181274,0.21963302791118622,-0.03662069886922836,0.006105206906795502,0.18052692711353302,-0.26270368695259094,-0.02183554321527481,-0.2924295663833618,0.030967125669121742,0.234159916639328,-0.01245027594268322,0.2412480115890503,-0.285267174243927,0.017854131758213043,-0.0990714505314827,0.08976224809885025,-0.05474643409252167,-0.06104690954089165,0.15054281055927277,0.019128913059830666,0.11521913856267929,0.2660802900791168,0.08595430105924606,0.27080997824668884,-0.19135352969169617,0.1547759771347046,-0.0939982607960701,-0.24354322254657745,-0.3342815041542053,-0.11826377362012863,0.04889857769012451,-0.005967918783426285,-0.0921286940574646,-0.031696684658527374,0.15567676723003387,0.004692587535828352,-0.07729031890630722,-0.0008721477352082729,-0.16060221195220947,0.0020936657674610615,0.04631349444389343,-0.21317866444587708,-0.16970258951187134,-0.06047441437840462,-0.04840724542737007,-0.1907571256160736,0.06838184595108032,-0.162420392036438,0.2360328584909439,-0.27175790071487427,-0.028165964409708977,0.43607330322265625,0.21265295147895813,-0.012519770301878452,-0.017366932705044746,-0.05396779254078865,-0.1466580480337143,0.08263175189495087,0.01665094494819641,0.020021574571728706,0.007871863432228565,0.34841856360435486,0.08909270912408829,-0.16889746487140656,-0.052795879542827606,-0.10766635835170746,-0.07223393768072128,-0.1461402326822281,-0.17135562002658844,-0.0943448543548584,-0.06015118211507797,-0.16038385033607483,0.048993825912475586,0.13213574886322021,-0.20373283326625824,0.014941846951842308,0.2745451331138611,-0.007811054587364197,-0.22924306988716125,0.1981671154499054,-0.3347971439361572,0.12327034026384354,0.1606578528881073,0.34393227100372314,-0.07774411141872406,-0.10012626647949219,0.0434986837208271,0.24916282296180725,-0.010352550074458122,0.14922979474067688,0.09712318331003189,-0.2562682032585144,0.022768793627619743,-0.11582522839307785,0.16360192000865936,-0.15763147175312042,-0.05788576230406761,0.17763979732990265,0.27340084314346313,-0.05838683620095253,-0.20121482014656067,0.08125601708889008,0.1264190971851349,0.1967422515153885,-0.013940039090812206,0.06389348953962326,-0.07705265283584595,0.12498480081558228,0.2561611831188202,0.29565849900245667,0.08343575894832611,-0.12196356803178787,0.08790794014930725,-0.009080911055207253,0.24673861265182495,-0.20935019850730896,0.05218696966767311,0.23003453016281128,-0.06693864613771439,0.013903125189244747,-0.030288642272353172,0.058424342423677444,-0.2727517783641815,-0.031235070899128914,0.031171290203928947,0.19753600656986237,0.41765472292900085,-0.1004558876156807,0.02985973469913006,0.09803547710180283,-0.1701550930738449,-0.23704859614372253,0.11541874706745148,0.007316194474697113,-0.16992172598838806,-0.004901675507426262,-0.24797937273979187,0.11361737549304962,0.177936851978302,-0.2095121294260025,-0.09153330326080322,0.13593526184558868,0.21086157858371735,0.03888098523020744,0.24321484565734863);\n//float w2[64] = float[64](-0.03250373899936676,0.09057306498289108,0.030593153089284897,-0.06133126839995384,-0.04308276250958443,-0.026851560920476913,-0.03364826738834381,0.011371323838829994,-0.01793096587061882,-0.022006554529070854,0.11912167817354202,-0.02678142674267292,0.058701518923044205,-0.04198088496923447,-0.07674757391214371,0.062471259385347366,-0.027833284810185432,0.0035922268871217966,0.007990445010364056,-0.049327969551086426,0.029241599142551422,0.02785487100481987,-0.03600781410932541,0.03756382688879967,-0.09185482561588287,0.040369030088186264,-0.026854194700717926,0.02558893710374832,0.08188150823116302,-0.009044118225574493,-0.02627185732126236,0.011147023178637028,0.0335681214928627,-0.017458448186516762,0.020906392484903336,-0.048782553523778915,0.030438020825386047,0.029651910066604614,0.0920482948422432,-0.07077661156654358,-0.023768993094563484,0.053314290940761566,-0.006387596018612385,0.014748336747288704,-0.0659249797463417,0.0554671473801136,0.010783422738313675,-0.008800152689218521,-0.027040531858801842,0.04030459746718407,0.029981281608343124,0.024064600467681885,-0.04541541263461113,-0.01698555424809456,0.025706863030791283,0.0007951497682370245,0.04347550496459007,0.07977954298257828,-0.06669053435325623,-0.06965472549200058,0.05847298353910446,-0.03257176652550697,-0.019977224990725517,0.018568849191069603);\n\n\n\n// Random Number Generator\n// From https://www.shadertoy.com/view/MsKGWz:\n// See Stack Overflow: http://stackoverflow.com/questions/5149544/can-i-generate-a-random-number-inside-a-pixel-shader/10625698#10625698\nfloat random_1( vec2 p )\n{\n    vec2 r = vec2(\n        23.14069263277926, // e^pi (Gelfond's constant)\n         2.665144142690225 // 2^sqrt(2) (Gelfondâ€“Schneider constant)\n    );\n    return fract( cos( mod( 12345678., 256. * dot(p,r) ) ) );\n}\n\n// Samples the neighbourhood (wrapping around where needed)\nvec2 coord (vec2 fragCoord, vec2 offset){\n    float x = mod(fragCoord.x + offset.x, iResolution.x);\n    float y = mod(fragCoord.y + offset.y, iResolution.y);\n    return vec2(x, y)/iResolution.xy;\n}\nvec4[9] sample_tex (vec2 fragCoord){\n    vec4 tex[9] = vec4[9](\n        (texture(iChannel0, coord(fragCoord, vec2(-1, 1)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(0, 1)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(1, 1)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(-1, 0)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(0, 0)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(1, 0)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(-1, -1)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(0, -1)))-0.5)*10.,\n        (texture(iChannel0, coord(fragCoord, vec2(1, -1)))-0.5)*10.\n    );\n    return tex;\n}\n\n// The four kernels used\nvec4 ident(vec2 fragCoord, vec4[9] tex){\n    return tex[4]; // no offset\n}\nvec4 sobel_x(vec2 fragCoord, vec4[9] tex){\n    vec4 result = -1.*tex[0]-2.*tex[3]-1.*tex[6]+1.*tex[2]+2.*tex[5]+1.*tex[8];\n    return result;\n}\nvec4 sobel_y(vec2 fragCoord, vec4[9] tex){\n    vec4 result = -1.*tex[0]-2.*tex[1]-1.*tex[2]+1.*tex[6]+2.*tex[7]+1.*tex[8];\n    return result;\n}\nvec4 lap(vec2 fragCoord, vec4[9] tex){\n    vec4 result = 1.*tex[0]+2.*tex[1]+1.*tex[2]+2.*tex[3]-12.*tex[4]+2.*tex[5]+1.*tex[6]+2.*tex[7]+1.*tex[8]; // was an errant +2.\n    return result;\n}\n\n// Our activation function\nfloat relu(float x){\n    if (x > 0.){return x;}\n    return 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Sample BufC for kernels\n    vec4 tex[9] = sample_tex(fragCoord);\n    \n    // Apply filters\n    vec4 id = ident(fragCoord, tex);\n    vec4 sx = sobel_x(fragCoord, tex);\n    vec4 sy = sobel_y(fragCoord, tex);\n    vec4 ll = lap(fragCoord, tex);\n    \n    // Create x (4 channels x 4 filters, per channel conv)\n    float x[16];\n    x[0] = id.x;x[1] = sx.x;x[2] = sy.x;x[3] = ll.x;\n    x[4] = id.y;x[5] = sx.y;x[6] = sy.y;x[7] = ll.y;\n    x[8] = id.z;x[9] = sx.z;x[10] = sy.z;x[11] = ll.z;\n    x[12] = id.w;x[13] = sx.w;x[14] = sy.w;x[15] = ll.w;\n    \n    \n    // First layer \n    float l1_out[nh];\n    for (int i = 0; i < nh; i++){\n        // Dot Product equivalent to:\n        // dot_product = x @ w1_i\n        float dot_product = 0.;\n        for (int j = 0; j < 16; j++){\n            dot_product += x[j]*w1[i*16+j];\n        }\n        // Add bias then RELU\n        l1_out[i] = relu(dot_product+b1[i]);  ;\n    }\n    \n    // Second layer\n    float l2_out[4];\n    for (int i = 0; i < 4; i++){\n        float dp2 = 0.;\n        for (int j = 0; j < nh; j++){\n            dp2 += l1_out[j]*w2[i*nh+j];\n        }\n        l2_out[i] = dp2; \n    }\n    \n    // Proposed update\n    vec4 y = vec4(l2_out[0], l2_out[1], l2_out[2], l2_out[3]);\n    \n    // Output as prev state\n    fragColor = id*0.1 + vec4(0.5);\n    \n    \n    // If (noise>0.5) apply update\n    vec2 p = vec2(uv.x/2.+sin(iTime/1000.), uv.y/2.+cos(iTime/1000.));\n    if (random_1(p) < 0.5){\n        fragColor = (id + y)*0.1 + vec4(0.5);\n    }\n    \n    // If (mouse down) paint grey around it\n    if(length(fragCoord.xy-iMouse.xy/2.)<(20.)){\n        if (iMouse.z>0.5){fragColor = vec4(0.5);}\n    }\n    \n    // Init \n    if (iFrame==0){fragColor = vec4(0.5);}\n    \n    \n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 161, 211, 554]]}
{"id": "NdVyzW", "name": "thermal inversion in atmosphere", "author": "FabriceNeyret2", "description": "atmosphere is like water in a pan: \nFloor is heat by Sun and cold by night radiation.\nThis transfer to the air above, which temperature diffuse slowly upwise.\nBut diffusion delay vs day alternance creates a temporary roof for clouds: the thermal inversion", "tags": ["simulation", "clouds", "atmosphere", "short", "buoyancy"], "likes": 7, "viewed": 292, "published": 3, "date": "1654531066", "time_retrieved": "2024-07-30T16:45:26.879863", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R;\n    O = T(u);              // red = hot, blue = cold\n    O.b = 1.-O.r;\n    float v = O.r-U.x;\n    O = mix(O, vec4(0,1,0,1), smoothstep(1.5,0., abs(v)/fwidth(v)) ); // temperature curve with height\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "buffer_a_code": "\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 U = u/R;\n    O = textureLod(iChannel0, U,floor(log2(R.y)-5.) ); // diffusion\n    if ( U.y<.05 ) O.r = .5+.5*sin(iTime); // temperature forcing at floor\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVyzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 255]]}
{"id": "NdVyRW", "name": "Moving RGB Colors", "author": "AShaderBeginner", "description": "My first time using ShaderToy, and my first time creating a shader.\nThank you Patricio Gonzalez Vivo & Jen Lowe for The Book of Shaders! (https://thebookofshaders.com/)", "tags": ["colors"], "likes": 7, "viewed": 256, "published": 3, "date": "1654529028", "time_retrieved": "2024-07-30T16:45:27.675736", "image_code": "#define centerX iResolution.x * 0.5\n#define centerY iResolution.y * 0.5\n\n#define START iResolution.y * 0.3\n#define INTERVAL iResolution.y * 0.1\n#define R 100.0\n\n#define MOVEINTENSITY 0.4\n\n// Negative distance.\nfloat negdst(float x0, float y0, float x1, float y1, float m){\n    return 1.0 - pow(pow(x0-x1,2.0)+pow(y0-y1,2.0),0.5)/m;\n}\n\nfloat curve(float t){\n    return sin(t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(\n        negdst(fragCoord.x, fragCoord.y, centerX * (1.0 + MOVEINTENSITY * curve(iTime * 1.0)), (START + 0.0 * INTERVAL) * curve(iTime) + centerY, R),\n        negdst(fragCoord.x, fragCoord.y, centerX * (1.0 + MOVEINTENSITY * curve(iTime * 1.5)), (START + 1.0 * INTERVAL) * curve(iTime) + centerY, R),\n        negdst(fragCoord.x, fragCoord.y, centerX * (1.0 + MOVEINTENSITY * curve(iTime * 2.0)), (START + 2.0 * INTERVAL) * curve(iTime) + centerY, R),\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 210, 272, 272, 333], [335, 335, 356, 356, 377], [379, 379, 435, 435, 928]]}
{"id": "fsyyRD", "name": "Poorly optimized fractal", "author": "ganerCodes", "description": "xd\nDrag to move camera :>", "tags": ["poorlyoptimizedfractal"], "likes": 2, "viewed": 293, "published": 3, "date": "1654485953", "time_retrieved": "2024-07-30T16:45:28.412765", "image_code": "#define PI 3.141592653589793238\n\nmat2 rotMatrix(vec2 p, float r) { vec2 s = vec2(cos(r), sin(r)); return mat2(s.x, -s.y, s.y,  s.x); }\nvec3 rot_XY(vec3 p, float r){ vec2 m = p.xy * rotMatrix(p.xy, r); return vec3(m, p.z); }\nvec3 rot_XZ(vec3 p, float r){ vec2 m = p.xz * rotMatrix(p.xz, r); return vec3(m.x, p.y, m.y); }\nvec3 rot_YZ(vec3 p, float r){ vec2 m = p.yz * rotMatrix(p.yz, r); return vec3(p.x, m); }\nvec3 rot_XZ_YZ(vec3 p, float r1, float r2) { return rot_XZ(rot_YZ(p, r1), r2); }\n\nfloat func(vec3 o) {\n    vec3 l = vec3(0.0);\n    float i = 0.0;\n    float m = 125.0;\n    while(i < m) {\n        float r = length(l);\n        float t = atan(length(l.xy), l.z);\n        float p = atan(l.y, l.x);\n        float n = 6.0;\n        l = pow(r, n) * vec3(\n            sin(t*n)*cos(p*n),\n            sin(t*n)*sin(p*n),\n            cos(t*n)\n        ) + o;\n        if(length(l) >= 4.0) {\n            return i / m;\n        }\n        i += 1.0;\n    }\n    return 1.0;\n}\n\nvec3 rot(vec3 p, vec3 r) {\n    p = rot_XY(p, r.x);\n    p = rot_XZ(p, r.y);\n    p = rot_YZ(p, r.z);\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = fragCoord / iResolution.xy;\n    \n    float t = 0.1 * iTime;\n    \n    vec3 vp_loc = vec3(2.0, 0.0, 0.0);\n    vec2 vp_ang = iMouse.xy==vec2(0.0) ? vec2(0.5*PI, PI) : (PI -  2.0 * PI * ((iMouse.xy / iResolution.xy) - 0.5));\n    float FOV = 130.0;\n    float cam_dist = 140.0;\n    \n    float hFOV = FOV * tan(PI * FOV / 360.0);\n    vec3 p_e = vec3(\n        hFOV * (pos - 0.5) * (iResolution.xy / iResolution.x),\n        -cam_dist);\n    \n    vec3 p_cast_s = vp_loc;\n    vec3 p_cast_e = vp_loc + rot_XZ_YZ(p_e, -vp_ang.y, vp_ang.x);\n    \n    vec3 rots = vec3(t, 0.75 * t, -1.25 * t);\n    p_cast_s = rot(p_cast_s, rots);\n    p_cast_e = rot(p_cast_e, rots);\n    \n    vec3 loc = p_cast_s;\n    vec3 delt = 0.001 * normalize(p_cast_e - p_cast_s);\n    vec3 col = vec3(0.0);\n    float i = -1.0;\n    while(i <= 300.0) {\n        i += 1.0;\n        float q = func(loc);\n        loc += max(1.0, 10.0 * (1.0 - q)) * delt;\n        if(q < 0.1) {\n            continue;\n        }else{\n            col = clamp(\n                2.0 * (0.1 * q + 1.0 - 0.1 * length(p_cast_s - loc)) * vec3(\n                mod(0.5 * abs(sin(loc.x - loc.y)), 1.0),\n                mod(0.5 * abs(sin(loc.y - loc.z)), 1.0),\n                mod(0.5 * abs(sin(loc.z - loc.x)), 1.0)\n            ), 0.0, 1.0);\n            break;\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyyRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 66, 66, 134], [135, 135, 164, 164, 223], [224, 224, 253, 253, 319], [320, 320, 349, 349, 408], [409, 409, 453, 453, 489], [491, 491, 511, 511, 960], [962, 962, 988, 988, 1076], [1078, 1078, 1133, 1133, 2481]]}
{"id": "NsGcRW", "name": "Interactive \"Fluid\"", "author": "SnoopethDuckDuck", "description": "click the screen", "tags": ["fun"], "likes": 11, "viewed": 340, "published": 3, "date": "1654468891", "time_retrieved": "2024-07-30T16:45:29.207640", "image_code": "vec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float zm = 1.;\n    vec2 res = 0.5 * floor(iResolution.xy);    \n    ivec2 px = ivec2(zm * fragCoord + (1.-zm) * res);\n    \n    vec4 c = cell(px);\n    vec3 col = c.rgb + vec3(0.15,0.1,0.25);\n\n    fragColor.rgb = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n} \n\nfloat L_in_power_P(vec2 b, vec2 e, float p) {\n    vec2 be = e - b;\n    return pow( pow(abs(be.x), p) + pow(abs(be.y), p), 1.0 / p );\n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    vec2 res = floor(0.5 * iResolution.xy);\n    vec2 ms = iMouse.xy;\n    \n    // doing something similar but without bias would be nice\n    ivec2 px = ivec2(f + 20.);\n    // px = ivec2(f * L_in_power_P(f, res, 0.1 + abs(cos(iTime))));  \n    \n    vec4 c = cell(px);\n    float v = pi * 5. * c.a;\n    \n    // Change me! (higher -> faster + more grainy)\n    float m = 2.;\n    \n    px = ivec2(f + m * vec2(cos(v), sin(v)));\n    vec4 c2 = cell(px);\n    \n    float d = length(f - ms);\n    float s = exp(-0.05 * d - 0. * (0.5 + 0.5 * cos(v)));\n    //col = 0.96 * c2 + 0.02* c + s;\n    col = 0.99 * c2 + s;\n     col = clamp(col, 0., 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGcRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 133], [136, 136, 193, 193, 485]]}
{"id": "sdcGRX", "name": "Psychedelic tube", "author": "z0rg", "description": "Plop", "tags": ["tunnel", "trance", "psytrance", "goa"], "likes": 48, "viewed": 1445, "published": 3, "date": "1654462906", "time_retrieved": "2024-07-30T16:45:29.957635", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define sat(a) clamp(a, 0., 1.)\n#define FFT(a) texture(iChannel1, vec2(a, 0.)).x\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 _max(vec2 a, vec2 b)\n{\n    if (a.x > b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 op = p;\n    vec2 acc = vec2(1000.,-1.);\n    \n    float an = atan(p.y, p.x);\n    p.xy -= vec2(sin(p.z+iTime), cos(p.z*.5+iTime))*.5;\n    p.y += sin(p.z*2.+iTime)*.1;\n    float rad = FFT(abs(p.z*.001))*.25;\n    vec2 tube = vec2(-(length(p.xy)-2.-rad+sin(p.z*.25)), 0.);\n    acc = _min(acc, tube);\n    \n    //acc = _min(acc, _max(tube, vec2((sin(an*1.+op.z*3.)-.8), 1.)));\n    \n    return acc;\n}\nvec3 accCol;\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    accCol = vec3(0.);\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n       // if (res.y == 1.)\n            accCol += vec3(1., .5, sin(p.z)*.5+.5)*pow(1.-sat(res.x/.7), 30.)*.3;\n        p += rd*res.x*.7;\n    }\n    return vec3(-1.);\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(1.);\n    float t= iTime*2.;\n    vec3 ro = vec3(sin(iTime)*.15,cos(iTime*.5)*.12,-12.+t);\n    vec3 ta = vec3(0.,0.,0.+t);\n    vec3 rd = normalize(ta-ro);\n    rd.xz *= r2d(sin(iTime*.5)*.15);\n    rd.yz *= r2d(sin(iTime+.5)*.15);\n    rd = getCam(rd, uv);\n    vec3 res = trace(ro, rd, 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = n*.5+.5;\n        vec3 lpos = vec3(0.);\n        vec3 ldir = p-lpos;\n        col = sat(dot(normalize(ldir), n))*vec3(1.);\n        col += accCol;\n        col = pow(col, vec3(3.));\n        float an = atan(p.y, p.x);\n        vec2 rep = vec2(.9, .5);\n        vec2 luv = vec2(an, p.z+iTime);\n        vec2 id = floor((luv+.5*rep)/rep);\n        luv.x += sin(id.y*.5)*iTime*2.;\n        luv = mod(luv+.5*rep, rep)-.5*rep;\n        float shape = _sqr(luv, vec2(5.4*pow(FFT(abs(id.y*.01)),5.), .05));\n        vec3 rgb = mix(col, vec3(1.), 1.-sat(shape*50.));\n        rgb += pow(FFT(.0),2.)*2.*vec3(1., .5, sin(p.z*10.)*.5+.5)*(1.-sat(shape*1.))*(1.-sat(length(uv*1.)));\n        col = mix(col, rgb, sin(iTime*5.+p.z*.5)*.5+.5);\n        col += 0.2*texture(iChannel0, vec2(atan(p.y, p.x)*2., length(p.xy*.1)-.25*iTime)*.1).xyz;\n        col = mix(col, col.zyx, sin(iTime*1.+p.z*.1)*.5+.5);\n        //col = mix(col, col*texture(iChannel0, vec2(atan(p.y, p.x)*2., length(p.xy*.1)-iTime)*.25).xxx, 1.-sat(length(uv*2.)));\n\n    }\n\n    return col;\n}\n\nvec2 messupUV(vec2 uv)\n{\n       vec2 ouv = uv;\n    uv += vec2(.1, 0.);\n    uv.x = abs(uv.x);\n    uv *= r2d(iTime*.25);\n    //uv += vec2(.3, 0.);\n    uv.y = abs(uv.y);\n    uv *= r2d(-iTime*.5);\n     uv *= r2d(.2*iTime+uv.x);\n    uv *= sin(iTime*.15);\n   \n    vec2 uv3 = uv*15.*uv.yx*r2d(length(uv));\n    return mix(mix(ouv, uv, sin(iTime*.2)), uv3, sin(iTime*.1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord.xy/iResolution.xy;\n\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    //uv = messupUV(uv);\n    vec3 col = rdr(uv);\n    col *= 1.+pow(FFT(.1), 1.)*2.;\n    col = mix(col, texture(iChannel2, ouv).xyz, .5+pow(FFT(.2), 2.)*.5);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30625, "src": "https://soundcloud.com/nostalgia-of-psytrance/astral-projection-another-world?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcGRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 176]]}
{"id": "7sKcR1", "name": "yin yang basis", "author": "jorge2017a2", "description": "yin yang basis", "tags": ["yinyangbasis"], "likes": 10, "viewed": 246, "published": 3, "date": "1654458904", "time_retrieved": "2024-07-30T16:45:30.835288", "image_code": "//----------image\n//por jorge2017a2-\n//yin yang basis---5-jun-2022-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat yin1(vec2 p)\n{\n    float d0a=sdCircle(p,4.0);\n    float d0b= sdBox(p-vec2(0.0,2.0), vec2(4.0,2.2) );\n    float d0c= sdBox(p-vec2(0.0,-2.0), vec2(4.0,2.2) );\n    \n    float d1a=sdCircle(p-vec2(-2.0,0.0),2.1); //circulo pequeño izq\n    float d1b=sdCircle(p-vec2( 2.0,0.0),2.1); //circulo pequeño izq\n    \n    float difci1=Difference(d0a, d0b);\n    float difci2=Difference(d0a, d0c);\n   \n    float duni1= Union(difci1, d1a);\n    float duni2= Union(difci2, d1b);\n    \n    //restar otro circulo\n    duni1= Difference(difci1, d1b);\n    // unir el otro cirulo por borrar\n    duni1= Union(duni1, d1a);\n    return duni1;\n    \n}\n\nfloat yin2(vec2 p)\n{   float d1a=sdCircle(p-vec2(-2.0,0.0),0.5); //circulo pequeño izq\n    return d1a;    \n}\n\n\nfloat yang1(vec2 p)\n{\n    float d0a=sdCircle(p,4.0);\n    float d0b= sdBox(p-vec2(0.0,2.1), vec2(4.0,2.1) );\n    float d0c= sdBox(p-vec2(0.0,-2.2), vec2(4.0,2.1) );\n    \n    float d1a=sdCircle(p-vec2(-2.0,0.0),2.0); //circulo pequeño izq\n    float d1b=sdCircle(p-vec2( 2.0,0.0),2.0); //circulo pequeño izq\n    \n    float difci2=Difference(d0a, d0c);\n   float duni2= Union(difci2, d1b);\n    \n    ///-------------segundo circulo\n    duni2=Difference(duni2, d1a);\n    return duni2;\n}\n\n\nfloat yang2(vec2 p)\n{   float d1b=sdCircle(p-vec2( 2.0,0.0),0.5); //circulo pequeño izq\n    return d1b;\n}\n\n\nvec2 GetDist1(vec3 p  )\n{\tvec2 res= vec2(9999.0, -1.0); \n    float t=iTime;\n    float pzm1=2.0*sin(t);\n    float pzm2=2.0*cos(t);\n    \n    float d1a= yin1(p.xy)-0.05;\n    float d1b= sdBox( p, vec3(10.0,6.0,3.0+pzm1) );\n    \n    float d2a= yang1(p.xy)-0.05;\n    float d2b= sdBox( p, vec3(10.0,6.0,3.0)+pzm2 );\n    \n    float d3a= yin2(p.xy);\n    float d3b= sdBox( p, vec3(5.0,5.0,4.0)+pzm1 );\n    \n    float d4a= yang2(p.xy);\n    float d4b= sdBox( p, vec3(5.0,5.0,4.0)+pzm2 );\n    \n    float dunia= Intersect(d1a, d1b);\n    float dunib= Intersect(d2a, d2b);\n    float dunic= Intersect(d3a, d3b);\n    float dunid= Intersect(d4a, d4b);\n    \n    res =opU2(res, vec2(dunia,32.0));\n    res =opU2(res, vec2(dunib,33.0));\n    res =opU2(res, vec2(dunic,33.0));\n    res =opU2(res, vec2(dunid,32.0));\n    return res;\n}\n\nvec2  opScaleGetDis( vec3 p,float s)\n{   vec2 res =GetDist1(p/s);\n    res.x =res.x*s;\n    return res;\n}\n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0); \n    vec3 p0=p;\n    float escala1=5.0*sin(iTime*0.25);\n    float escala2=-5.0*sin(iTime*0.25);\n    \n    vec2 gt1;\n    if (escala1>0.0)\n        gt1= opScaleGetDis(p, escala1);\n    else\n        gt1= opScaleGetDis(p, escala2);\n    res =opU2(res, gt1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    \n    // efecto\n    if(2.0*sin(iTime)>0.0) \n    colOut=(colOut+ pallete(diffuse.x) * max(0.0, dot(N, L)))/2.0;  //-2-\n    return colOut;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .7)*col, vec3(.3, .8+0.6*sin(iTime), .8), 1.0 - rd.y);\n    float d = pow(rd.z+0.3,2.)*pow(rd.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n\treturn sky*d;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n     \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n        \n    }\n    else if(hit.x>MAX_DIST)\n    col=  ACESFilm(render_sky_color(rd));\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 0.7 +0.5*sin(t)); \n   vec3 ro=vec3(0.0,0.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKcR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[493, 493, 529, 529, 550], [551, 551, 583, 583, 667], [669, 669, 704, 704, 727], [729, 729, 766, 766, 840], [843, 843, 887, 887, 914], [915, 915, 955, 955, 982], [983, 983, 1028, 1028, 1056], [1058, 1058, 1094, 1094, 1139], [1141, 1141, 1175, 1175, 1271], [1272, 1272, 1306, 1306, 1397], [1398, 1398, 1432, 1432, 1523], [1525, 1525, 1545, 1545, 2151], [2153, 2153, 2173, 2173, 2262], [2265, 2265, 2286, 2286, 2746], [2749, 2749, 2770, 2770, 2855], [2858, 2858, 2883, 2883, 3665], [3667, 3667, 3705, 3705, 3770], [3773, 3773, 3798, 3798, 4095], [4097, 4097, 4121, 4121, 4283], [4285, 4285, 4333, 4333, 4612], [4615, 4615, 4659, 4659, 4980], [4982, 4982, 5019, 5019, 5276], [5279, 5279, 5302, 5302, 5457], [5459, 5459, 5549, 5549, 6630], [6632, 6632, 6664, 6664, 6951], [6954, 6954, 7024, 7024, 7123], [7125, 7125, 7152, 7152, 7241], [7243, 7243, 7301, 7301, 7349], [7351, 7351, 7374, 7374, 7486], [7488, 7488, 7519, 7519, 8168], [8170, 8170, 8227, 8227, 8658]]}
{"id": "7dKczh", "name": "Trail UV Test", "author": "SnoopethDuckDuck", "description": "not perfect", "tags": ["e"], "likes": 8, "viewed": 297, "published": 3, "date": "1654452403", "time_retrieved": "2024-07-30T16:45:31.638141", "image_code": "vec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n} \n\nvec3 pal(float t) {\n    vec3 d = 0.5 * vec3(0,1,2)/3.;\n    return 0.5 + 0.5 * cos(6.28319 * (0.5 * t + d));\n}\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float zm = 1.;\n    vec2 res = iResolution.xy;    \n    ivec2 px = ivec2(mod(zm * fragCoord + (1.-zm) * res, res));\n    \n    vec3 c = cell(px).rgb;\n    vec3 col = c;\n\n    vec2 uv2 = col.rg;\n    col.rgb += 0.5;\n    col *= 0.5 + 0.5 * thc(4., 40. * uv2.x + 2. * cos(10. * (uv2.x + uv2.y - iTime)));\n    col *= step(0.001, c.b);\n    float d = length(uv2);\n    float s = step(d, 0.2);\n\n    col = c.b * c.b * mix(col, pal(iTime * c.b * 2.+ uv2.x * 10. + c.b * 4.), 0.5);\n    col += vec3(0.1,0.12,0.2);\n    \n    fragColor.rgb = col.rgb;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define mlength(p) max(abs(p.x), abs(p.y))\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n} \n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    vec2 res = floor(0.5 * iResolution.xy);\n\n    ivec2 px = ivec2(f);\n    f -= res;\n\n    col = vec4(0);\n    \n    float t = 2. * iTime; //floor(8. * iTime)/4.;\n    vec2 p = 120. * vec2(cos(t), sin(0.825 * t));\n    t += 0.01;\n    vec2 q = 120. * vec2(cos(t), sin(0.825 * t));\n    \n    vec2 dir = p - q;\n    float a = atan(dir.x, dir.y);\n\n    f -= p;\n    f *= rot(a);\n    float sc = 50.;\n    col.rgb = vec3(f * 0.5 / sc, 1.);   \n    col.rgb *= step(mlength(col.rg), 0.5);\n\n    vec4 c = cell(px);\n    if (col.b < c.b) {\n        col.rgb += c.rgb;\n        col.b -= 0.012;\n    }\n    \n    col.rg = clamp(col.rg, -0.5, 0.5);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 133], [136, 136, 155, 155, 245], [288, 288, 345, 345, 951]]}
{"id": "7sKyzh", "name": "FPS Counter", "author": "Ptyonic", "description": "shows fps in top right", "tags": ["debug"], "likes": 1, "viewed": 348, "published": 3, "date": "1654451858", "time_retrieved": "2024-07-30T16:45:32.394120", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    float fontHeight = 30.0;\n    float fontWidth = 15.0;\n    float fontRatio = fontWidth / fontHeight;\n    vec2 uv = (fragCoord - iResolution.xy + vec2(fontWidth, fontHeight)) / fontHeight;\n\n    vec2 offset = vec2(1.0 / 16.0, 1.0 / 16.0);\n    vec2 digit = vec2(0.0, -4.0);\n    vec2 decimalPoint = vec2(-2.0, -3.0);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 font = vec4(0.0);\n    \n    // float number = 1234.09999;\n    float number = 1.0 / iTimeDelta;\n    float decimalPlaces = 2.0;\n    number *= pow(10.0, decimalPlaces);\n    float i = 0.0;\n    while (number > 0.999) {\n        vec2 coords = uv + vec2(i * fontRatio + (1.0 - fontRatio), 0.0);\n        if (abs(i - decimalPlaces) <= 0.001) {\n            if (coords.x >= (1.0 - fontRatio) / 2.0 && coords.x < 1.0 - (1.0 - fontRatio) / 2.0 && coords.y >= 0.0 && coords.y < 1.0) {\n                font = texture(iChannel0, (coords + decimalPoint) * offset);\n            }\n            i += 1.0;\n            continue;\n        } else {\n            float current = mod(floor(number), 10.0);\n            if (coords.x >= (1.0 - fontRatio) / 2.0 && coords.x < (1.0 + fontRatio) / 2.0 && coords.y >= 0.0 && coords.y < 1.0) {\n            //if (true) {\n                font = texture(iChannel0, (coords + digit + current * vec2(1.0, 0.0)) * offset);\n            }\n            number /= 10.0;\n        }\n        i += 1.0;\n    }\n    // Output to screen\n    fragColor = vec4(font.x, 0.0, 0.0, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 105, 1597]]}
{"id": "NsccDl", "name": "colorblind", "author": "arthehaxxor", "description": "colorblind vision, idk how this stuff actually works, it seems to line up with actual charts, but I can't be sure past intuition", "tags": ["colorblind"], "likes": 0, "viewed": 201, "published": 3, "date": "1654438126", "time_retrieved": "2024-07-30T16:45:33.189992", "image_code": "// this is how much each cone biases the other\n\n#define RR 1.0\n#define RG 0.0\n#define RB 0.0\n#define GR 0.0\n#define GG 1.0\n#define GB 0.0\n#define BR 0.0\n#define BG 1.0\n#define BB 0.0\n\n// for example, RR is the weight for how much red \n// biases the red chanel\n\n// changing these values results in different \n// color blindess type\n\n// for example, all ones lead to complete color blindness \n// and setting GR to 1.0 leads to a type of red green\n// color blindness\n\n// tecnically, there is no actual color blindness that \n// would be created from the BR or RB biases since \n// there is no colorblindness that involves both \n// the red and blue cones \n\n\n/*** CODE, DO NOT TOUCH WHILE PRESENTING ***/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // reading image and storing normal color values\n    vec4 col = texture(iChannel0,uv); \n    float r = col.x;\n    float g = col.y;\n    float b = col.z;\n    \n    \n    // taking weighted average of the colors\n    if(uv.y>0.5) {\n        col.x=(r*RR+g*RG+b*RB)/(RR+RG+RB);\n        col.y=(r*GR+g*GG+b*GB)/(GR+GG+GB);\n        col.z=(r*BR+g*BG+b*BB)/(BR+BG+BB);\n    }\n    \n    col.x=pow(col.x,2.2);\n    col.y=pow(col.y,2.2);\n    col.z=pow(col.z,2.2);\n    \n    \n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 frag_colour, in vec2 frag_coord) {\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = frag_coord / iResolution.xy;\n    frag_colour = vec4(hsv2rgb(vec3(uv.x,1,1)), 1.f);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsccDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[699, 699, 756, 806, 1352]]}
{"id": "sddyR2", "name": "Alternative blend", "author": "El_Sargo", "description": "Top: mix\nBottom: new method\nAn alternative to mix that tries to avoid the grey colors that sometimes occur when using mix.\nIt's pretty cheap, just a couple mins and maxes.\nmix sometimes produces better results, eg when blending red and green. ", "tags": ["blending", "rbg"], "likes": 2, "viewed": 233, "published": 3, "date": "1654412840", "time_retrieved": "2024-07-30T16:45:33.941981", "image_code": "const vec3 col1 = vec3(0.553,0.933,0.090);\nconst vec3 col2 = vec3(0.153,0.118,0.643);\n\n\nvec3 blend(vec3 a, vec3 b, float t){\n    vec3 delta = a - b;\n    float maxDelta =     max(\n        max(\n            abs(delta.x),\n            abs(delta.y)),\n            abs(delta.z)\n    );\n    vec3 s = sign(delta);\n    vec3 c = a - s*maxDelta*t;\n    \n    vec3 minc = vec3(\n        min(a.x, b.x),\n        min(a.y, b.y),\n        min(a.z, b.z)\n    );\n    \n    vec3 maxc = vec3(\n        max(a.x, b.x),\n        max(a.y, b.y),\n        max(a.z, b.z)\n    );\n    \n    return clamp(c,minc,maxc);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col;\n    if(uv.y > 0.5)col = mix(col1, col2, uv.x);\n    else          col = blend(col1, col2, uv.x);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddyR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 124, 124, 575], [577, 577, 634, 634, 819]]}
{"id": "ssGcz1", "name": "Felix Westin minimalAtmosphere", "author": "blahblah", "description": "Trying to port Felix Westin's minimalAtmosphere to shader toy but I have no idea what I'm doing :)\n\nhttps://github.com/Fewes/MinimalAtmosphere\nhttps://github.com/Fewes/MinimalAtmosphere/blob/master/Assets/Atmosphere/Shaders/Atmosphere.cginc\n\n", "tags": ["atmosphere"], "likes": 0, "viewed": 253, "published": 3, "date": "1654406918", "time_retrieved": "2024-07-30T16:45:34.689981", "image_code": "// Copyright (c) 2021 Felix Westin\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// -------------------------------------\n// Defines\n#define EPS 1e-6\n#define PI 3.14159265359\n#define INFINITY 1000000.0 // Had to change this otherwise I got a division by zero 1.0 / 0.0\n#define PLANET_RADIUS 6371000.0\n#define PLANET_CENTER vec3(0, -PLANET_RADIUS, 0)\n#define ATMOSPHERE_HEIGHT 100000.0\n#define RAYLEIGH_HEIGHT (ATMOSPHERE_HEIGHT * 0.08)\n#define MIE_HEIGHT (ATMOSPHERE_HEIGHT * 0.012)\n\n// -------------------------------------\n// Coefficients\n#define C_RAYLEIGH (vec3(5.802, 13.558, 33.100) * 1e-6)\n#define C_MIE (vec3(3.996, 3.996, 3.996) * 1e-6)\n#define C_OZONE (vec3(0.650, 1.881, 0.085) * 1e-6)\n\n#define ATMOSPHERE_DENSITY 1.0\n#define EXPOSURE 20.0\n\n// -------------------------------------\n// Math\nvec2 SphereIntersection(vec3 rayStart, vec3 rayDir, vec3 sphereCenter, float sphereRadius)\n{\n    rayStart -= sphereCenter;\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayStart, rayDir);\n    float c = dot(rayStart, rayStart) - (sphereRadius * sphereRadius);\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0)\n    {\n        return vec2(-1, -1);\n    }\n    else\n    {\n        d = sqrt(d);\n        return vec2(-b - d, -b + d) / (2.0 * a);\n    }\n}\n\nvec2 PlanetIntersection(vec3 rayStart, vec3 rayDir)\n{\n    return SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS);\n}\n\nvec2 AtmosphereIntersection(vec3 rayStart, vec3 rayDir)\n{\n    return SphereIntersection(rayStart, rayDir, PLANET_CENTER, PLANET_RADIUS + ATMOSPHERE_HEIGHT);\n}\n\n// -------------------------------------\n// Phase functions\nfloat PhaseRayleigh(float costh)\n{\n    return 3.0 * (1.0 + costh * costh) / (16.0 * PI);\n}\n// g = 0.85\nfloat PhaseMie(float costh)\n{\n    float g = 0.85;\n    g = min(g, 0.9381);\n    float k = 1.55 * g - 0.55 * g * g * g;\n    float kcosth = k * costh;\n    return (1.0 - k * k) / ((4.0 * PI) * (1.0 - kcosth) * (1.0 - kcosth));\n}\n\n// -------------------------------------\n// Atmosphere\nfloat AtmosphereHeight(vec3 positionWS)\n{\n    return distance(positionWS, PLANET_CENTER) - PLANET_RADIUS;\n}\nfloat DensityRayleigh(float h)\n{\n    return exp(-max(0.0, h / RAYLEIGH_HEIGHT));\n}\nfloat DensityMie(float h)\n{\n    return exp(-max(0.0, h / MIE_HEIGHT));\n}\nfloat DensityOzone(float h)\n{\n    // The ozone layer is represented as a tent function with a width of 30km, centered around an altitude of 25km.\n    return max(0.0, 1.0 - abs(h - 25000.0) / 15000.0);\n}\nvec3 AtmosphereDensity(float h)\n{\n    return vec3(DensityRayleigh(h), DensityMie(h), DensityOzone(h));\n}\n\n// Optical depth is a unitless measurement of the amount of absorption of a participating medium (such as the atmosphere).\n// This function calculates just that for our three atmospheric elements:\n// R: Rayleigh\n// G: Mie\n// B: Ozone\n// If you find the term \"optical depth\" confusing, you can think of it as \"how much density was found along the ray in total\".\nvec3 IntegrateOpticalDepth(vec3 rayStart, vec3 rayDir)\n{\n    vec2 intersection = AtmosphereIntersection(rayStart, rayDir);\n    float rayLength = intersection.y;\n\n    int sampleCount = 8;\n    float stepSize = rayLength / float(sampleCount);\n\n    vec3 opticalDepth = vec3(0.0, 0.0, 0.0);\n\n    for (int i = 0; i < sampleCount; i++)\n    {\n        vec3 localPosition = rayStart + rayDir * (float(i) + 0.5) * stepSize;\n        float localHeight = AtmosphereHeight(localPosition);\n        vec3 localDensity = AtmosphereDensity(localHeight);\n\n        opticalDepth += localDensity * stepSize;\n    }\n\n    return opticalDepth;\n}\n\n// Calculate a luminance transmittance value from optical depth.\nvec3 Absorb(vec3 opticalDepth)\n{\n    // Note that Mie results in slightly more light absorption than scattering, about 10%\n    return exp(-(opticalDepth.x * C_RAYLEIGH + opticalDepth.y * C_MIE * 1.1 + opticalDepth.z * C_OZONE) * ATMOSPHERE_DENSITY);\n}\n\n// Integrate scattering over a ray for a single directional light source.\n// Also return the transmittance for the same ray as we are already calculating the optical depth anyway.\nvec3 IntegrateScattering(vec3 rayStart, vec3 rayDir, float rayLength, vec3 lightDir, vec3 lightColor, out vec3 transmittance)\n{\n    // We can reduce the number of atmospheric samples required to converge by spacing them exponentially closer to the camera.\n    // This breaks space view however, so let's compensate for that with an exponent that \"fades\" to 1 as we leave the atmosphere.\n    float rayHeight = AtmosphereHeight(rayStart);\n    float sampleDistributionExponent = 1.0 + clamp(1.0 - rayHeight / ATMOSPHERE_HEIGHT, 0.0, 1.0) * 8.0; // Slightly arbitrary max exponent of 9\n\n    vec2 intersection = AtmosphereIntersection(rayStart, rayDir);\n    rayLength = min(rayLength, intersection.y);\n    if (intersection.x > 0.0)\n    {\n        // Advance ray to the atmosphere entry point\n        rayStart += rayDir * intersection.x;\n        rayLength -= intersection.x;\n    }\n\n    float costh = dot(rayDir, lightDir);\n    float phaseR = PhaseRayleigh(costh);\n    float phaseM = PhaseMie(costh);\n\n    int sampleCount = 64;\n\n    vec3 opticalDepth = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh = vec3(0.0, 0.0, 0.0);\n    vec3 mie = vec3(0.0, 0.0, 0.0);\n\n    float prevRayTime = 0.0;\n\n    for (int i = 0; i < sampleCount; i++)\n    {\n        float rayTime = pow(float(i) / float(sampleCount), sampleDistributionExponent) * rayLength;\n        // Because we are distributing the samples exponentially, we have to calculate the step size per sample.\n        float stepSize = (rayTime - prevRayTime);\n\n        vec3 localPosition = rayStart + rayDir * rayTime;\n        float localHeight = AtmosphereHeight(localPosition);\n        vec3 localDensity = AtmosphereDensity(localHeight);\n\n        opticalDepth += localDensity * stepSize;\n\n        // The atmospheric transmittance from rayStart to localPosition\n        vec3 viewTransmittance = Absorb(opticalDepth);\n\n        vec3 opticalDepthlight = IntegrateOpticalDepth(localPosition, lightDir);\n        // The atmospheric transmittance of light reaching localPosition\n        vec3 lightTransmittance = Absorb(opticalDepthlight);\n\n        rayleigh += viewTransmittance * lightTransmittance * phaseR * localDensity.x * stepSize;\n        mie += viewTransmittance * lightTransmittance * phaseM * localDensity.y * stepSize;\n\n        prevRayTime = rayTime;\n    }\n\n    transmittance = Absorb(opticalDepth);\n\n    return (rayleigh * C_RAYLEIGH + mie * C_MIE) * lightColor * EXPOSURE;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    // Hack this for now because I don't know how to get world position in shaderToy...\n    vec3 instanceWorldPos = vec3(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y  * 5.0, 0.0);\n    \n    vec3 _WorldSpaceCameraPos = vec3(0.0, 0.0, -10.0);\n    vec3 _WorldSpaceLightPos0 = vec3(0.0, 10.0, 0.0);\n    vec3 _LightColor0 = vec3(0.5, 0.5, 0.5);\n\n    vec3 rayStart = _WorldSpaceCameraPos;\n    vec3 rayDir = normalize(instanceWorldPos - _WorldSpaceCameraPos);\n    float rayLength = INFINITY;\n    \n    float _DrawPlanet = 0.0;\n\n    if (_DrawPlanet == 1.0)\n    {\n        vec2 planetIntersection = PlanetIntersection(rayStart, rayDir);\n        if (planetIntersection.x > 0.0)\n            rayLength = min(rayLength, planetIntersection.x);\n    }\n\n    vec3 lightDir = _WorldSpaceLightPos0.xyz;\n    vec3 lightColor = _LightColor0.xyz;\n\n    vec3 transmittance;\n    vec3 color = IntegrateScattering(rayStart, rayDir, rayLength, lightDir, lightColor, transmittance);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGcz1.jpg", "access": "api", "license": "mit", "functions": [[1785, 1834, 1926, 1926, 2291], [2293, 2293, 2346, 2346, 2427], [2429, 2429, 2486, 2486, 2587], [2589, 2649, 2683, 2683, 2739], [2740, 2752, 2781, 2781, 2975], [2977, 3032, 3073, 3073, 3139], [3140, 3140, 3172, 3172, 3222], [3223, 3223, 3250, 3250, 3295], [3296, 3296, 3325, 3441, 3498], [3499, 3499, 3532, 3532, 3603], [4585, 4650, 4682, 4772, 4901], [4903, 5083, 5210, 5469, 7489], [7491, 7491, 7546, 7637, 8547]]}
{"id": "fdGyz1", "name": "[FieldFX Shader Jam] 大龙猫 - Meh", "author": "totetmatt", "description": "Done during FieldFx demoparty shaderjam with evvvvil and mrsoleil. \nReally underperforming result, sorry for that, I will improve.\n\n", "tags": ["fieldfx"], "likes": 9, "viewed": 315, "published": 3, "date": "1654368215", "time_retrieved": "2024-07-30T16:45:35.506798", "image_code": "\nvec3 erot(vec3 p,vec3 ax,float t){\n    return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);\n}\n     \nfloat box2(vec2 p, vec2 b){\n    vec2 q = abs(p)-b;\n    return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));  \n}\n\nfloat box3(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\nfloat diam(vec3 p,float s){\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*inversesqrt(3.);\n}\n\nvec2 sdf(vec3 p){  \n \n    vec3 tp=p,hp=p;\n    hp.y -=abs(asin(sin(iTime)));  \n  float gy = dot(sin(p),cos(p.zxy*7.));  \n    \nhp = erot(hp,normalize(vec3(1.,2.,3)),iTime);\n    vec2 h;\n    h.x = length(hp)-1.;\n    h.x = .7*mix(diam(hp,1.),box3(hp,vec3(1.)),sin(iTime+gy*.2)*.5-0.2)*.9;\n   \n     \n    \n  \n    h.y = 1.;\n  \n    vec2 t;\n     tp.y +=1.;\n      tp.x +=iTime;\n     tp.xz = asin(sin(tp.xz));\n  \n   float sc=1.;\n    for(float i=0.;i<4.;i++){\n          tp.x = .5-abs(tp.x);\n         tp*=2.5;\n         sc*=2.5;\n          \n      tp = erot(tp,vec3(0,1,0),.785);\n      }\n     float dd,c=10./3.141592;\n     \n     tp.xz = vec2(log(dd=length(tp.xz)),atan(tp.x,tp.z))*c;\n     tp.y /=dd/=c;\n    \n    tp.x +=iTime;\n    tp.xz = asin(sin(tp.xz));\n  \n    tp.y = abs(tp.y)-0.5-abs(gy)*.1;\n \n    gy = dot(sin(tp),cos(tp.zxy*7.)); \n    t.x=  dd*.8*min(box2(tp.yz,vec2(.01)), box2(tp.xy,vec2(.01)))/sc;\n    t.y = 2.;\n    h = t.x < h.x ? t:h;\n      \n      \n      \n    return h;\n}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(.0,.3,.7)));}\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n  vec3 col = vec3(.1,.2,.7)*max(0.,1.+uv.y*7.);\n\tvec3 ro = vec3(0.,1.+sin(iTime),-5.);\n   \n  if(mod(iTime,20.) > 10. ) ro = erot(ro,normalize(vec3(0.,1.,0.)),iTime*.5);\n \n  vec3 rt = vec3(0.);\n  vec3 z = normalize(rt-ro);\n  vec3 x = normalize(cross(z,vec3(0.,-1.,0.)));\n  vec3 y = normalize(cross(z,x));\n  vec3 rd = mat3(x,y,z)*normalize(vec3(uv,1.-sin(floor(iTime*.5)*55.)*.8*sqrt(length(uv))));\n  vec3 rp = ro;\n  vec3 light = vec3(1.,2.,-3);\n  float dd = 0.;\n  vec3 acc = vec3(0.);\n  \n\n  for(float i=0.;i<128.;i++){\n      vec2 d = sdf(rp);\n      if(d.y == 2.){\n        acc += vec3(1.,1.,0.)*.25*exp(i*-abs(d.x))/(60.+sin(iTime*10.+rp.y*10.)*50.);\n        d.x = max(.001,abs(d.x));\n      }\n      rp+=rd*d.x;\n      \n      dd+=d.x;\n      if(dd>50.) break;\n      if(d.x < .0001){\n          vec3 n = norm(rp,.001);\n         vec3 n2 = norm(rp,.02+cos(rp.z*10.)*.01);\n          float dif = max(0.5,dot(normalize(light-rp),n));\n          float spc = pow(max(0.,dot(rd,reflect(normalize(light),n))),32.);\n          float fres = pow(1. - dot(-rd, n), 5.);\n         float ol = step(.1,.3*length(n-n2));\n         if(ol ==0.){\n             rd = reflect(rd,n);\n             rp+=rd*.1;\n           continue;\n           }\n          col = pal(fres*2.-iTime*.5+dif)*ol+spc+fres;\n          break;\n      }\n\n  }  \n  \n\n    // Output to screen\n    fragColor = vec4(col+acc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 35, 35, 95], [102, 102, 129, 129, 213], [215, 215, 241, 241, 332], [333, 333, 399, 399, 616], [617, 617, 644, 644, 706], [708, 708, 725, 725, 1673], [1674, 1674, 1692, 1692, 1738], [1765, 1765, 1792, 1792, 1867], [1868, 1868, 1925, 1975, 3399]]}
{"id": "fsyczh", "name": "Parabolic Mandelbrot Set M1", "author": "amoser", "description": "Mandelbrot set (connectedness locus of Julia sets) for a family of functions g_A(z) = z +1/z + A, which have a parabolic fixed point at infinity.", "tags": ["fractal", "mandelbrot", "complex", "parabolic"], "likes": 9, "viewed": 381, "published": 3, "date": "1654365012", "time_retrieved": "2024-07-30T16:45:36.248814", "image_code": "// I first heard of this fractal, which is homeomorphic to the Mandelbrot set, in this lecture by Luna Lomonaco https://www.youtube.com/watch?v=QXQkRjeFCcM&t=3034s\n// I wasn't able to find any code for rendering it, despite its relative simplicity, so I wanted to share this first pass. Feel free to reuse it.\n// It's not at all optimized for the sake of readability. In fact, it's quite slow.\n\nconst bool julia = false;\nconst float iterations = 100.0;\nconst float escapeDistance = 60.0;\nconst float pi = 3.1415926;\n\nvec3 hue(float x)\n{\n    return vec3(0.6 + 0.6*cos(2.0*pi*(x) + vec4(0,-2.0*pi/3.,2.0*pi/3.0,0)));\n}\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), -sin(x), sin(x), cos(x));\n}\n\nvec2 cmul(vec2 za,vec2 zb)\n{\n    return za*mat2(zb.x, -zb.y, zb.yx);\n}\n\nvec2 cinv(vec2 z) \n{\n    return z*vec2(1, -1)/dot(z, z);\n}\n\nvec2 cexp(vec2 z) \n{\n    return exp(z.x)*vec2(cos(z.y), sin(z.y));\n}\n\nvec2 clog(vec2 z) \n{\n    return vec2(log(length(z)), atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z, float n)\n{\n    return cexp(n*clog(z));\n}\n\n//https://www.shadertoy.com/view/WlfXRN\nvec3 magma(float t) \n{\n    const vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float escaped = iterations;\n\n\tvec2 coord = vec2(-2.0,0) + 3.0*(2.0*fragCoord.xy-iResolution.xy)/(iResolution.x);\n    vec2 mouse = vec2(-2.0,0) + 3.0*(2.0*iMouse.xy-iResolution.xy)/(iResolution.x);\n    \n    vec2 B = julia ? mouse : coord;\n    vec2 A = cpow(-B, 0.5);\n    // As far as I know, for the general class of functions conformally conjugate to g_A(z) = z +1/z + A, we'd need to check the orbit of both -1 and 1.\n    // Just -1 seems to be sufficient for this particular construction.\n    vec2 z = julia ? coord : vec2(-1,0);\n\n    vec2 zStop = vec2(0);\n    float i = 0.0;\n    for (; i < iterations; i++)\n    {\n        // Note that \"escapeDistance\" is just a useful fiction for coloring the exterior. It doesn't guarantee divergence.\n        if(length(z) > escapeDistance && escaped >= iterations) \n        {\n            escaped = i;\n            zStop = z;\n        }\n        z = z + cinv(z) + A;\n    }\n    \n    // \"Smooth iteration count\" naively adapted from the standard Mandelbrot. \n    // Looks OK but isn't really correct.\n    if(zStop != vec2(0))\n    {\n        escaped += 1.0-2.0*escapeDistance*log(log(length(zStop))/log(escapeDistance));\n        escaped = max(escaped, 0.0);\n    }\n    \n    float escapeTime = escaped/iterations;\n    vec2 gridOrigin = z + 50.0*mouse + vec2(0,15)*rot(iTime/4.0);\n    float grid = 0.5*(0.5*sin(0.4*gridOrigin.x)+0.5) + 0.5*(0.5*sin(0.4*gridOrigin.y)+0.5);\n    grid = pow(grid+0.4975, 200.0);\n    grid = clamp(grid, 0.0, 1.0);\n    vec3 col = magma(mix(escapeTime, grid*escapeTime, 0.05*smoothstep(0.0, 10.0, length(z)-5.0)));\n    col = mix(col, hue(0.2*iTime+-0.5*mouse.y+4.0/pi*atan(z.y,z.x)).rgb, 0.1);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[517, 517, 536, 536, 616], [618, 618, 637, 637, 689], [691, 691, 719, 719, 761], [763, 763, 783, 783, 821], [823, 823, 843, 843, 891], [893, 893, 913, 913, 963], [965, 965, 993, 993, 1023], [1025, 1065, 1087, 1087, 1747], [1749, 1749, 1806, 1806, 3488]]}
{"id": "sddcWl", "name": "Modular Forms", "author": "mla", "description": "Based entirely on original work by David Lowry-Duda: [url]https://davidlowryduda.com/quanta-langlands-viz/[/url]\n\nSelect form to display with FORM macro at start of Image code. Mousable. For other controls, see header.", "tags": ["complex", "form", "modular"], "likes": 15, "viewed": 377, "published": 3, "date": "1654361115", "time_retrieved": "2024-07-30T16:45:36.990830", "image_code": "////////////////////////////////////////////////////////////////////////////////\n\n// Modular Forms, Matthew Arcus, mla, 2022\n// Based entirely on original work by David Lowry-Duda:\n// https://davidlowryduda.com/quanta-langlands-viz/\n\n// A Modular Form is a complex valued function, defined on\n// the upper half plane, that is invariant (up to a certain\n// scaling factor, determined by the \"weight\" of the form) \n// under the action of the modular group (integer valued\n// Mobius transformations with unit determinant).\n\n// Each form can be evaluated by a Fourier series, but this\n// can result in large numeric errors. A better way (as\n// described by Lowry-Duda) is to pullback or fold the\n// half plane into the fundamental region for the\n// group (the region with |Re(z)| < 0.5 and |z| > 1) and\n// only evaluate the series there, where it can be done\n// with less loss of precision.\n\n// The value of the form is shown with color indicating phase\n// and shading showing magnitude & the boundary of the\n// fundamental region is also shown ('p','m' and 'r' control\n// these).\n\n// By default the upper halfplane is mapped into the unit disk\n// (press 'h' to see the half plane). Use the mouse to apply\n// a Mobius transformation to the disk or plane.\n\n// Controls:\n// <mouse>: apply transform to disk or plane\n// 'h': Half plane\n// 'p': Show phase as color\n// 'm': Show (log) magnitude as shading\n// 'r': Show fundamental region\n// 'f': Use pullback/fold\n// 'c': Continuous coloring\n// 't': color change over time\n// 'l': log contour lines\n// 'x': Progressive Fourier expansion\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Select form to display here\n//#define FORM JINVARIANT\n#define FORM FORM12\n//#define FORM E10\n\n#define FORM4 0\n#define FORM12 1\n#define FORM14 2\n#define FORM20 3\n#define FORM24 4\n#define JINVARIANT 5\n#define E2 6\n#define E10 7\n\n#if FORM == E10\n// E10\nfloat coeffs[] = float[](\n  1.0, -264.0, -135432.0, -5196576.0, -69341448.0, -515625264.0, -2665843488.0, -10653352512.0, -35502821640.0\n);\nint weight = 10;\n#elif FORM == FORM20\nfloat coeffs[] = float[](\n   0.0,1.0,456.0,50652.0,-316352.0,-2377410.0,23097312.0,-16917544.0,\n   -383331840.0,1403363637.0\n);\nint weight = 20;\n#elif FORM == FORM14\nfloat coeffs[] = float[](\n  1.0,-24.0,-196632.0,-38263776.0,-1610809368.0,-29296875024.0, \n  -313495116768.0, -2325336249792.0\n);\nint weight = 14;\n#elif FORM == FORM12\n// Ramanujan's tau function, giving the modular discriminant\nfloat coeffs[] = float[](\n  0.0, 1.0, -24.0, 252.0, -1472.0, 4830.0, -6048.0, -16744.0, 84480.0, -113643.0, -115920.0,\n  534612.0, -370944.0, -577738.0, 401856.0, 1217160.0, 987136.0, -6905934.0, 2727432.0,\n  10661420.0, -7109760.0, -4219488.0, -12830688.0, 18643272.0, 21288960.0, -25499225.0,\n  13865712.0, -73279080.0, 24647168.0, 128406630.0, -29211840.0, -52843168.0, -196706304.0\n);\nint weight = 12;\n#elif FORM == FORM4\nfloat coeffs[] = float[](\n  1.0,240.0,2160.0,6720.0,17520.0,30240.0,60480.0,82560.0,140400.0\n);\nint weight = 4;\n#elif FORM == FORM24\nfloat coeffs[] = float[](\n  0.0,1.0,0.0,195660.0,12080128.0,44656110.0,-982499328.0, -147247240.0,\n  22106234880.0,-8700375483.0,-307849789440.0,407518320132.0,\n  1302498570240.0,1503145514150.0,-20178571198464.0,23514204375720.0,\n  -1899976392704.0,139716078767730.0,-333538871869440.0,-71967740442820.0\n);\nint weight = 24;\n#elif FORM == JINVARIANT\n// Klein's J-Invariant\nfloat coeffs[] = float[](\n  744.0,196884.0,21493760.0,864299970.0,20245856256.0,\n  333202640600.0, 4252023300096.0, 44656994071935.0, 401490886656000.0,\n  3176440229784420.0, 22567393309593600.0, 146211911499519294.0, \n  874313719685775360.0, 4872010111798142520.0, 25497827389410525184.0,\n  126142916465781843075.0);\nint weight = 0;\n#define NEEDINVERSE\n#else\n#error No FORM defined\n#endif\n\nvec2 deltafn(vec2 z) {\n  vec2 w = complex(0);\n  vec2 q = cexp(TWOPI*cmul(vec2(0,1),z)); // The nome squared\n  int N = coeffs.length();\n  if (key(CHAR_X)) N = int(iTime)%(N+1); // Progressive\n  for (int i = N; i > 0; i--) {\n    w = cmul(w,q);\n    w += complex(coeffs[i-1]);\n  }\n#if defined NEEDINVERSE\n  w += cinv(q);\n#endif\n  return w;\n}\n\nvec2 act(mat2 gamma, vec2 z) {\n  // Action of Mobius transformation matrix on z.\n  float a = gamma[0][0], b = gamma[0][1];\n  float c = gamma[1][0], d = gamma[1][1];\n  return cdiv(a*z+complex(b),c*z+complex(d));\n}\n\nvec2 pullback(vec2 z, out mat2 gamma) {\n    //Returns gamma, w such that gamma(z) = w and w is\n    //(essentially) in the fundamental domain.\n    gamma = mat2(1);\n    for (int i = 0; i < 40; i++) {\n      if (abs(z.x) < 0.5 && dot(z,z) > 1.0) break;\n      float xshift = -floor(z.x + 0.5);\n      mat2 shiftmatrix = mat2(1, xshift, 0, 1);\n      gamma *= shiftmatrix;\n      z = act(shiftmatrix, z);\n      if (dot(z,z) < 1.0) {\n         z = -cinv(z);\n         gamma *= mat2(0, -1, 1, 0);\n      }\n    }\n    return z;\n}\n\nfloat clength(vec2 z) {\n  // \"Careful\" length - avoid overflow for very large values\n  if (z == vec2(0)) return 0.0;\n  float t = max(abs(z.x),abs(z.y));\n  z /= t;\n  return t*length(z);\n}\n\nvec3 getcolor(vec2 z) {\n  if (key(CHAR_H)) {\n    z.y += 1.0;\n    if (iMouse.x > 0.0) {\n      vec2 c = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n      z.x -= c.x;\n      z *= (c.y+1.0)/dot(z,z);\n      z.x += c.x;\n      z /= dot(z,z);\n    }\n  } else {\n    if (dot(z,z) > 1.0) return vec3(0);\n    if (iMouse.x > 0.0) {\n      vec2 c = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n      if (dot(c,c) > 1.0) c /= dot(c,c);\n      z -= c;\n      z *= (dot(c,c)-1.0)/dot(z,z);\n      z += c;\n      z /= -dot(z,z);\n    }\n    z.y += 1.0;\n    z *= 2.0/dot(z,z);\n    z.y -= 1.0;\n    z /= dot(z,z);\n  }\n  mat2 gamma = mat2(1);\n  if (!key(CHAR_F)) z = pullback(z,gamma);\n  float a = gamma[0][0], b = gamma[0][1];\n  float c = gamma[1][0], d = gamma[1][1];\n  vec2 w = deltafn(z);\n  if (w == vec2(0)) return vec3(0);\n  // Apply modularity - note that gamma is inverse of mapping\n  // to fundamental region & and has unit determinant.\n  w = cmul(w,cpow(-c*z + complex(a),weight));\n  float h = 0.5+atan(w.y,w.x)/TWOPI;\n  if (!key(CHAR_C)) h *= 0.5; // Use limited color range\n  vec3 col = vec3(1,1,0.5);\n  float t = 0.0;\n  if (!key(CHAR_T)) t = iTime;\n  if (!key(CHAR_P)) col = 0.2+0.8*h2rgb(h+0.0*t);\n  if (!key(CHAR_L)) {\n    vec2 uv = (vec2(t,0)+4.0*clog(w))/PI;\n    float px = fwidth(uv.x);\n    uv = fract(uv);\n    uv = min(uv,1.0-uv);\n    col *= smoothstep(0.0,min(px,0.1),min(uv.x,uv.y));\n  }\n  if (!key(CHAR_M)) col *= 0.65+0.35*cos(t+4.0*log(clength(w)));\n  if (key(CHAR_R)) {\n    //  Fundamental region borders\n    float d = abs(0.5-abs(z.x));\n    d = min(d,abs(length(z)-1.0));\n    d = min(d,abs(z.x));\n    float px = fwidth(d);\n    col *= 0.5+0.5*smoothstep(-px,px,d-0.02);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  int AA = 2;\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++){\n      for (int j = 0; j < AA; j++) {\n        vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n        col += getcolor(z);\n      }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "bool alert = false;\nvoid assert(bool b) { if (!b) alert = true; }\n\nconst float PI = 3.14159265359;\nconst float TWOPI = 2.0*3.14159265359;\n\n#define complex(x) (vec2((x),0))\n\nvec2 cmul(vec2 z, vec2 w) {\n  return mat2(z.x,z.y,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 cexp(vec2 z) {\n  // If cos and sin were perfect we wouldn't need normalize\n  return exp(z.x)*normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z, vec2 w) {\n  return cexp(cmul(clog(z),w));\n}\n\nvec2 cpow(vec2 z, int n) {\n  // Integer powers by repeated squaring, more\n  // for precision than for performance.\n  vec2 res = vec2(1,0);\n  vec2 t = z;\n  while (true) {\n    if ((n&1) == 1) res = cmul(res,t);\n    n >>= 1;\n    if (n == 0) break;\n    t = cmul(t,t);\n  }\n  return res;\n}\n\nvec3 h2rgb(float h) {\n  // Function by iq\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddcWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3810, 3810, 3832, 3832, 4147], [4149, 4149, 4179, 4229, 4361], [4363, 4363, 4402, 4504, 4876], [4878, 4878, 4901, 4962, 5064], [5066, 5066, 5089, 5089, 6752], [6754, 6754, 6806, 6806, 7121]]}
{"id": "NdVyzz", "name": "cheap filters using MIPmap", "author": "FabriceNeyret2", "description": "Each MIPmap LOD roughly represent the integral on a crown ( variant : LOD(r) - LOD(r-1) ).\n1 single may look blocky, but a continuous spectrum looks smooth.\nA reminder that you can also activate MIPmap for your own buffers.", "tags": ["gpmipmap"], "likes": 10, "viewed": 403, "published": 3, "date": "1654325887", "time_retrieved": "2024-07-30T16:45:37.731848", "image_code": "#define T(U,l) textureLod( iChannel0, U, float(l) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n    u /= R;\n    O-=O;\n    float w, t=0.;\n    for( float i=0.; i<8.; i++ ) {\n        w = sin(6.28*(iTime-i)/8.);\n        t += w = U.x < 0. ? .5+.5*w : w;\n        O += w*T(u,i);\n     // O += w*( T(u,i) - ( i>0. ? T(u,i-1.) : vec4(0) ) );\n    }\n    if (U.x<0.) O /= t; else O = .5*O+.5;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVyzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 91, 91, 439]]}
{"id": "fdKcRz", "name": "Space Station [494 chars]", "author": "Xor", "description": "[url=https://www.shadertoy.com/view/NsVyRz]Apollonian Fractal[/url], but with DOF.\nThanks to coyote for trimming this down further", "tags": ["fractal", "dof", "bokeh", "golf"], "likes": 35, "viewed": 876, "published": 3, "date": "1654320767", "time_retrieved": "2024-07-30T16:45:38.472867", "image_code": "/*\n    \"Space Station\" by @XorDev\n    \n    310 char version: shadertoy.com/view/NsVyRz\n    Based on Shane's Apollonian Fractal: shadertoy.com/view/4d2BW1\n    \n    Twigl: bit.ly/3xgtDUD\n    -14 thanks to coyote\n    \n    <512 Chars playlist: shadertoy.com/playlist/N3SyzR\n*/\n//Bokeh pass\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    //Resolution, center coordinates and variable for iteration\n    vec2 r=iResolution.xy, u=(I+I-r).xx/2e3, i=r/r;\n    //Iterate with \"i\" approximating the sqrt of the number of iterations.\n    for(O-=O; i.x<16.; i+=1./i)\n        //Rotate sample point with golden angle\n        u *= mat2(0,.061,1.413, 0)-.737,\n        //Add sample to total (weighted towards brightness)\n        O += texture(iChannel0,I/r+u*i/r);\n    \n    //Compute average\n    O=sqrt(O)*.1;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29079, "src": "https://soundcloud.com/1985music1985/scars?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "/*\n    \"Space Station\" by @XorDev\n    \n    Based on Shane's Apollonian Fractal: https://www.shadertoy.com/view/4d2BW1\n    \n    Twigl: https://bit.ly/3xgtDUD\n*/\nvoid mainImage(out vec4 O, vec2 I)\n{\n    float i=0.,e,j,s,t=iTime;\n    //Resolution for scaling\n    vec3 r = iResolution,\n    //Position and transformed vector\n    p = r-r,v;\n    \n    //Clear color\n    for(O-=O;\n\n        //Scroll forward\n        v = p+t/r,\n        \n        //Rotate view\n        v.xy *= mat2(sin(t*.1+vec4(0,11,33,0))),\n        //Center\n        v--,\n        i++<2e2;\n\n        \n        //Shadow tracing after 100 iterations\n        i>1e2 ?\n            //Step forward in vec3(1,1,1) direction\n            p += e+=1e-5,\n            //Add lighting\n            O += e\n        :\n            //Add fog and step forward\n            O+=vec4(5,6,9, p+=(vec3(I+I,r)-r)/r.x*e )/1e2*e\n    )\n    //Apollonian fractal\n    for(j=s=4.;j++<11.;e=length(v*=e)/s-p.z/4e2)\n            s*=e=1.5/dot(v=mod(--v,2.)-1.,v);\n    O=min(O*O*O,1.);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 323, 387, 785]]}
{"id": "fsVczR", "name": "Normals from Depth", "author": "iq", "description": "A method to compute world space normals from a depth buffer that avoids the usual discontinuities at the edges of the objects, described by Yuwen Wu here [url]https://atyuwen.github.io/posts/normal-reconstruction[/url]. Left: naive. Right: improve", "tags": ["3d", "normals", "depth"], "likes": 74, "viewed": 5310, "published": 3, "date": "1654319734", "time_retrieved": "2024-07-30T16:45:39.225854", "image_code": "// When computing world space normals from a camera space depth buffer\n// the naive way, artifact appear at the edges of the objects. This\n// shaders shows one way to reduce these artifacts, described by Yuwen Wu\n// here: https://atyuwen.github.io/posts/normal-reconstruction\n//\n// On the left you see the naive method to compute normals, which produces\n// wrong results. On the right side you see the improved method which is\n// very close to the ground truth, as long as the surface details are larger\n// than 2 pixels. Both the naive and improved method are compared to the\n// ground truth normals every second.\n//\n// Like the naive method, the improved one computes world space normals\n// by considering the world position derivatives with respect to the\n// pixel's X and Y coordinates.\n//\n// However, instead of using central differences blindly, it picks either\n// the left or right neighbor based on which one is estimated to belong to\n// the same surface as the pixel for which we are currently computing a\n// normal. This is done by examining a second pixel to the right and left\n// and doing a comparison between the current pixel's depth and that we'd\n// expect to have at the current pixel if the neighbors were forming a\n// plane. Because such interpolation is linear, we do it in 1/z rather\n// than z space. So,\n//\n// 1/(1/a+1/a-1/b) rather than a+a-b, which leads to ab/(2b-a)\n//\n// The side with lowest discontinuity is picked, to avoid edge artifacts\n// as much as poosible.\n\n// recoved world space from depth\nvec3 getPos( in ivec2 fragCoord, in float depth );\n\n// computes the normal at pixel \"p\" based on the deph buffer \"depth\"\nvec3 computeNormalImproved( const sampler2D depth, in ivec2 p )\n{\n    float c0 = texelFetch(depth,p           ,0).w;\n    float l2 = texelFetch(depth,p-ivec2(2,0),0).w;\n    float l1 = texelFetch(depth,p-ivec2(1,0),0).w;\n    float r1 = texelFetch(depth,p+ivec2(1,0),0).w;\n    float r2 = texelFetch(depth,p+ivec2(2,0),0).w;\n    float b2 = texelFetch(depth,p-ivec2(0,2),0).w;\n    float b1 = texelFetch(depth,p-ivec2(0,1),0).w;\n    float t1 = texelFetch(depth,p+ivec2(0,1),0).w;\n    float t2 = texelFetch(depth,p+ivec2(0,2),0).w;\n    \n    float dl = abs(l1*l2/(2.0*l2-l1)-c0);\n    float dr = abs(r1*r2/(2.0*r2-r1)-c0);\n    float db = abs(b1*b2/(2.0*b2-b1)-c0);\n    float dt = abs(t1*t2/(2.0*t2-t1)-c0);\n    \n    vec3 ce = getPos(p,c0);\n\n    vec3 dpdx = (dl<dr) ?  ce-getPos(p-ivec2(1,0),l1) : \n                          -ce+getPos(p+ivec2(1,0),r1) ;\n    vec3 dpdy = (db<dt) ?  ce-getPos(p-ivec2(0,1),b1) : \n                          -ce+getPos(p+ivec2(0,1),t1) ;\n\n    return normalize(cross(dpdx,dpdy));\n}\n\n// naive way of computing the normal\nvec3 computeNormalNaive( const sampler2D depth, in ivec2 p )\n{\n    vec3 l1 = getPos(p-ivec2(1,0),texelFetch(depth,p-ivec2(1,0),0).w);\n    vec3 r1 = getPos(p+ivec2(1,0),texelFetch(depth,p+ivec2(1,0),0).w);\n    vec3 t1 = getPos(p+ivec2(0,1),texelFetch(depth,p+ivec2(0,1),0).w);\n    vec3 b1 = getPos(p-ivec2(0,1),texelFetch(depth,p-ivec2(0,1),0).w);\n    vec3 dpdx = r1-l1;\n    vec3 dpdy = t1-b1;\n    return normalize(cross(dpdx,dpdy));\n}\n\n// compute the world space position of a pixel with coordinates\n// fragCoord and distance \"depth\" to camera. This will need to\n// change depending on wether your depth buffer stores \"depth\"\n// \"z\", \"reverse z\", etc\nvec3 getPos( in ivec2 fragCoord, in float depth )\n{\n    vec2 p = (2.0*vec2(fragCoord)-iResolution.xy)/iResolution.y;\n    vec3 ro, rd;\n    camera( ro, rd, iTime, p );\n    return depth*rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n \n    //----------\n    // compute\n    //----------\n\n    // ground truth normal\n    vec3 norT = texelFetch( iChannel0, p, 0 ).xyz;\n \n    // naive way of computing the normal\n    vec3 norN = computeNormalNaive( iChannel0, p );\n    \n    // improved normal computation\n    vec3 norI = computeNormalImproved( iChannel0, p );\n\n    //----------\n    // display\n    //----------\n\n    // left: naive, right: improved\n    float x = fragCoord.x/iResolution.x;\n    vec3 nor = (x<0.5) ? norN : norI;\n    \n    // compare to true normal\n    if( sin(0.5*6.283185*iTime)<0.0 ) nor = norT;\n\n    // color : switch normals and lighting\n    vec3 col = nor;\n    if( sin(6.283185*iTime/16.0)<0.0 ) col = vec3(0.1,0.15,0.2)*nor.y + vec3(1.0,0.9,0.85)*vec3(nor.x*0.8+nor.y*0.5+nor.z*0.6);\n    \n    // depth darkening to hide geometry aliasing\n    float t = texelFetch( iChannel0, p, 0 ).w;\n    col *= exp2(-0.12*t*t);\n    \n    // separation bar\n    col = mix( vec3(1.0), col, smoothstep( 0.002, 0.003, abs(x-0.5) ) );\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n// Simplified geometry from https://www.shadertoy.com/view/lsf3zr\n//\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n//------------------------------------------\n\nfloat column( in float x, in float y, in float z )\n{\n    float y2=y-0.25;\n    float y4=y-1.0;\n\n    const float sqh = sqrt(0.5);\n    float nx = max(abs(x),abs(z));\n    float nz = min(abs(x),abs(z));\t\n\n    float dsp = abs(min(cos(1.125*6.283185*x/0.085), \n                        cos(1.125*6.283185*z/0.085)));\n    dsp *= 1.0-smoothstep(0.8,0.9,abs(x/0.085)*abs(z/0.085));\n    \n    float di1 = sdBox( vec3(x,y,z),   vec3(0.085+dsp*0.0075,1.0,0.085+dsp*0.0075));\n    float di2 = sdBox( vec3(x,y,z),   vec3(0.12,0.29,0.12) );\n    float di3 = sdBox( vec3(x,y4,z),  vec3(0.14,0.02,0.14) );\n    float di4 = sdBox( vec3(nx,y,nz), vec3(0.14,0.3,0.05) );\n    float di5 = sdBox( vec3(nx,(y2+nz)*sqh,(nz-y2)*sqh), vec3(0.12, 0.16*sqh, 0.16*sqh));\n    float di6 = sdBox( vec3(nx,(y2+nz)*sqh,(nz-y2)*sqh), vec3(0.14, 0.10*sqh, 0.10*sqh));\n\n    return min(min(min(di1,di2),\n                   min(di3,di4)),\n                   min(di5,di6));\n}\n\nfloat wave( in float x, in float y )\n{\n    return sin(x)*sin(y);\n}\n\nfloat map( vec3 pos )\n{\n    // floor\n    vec2 id = floor((pos.xz+0.1)/0.2 );\n    float h = 0.012 + 0.008*sin(id.x*2313.12+id.y*3231.219);\n    vec3 ros = vec3( mod(pos.x+0.1,0.2)-0.1, pos.y, mod(pos.z+0.1,0.2)-0.1 );\n    float res = sdBox( ros, vec3(0.096,h,0.096) );\n\n    // ceilin\n\tfloat x = fract( pos.x+128.0 ) - 0.5;\n\tfloat z = fract( pos.z+128.0 ) - 0.5;\n    float y = (1.0 - pos.y)*0.6;\n    float dis = 0.4 - smin(sqrt(y*y+x*x),sqrt(y*y+z*z),0.01);\n    float dsp = abs(sin(31.416*pos.y)*sin(31.416*pos.x)*sin(31.416*pos.z));\n    dis -= 0.02*dsp;\n\tdis = max( dis, y );\n    res = min( res, dis );\n\n    // columns\n\tvec2 fc = fract( pos.xz+128.5 ) - 0.5;\n\tfloat dis2 = column( fc.x, pos.y, fc.y );\n    res = min( res, dis2 );\n    \n    return res;\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, in float precis, in float maxd )\n{\n    float t = 0.001;\n    for( int i=0; i<128; i++ )\n    {\n\t    float d = map( ro+rd*t );\n        if( abs(d)<(precis*t)||t>maxd ) break;\n        t += d;\n    }\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n\tconst vec2 eps = vec2( 0.0002, 0.0 );\n\treturn normalize(vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro, rd;\n    camera( ro, rd, iTime, p );\n\n    float t= raycast(ro,rd,0.00001,100.0);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        fragColor = vec4(nor,t);\n    }\n    else\n    {\n        fragColor = vec4( 0.0, 0.0, 0.0, 1e10 );\n    }\n}", "buffer_a_inputs": [], "common_code": "void camera( out vec3 ro, out vec3 rd, in float time, in vec2 p)\n{\n    // screen split\n    p.x -= sign(p.x)*1.77777*0.5;\n\n    // camera position and target\n    ro = vec3(0.5, 0.3, 0.5 );\n    vec3 ta = ro + vec3( -1.0, 0.0, -1.0 );\n    \n    // contruct ray\n    vec3 cw = normalize( ta-ro );\n    vec3 cp = vec3( 0.0, 1.0, 0.0 );\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    rd = normalize( p.x*cu + p.y*cv + 1.8*cw );\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVczR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1579, 1648, 1713, 1713, 2648], [2650, 2687, 2749, 2749, 3121], [3123, 3338, 3389, 3389, 3526], [3528, 3528, 3585, 3585, 4647]]}
{"id": "fdVcRR", "name": "Creepy Trails", "author": "SnoopethDuckDuck", "description": "messy code", "tags": ["e"], "likes": 7, "viewed": 286, "published": 3, "date": "1654313630", "time_retrieved": "2024-07-30T16:45:39.967870", "image_code": "vec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n} \n\nvec3 pal(float t) {\n    vec3 d = 1. * vec3(0,1,2)/3.;\n    return 1. + 2. * cos(6.28319 * (0.5 * t + d));\n}\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Zoom + distort\n    float mx = 0.5 + 0.5 * thc(2.5, length(uv) * 0.5 - 0.4 * iTime);\n    float zm = mix(0.44, 0.6, mx);\n    zm += 1.5 - 1.5 * tanh(0.04 * iTime * iTime);\n    \n    //zm -= 0.3 * tanh(24. - length(uv) * 50.);\n    \n    // Pixel + cells etc.\n    vec2 res = 0.5 * floor(iResolution.xy);    \n    ivec2 px = ivec2(zm * fragCoord + (1.-zm) * res);\n    \n    vec4 c = cell(px);\n    vec4 b = cell(px - ivec2(0,1));\n    vec4 t = cell(px + ivec2(0,1));  \n    vec4 l = cell(px - ivec2(1,0));\n    vec4 r = cell(px + ivec2(1,0));    \n    vec4 sum = b + t + l + r;\n      \n    // Lighten right side\n    float cn = 0.06 * smoothstep(-0.2, 0.2, uv.x); \n    \n    // Cut colors into lines\n    float fl = clamp(uv.y, -0.125, 0.125);\n    \n    // Background\n    vec3 col = pal(0.05 * (uv.x + 5. * uv.y) + 0.2 * cn - 0.7);\n    \n    // Exterior outline\n   // if (sum.r > 1.)\n        col = c.g * pal(0.2 + uv.x * 0.2 + 0.3 * floor(c.g * 40.) /40.);  \n    \n    //col -= c.rgb;\n    fragColor.rgb = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n} \n\n// From iq\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    ivec2 px = ivec2(f);\n    vec4 test = cell(px);\n    //px = ivec2(1.2 * (f-res));\n    \n    // Centre coords\n    vec2 res = floor(0.5 * iResolution.xy);\n    f -= res;\n    \n    px = ivec2(1.5 * f + 1. * iTime * vec2(1,0));\n    \n    // Speed of time\n    float spd = 0.125;\n\n    // Number of blobs\n    float n = 40.;\n    \n    // Distance from blobs\n    float d = 1e5;\n    \n    for (float i = 0.; i < n; i++) {\n        // Offset each blob\n        float io = 2. * pi * i / n;\n        \n        // Time\n        float t = spd * iTime + 2. * pi * cos(0.5 * spd * iTime + io);\n        \n        // Motion of blobs (idk how this works)\n        float c = 1. + 0.5 * cos(4. * t + io);\n        d = smin(d, c * length(f - 120. * (c-0.5) * vec2(cos(t+io), sin(t+io))), 2.);  \n     }\n     \n     // Harsh shape\n     float r = step(d, 5.);\n     \n     // Soft shape (going inwards)\n     float s = smoothstep(0., 5., -d + 5.);\n     \n     vec4 cl = cell(px);\n     cl = mix(cl, cell(ivec2(f)), 0.95);\n     col = vec4(s);\n     \n     col = mix(col + 0.99 * cl, 0.999 * abs(col-cl), 1.);//cl * 0.999;\n\n     col = clamp(col, 0., 1.);\n     //col *= 0.5;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVcRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 133], [136, 136, 155, 155, 242], [285, 285, 342, 342, 1410]]}
{"id": "7dyyRz", "name": "Pixel Blobs", "author": "SnoopethDuckDuck", "description": "Simple and fun", "tags": ["pixelart"], "likes": 13, "viewed": 397, "published": 3, "date": "1654301561", "time_retrieved": "2024-07-30T16:45:40.719859", "image_code": "#define cell(p) texelFetch(iChannel0, ivec2(p), 0 )\n\nvec3 pal(float t) {\n    vec3 d = 0.35 * vec3(0,1,2)/3.;\n    return 0.5 + 0.5 * cos(6.28319 * (0.5 * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0. * iResolution.xy) / iResolution.y;\n    \n    // Zoom + distort\n    float zm = 0.7 - 0.5 * min(1., tanh(iTime * iTime));\n    //zm += 0.3 - 0.3 * tanh(24. - length(uv) * 50.);\n    \n    // Pixel + cells etc.  \n    vec2 px = zm * fragCoord + (1.-zm) * 0.5 * iResolution.xy;\n        \n    vec4 c = cell(px),\n         b = cell(px - vec2(0,1)),\n         t = cell(px + vec2(0,1)),\n         l = cell(px - vec2(1,0)),\n         r = cell(px + vec2(1,0)), \n         sum = b + t + l + r;\n      \n    // Lighten right side\n    float cn = 0.06 * smoothstep(-0.2, 0.2, uv.x); \n    \n    // Shade from bottom to top\n    float fl = clamp(uv.y, -0.125, 0.125);\n    \n    // Background\n    vec3 col = pal(0.05 * (uv.x + 5. * uv.y) + 0.2 * cn - 0.7);\n    \n    // Exterior outline\n    if (c.r == 0. && (sum.r == 1. || sum.r == 2.))\n        col = pal(fl + cn - 0.4);  \n    // Interior\n    else if (sum.r == 4.) \n        col = pal(fl + cn - 0.52 - 0.18 * c.g);    \n\n    fragColor.rgb = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n\n// From iq\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    // Centre coords\n    f -= floor(0.5 * iResolution.xy);\n    \n    // Speed of time\n    float spd = 0.125;\n\n    // Number of blobs\n    float n = 5.;\n    \n    // Distance from blobs\n    float d = 1e5;\n    \n    for (float i = 0.; i < n; i++) {\n        // Offset each blob\n        float io = 2. * pi * i / n;\n        \n        // Time\n        float t = spd * iTime + 2. * pi * cos(0.5 * spd * iTime + io);\n        \n        // Motion of blobs (idk how this works)\n        float c = 1. + 0.5 * cos(4. * t + io);\n        d = smin(d, c * length(f - 30. * (c-0.5) * vec2(cos(t+io), sin(t+io))), 10.);  \n     }\n     \n     // Harsh shape\n     float r = step(d, 5.);\n     \n     // Soft shape (going inwards)\n     float s = smoothstep(0., 5., -d + 5.);\n     \n     col = vec4(r, s, 0, 0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 72, 72, 163], [165, 165, 222, 222, 1215]]}
{"id": "sdGyzR", "name": "30 minutes 6/3", "author": "scry", "description": "timelapse: \nhttps://twitter.com/Scrygl/status/1532827703690244096", "tags": ["3d", "light", "rgb"], "likes": 3, "viewed": 236, "published": 3, "date": "1654289461", "time_retrieved": "2024-07-30T16:45:41.476835", "image_code": "////////////////////////////////////////////\n#define time iTime*1.\n#define pi 3.14159265\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    return max(abs(p.z)-s.z,max(abs(p.x)-s.x,abs(p.y)-s.y));\n} \n\nvec3 lpos(float a) {\n    vec3 l = vec3(0.,1.,3.);\n    l -= 0.3;\n    l += a*0.1;\n    l.xz *= r2d(time*0.5+a*0.1*time);\n    return l;\n}\n\nvec4 map(vec3 p) {\n    vec3 o = p;\n    p.z -= 3.;\n    p.yz *= r2d(sin(time/3.)*0.1);\n    p.xz *= r2d(time/6.);\n    float d = sdBox(p,vec3(0.05));\n    float od = d;\n    for (int i=0;i<4;i++) {\n        p = abs(p)-sin(time/4.+p.y*0.2)*0.1-0.1;\n        d = min(d,sdBox(p,vec3(sin(time*0.3+d*0.5+p.y*0.2)*0.5+0.5)*0.1));\n    }\n    //float d = sdBox(p,vec3(0.05));\n    d = min(d,o.y+0.5+0.5-od*0.2);\n    //d = max(d,-o.z+0.1);\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro ,vec3 rd, float s) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<99;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w*s;\n        dO += dS;\n        ii += 0.01;\n        if (dO > 100. || dS < 0.001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001,0.);\n    return normalize(vec3(\n        map(p-h.xyy).w-map(p+h.xyy).w,\n        map(p-h.yxy).w-map(p+h.yxy).w,\n        map(p-h.yyx).w-map(p+h.yyx).w\n    ));\n}\n\nvec3 sh(vec3 p, vec3 n, float a) {\n    vec3 l = lpos(a);\n    vec3 rd = normalize(l-p);\n    vec2 d = RM(p-n*0.003,rd,1.);\n    float dif = clamp(dot(rd,-n),0.,1.);\n    float s = 0.;\n    if (length(l-p) > d.x) {\n        s = 1.;\n    }\n    return vec3(s,dif,d.x);\n}\n\nfloat point(vec3 p, vec3 rd, float a) {\n    vec3 l = lpos(a);\n    float l1 = clamp(length(l-p)*0.5,0.,1.);\n    float l2 = pow(1.-length(l.xy-rd.xy*l.z),3.);\n    return clamp(pow(l2+0.1,5.),0.,1.);\n}\n\nvec3 colo(vec3 p, vec3 n, vec2 d, vec3 rd) {\n    vec3 col = 1.-d.xxx/7.;\n    vec3 mp = map(p).xyz;\n    col += 1.-n;\n    col *= 0.05;\n    \n    col *= 0.;\n    col.rg += sin(mp.z*10.)*0.1;\n    vec3 rs = sh(p,n,0.);\n    float p1 = point(p,rd,0.);\n    col.r += p1;\n    col.r -= rs.x*0.5;\n    col.r += rs.y*0.4;\n    vec3 bs = sh(p,n,1.);\n    p1 = point(p,rd,1.);\n    col.b += p1;\n    col.b -= bs.x*0.5;\n    col.b += bs.y*0.4;\n    vec3 gs = sh(p,n,2.);\n    p1 = point(p,rd,2.);\n    col.g += p1;\n    col.g -= gs.x*0.5;\n    col.g += gs.y*0.4;\n    //col += clamp(pow(p1+0.1,5.),0.,1.);\n    //col += clamp(s.z*0.01,0.,1.)*0.1;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd,1.);\n    vec3 p = ro+rd*d.x;\n    vec3 n = calcNorm(p);\n    col = colo(p,n,d,rd);\n    vec3 ocol = col;\n    vec3 oro = ro;\n    vec3 ord = rd;\n    vec2 od = d;\n    vec3 op = p;\n    vec3 on = n;\n    float rl = 1.5;\n    for (int i=0;i<3;i++) {\n        ro = p-n*0.003;\n        rd = reflect(rd,n);\n        d = RM(ro,rd,1.);\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        col += colo(p,n,d,rd)*rl;\n        rl *= 0.9;\n    }\n    col = clamp(col,0.,1.);\n    col += ocol;\n    \ncol *= 1.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 129, 129, 178], [180, 180, 209, 209, 272], [275, 275, 295, 295, 408], [410, 410, 428, 428, 854], [856, 856, 892, 892, 1133], [1135, 1135, 1158, 1158, 1340], [1342, 1342, 1376, 1376, 1602], [1604, 1604, 1643, 1643, 1802], [1804, 1804, 1848, 1848, 2437], [2439, 2439, 2494, 2494, 3250]]}
{"id": "7ddcRj", "name": "Game and Watch ", "author": "byt3_m3chanic", "description": "Just playing around with some flat 2D interface design (mouseable)", "tags": ["2d", "interface", "desgin"], "likes": 21, "viewed": 330, "published": 3, "date": "1654273908", "time_retrieved": "2024-07-30T16:45:42.303625", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   \n    interface\n    06/03/22 | byt3_m3chanic\n    \n    Just playing around with some flat 2D interface design (mouseable)\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI2 6.28318530718\n#define PI  3.14159265359\n\n// power color\nconst vec3 tcolor = vec3(0.518,0.933,0.365);\n\nmat2 rot(float g){return mat2(cos(g), sin(g),-sin(g), cos(g));}\nfloat hash21( vec2 p ){return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\n\nconst float scale = 40.;\nconst float hlfsc = (.435/scale)*scale;\n\nconst float N = 10.;\nconst float SN = 8.;\nconst int oct = 5;\n\n// @Shane - a very tightly compacted, self-contained version \n// of IQ's 3D value noise function.\n//---------------------------------------------------------------\nfloat n3D(vec3 p){\n    const vec3 s = vec3(113, 57, 27);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n//---------------------------------------------------------------\n// @iq fbm generator\nfloat fbm3( in vec3 x) {\n    x*=.64;\n    x.x = mod(x.x,SN*N);\n    x.y = mod(x.y,SN*N);//@mla : shifting the y value from the range [-PI,+PI] to [0,2N]\n    x*=.085;\n    float a = 0.1,b = .5,f = 2.;\n    vec3  d = vec3(0.);\n    for (int i = 0; i < oct; ++i) {      \n        float n = n3D(f*x);\n        a += b*n;\n        b *= 0.5;\n        f *= 1.8;\n    }\n\treturn a;\n}\n\nfloat box(vec2 p, vec2 b) {vec2 d=abs(p)-b;return length(max(d,0.))+min(max(d.x,d.y),0.);}\nfloat rbox(vec2 p, vec2 b, vec4 r ) {\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n//iq color functions\nvec3 hue(float t){ \n    t*=3.125;\n    vec3 d = vec3(0.357,0.937,0.043);\n    return .65+.4*cos( PI2*t * (vec3(0.945,0.937,0.875)*d) ); \n}\n\nfloat px = 0.;\n\nvec2 mainSize = vec2(.725,.45);\nvec2 insetSize =vec2(.7125,.4375);\nvec2 screenSize =vec2(.475,.275);\n\nvoid nanoBody(inout vec3 C, vec2 p) {\n    vec2 uv=p-vec2(0);\n    \n    //body\n    float d = box(uv,mainSize)-.015;\n    float sad = d;\n    d=smoothstep(px,-px,d);\n\n    //inset\n    float i = box(uv,insetSize)-.015;\n    i=smoothstep(px,-px,i);\n    \n    //shadow\n    float sd = box(uv+vec2(0,.01),insetSize);\n    sd=smoothstep(.045-px,-px,abs(sd)-.01);\n    \n    //screen\n    float d2 = box(uv-vec2(0.,.115),screenSize)-.015;\n    float d3 = abs(d2)-.0015;\n    float d4 = abs(d2)-.008;\n    d2=smoothstep(px,-px,d2);\n    d3=smoothstep(px,-px,d3);\n    d4=smoothstep(.015-px,-px,d4);\n    float hs = hash21(uv*sin(uv.x));\n    //red buttons\n    px=4./R.x;\n    vec2 dv = uv;\n    dv.x=abs(dv.x)-.61;\n    float btn = length(dv-vec2(.0,-.15))-.065;\n    btn=min(btn,rbox(dv+vec2(.185,.25),vec2(.065,.030),vec4(.030)) );\n    btn=min(btn,rbox(dv+vec2(.46,.25),vec2(.065,.030),vec4(.030)) );\n    btn=smoothstep(px,-px,btn);\n    \n    vec2 tv = uv*10.;\n    float nd = box(vec2(abs(tv.x)-6.1,tv.y-1.7),vec2(.65,1.4));\n    //speaker dots\n    tv=mod(tv+.1,.2)-.1;\n    float dts = length(tv)-.05;\n    dts=max(dts,nd);\n    dts=smoothstep(px,-px,dts);\n\n    C= mix(C,vec3(.0),sd);\n    C= mix(C,vec3(.015)-(hs*.01),d);\n\n    C= mix(C,vec3(.335)-(hs*.01),min(clamp(min(uv.y+.4,i),0.,1.),1.-btn) );\n    C= mix(C,vec3(0.208,0.373,0.220)-(hs*.05),d2);\n    C= mix(C,C*.5,min(d4,d2));\n    C= mix(C,vec3(.6),d3);\n    C= mix(C,vec3(.015),dts);\n    \n    float mcheck = 0.;\n    px=2./R.x;\n    float ftn = length(dv-vec2(.0,-.15))-.055;\n    float rtn=rbox(dv+vec2(.185,.25),vec2(.055,.020),vec4(.020));\n    rtn=min(rtn,rbox(dv+vec2(.46,.25),vec2(.055,.020),vec4(.020)) );\n    ftn=smoothstep(px,-px,ftn);\n    rtn=smoothstep(px,-px,rtn);\n    C= mix(C,vec3(.9,.01,.01),ftn);\n    C= mix(C,vec3(0.149,0.149,0.149),rtn);\n    //button highlight\n    float etn = length(dv-vec2(.0,-.15))-.05;\n    float een = rbox(dv+vec2(.185,.249),vec2(.050,.015),vec4(.015));\n    een=min(een,rbox(dv+vec2(.46,.25),vec2(.050,.015),vec4(.015)) );\n    etn=smoothstep(px,-px,etn);\n    een=smoothstep(px,-px,een);\n    C= mix(C,vec3(1),min(clamp((uv.y*3.25)+.55,0.,1.),etn));\n    C= mix(C,vec3(1),min(clamp((uv.y*3.55)+.95,0.,1.),een));\n    // power light\n    float l = box(uv+vec2(.685,-.42),vec2(.0125,.002))-.0025;\n    float sl=smoothstep(.02-px,-px,l);\n    l=smoothstep(px,-px,l);\n    C= mix(C,tcolor*.2,sl);\n    C= mix(C,tcolor,l);\n\n}\n\nconst float tx = .5;\nconst vec2[4] myhood = vec2[4](vec2(1,0),vec2(0,-1),vec2(-1,0),vec2(0,1));\nconst vec2[4] mypos  = vec2[4](vec2(tx,0),vec2(0,-tx),vec2(-tx,0),vec2(0,tx));\n\nfloat side(float hs) {\n    float s=(hs>.75)?0.:(hs>.5)?2.:(hs>.25)?1.:3.;\n    return s;\n}\n\nvec3 checkColor(float sd, float fc, vec4 hash) {\n    float ch = side(hash[int(fc)]);\n\n    if(sd==0.&&ch==1.||sd==1.&&ch==0.) ch=8.;\n    if(sd==0.&&ch==3.||sd==3.&&ch==0.) ch=7.;\n    if(sd==0.&&ch==2.||sd==2.&&ch==0.) ch=6.;\n    \n    if(sd==1.&&ch==3.||sd==3.&&ch==1.) ch=14.;\n    if(sd==1.&&ch==2.||sd==2.&&ch==1.) ch=9.;   \n  \n    if(sd==2.&&ch==3.||sd==3.&&ch==2.) ch=5.;\n    \n    if(sd==ch) ch=sd;\n    \n    return vec3(1./ch);\n}\n\nvec4 gethood(vec2 id, inout float hs) {\n    vec4 nh = vec4(0);\n    hs = fbm3(vec3(id,T*2.5));\n    for(int i=0;i<4;i++){\n        nh[i]=fbm3(vec3(id-myhood[i],T*2.5));\n    }\n    return nh;\n}\n\nvoid getScreen(inout vec3 C, vec2 p3) {\n    vec2 uv=p3;\n\n    //screen\n    float srrn = box(uv-vec2(0.,.115),screenSize*.99)-.015;\n    srrn=smoothstep(px,-px,srrn);\n    \n    float px =scale/R.x;\n    vec3 clr = vec3(1.);\n    uv+=vec2(.0,.1)*T;\n    uv-=vec2((M.x/R.x*PI)*1.-.5,(M.y/R.y*PI)*1.-.5);\n  \n    vec2 id= floor(uv*scale);\n    vec2 p = fract(uv*scale)-.5;\n    \n    float hs = 0.;\n    vec4  gs = gethood(id, hs);\n\n    float d1 = box(p,vec2(hlfsc*.89))-.075;\n    if(hs>.25){\n        float d2 = length(p)-(hs*.3);\n        d2=abs(d2)-.02;\n        d2=smoothstep(px,-px,d2);\n    }\n    \n    float sd = side(hs);\n    d1=smoothstep(px,-px,d1);\n    C=mix(C,C*hue(sd),min(d1,srrn));\n    \n    float sz = .85;\n\n    for(int i=0;i<4;i++){\n\n        vec2 tuv = p+vec2(mypos[i]);\n        vec2 bs = i==1||i==3 ? vec2(hlfsc*sz,hlfsc*.25) : vec2(hlfsc*.25,hlfsc*sz);\n        d1=box(tuv,bs);\n\n        float s1 = box(tuv-vec2(-.05,.05),bs);\n        s1=smoothstep(.15-px,-px,s1);\n        \n        float od1 = abs(d1)-.015;\n        d1=smoothstep(px,-px,d1);\n        clr = checkColor(sd,float(i),gs);\n        \n        // only if edges are different draw overlap\n        if(side(gs[i])!=sd){\n            C=mix(C,C*.5,min(s1,srrn));\n            C=mix(C,clr,min(d1,srrn));\n            od1=smoothstep(px,-px,od1);\n            C=mix(C,vec3(.01),min(od1,srrn));\n        }\n    }\n}\n\nvoid rainbow( inout vec3 C, vec2 uv) {\n    float hs = hash21(uv*sin(uv.x));\n    float s1 = length(abs(uv.y+.04))-.02;\n    s1=smoothstep(px,-px,s1);\n    C=mix(C,vec3(0.576,0.024,0.161)-(hs*.025),s1);\n\n    s1 = length(abs(uv.y))-.02;\n    s1=smoothstep(px,-px,s1);\n    C=mix(C,vec3(0.576,0.216,0.024)-(hs*.035),s1);\n    \n    s1 = length(abs(uv.y-.04))-.02;\n    s1=smoothstep(px,-px,s1);\n    C=mix(C,vec3(0.678,0.624,0.020)-(hs*.035),s1);\n    \n    s1 = length(abs(uv.y-.08))-.02;\n    s1=smoothstep(px,-px,s1);\n    C=mix(C,vec3(0.184,0.553,0.027)-(hs*.025),s1);\n\n    s1 = length(abs(uv.y-.12))-.02;\n    s1=smoothstep(px,-px,s1);\n    C=mix(C,vec3(0.027,0.220,0.533)-(hs*.035),s1);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    float hs = hash21(uv*sin(uv.x));\n    vec3 C = vec3(clamp((uv.y+1.)*.1,.01,1.))-(hs*.015);\n\n    px=2./R.x;\n\n    rainbow(C, uv);\n    nanoBody(C, uv);\n    getScreen(C,uv);\n\n    if(hs<.65) C = clamp(C-(hs*.005),C,vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddcRj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[391, 391, 409, 409, 454], [455, 455, 478, 478, 533], [663, 827, 845, 845, 1155], [1156, 1243, 1267, 1267, 1606], [1608, 1608, 1635, 1635, 1698], [1699, 1699, 1736, 1736, 1893], [1895, 1916, 1934, 1934, 2052], [2172, 2172, 2209, 2209, 4540], [4718, 4718, 4740, 4740, 4807], [4809, 4809, 4857, 4857, 5240], [5242, 5242, 5281, 5281, 5430], [5432, 5432, 5471, 5471, 6784], [6786, 6786, 6824, 6824, 7462], [7464, 7464, 7505, 7505, 7824]]}
{"id": "sstcDl", "name": "TP 5", "author": "zinedine", "description": "TP5", "tags": ["zinedine"], "likes": 1, "viewed": 188, "published": 3, "date": "1654273514", "time_retrieved": "2024-07-30T16:45:43.054617", "image_code": "// Texturing\n// Zidane Zinedine\n\n\nconst float View = 2800.0;  // View distance\nconst float Epsilon = 0.01; // Marching epsilon\nconst int Steps = 400;      // Number of steps\n\n// Lipschitz constant\nconst float K=1.0;\n\n// Terrain -----------------------------------------------------------------------------------------------\n\n//PLATEAU\n\nfloat plateau(float h, float e, float a)\n{\n    if ((h<e)||(h>e+a)){ return h;}\n   float u = (h-e)/((e+a)-e);\n    float c = u*u;\n    h = e + a*c;\n    return h;\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nfloat Intersection(float a,float b)\n{\n    return max(a,b);\n}\n\nfloat Union(float a, float b)\n{\n    return min(a,b);\n}\n\n// Terrain heightfield\n// x : Position in the plane\nfloat Terrain( in vec2 p )\n{\n\treturn 50.0*sin(p.x/120.0)*cos(p.y/90.0);\n} \n\nfloat Terre (in vec2 p)\n{\n    return FbmRidge(p,200.0, 140.0, 9);\n}\n\nfloat mer(in vec2 p)\n{\n    return FbmRidge(p,20.0, 10.0, 2);\n}\n\n// Implicit surface defining the terrain\n// p : Point\nfloat ImplicitTerrain(in vec3 p)\n{\n    float z = Terre( p.xy );\n    float h = (p.z - z)/2.0; \n    return h;\n}\n\nfloat ImplicitTerrain1(in vec3 p)\n{\n    float z = mer( p.xy );\n    float h = (p.z - z)/2.0; \n    return h;\n}\n\n\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Sphere \n// p : Point\n// c : Center \n// r : Radius\nfloat Sphere(vec3 p, vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\n\n\n// Scene --------------------------------------------------------------------------\n\n// Potential field of the object\n// p : point\nfloat Object(vec3 p)\n{\n  float a = ImplicitTerrain1(p+iTime*vec3(27,27,0));\n  float u = Union(ImplicitTerrain(p),a);\n\n  return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n    float v = Object(p);\n  n.x = Object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = Object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = Object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = Object(p);\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v/K);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\n\nvec3 TextureWater(in vec3 p)\n{\n  return vec3(0.52,0.75,0.91);   \n}\n\nvec3 TextureRock(in vec3 p)\n{\n  return mix(vec3(0.92,0.91,0.90),vec3(0.74,0.72,0.72),Fbm(p/50.0));   \n}\n\n\nvec3 TextureBorder(in vec3 p)\n{\n    return vec3(0.25,0.24,0.24);   \n}\n\n// Compute color \n// p : Point\n// n : Normal\nvec3 Color(in vec3 p,in vec3 n)\n{\n    return TextureBorder(p);\n}\n\n// Rendering \n// ro, rd : Ray origin and direction\n// pip : Picture in picture boolean\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8,-0.3,0.4) );\n   \n    \n\tvec3 col;\n    int it;\n    bool b;\n    float t = SphereTrace( ro, rd, View,b , it);\n\tvec3 p = ro + t*rd;\n    float vp= Object(p);\n    vec3 n = ObjectNormal( p );\n\n\n    col = Color(p,n);\n    // Sky\n    if( b==false )\n    {\n        col = vec3(0.35,0.65,0.95) - rd.z*rd.z*2.5;\n    }\n\telse \n\t{\n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n                   \n\n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif;\n        \n        col = 0.45*col+0.55*dif*vec3(0.35,0.35,0.35);\n\t}\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    \tfloat s=float(it)/float(Steps);\n\t\treturn vec4(0.112+0.824*s,0.418+0.556*s,0.611-0.515*s,t);\n    }\n    else\n    {\n    \t// Gamma with square root\n    \treturn vec4( sqrt(col), t );\n    }\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float a = 3.14*2.0*1.5*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = Camera( a, ro);   \n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,5.0));\n    \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n}", "image_inputs": [], "common_code": "// Texturing\n// Zinedine Zidane\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\n\n// Fractal brownian motion with 4 frequencies\n// p : Point\nfloat Fbm(in vec3 p)\n{\n    return Noise(p)/2.0+Noise(p*2.0)/4.0+Noise(p*4.0)/8.0+Noise(p*8.0)/16.0;\n}\n\nfloat Fbmc(vec2 p, float l, float a, int d)\n{\n    float t=0.0;\n        for(int i = 0; i<0; i++)\n        {\n            t+= a*Noise(p/l);\n            a*=0.5;\n            l*=0.5;\n        }\n    return t;\n}\n\nfloat ridge (vec2 p)\n{\n     float c = 1.0-2.0*abs(Noise(p));\n     return c;\n}\n\nfloat FbmRidge(vec2 p, float l, float a, int d)\n{\n    float t = 0.0;\n    for(int i = 1; i<d; i++)\n    {\n        t += a*ridge(p/l);\n        a *= 0.5; l *= 0.5;\n    }\n    return t;\n}\n\n\nfloat HGRF(vec2 p, float l, float a, int d, float amin, float amax)\n{\n    float t = a*ridge(p/l);\n    for(int i = 1; i<0; i++)\n    {\n        a*=0.5; l*0.5;\n        float att=smoothstep(amin, amax, t);\n        t+= att*a*ridge(p/l);\n    }\n    return t;\n}\n\n\n// Camera\n// a: Rotation angle around z axis\n// ro : Ray origin\nmat3 Camera(float a, out vec3 ro)\n{\n\tfloat range=1350.0;\n    // Origin\n    ro = vec3(range*cos(a),range*sin(a),range/4.0);\n\t\n    // Target\n    vec3 ta = vec3(0.0,0.0,0.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstcDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[336, 336, 378, 378, 496], [498, 603, 640, 640, 663], [665, 665, 696, 696, 719], [721, 773, 801, 801, 846], [849, 849, 874, 874, 916], [918, 918, 940, 940, 980], [982, 1036, 1070, 1070, 1145], [1147, 1147, 1182, 1182, 1255], [1367, 1420, 1458, 1458, 1484], [1573, 1619, 1641, 1641, 1750], [1860, 1900, 1931, 1931, 2153], [2155, 2285, 2350, 2350, 2757], [2863, 2863, 2893, 2893, 2929], [2931, 2931, 2960, 2960, 3034], [3037, 3037, 3068, 3068, 3106], [3108, 3153, 3186, 3186, 3217], [3219, 3306, 3355, 3378, 4295], [4297, 4297, 4345, 4370, 4770], [4774, 4774, 4831, 4883, 5304]]}
{"id": "ftjfWt", "name": "Art Room Colored", "author": "Charbake", "description": "Colored Art Room", "tags": ["art"], "likes": 1, "viewed": 179, "published": 3, "date": "1654266967", "time_retrieved": "2024-07-30T16:45:43.796633", "image_code": "struct ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct material {\n    vec3 color;\n    int mat_type;\n    float mat_dep_var;\n    float fuzz;\n    float ir;\n};\n\nstruct hitRecord{\n    vec3 point;\n    vec3 normal;\n    float t;\n    bool front;\n    material mat;\n};\n\nbool zero(vec3 direction){\n    float minNum = 1e-8;\n    if (abs(direction.x) < minNum && abs(direction.y) < minNum && abs(direction.z) < minNum){\n        return true;\n    }\n    return false;\n}\n\nbool lambertian(ray r, hitRecord rec, out vec3 attenuation, out ray scatteredRay, material mat){\n    vec3 scatteredDir= rec.normal + normalize(random_in_unit_sphere(g_seed));\n    \n    if (zero(scatteredDir)){\n        scatteredDir = rec.normal;    \n    }\n    scatteredRay = ray(rec.point, scatteredDir);\n    attenuation = mat.color;\n    return true;\n}\n\nvec3 reflect(vec3 v, vec3 n) {\n    return v - 2.*dot(v,n)*n;\n}\n\nvec3 refract(vec3 uv, vec3 n, float etai_over_etat){\n    float cosTheta = min(dot(uv*-1.0, n), 1.0);\n    vec3 rOutPerp =  etai_over_etat * (uv + cosTheta*n);\n    vec3 rOutParallel = -sqrt(abs(1.0 - length(rOutPerp)*length(rOutPerp))) * n;\n    return rOutPerp + rOutParallel;\n}\n\nfloat reflectance(float cosine, float refIdx){\n    float r0 = (1.-refIdx) / (1.+refIdx);\n    float r = r0 * r0;\n    return r + (1.-r)*pow((1.-cosine),5.);\n}\n\nbool dielectric(material m, ray r_in, hitRecord rec, out vec3 attenuation, out ray scattered){\n    attenuation = vec3(1.,1.,1.);\n    float refractionRatio = m.ir;\n    if (rec.front){\n        refractionRatio = 1.0 / m.ir;\n    }\n    vec3 unitDirection = normalize(r_in.direction);\n    \n    float cosTheta = min(dot(-unitDirection, rec.normal), 1.0);\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    bool cannotRefract = refractionRatio * sinTheta > 1.0;\n    vec3 direction;\n    if (cannotRefract || reflectance(cosTheta, refractionRatio) > rand1(g_seed)){\n        direction = reflect(unitDirection, rec.normal);\n    }\n    else{\n        direction = refract(unitDirection, rec.normal, refractionRatio);\n    }\n    scattered = ray(rec.point, direction);\n    return true;\n}\n\nstruct camera{\n    float aspect_ratio;\n    float viewport_height;\n    float viewport_width;\n    float focal_length;\n    \n    vec3 origin;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 lower_left;\n};\n\nstruct sphereStruct {\n    vec3 center;\n    float radius;\n    material mat;\n};\n\nbool metal(material mat, ray rIn, hitRecord rec, out vec3 attenuation, out ray scattered) {\n    float f = min(mat.fuzz, 1.0);\n    vec3 reflected = reflect(normalize(rIn.direction), rec.normal);\n    scattered = ray(rec.point, reflected + f*random_in_unit_sphere(g_seed));\n    attenuation = mat.color;\n    bool test = (dot(scattered.direction, rec.normal) > 0.);\n    return test;\n}\n\nbool materialScatter(material mat, ray rIn, hitRecord rec, out vec3 attenuation, out ray scattered) {\n    if (mat.mat_type == 8){\n        return lambertian(rIn, rec, attenuation, scattered, mat);\n    }\n    else if (mat.mat_type == 9){\n        return metal(mat, rIn, rec, attenuation, scattered);\n    }\n    else if (mat.mat_type == 10){\n        return dielectric(mat, rIn, rec, attenuation, scattered);\n    } \n    else{\n        return false;\n    }\n}\n\nray getRay(float u, float v, camera c){\n    return ray(c.origin, c.lower_left + u*c.horizontal + v*c.vertical - c.origin);\n}\n\nvoid setFaceNormal(const ray r, vec3 normalOut, out hitRecord rec) {\n    rec.front = dot(r.direction, normalOut) < 0.;\n    if (rec.front){\n        rec.normal = normalOut;\n    }\n    else{\n        rec.normal = -normalOut;\n    }\n}\nvec3 pointAt(float t, ray r)  {\n    return r.origin + t*r.direction;\n}\n \n\nbool sphere(ray r, float min_t, float max_t, out hitRecord temp, sphereStruct s) {\n    vec3 oc = r.origin - s.center;\n    float dir2 = length(r.direction)*length(r.direction);\n    float oc_dir =dot(oc, r.direction);\n    float oc_rad = length(oc) * length(oc) - s.radius*s.radius;\n    float discriminant = oc_dir*oc_dir - dir2*oc_rad;\n   \n    if (discriminant < 0.) return false;\n\n    float sqrtd = sqrt(discriminant);\n   \n    float root = (-oc_dir - sqrtd) / dir2;\n    if (root < min_t || max_t < root){\n       return false;\n    }\n\n    temp.t = root;\n    temp.point = pointAt(temp.t,r);\n    temp.normal = (temp.point - s.center)/s.radius;\n    vec3 outward_normal = (temp.point - s.center) / s.radius;\n    setFaceNormal(r, outward_normal, temp);\n    temp.mat = s.mat;\n    return true;\n   \n}\n\nbool hit(ray r, float minT, float maxT, inout hitRecord rec, sphereStruct s[9], int spheres) {\n   hitRecord temp;\n   bool hitCheck = false;\n   float closest = maxT;\n   \n   for (int i=0; i < spheres; i++){\n      if (sphere(r, minT, closest, temp, s[i])){\n          hitCheck = true;\n          closest = temp.t;\n          rec = temp;\n       }\n   }\n   return hitCheck;\n}\n\nbool rayColorHelper(out ray r, int depth, out vec3 result, out vec3 attenTotal) {\n    if (depth <= 0){\n        result = vec3(0., 0., 0.);\n        return false;\n    }\n    const int spheres = 9;\n    sphereStruct[spheres] sphereArray;\n    sphereArray[0] = sphereStruct(vec3(0., -100.5, -1.), 100., material(vec3(0.1, 0.1, 0.1), 8, 0., 0., 0.));   \n    sphereArray[1] = sphereStruct(vec3(-101.5, 0.0, -1.), 100., material(vec3(0.0, 0.9, 0.9), 8, 0., 0., 0.));   \n    sphereArray[2] = sphereStruct(vec3(101.5, 0.0, -1.), 100., material(vec3(0., 0.9, 0.9), 8, 0., 0., 0.));\n    sphereArray[3] = sphereStruct(vec3(0.0, 2.0, 120.), 100., material(vec3(0.,0.9,0.9), 8, 0., 0., 0.));\nsphereArray[4] = sphereStruct(vec3(0.19,1.07,3.0),0.09, material(vec3(0.8, 0.8, 0.8),9, 0., 0.0, 1.)); \nsphereArray[5] = sphereStruct(vec3(-0.16,1.19,3.0),0.12, material(vec3(0.8, 0.8, 0.8),9, 0., 0.0, 1.)); \nsphereArray[6] = sphereStruct(vec3(0.19,1.17,3.0),0.18, material(vec3(0.8, 0.8, 0.8),9, 0., 0.0, 1.)); \nsphereArray[7] = sphereStruct(vec3(-0.42,1.12,3.0),0.19, material(vec3(0.8, 0.8, 0.8),9, 0., 0.0, 1.)); \nsphereArray[8] = sphereStruct(vec3(-0.18,0.7,3.0),0.14, material(vec3(0.8, 0.8, 0.8),9, 0., 0.0, 1.));\n    \n    hitRecord rec;\n    if (hit(r, 0.001, 1e5, rec, sphereArray, spheres)){\n        ray scattered;\n        vec3 attenuation;\n        if (materialScatter(rec.mat, r, rec, attenuation, scattered)){\n            attenTotal *= attenuation;\n            r = scattered;\n            return true;\n        }\n        result = vec3(0.,0.,0.);\n        return true;\n    }\n   \n    vec3 dir = r.direction;\n    float t = 0.5 *(dir.y + 1.);\n    result = (1. - t)*vec3(1., 1., 1.) + t*vec3(0.5, 0.7, 1.);\n   \n    return false;\n   \n}\n\nvec3 rayColor(ray r, int depth){\n    vec3 result;\n    float count = 0.;\n    int d = depth;\n    vec3 attenTotal = vec3(1.,1.,1.);\n    \n    for (;rayColorHelper(r, d, result, attenTotal); d--);\n    return attenTotal*result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lookfrom = vec3(0.0,0.5,-4.);\n    vec3 lookat = vec3(0.,0.4,0.);\n    vec3 vup = vec3(0.,1.,0.);\n    \n    float vertFieldOfView = 20.;\n    float rads = vertFieldOfView * 3.14159265/180.;\n    float h = tan(rads/2.0);\n    \n    camera c;\n    c.aspect_ratio = 16.0 / 9.0;\n    c.viewport_height = 2.0 * h;\n    c.viewport_width = c.aspect_ratio * c.viewport_height;\n    c.focal_length = 1.0;\n    \n    vec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(vup,w));\n    vec3 v = cross(w,u);\n    \n    \n    c.origin = lookfrom;\n    c.horizontal = c.viewport_width * u;\n    c.vertical = c.viewport_height * v;\n    c.lower_left = c.origin - (c.horizontal/2.) - (c.vertical/2.) - w;\n   \n    int samples_per_pixel = 40;\n    const int max_depth = 20;\n    vec3 finColor = vec3(0., 0., 0.);\n    init_rand(fragCoord, iTime);\n   \n    for (int s = 0; s < samples_per_pixel; s++){\n        float x = (fragCoord.x + rand1(g_seed))/ (float(iResolution.x) - 1.);\n        float y = (fragCoord.y + rand1(g_seed))/ (float(iResolution.y) - 1.);\n        ray r = getRay(x, y, c);\n        vec3 color = rayColor(r, max_depth);\n        finColor += color * (1./float(samples_per_pixel));\n    }\n    fragColor = vec4(sqrt(finColor), 1.0);\n}", "image_inputs": [], "common_code": "// Ray tracing in one weekend basecode for Dartmouth CS 77/177 \n// by Wojciech Jarosz, 2019\n\n#define EPSILON 1e-3 \n#define MAX_FLOAT 1e5\n#define MAX_RECURSION 5\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time) {\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+time;\n}\n\n\nfloat rand1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 rand2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rand3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = rand2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = rand3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjfWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 265, 291, 291, 457], [459, 459, 555, 555, 809], [811, 811, 841, 841, 873], [875, 875, 927, 927, 1151], [1153, 1153, 1199, 1199, 1309], [1311, 1311, 1405, 1405, 2084], [2368, 2368, 2459, 2459, 2747], [2749, 2749, 2850, 2850, 3197], [3199, 3199, 3238, 3238, 3323], [3325, 3325, 3393, 3393, 3552], [3553, 3553, 3584, 3584, 3623], [3627, 3627, 3709, 3709, 4416], [4418, 4418, 4512, 4512, 4784], [6499, 6499, 6531, 6531, 6722]]}
{"id": "NstyWl", "name": "repro image by dart throwing", "author": "FabriceNeyret2", "description": "Reproduce ref image with random splats ( ultra slow to converge ;-) )\nred = remaining error\nblue = reconstruction\ngreen/red splats:  positive/negative shape dart throwing\nNB: you can change splat shape in buffA:23-26", "tags": ["montecarlo", "gpmipmap", "dartthrowing"], "likes": 3, "viewed": 317, "published": 3, "date": "1654245377", "time_retrieved": "2024-07-30T16:45:44.539646", "image_code": "\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T(U);\n    if ( O.g != 0. ) O = 30.*vec4(-O.g,O.g,0,0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n#define R    iResolution.xy", "buffer_a_code": "// O.r : current image error\n// O.b : current image best\n// O.g : current image delta proposal\n// O.a : integral error\n\n#define hash(p)  fract(sin((p)* vec2(12.9898, 78.233 )) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);                      // restore previous state\n    vec2  U = u/R.y;\n    float m = textureLod(iChannel0, vec2(.5), 99.).r, // total image difference\n          m0= O.a;                 // previous image difference\n    if ( m < m0 ) O.b += O.g,      // if last draw improved, keep it.\n                  O.a = m;         // store new image difference\n    O.g = 0.;                      // proposal: modification to prev best\n    for( float s,t,i = 0.; i < 1.; i++ ) {           // simulatenous tests (not independant: whole lot ok or not)\n        t = iTime -7.1*i;                            // seed\n        vec2 p = R/R.y*hash(t), r = hash(t+1.), d;   // random rectangle\n        r = .2*r*r;                                  // size distribution\n        s =  2.*hash(t+.5).y -1.;                    // random signed weight\n                                                     // proposal splat:\n     // d = r - abs(U-p); O.g += s* step( 0.,min(d.x,d.y)); //  rectangle\n     // O.g += s* step( length(U-p) , r.x );         //         disc\n        O.g += s* max(0., r.x - length(U-p) );       //         cone\n     // O.g += s* smoothstep(r.x,0.,length(U-p) );   //         blob\n    }\n    O.r = abs ( O.b+O.g - texture(iChannel1,u/R).b );// error compare to reference\n                                                     // top MIPmap LOD will integrate    \n    if (iFrame<1) O = vec4(1e9, .5,0, 1e9); \n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstyWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 104]]}
{"id": "7scyDl", "name": "dance sphere", "author": "jorge2017a2", "description": "dance sphere", "tags": ["dancesphere"], "likes": 7, "viewed": 239, "published": 3, "date": "1654222455", "time_retrieved": "2024-07-30T16:45:45.331529", "image_code": "//----------image\n//por jorge2017a2-\n//referencia\n//https://www.shadertoy.com/view/NlSfDD.....Created by yasuo in 2022-05-10\n//https://iquilezles.org/\n\n#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//iq \nfloat sdTunnel( in vec2 p, in vec2 wh )\n{   p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\n\nfloat random2(vec2 st)\n{return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123); }\n\nfloat hash(vec2 co)\n{ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    //referencia yasuo\n    float m=45.0;\n    vec3 p0=p;\n    vec2 id = floor(p.xz/m);\n  \n    p.xz = mod(p.xz,m)-m*0.5;\n    float h = 1.0+clamp(hash(id), .1, .7)*3.1415*2.3;\n    p.y-=h-1.5;\n    \n    ///--\n    float dir = 1.0;\n    float n = hash(id);\n    if(n<0.5)dir = -1.0;\n    \n    p.xz *= Rot(radians(45.0+n*20.0+iTime*1.0*dir));\n    ///--\n    \n    p=rotate_y( p, iTime*2.0);\n    \n    p.y=p.y-5.0;\n    \n    float d0=sdBox( p-vec3(0.0,12.0,0.0), vec3(4.0,2.0,4.0) );\n    float d1a=sdSphere(p-vec3(0.0,0.0,0.0), 12.0 );\n    float d1b=d1a;\n    float d2a=sdBox( p-vec3(0.0,-6.0,0.0), vec3(14.0,6.0,14.0) );\n    float d2b=sdBox( p-vec3(0.0,-3.0,0.0), vec3(14.0,3.0,14.0) );\n    \n    float d3a= sdTunnel(p.xy, vec2(3.,4.0) );\n    float d4a= sdTunnel(p.xy, vec2(4.,5.0) );\n    float d5a= sdTunnel(p.xy, vec2(5.,6.0) );\n    \n    float d6a=sdCylinderXZ( p-vec3(0.0,-5.0,0.0), vec2(14.0,1.1) );\n    float d7a=sdCylinderXZ( p-vec3(0.0,-5.0,0.0), vec2(17.0,1.1) );\n    float d8a=sdCylinderXZ( p-vec3(0.0,-5.0,0.0), vec2(20.0,1.1) );\n    \n    d1a= Difference(d1a, d2a);\n    d1b=Intersect(d1b,d2b);\n    float d3aa=Intersect(d3a,d1a);\n    float d3ab=Intersect(d3a,d1b);\n    float d4aa=Intersect(d4a,d1a);\n    float d4ab=Intersect(d4a,d1b);\n    float d5aa=Intersect(d5a,d1a);\n    float d5ab=Intersect(d5a,d1b);\n    \n    res =opU2(res, vec2(d0,9.0));\n    res =opU2(res, vec2(d1a,1.0));\n    res =opU2(res, vec2(d1b,0.0));\n    res =opU2(res, vec2(d5aa,5.0));\n    res =opU2(res, vec2(d5ab,5.0));\n    res =opU2(res, vec2(d4aa,8.0));\n    res =opU2(res, vec2(d4ab,8.0));\n    res =opU2(res, vec2(d3aa,2.0));\n    res =opU2(res, vec2(d3ab,2.0));\n    res =opU2(res, vec2(d8a,8.0));\n    res =opU2(res, vec2(d7a,0.0));\n    res =opU2(res, vec2(d6a,1.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    \n    // efecto\n    if (1.5*sin( iTime)>0.0)\n        colOut=(colOut+ pallete(diffuse.x) * max(0.0, dot(N, L)))/2.0;  //-2-\n    \n    return colOut;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{ return vec3(0.0);}\n\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n     \n    if (id_color==57) {return pattern( p.xz );}\n    if (id_color==58) {return pattern( p.xy );}\n    if (id_color==59) {return pattern( p.zy );}\n   \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 60.0, -25.); light_color1=vec3( 0.5,0.5,0.5 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,30.0,-25.0+t*1.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(20.0));\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0)   //10\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i]; }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[577, 577, 613, 613, 634], [635, 635, 667, 667, 751], [753, 753, 792, 792, 887], [888, 888, 927, 927, 1022], [1023, 1023, 1062, 1062, 1157], [1160, 1160, 1204, 1204, 1231], [1232, 1232, 1272, 1272, 1299], [1300, 1300, 1345, 1345, 1373], [1374, 1412, 1448, 1448, 1493], [1496, 1496, 1530, 1530, 1626], [1627, 1627, 1661, 1661, 1752], [1753, 1753, 1787, 1787, 1878], [1880, 1880, 1914, 1914, 2005], [2007, 2007, 2032, 2032, 2051], [2052, 2052, 2077, 2077, 2096], [2097, 2097, 2133, 2133, 2161], [2163, 2169, 2210, 2210, 2471], [2474, 2474, 2498, 2498, 2565], [2567, 2567, 2588, 2588, 2656], [2709, 2709, 2734, 2734, 4510], [4512, 4512, 4536, 4536, 4698], [4700, 4700, 4748, 4748, 5027], [5030, 5030, 5074, 5074, 5395], [5397, 5397, 5434, 5434, 5691], [5694, 5694, 5717, 5717, 5862], [5864, 5864, 5954, 5954, 7045], [7048, 7048, 7080, 7080, 7099], [7102, 7150, 7178, 7178, 7366], [7370, 7370, 7440, 7440, 7687], [7689, 7689, 7716, 7716, 7805], [7807, 7807, 7865, 7865, 7913], [7915, 7915, 7938, 7938, 8050], [8052, 8052, 8083, 8083, 8721], [8725, 8725, 8782, 8782, 9256]]}
{"id": "Ns3yWs", "name": "CodeGarden Challenge 22 #3", "author": "larserik", "description": "CodeGarden Challenge 22 - Make the CG heart logo with whatever you want\nReflections on a beating heart edition", "tags": ["raymarching", "logo", "umbraco", "codegarden", "codegardenchallenge"], "likes": 2, "viewed": 716, "published": 3, "date": "1654211873", "time_retrieved": "2024-07-30T16:45:46.083520", "image_code": "// Ray marching code and SDF functions copied from Inigo Quilez and Martijn Steinrucken\n// The MIT License\n// Copyright © 2022 Lars-Erik Aabech\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define MAX_STEPS 50\n#define MAX_DIST 10.\n#define SURF_DIST .005\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1, d2);\n}\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\n\nfloat sdBox2( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\nfloat GetDist(vec3 p, out float col) {\n    const float hr = 0.707; // heart raduis\n    const float tr = 0.07; // torus radius\n\n    col = 1.;\n\n    float isBeat = max(0., mod(floor(iTime*1.7),3.)-1.);\n    float beat = abs(sin(iTime*TAU*1.7));\n    float scale = 1. + isBeat * beat * .2;\n\n    //float d = sdBox(p, vec3(1));\n    // Top right arc\n    vec3 p1 = p;\n    p1.x += .5 * scale;\n    p1.y -= .5 * scale;\n    p1.xy *= Rot(-0.785);\n    vec2 a = vec2(sin(1.57), cos(1.57));\n    //a = vec2(sin(3.14), cos(3.14));\n    float d1 = sdCappedTorus(p1, a, hr, tr);\n    d1 = opU(d1, sdCapsule(p1, vec3(-hr, 0., 0.), vec3(hr, 0., 0.), tr));\n    \n    // Mid right triangle\n    vec3 p2 = p;\n    p2.x += 1. * scale;\n    p2.y += (scale - 1.) * .5;\n    float d2 = sdCapsule(p2, vec3(0), vec3(1, 0, 0), tr);\n    d2 = opU(d2, sdCapsule(p2, vec3(0), vec3(1, 1, 0), tr));\n    d2 = opU(d2, sdCapsule(p2, vec3(1, 1, 0), vec3(1, 0, 0), tr));\n\n    // Bottom right triangle\n    vec3 p3 = p;\n    p3.x += 1. * scale;\n    p3.y += 0. + scale - 1.;\n    float d3 = sdCapsule(p3, vec3(0), vec3(1, 0, 0), tr);\n    d3 = opU(d3, sdCapsule(p3, vec3(0), vec3(1, -1, 0), tr));\n    d3 = opU(d3, sdCapsule(p3, vec3(1, -1, 0), vec3(1, 0, 0), tr));\n\n    float rightHalf = opU(opU(d1, d2), d3);\n    \n    // Upper left pie\n    vec3 p4 = p;\n    p4.x -= .5 * scale;\n    p4.y -= .5 * scale;\n    p4.xy *= Rot(.785);\n    float d4 = sdCappedCylinder(p4, vec3(0, 0, .001), vec3(0, 0, -.001), hr);\n    d4 = opSub(sdBox2(p4+vec3(-0,.5,0), vec3(1, .5, .5)), d4);\n    d4 = rounding(d4, tr-.005);\n\n    // Lower left triangle\n    vec3 p5 = p;\n    p5 -= vec3(scale-1.,-scale+1., 0);\n    float d5 = udTriangle(vec3(0), vec3(1, 0, 0), vec3(0, -1, 0), p5) - .001;\n    d5 = rounding(d5, tr-.006);\n\n    float leftHalf = opU(d4, d5);\n    \n    float d = min(rightHalf, leftHalf);\n    \n    if (d == d4) col = 2.;\n    if (d == d5) col = 3.;\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, out float col) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p, col);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float col;\n\tfloat d = GetDist(p, col);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, col),\n        GetDist(p-e.yxy, col),\n        GetDist(p-e.yyx, col)\n    );\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Render(inout vec3 ro, inout vec3 rd, inout float ref) {\n    // Doing weird things to move the skybox to nice starting reflection and tint.\n    // Straight skybox woud be texture(iChannel0, rd).rgb, tuned to not over expose color.\n    vec3 skybox = texture(iChannel0, vec3(rd.xz*Rot(PI*-.25), rd.y)).rbg * vec3(.3, .6, .5);\n    // background tint + slight skybox\n    vec3 col = vec3(.2, .266, .694) + skybox;\n\n    // Get distance and color, TODO: move color to vec2 return type\n    float colIndex = 0.;\n    float d = RayMarch(ro, rd, colIndex);\n\n    // Make a nice color if we hit\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        // Super basic lighting\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        \n        // Color and reflectiveness\n        if (colIndex == 1.) {\n            col = vec3(.8)*dif;\n            ref = .35;\n        }\n        else if (colIndex == 2.) {\n            col = vec3(.96, .756, .737)*dif;\n            ref = .35;\n        }\n        else if (colIndex == 3.) {\n            col = vec3(.615, .5, .341)*dif;\n            ref = .25;\n        }\n\n        // Adjust direction to reflect\n        ro = p+n*SURF_DIST*3.;\n        rd = r;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0, 3.2, 3);\n    if (iMouse.z > 0. && (m.x > 0. || m.y > 0.)) {\n        m -= .5;\n        m.y *= -1.;\n        ro.yz *= Rot(-m.y*PI+1.);\n        ro.xz *= Rot(-m.x*TAU);\n    } else {\n        ro.y = -1.4;\n        ro.xz *= Rot(iTime*.3);\n    }\n    ro = (normalize(ro)*6.);\n\n    uv.y += .03;\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 2.);\n\n    float ref = 0.;\n    vec3 col = Render(ro, rd, ref);\n    vec3 bounce = ref * Render(ro, rd, ref);\n    col += bounce;\n    \n    col = pow(col, vec3(1.3));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3yWs.jpg", "access": "api", "license": "mit", "functions": [[1314, 1314, 1333, 1333, 1395], [1397, 1397, 1422, 1422, 1441], [1442, 1442, 1467, 1467, 1486], [1488, 1488, 1521, 1521, 1544], [1546, 1546, 1581, 1581, 1603], [1605, 1605, 1634, 1634, 1715], [1717, 1717, 1759, 1759, 1779], [1781, 1781, 1813, 1813, 1900], [1902, 1902, 1972, 1972, 2106], [2108, 2108, 2160, 2160, 2281], [2283, 2283, 2340, 2340, 2676], [2678, 2678, 2745, 2745, 3397], [3399, 3399, 3437, 3437, 5289], [5291, 5291, 5340, 5340, 5556], [5558, 5558, 5582, 5582, 5812], [5814, 5814, 5864, 5864, 6055], [6057, 6057, 6117, 6291, 7328], [7330, 7330, 7387, 7387, 8057]]}
{"id": "7ddyWf", "name": "Art Room - Final Project", "author": "Charbake", "description": "This is our final project", "tags": ["art"], "likes": 5, "viewed": 272, "published": 3, "date": "1654199552", "time_retrieved": "2024-07-30T16:45:47.019017", "image_code": "//Creating the map of the whole world of SDFs\nfloat map(vec3 p, settings setts)\n{\n    return world_sdf(p, iTime, setts);\n}\n\n\n// Computing the normals\nvec3 computeNormal(vec3 p, settings setts)\n{\n    const float h = 1e-4;\n    float dist = world_sdf(p, iTime, setts);  \n    float distx = world_sdf(p+vec3(h,0.,0.), iTime, setts) - dist;\n    float disty = world_sdf(p+vec3(0.,h,0.), iTime, setts) - dist;\n    float distz = world_sdf(p+vec3(0.,0.,h), iTime, setts) - dist;\n    vec3 un_norm = vec3(distx, disty, distz);\n    return normalize(un_norm);\n}\n\n//Sphere tracing\nbool sphere_tracing(ray r,\n               \t\tint max_iter,\n               \t\tsettings setts,\n               \t\tout vec3 hit_loc,\n               \t\tout int iters)\n{\n    hit_loc = r.origin + r.direction * (-r.origin.y / r.direction.y);\n    iters = 1;\n\n    float step_size;\n    vec3 old_loc = r.origin;\n    int curr_iters = 1;\n    while (curr_iters < max_iter){\n        step_size = world_sdf(old_loc, iTime, setts);\n        vec3 curr_loc = old_loc + step_size*r.direction;\n        if (step_size < 1e-4){\n            hit_loc = curr_loc;\n            iters = curr_iters;\n            return true;\n        }\n        old_loc = curr_loc;\n        curr_iters += 1;\n    }\n    iters = max_iter;\n    return false;\n}\n\n\nvec3 shade(ray r, int iters, settings setts)\n{\n    vec3 p = r.origin;\n    vec3 d = r.direction;\n    \n    if (setts.shade_mode == GRID)\n    {\n    \tfloat res = 0.2;\n    \tfloat one = abs(mod(p.x, res) - res / 2.0);\n    \tfloat two = abs(mod(p.y, res) - res / 2.0);\n    \tfloat three = abs(mod(p.z, res) - res / 2.0);\n    \tfloat interp = min(one, min(two, three)) / res;\n        \n        return mix( vec3(0.2, 0.5, 1.0), vec3(0.1, 0.1, 0.1), smoothstep(0.0,0.05,abs(interp)) );\n    }\n    else if (setts.shade_mode == COST)\n    {\n        return vec3(float(iters) / float(cost_norm));\n    }\n    else if (setts.shade_mode == NORMAL)\n    {\n        vec3 normal = computeNormal(p, setts);\n        vec3 calc = vec3((normal.x+1.0)/2.0, (normal.y+1.0)/2.0, (normal.z+1.0)/2.0);\n        return calc;\n    }\n    else if (setts.shade_mode == DIFFUSE_POINT)\n    {\n        float r = abs(cos(iTime * 0.2));\n        float g = abs(sin(iTime * 0.2));\n        float b = abs(tan(iTime * 0.2));\n        \n        //static light source\n        vec3 light_pos = vec3(0.0, 7., -2.);\n        \n        //moving light source\n        //vec3 light_pos = vec3(r, 4. + g, b);\n     \n        vec3 light_intensity = vec3(20.0);\n        vec3 surface_color = vec3(0.0,0.8,0.9);\n        \n        //Changing color\n        //vec3 surface_color = vec3(r, g, b);\n        \n        vec3 normal = computeNormal(p, setts);\n        vec3 Li = light_intensity/dot(light_pos-p, light_pos-p);\n        vec3 color = surface_color*max(0.0, dot(normalize(light_pos-p), normalize(normal)))*Li;\n        return color;\n    }\n    else\n    {\n        return vec3(0.0);\n    }\n    \n    return vec3(0.0);\n}\n\n\nvec3 render(settings setts, vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    if (p.y < -0.95)\n    {\n        float val = cos(iTime * anim_speed);\n    }\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= aspect;\n   \n    //Static Camera\n    vec3 eye = vec3(0.0, 0.5 , -4.1);\n    \n    // RIGHT STACK\n    //vec3 eye = vec3(1.4, 0.2 , -0.9);\n    //vec3 dir = vec3(-0.9, 0.3, 1.0) - eye;\n    \n    //Rotating the camera\n    //float change = abs(1. - abs(cos(iTime*0.2)));\n    //vec3 eye = vec3(0.0, 0.5 + 5.*change, -4.0);\n    \n   // Shelf View\n    //vec3 eye = vec3(1.45, 0.75 , -2.0);\n    //vec3 dir = vec3(-1.5, 0.8, 0.) - eye;\n    \n    //Left Wall View\n    //vec3 eye = vec3(-1.49, 0.75 , -1.0);\n    //vec3 dir = vec3(1.3, 0.95, 0.) - eye;\n    \n    //vec3 eye = vec3(-1.45, 0.75 , -4.0);\n    \n    \n    vec3 dir = vec3(0.0, 0.8, 0.) - eye;\n    vec3 up = vec3(0, 1., 0);\n    \n    \n    float focal_length = 2.;\n    \n    vec3 u,v,w;\n    compute_camera_frame(dir, up, u, v, w);\n    \n    ray r;\n    switch(projection_func) {\n        case PROJECTION_ORTHOGRAPHIC:\n            r = generate_ray_orthographic(uv, eye, u, v, w);\n            break;\n     \n        case PROJECTION_PERSPECTIVE:\n            r = generate_ray_perspective(uv, eye, u, v, w, focal_length);\n            break;\n    }\n    \n    int max_iter = 1000;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 hit_loc;\n    int iters;\n    bool hit;\n    \n    if (sphere_tracing(r, max_iter, setts, hit_loc, iters))\n    {\n        r.origin = hit_loc;\n        col = shade(r, iters, setts);\n    }\n    \n\n    \n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(render(render_settings, fragCoord), 1.0);\n}", "image_inputs": [], "common_code": "// pre-defined constants\n#define EPSILON 1e-4\n#define PI 3.1415926535897932384626433832795\n\n\n// shade mode\n#define GRID 0\n#define COST 1\n#define NORMAL 2\n#define AMBIENT 3\n#define DIFFUSE_POINT 4\n#define ENVIRONMENT_MAP 5\n\n\n// Render Settings\n\nstruct settings\n{\n    int shade_mode;\n};\n\nsettings render_settings = settings(NORMAL);\n\nfloat anim_speed = 0.35;\nint cost_norm = 200;\n\nvec3 two_tone_color_a = vec3(0.6 * 1.0, 0.6 * 1.0, 0.0 * 1.0);\nvec3 two_tone_color_b = vec3(0.2 * 1.0, 0.1 * 1.0, 0.9 * 1.0);\nvec3 two_tone_dir = vec3(1.0, 1.0, 0.0);\n\n//SDFs -- All reused from previous assignments\n\n// returns the signed distance to a sphere from position p\nfloat sdSphere(vec3 p, float r)\n{\n \treturn length(p) - r;\n}\n\n// returns the signed distance to a box from position p\nfloat sdBox( vec3 p, vec3 half_bounds )\n{\n    vec3 dist = abs(p) - half_bounds;\n    float max_dist = max(dist.x,max(dist.y,dist.z));\n    float inside = min(max_dist, 0.0);\n    float outside = length(max(dist, 0.0));\n    return inside + outside;\n}\n\n// returns the signed distance to a cylinder from position p\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  b_minus_a = b - a;\n    vec3  p_minus_a = p - a;\n    float ba_ba = dot(b_minus_a,b_minus_a);\n    float pa_ba = dot(p_minus_a,b_minus_a);\n    float x = length(p_minus_a*ba_ba-b_minus_a*pa_ba) - r*ba_ba;\n    float y = abs(pa_ba-ba_ba*0.5)-ba_ba*0.5;\n    float x2 = x*x;\n    float y2_ba = y*y*ba_ba;\n    float dist = 0.0;\n    if (max(x,y)<0.0){\n        dist = -min(x2,y2_ba);\n    }\n    else{\n        if (x>0.0){\n            dist = x2;\n        }\n        if (y>0.0){\n            dist += y2_ba;\n        }\n    }\n    return sign(dist)*sqrt(abs(dist))/ba_ba;\n}\n\n// returns the signed distance to a cone from position p\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    vec3  b_minus_a = b - a;\n    vec3  p_minus_a = p - a;\n    float rb_minus_ra  = rb-ra;\n    float ba_dot = dot(b_minus_a,b_minus_a);\n    float pa_dot = dot(p_minus_a,p_minus_a);\n    float pa_ba = dot(p_minus_a,b_minus_a)/ba_dot;\n    float x = sqrt( pa_dot - pa_ba*pa_ba*ba_dot );\n    \n    float radius = 0.0;\n    if (pa_ba<0.5){\n        radius = ra;\n    }\n    else{\n        radius = rb;\n    }\n    float x_mag = max(0.0,x-radius);\n    float y_mag = abs(pa_ba-0.5)-0.5;\n    float k = rb_minus_ra*rb_minus_ra + ba_dot;\n    float f = max((rb_minus_ra*(x-ra)+pa_ba*ba_dot)/k, 0.0);\n    f = min(f,1.0);\n    float x_mag1 = x-ra - f*rb_minus_ra;\n    float y_mag1 = pa_ba - f;\n    float ori = 0.0;\n    if (x_mag1<0.0 && y_mag<0.0){\n        ori = -1.0;\n    }\n    else{\n        ori = 1.0;\n    }\n    float xx = x_mag*x_mag;\n    float yy = y_mag*y_mag;\n    float xx1 = x_mag1*x_mag1;\n    float yy1 = y_mag1*y_mag1;\n    \n    float squared = min(xx + yy*ba_dot, xx1 + yy1*ba_dot);\n    return ori*sqrt(squared);\n}\n\n//Boolean Set Operations - All reused from previous assignments\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = max(k-abs(d1-d2), 0.0);\n    float s_union = min(d1, d2) - (h*h)/(4.0*k);\n    return s_union;\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k)\n{\n    float h = max(k-abs(-d1-d2), 0.0);\n    float s_subtraction = max(-d1, d2) + (h*h)/(4.0*k);\n    return s_subtraction;\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2), 0.0);\n    float s_intersection = max(d1, d2) + (h*h)/(4.0*k);\n    return s_intersection;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  float len = length(p.xz)-t.x;\n  vec2 q = vec2(len,p.y);\n  return length(q)-t.y;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n\n\n#define PROJECTION_ORTHOGRAPHIC 0\n#define PROJECTION_PERSPECTIVE  1\n\nint projection_func = PROJECTION_PERSPECTIVE;\n\n//Ray generation\nstruct ray { \n    vec3 origin;\n    vec3 direction;\n};\n\n\n//Computing the camera frame\nvoid compute_camera_frame(vec3 dir, vec3 up, out vec3 u, out vec3 v, out vec3 w){\n    w = -dir/(sqrt(dot(dir,dir)));\n    u = (cross(up, w))/(sqrt(dot(cross(up,w),cross(up,w))));\n    v = cross(w,u);\n}\n\n//Generating an orthographic ray\nray generate_ray_orthographic(vec2 uv, vec3 e, vec3 u, vec3 v, vec3 w) {\n    return ray(e + uv.x*u + uv.y*v, -w);\n\n}\n\n//Generating a persepective ray\nray generate_ray_perspective(vec2 uv, vec3 eye, vec3 u, vec3 v, vec3 w, float focal_length) {\n    vec3 dir = -1.0*focal_length*w + uv.x*u + uv.y*v;\n    return ray(eye, dir/length(dir));\n}\n\n// returns the signed distance to an infinate plane with a specific y value\nfloat sdPlane(vec3 p, float z)\n{\n    return p.z - z;\n}\n\nfloat world_sdf(vec3 p, float time, settings setts)\n{\n    float dist = 100000.0;\n    \n    //Room itself\n    \n    dist = sdPlane(p.xzy,  -0.3); // floor\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(0.0, 0.0, 102.0), vec3(100.)), 0.001);  //back wall\n    \n    //Left pedestal -- built with cylinders, toruses, and a cone on top\n  \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(1.2,-0.25,1.7), vec2(0.2, 0.04)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(1.2,0.25,1.7), vec2(0.2, 0.04)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(1.2,0.0,1.7), vec2(0.2, 0.04)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(1.2,0.5,1.7), vec2(0.2, 0.04)), 0.01);  \n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(1.2,-0.25,1.7), vec3(-0.2,-0.25,0.), vec3(-0.2,1.1,0.), 0.04), 0.001);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(1.2,-0.25,1.7), vec3(0.2,-0.25,0.) , vec3(0.2,1.1,0.), 0.04), 0.001);\n   \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(1.2,-0.25,1.7), vec3(0.0,-0.25,0.2), vec3(0.,1.1,0.2), 0.04), 0.001);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(1.2,-0.25,1.7), vec3(0.,-0.25,-0.2) , vec3(0.0,1.1,-0.2), 0.04), 0.001);\n    \n    vec3 cone_a = vec3(0.0, 0.75, 0.0);\n    vec3 cone_b = vec3(0.0, 0.85, 0.0);\n    float cone_ra = 0.2;\n    float cone_rb = 0.3;\n    dist = opSmoothUnion(dist, sdCone(p - vec3(1.2,0.0,1.7), cone_a, cone_b, cone_ra, cone_rb), 0.01);\n    \n    \n    //Right pedestal -- built of toruses and slanted cylinders\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.3, 0.03)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.25, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.2, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.15, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.1, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,0.8,1.65), vec2(0.01, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.3, 0.03)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.25, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.2, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.15, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.1, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdTorus(p - vec3(-1.15,-.2,1.65), vec2(0.01, 0.03)), 0.1);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(0.315,0.8,0.), vec3(-0.315,-0.2,0.), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(-0.315,0.8,0.), vec3(0.315,-0.2,0.), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(0.0,0.8,0.315), vec3(0.0,-0.2,-0.315), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(0.0,0.8,-0.315), vec3(0.0,-0.2,0.315), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(0.23,0.8,0.23), vec3(-0.23,-0.2,-0.23), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(-0.23,0.8,-0.23), vec3(0.23,-0.2,0.23), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(0.23,0.8,-0.23), vec3(-.23,-0.2,0.23), 0.02), 0.01);\n   \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-1.15,0.,1.65), vec3(-0.23,0.8,0.23), vec3(0.23,-0.2,-0.23), 0.02), 0.01);\n    \n    \n    //Chandelier -- all made of cones\n    float height = 1.6;\n    float closeZ = 0.5;\n    \n    vec3 cone_a1 = vec3(0.0, -0.4, 0.0);\n    vec3 cone_b1 = vec3(0.0, -0.1, 0.0);\n    float cone_ra1 = 0.0;\n    float cone_rb1 = 0.1;\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a1, cone_b1, cone_ra1, cone_rb1), 0.1);\n    \n    vec3 cone_a2 = vec3(0.0, 0.1, 0.0);\n    vec3 cone_b2 = vec3(0.0, 0.4, 0.0);\n    float cone_ra2 = 0.1;\n    float cone_rb2 = 0.0;\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a2, cone_b2, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a3 = vec3(0.1, 0.0, 0.0);\n    vec3 cone_b3 = vec3(0.4, 0.0, 0.0);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a3, cone_b3, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a4 = vec3(-0.1, 0.0, 0.0);\n    vec3 cone_b4 = vec3(-0.4, 0.0, 0.0);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a4, cone_b4, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a5 = vec3(0.0, 0.0, 0.1);\n    vec3 cone_b5 = vec3(0.0, 0.0, 0.4);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a5, cone_b5, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a6 = vec3(0.0, 0.0, -0.1);\n    vec3 cone_b6 = vec3(0.0, 0.0, -0.4);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a6, cone_b6, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a7 = vec3(-0.25, -0.25, -0.25);\n    vec3 cone_b7 = vec3(-0.05, -0.05, -0.05);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a7, cone_b7, cone_ra1, cone_rb1), 0.1);\n    \n    vec3 cone_a8 = vec3(0.05, 0.05, 0.05);\n    vec3 cone_b8 = vec3(0.25, 0.25, 0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a8, cone_b8, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a9 = vec3(0.05, -0.05, 0.05);\n    vec3 cone_b9 = vec3(0.25, -0.25, 0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a9, cone_b9, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a10 = vec3(-0.05, 0.05, -0.05);\n    vec3 cone_b10 = vec3(-0.25, 0.25, -0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a10, cone_b10, cone_ra2, cone_rb2), 0.1);\n   \n    vec3 cone_a11 = vec3(-0.05, -0.05, 0.05);\n    vec3 cone_b11 = vec3(-0.25, -0.25, 0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a11, cone_b11, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a12 = vec3(-0.05, 0.05, 0.05);\n    vec3 cone_b12 = vec3(-0.25, 0.25, 0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a12, cone_b12, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a13 = vec3(0.05, 0.05, -0.05);\n    vec3 cone_b13 = vec3(0.25, 0.25, -0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a13, cone_b13, cone_ra2, cone_rb2), 0.1);\n    \n    vec3 cone_a14 = vec3(0.05, -0.05, -0.05);\n    vec3 cone_b14 = vec3(0.25, -0.25, -0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(0.,height,closeZ), cone_a14, cone_b14, cone_ra2, cone_rb2), 0.1);\n  \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(-0.,.5,closeZ), vec3(0.0,1.2,0.), vec3(0.,4.,0.), 0.02), 0.01);\n   \n    \n    //Painting Frame\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(-0.0,1.0+0.25,1.65), vec3(0.8, 0.5, 0.01)), 0.01);\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(-0.0,1.51+0.25,1.65), vec3(0.818, 0.02, 0.02)), 0.0002);\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(-0.0,0.49+0.25,1.65), vec3(0.818, 0.02, 0.02)), 0.0002);\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(-0.8,1.0+0.25,1.65), vec3(0.02, 0.484, 0.02)), 0.0002);\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(0.8,1.0+0.25,1.65), vec3(0.02, 0.484, 0.02)), 0.0002);\n   \n    //Painting\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.46,1.1+0.25,1.65),0.08), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.08,1.29+0.25,1.65),0.13), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.39,0.81+0.25,1.65),0.1), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.6,0.8+0.25,1.65),0.1), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.5,0.71+0.25,1.65),0.05), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.56,0.65+0.25,1.65),0.01), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.68,0.92+0.25,1.65),0.01), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.5,1.21+0.25,1.65),0.06), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.26,0.67+0.25,1.65),0.07), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.24,0.65+0.25,1.65),0.02), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.32,0.93+0.25,1.65),0.04), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.38,0.89+0.25,1.65),0.05), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.58,1.03+0.25,1.65),0.1), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.24,1.07+0.25,1.65),0.06), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.65,1.23+0.25,1.65),0.05), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.39,1.37+0.25,1.65),0.05), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.03,0.88+0.25,1.65),0.07), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(-0.22,0.89+0.25,1.65),0.07), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.16,0.91+0.25,1.65),0.02), 0.01);\n    dist = opSmoothUnion(dist, sdSphere(p - vec3(0.35,1.06+0.25,1.65),0.09), 0.01);\n    \n    //Bookshelf\n    vec3 cone_a15 = vec3(0.00, 0.00, -0.05);\n    vec3 cone_b15 = vec3(0.00, 0.00, -0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(-1.55,0.5,1.2), cone_a15, cone_b15, 0.3, 0.3), 0.01);\n    \n    vec3 cone_a16 = vec3(0.00, 0.00, -0.05);\n    vec3 cone_b16 = vec3(0.00, 0.00, -0.25);\n    dist = opSmoothUnion(dist, sdCone(p - vec3(-1.55,0.5,-0.6), cone_a16, cone_b16, 0.3, 0.3), 0.01);\n    \n    dist = opSmoothUnion(dist, sdBox(p - vec3(-1.36,0.5,0.2),vec3(0.10, 0.04, 0.9)), 0.01);\n    \n    \n    float rightWall = sdBox(p - vec3(-101.5, 0.0, 0.0), vec3(100.));  //right wall\n    \n    float inlay = sdBox(p - vec3(-1.55, 1.0, 0.15), vec3(0.075, 0.5, 0.8));\n    \n    float subtract = opSmoothSubtraction(inlay, rightWall, 0.01);\n    \n    float inlay2 = sdBox(p - vec3(-1.65,  1.0, 0.15), vec3(0.075, 0.4, 0.7));\n    \n    float subtract2 = opSmoothSubtraction(inlay2, subtract, 0.01);\n    \n    float inlay3 = sdBox(p - vec3(-1.75,  1.0, 0.15), vec3(0.075, 0.3, 0.6));\n    \n    float subtract3 = opSmoothSubtraction(inlay3, subtract2, 0.01);\n    \n    float inlay4 = sdBox(p - vec3(-1.85,  1.0, 0.15), vec3(0.075, 0.2, 0.5));\n    \n    float subtract4 = opSmoothSubtraction(inlay4, subtract3, 0.01);\n    \n    float inlay5 = sdBox(p - vec3(-1.95, 1.0, 0.15), vec3(0.075, 0.1, 0.4));\n   \n    float subtract5 = opSmoothSubtraction(inlay5, subtract4, 0.01);\n    \n    float inlay6 = sdSphere(p - vec3(-1.95, 1.0, 0.25), 0.1);\n    \n    float subtract6 = opSmoothSubtraction(inlay6, subtract5, 0.007);\n    \n    float inlay7 = sdSphere(p - vec3(-1.95, 1.0, 0.45), 0.1);\n    \n    float subtract7 = opSmoothSubtraction(inlay7, subtract6, 0.007);\n    \n    float inlay8 = sdSphere(p - vec3(-1.95, 1.0, -0.15), 0.1);\n    \n    float subtract8 = opSmoothSubtraction(inlay8, subtract7, 0.007);\n    \n    float inlay9 = sdSphere(p - vec3(-1.95, 1.0, 0.05), 0.1);\n    \n    float subtract9 = opSmoothSubtraction(inlay9, subtract8, 0.007);\n    \n    dist = opSmoothUnion(dist, subtract9, 0.001);\n    \n    //Names\n    \n    //A\n    float height2 = 0.25;\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.8,-0.2,0.0), vec3(0.62,0.2,0.0), 0.02), 0.03);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.44,-0.2,0.0), vec3(0.62,0.2,0.0), 0.02), 0.03);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.72,-0.03,0.0), vec3(0.52,-0.03,0.0), 0.02), 0.03);\n    \n    //B\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.34,-0.2,0.0), vec3(0.34,0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.34,-0.2,0.0), vec3(0.14,-0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.34,0.2,0.0), vec3(0.14,0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.34,0.,0.0), vec3(0.14,0.,0.0), 0.02), 0.02);\n   \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,-0.13,0.0), vec3(0.06,-0.07,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,0.13,0.0), vec3(0.06,0.07,0.0), 0.02), 0.02);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,-0.13,0.0), vec3(0.14,-0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,0.13,0.0), vec3(0.14,0.2,0.0), 0.02), 0.02);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,-0.07,0.0), vec3(0.14,0.0,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(.06,0.07,0.0), vec3(0.14,0.0,0.0), 0.02), 0.02);\n    \n  \n    //C\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.08,0.1,0.0), vec3(-0.08,-0.1,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.38,-0.2,0.0), vec3(-0.18,-0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.38,0.2,0.0), vec3(-0.18,0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.18,-0.2,0.0), vec3(-0.08,-0.1,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.18,0.2,0.0), vec3(-0.08,0.1,0.0), 0.02), 0.02);\n  \n    //D\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.5,-0.2,0.0), vec3(-0.5,0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.82,0.1,0.0), vec3(-0.82,-0.1,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.5,-0.2,0.0), vec3(-0.72,-0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.5,0.2,0.0), vec3(-0.72,0.2,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.72,-0.2,0.0), vec3(-0.82,-0.1,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-.72,0.2,0.0), vec3(-0.82,0.1,0.0), 0.02), 0.02);\n    \n    //Connectors\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.62,-0.32,0.0), vec3(-0.25,-0.32,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.62,-0.32,0.0), vec3(0.62,-0.25,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-0.25,-0.32,0.0), vec3(-0.25,-0.25,0.0), 0.02), 0.02);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.22,0.32,0.0), vec3(-0.25,0.32,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.22,0.32,0.0), vec3(0.22,0.25,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-0.25,0.32,0.0), vec3(-0.25,0.25,0.0), 0.02), 0.02);\n    \n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.62,0.4,0.0), vec3(-0.62,0.4,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(0.62,0.4,0.0), vec3(0.62,0.25,0.0), 0.02), 0.02);\n    dist = opSmoothUnion(dist, sdCylinder(p - vec3(0.0,height2,1.65), vec3(-0.62,0.4,0.0), vec3(-0.62,0.25,0.0), 0.02), 0.02);\n    \n    //Left tower\n    dist = opSmoothUnion(dist, sdBox(p - vec3(1.2,1.02,1.7), vec3(0.169)), 0.001);\n    dist = opSmoothUnion(dist, sdBox(p - vec3(1.07,1.335,1.54), vec3(0.145)), 0.001);\n    dist = opSmoothUnion(dist, sdBox(p - vec3(1.27,1.64,1.74), vec3(0.14)), 0.001);\n    dist = opSmoothUnion(dist, sdBox(p - vec3(1.1,1.88,1.74), vec3(0.1)), 0.001);\n    dist = opSmoothUnion(dist, sdBox(p - vec3(1.2,2.135,1.74), vec3(0.15)), 0.001);\n    \n    //right tower\n    float sphere1 = sdSphere(p-vec3(-0.95,1.1,1.57),0.32);\n    float sphere2 = sdSphere(p-vec3(-1.3,1.1,1.57),0.32);\n    float intersect1 = opSmoothIntersection(sphere1, sphere2, 0.01);\n    dist = opSmoothUnion(dist, intersect1, 0.001);\n    \n    float sphere3 = sdSphere(p-vec3(-0.95,1.562,1.57),0.27);\n    float sphere4 = sdSphere(p-vec3(-1.3,1.562,1.57),0.27);\n    float intersect2 = opSmoothIntersection(sphere3, sphere4, 0.01);\n    dist = opSmoothUnion(dist, intersect2, 0.001);\n    \n    float sphere5 = sdSphere(p-vec3(-0.95,1.91,1.57),0.23);\n    float sphere6 = sdSphere(p-vec3(-1.3,1.91,1.57),0.23);\n    float intersect3 = opSmoothIntersection(sphere5, sphere6, 0.01);\n    dist = opSmoothUnion(dist, intersect3, 0.001);\n    \n    //left wall\n    float leftwall = opSmoothUnion(dist, sdBox(p - vec3(101.5, 0.0, 0.0), vec3(100.)), 0.001);   //left wall  -- right wall is with book shelf\n    float sphere7 = sdSphere(p - vec3(2.55,1.0,0.3),1.3);\n    float box = sdBox(p - vec3(1.5,1.0,0.3),vec3(0.3));\n    \n    float intersect4 = opSmoothSubtraction(box,sphere7, 0.01);\n    float intersect5 = opSmoothSubtraction(box, leftwall, 0.01);\n    float dist2 = opSmoothUnion(intersect5, intersect4, 0.01);\n    \n    dist = opSmoothUnion(dist, dist2, 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(p - vec3(1.6,1.0,0.3),0.29), 0.01);\n    \n    return dist; \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddyWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 81, 81, 122], [125, 150, 194, 194, 547], [549, 566, 725, 725, 1262], [1265, 1265, 1311, 1311, 2899], [2902, 2902, 2947, 2947, 4582], [4584, 4584, 4639, 4639, 4704]]}
{"id": "NdtyW4", "name": "Game of Life Computes Pi", "author": "BlackSquare", "description": "Looks best in fullscreen (press space to reset) on high-resolution displays (> 1080p)\n\nControls:\n     [W, A, S, D, mouse drag] - camera move\n     [UP, DOWN, top-right screen corner] - camera zoom \n     [SPACE, botom-right screen reset] - reset", "tags": ["2d", "zoom", "camera", "compression", "gameoflife", "mobile"], "likes": 5, "viewed": 359, "published": 3, "date": "1654198566", "time_retrieved": "2024-07-30T16:45:48.135034", "image_code": "/* \n    Title:  Game of Life Computes Pi\n    Author: Dmitrii Shesterkin\n\n    Description:\n        Demonstrates Conway’s Game of Life with a pattern that geometrically \n        computes a value related to Pi.\n\n        \"An arrangement of four breeders that produce Gosper glider guns that \n        fire at each other so as to invert each others’ streams\"\n\n        Looks best in fullscreen (press space to reset) on high-resolution \n        displays (> 1080p)\n\n    Controls:\n        [W, A, S, D, mouse drag] - camera move\n        [UP, DOWN, top-right screen corner] - camera zoom\n        [SPACE, botom-right screen corner] - reset\n\n    Features:\n        * Initialized with an interesting Game Of Life pattern\n        * Mobile-friendly: 60FPS on 2016's Android phone (Mali-G71 MP8)\n        * Implements data compression to overcome constant values limit \n          (it is especially low on mobiles)\n        * Relatively efficient branchless code\n        * SDF rendering of the cells\n        \n    History and tools:\n        https://github.com/black-square/GameOfLife\n\n    The pattern source:\n        \"FIGURE 6.43: LIFE COMPUTES PI\" \"A pattern with population in \n        generation t equal to approximately (pi-2)t^2/720\"\n        from \"Nathaniel Johnston and Dave Greene - \"Conway’s Game of Life: \n        Mathematics and Construction\" \n\n        https://conwaylife.com/book/periodic_circuitry\n*/\n\nvec3 colorize(in vec2 uv )\n{   \n    //Time varying pixel color from the default shadertoy shader \n    return 0.8 + 0.2 * cos(iTime + uv.xyx + vec3(0,2,4) );\n}\n\nfloat drawCircle( in vec2 pos, in vec2 center, in float radius, in float eps )\n{\n    //Efficient circle rendering without sqrt\n    vec2 delta = pos - center;\n    float distSquared = dot(delta, delta);\n\t \n    vec2 border = vec2( radius - eps, radius + eps );\n    \n    border *= border;\n    \n    return 1.0 - smoothstep(border.x, border.y, distSquared);\n}\n\nfloat DrawRing( in vec2 pos, in vec2 center, in float radius, in float aspectRatio, in float eps )\n{\n    float res = 1.0;\n    \n    //We use negative values to simplify alignment to the right or the bottom border\n    center = wrap( center, vec2(1.0, aspectRatio) );\n    \n    res *= drawCircle(pos, center, radius, eps);\n    res *= 1.0 - drawCircle(pos, center, radius * 0.75, eps);\n    \n    return res;\n}\n\nfloat drawUi( in vec2 uiPos, in float eps, in float aspectRatio )\n{\n    float res = 1.0;\n    \n    // A OR B = 1 - (1 - A) * (1 - B)\n    res *= 1.0 - DrawRing(uiPos, btnZoomInPos, btnRadius, aspectRatio, eps);\n    res *= 1.0 - DrawRing(uiPos, btnZoomOutPos, btnRadius, aspectRatio, eps);\n    res *= 1.0 - DrawRing(uiPos, btnResetPos, btnRadius, aspectRatio, eps);\n    \n    return 1.0 - res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    //Inverse of Y axis\n    fragCoord.y = iResolution.y - fragCoord.y;\n    \n    //Following multiplications could be faster than division\n    vec2 invRes = 1.0 / iResolution.xy;\n    \n    //Read camera info. It's the same for all texels \n    vec4 buff0 = texture(iChannel0, fragColor.xy * invRes);\n    float camZoom = buff0.w;\n    vec2 camPan = buff0.yz;\n    \n    //Camera formula. solve([xy / camZoom + camPan = screenPos], [xy])\n    vec2 uv = (fragCoord.xy - camPan) * camZoom;\n    \n    //Texture lookup by the cell center eliminates borders \n    //artifacts at the very close zoom\n    vec2 cellCenter = floor(uv) + vec2(0.5);\n    float val = texture(iChannel0, cellCenter * invRes).x;\n   \n    //The SDF border smoothness in screen pixels\n    float eps = 1.0;\n    \n    //Render the cell as a circle in the world's (grid) space   \n    val *= drawCircle( uv, cellCenter, 0.5, eps * camZoom);\n    \n    //Render UI in the screen space\n    vec2 uiPos = fragCoord * invRes.x;\n    float epsScreen = eps * invRes.x;\n    float uiVal = drawUi(uiPos, epsScreen, invRes.x * iResolution.y);\n    \n    vec3 res = mix( colorize(fragCoord * invRes) * val, vec3(1.0), 0.5 * uiVal );\n    \n    fragColor = vec4(res, 1.0); \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 wrap( in vec2 uv, in vec2 resolution )\n{\n    return mod(uv, resolution);\n}\n\nivec2 wrap( in ivec2 uv, in vec2 resolution )\n{\n    return ivec2( wrap(vec2(uv), resolution) );\n}\n\n//UI Elements\nconst float btnRadius = 0.025;\nconst vec2 btnZoomInPos = vec2(-btnRadius, btnRadius);\nconst vec2 btnZoomOutPos = vec2(-btnRadius, 3.0 * btnRadius);\nconst vec2 btnResetPos = vec2(-btnRadius, -btnRadius);\n\n\n#define COMPRESSED_BITMAP_NODES \\\n0x00000000u, 0x00400100u, 0x00000020u, 0x03800E00u, 0x00000080u, 0x1A086800u, 0x7071C000u, 0xC1630000u, 0x20000000u, \\\n0x80000000u, 0x00000383u, 0x00000904u, 0x00002090u, 0x00008380u, 0x00010000u, 0x00000100u, 0x00000E00u, 0x00002C00u, \\\n0x00007000u, 0x00000400u, 0x00018000u, 0x00003800u, 0x0000B082u, 0x0001C71Cu, 0x00063458u, 0x30000000u, 0x0000E0E0u, \\\n0x02018301u, 0x0C000001u, 0x08010000u, 0x200E0000u, 0x00441800u, 0x0110C000u, 0x00E00000u, 0x00008038u, 0x02400000u, \\\n0x00000090u, 0x00000040u, 0x08000000u, 0x00000207u, 0x80000824u, 0x40000200u, 0x00001088u, 0x00000002u, 0x70000000u, \\\n0x00001C00u, 0x000001E0u, 0x00000008u, 0x60000000u, 0x00005841u, 0x0000E383u, 0x0003190Cu, 0x00006C00u, 0x00000380u, \\\n0x00013800u, 0x00000B00u, 0x0002C000u, 0x00020000u, 0x00006000u, 0x1C880000u, 0x91400000u, 0x18000000u, 0x00002000u, \\\n0x42000000u, 0x0001C000u, 0x00000001u, 0x000D0000u, 0x00010408u, 0x00380000u, 0x000E3800u, 0x00E00E07u, 0x0068B000u, \\\n0x01802422u, 0x01C1C000u, 0x00008104u, 0x03060000u, 0x00020200u, 0x00040780u, 0x40000000u, 0x02000003u, 0x1C00000Eu, \\\n0x00300000u, 0x88000018u, 0x00A0001Cu, 0x0180304Au, 0x00014101u, 0x00000036u, 0x00060404u, 0x20018000u, 0x00000AA0u, \\\n0xC0050000u, 0x0000E001u, 0x00048005u, 0x00001004u, 0x00000004u, 0x00020E0Eu, 0x0000E060u, 0x00000030u, 0x10000000u, \\\n0x00083038u, 0x0406C0C0u, 0xC0000000u, 0x002000E0u, 0x301B0000u, 0x00800302u, 0x80280000u, 0x04000000u, 0x00400000u, \\\n0x00000800u, 0x00014000u, 0xA0000000u, 0x70E00000u, 0x44800000u, 0x00000003u, 0x02000000u, 0x0000000Eu, 0x00000018u, \\\n0x00004000u, 0x00008000u, 0x00220000u, 0x1C000000u, 0x0078003Cu, 0x90000000u, 0x00000110u, 0x00000200u, 0x03000000u, \\\n0x0C020000u, 0x00000A00u, 0x30040000u, 0x00001804u, 0x58100000u, 0x00000038u, 0xF0C00000u, 0x00000181u, 0x84000000u, \\\n0x00400063u, 0x05000000u, 0x00900000u, 0x0C000000u, 0x00000183u, 0x00001B11u, 0x80000020u, 0xF8007804u, 0x00000281u, \\\n0x2000C020u, 0x00000608u, 0x40000003u, 0x1E000000u, 0x80000076u, 0x88000000u, 0x000F01F0u, 0x0000000Bu, 0x007E0380u, \\\n0x0000001Cu, 0x00001FC9u, 0x01EC0000u, 0x00000060u, 0x00009D80u, 0x00600000u, 0x0001FC90u, 0x00002020u, 0x00000880u, \\\n0x00001E00u, 0xD8000000u, 0xC00000C0u, 0x0000000Fu, 0x00000780u, 0x0000001Eu, 0x0000183Cu, 0x03600000u, 0x0F000000u, \\\n0x2000C000u, 0x4006C000u, 0x30000004u, 0x00090000u, 0x60000011u, 0x00240000u, 0x00000044u, 0x000000A3u, 0x00000104u, \\\n0x00002200u, 0x10018000u, 0x28008001u, 0xC00F0000u, 0xC0010003u, 0x00360000u, 0x00440000u, 0x00300018u, 0x00F00000u, \\\n0x000001B0u, 0x00000C00u, 0x0000000Au, 0x00000088u, 0x00006020u, 0x00C40000u, 0x0003C900u, 0x0E180000u, 0x00118000u, \\\n0x48300000u, 0x00050000u, 0x003C9000u, 0x01800000u, 0x000C0001u, 0x00602018u, 0x00200006u, 0x000883B0u, 0x001E0F80u, \\\n0x000C0000u, 0x00780040u, 0x01B00081u, 0xC180221Bu, 0x80007878u\n\n#define COMPRESSED_BITMAP_INDEX \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x02010000u, 0x03000000u, 0x00000004u, 0x00000005u, 0x00000600u, 0x00070000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00080000u, 0x09000000u, 0x0000000Au, 0x00000B00u, 0x000C0000u, \\\n0x0D000000u, 0x00000000u, 0x0000000Eu, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0000000Fu, 0x00001000u, \\\n0x00110000u, 0x12000000u, 0x00000013u, 0x00001514u, 0x00160000u, 0x17000000u, 0x00000000u, 0x00000018u, 0x00001A19u, \\\n0x001B0900u, 0x1C000000u, 0x00000000u, 0x0000001Du, 0x00001E00u, 0x001F0000u, 0x20000000u, 0x21000000u, 0x00000022u, \\\n0x00252423u, 0x0F272600u, 0x28080000u, 0x29260013u, 0x2C002B2Au, 0x002F2E2Du, 0x000F3130u, 0x00320900u, 0x33000000u, \\\n0x00000025u, 0x00003534u, 0x00373600u, 0x2D380000u, 0x39000000u, 0x0000003Au, 0x0000003Bu, 0x3E3D3C00u, 0x083F0000u, \\\n0x00000040u, 0x00004241u, 0x00444300u, 0x46450000u, 0x47000000u, 0x00000048u, 0x00004A49u, 0x004C4B26u, 0x4D002C00u, \\\n0x4F4E0000u, 0x00000000u, 0x00510050u, 0x532C5200u, 0x4E000000u, 0x00000054u, 0x00005500u, 0x0057563Eu, 0x59025800u, \\\n0x5B5A0000u, 0x09000000u, 0x005E5D5Cu, 0x61605F00u, 0x64636200u, 0x66650004u, 0x09000067u, 0x00006968u, 0x006B6A00u, \\\n0x00000000u, 0x6C000000u, 0x00000000u, 0x0000003Au, 0x00006D00u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0000006Au, \\\n0x00001900u, 0x006E0000u, 0x00000000u, 0x00000000u, 0x00002600u, 0x006F0000u, 0x70000000u, 0x00000071u, 0x00007372u, \\\n0x00742600u, 0x004E0000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00007500u, 0x00760000u, 0x77000000u, \\\n0x00000078u, 0x00007A79u, 0x004E7B00u, 0x00250000u, 0x7C000041u, 0x00005E00u, 0x00020000u, 0x00047D00u, 0x7F7E0000u, \\\n0x80000000u, 0x00000081u, 0x00008382u, 0x00858400u, 0x87860000u, 0x65000044u, 0x00008988u, 0x00728A00u, 0x26000000u, \\\n0x8B650000u, 0x00000008u, 0x00008D8Cu, 0x418F8E00u, 0x91900000u, 0x09000000u, 0x00000000u, 0x00005E00u, 0x92000000u, \\\n0x00930000u, 0x95007194u, 0x00979600u, 0x99980208u, 0x9B9A0000u, 0x9D00009Cu, 0x0000009Eu, 0x0000009Fu, 0x0000A000u, \\\n0x00A10000u, 0xA2000000u, 0x00000000u, 0x00000000u, 0x00008A00u, 0x71A30000u, 0xA4080000u, 0x4E0000A5u, 0x0000A7A6u, \\\n0x00518C00u, 0xA9A80000u, 0x00000000u, 0x000000AAu, 0x00003D00u, 0x00006200u, 0x41AB0000u, 0xAC000000u, 0x000000ADu, \\\n0x0071AFAEu, 0xA5B1B000u, 0xB29E0000u, 0x00000074u, 0x00A600B3u, 0xB4000000u, 0x00007200u, 0x006A006Cu, 0xB5007500u, \\\n0x000000B6u, 0x0000B8B7u, 0x41BAB900u, 0xBCBB0000u, 0xBD000000u, 0x00000000u, 0x000000A6u, 0xA7BFBE00u, 0x74000000u, \\\n0x000000C0u, 0x0000C125u, 0x00C300C2u, 0xC500C400u, 0xC7C60000u, 0xC90000C8u, 0x0000CBCAu, 0x00CDCC00u, 0xCE000000u, \\\n0xCF000000u, 0x0000002Du, 0x000000D0u, 0x0000D109u, 0x00D20000u, 0xD3000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u\n\n#define BITMAP \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00400100u, 0x00000020u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x03800E00u, 0x00000080u, 0x00000000u, 0x00000000u, 0x00000000u, 0x1A086800u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x7071C000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0xC1630000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x20000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x80000000u, 0x00000383u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000904u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00002090u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00008380u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00010000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000100u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000E00u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00002C00u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00007000u, 0x00000400u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00018000u, 0x00003800u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x0000B082u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0001C71Cu, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00063458u, 0x00000000u, 0x00000000u, 0x00000000u, 0x30000000u, 0x0000E0E0u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x80000000u, 0x02018301u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0C000001u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x08010000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x200E0000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00441800u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x0110C000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00E00000u, 0x00008038u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x02400000u, 0x00000090u, 0x00000040u, 0x00000000u, 0x00000000u, 0x08000000u, 0x00000207u, 0x00000100u, 0x00000000u, \\\n0x00000000u, 0x20000000u, 0x80000824u, 0x00000400u, 0x00000000u, 0x08000000u, 0x40000200u, 0x00001088u, 0x00000002u, \\\n0x00000000u, 0x70000000u, 0x00001C00u, 0x000001E0u, 0x00000008u, 0x00000000u, 0x60000000u, 0x00005841u, 0x00000100u, \\\n0x00000000u, 0x00000000u, 0x80000000u, 0x0000E383u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0003190Cu, \\\n0x00000040u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00006C00u, 0x00000380u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00013800u, 0x00000B00u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0002C000u, 0x00001C00u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00020000u, 0x00006000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x1C880000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x91400000u, 0x18000000u, 0x00002000u, 0x00000000u, 0x00000000u, 0x42000000u, 0x20000000u, \\\n0x0001C000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000001u, 0x000D0000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00010408u, 0x00380000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x000E3800u, 0x00E00E07u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x0068B000u, 0x01802422u, 0x00000000u, 0x00000000u, 0x00000000u, 0x01C1C000u, 0x00008104u, 0x00000000u, \\\n0x00000000u, 0x08000000u, 0x03060000u, 0x00020200u, 0x00000000u, 0x00000000u, 0x70000000u, 0x00000000u, 0x00040780u, \\\n0x00000000u, 0x00000000u, 0x40000000u, 0x02000003u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x1C00000Eu, \\\n0x00000000u, 0x00300000u, 0x00000000u, 0x00000000u, 0x88000018u, 0x70000000u, 0x00A0001Cu, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x40000000u, 0x0180304Au, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00014101u, 0x00000000u, \\\n0x00000000u, 0x00002000u, 0x00000036u, 0x00060404u, 0x00000000u, 0x00000000u, 0x20018000u, 0x00000020u, 0x00000AA0u, \\\n0x00000000u, 0x00000000u, 0xC0050000u, 0x0000E001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x80000000u, 0x00048005u, \\\n0x00001004u, 0x00000004u, 0x00000000u, 0x00000000u, 0x00020E0Eu, 0x0000E060u, 0x00000030u, 0x00000000u, 0x10000000u, \\\n0x00083038u, 0x0406C0C0u, 0x00000080u, 0x00000000u, 0xC0000000u, 0x002000E0u, 0x301B0000u, 0x00000000u, 0x00000000u, \\\n0x80000000u, 0x00800302u, 0x80280000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x04000000u, 0x00400000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000800u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00006000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00014000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x04000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x30000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0xA0000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x08000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x70E00000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x44800000u, 0x00000003u, 0x00000000u, 0x00000000u, 0x00000000u, 0x02000000u, 0x0000000Eu, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x08000000u, 0x00000018u, 0x00000000u, 0x00000000u, 0x00000000u, 0x40000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00004000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00008000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00220000u, \\\n0x1C000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0078003Cu, 0x90000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000110u, 0x40000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000040u, 0x00000000u, 0x00000001u, 0x00000000u, \\\n0x00000000u, 0x00000200u, 0x00000000u, 0x00000004u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000020u, \\\n0x00000000u, 0x00000000u, 0x03000000u, 0x00000080u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0C020000u, 0x00000A00u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x30040000u, 0x00001804u, 0x00000000u, 0x00000000u, 0x00000000u, 0x58100000u, \\\n0x00000038u, 0x00000000u, 0x00000000u, 0x00000000u, 0xF0C00000u, 0x00000181u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x84000000u, 0x00400063u, 0x00380000u, 0x00000000u, 0x00000000u, 0xC0000000u, 0x05000000u, 0x00900000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x0C000000u, 0x02000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x08000000u, \\\n0x00000000u, 0x00000000u, 0xC0000000u, 0x00000183u, 0x20000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00001B11u, \\\n0x80000020u, 0x00000000u, 0x00000000u, 0x00000000u, 0xF8007804u, 0x00000281u, 0x00000001u, 0x00000000u, 0x00000000u, \\\n0x2000C020u, 0x00000608u, 0x00000000u, 0x00000000u, 0x00000000u, 0x80000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000004u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x40000003u, \\\n0x00000000u, 0x00000000u, 0x1E000000u, 0x00000000u, 0x80000076u, 0x00000003u, 0x00000000u, 0x88000000u, 0x00000000u, \\\n0x000F01F0u, 0x0000000Bu, 0x00000000u, 0x20000000u, 0x00000020u, 0x007E0380u, 0x0000001Cu, 0x00000000u, 0x00000000u, \\\n0x00001FC9u, 0x01EC0000u, 0x00000060u, 0x00000000u, 0x00000000u, 0x00009D80u, 0x00600000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x0001FC90u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00002020u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000880u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00001E00u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0C000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0xD8000000u, 0x00000003u, 0x00000000u, 0x00000000u, 0x20000000u, \\\n0xC00000C0u, 0x0000000Fu, 0x00000000u, 0x00000000u, 0x40000000u, 0x00000780u, 0x0000001Eu, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00001B11u, 0x00300000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x0000183Cu, 0x03600000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x0F000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x18000000u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x10000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x2000C000u, \\\n0x00000001u, 0x00000000u, 0x00000000u, 0x00000000u, 0x4006C000u, 0x30000004u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00090000u, 0x60000011u, 0x00000003u, 0x00000000u, 0x00000000u, 0x00240000u, 0x00000044u, 0x0000000Fu, 0x00000000u, \\\n0x00000000u, 0x00600000u, 0x000000A3u, 0x00000018u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000104u, 0x00000000u, \\\n0x00000780u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00002200u, 0x00000000u, 0x02000000u, 0x00000000u, \\\n0x00000000u, 0x00000800u, 0x00000000u, 0x04000000u, 0x00000000u, 0x00000000u, 0x00004000u, 0x00000000u, 0x10018000u, \\\n0x28008001u, 0x00000000u, 0x00000000u, 0x00000000u, 0xC00F0000u, 0xC0010003u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00360000u, 0x00440000u, 0x00000001u, 0x00000000u, 0x00000000u, 0x00300018u, 0x00F00000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x000001B0u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000780u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00000C00u, 0x0000000Au, 0x0000001Eu, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000018u, \\\n0x00000088u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000040u, 0x00006020u, 0x00000000u, 0x00000000u, 0x00C40000u, \\\n0x00000000u, 0x0003C900u, 0x00000000u, 0x00000000u, 0x0E180000u, 0x00000000u, 0x00118000u, 0x00000000u, 0x00000000u, \\\n0x48300000u, 0x00050000u, 0x003C9000u, 0x00000000u, 0x00000000u, 0x01800000u, 0x000C0001u, 0x00602018u, 0x00000000u, \\\n0x00000000u, 0x00000000u, 0x00200006u, 0x000883B0u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x001E0F80u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x000C0000u, 0x00001C00u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00780040u, \\\n0x00000000u, 0x00000000u, 0x00000000u, 0x80000000u, 0x01B00081u, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0xC180221Bu, 0x00000000u, 0x00000000u, 0x00000000u, 0x00000000u, 0x80007878u, 0x00000000u, 0x00000000u, 0x00000000u, \\\n0x00000000u, 0x00000000u\n\n\n\n#define ACTIVE_CELLS0 \\\nivec2(132,  2), ivec2(146,  2), ivec2(161,  2), ivec2(131,  3), ivec2(132,  3), ivec2(133,  3), ivec2(145,  3), \\\nivec2(146,  3), ivec2(147,  3), ivec2(161,  3), ivec2(131,  4), ivec2(133,  4), ivec2(134,  4), ivec2(139,  4), \\\nivec2(145,  4), ivec2(147,  4), ivec2(148,  4), ivec2(132,  5), ivec2(133,  5), ivec2(134,  5), ivec2(138,  5), \\\nivec2(139,  5), ivec2(140,  5), ivec2(146,  5), ivec2(147,  5), ivec2(148,  5), ivec2(132,  6), ivec2(133,  6), \\\nivec2(137,  6), ivec2(138,  6), ivec2(140,  6), ivec2(146,  6), ivec2(147,  6), ivec2(137, 10), ivec2(137, 11), \\\nivec2(138, 11), ivec2(139, 11), ivec2(145, 11), ivec2(146, 11), ivec2(147, 11), ivec2(138, 12), ivec2(144, 12), \\\nivec2(147, 12), ivec2(138, 13), ivec2(141, 13), ivec2(147, 13), ivec2(139, 14), ivec2(140, 14), ivec2(141, 14), \\\nivec2(147, 14), ivec2(146, 15), ivec2(130, 19), ivec2(129, 20), ivec2(130, 20), ivec2(131, 20), ivec2(128, 21), \\\nivec2(129, 21), ivec2(131, 21), ivec2(128, 22), ivec2(129, 22), ivec2(130, 22), ivec2(158, 22), ivec2(129, 23), \\\nivec2(130, 23), ivec2(157, 23), ivec2(158, 23), ivec2(159, 23), ivec2(145, 24), ivec2(151, 24), ivec2(156, 24), \\\nivec2(157, 24), ivec2(159, 24), ivec2(144, 25), ivec2(145, 25), ivec2(146, 25), ivec2(150, 25), ivec2(151, 25), \\\nivec2(152, 25), ivec2(156, 25), ivec2(157, 25), ivec2(158, 25), ivec2(143, 26), ivec2(144, 26), ivec2(146, 26), \\\nivec2(150, 26), ivec2(152, 26), ivec2(153, 26), ivec2(157, 26), ivec2(158, 26), ivec2(134, 27), ivec2(135, 27), \\\nivec2(143, 27), ivec2(144, 27), ivec2(145, 27), ivec2(151, 27), ivec2(152, 27), ivec2(153, 27), ivec2(135, 28), \\\nivec2(136, 28), ivec2(144, 28), ivec2(145, 28), ivec2(151, 28), ivec2(152, 28), ivec2(161, 28), ivec2(134, 29), \\\nivec2(160, 29), ivec2(161, 29), ivec2(148, 30), ivec2(159, 30), ivec2(147, 31), ivec2(148, 31), ivec2(149, 31), \\\nivec2(159, 31), ivec2(139, 32), ivec2(140, 32), ivec2(146, 32), ivec2(150, 32), ivec2(140, 33), ivec2(141, 33), \\\nivec2(146, 33), ivec2(150, 33), ivec2(113, 34), ivec2(114, 34), ivec2(115, 34), ivec2(127, 34), ivec2(128, 34), \\\nivec2(129, 34), ivec2(139, 34), ivec2(112, 35), ivec2(115, 35), ivec2(126, 35), ivec2(129, 35), ivec2(160, 35), \\\nivec2(115, 36), ivec2(120, 36), ivec2(121, 36), ivec2(122, 36), ivec2(129, 36), ivec2(160, 36), ivec2(115, 37), \\\nivec2(120, 37), ivec2(123, 37), ivec2(129, 37), ivec2(149, 37), ivec2(160, 37), ivec2( 79, 38), ivec2( 93, 38), \\\nivec2(114, 38), ivec2(119, 38), ivec2(123, 38), ivec2(128, 38), ivec2(149, 38), ivec2( 78, 39), ivec2( 79, 39), \\\nivec2( 80, 39), ivec2( 92, 39), ivec2( 93, 39), ivec2( 94, 39), ivec2(119, 39), ivec2(120, 39), ivec2(121, 39), \\\nivec2(122, 39), ivec2(149, 39), ivec2( 77, 40), ivec2( 78, 40), ivec2( 80, 40), ivec2( 86, 40), ivec2( 91, 40), \\\nivec2( 92, 40), ivec2( 94, 40), ivec2(120, 40), ivec2( 77, 41), ivec2( 78, 41), ivec2( 79, 41), ivec2( 85, 41), \\\nivec2( 86, 41), ivec2( 87, 41), ivec2( 91, 41), ivec2( 92, 41), ivec2( 93, 41), ivec2( 78, 42), ivec2( 79, 42), \\\nivec2( 84, 42), ivec2( 87, 42), ivec2( 88, 42), ivec2( 92, 42), ivec2( 93, 42), ivec2(114, 42), ivec2( 84, 43), \\\nivec2( 85, 43), ivec2( 87, 43), ivec2( 88, 43), ivec2(113, 43), ivec2(114, 43), ivec2(115, 43), ivec2( 83, 44), \\\nivec2( 84, 44), ivec2( 85, 44), ivec2( 88, 44), ivec2(112, 44), ivec2(113, 44), ivec2(115, 44), ivec2( 84, 45), \\\nivec2( 85, 45), ivec2( 87, 45), ivec2(112, 45), ivec2(113, 45), ivec2(114, 45), ivec2( 85, 46), ivec2(113, 46), \\\nivec2(114, 46), ivec2( 85, 47), ivec2( 89, 47), ivec2( 92, 47), ivec2( 93, 47), ivec2( 94, 47), ivec2( 86, 48), \\\nivec2( 88, 48), ivec2( 92, 48), ivec2( 95, 48), ivec2(123, 48), ivec2(124, 48), ivec2(141, 48), ivec2( 87, 49), \\\nivec2( 92, 49), ivec2(123, 49), ivec2(140, 49), ivec2(141, 49), ivec2(142, 49), ivec2( 92, 50), ivec2(140, 50), \\\nivec2(142, 50), ivec2(143, 50), ivec2( 93, 51), ivec2(100, 51), ivec2(106, 51), ivec2(141, 51), ivec2(142, 51), \\\nivec2(143, 51), ivec2( 99, 52), ivec2(100, 52), ivec2(101, 52), ivec2(105, 52), ivec2(106, 52), ivec2(107, 52), \\\nivec2(120, 52), ivec2(121, 52), ivec2(122, 52), ivec2(129, 52), ivec2(130, 52), ivec2(131, 52), ivec2(141, 52), \\\nivec2(142, 52), ivec2(143, 52), ivec2( 98, 53), ivec2( 99, 53), ivec2(101, 53), ivec2(105, 53), ivec2(107, 53), \\\nivec2(108, 53), ivec2(119, 53), ivec2(123, 53), ivec2(128, 53), ivec2(131, 53), ivec2(141, 53), ivec2(142, 53), \\\nivec2( 98, 54), ivec2( 99, 54), ivec2(100, 54), ivec2(106, 54), ivec2(107, 54), ivec2(108, 54), ivec2(118, 54), \\\nivec2(124, 54), ivec2(131, 54), ivec2( 77, 55), ivec2( 99, 55), ivec2(100, 55), ivec2(106, 55), ivec2(107, 55), \\\nivec2(123, 55), ivec2(131, 55), ivec2( 76, 56), ivec2( 77, 56), ivec2( 78, 56), ivec2(119, 56), ivec2(120, 56), \\\nivec2(121, 56), ivec2(122, 56), ivec2(130, 56), ivec2( 76, 57), ivec2( 78, 57), ivec2( 79, 57), ivec2(103, 57), \\\nivec2( 77, 58), ivec2( 78, 58), ivec2( 79, 58), ivec2(102, 58), ivec2(103, 58), ivec2(104, 58), ivec2(160, 58), \\\nivec2(161, 58), ivec2( 77, 59), ivec2( 78, 59), ivec2(101, 59), ivec2(105, 59), ivec2(134, 59), ivec2(135, 59), \\\nivec2(136, 59), ivec2(140, 59), ivec2(141, 59), ivec2(142, 59), ivec2(159, 59), ivec2(161, 59), ivec2(134, 60), \\\nivec2(137, 60), ivec2(139, 60), ivec2(142, 60), ivec2(148, 60), ivec2(149, 60), ivec2(159, 60), ivec2(160, 60), \\\nivec2(134, 61), ivec2(142, 61), ivec2(148, 61), ivec2(150, 61), ivec2( 81, 62), ivec2(101, 62), ivec2(102, 62), \\\nivec2(104, 62), ivec2(105, 62), ivec2(134, 62), ivec2(142, 62), ivec2(149, 62), ivec2(150, 62), ivec2( 81, 63), \\\nivec2( 82, 63), ivec2( 95, 63), ivec2(103, 63), ivec2(135, 63), ivec2(137, 63), ivec2(139, 63), ivec2(141, 63), \\\nivec2( 80, 64), ivec2( 82, 64), ivec2( 94, 64), ivec2( 95, 64), ivec2( 96, 64), ivec2(109, 64), ivec2(110, 64), \\\nivec2(111, 64), ivec2( 93, 65), ivec2( 94, 65), ivec2( 96, 65), ivec2(109, 65), ivec2(112, 65), ivec2(128, 65), \\\nivec2(138, 65), ivec2(160, 65), ivec2( 93, 66), ivec2( 94, 66), ivec2( 95, 66), ivec2(101, 66), ivec2(102, 66), \\\nivec2(103, 66), ivec2(109, 66), ivec2(129, 66), ivec2(130, 66), ivec2(137, 66), ivec2(138, 66), ivec2(139, 66), \\\nivec2(160, 66), ivec2(161, 66), ivec2( 86, 67), ivec2( 93, 67), ivec2( 94, 67), ivec2( 95, 67), ivec2(102, 67), \\\nivec2(103, 67), ivec2(109, 67), ivec2(128, 67), ivec2(129, 67), ivec2(136, 67), ivec2(137, 67), ivec2(139, 67), \\\nivec2(140, 67), ivec2(148, 67), ivec2(161, 67), ivec2( 86, 68), ivec2( 87, 68), ivec2( 93, 68), ivec2( 94, 68), \\\nivec2( 95, 68), ivec2(109, 68), ivec2(136, 68), ivec2(137, 68), ivec2(139, 68), ivec2(140, 68), ivec2(148, 68), \\\nivec2(149, 68), ivec2( 85, 69), ivec2( 87, 69), ivec2( 94, 69), ivec2( 95, 69), ivec2(109, 69), ivec2(137, 69), \\\nivec2(139, 69), ivec2(149, 69), ivec2(110, 70), ivec2(138, 70), ivec2( 91, 72), ivec2( 91, 73), ivec2( 92, 73), \\\nivec2( 90, 74), ivec2( 92, 74), ivec2( 96, 77), ivec2( 96, 78), ivec2( 97, 78), ivec2( 95, 79), ivec2( 97, 79), \\\nivec2(121, 81), ivec2(113, 82), ivec2(114, 82), ivec2(115, 82), ivec2(120, 82), ivec2(121, 82), ivec2(122, 82), \\\nivec2(113, 83), ivec2(116, 83), ivec2(120, 83), ivec2(122, 83), ivec2(123, 83), ivec2(113, 84), ivec2(121, 84), \\\nivec2(122, 84), ivec2(123, 84), ivec2(113, 85), ivec2(121, 85), ivec2(122, 85), ivec2(114, 86), ivec2( 58, 90), \\\nivec2( 57, 91), ivec2( 57, 92), ivec2( 61, 92), ivec2( 98, 92), ivec2( 99, 92), ivec2(100, 92), ivec2( 40, 93), \\\nivec2( 41, 93), ivec2( 42, 93), ivec2( 43, 93), ivec2( 57, 93), ivec2( 58, 93), ivec2( 59, 93), ivec2( 60, 93), \\\nivec2( 98, 93), ivec2(101, 93), ivec2( 40, 94), ivec2( 44, 94), ivec2( 98, 94), ivec2( 40, 95), ivec2( 98, 95), \\\nivec2( 41, 96), ivec2( 98, 96), ivec2( 99, 97), ivec2( 52, 98), ivec2( 53, 98), ivec2( 67, 98), ivec2( 43, 99), \\\nivec2( 52, 99), ivec2( 53, 99), ivec2( 67, 99), ivec2( 69, 99), ivec2( 42,100), ivec2( 52,100), ivec2( 53,100), \\\nivec2( 58,100), ivec2( 67,100), ivec2( 68,100), ivec2( 42,101), ivec2( 49,101), ivec2( 50,101), ivec2( 52,101), \\\nivec2( 57,101), ivec2( 58,101), ivec2( 59,101), ivec2( 42,102), ivec2( 43,102), ivec2( 48,102), ivec2( 49,102), \\\nivec2( 50,102), ivec2( 51,102), ivec2( 52,102), ivec2( 59,102), ivec2( 60,102), ivec2( 44,103), ivec2( 49,103), \\\nivec2( 50,103), ivec2( 51,103), ivec2( 55,103), ivec2( 56,103), ivec2( 72,103), ivec2(101,103), ivec2(102,103), \\\nivec2(103,103), ivec2( 46,104), ivec2( 47,104), ivec2( 72,104), ivec2( 74,104), ivec2(100,104), ivec2(103,104), \\\nivec2( 72,105), ivec2( 73,105), ivec2(103,105), ivec2(103,106), ivec2( 40,107), ivec2( 41,107), ivec2( 42,107), \\\nivec2( 43,107), ivec2( 49,107), ivec2( 50,107), ivec2(103,107), ivec2( 40,108), ivec2( 44,108), ivec2( 48,108), \\\nivec2( 49,108), ivec2( 51,108), ivec2( 52,108), ivec2( 77,108), ivec2(103,108), ivec2( 40,109), ivec2( 49,109), \\\nivec2( 50,109), ivec2( 51,109), ivec2( 52,109), ivec2( 65,109), ivec2( 66,109), ivec2( 67,109), ivec2( 68,109), \\\nivec2( 69,109), ivec2( 70,109), ivec2( 77,109), ivec2( 79,109), ivec2(102,109), ivec2( 41,110), ivec2( 50,110), \\\nivec2( 51,110), ivec2( 65,110), ivec2( 71,110), ivec2( 77,110), ivec2( 78,110), ivec2( 65,111), ivec2( 66,112), \\\nivec2( 94,113), ivec2( 95,113), ivec2(124,113), ivec2( 53,114), ivec2( 54,114), ivec2( 55,114), ivec2( 56,114), \\\nivec2( 93,114), ivec2( 94,114), ivec2( 96,114), ivec2( 97,114), ivec2( 98,114), ivec2(123,114), ivec2(124,114), \\\nivec2(125,114), ivec2( 53,115), ivec2( 57,115), ivec2( 94,115), ivec2( 95,115), ivec2( 96,115), ivec2( 97,115), \\\nivec2( 98,115), ivec2(106,115), ivec2(107,115), ivec2(108,115), ivec2(109,115), ivec2(122,115), ivec2(123,115), \\\nivec2(125,115), ivec2( 53,116), ivec2( 61,116), ivec2( 95,116), ivec2( 96,116), ivec2( 97,116), ivec2(105,116), \\\nivec2(106,116), ivec2(107,116), ivec2(108,116), ivec2(109,116), ivec2(110,116), ivec2(122,116), ivec2(123,116), \\\nivec2(124,116), ivec2( 54,117), ivec2( 57,117), ivec2( 60,117), ivec2( 61,117), ivec2( 62,117), ivec2( 63,117), \\\nivec2( 64,117), ivec2( 65,117), ivec2( 66,117), ivec2(104,117), ivec2(105,117), ivec2(107,117), ivec2(108,117), \\\nivec2(109,117), ivec2(110,117), ivec2(123,117), ivec2(124,117), ivec2( 59,118), ivec2( 60,118), ivec2( 62,118), \\\nivec2( 63,118), ivec2( 64,118), ivec2( 67,118), ivec2(105,118), ivec2(106,118), ivec2( 54,119), ivec2( 57,119), \\\nivec2( 60,119), ivec2( 61,119), ivec2( 62,119), ivec2( 63,119), ivec2( 64,119), ivec2( 65,119), ivec2( 66,119), \\\nivec2( 53,120), ivec2( 61,120), ivec2( 53,121), ivec2( 57,121), ivec2( 53,122), ivec2( 54,122), ivec2( 55,122), \\\nivec2( 56,122), ivec2( 66,124), ivec2( 67,124), ivec2( 65,125), ivec2( 66,125), ivec2( 68,125), ivec2( 69,125), \\\nivec2( 70,125), ivec2( 71,125), ivec2( 33,126), ivec2( 42,126), ivec2( 43,126), ivec2( 66,126), ivec2( 67,126), \\\nivec2( 68,126), ivec2( 69,126), ivec2( 70,126), ivec2( 71,126), ivec2( 32,127), ivec2( 41,127), ivec2( 42,127), \\\nivec2( 43,127), ivec2( 44,127), ivec2( 67,127), ivec2( 68,127), ivec2( 69,127), ivec2( 70,127), ivec2( 32,128), \\\nivec2( 36,128), ivec2( 40,128), ivec2( 41,128), ivec2( 43,128), ivec2( 44,128), ivec2( 84,128), ivec2( 85,128), \\\nivec2( 32,129), ivec2( 33,129), ivec2( 34,129), ivec2( 35,129), ivec2( 41,129), ivec2( 42,129), ivec2( 83,129), \\\nivec2( 84,129), ivec2( 86,129), ivec2( 87,129), ivec2( 84,130), ivec2( 85,130), ivec2( 86,130), ivec2( 87,130), \\\nivec2( 85,131), ivec2( 86,131), ivec2( 52,132), ivec2( 36,133), ivec2( 37,133), ivec2( 51,133), ivec2( 54,133), \\\nivec2( 34,134), ivec2( 35,134), ivec2( 37,134), ivec2( 38,134), ivec2( 50,134), ivec2( 54,134), ivec2( 80,134), \\\nivec2( 81,134), ivec2( 34,135), ivec2( 37,135), ivec2( 50,135), ivec2( 54,135), ivec2( 79,135), ivec2( 80,135), \\\nivec2( 82,135), ivec2( 83,135), ivec2( 34,136), ivec2( 37,136), ivec2( 50,136), ivec2( 54,136), ivec2( 80,136), \\\nivec2( 81,136), ivec2( 82,136), ivec2( 83,136), ivec2( 35,137), ivec2( 36,137), ivec2( 46,137), ivec2( 47,137), \\\nivec2( 51,137), ivec2( 53,137), ivec2( 81,137), ivec2( 82,137), ivec2( 46,138), ivec2( 52,138), ivec2(115,138), \\\nivec2(116,138), ivec2(117,138), ivec2(118,138), ivec2(115,139), ivec2(119,139), ivec2( 33,140), ivec2(115,140), \\\nivec2( 32,141), ivec2(116,141), ivec2( 19,142), ivec2( 20,142), ivec2( 32,142), ivec2( 36,142), ivec2( 51,142), \\\nivec2( 63,142), ivec2( 65,142), ivec2( 18,143), ivec2( 19,143), ivec2( 20,143), ivec2( 21,143), ivec2( 32,143), \\\nivec2( 33,143), ivec2( 34,143), ivec2( 35,143), ivec2( 50,143), ivec2( 64,143), ivec2( 65,143), ivec2( 17,144), \\\nivec2( 18,144), ivec2( 20,144), ivec2( 21,144), ivec2( 50,144), ivec2( 54,144), ivec2( 64,144), ivec2(  1,145), \\\nivec2(  2,145), ivec2( 18,145), ivec2( 19,145), ivec2( 50,145), ivec2( 51,145), ivec2( 52,145), ivec2( 53,145), \\\nivec2(  0,146), ivec2(  1,146), ivec2(  3,146), ivec2(  4,146), ivec2(  1,147), ivec2(  2,147), ivec2(  3,147), \\\nivec2(  4,147), ivec2(  2,148), ivec2(  3,148), ivec2( 25,148), ivec2( 27,148), ivec2( 57,148), ivec2( 58,148), \\\nivec2( 59,148), ivec2( 60,148), ivec2( 25,149), ivec2( 26,149), ivec2( 57,149), ivec2( 61,149), ivec2( 26,150), \\\nivec2( 57,150), ivec2( 65,150), ivec2( 66,150), ivec2(  4,151), ivec2(  8,151), ivec2(  9,151), ivec2( 58,151), \\\nivec2( 61,151), ivec2( 64,151), ivec2( 65,151), ivec2( 66,151), ivec2( 67,151), ivec2(  3,152), ivec2(  4,152), \\\nivec2(  9,152), ivec2( 10,152), ivec2( 11,152), ivec2( 63,152), ivec2( 64,152), ivec2( 68,152), ivec2(  2,153), \\\nivec2(  3,153), ivec2(  9,153), ivec2( 12,153), ivec2( 30,153), ivec2( 32,153), ivec2( 58,153), ivec2( 61,153), \\\nivec2( 64,153), ivec2( 65,153), ivec2( 66,153), ivec2( 67,153), ivec2(  3,154), ivec2(  4,154), ivec2( 12,154), \\\nivec2( 30,154), ivec2( 31,154), ivec2( 47,154), ivec2( 48,154), ivec2( 57,154), ivec2( 65,154), ivec2( 66,154), \\\nivec2( 11,155), ivec2( 12,155), ivec2( 31,155), ivec2( 46,155), ivec2( 47,155), ivec2( 49,155), ivec2( 50,155), \\\nivec2( 51,155), ivec2( 57,155), ivec2( 61,155), ivec2( 47,156), ivec2( 48,156), ivec2( 49,156), ivec2( 50,156), \\\nivec2( 51,156), ivec2( 57,156), ivec2( 58,156), ivec2( 59,156), ivec2( 60,156), ivec2( 24,157), ivec2( 25,157), \\\nivec2( 48,157), ivec2( 49,157), ivec2( 50,157), ivec2( 10,158), ivec2( 23,158), ivec2( 24,158), ivec2( 25,158), \\\nivec2( 26,158), ivec2(  1,159), ivec2(  2,159), ivec2(  9,159), ivec2( 22,159), ivec2( 23,159), ivec2( 25,159), \\\nivec2( 26,159), ivec2(  0,160), ivec2(  1,160), ivec2(  3,160), ivec2(  4,160), ivec2(  9,160), ivec2( 13,160), \\\nivec2( 23,160), ivec2( 24,160), ivec2( 30,160), ivec2( 31,160), ivec2(  1,161), ivec2(  2,161), ivec2(  3,161), \\\nivec2(  4,161), ivec2(  9,161), ivec2( 10,161), ivec2( 11,161), ivec2( 12,161), ivec2( 29,161)", "buffer_a_code": "//Simple init with several Gosper glider guns\nfloat initFromArray(in ivec2 uv)\n{\n    const ivec2[] initState = ivec2[] (\n        ivec2(50,180), ivec2(51,180), ivec2(50,181), ivec2(51,181), ivec2(60,180), \n        ivec2(60,179), ivec2(60,181), ivec2(61,178), ivec2(62,177), ivec2(63,177), \n        ivec2(61,182), ivec2(62,183), ivec2(63,183), ivec2(65,182), ivec2(66,181), \n        ivec2(66,180), ivec2(66,179), ivec2(65,178), ivec2(64,180), ivec2(67,180), \n        ivec2(70,181), ivec2(70,182), ivec2(70,183), ivec2(71,181), ivec2(71,182), \n        ivec2(71,183), ivec2(72,180), ivec2(72,184), ivec2(74,180), ivec2(74,179), \n        ivec2(74,184), ivec2(74,185), ivec2(84,182), ivec2(84,183), ivec2(85,182), \n        ivec2(85,183)\n    );\n\n    const int repeat = 200;\n    ivec2 uv2 = (uv + ivec2(40, 100));\n\n    //Let's introduce some variability\n    ivec2 shift = uv2 / repeat;\n    shift = ivec2(shift.x * shift.y, shift.x * shift.y);\n    uv2 = uv2 % repeat + shift;\n\n    for(int i=0; i != initState.length(); ++i)\n        if( uv2 == initState[i] )\n            return 1.0;\n\n    return 0.0;\n}\n\n//Init form the list of active cells\nconst ivec2[] initState = ivec2[](ACTIVE_CELLS0);\n\nfloat initFromArray2(in ivec2 uv)\n{   \n    for(int i=0; i != initState.length(); ++i)\n        if( uv == initState[i] )\n            return 1.0;\n\n    return 0.0;\n}\n\n//Init form the BITMAP without compression\nconst ivec2 bitmapSize = ivec2(162, 162);\nconst uint[] bitmap = uint[] (BITMAP);\n\nfloat initFromBitmap(in ivec2 uv)\n{\n    if( uint(uv.x) >= uint(bitmapSize.x) || uint(uv.y) >= uint(bitmapSize.y) )\n        return 0.0;\n        \n    int pos = uv.y * bitmapSize.x + uv.x;    \n    float val = float( (bitmap[pos / 32] >> (pos % 32)) & 0x1u );\n    \n    return val;\n}\n\n//Init form the BITMAP with compression\nconst uint[] compBitmapNodes = uint[] (COMPRESSED_BITMAP_NODES);\nconst uint[] compBitmapIndex = uint[] (COMPRESSED_BITMAP_INDEX);\n\nfloat initFromCompressedBitmap(in ivec2 uv)\n{\n    //Each `compBitmapIndex` contains 4 indexes in the list of unique \n    //combinations of 32 active cells `compBitmapNodes`\n    if( uint(uv.x) >= uint(bitmapSize.x) || uint(uv.y) >= uint(bitmapSize.y) )\n        return 0.0;\n        \n    int pos = uv.y * bitmapSize.x + uv.x;\n    int wordIdx = pos / 32;\n    uint idxNode = (compBitmapIndex[wordIdx / 4] >> (wordIdx % 4) * 8) & 0xFFu;\n    float val = float( (compBitmapNodes[idxNode] >> (pos % 32)) & 0x1u );\n    \n    return val;\n}\n\n// Rotate 90 deg in 2d\nivec2 rot90(in ivec2 v, in int size)\n{\n    return ivec2(v.y, size - v.x);\n}\n\n#if 0\n    #define IMPL_SYMMETRICAL(uv) initFromArray2(uv)\n#elif 0\n    #define IMPL_SYMMETRICAL(uv) initFromBitmap(uv)\n#else\n    #define IMPL_SYMMETRICAL(uv) initFromCompressedBitmap(uv)\n#endif    \n\n//Init by applying `IMPL_SYMMETRICAL` 4 times with 90 degrees rotation\nfloat initFromSymmetrical(in ivec2 uv)\n{\n    const int w = bitmapSize.x;\n\n    ivec2 centerShift = ivec2(iChannelResolution[0]) / 2 - bitmapSize;\n    \n    if( uv.x < centerShift.x || uv.y < centerShift.y )\n        return 0.0;\n        \n    uv -= centerShift;\n\n    if( uv.x < w && uv.y < w )  \n        return IMPL_SYMMETRICAL(uv);\n    else if( uv.y < w )\n        return IMPL_SYMMETRICAL(rot90(ivec2(uv.x - (w-1), uv.y), w));\n    else if( uv.x < w )\n        return IMPL_SYMMETRICAL(rot90(rot90( rot90(ivec2(uv.x, uv.y - (w-1)), w), w), w));\n    else\n        return IMPL_SYMMETRICAL(rot90( rot90(ivec2(uv.x - (w-1), uv.y - (w-1)), w), w));\n}\n\n//Read the state of field of the previous generation\nvec4 readState( in ivec2 uv )\n{\n    #if 0\n        uv = wrap(uv, iChannelResolution[0].xy);\n    #endif\n\n    return texelFetch( iChannel0, uv, 0);\n}\n\nfloat keyHit( in int key )\n{\n    return texelFetch( iChannel1, ivec2(key, 1), 0 ).x;\n}\n\nfloat keyDown( in int key )\n{\n    return texelFetch( iChannel1, ivec2(key, 0), 0 ).x;\n}\n\n//Returns 1.0 if the distance between `a` and `b` less than 0.5\nfloat roundEqual( float a, float b )\n{\n    return step( abs(a - b), 0.5 );\n}\n\nfloat calcCellState(in ivec2 uv, out vec4 buff )\n{\n    //Rules: https://conwaylife.com/wiki/Conway%27s_Game_of_Life \n    \n    buff = readState( uv );\n    \n    //Makes sure we won't lose precision\n    float curState = floor(buff.x + 0.5);\n    float totalAliveAround = 0.0;\n    \n    totalAliveAround += readState( uv + ivec2(-1, -1) ).x;\n    totalAliveAround += readState( uv + ivec2( 0, -1) ).x;\n    totalAliveAround += readState( uv + ivec2( 1, -1) ).x;\n    totalAliveAround += readState( uv + ivec2(-1,  0) ).x;\n    totalAliveAround += readState( uv + ivec2( 1,  0) ).x;\n    totalAliveAround += readState( uv + ivec2(-1,  1) ).x;\n    totalAliveAround += readState( uv + ivec2( 0,  1) ).x;\n    totalAliveAround += readState( uv + ivec2( 1,  1) ).x;\n     \n    //The rules of Conway's Game of Life distilled to the branchless form\n    return roundEqual(totalAliveAround, 2.0) * curState + roundEqual(totalAliveAround, 3.0);  \n}\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE = 32;\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\n\nfloat isBtnClicked( in vec2 center, in float radius )\n{\n    vec2 pos = abs(iMouse.zw);\n    pos = vec2(iMouse.x, iResolution.y - iMouse.y);\n    \n    pos = pos / iResolution.x;\n    \n    center = wrap( center, vec2(1.0, iResolution.y / iResolution.x ) );\n    \n    vec2 delta = pos - center;\n    float distSquared = dot(delta, delta);\n   \n    //Mobiles support button clicks only\n    return step(distSquared, radius * radius) * float(iMouse.w > 0.0 || iMouse.z > 0.0);\n}\n\nvoid calcCamera( inout vec2 pan, inout float zoom)\n{\n    //All values are in the world space\n    const float zoomDelta = 0.05;\n    float panDelta = 0.025 * iResolution.x;\n    vec2 screenPos = vec2(0.5) * iResolution.xy;\n    \n    float prevZoom = zoom;\n    \n    zoom *= 1.0 - zoomDelta * (keyDown(KEY_UP) - keyDown(KEY_DOWN));\n    zoom *= 1.0 - zoomDelta * (isBtnClicked(btnZoomInPos, btnRadius) - isBtnClicked(btnZoomOutPos, btnRadius));\n    \n    //We always zoom around the center of the screen\n    //XCas: solve( [x / prevZoom + prevPan = screenPos, x / zoom + pan = screenPos], [pan, x] );\n    pan = screenPos + (pan - screenPos) * prevZoom / zoom;\n\n    pan.x += (keyDown(KEY_A) - keyDown(KEY_D)) * panDelta;\n    pan.y += (keyDown(KEY_W) - keyDown(KEY_S)) * panDelta;\n    \n    pan += (iMouse.xy - abs(iMouse.zw)) * float(iMouse.z > 0.0) * vec2(1, -1) * panDelta / iResolution.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n        \n    if(iFrame == 0 || keyHit(KEY_SPACE) > 0.0 || isBtnClicked(btnResetPos, btnRadius) > 0.0 )\n    {\n        float val = 0.0;\n        //val = initFromArray(uv);\n        //val = initFromArray2(uv);\n        //val = initFromBitmap(uv);\n        //val = initFromCompressedBitmap(uv);\n        val = initFromSymmetrical(uv);\n        fragColor = vec4( val, 0.0, 0.0, 1.0 );\n   \n        return;\n    }\n    \n    vec4 buff;\n    \n    float newState = calcCellState(uv, buff);\n    \n    vec2 camPan = buff.yz;\n    float camZoom = buff.w;\n\n    calcCamera( camPan, camZoom );\n    \n    fragColor = vec4(newState, camPan, camZoom );  \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1398, 1398, 1426, 1495, 1556], [1558, 1558, 1638, 1684, 1911], [1913, 1913, 2013, 2013, 2316], [2318, 2318, 2385, 2385, 2709], [2711, 2711, 2768, 2794, 3976]]}
{"id": "7ddyDf", "name": "Warped Hexler Hexes", "author": "mrange", "description": "License CC0: Warped Hexler Hexes\nResult from some random coding\n", "tags": ["2d", "hex"], "likes": 11, "viewed": 347, "published": 3, "date": "1654195957", "time_retrieved": "2024-07-30T16:45:48.890015", "image_code": "// License CC0: Warped Hexler Hexes\n//  Result from some random coding\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat modMirror1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize,size) - halfsize;\n  p *= mod(c, 2.0)*2.0 - 1.0;\n  return c;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat smoothKaleidoscope(inout vec2 p, float sm, float rep) {\n  vec2 hp = p;\n\n  vec2 hpp = toPolar(hp);\n  float rn = modMirror1(hpp.y, TAU/rep);\n\n  float sa = PI/rep - pabs(PI/rep - abs(hpp.y), sm);\n  hpp.y = sign(hpp.y)*(sa);\n\n  hp = toRect(hpp);\n\n  p = hp;\n\n  return rn;\n}\n\nvec2 transform(vec2 p) {\n  p *= sqrt(0.5);\n  vec2 sp = toSmith(p);\n  float tm = TIME*0.125;\n  sp += sin(tm*vec2(1.0, sqrt(0.5)));\n  sp *= ROT(tm*sqrt(3.0));\n  p = fromSmith(sp);\n  return p;\n}\n\n\nvec3 color(vec2 p_) {\n  const float N = 6.0;\n  const float coln = 9.0;\n\n  float aaa = 2.0/RESOLUTION.y;\n  p_ *= ROT(0.05*TIME);\n  smoothKaleidoscope(p_, 0.125, 2.0*N);\n  vec2 p = p_;\n  vec2 np = p_+aaa;\n  p = transform(p);\n  np = transform(np);\n  float aa = distance(p, np)*sqrt(0.5);\n  float aaf = aa/aaa; \n  \n  vec2 htn = hextile(p);\n  \n  vec2 pp = toPolar(p);\n  float a = pp.y;\n  float hn = mod1(pp.y, TAU/N);\n  vec2 hp = toRect(pp);\n  \n  float x = hp.x;\n  float w = 0.0525;\n  float n = mod1(x, w)+htn.x+hash(htn+123.4);\n  float d = abs(x)-(0.5*w-3.*aa);\n  \n  float h0 = hash(n+1.234);\n  float h1 = hash(n+2.345);\n  float cut = mix(-0.5, 0.999, 0.5+0.5*sin(TIME+TAU*h0));\n  vec3 col = hsv2rgb(vec3(\n      floor(h0*coln)/coln\n    , mix(0.25, 0.8, tanh(aaf))\n    , 1.0));\n  col *= smoothstep(aa, -aa, d);\n  col *= smoothstep(cut, cut-0.005, sin(a+2.0*(h1-0.5)*TIME+h1*TAU));\n  col += (0.025*sqrt(aaf)+0.1)*HSV2RGB(vec3(0.6, 0.99, 1.0));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = color(p);\n\n  col = sqrt(col);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddyDf.jpg", "access": "api", "license": "cc0-1.0", "functions": [[402, 402, 424, 424, 570], [865, 925, 947, 947, 995], [997, 1057, 1081, 1081, 1151], [1153, 1239, 1278, 1278, 1403], [1405, 1493, 1515, 1515, 1559], [1561, 1649, 1670, 1670, 1715], [1717, 1818, 1846, 1945, 2272], [2274, 2274, 2297, 2377, 2516], [2518, 2518, 2543, 2622, 2761], [2763, 2863, 2902, 2902, 2987], [2989, 3077, 3107, 3107, 3135], [3137, 3223, 3268, 3268, 3422], [3424, 3512, 3573, 3573, 3786], [3788, 3788, 3812, 3812, 3979], [3982, 3982, 4003, 4003, 4935], [4937, 4937, 4992, 4992, 5166]]}
{"id": "7dtyWX", "name": "Damaged Photo Noise ", "author": "Sergeindamix", "description": "Value Noise Explained!", "tags": ["noise", "random", "valuenoise"], "likes": 1, "viewed": 278, "published": 3, "date": "1654191152", "time_retrieved": "2024-07-30T16:45:49.631034", "image_code": "float N21(vec2 p) {\n    return fract(sin(p.x*100.+p.y*6574.)*5647.);\n}\n\nfloat SmoothNoise(vec2 uv) {\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n    \n    // don't make octaves exactly twice as small\n    // this way the pattern will look more random and repeat less\n    c += SmoothNoise(uv*8.2)*.5;\n    c += SmoothNoise(uv*16.7)*.25;\n    c += SmoothNoise(uv*32.4)*.125;\n    c += SmoothNoise(uv*64.5)*.0625;\n    \n    c /= 2.;\n    \n    return c;\n}\n\nfloat rectangle(vec2 position, vec2 scale)\n{\n    scale = vec2(0.5) - scale * 0.5;\n    vec2 shape = vec2(step(scale.x, position.x), step(scale.y, position.y));\n    shape *= vec2(step(scale.x, 1.0 - position.x), step(scale.y, 1.0 - position.y));\n    \n    return shape.x * shape.y;\n\n}\n\nfloat Band(float t, float start, float end, float blur){\n    \n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    \n    return step1*step2;//overlap edges\n\n}\n\nfloat Rect(vec2 uv, float left,float right,float bottom,float top,float blur){\n    float band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1*band2;//overlap horizontal and vertical bands\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = uv;\n    float x = uv.x;\n    float y = uv.y;\n    \n    x+=.0;//move horizontal\n    y+=.0;//move vertical\n    float t = iTime;\n    \n    uv+=0.25;//Noise Shape\n    float c = SmoothNoise2(uv);\n    \n    float d = smoothstep(0.,1.,length(uv2-.5)-.5);//rectangle(uv2,vec2(.500))-.025;\n    \n    d+=c;\n    vec3 v = texture(iChannel0,uv2).rgb/d*c;\n    vec3 col = vec3(v);//Noise\n    \n    if( col.y > y/.125 || col.y > x/.125 || col.x<.5 && col.y > 1.25-y ||\n        col.x<.75 && col.y > 1.25-x)\n        col=vec3(1);//Edges White Noise\n    else col = texture(iChannel1,uv2).rgb;//vec3(0);//photo\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 70], [72, 72, 100, 100, 419], [421, 421, 450, 450, 784], [786, 786, 830, 830, 1067], [1069, 1069, 1125, 1125, 1287], [1289, 1289, 1367, 1367, 1536], [1538, 1538, 1595, 1595, 2267]]}
{"id": "7sdcDX", "name": "Eyebat", "author": "yasuo", "description": "The Eyebat is exploring the cave.", "tags": ["eyebat"], "likes": 10, "viewed": 266, "published": 3, "date": "1654190953", "time_retrieved": "2024-07-30T16:45:50.382026", "image_code": "// Raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 64\n#define MAX_DIST 32.\n#define SURF_DIST .001\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define MATERIAL0 0\n#define MATERIAL1 1\n#define MATERIAL2 2\n#define SPEED 7.0\n#define ZERO (min(iFrame,0))\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n    p = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n    return sin(p*6.283);\n}\n\nfloat perlin_noise(vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat feather(vec3 p) {\n    float k = 0.03;\n    p.x = abs(p.x);\n    p.y+=0.1;\n    p.z-=0.1;\n    p.xz*=Rot(radians(sin(iTime*10.0)*10.0));\n    p.xy*=Rot(radians(-20.0));\n    p.x-=1.2;\n    vec3 prevP = p;\n    \n    // feather\n    p.y*=mix(2.0,0.6,smoothstep(-1.0,1.0,p.x));\n    float d = sdBox(p,vec3(0.7,0.4,0.01))-0.03;\n    \n    p = prevP;\n    p.x-=0.9;\n    p.xy*=Rot(radians(-18.0));\n    float d2 = sdBox(p,vec3(0.35,0.6,0.01))-0.03;\n    float rad = radians(18.0);\n    p.x = abs(p.x)-0.2;\n    float mask = dot(p,vec3(cos(rad),sin(rad),0.0));\n    d2 = max(mask,d2);\n    p = prevP;\n    p.x-=0.9;\n    p.xy*=Rot(radians(-18.0));\n    p.x*=0.8;\n    d2 = max(-(length(p-vec3(0.0,-0.7,0.0))-0.3),d2);\n    \n    d = smin(d,d2,k);\n    \n    p = prevP;\n    p.x-=1.2;\n    p.y-=0.2;\n    p.xy*=Rot(radians(-50.0));\n    d2 = sdBox(p,vec3(0.35,0.6,0.01))-0.03;\n    rad = radians(18.0);\n    p.x = abs(p.x)-0.2;\n    mask = dot(p,vec3(cos(rad),sin(rad),0.0));\n    d2 = max(mask,d2);\n    p = prevP;\n    p.x-=1.2;\n    p.y-=0.2;\n    p.xy*=Rot(radians(-50.0));\n    p.x*=0.8;\n    d2 = max(-(length(p-vec3(0.0,-0.7,0.0))-0.3),d2);\n    \n    d = smin(d,d2,k);\n    \n    p = prevP;\n    d2 = sdCone(p-vec3(0.75,0.85,.0),vec2(0.03,0.12),0.3);\n    d = smin(d,d2,k+0.02);\n    \n    return d*0.6;\n}\n\nfloat tail(vec3 p){\n    p.yz*=Rot(radians(sin(-iTime*3.0)*20.0));\n    vec3 prevP = p;\n    p = prevP;\n    float d = sdRoundedCylinder(p-vec3(.0,-1.0,.0),0.05,0.1,0.3);\n    \n    p.xy*=Rot(radians(180.0));\n    float d2 = sdCone(p-vec3(.0,1.7,.0),vec2(0.05,0.15),0.5);\n    d = smin(d,d2,0.2);\n    return d;\n}\n\nvec2 eyeBat(vec3 p){\n    vec3 prevP = p;\n    \n    // body part\n    float d = length(p) - 0.7;\n    float rad = radians(abs(sin(iTime*5.0)*10.0+20.0));\n    p.y = abs(p.y)-0.1;\n    float d2 = dot(p,vec3(0.0,cos(rad),sin(rad)));\n    d2 = max(p.z+0.1,d2);\n    d = max(-d2,d);\n    \n    // horn\n    p = prevP;\n    p.x = abs(p.x)-0.3;\n    p.yz*=Rot(radians(-15.0));\n    d2 = sdCone(p-vec3(0.0,1.1,-.1),vec2(0.03,0.15),0.5);\n    d = smin(d,d2,0.1);\n    \n    p = prevP;\n    \n    // feather\n    d2 = feather(p);\n    d = smin(d,d2,0.2);\n     \n    // tail\n    d2 = tail(p);\n    d = smin(d,d2,0.2);\n    \n    // eyeball\n    d2 = length(p) - 0.68;\n    \n    return combine(vec2(d,MATERIAL0),vec2(d2,MATERIAL2));\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p.z-=iTime*10.0;\n    float n = perlin_noise(p.xz*0.3)*3.0;\n    p.xy+=n;\n    \n    float d = -length(p.xy) + 8.0;\n    \n    p = prevP;\n    return combine(eyeBat(p),vec2(d*0.6,MATERIAL1));\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n\n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n                \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    float h = 1.0;\n    for( int i=0; i<48; i++ )\n    {\n        h = GetDist(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += clamp( h, 0.025, 1.0 );\n        if( h<0.001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(p.x,p.y,-2));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    //float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float shadow = softshadow(p,rd,0.05, 32.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(0.5)*diff*shadow*occ;\n    diffCol += col*vec3(0.3,0.7,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.5,0.7,0.5)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 20.); // spec\n\n    return diffCol;\n}\n\nvec3 tex(vec3 p,vec3 col){\n    vec2 uv = p.xy;\n    uv*=5.0;\n    vec2 grid = abs(fract(uv - 0.5) - 0.5) / fwidth(uv);\n    float line = min(grid.x, grid.y);\n    float gridd = 0.5 - min(line, 1.0);\n    return mix(vec3(0.0),vec3(1.0),S(gridd,-0.2));\n}\n\nvec3 eyeTex(vec3 p,vec3 col){\n    vec2 uv = p.xy;\n    uv.x+=sin(iTime*2.0)*0.2;\n    float d = length(uv)-0.35;\n    col = mix(vec3(1.0,0.95,0.9),vec3(0.0),S(d,0.0));\n    d = length(uv)-0.2;\n    col =  mix(col,vec3(0.3),S(d,0.0));\n    d = length(uv-vec2(-0.15,0.23))-0.05;\n    return mix(col,vec3(2.0),S(d,0.0)); \n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    vec3 r = reflect(rd,n);   \n    vec3 refTex = tex(p,vec3(max(0.55,r.x)))+(r*sin(iTime)*0.5);\n    return refTex;\n}\n\nvec3 fractalTex(vec3 p, vec3 col, float deg, float thickness, float b){\n    vec2 uv = p.xy;\n    uv*=0.2;\n    uv = fract(uv)-0.5;\n    float dd = 10.0;\n    \n    for(float i = 0.; i<7.0; i++){\n        uv = abs(uv)-(0.01*i)-0.2;\n        float rad = radians(50.0*i+deg);\n        float n = dot(uv,vec2(sin(rad),cos(rad)));\n        dd = min(dd,abs(n)-thickness);\n    }\n    \n    col = mix(col,vec3(0.9,0.5,0.3)+sin(0.5*iTime+(uv.x+uv.y+p.z)),S(dd,b));\n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n\n    if(mat == MATERIAL0){\n        float perl = perlin_noise(p.xy*3.5)*0.1;\n        float nn = hash12(p.xy*8.0)*0.3;\n        col = mix(vec3(0.3,0.4,0.3),vec3(0.2,0.3,0.2),p.y);\n        col = fractalTex(p*1.2,col,10.0,0.01,-0.01)*0.5;\n        col = diffuseMaterial(n,rd,p,col+perl+nn);\n    } else if(mat == MATERIAL1) {\n        float nn = hash12(p.xy*8.0)*0.3;\n        col = reflectMaterial(p,rd,n)*vec3(0.6,0.3,0.0);\n        col = diffuseMaterial(n,rd,p,col+nn)+fractalTex(p,col,iTime*10.0,0.025,-0.03)*0.5;\n    } else if(mat == MATERIAL2){\n        col = eyeTex(p,col);\n        col = diffuseMaterial(n,rd,p,col);\n    }\n    \n    float dd = abs(length(p.xy)-0.1)-0.0001;\n    col *= 1.0 + 0.5*cos(200.0*dd);\n    \n    return col;\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = iTime*SPEED;\n    vec3 ro = vec3(0,0.0,-5.0);\n \n    vec2 m =  iMouse.xy/iResolution.xy;\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(3.0,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        if(mod(iTime,30.0)<15.0){\n            ro.xz *= Rot(radians(sin(iTime*0.5)*30.0));\n        } else {\n            ro.yz *= Rot(radians(sin(iTime*0.5)*30.0));\n        }\n    }\n \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n        col *= exp( -0.000005*d.x*d.x*d.x*d.x );//fog\n    } else {\n        col = vec3(0.0);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n    col = ACESFilm(col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdcDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[441, 441, 477, 477, 519], [521, 540, 562, 562, 682], [684, 684, 705, 705, 823], [825, 825, 853, 853, 1451], [1453, 1511, 1554, 1554, 1653], [1655, 1713, 1744, 1744, 1831], [1833, 1891, 1955, 1955, 2072], [2074, 2132, 2179, 2313, 2648], [2650, 2650, 2673, 2673, 3911], [3913, 3913, 3932, 3932, 4217], [4219, 4219, 4239, 4239, 4915], [4917, 4917, 4939, 4939, 5150], [5152, 5152, 5210, 5210, 5481], [5483, 5483, 5507, 5507, 5708], [5710, 5710, 5752, 5752, 5947], [5949, 5990, 6039, 6039, 6333], [6335, 6380, 6445, 6445, 6733], [6735, 6735, 6792, 6792, 7452], [7454, 7454, 7480, 7480, 7701], [7703, 7703, 7732, 7732, 8016], [8018, 8018, 8065, 8065, 8182], [8184, 8184, 8255, 8255, 8645], [8647, 8647, 8706, 8706, 9434], [9436, 9515, 9538, 9538, 9698], [9700, 9700, 9757, 9757, 10748]]}
{"id": "NdtyDX", "name": "Basic TerrainMarching", "author": "droidkid", "description": "Trying to ray march a simple terrain. Following along https://iquilezles.org/articles/terrainmarching/", "tags": ["raymarching", "terrain", "learning"], "likes": 0, "viewed": 232, "published": 3, "date": "1654185935", "time_retrieved": "2024-07-30T16:45:51.131023", "image_code": "float terrain(vec3 pos) {\n    return clamp(sin(pos.x) * sin(2.0*pos.z), -0.5 , 1.8);\n}\n\nvec3 calcNormal(vec3 pos) {\n    vec3 e = vec3(0.0001, 0.0, 0.0);\n    return normalize(vec3(\n        terrain(pos - e.xyy) - terrain(pos + e.xyy),\n        2.0 * e.x,\n        terrain(pos - e.yyx) - terrain(pos + e.yyx)\n    ));\n}\n\nfloat castRay(in vec3 ro, in vec3 rd) {\n    float t = 0.001;\n    float del = 0.01;\n    while (t < 20.0) {\n        vec3 pos = ro + t * rd;\n        if (pos.y < terrain(pos)) {\n            // below the terrain.\n            return t;\n        }\n        t += del;\n    }\n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n\n    float an = 10.0*iMouse.x/iResolution.x;\n\n    vec3 ro = vec3(8.0 * sin(an), 7.0 , 8.0 * cos(an));\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ww = normalize(ta-ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    mat3 cam = mat3(uu, vv, ww);\n    \n    vec3 rd = normalize(cam * (vec3(p, 1.5)));\n\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y, 0.0) * 0.5;\n    float t = castRay(ro, rd);\n    if (t > 0.0) {\n        vec3 pos = ro + t*rd;\n        vec3 normal = calcNormal(pos);\n        \n        vec3 mate = vec3(0.2);\n         \n        vec3 sunDir = vec3(0.8, 0.4, 1.0);\n        \n        float sun_dif = clamp(dot(normal, sunDir), 0.0, 1.0);\n        float sun_sha = step(castRay(pos + 0.01*normal, sunDir), 0.0);\n        float sky_dif = clamp(0.3 + 0.5 * dot(normal, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bou_dif = clamp(0.5 + 0.5*dot(normal, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n\n        \n        col =  mate * sun_dif * sun_sha * vec3(7.0, 5.0, 3.0);\n        col += mate * sky_dif * vec3(0.2, 0.2, 0.2);\n        col += mate * vec3(0.7, 0.3, 0.2) * bou_dif;\n\n    } \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 0.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtyDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 86], [88, 88, 115, 115, 313], [315, 315, 354, 354, 597], [599, 599, 656, 656, 1925]]}
{"id": "Ns3cWX", "name": "CodeGarden Challenge 22 #2", "author": "larserik", "description": "CodeGarden Challenge 22 - Make the CG heart logo with whatever you want\nBeating heart animation edition", "tags": ["raymarching", "logo", "umbraco", "codegarden", "codegardenchallenge"], "likes": 1, "viewed": 190, "published": 3, "date": "1654185197", "time_retrieved": "2024-07-30T16:45:51.869050", "image_code": "// Ray marching code and SDF functions copied from Inigo Quilez and Martijn Steinrucken\n// The MIT License\n// Copyright © 2022 Lars-Erik Aabech\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1, d2);\n}\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\n\nfloat sdBox2( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\nfloat GetDist(vec3 p, out float col) {\n    const float hr = 0.707; // heart raduis\n    const float tr = 0.07; // torus radius\n\n    col = 1.;\n\n    float isBeat = max(0., mod(floor(iTime*1.7),3.)-1.);\n    float beat = abs(sin(iTime*TAU*1.7));\n    float scale = 1. + isBeat * beat * .2;\n\n    //float d = sdBox(p, vec3(1));\n    // Top right arc\n    vec3 p1 = p;\n    p1.x += .5 * scale;\n    p1.y -= .5 * scale;\n    p1.xy *= Rot(-0.785);\n    vec2 a = vec2(sin(1.57), cos(1.57));\n    //a = vec2(sin(3.14), cos(3.14));\n    float d1 = sdCappedTorus(p1, a, hr, tr);\n    d1 = opU(d1, sdCapsule(p1, vec3(-hr, 0., 0.), vec3(hr, 0., 0.), tr));\n    \n    // Mid right triangle\n    vec3 p2 = p;\n    p2.x += 1. * scale;\n    p2.y += (scale - 1.) * .5;\n    float d2 = sdCapsule(p2, vec3(0), vec3(1, 0, 0), tr);\n    d2 = opU(d2, sdCapsule(p2, vec3(0), vec3(1, 1, 0), tr));\n    d2 = opU(d2, sdCapsule(p2, vec3(1, 1, 0), vec3(1, 0, 0), tr));\n\n    // Bottom right triangle\n    vec3 p3 = p;\n    p3.x += 1. * scale;\n    p3.y += 0. + scale - 1.;\n    float d3 = sdCapsule(p3, vec3(0), vec3(1, 0, 0), tr);\n    d3 = opU(d3, sdCapsule(p3, vec3(0), vec3(1, -1, 0), tr));\n    d3 = opU(d3, sdCapsule(p3, vec3(1, -1, 0), vec3(1, 0, 0), tr));\n\n    float rightHalf = opU(opU(d1, d2), d3);\n    \n    // Upper left pie\n    vec3 p4 = p;\n    p4.x -= .5 * scale;\n    p4.y -= .5 * scale;\n    p4.xy *= Rot(.785);\n    float d4 = sdCappedCylinder(p4, vec3(0, 0, .001), vec3(0, 0, -.001), hr);\n    d4 = opSub(sdBox2(p4+vec3(-0,.5,0), vec3(1, .5, .5)), d4);\n    d4 = rounding(d4, tr-.005);\n\n    // Lower left triangle\n    vec3 p5 = p;\n    p5 -= vec3(scale-1.,-scale+1., 0);\n    float d5 = udTriangle(vec3(0), vec3(1, 0, 0), vec3(0, -1, 0), p5) - .001;\n    d5 = rounding(d5, tr-.006);\n\n    float leftHalf = opU(d4, d5);\n    \n    float d = min(rightHalf, leftHalf);\n    \n    if (d == d4) col = 2.;\n    if (d == d5) col = 3.;\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, out float col) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p, col);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float col;\n\tfloat d = GetDist(p, col);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, col),\n        GetDist(p-e.yxy, col),\n        GetDist(p-e.yyx, col)\n    );\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    if (m.x > 0. || m.y > 0.) {\n        m -= .5;\n        m.y *= -1.;\n    }\n\n    vec3 ro = vec3(0, 2, 2);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(.2, .266, .694);\n\n    float colIndex = 0.;\n    float d = RayMarch(ro, rd, colIndex);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        \n        if (colIndex == 1.)\n            col = vec3(colIndex);\n        else if (colIndex == 2.)\n            col = vec3(.96, .756, .737);\n        else if (colIndex == 3.)\n            col = vec3(.615, .5, .341);\n        \n        col = col * dif;\n    }\n    \n    //col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3cWX.jpg", "access": "api", "license": "mit", "functions": [[1316, 1316, 1335, 1335, 1397], [1399, 1399, 1424, 1424, 1443], [1444, 1444, 1469, 1469, 1488], [1490, 1490, 1523, 1523, 1546], [1548, 1548, 1583, 1583, 1605], [1607, 1607, 1636, 1636, 1717], [1719, 1719, 1761, 1761, 1781], [1783, 1783, 1815, 1815, 1902], [1904, 1904, 1974, 1974, 2108], [2110, 2110, 2162, 2162, 2283], [2285, 2285, 2342, 2342, 2678], [2680, 2680, 2747, 2747, 3399], [3401, 3401, 3439, 3439, 5291], [5293, 5293, 5342, 5342, 5558], [5560, 5560, 5584, 5584, 5814], [5816, 5816, 5866, 5866, 6057], [6059, 6059, 6116, 6116, 7066]]}
{"id": "7sdyWX", "name": "Is it still raymarching?", "author": "VPas", "description": "Procedural waves generated by ray tracing.\n\nInspired by https://www.shadertoy.com/view/MtX3Ws", "tags": ["waves", "raytrace", "animation"], "likes": 24, "viewed": 749, "published": 3, "date": "1654184262", "time_retrieved": "2024-07-30T16:45:52.607077", "image_code": "//Inspired by https://www.shadertoy.com/view/MtX3Ws\n\n#define aa\n#define iTimer 0.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 r=iResolution.xy,m=iMouse.xy*6.28+3.14;\n  float mr=1./min(r.x,r.y),x,y,i,j,c,f,t=iTime*1.,a=m.x,b=m.y;\n  vec3 z,n,k,p,l=vec3(sin(t*.035),sin(t*.089)*cos(t*.073),cos(t*.1))*.3+vec3(.3);\n  #ifdef aa\n  for(;x++<2.;y=0.){for(;y++<2.;){\n  #endif\n    n=vec3((fragCoord*2.-r+vec2(x,y))*mr*4.,1.);\n    vec3 g;float u=.2,d,e=1.;\n    for(i=0.;i++<3.;){\n      d+=u;p=n*d-l;c=0.;\n      for(j=0.;j++<7.;){\n        p=(sin(t*.05)*.1+.9)*abs(p)/dot(p,p)-(cos(t*.09)*.02+.8);\n        p.xy=vec2(p.x*p.x-p.y*p.y,(smoothstep(0., 4., iTime)*3.+.8*cos(t*.07))*p.x*p.y);\n        p=p.yxz;\n        c+=exp(-9.*abs(dot(p,p.zxy)));\n      }\n      u*=exp(-c*.6);\n      f=c*c*.09;\n      g=g*1.5+.5*vec3(c*f*.3,f,f)*1.;\n    }\n    g*=g;\n    k+=g*\n    #ifdef aa\n    .4;}}\n    #else\n    1.6;\n    #endif\n  fragColor=vec4(k/(1.+k),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "fdtyWX", "name": "Cherry Blossom", "author": "chenglou", "description": "Random experiment with polar coordinates and short code. Stare long enough and even static objects start rotating afterward", "tags": ["polar"], "likes": 4, "viewed": 274, "published": 3, "date": "1654158628", "time_retrieved": "2024-07-30T16:45:53.345103", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y; // normalize y from -1 to 1\n    float r = length(uv); // radius\n    float a = atan(uv.y, uv.x); // angle\n    \n    float color = cos(6. * (a + iTime / 2.)) - sin(iTime) / 2. + .5 - tan(r * sin((sin(iTime) * 2. + 12.) * r)); // numbers here mostly arbitrary\n\n    fragColor = vec4(color * (vec4(r, 0.3/r, r/1.2, 1))); // arbitrary constant numbers here too\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 476]]}
{"id": "fs3yDf", "name": "Lattice of Forking Paths", "author": "mla", "description": "Cubeworld ([url]https://www.shadertoy.com/view/tsXBzs[/url]) again, but instead of every face leading back to the same cube, every face leads back to a different cube. Inspired by [url]https://www.shadertoy.com/view/7dlyW7[/url] by SchnitzelKiller.", "tags": ["cube", "lattice", "noneuclidean", "feistel"], "likes": 9, "viewed": 319, "published": 3, "date": "1654154742", "time_retrieved": "2024-07-30T16:45:54.083130", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Lattice of Forking Paths\n// Matthew Arcus, mla, 2022\n//\n// Based on https://www.shadertoy.com/view/tsXBzs, but instead of every face\n// leading back to the same cube, every face leads to a completely different\n// cube, with each path leading to a different cube.\n//\n// We need to keep track of the path through the lattice, this is done with\n// an iterated hash (so we're using blockchain technology!). The hash is a\n// simple Feistel network so moving through a face one way undoes the effect\n// of moving through the other way.\n//\n// Navigation is just moving on a line. Mouse changes view direction.\n// Repeats every 60 seconds to avoid excessive time computing the start\n// cube (I should store this in a texture).\n//\n// Inspired by https://www.shadertoy.com/view/7dlyW7 by SchnitzelKiller.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\nfloat maxdist = 50.0;\nint maxiterations = 100;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat stepsize(vec3 p, vec3 r) {\n  // Want least k such that p + kr has coordinate 1 in some dimension\n  // eg. p.x+kr.x = 1 => k = (1-p.x)/r.x\n  // eg. p.x+kr.x = 0 => k = -p.x/r.x\n  // Want k positive, so assuming p.x is 0 < p.x < 1, depends on r.\n  float k = 1e8;\n  if (r.x > 0.0) k = min(k,(1.0-p.x)/r.x);\n  else if (r.x < 0.0) k = min(k,-p.x/r.x);\n  if (r.y > 0.0) k = min(k,(1.0-p.y)/r.y);\n  else if (r.y < 0.0) k = min(k,-p.y/r.y);\n  if (r.z > 0.0) k = min(k,(1.0-p.z)/r.z);\n  else if (r.z < 0.0) k = min(k,-p.z/r.z);\n  return k;\n}\n\n// Having moved to a face & just beyond, work out which face\n// we have hit. What happens if we are close to the edge & in\n// fact have passed through 2 faces?\nint gethitface(vec3 p) {\n  if (p.x > 1.0) return 0;\n  if (p.x < 0.0) return 1;\n  if (p.y > 1.0) return 2;\n  if (p.y < 0.0) return 3;\n  if (p.z > 1.0) return 4;\n  if (p.z < 0.0) return 5;\n  return -1;\n}\n\nvoid nextpos(int hitface, inout vec3 p) {\n  if (hitface == 0) p.x -= 1.0;\n  if (hitface == 1) p.x += 1.0;\n  if (hitface == 2) p.y -= 1.0;\n  if (hitface == 3) p.y += 1.0;\n  if (hitface == 4) p.z -= 1.0;\n  if (hitface == 5) p.z += 1.0;\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuvec2 update(uvec2 type, int hitface) {\n  uint k = uint((hitface>>1)+1);\n  uint n0 = type[0];\n  uint n1 = type[1];\n  if ((hitface&1) == 0) {\n    n0 ^= ihash(n1^k);\n    n1 ^= ihash(n0^k);\n  } else {\n    n1 ^= ihash(n0^k);\n    n0 ^= ihash(n1^k);\n  }\n  return uvec2(n0,n1);\n}\n\nbool traceray(inout vec3 p, inout vec3 r, out int hitface, inout uvec2 type, out float totaldist) {\n  totaldist = 0.0;\n  vec3 p0 = p;\n  for (int i = 0; i < maxiterations; i++) {\n    assert(i+1 < maxiterations);\n    float eps = 1e-3;\n    float k = stepsize(p,r)+eps;\n    p += k*r;\n    totaldist += k;\n    if (totaldist > maxdist) return false;\n    // determine the hit face\n    hitface = gethitface(p);\n    type = update(type,hitface);\n    vec3 border = min(p,1.0-p);\n    // Have we hit the face frames?\n    float framewidth = 0.05;\n    if (true) {\n      if (hitface/2 == 0 && min(border.y,border.z) < framewidth) return true;\n      if (hitface/2 == 1 && min(border.z,border.x) < framewidth) return true;\n      if (hitface/2 == 2 && min(border.x,border.y) < framewidth) return true;\n    }\n    // Advance p\n    nextpos(hitface,p);\n  }\n  assert(false); // We should have enough iterations to get to maxdist\n  return false;\n}\n\nvoid moveforward(inout vec3 p, vec3 dir, float t, inout uvec2 type) {\n  for (int i = 0; i < 50; i++) {\n    assert(i < 49);\n    float k = stepsize(p,dir) ;\n    float eps = 1e-3;\n    if (t <= k) {\n      p += t*dir;\n      return;\n    }\n    k += eps;\n    p += k*dir;\n    t -= k;\n    int hitface = gethitface(p);\n    type = update(type,hitface);\n    nextpos(hitface,p);\n  }\n  assert(false);\n}\n\nvec3 bgcol = vec3(1,1,0.5);\n\nvec3 colors[] =\n  vec3[](vec3(1,0,0),\n         vec3(0,1,0),\n         vec3(0,0,1),\n         vec3(1,1,0),\n         vec3(1,0,1),\n         vec3(0,1,1));\n         \nvec3 getcolor(uint type) {\n  type = ihash(type);\n  return colors[type%uint(colors.length())];\n}\n\nvec3 normal(int hitface) {\n  vec3 n = vec3(0);\n  n[hitface>>1] = 1.0;\n  return n;\n}\n\nvec3 raycolor(vec3 p, vec3 r, uvec2 type) {\n  float totaldist;\n  int hitface;\n  if (!traceray(p,r,hitface,type,totaldist)) return bgcol;\n  vec3 color = 0.8*getcolor(type[0]^type[1]);\n  vec3 light = normalize(vec3(0,1,-0.5));\n  vec3 n = normal(hitface);\n  if (dot(n,r) > 0.0) n = -n;\n  color *= 0.4+0.4*clamp(dot(light,n),0.0,1.0);\n  color = mix(color,bgcol,totaldist/maxdist);\n  return color;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return mat2(cos(t),sin(t),-sin(t),cos(t))*p;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (false) {\n    p.zx = rotate(p.zx,iTime * 0.2);\n    p.xy = rotate(p.xy,iTime * 0.125);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  vec3 p0 = vec3(0.5);\n  uvec2 type0 = uvec2(0x12345678U,0x87654321U);\n  moveforward(p0,vec3(0,0.618,1),mod(0.5*iTime,30.0),type0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec3 p = p0;\n      uvec2 type = type0;\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,2);\n      r = transform(r);\n      r = normalize(r); // Normalize after transform\n      vec3 c = raycolor(p,r,type);\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3yDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1063, 1063, 1084, 1084, 1110], [1112, 1112, 1144, 1361, 1650], [1652, 1812, 1836, 1836, 2013], [2015, 2015, 2056, 2056, 2250], [2252, 2316, 2336, 2336, 2450], [2452, 2452, 2491, 2491, 2724], [2726, 2726, 2825, 2825, 3647], [3649, 3649, 3718, 3718, 4036], [4226, 4226, 4252, 4252, 4321], [4323, 4323, 4349, 4349, 4406], [4408, 4408, 4451, 4451, 4802], [4804, 4804, 4834, 4834, 4883], [4885, 4885, 4912, 4912, 5240], [5242, 5242, 5299, 5299, 5949]]}
{"id": "7scyWX", "name": "Normalized FragCoord", "author": "GlitchEnzo", "description": "The fragment coordinates output as a normalized color value. This is useful for debugging coordinate systems.", "tags": ["fragcoord"], "likes": 1, "viewed": 206, "published": 3, "date": "1654134150", "time_retrieved": "2024-07-30T16:45:54.831130", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(fragCoord.xy / iResolution.xy, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scyWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 122]]}
{"id": "7dtcW2", "name": "CodeGarden Challenge 22 #1", "author": "larserik", "description": "CodeGarden Challenge 22 - Make the CG heart logo with whatever you want", "tags": ["raymarching", "logo", "umbraco", "codegarden"], "likes": 2, "viewed": 233, "published": 3, "date": "1654117225", "time_retrieved": "2024-07-30T16:45:55.576138", "image_code": "// Ray marching code and SDF functions copied from Inigo Quilez and Martijn Steinrucken\n// The MIT License\n// Copyright © 2022 Lars-Erik Aabech\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1, d2);\n}\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\n\nfloat sdBox2( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\nfloat GetDist(vec3 p, out float col) {\n    const float hr = 0.707; // heart raduis\n    const float tr = 0.07; // torus radius\n\n    col = 1.;\n\n    //float d = sdBox(p, vec3(1));\n    // Top right arc\n    vec3 p1 = p;\n    p1.x += .5;\n    p1.y -= .5;\n    p1.xy *= Rot(-0.785);\n    vec2 a = vec2(sin(1.57), cos(1.57));\n    //a = vec2(sin(3.14), cos(3.14));\n    float d1 = sdCappedTorus(p1, a, hr, tr);\n    d1 = opU(d1, sdCapsule(p1, vec3(-hr, 0., 0.), vec3(hr, 0., 0.), tr));\n    \n    // Mid right triangle\n    vec3 p2 = p;\n    p2.x += 1.;\n    p2.y += 0.;\n    float d2 = sdCapsule(p2, vec3(0), vec3(1, 0, 0), tr);\n    d2 = opU(d2, sdCapsule(p2, vec3(0), vec3(1, 1, 0), tr));\n    d2 = opU(d2, sdCapsule(p2, vec3(1, 1, 0), vec3(1, 0, 0), tr));\n\n    \n    // Bottom right triangle\n    vec3 p3 = p;\n    p3.x += 1.;\n    p3.y += 0.;\n    float d3 = sdCapsule(p3, vec3(0), vec3(1, 0, 0), tr);\n    d3 = opU(d3, sdCapsule(p2, vec3(0), vec3(1, -1, 0), tr));\n    d3 = opU(d3, sdCapsule(p2, vec3(1, -1, 0), vec3(1, 0, 0), tr));\n\n    float rightHalf = opU(opU(d1, d2), d3);\n    \n    // Upper left pie\n    vec3 p4 = p;\n    p4.x -= .5;\n    p4.y -= .5;\n    p4.xy *= Rot(.785);\n    float d4 = sdCappedCylinder(p4, vec3(0, 0, .001), vec3(0, 0, -.001), hr);\n    d4 = opSub(sdBox2(p4+vec3(-0,.5,0), vec3(1, .5, .5)), d4);\n    d4 = rounding(d4, tr-.005);\n\n    // Lower left triangle\n    vec3 p5 = p;\n    float d5 = udTriangle(vec3(0), vec3(1, 0, 0), vec3(0, -1, 0), p5) - .001;\n    d5 = rounding(d5, tr-.006);\n\n    float leftHalf = opU(d4, d5);\n    \n    float d = min(rightHalf, leftHalf);\n    \n    if (d == d4) col = 2.;\n    if (d == d5) col = 3.;\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, out float col) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p, col);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float col;\n\tfloat d = GetDist(p, col);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, col),\n        GetDist(p-e.yxy, col),\n        GetDist(p-e.yyx, col)\n    );\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    if (m.x > 0. || m.y > 0.) {\n        m -= .5;\n        m.y *= -1.;\n    }\n\n    vec3 ro = vec3(0, 2, 2);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(.2, .266, .694);\n\n    float colIndex = 0.;\n    float d = RayMarch(ro, rd, colIndex);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        \n        if (colIndex == 1.)\n            col = vec3(colIndex);\n        else if (colIndex == 2.)\n            col = vec3(.96, .756, .737);\n        else if (colIndex == 3.)\n            col = vec3(.615, .5, .341);\n        \n        col = col * dif;\n    }\n    \n    //col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtcW2.jpg", "access": "api", "license": "mit", "functions": [[1316, 1316, 1335, 1335, 1397], [1399, 1399, 1424, 1424, 1443], [1444, 1444, 1469, 1469, 1488], [1490, 1490, 1523, 1523, 1546], [1548, 1548, 1583, 1583, 1605], [1607, 1607, 1636, 1636, 1717], [1719, 1719, 1761, 1761, 1781], [1783, 1783, 1815, 1815, 1902], [1904, 1904, 1974, 1974, 2108], [2110, 2110, 2162, 2162, 2283], [2285, 2285, 2342, 2342, 2678], [2680, 2680, 2747, 2747, 3399], [3401, 3401, 3439, 3439, 5038], [5040, 5040, 5089, 5089, 5305], [5307, 5307, 5331, 5331, 5561], [5563, 5563, 5613, 5613, 5804], [5806, 5806, 5863, 5863, 6813]]}
{"id": "ssdcD2", "name": "my ladder", "author": "jorge2017a2", "description": "my ladder", "tags": ["myladder"], "likes": 12, "viewed": 253, "published": 3, "date": "1654115767", "time_retrieved": "2024-07-30T16:45:56.348074", "image_code": "//----------image\n//por jorge2017a2-\n//my ladder....1-jun-2022\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d/\n//https://iquilezles.org/articles/distfunctions/\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    // base\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    // steps repetition\n#if 1\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float lid = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - lid*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n#else\n    float dia2 = dot(wh,wh);\n    p = mat2(wh.x,-wh.y,wh.y,wh.x)*p;\n    float lid = clamp(round(p.x/dia2),0.0,n-1.0);\n    p.x = p.x - lid*dia2;\n    p = mat2(wh.x,wh.y,-wh.y,wh.x)*p/dia2;\n#endif    \n\n    // single step\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    \n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (lid<0.5 || p.x>0.0) ? p : -p;\n\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\nfloat opScaleEscalera( in vec3 p )\n{   float s=0.125;\n    return sdStairs(p.xy/s, vec2(10.0,10.0), 10.0 )*s;\n}\n\nvec2 DosParedes(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n   float d1=opScaleEscalera( p-vec3(-5.0,5.0,0.0));\n    float d2= sdBox(p-vec3(0.0,15.0,0.0), vec3(10.0,10.0,2.0) );\n    float d3= sdBox(p-vec3(0.0,-4.0,0.0), vec3(7.5,10.0,2.0) );\n    d1= Intersect(d1, d2);\n    d1= Union(d1, d3);\n    res =opU2(res, vec2(d1,100.0));\n    return res;\n}\n\n\nvec2 UnCuarto(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n     p.x=abs(p.x)-5.0;\n    p.z=abs(p.z)-10.0;\n    vec2 dp1= DosParedes(p);\n    p=p0;\n    p.z=abs(p.z)-5.0;\n    p.x=abs(p.x)-10.0;\n    vec2 dp2= DosParedes(p.zyx);\n    res =opU2(res, dp1);\n    res =opU2(res, dp2);\n    return res;\n}    \n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+14.0;  //piso inf\n    p.x=abs(p.x)-12.0;\n    p.z=abs(p.z)-11.0;\n    vec2 uc1= UnCuarto(p);\n    vec2 uc2= UnCuarto(vec3(p.x, -p.y, p.z)-vec3(0.0,-40.0,0.0));\n    res =opU2(res, uc1);\n    res =opU2(res, uc2);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 )\n    { col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, 1.2), 1.0 - rd.y);\n    float d = pow(rd.z+0.3,2.)*pow(rd.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n\t//return sky;\n    return sky*d;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color>=100 ){ return  getColorTextura( p, nor,id_color); }      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=30.0;\n   float veltime=30.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,25.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n    float t;\n    t=mod(iTime*1.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,20.0,-25.0);\n  \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdcD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[603, 603, 635, 635, 719], [722, 722, 766, 766, 793], [794, 794, 834, 834, 861], [862, 862, 907, 907, 935], [937, 937, 973, 973, 1018], [1020, 1020, 1054, 1054, 1150], [1151, 1151, 1185, 1185, 1276], [1277, 1277, 1311, 1311, 1402], [1404, 1404, 1429, 1429, 1448], [1449, 1449, 1474, 1474, 1493], [1494, 1494, 1530, 1530, 1558], [1561, 1561, 1614, 1626, 2506], [2508, 2508, 2544, 2544, 2618], [2620, 2620, 2645, 2645, 2972], [2975, 2975, 2998, 2998, 3271], [3277, 3277, 3302, 3302, 3593], [3595, 3595, 3619, 3619, 3781], [3783, 3783, 3831, 3831, 4110], [4113, 4113, 4157, 4157, 4478], [4480, 4480, 4517, 4517, 4774], [4776, 4776, 4866, 4866, 5826], [5828, 5828, 5877, 5877, 6129], [6133, 6133, 6165, 6165, 6456], [6458, 6458, 6528, 6528, 6623], [6625, 6625, 6652, 6652, 6741], [6743, 6743, 6801, 6801, 6849], [6851, 6851, 6874, 6874, 6986], [6988, 6988, 7019, 7019, 7648], [7650, 7650, 7687, 7687, 7957], [7960, 7960, 8017, 8017, 8517]]}
{"id": "sstyW2", "name": "Hexler hexes", "author": "mrange", "description": "License CC0: Hexler hexes\nI like Hexler's kodelife. When I go to their homepage they often\nhave an image of repeated hexes. \nThis is the result of short hack to try to recreate it\n\n", "tags": ["2d", "hexler"], "likes": 17, "viewed": 456, "published": 3, "date": "1654107632", "time_retrieved": "2024-07-30T16:45:57.135968", "image_code": "// License CC0: Hexler hexes\n//  I like Hexler's kodelife. When I go to their homepage they often\n//  have an image of repeated hexes. \n//  This is the result of short hack to try to recreate it\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  \n  vec2 pp = toPolar(p);\n  float a = pp.y;\n  float hn = mod1(pp.y, TAU/6.0);\n  vec2 hp = toRect(pp);\n  \n  float x = hp.x;\n  float w = mix(0.03, 0.1, 0.5+0.5*cos(sqrt(0.5)*0.125*TIME));\n  float n = mod1(x, w);\n  float d = abs(x)-(0.5*w-aa);\n  \n  float h0 = hash(n+1.234);\n  float h1 = hash(n+2.345);\n  float cut = mix(-0.5, 0.999, 0.5+0.5*sin(TIME+TAU*h0));\n  const float coln = 6.0;\n  vec3 col = hsv2rgb(vec3(0.1*TIME+floor(h0*coln)/coln, 0.9, 1.0))*smoothstep(aa, -aa, d)*smoothstep(cut, cut-0.005, sin(a+2.0*(h1-0.5)*TIME+h1*TAU));\n\n  col = sqrt(col);\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstyW2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[469, 469, 491, 491, 637], [932, 992, 1014, 1014, 1062], [1064, 1150, 1189, 1189, 1314], [1316, 1404, 1426, 1426, 1470], [1472, 1560, 1581, 1581, 1626], [1628, 1628, 1684, 1684, 2401]]}
{"id": "slBBDh", "name": "Some Spheres", "author": "droidkid", "description": "Trying out ray marching. Animated 3 spheres.", "tags": ["raymarching", "learning"], "likes": 2, "viewed": 196, "published": 3, "date": "1654103454", "time_retrieved": "2024-07-30T16:45:57.873994", "image_code": "vec2 opU(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(length(p-vec3(0.0, 0.2 + cos(iTime) * 0.05, 0.0 + sin(iTime)*0.02)) - 0.2, 0.05);\n    d = opU(d, vec2(length(p-vec3(0.5, 0.05 + sin(1.4*iTime+2.0)*0.03, 0.0 + cos(iTime)*0.03)) - 0.1, 2.2));\n    d = opU(d, vec2(length(p-vec3(-0.4 + cos(iTime) * 0.02, 0.1 + sin(iTime)*0.01, 0.1* sin(3.0*iTime)*0.3)) - 0.1, 0.8));\n    \n    d = opU(d, vec2(sdBox(p - vec3(0.0, 0.0, 0.5), vec3(2.1, 3.1, 0.1)), 0.7));\n    d = opU(d, vec2(sdBox(p - vec3(0.0, -0.3, 0.0), vec3(2.1, 0.1, 2.1)), 0.6));\n\n    return d;\n}\n\nfloat shadow(vec3 p, vec3 light) {\n    vec3 ro = p;\n    vec3 rd = normalize(light-p);\n    \n    float tmin = 0.21;\n    float t = tmin;\n    int maxSteps = 700;\n    \n    float res = 1.0;\n    for (int i=0; i<maxSteps; i++) {\n            vec3 p = ro + t*rd;\n            vec2 h = map(p);\n            if (h.x < 0.0001) {\n                return 0.0;\n            }\n            res = min(res, 32.0*h.x/t);\n            t += h.x;\n    }\n    return res;\n\n}\n\nvec3 calcNormal(vec3 p) {\n    vec3 d = vec3(0.0001, 0.0, 0.0);\n    \n    float dx = (map(p + d.xyy) - map(p - d.xyy)).x;\n    float dy = (map(p + d.yxy) - map(p - d.yxy)).x;\n    float dz = (map(p + d.yyx) - map(p - d.yyx)).x;\n\n    return normalize(vec3(dx, dy, dz));\n}\n\nmat3 setUpCamera(vec3 camera_pos, vec3 camera_target, float angle) {\n\tvec3 up = vec3(sin(angle), cos(angle), 0.0);\n\tvec3 cz = normalize(camera_target - camera_pos);\n\tvec3 cx = normalize(cross(up, cz));\n\tvec3 cy = normalize(cross(cz, cx));\n\treturn mat3(cx, cy, cz);\n}\n\nvec2 rayCast(vec3 ro, vec3 rd) {\n    float tmin = 0.1;\n    float tmax = 200.0;\n    float t = tmin;\n    int maxSteps = 70;\n    \n    vec2 res = vec2(-1.0, -7.0);\n    \n    for (int i=0; i<maxSteps && t<tmax; i++) {\n            vec3 p = ro + t*rd;\n            vec2 h = map(p);\n            if (h.x < 0.0001) {\n                res = vec2(t, h.y);\n                break;\n            }\n            t += h.x;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3(0.0, 0.1, -1.0);\n    vec3 ta = vec3(0.0, 0.1, 0.0);\n    mat3 camera = setUpCamera(ro, ta, 0.0);\n    float fo = 2.5;\n    \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 rd = camera * normalize(vec3(uv, fo));\n    \n    vec2 h = rayCast(ro, rd);\n    if (h.y < 0.0) {\n        fragColor = vec4(0.0);\n        return;\n     }\n     \n     vec3 light = vec3(0.5, 0.5, -1.0);\n     vec3 point = ro + rd * h.x;\n     vec3 ld = normalize(light-point);\n     vec3 normal = calcNormal(point);\n     \n     vec3 color = pallete(h.y) * max(0.0, dot(normal, ld));\n     \n     // specular\n     vec3 hf = normalize(normal + ld);\n     color += vec3(0.5) * pow(dot(normal, hf), 1000.0);\n     \n     color = shadow(point, light) * color;\n     \n     // gamma correction\n     color = pow( color, vec3(0.4545) );\n     \n     fragColor = vec4(color, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBBDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 66], [68, 68, 91, 91, 246], [248, 248, 279, 279, 366], [369, 369, 387, 387, 902], [904, 904, 938, 938, 1346], [1348, 1348, 1373, 1373, 1614], [1616, 1616, 1684, 1684, 1882], [1884, 1884, 1916, 1916, 2307], [2309, 2309, 2366, 2366, 3234]]}
{"id": "sddyWj", "name": "marching triangle on img: phase", "author": "FabriceNeyret2", "description": "marching cube/square/triangle is sensitive to phase, i.e. offset of the sampling grid.\n→ averaging of 9 different offsets so that grey shows the variance.\nClick for outlines instead.", "tags": ["short", "marchingsquare", "marchingcube", "vectorization"], "likes": 11, "viewed": 384, "published": 3, "date": "1654096845", "time_retrieved": "2024-07-30T16:45:58.623989", "image_code": "// variant of https://shadertoy.com/view/7d3yWS\n// variant of https://shadertoy.com/view/fddyRs\n// using marching triangles https://www.shadertoy.com/view/fdccDB\n int lod = 5;\n float thresh = .6;\n \n#define T(U)  textureLod(iChannel0, U*R.y/R , float(lod-3) ).r // or lod=0 for fun\n#define G(uv) ( ( (floor(U) + uv) *mat2(1,.5,0,.86) +d ) *Z/1024. )\n#define S(v) smoothstep( -.8,.8,(iMouse.z>0.?abs(v):v)/fwidth(v) ) // antialiasing draw\n\nfloat vector(vec2 U, vec2 d )\n{\n    float Z = exp2(float(lod));                           // scaling\n    vec2  v, R = iResolution.xy; \n    U *= 1024./Z/R.y;\n    d *= Z/288.;\n    U -= d;\n    float O = 0.;                                         // --- marching triangle -------\n    U *= mat2(1,-1./1.73, 0,2./1.73);                     // conversion to\n    vec3 g = vec3(U, 1.-U.x-U.y);                         // hexagonal coordinates\n\tg = fract(g);                                         // diamond coords\n    bool side = length(g)>1.;                             // tri: which diamond half\n \n    vec3 V = side ? vec3( T(G(vec2(1))), T(G(vec2(0,1))), T(G(vec2(1,0))) ) // samples at corder\n                  : vec3( T(G(vec2(0))), T(G(vec2(1,0))), T(G(vec2(0,1))) );\n    if (side) g = 1.-g;                                   // barycentric coordinates\n    O = S( (1.-g.x-g.y)*V.x + g.x*V.y + g.y*V.z - thresh );\n    return O;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{   \n    O-=O;\n    for ( int k=0; k<9; k++ )\n        O += vector( U, vec2(k%3-1, k/3-1)*2. ) /9.;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 438, 469, 469, 1367], [1369, 1369, 1407, 1407, 1505]]}
{"id": "7styWj", "name": "marching triangle on images: LOD", "author": "FabriceNeyret2", "description": "contrary to marching-cube, for marching triangles we must rely on less well-defined image smoothing to fit the sampling rate at vertices.\nLower LOD: some noise and thus details. Larger LOD: smooths more.\n→ blend all LOD offsets -3 to +1. click for outline", "tags": ["short", "marchingsquare", "marchingcube", "vectorization"], "likes": 9, "viewed": 291, "published": 3, "date": "1654095076", "time_retrieved": "2024-07-30T16:45:59.378971", "image_code": "// variant of https://shadertoy.com/view/7d3yWS\n// variant of https://shadertoy.com/view/fddyRs\n// using marching triangles https://www.shadertoy.com/view/fdccDB\n int lod = 5;\n float thresh = .5;\n \n#define T(U)  textureLod(iChannel0, U*R.y/R , float(lod-delta) ).r // or lod=0 for fun\n#define G(uv) ( ( (floor(U) + uv) *mat2(1,.5,0,.86) ) *Z/1024. )\n#define S(v) smoothstep( -.8,.8,(iMouse.z>0.?abs(v):v)/fwidth(v) ) // antialiasing draw\n\nfloat vector(vec2 U, int delta)\n{\n    float Z = exp2(float(lod));                           // scaling\n    vec2  v, R = iResolution.xy;\n    float O = 0.;                                         // --- marching triangle -------\n    U *= mat2(1,-1./1.73, 0,2./1.73) *1024./Z/R.y;        // conversion to\n    vec3 g = vec3(U, 1.-U.x-U.y);                         // hexagonal coordinates\n\tg = fract(g);                                         // diamond coords\n    bool side = length(g)>1.;                             // tri: which diamond half\n \n    vec3 V = side ? vec3( T(G(vec2(1))), T(G(vec2(0,1))), T(G(vec2(1,0))) ) // samples at corder\n                  : vec3( T(G(vec2(0))), T(G(vec2(1,0))), T(G(vec2(0,1))) );\n    if (side) g = 1.-g;                                   // barycentric coordinates\n    O = S( (1.-g.x-g.y)*V.x + g.x*V.y + g.y*V.z - thresh );\n    return O;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{   \n    O = vec4( vector(U,3) + vector(U,2) + vector(U,1) + vector(U,0)  + vector(U,-1) ) / 5.;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7styWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 439, 472, 472, 1318], [1320, 1320, 1358, 1358, 1455]]}
{"id": "Nd3yRX", "name": "Multisample Raycaster", "author": "Shane", "description": "A realtime path traced square prism grid traversal using IQ's temporal reprojection routine to give the appearance of a higher sample count.", "tags": ["grid", "raycasting", "global", "illumination", "pathtracing", "city", "multisample", "reprojection", "emitter"], "likes": 86, "viewed": 2186, "published": 3, "date": "1654086595", "time_retrieved": "2024-07-30T16:46:00.302502", "image_code": "/*\n\n    Multisample Raycaster\n    ---------------------\n\n    See \"Buffer A\" for an explanation.\n\n*/\n\n\n// The following is based on John Hable's Uncharted 2 tone mapping, which\n// I feel does a really good job at toning down the high color frequencies\n// whilst leaving the essence of the gamma corrected linear image intact.\n//\n// To arrive at this non-tweakable overly simplified formula, I've plugged\n// in the most basic settings that work with scenes like this, then cut things\n// right back. Anyway, if you want to read about the extended formula, here\n// it is.\n//\n// http://filmicworlds.com/blog/filmic-tonemapping-with-piecewise-power-curves/\n// A nice rounded article to read. \n// https://64.github.io/tonemapping/#uncharted-2\nvec4 uTone(vec4 x){\n    return ((x*(x*.6 + .1) + .004)/(x*(x*.6 + 1.)  + .06) - .0667)*1.933526;    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // The other buffer has a maximum Y-resolution of 540 set, which \n    // means any pixels outside that are not rendered. On a 1980x1080\n    // fullscreen resolution, this means roughly a quarter of the pixels\n    // are rendered, which is a huge saving. Of course, this also means\n    // that the scene needs to be upscaled, which will make things less\n    // crisp, but you can't have everything. :)\n    //\n    // By the way, this tip came from Shadertoy user, spalmer, who has\n    // a heap of interesting work for anyone interested:\n    // https://www.shadertoy.com/user/spalmer\n    //\n    float maxRes = iResolution.y;//540.;\n    vec2 uv = fragCoord/iResolution.xy;\n    // If the resolution exceeds the maximum, upscale.\n    if(iResolution.y>maxRes) uv = (fragCoord/iResolution.xy - .5)*maxRes/iResolution.y + .5;\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, uv);\n   \n    // Toning down the high frequency values. A simple Reinhard toner would \n    // get the job done, but I've dropped in a heavily modified and trimmed \n    // down Uncharted 2 tone mapping formula.\n    // mapping functio.\n    col = uTone(col); \n    \n    // Subtle vignette.\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.);\n    \n  \n    // Rough gamma correction and screen presentation.\n    fragColor = pow(max(col, 0.), vec4(1./2.2));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Multisample Raycaster\n    ---------------------\n    \n    This is a realtime path traced cell by cell square grid traversal. The scene \n    is lit entirely by rendered square emitters on the sides of the square prisms\n    and a small portion of atmospheric haze. No Blinn-Phong was harmed during the \n    making of this shader. :D\n    \n    I've been meaning to post one of these for a while. Individually, all the \n    concepts involved are pretty simple. However, tying them all together involves \n    more thinking than I enjoy, so I've been procrastinating on it for a while. :)\n    \n    Since this is realtime path tracing, things aren't going to be perfect on an\n    average system -- and apologies in advance for those with slower systems. A \n    basic static path traced scene normally takes seconds to minutes to produce in \n    a fast application like Blender, but realtime requirements only allow for a \n    fraction of a second per frame, so perfect quality is a big ask.\n    \n    Realtime path traced cell by cell traversals are not common, but they're \n    nothing new, and there's even a few examples on Shadertoy -- By the way, check \n    out 0b5vr's work on here, if you're into this kind of thing. A lot of realtime \n    path traced examples that have been appearing in demo competitions feel like \n    they're based on W23's \"past racer by jetlag\" engine, which is fair enough, as \n    it lends itself well to that kind of thing. This particular example was coded \n    off the top of my head, and uses simple traditional techniques that have been \n    around for ages. The grid traversal code is also standard and the very simple \n    emitter and throughput lighting code is as basic as it gets.\n    \n    As mentioned in other examples, the only genuinely interesting thing is the use \n    of IQ's temporal reprojection code. Under the right circumstances it can give \n    the appearance of a huge sample boost.\n    \n    In regard to scene design, there is none. It's a textured square grid with some \n    tiny colored squares painted on the sides and some dark edging. That's the \n    beauty of path traced light emitters. Once everything's in place, the algorithm \n    does a lot of the aesthetic work for you.\n    \n    \n    \n    Other examples:\n    \n    // A lot of the realtime path tracing demos out there\n    // are based on elements from this example.\n    past racer by jetlag - w23\n    https://www.shadertoy.com/view/Wts3W7\n    \n    // Like everyone else, I really like this example.\n    20210930_CLUB-CAVE-09 - 0b5vr\n    https://www.shadertoy.com/view/ss3SD8\n    \n    // Path tracing a heap of boxes in realtime with the help of camera\n    // reprojection -- It's one of IQ's many understated examples that \n    // does something amazing.\n    Some boxes - iq\n    https://www.shadertoy.com/view/Xd2fzR\n\n\n*/\n\n\n// Unfortunately, if you have a slow machine IQ's temporal reprojection option\n// will usually result in blur. Regular accumulation might work, but you'll \n// probably have to use straight samples (BUFF_ACCUM 0).\n// Buffer accumulation style:\n// 0: No accumulation -- Noisy, sharper picture, but with no blur. \n// 1: Regular accumulation with no reprojection -- A mixture.\n// 2: Temporal reprojection. -- Smoother for faster machines.\n#define BUFF_ACCUM 2\n\n\n// Far plane. I've kept it close.\n#define FAR 25.\n\n\n///////////////\n\n// Random seed value.\nvec2 seed = vec2(.13, .27);\n\n// Basic random function.\nvec3 rnd23() {\n    \n    //seed += vec2(.723, .647);\n    //return texture(iChannel2, seed*43266.1341).xyz;\n    \n    seed = fract(seed + vec2(.723, .647));\n    vec3 p = vec3(dot(seed.xy, vec2(12.989, 78.233)), \n                          dot(seed.xy, vec2(41.898, 57.267)),\n                          dot(seed.xy, vec2(65.746, 83.765)));\n                          \n    return fract(sin(p)*vec3(43758.5453, 23421.6361, 34266.8747));\n    \n}\n\n// Basic random function. Not a lot of thought was put into it. Using one of\n// the more reliable positive integer based ones might be better... Common sense\n// would dictate that integers work faster, but on a GPU, I'm not really sure.\nvec2 hash22() {\n    \n    //seed += vec2(.723, .647);\n    //return texture(iChannel2, seed*43266.1341).xy;\n    \n    seed = fract(seed + vec2(.723, .647));\n    return fract(sin(vec2(dot(seed.xy, vec2(12.989, 78.233)), dot(seed.xy, vec2(41.898, 57.263))))\n                    *vec2(43758.5453, 23421.6361));\n}\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\nfloat hash31(in vec3 p){ return fract(sin(dot(p, vec3(91.537, 151.761, 72.453)))*435758.5453); }\n\n\n \n// A nice random hemispherical routine taken out of one of IQ's examples.\n// The routine itself was written by Fizzer.\nvec3 cosDir( in float seed, in vec3 n){\n\n    vec2 rnd = hash22();\n    float u = rnd.x;\n    float v = rnd.y;\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853*v;\n    u = 2.*u - 1.;\n    return normalize(n + vec3(sqrt(1. - u*u)*vec2(cos(a), sin(a)), u));\n    \n}\n\n////////////////\n\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Rectangle scale. Smaller scales mean smaller squares, thus more of\n// them. Sometimes, people (including myself) will confuse matters\n// and use the inverse number. :)\nvec2 s = vec2(1, 1)/2.; \n\n // Ray origin, ray direction, point on the line, normal. \nfloat rayLine(vec2 ro, vec2 rd, vec2 p, vec2 n){\n   \n   // This it trimmed down, and can be trimmed down more. Note that \n   // \"1./dot(rd, n)\" can be precalculated outside the loop. However,\n   // this isn't a GPU intensive example, so it doesn't matter here.\n   return dot(p - ro, n)/dot(rd, n);\n\n}\n\n// Grid cell function.\nvec2 gridID(vec2 p){\n    // Using the rectangle's center position for the ID. \n    return floor(p/s) + .5;\n\n}\n\n\nfloat h(vec2 p){\n\n    // Only one texture read.\n    vec3 tx = texture(iChannel0, p/iChannelResolution[0].xy*4.).xyz;  tx *= tx;///iChannelResolution[0].xy\n    // Greyscale height. Using \"tx.x\" would work, too.\n\tfloat f = dot(tx, vec3(.299, .587, .114));\n    float f2 = f;\n    \n    //f = sin(f*6.2831 + iTime)*.5 + .5;\n    \n    f *= min(p.x*p.x/16., 1.);\n    \n    return floor((f*12. + f2*4.)*8.)/8.;\n\n}\n \n// A standard square cell by cell traversal. Not optimized enough for path tracing\n// purposes, but it's reasonable quick otherwise.\nvec4 raycast(vec3 ro, vec3 rd){\n   \n    // Initial result.\n    vec4 res = vec4(FAR, 0, 0, 0);\n    \n    // Rectangle normals: Any two will do. By the way, there's nothing\n    // stopping you from declaring all four normals for all surrounding\n    // walls, but since you know only two will be in front of the\n    // direction ray at any given time, it makes sense to only choose\n    // two.\n    //\n    // Declare two normals. Any side by side ones will do.\n    vec2 n1 = vec2(-1, 0), n2 = vec2(0, -1); // Right and top edges.\n    \n    // If the cell wall is behind the ray (or the ray is facing the opposing cell\n    // wall, if you prefer), use the normal index from the back cell wall. This \n    // trick is possible because of the rectangle symmetry. As an aside, for \n    // anyone who doesn't know, dotting the direction ray with the face normal \n    // is something you do in software engines for back face culling.\n    float d1 = dot(rd.xz, n1);\n    float d2 = dot(rd.xz, n2);\n    n1 = d1<0.? -n1 : n1;\n    n2 = d2<0.? -n2 : n2;\n    \n    // Initiate the ray position at the ray origin.\n    vec3 pos = ro;\n    \n    // Obtain the coordinates of the cell that the current ray position \n    // is contained in -- I've arranged for the cell coordinates to \n    // represent the cell center to make things easier.\n    vec2 ip = gridID(pos.xz);\n    \n    float t1 = 1e8, t2 = 1e8, tT = 1e8;\n    \n    int hit = 0;\n    \n    \n    // Iterate through 24 cells -- Obviously, if the cells were smaller,\n    // you'd need more to cover the distance.\n    for(int i = 0; i<64; i++){ \n\n         \n        // Height. \n        float ma = h(ip*s);\n        \n         \n        // At this point, we haven't advanced the ray to the back of the cell boundary,\n        // so we're at one of the front cell face positions. Therefore, check to see if \n        // we're under the pylon height. If so, we've hit a face, so mark the face as hit, \n        // then break.\n        if(pos.y<ma){\n            // Hit a side.\n            hit = 1;\n            break; \n        \n        } \n        \n        // Ray intersection from the currect cell position to each of the \n        // visible cell walls. Normals face inward.\n        // You pass in the current position, the unit direction ray, a known \n        // point on the cell wall (any will do) and the cell wall's normal.\n        t1 = rayLine(pos.xz, rd.xz, (ip + n1*.5)*s, -n1);\n        t2 = rayLine(pos.xz, rd.xz, (ip + n2*.5)*s, -n2);\n        \n        // Determine the closest edge then record the closest distance and\n        // asign its normal index.\n        vec3 tn = t1<t2? vec3(t1, n1) : vec3(t2, n2);\n        \n        // Top face distance.\n        tT = (ma - pos.y)/rd.y;\n        tT = tT<0. ? 1e8 : tT;\n        \n        \n        // We've now advanced to one of the back faces of the cell. Check to see whether\n        // we're still under the pylon height, and if so, we've hit the top face --  \n        // I always have to think about this, but the logic is that we haven't hit a front\n        // cell face and we're still under the height, so we've hit the top. Anyway, mark \n        // the top face as hit, advance the distance in the Y direction to the top face, \n        // then break.\n        if(tT<tn.x){\n            \n            //dist += tT;\n            pos += rd*tT; \n            hit = 2;\n            break;\n             \n        }      \n         \n    \n        // If this cell's ID matches the ID of the backgound cell, \n        // flag it as hit in order to color it, or whatever.\n        //if(length(cell - ip)<.001){ hit = 1; break; }\n        \n        // Advance the cell index position by the indices of the \n        // cell wall normal that you hit. \n        ip += tn.yz;\n        // Advance the ray position by the distance to the next cell wall.\n        pos += rd*tn.x;\n    \n    }\n    \n    float fID = tT<t1 && tT<t2? 0. : t1<t2? 1. : 2.;\n    if(fID == 1.){ fID = d1<0.? -fID : fID; }\n    else if(fID == 2.){ fID = d2<0.? -fID : fID; }\n    \n    res.x = length(pos - ro);\n    if(hit == 0) res.x = FAR;\n    \n    return vec4(res.x, fID, ip);\n    \n}\n\n// Standard normal function.\nvec3 nr(float fID, vec3 rd) {\n\t\n    vec3 n = fID == 0.? vec3(0, 1, 0) : abs(fID) == 1.? vec3(1, 0, 0) : vec3(0, 0, 1);\n    //if(fID == 1.) n = dot(rd.xz, n.xz)<0.? -n : n;\n    //if(fID == 2.) n = dot(rd.xz, n.xz)<0.? -n : n;\n    n *= fID<-.001? -1. : 1.; \n\treturn n;\n}\n\n// mat3 rotation... I did this in a hurry, but I think it's right. :)\n// I have a much better one than this somewhere. \nmat3 rot(vec3 ang){\n    \n    vec3 c = cos(ang), s = sin(ang);\n\n    return mat3(c.x*c.z - s.x*s.y*s.z, -s.x*c.y, -c.x*s.z - s.x*s.y*c.z,\n                c.x*s.y*s.z + s.x*c.z, c.x*c.y, c.x*s.y*c.z - s.x*s.z,\n                c.y*s.z, -s.y, c.y*c.z);    \n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\n\n\n    #if BUFF_ACCUM == 2\n    // Initial hit point and distance.\n    vec3 resPos = vec3(0);\n    float resT = 0.;\n    #endif\n\n    // Screen pixel coordinates.\n    vec2 uv0 = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n\n    // Initializing the seed value. It needs to be different every frame.\n    seed = uv0 + vec2(fract(iTime/113.671)*.123, fract(iTime/57.913)*.14527);\n    \n    // Ray origin.\n    vec3 ro = vec3(-s.x/2., 3.5, iTime*.25); \n    // Setting the camera to the ray origin. The ray origin vector will change\n    // from bounce to bounce, so we'll need a record of the initial camera position.\n    vec3 cam = ro;\n    \n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    \n    // Lazy identity camera -- No to and from. I might update it later.\n    mat3 mCam = mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\n\n \n    mCam *= rot(vec3(0, 0, cos(iTime/8.*.25)/4.)); // Camera yaw.\n    mCam *= rot(vec3(-sin(iTime/4.*.25)/8., 0, 0)); // Camera roll.\n    mCam *= rot(vec3(0, .5, 0)); // Y axis tilt, or pitch.\n    \n/*\n    // Artistic black movie strips. 20% faster elite democoder move. :D\n    if(abs(uv0.y)>.4) { \n        ivec2 q = ivec2(fragCoord);\n        vec4 c = vec4(0, 0, 0, 1); \n    \tif(q.y == 0 && q.x<3){\n    \n    \t// Camera matrix in lower left three pixels, for next frame.\n        if(q.x == 0) c = vec4(mCam[0], -dot(mCam[0], cam));\n        else if(q.x == 1) c = vec4( mCam[1], -dot(mCam[1], cam));\n        else c = vec4( mCam[2], -dot(mCam[2], cam));\n        } \n        fragColor = c;\n        return; \n    }\n*/\n    \n    // Accumulative color and sample number. 8 is all that my computer can \n    // handle. Some computers would be able to handle more and others less.\n    vec3 atot = vec3(0);\n    const int sampNum = 8;\n    \n    for(int j = min(0, iFrame); j<sampNum; j++){\n    \n    \n        //vec2 jit = vec2(hash21(uv0 + seed + vec2(j, j + 1)), \n        //                hash21(uv0 - seed + vec2(j + 5, j + 7))) - .5;\n        \n        vec2 jit = hash22() - .5;\n                        \n        vec2 uv = uv0 + jit/iResolution.y;\n    \n        // Unit direction vector.\n        vec3 rd = mCam*normalize(vec3(uv, 1./FOV)); \n        \n        // Depth of field. I hacked this in as an afterthought... It seems\n        // about right, but I'll have to take a closer look later.\n        float fDist = 6.;\n        vec2 jitDOF = hash22()*2. - 1.;\n        vec3 vDOF = mCam*vec3(jitDOF, 0.)*.035;\n        rd = normalize(rd - vDOF/fDist);\n        ro = cam + vDOF;\n        \n        // Accumulative, and thoughput.\n        vec3 acc = vec3(0);\n        \n        vec3 through = vec3(1);\n\n        // First hit distance. It's used for fog, amongst other things.\n        float t0; \n        \n  \n        for(int i = min(0, iFrame); i<3; i++){\n\n            // Raycasting\n            vec4 res = raycast(ro, rd);\n\n            float t = res.x, d;\n            float fID = res.y;\n            vec2 id = res.zw;\n\n            t = min(t, FAR); // Clipping to the far distance, which helps avoid artifacts.\n\n            if(i == 0) t0 = t; // Recording the first hit distance.\n\n\n            // Hit point.\n            vec3 p = ro + rd*t;\n            \n            #if BUFF_ACCUM == 2\n            if(i==0){\n                // Only save the initial hit point and distance. Ignore other bounces.\n                resPos += p/float(sampNum); // Accumulative position.\n                resT += t/float(sampNum); // Accumulative distance.\n            }\n            #endif\n\n            // If we've hit an object, light it up.\n            if(t<FAR - 1e-6){\n            \n                \n                // Surface normal.\n                vec3 n = nr(fID, rd);\n\n                // Scene object color.\n                //\n                // Texture coordinates, based on a cube mapping routine.\n                vec2 tuv = fID == 0.? p.xz : abs(fID) == 1.? p.zy : p.xy;\n                vec3 tx = texture(iChannel1, tuv/3.).xyz; tx *= tx;\n\n                vec3 oCol = .125 + tx*2.5;\n\n\n                // Edging routine.\n                float h0 = h(id*s); // Square prism height.\n\n                float minEdge = min(s.x, s.y)/4.;\n                float edge = s.y/4.;\n                float edge2 = s.x/4.;\n\n                // Local coordinates.\n                vec2 lc = p.xz - id*s;\n                // Domain.\n                vec2 ap = abs(lc) - s/2.;\n                // Face edges.\n                float fEdge = max(ap.x, ap.y);\n                fEdge = abs(fEdge);\n                fEdge = max(fEdge, -(p.y - h0)) - .015;\n                // Side edges.\n                float sEdge = min(ap.x, ap.y);\n                sEdge = max(-sEdge, (p.y - h0)) - .015;\n                // Combining.\n                fEdge = min(fEdge, sEdge);\n\n                // Smoothing facor... Not even sure if it's needed in a multisample\n                // example, but it's here anyway.\n                float sf = .001*(1. + res.x*res.x*.1);\n                \n                // Edge rendering.\n                oCol = mix(oCol, vec3(0), (1. - smoothstep(0., sf, fEdge))*.85);\n\n                // Window stips.\n                float strip = abs(p.y - h0 + 2./8.) - 1./8.;\n                oCol = mix(oCol, vec3(0), (1. - smoothstep(0., sf, abs(strip) - .02/2.))*.85);\n\n                // Top face markings, for debug purposes.\n                //c.xyz = mix(c.xyz, vec3(0), 1. - smoothstep(0., sf, length(p.xz - id*s) - .05));\n\n                // Windows.\n                vec2 tip = floor(tuv*8.);\n                vec2 tup = abs(tuv - (tip + .5)/8.);\n                float sq = max(tup.x, tup.y) - .5/8.;\n\n                // Surface roughness. Larger values are duller in appearance, and lower\n                // values are more relective.\n                float rough = .9;\n\n                // Substance emissive color. Initialized to zero.\n                vec3 emissive = vec3(0);\n                \n                // If we hit square prism strip, color random windows and set their emission color. \n                if(strip<.0){\n                //if(hash21(id +.1)<.25 && strip<0.){\n                    \n                    // Render random square frames.\n                    oCol = mix(oCol, vec3(0), (1. - smoothstep(0., sf*8., abs(sq) - .01/2.))*.85);\n                \n                    // Random window color.\n                    vec3 eCol = .5 + .45*cos(6.2831*hash21(tip +.17)/5. + vec3(0, 1.4, 2));\n\n                    // Random emissive color.\n                    emissive = oCol*eCol; // Warm hues.\n                    if(hash21(id +.2)<.5) emissive = oCol*eCol.zyx; // Random cool hues.\n                    // Applying some random green.\n                    emissive = mix(emissive, emissive.xzy, floor(hash21(tip +.42)*4.999)/4.*.35);\n                    // Pink. Too much.\n                    //if(hash21(tip +.33)<.1) emissive = oCol*mix(oCol, eCol.xzy, .5);\n\n                    // Randomly turn lights on and off for some visual interest.\n                    float blink = smoothstep(.2, .3, sin(6.2831*hash21(tip + .09) + iTime/4.)*.5 + .5);\n                    emissive *= mix(1., 0., blink);\n                 \n                    // Ramp up the emissive power.\n                    emissive *= 8.; \n                    \n                    // Make the windows less rough, and randomize a bit.\n                    rough = hash21(tip + .21)*.75;\n                }\n                else {\n                    // Subtly Color the pylons outside the strips.\n                    oCol *= (1. + .25*cos(hash21(id + .06)*6.2831/4. + vec3(0, 1, 2)));\n                }\n                 \n                // Applying the edging to the emission value. You don't have to, but it looks better. \n                emissive = mix(emissive, vec3(0), (1. - smoothstep(0., sf, fEdge))*.95);\n\n                // Tapering emission into the distance.\n                //emissive = mix(emissive, vec4(0), smoothstep(.25, .99, t0/FAR));\n\n                // If an emissive sustance has been hit, use it to light the surface.\n                acc += emissive*through;\n                through *= oCol; // Integrate colors from previous surfaces. \n\n                \n                vec3 ref = reflect(rd, n); // Purely reflected vector.\n                vec3 rrd = cosDir(0., n); // Random half hemisphere vector.\n\n                // Mimicking surface inconsistancies with fuzzy reflections.\n                // Rougher surfaces have a greater chance of random reflecting at any direction and\n                // smoother surfaces are more likely to purely reflect.\n                float rChance = step(0., rough - hash21(uv + vec2(i*277, j*113) + fract(iTime*.97 + .137)));\n                rd = (mix(ref, rrd, rChance));\n                // Other variations. Not physically correct, but they have their purposes.\n                //float rChance = rough*hash21(uv + vec2(i*277, j*113) + fract(iTime*.97 + .137));\n                //rd = normalize(ref + rrd*rChance);\n                //rd = normalize(mix(ref, rrd, rough));\n                //rd = normalize(ref + normalize(rnd23() - .5)*rChance);             \n                //rd = normalize(ref + rrd*rough);\n\n                // Bump the ray off of the hit surface to avoid self collision.\n                ro = p + n*.001;\n\n            }\n            else { \n                // If the scene hasn't been hit, add a touch of atmospheric haze, then exit.\n                // Depending what you're after, you could include the throughput also --\n                // Infact, for some situations, I'm pretty sure you need it:\n                //acc += through*vec3(.4, .6, 1)*.05;\n                acc += vec3(.4, .6, 1)*.035;\n                break;\n            }\n\n    \n        }\n       \n        // Very simple sky fog, or whatever. Not really the way you apply atmosphere in a \n        // path tracer, but way, way cheaper. :)\n        vec3 sky = mix(vec3(1, .7, .5), vec3(.4, .6, 1), uv0.y*2.5 - .15)*1.5;//vec4(.6, .75, 1, 0)/.6\n        //sky *= fBm((cam + r*t0)*128.)*2.;\n        acc = mix(acc, sky, smoothstep(.35, .99, t0/FAR));\n        \n        \n        // Add this sample to the running total.\n        atot += acc;\n        \n    }\n    \n    vec3 col = atot/float(sampNum);\n    \n    \n    \n    // This is IQ's temporal reprojection code: It's well written and\n    // it makes sense. I wrote some 2D reprojection code and was not\n    // looking forward to writing the 3D version, and then this \n    // suddenly appeared on Shadertoy. If you're interested in rigid \n    // realtime path traced scenes with slowly moving cameras, this is \n    // much appreciated. :)\n    //\n    #if BUFF_ACCUM == 2\n    //-----------------------------------------------\n\t// Reproject to previous frame and pull history.\n    //-----------------------------------------------\n    \n    float kFocLen = 1./FOV;\n    vec3 pos = resPos;\n    ivec2 q = ivec2(fragCoord);\n    col = clamp(col, 0., 1.);\n\n    // Fetch previous camera matrix from the bottom left three pixels.\n    mat3x4 oldCam = mat3x4(texelFetch(iChannel3, ivec2(0, 0), 0),\n                           texelFetch(iChannel3, ivec2(1, 0), 0),\n                           texelFetch(iChannel3, ivec2(2, 0), 0));\n    // World space point.\n    vec4 wpos = vec4(pos, 1.);\n    // Convert to camera space (note inverse multiply).\n    vec3 cpos = wpos*oldCam;\n    // Convert to NDC space (project).\n    vec2 npos = (kFocLen*2.)*cpos.xy/cpos.z;//*iRes/iResolution.y;\n    // Convert to screen space.\n    vec2 spos = .5 + .5*npos*vec2(iResolution.y/iResolution.x, 1);\n\t// Convert to raster space.\n    vec2 rpos = spos*iResolution.xy;\n\n    // Read color+depth from this point's previous screen location.\n    vec4 ocolt = textureLod(iChannel3, spos, 0.);\n    // If we consider the data contains the history for this point.\n    if(iFrame>0 && resT<FAR && (rpos.y>1.5 ||rpos.x>3.5)){\n    \n        // Blend with history (it's an IIR low pas filter really).\n        col = mix( ocolt.xyz, col, 1./8.);\n    }\n    \n    // Color and depth.\n    fragColor = vec4(col, resT);\n    \n    // Output.\n\tif(q.y == 0 && q.x<3){\n    \n    \t// Camera matrix in lower left three pixels, for next frame.\n        if(q.x == 0) fragColor = vec4(mCam[0], -dot(mCam[0], cam));\n        else if(q.x == 1) fragColor = vec4( mCam[1], -dot(mCam[1], cam));\n        else fragColor = vec4( mCam[2], -dot(mCam[2], cam));\n    } \n    #elif BUFF_ACCUM == 1\n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./4.; \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    #else\n    // No reprojection or temporal blur, for comparisson.\n    fragColor = vec4(max(col, 0.), 1);\n    #endif\n    \n\n    \n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3yRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 736, 755, 755, 838], [840, 840, 894, 1489, 2263]]}
{"id": "NsdyWj", "name": "pseudo-vectorization of video3", "author": "FabriceNeyret2", "description": "color variant of https://shadertoy.com/view/7d3yWS\nclick to see the outlines instead.", "tags": ["short", "marchingsquare", "marchingcube", "vectorization"], "likes": 7, "viewed": 275, "published": 3, "date": "1654070557", "time_retrieved": "2024-07-30T16:46:01.085408", "image_code": "// color variant of https://shadertoy.com/view/7d3yWS\n// variant of https://shadertoy.com/view/fddyRs\n// using marching triangles https://www.shadertoy.com/view/fdccDB\n\nint c;\n#define T(U)  textureLod(iChannel0, U*R.y/R , float(lod)-2. )[c]   // or lod=0 for fun\n#define G(uv) ( ( (floor(U) + uv) *mat2(1,.5,0,.86) ) *Z/1024. )\n#define S(v) smoothstep( -.8,.8,(iMouse.z>0.?-.5*abs(v):v)/fwidth(v) ) // antialiasing draw\n\nfloat vector(vec2 U, int lod, float thresh)\n{\n    float Z = exp2(float(lod));                           // scaling\n    vec2  v, R = iResolution.xy;\n    float O = 0.;                                         // --- marching triangle -------\n    U *= mat2(1,-1./1.73, 0,2./1.73) *1024./Z/R.y;        // conversion to\n    vec3 g = vec3(U, 1.-U.x-U.y);                         // hexagonal coordinates\n\tg = fract(g);                                         // diamond coords\n    bool side = length(g)>1.;                             // tri: which diamond half\n \n    vec3 V = side ? vec3( T(G(vec2(1))), T(G(vec2(0,1))), T(G(vec2(1,0))) ) // samples at corder\n                  : vec3( T(G(vec2(0))), T(G(vec2(1,0))), T(G(vec2(0,1))) );\n    if (side) g = 1.-g;                                   // barycentric coordinates\n    O = S( (1.-g.x-g.y)*V.x + g.x*V.y + g.y*V.z - thresh );\n    return O;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{   int lod = 5;\n    c = 0; O.r = vector(U,lod,.5);\n    c = 1; O.g = vector(U,lod,.5);\n    c = 2; O.b = vector(U,lod,.5);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[421, 421, 466, 466, 1312], [1314, 1314, 1352, 1352, 1474]]}
{"id": "fddyWj", "name": "ROCK KOLPASHEVO 321", "author": "vityahann", "description": "123", "tags": ["123"], "likes": 3, "viewed": 385, "published": 3, "date": "1654068993", "time_retrieved": "2024-07-30T16:46:01.880283", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 1.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 4.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 1.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 229, 250, 250, 419], [421, 421, 445, 445, 495], [497, 497, 526, 526, 619], [621, 621, 657, 657, 868], [870, 870, 905, 905, 969], [971, 971, 1013, 1013, 1480], [1482, 1482, 1533, 1533, 1785], [1788, 1788, 1845, 1845, 2278]]}
{"id": "7scyD2", "name": "rock KOLPASHEVO #2", "author": "vityahann", "description": "MICROFON", "tags": ["rock"], "likes": 2, "viewed": 299, "published": 3, "date": "1654067155", "time_retrieved": "2024-07-30T16:46:02.685131", "image_code": "#define TWO_PI 3.283185\n#define NUMBALLS 60.0\nfloat hash( vec2 p )\n{\n    return fract( sin( dot(p, vec2( 15.79, 81.93  ) ) * 45678.9123 ) );\n}\n\nfloat d = -TWO_PI;\nvoid texto(inout vec3 col, vec2 offset) {\n    vec2 uv=gl_FragCoord.xy/iResolution.xy;\n    uv.y=1.-uv.y;\n    vec4 tx = texture(iChannel1, uv+offset);\n    col = mix(col, tx.rgb, length(tx.rgb));\n}\nfloat getSound() \n{\n    float s=0.;\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(3000.,i/20.)).r;\n        s+=texture(iChannel0,vec2(i/20000.,0.)).r;\n    }\n    return s/25.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n    vec3 c = vec3(0);\n    float a1 = floor(mod(iTime*0.08, 10.)) + 1.;\n    float a2 = floor(mod(iTime*0.08, 10.)) + 2.;\n    // Así sería si quiero uno random cada vez que cambia\n    // float a2 = rand(vec2(floor(mod(iTime / 5., 10.)))) * 10.;\n    \n    \n\tfor(float i = 1.0; i < NUMBALLS; i++) {\n\t\tfloat t = TWO_PI * i/NUMBALLS + sin(iTime*0.2)*5.;\n\t\tfloat x = cos(a1 * t + d);\n\t\tfloat y = sin(a2 * t + d);\n\t\tvec2 q = .4 * vec2(x, y);\n\t\tc += 0.004/distance(uv, q) * vec3(0.5 * abs(x), 0, abs(y));\n\t}\n    texto(c, vec2(-0.42,0.42));\n    fragColor = vec4(vec3(c), 1.0)*(getSound()*1.+0.5);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ↙\n//  ↙\n//   ↙\n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n\tvec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n    uv *= 2.5;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 24.0 ;\n\tuv -= vec2(-10., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=3. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t R O C K _ K O L P A S H E V O _ _ _ _ _\n    float a = smoothstep(0.4,0.2,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    fragColor = vec4(col, max(a,b));\n}\n", "buffer_a_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 68, 68, 142], [163, 163, 204, 204, 357], [358, 358, 377, 377, 556], [557, 557, 614, 614, 1266]]}
{"id": "sd3yW2", "name": "Procedural flowing liquid", "author": "vipiao", "description": "Use mouse to change the view position.", "tags": ["procedural", "noise", "liquid", "generation", "textureadvection"], "likes": 22, "viewed": 585, "published": 3, "date": "1654065891", "time_retrieved": "2024-07-30T16:46:03.430139", "image_code": "\n/*\nThe flow is represented by a vector field. A point in 2d space gives a 2d vector.\nTo make the liquid flow naturally, volume should be conserved.\nA vector field that conserves volume is said to have a divergence of 0 all over.\nThe function \"whirl\" generates a whirl at the position \"center\".\nSuch a whirl has 0 divergence since it only spins the volume in circular motion at a random speed.\n\"whirldNoise\" generates several such whirls in a grid pattern.\nThis is the same as a sum of whirl vector fields.\nThe divergence of a sum of vector fields is a sum of the divergence of these vector fields.\nThis means \"whirldNoise\" also has 0 divergence.\n\"layeredWhirlNoise\" adds multiple such whirl noises on top of each other with different frequencies\nand magnitudes. By the same logic, this function will also have 0 divergence, so volume is conserved.\nBy slowly changing the seed of the layeredWhirlNoise function, the flow will change over time.\n\nTo animate the noise function to make it move in the direction of the vector field,\na technique similar to Shepard's tone is being used. Shepard's tone uses multiple rising sound frequencies\nadded together making a sound that will rise. The frequencies that are too high are faded away and new\nlower frequencies are added in. The fading is too slow for humans to notice resulting in the illusion\nof an ever increasing tone. In the animation the same is done, but for noise functions instead.\nThe one noise function is distorted in the direction of the vector field. When the distortion\nis too large, it is faded away as it is being replaced with a less distorted version of the noise function.\n*/\n\n// Change parameters to change the simulation.\n#define DIRECTION_CHANGE_SPEED 1.0\n#define LIQUID_SPEED 1.0\n#define NOISE_FREQ 40.\n\n// \"hash13\" is taken from:\n//https://www.shadertoy.com/view/4djSRW\n// Generates random noise from p3.\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// A simple 3d noise function that correlates similar positions in 3d. Is more smooth than rand3d.\nfloat boxNoise(vec3 pos){\n\tvec3 ind = vec3(floor(pos));\n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    return mix(mix(mix( hash13(ind + vec3(0,0,0)), hash13(ind + vec3(1,0,0)), u.x),\n                   mix( hash13(ind + vec3(0,1,0)), hash13(ind + vec3(1,1,0)), u.x), u.y),\n               mix(mix( hash13(ind + vec3(0,0,1)), hash13(ind + vec3(1,0,1)), u.x),\n                   mix( hash13(ind + vec3(0,1,1)), hash13(ind + vec3(1,1,1)), u.x), u.y), u.z);\n}\n// Creates a whirl vector field at \"center\" sampled at \"pos\".\nvec2 whirl(vec2 pos, vec2 center, float ff, float seed){\n    vec2 relPos = pos - center;\n    float ll = length(relPos);\n    float mm = 1. - 2. * boxNoise(vec3(center, ll*ff + seed));\n    vec2 dir = vec2(-relPos.y, relPos.x) / ll;\n    \n    return dir * mm * ll / (1.+abs(ll));\n}\n// Distributes whirls at a grid of 1 by 1 cells.\nvec2 whirldNoise(vec2 pos, float seed){\n\tvec2 botL = floor(pos);\n    vec2 ee = vec2(1,0);\n    float ff = 2.;\n    return\n        whirl(pos, botL      , ff, seed) * max(1.-length(pos-botL      ), 0.)*1. +\n        whirl(pos, botL+ee.xy, ff, seed) * max(1.-length(pos-botL-ee.xy), 0.)*1. +\n        whirl(pos, botL+ee.yx, ff, seed) * max(1.-length(pos-botL-ee.yx), 0.)*1. +\n        whirl(pos, botL+ee.xx, ff, seed) * max(1.-length(pos-botL-ee.xx), 0.)*1.\n    ;\n}\n// Layer the whirls with different frequencies and magnitudes.\nvec2 layeredWhirlNoise(vec2 pos, int nn, float seed){\n    vec2 rr = vec2(0.);\n    float ff = 1.;\n    for(int ii=0;ii<nn;ii++){\n        rr += whirldNoise(pos / ff, seed) * ff;\n        ff *= 0.67;\n        pos += vec2(1,-1);\n    }\n    return rr;\n}\n// Calculates the pixel color.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    vec2 camPos = (vec2(iMouse.xy) - vec2(iResolution.xy) * 0.5)*0.05;\n    float zoom = 6.; // How many distance units are visible in the horizontal direction.\n    vec2 pos = camPos.xy + uv * zoom*2.;\n    \n    // Calculate color.\n    // The flow vector field.\n    vec2 ww = LIQUID_SPEED*4.0*layeredWhirlNoise(pos*0.1, 5, iTime*0.2*DIRECTION_CHANGE_SPEED);\n    \n    float ff = 2.*LIQUID_SPEED; // The pace of swapping textures\n    float t0 = mod(ff*iTime, 1.);\n    float t1 = mod(ff*iTime + 0.5, 1.);\n    vec3 n0 = vec3(\n        boxNoise(vec3((pos - t0 * ww) * NOISE_FREQ, 0. + 0.5*iTime)),\n        boxNoise(vec3((pos - t0 * ww) * NOISE_FREQ, 1. + 0.5*iTime)),\n        boxNoise(vec3((pos - t0 * ww) * NOISE_FREQ, 2. + 0.5*iTime))\n    );\n    vec3 n1 = vec3(\n        boxNoise(vec3((pos - t1 * ww) * NOISE_FREQ, 3. + 0.5*iTime)),\n        boxNoise(vec3((pos - t1 * ww) * NOISE_FREQ, 4. + 0.5*iTime)),\n        boxNoise(vec3((pos - t1 * ww) * NOISE_FREQ, 5. + 0.5*iTime))\n    );\n    float mm = -abs(t1*2.-1.)+1.;\n    vec3 color = mix(n0, n1, mm);\n    \n    // An average of two noise functions have less variance.\n    // This could lead to contrast visible oscillations of variance.\n    // Compensate by reducing variance when noise is mixed.\n    float var = abs(round(t0 * 2. - 0.5) - t0 * 2. + 0.5)*(2. - sqrt(2.));\n    // Apply variance reduction.\n    color = mix(color, vec3(0.5), var);\n    //color *= length(ww); // Uncomment to only see moving liquid.\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3yW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1774, 1876, 1898, 1898, 2001], [2002, 2101, 2126, 2126, 2585], [2586, 2648, 2704, 2704, 2925], [2926, 2975, 3014, 3014, 3432], [3433, 3496, 3549, 3549, 3740], [3741, 3772, 3829, 3829, 5464]]}
{"id": "7d3yW2", "name": "30 Minutes 5/31", "author": "scry", "description": ":)\nTimelapse:\nhttps://twitter.com/Scrygl/status/1531868744883941376", "tags": ["3d", "rings", "shadow"], "likes": 4, "viewed": 193, "published": 3, "date": "1654060806", "time_retrieved": "2024-07-30T16:46:04.185120", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//////////////////////////////////////////////////////////////\n#define time iTime*1.\n#define pi 3.14159265\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdBox(vec3 p ,vec3 s) {\n    return max(abs(p.z)-s.z,max(abs(p.y)-s.y,abs(p.x)-s.x));\n}\n\nvec3 lpos(void) {\n    vec3 l = vec3(0.,1.5,5.);\n    l.x += sin(time/5.)*1.2;\n    l.z += cos(time/5.)*1.2;\n    return l;\n}\n\nfloat sdTorus(vec3 p, vec2 s) {\n    return length(vec2(length(p.xy),p.z+s.x)-s.x)-s.y;\n}\n\nvec4 map(vec3 p) {\n    vec3 o = p;\n    p.z -= 5.;\n    p.yz *= r2d(sin(time/5.)*0.1);\n    vec3 tp = p;\n    float tpf = 2.;\n    vec3 tpb = tp;\n    tp.y = (fract(tp.y*tpf)-0.5)/tpf;\n    tp.xz *= r2d(time);\n    tp.yz *= r2d(deg*60.*(abs(fract(floor(tpb.y*tpf)/tpf)-1.)*2.));\n    float d = sdTorus(p,vec2(0.1,0.01));\n    d = min(d,sdTorus(tp,vec2(0.48,0.01)));\n    d = min(d,p.y+1.);\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd,float s) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<99;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w*s;\n        dO += dS*0.5;\n        ii += 0.01;\n        if (dO > 100. || dS< 0.001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001,0.);\n    return normalize(vec3(\n        map(p-h.xyy).w-map(p+h.xyy).w,\n        map(p-h.yxy).w-map(p+h.yxy).w,\n        map(p-h.yyx).w-map(p+h.yyx).w\n    ));\n}\n\nvec3 sh(vec3 p, vec3 n) {\n    vec3 l = lpos();\n    vec3 rd = normalize(l-p);\n    vec2 d = RM(p-n*0.003,rd,1.);\n    float s = 0.;\n    float dif = clamp(dot(rd,n),0.,1.);\n    if (length(l-p) > d.x) {\n        s = 1.;\n    }\n    return vec3(s,dif,d.x);\n}\n\nvec3 colo(vec3 p , vec3 n ,vec2 d, vec3 rd) {\n    vec3 col = 1.-d.xxx*0.1;\n    vec3 s = sh(p,n);\n    col *= 0.5;\n    col.rg += n.yz*r2d(0.2)*0.2;\n    col.b += n.x;\n    col -= s.x*0.5;\n    col += (1.-s.y*1.)*0.4;\n    vec3 l = lpos();\n    float l1 = clamp(length(l-p),0.,1.);\n    float l2 = pow(1.-length(l.xy-rd.xy*l.z),3.);\n    col = clamp(col,0.,1.);\n    col += clamp((l1*l2),0.,1.);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,2.));\n    vec2 d = RM(ro,rd,1.);\n    vec3 p = ro+rd*d.x;\n    vec3 n = calcNorm(p);\n    col += colo(p,n,d,rd);\n    float rl = 1.;\n    for (int i=0;i<3;i++) {\n        ro = p-n*0.003;\n        rd = reflect(rd,n);\n        d = RM(ro,rd,1.);\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        col += colo(p,n,d,rd)*rl*0.2;\n    }\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3yW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 247]]}
{"id": "sd3cDj", "name": "things and stuff", "author": "Ciph3rzer0", "description": "it's a shader", "tags": ["stuff"], "likes": 6, "viewed": 231, "published": 3, "date": "1654053268", "time_retrieved": "2024-07-30T16:46:04.928134", "image_code": "#define S(r,v) smoothstep(9./iResolution.y,0.,abs(v-(r)))\n\nconst vec2 s = vec2(1, 1.7320508); // 1.7320508 = sqrt(3)\nconst vec3 baseCol = vec3(.05098, .25098, .2784);\nconst float borderThickness = .02;\nconst float isolineOffset = .4;\nconst float isolineOffset2 = .325;\n\nfloat calcHexDistance(vec2 p)\n{\n    p = abs(p);\n    return max(dot(p, s * .5), p.x);\n}\n\nfloat random(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 calcHexInfo(vec2 uv)\n{\n    vec4 hexCenter = round(vec4(uv, uv - vec2(.5, 1.)) / s.xyxy);\n    vec4 offset = vec4(uv - hexCenter.xy * s, uv - (hexCenter.zw + .5) * s);\n    return dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ? vec4(offset.xy, hexCenter.xy) : vec4(offset.zw, hexCenter.zw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 3. * (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.x += iTime * .25;\n    \n    vec4 hexInfo = calcHexInfo(uv);\n    float totalDist = calcHexDistance(hexInfo.xy) + borderThickness;\n    float rand = random(hexInfo.zw);\n    \n    float angle = atan(hexInfo.y, hexInfo.x) + rand * 5. + iTime;\n    \n    vec3 isoline = S(isolineOffset, totalDist) * baseCol * step(3. + rand * .5, mod(angle, 6.28))\n        + S(isolineOffset2, totalDist)\n                    * baseCol * step(4. + rand * 1.5, mod(angle + rand * 2., 6.28));\n    \n    float sinOffset = sin(iTime + rand * 8.);\n    float aa = 5. / iResolution.y;\n    \n    fragColor.rgb = (smoothstep(.51, .51 - aa, totalDist) \n    + pow(1. - max(0., .5 - totalDist), 20.) * 1.5) * (baseCol + rand * vec3(0., .1, .09)\n    )\n    + isoline \n    //+ baseCol * smoothstep(.2 + sinOffset, .2 + sinOffset - aa, totalDist)\n    ;    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3cDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 270, 301, 301, 356], [358, 358, 381, 381, 453], [455, 455, 482, 482, 757], [759, 759, 816, 816, 1706]]}
{"id": "fs3cWH", "name": "Mickey Mouse Man", "author": "avidixit27", "description": "title", "tags": ["implicitsurfaceart"], "likes": 1, "viewed": 165, "published": 3, "date": "1654052631", "time_retrieved": "2024-07-30T16:46:05.738966", "image_code": "float map(vec3 p, settings setts)\n{\n    return world_sdf(p, iTime, setts);\n}\n\n\nvec3 computeNormal(vec3 p, settings setts)\n{\n    float h = 1e-4;\n    float sdp = world_sdf(p, iTime, setts);\n    return normalize(vec3(world_sdf(p + vec3(h, 0, 0), iTime, setts) - sdp,\n                          world_sdf(p + vec3(0, h, 0), iTime, setts) - sdp,\n                          world_sdf(p + vec3(0, 0, h), iTime, setts) - sdp));\n\n    \n}\n\n\n///////////////////////////////////////////\n/////// SPHERE TRACING CODE HERE:\n///////////////////////////////////////////\n\nbool sphere_tracing(ray r,\n               \t\tint max_iter,\n               \t\tsettings setts,\n               \t\tout vec3 hit_loc,\n               \t\tout int iters)\n{\n    hit_loc = r.origin + r.direction * (-r.origin.y / r.direction.y);\n    iters = 1;\n    float t = 0.;\n    for (int i = 0; i < max_iter; i++) {\n        vec3 p = r.origin + t * r.direction;\n        float dist = world_sdf(p, iTime, setts);\n        if (dist < EPSILON) {\n            hit_loc = p;\n            iters = i;\n            return true;\n        }\n        \n        t += dist;\n        \n    }\n    \n    iters = max_iter;\n    return false;\n    \n}\n\n///////////////////////////////////////////\n\nvec3 shade(ray r, int iters, settings setts)\n{\n    vec3 p = r.origin;\n    vec3 d = r.direction;\n    \n    if (setts.shade_mode == GRID)\n    {\n    \tfloat res = 0.2;\n    \tfloat one = abs(mod(p.x, res) - res / 2.0);\n    \tfloat two = abs(mod(p.y, res) - res / 2.0);\n    \tfloat three = abs(mod(p.z, res) - res / 2.0);\n    \tfloat interp = min(one, min(two, three)) / res;\n        \n        return mix( vec3(0.2, 0.5, 1.0), vec3(0.1, 0.1, 0.1), smoothstep(0.0,0.05,abs(interp)) );\n    }\n    else if (setts.shade_mode == COST)\n    {\n        return vec3(float(iters) / float(cost_norm));\n    }\n    else if (setts.shade_mode == NORMAL)\n    {\n        vec3 normal = computeNormal(p, setts);\n        vec3 white = vec3(1., 1., 1.);\n        return (normal + white) / 2.;\n\n    }\n    else if (setts.shade_mode == DIFFUSE_POINT)\n    {\n        vec3 light_pos = vec3(0.0, 5.0, 0.0);\n        vec3 light_intensity = vec3(5.0);\n        vec3 surface_color = vec3(0.5);\n        \n        vec3 lightDirection = normalize(light_pos - p);\n        vec3 normal = computeNormal(p, setts);\n        vec3 Li = light_intensity / pow(distance(light_pos, p), 2.0);\n        return surface_color * max(0.0, dot(normal, lightDirection)) * Li;\n    }\n    else if (setts.shade_mode == ENVIRONMENT_MAP)\n    {\n        vec3 normal = computeNormal(p, setts);\n        vec3 reflection = reflect(d, normal);\n        //return vec3(texture(iChannel0, reflection));\n    }\n    else\n    {\n        return vec3(0.0);\n    }\n    \n    return vec3(0.0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// we will be replacing all of the code below with our own method(s). All of    //\n// the changes you make will be disgarded. But feel free to change the main     //\n// method to help debug your code.                                              //\n//////////////////////////////////////////////////////////////////////////////////\n\nvec3 render(settings setts, vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //if (p.y < -0.95)\n    //{\n    //    float val = cos(iTime * anim_speed);\n     //   return shade_progress_bar(p, iResolution.xy, val);\n    //}\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= aspect;\n   \n    \n    // Rotate the camera\n    vec3 eye = vec3(-3, 0.5, 1.);\n    // vec3(-3.0*cos(iTime*0.2), 2.0 + 0.5*sin(iTime*0.1), -3.0*sin(iTime*0.2));\n    vec3 dir = vec3(0.0, 0.0, 0.0) - eye;\n    vec3 up = vec3(0, 1, 0);\n    \n    \n    float focal_length = 2.;\n    \n    vec3 u,v,w;\n    compute_camera_frame(dir, up, u, v, w);\n    \n    ray r;\n    switch(projection_func) {\n        case PROJECTION_ORTHOGRAPHIC:\n            r = generate_ray_orthographic(uv, eye, u, v, w);\n            break;\n     \n        case PROJECTION_PERSPECTIVE:\n            r = generate_ray_perspective(uv, eye, u, v, w, focal_length);\n            break;\n    }\n    \n    \n    int max_iter = 1000;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 hit_loc;\n    int iters;\n    bool hit;\n    \n    if (sphere_tracing(r, max_iter, setts, hit_loc, iters))\n    {\n        r.origin = hit_loc;\n        col = shade(r, iters, setts);\n    }\n    \n\n    \n    return pow(col, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(render(render_settings, fragCoord), 1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// pre-defined constants\n#define EPSILON 1e-4\n#define PI 3.1415926535897932384626433832795\n\n\n// shade mode\n#define GRID 0\n#define COST 1\n#define NORMAL 2\n#define AMBIENT 3\n#define DIFFUSE_POINT 4\n#define ENVIRONMENT_MAP 5\n\n\n//\n// Render Settings\n//\nstruct settings\n{\n    int shade_mode;\n};\n\nsettings render_settings = settings(DIFFUSE_POINT);\n\n\n\n//float anim_speed = 0.35;\nfloat anim_speed = 0.35;\nint cost_norm = 200;\n\nvec3 two_tone_color_a = vec3(0.6 * 1.0, 0.6 * 1.0, 0.0 * 1.0);\nvec3 two_tone_color_b = vec3(0.2 * 1.0, 0.1 * 1.0, 0.9 * 1.0);\n//vec3 two_tone_color_a = vec3(0.9,0.7,0.6);\n//vec3 two_tone_color_b = vec3(0.0);\nvec3 two_tone_dir = vec3(1.0, 1.0, 0.0);\n\n////////////////////////////////////////////////////\n// SDF evaluation code here:\n////////////////////////////////////////////////////\n\n// returns the signed distance to a sphere from position p\nfloat sdSphere(vec3 p, float r)\n{\n \treturn length(p) - r;\n}\n\n// returns the signed distance to a box from position p\nfloat sdBox( vec3 p, vec3 half_bounds )\n{\n    vec3 q = abs(p) - half_bounds;\n    float maxComponent = max(q.x, max(q.y, q.z));\n    return length(max(q, 0.)) + min(maxComponent, 0.);\n}\n\n// returns the signed distance to a cylinder from position p\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    float baMagnitudeSquared = dot(b-a,b-a);\n    float x = length((p - a) * baMagnitudeSquared - (b - a) * dot(p - a, b - a)) - r * baMagnitudeSquared;\n    float y = abs(dot(p - a, b - a) - baMagnitudeSquared * 0.5) - baMagnitudeSquared * 0.5;\n    float dist = 0.0;\n    \n    \n    if (max(x, y) < 0.0) {\n        dist = -min(x * x, y * y * baMagnitudeSquared);\n    } else {\n        \n        if (x > 0.0) {\n            x = x * x;\n        } else {\n            x = 0.0;\n        }\n    \n        if (y > 0.0) {\n            y = y * y * baMagnitudeSquared;\n        } else {\n            y = 0.0;\n        }\n        dist = x + y;\n    }\n    \n    \n    return sign(dist) * sqrt(abs(dist)) / baMagnitudeSquared;\n}\n\n// returns the signed distance to a cone from position p\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float tPrime = dot(p-a, b-a) / dot(b-a, b-a);\n    float x = sqrt(dot(p-a, p-a) - tPrime * tPrime * dot(b-a, b-a));\n    float ax = 0.0; \n    \n    if (tPrime < 0.5) {\n        ax = max(0.0, x-ra);\n    } else {\n        ax = max(0.0, x-rb);\n    }\n    \n    float ay = abs(tPrime - 0.5) - 0.5;\n    float k = (rb-ra) * (rb-ra) + dot(b-a,b-a);\n    float d = min(max(((rb-ra) * (x-ra) + tPrime * dot(b-a,b-a)) / k, 0.0), 1.0);\n    float bx = x-ra - d * (rb-ra);\n    float by = tPrime - d;\n    float y = 0.0; \n    \n    if (bx < 0.0 && ay < 0.0) {\n        y = -1.0;\n    } else {\n        y = 1.0;\n    }\n    \n    return y * sqrt(min(ax*ax + ay*ay*dot(b-a,b-a), bx*bx + by*by*dot(b-a,b-a)));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b)\n{\n    float tPrime = min(1., max( 0., dot(p-a, b-a) / dot(b-a, b-a)));\n    return length(p-a-(b-a)*tPrime);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    float h = max(k - abs(d1 - d2), 0.0);\n    return min(d1, d2) - h * h / (4.0 * k);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k - abs(d1 - d2), 0.0);\n    return max(d1, d2) + (h * h / (4.0 * k));\n}\n\nfloat opRound(float d, float iso)\n{\n    return d - iso;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\n\n#define PROJECTION_ORTHOGRAPHIC 0\n#define PROJECTION_PERSPECTIVE  1\n\nint projection_func = PROJECTION_ORTHOGRAPHIC;\n\n////////////////////////////////////////////////////\n// Write up your ray generation code here:\n////////////////////////////////////////////////////\nstruct ray { \n    vec3 origin;\n    vec3 direction;\n};\n\n\n// TASK 2.1\nvoid compute_camera_frame(\n    vec3 dir, vec3 up,\n    out vec3 u, out vec3 v, out vec3 w ) {\n    \n    w = -dir / length(dir);\n    u = cross(up, w) / length(cross(up, w));\n    v = cross(w, u);\n\n}\n\n\n// TASK 2.2\nray generate_ray_orthographic(vec2 uv, vec3 e, vec3 u, vec3 v, vec3 w) {\n    return ray(vec3(e + uv.x * u + uv.y * v), vec3(-w));\n\n}\n\n// TASK 2.3\nray generate_ray_perspective(vec2 uv, vec3 eye, vec3 u, vec3 v, vec3 w, float focal_length) {\n    return ray(eye, normalize(vec3(-focal_length * w + uv.x * u + uv.y * v)));\n}\n////////////////////////////////////////////////////\n\n// returns the signed distance to an infinate plane with a specific y value\nfloat sdPlane(vec3 p, float z)\n{\n    return p.z - z;\n}\n\nfloat world_sdf(vec3 p, float time, settings setts)\n{\n    float dist = 100000.0;\n    \n    dist = sdPlane(p.xzy, -0.15);\n    \n       \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.20, p.y, p.z), 0.20), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.20, p.y-0.2, p.z-0.1), 0.1), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.20, p.y-0.2, p.z+0.1), 0.1), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.20, p.y-0.2, p.z+0.1), 0.1), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.28, p.y-0.25, p.z+0.09), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.28, p.y-0.25, p.z-0.08), 0.02), 0.01);\n    \n    dist = opSmoothUnion(dist, sdSphere(vec3(p.x+0.28, p.y-0.15, p.z), 0.05), 0.01);\n    \n    dist = opSmoothSubtraction(sdSphere(vec3(p.x+0.31, p.y-0.05, p.z-0.15), 0.02), dist , 0.01);\n    \n    dist = opSmoothSubtraction(sdSphere(vec3(p.x+0.33, p.y-0.03, p.z-0.13), 0.02), dist, 0.01);\n    \n    dist = opSmoothSubtraction(sdSphere(vec3(p.x+0.35, p.y-0.01, p.z-0.11), 0.02), dist, 0.01);\n    \n    dist = opSmoothSubtraction(sdSphere(vec3(p.x+0.37, p.y, p.z-0.08), 0.02), dist, 0.01);\n    \n    dist = opSmoothSubtraction(sdSphere(vec3(p.x+0.38, p.y+0.01, p.z-0.05), 0.02), dist, 0.01);\n    \n    \n\n    return dist;\n}\n\n\n// The animation which you see is of a 2D slice of a 3D object. The objects exist in [-1, 1] space\n// and the slice is continuously moved along z=[-1,1] using a cosine. This method renders what the\n// current z value is as a progress bar at the bottom of the animation for reference.\n//vec3 shade_progress_bar(vec2 p, vec2 res, float z)\n//{\n    // have to take account of the aspect ratio\n //   float xpos = p.x * res.y / res.x;\n    \n //   if (xpos > z - 0.01 && xpos < z + 0.01) return vec3(1.0);\n //   else return vec3(0.0);\n//}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3cWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 76], [79, 79, 123, 123, 425], [551, 551, 710, 710, 1156], [1203, 1203, 1249, 1249, 2694], [3112, 3112, 3157, 3157, 4431], [4433, 4433, 4488, 4488, 4553]]}
{"id": "7dcyDj", "name": "small construction", "author": "jorge2017a2", "description": "small construction", "tags": ["smallconstruction"], "likes": 9, "viewed": 203, "published": 3, "date": "1654052008", "time_retrieved": "2024-07-30T16:46:06.497936", "image_code": "//----------image\n//por jorge2017a2-\n//https://iquilezles.org/articles/distfunctions2d/\n//small construction----31-may-2022\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\nfloat puertaMed(vec2 p, vec2 med)\n{   float d1= sdBox( p,med );\n    float d2= sdTriangleIsosceles(vec2(p.x, -p.y)-vec2(0.0,-med.y*2.0+0.5),med );\n    float duni= Union(d1, d2);\n    return duni;\n}\n\nvec2 puertaFinal(vec3 p, float distbox)\n{   vec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    float d0=distbox;\n    float d0a=sdBox(p-vec3(0.0,-3.0,0.0), vec3(4.0,7.0,11.0) );  //puerta box\n    float d0b= puertaMed(p.xy-vec2(0.0,-6.0),  vec2(3.5,4.5)); //puerta A\n    float d0c= puertaMed(p.xy-vec2(0.0,-6.0),  vec2(3.0,4.0)); //puerta B\n     d0a= Intersect(d0a, d0b); //marco\n     d0a= Difference(d0a, d0c);\n     d0= Difference(d0, d0c);\n    vec2 pra= rotatev2(p.yz, radians(90.0));\n    \n    float d2a= sdTunnel(pra-vec2(0.0,-0.5), vec2(3.0,6.0) );\n    d0= Difference(d0, d2a);\n    d0a= Difference(d0a, d2a);  ///puerta otra\n    res =opU2(res, vec2(d0,105.0));\n    res =opU2(res, vec2(d0a,106.0));\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    p.xyz=p.zyx;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    p.y=p.y-8.0;\n    float da=sdBox(p-vec3(0.0,-11.0,0.0), vec3(20.0,1.0,20.0) ); //base\n    float d0a=sdBox(p, vec3(10.0,10.0,10.0) );  //edificio a\n    float d0b=sdBox(p-vec3(0.0,10.0,0.0), vec3(9.0,3.0,9.0) );  //edificio b\n   d0a= Difference(d0a, d0b);\n   vec2 pf1= puertaFinal(p-vec3(0.0,-0.5,0.0), d0a);\n    \n    p.x=abs(p.x)-13.0;\n    p.z=abs(p.z)-11.0;\n    float d1a= sdCylinderXZ( p-vec3(0.0,1.0,0.0), vec2(4.0,12.0) );\n    float d1b= sdCylinderXZ( p-vec3(0.0,1.0,0.0), vec2(3.0,14.0) );\n    d1a= Difference(d1a, d1b);\n    \n    res =opU2(res, vec2(da,105.0));\n    res =opU2(res, pf1);\n    res =opU2(res, vec2(d1a,105.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n    vec3 col;\n    if (i==100 )\n    {  col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n    if (i==105 ) { col=tex3D(iChannel0, p/32., nor); col=vec3(1.0)-col;  return  col;  }\n    if (i==106 ) { col=tex3D(iChannel0, p/16., nor); col=vec3(1.0,1.0,0.0)-col;  return  col;  }\n    \n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    float d = pow(rd.z+0.3,2.)*pow(rd.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n\t//return sky;\n    return sky*d;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=35.0;\n   float veltime=30.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,20.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 0.5,0.5,0.5 ); \n   vec3 ro=vec3(0.0,25.0+5.0*sin(t),-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   rd= rotate_x(rd, radians(30.));\n     Ray ray= RotarEnCirculo(ro,rd);\n    ro=ray.ro;\n    rd=ray.rd;\n    \n   rd= rotate_x(rd, radians(20.)); \n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//https://iquilezles.org/articles/distfunctions2d/\n//-------common\n#define PI 3.14159265\n\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n///Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcyDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[551, 551, 583, 583, 667], [668, 668, 707, 707, 802], [803, 803, 842, 842, 937], [938, 938, 977, 977, 1072], [1074, 1074, 1118, 1118, 1145], [1146, 1146, 1186, 1186, 1213], [1214, 1214, 1259, 1259, 1287], [1289, 1314, 1348, 1348, 1444], [1445, 1445, 1479, 1479, 1570], [1571, 1571, 1605, 1605, 1696], [1697, 1697, 1731, 1731, 1822], [1823, 1823, 1858, 1858, 2018], [2020, 2020, 2061, 2061, 2732], [2734, 2734, 2759, 2759, 3513], [3515, 3515, 3539, 3539, 3701], [3703, 3703, 3751, 3751, 4030], [4032, 4032, 4076, 4076, 4397], [4399, 4399, 4436, 4436, 4693], [4695, 4695, 4785, 4785, 5745], [5747, 5747, 5796, 5796, 6079], [6081, 6081, 6113, 6113, 6403], [6405, 6405, 6475, 6475, 6574], [6576, 6576, 6603, 6603, 6692], [6694, 6694, 6752, 6752, 6800], [6802, 6802, 6825, 6825, 6937], [6939, 6939, 6970, 6970, 7599], [7602, 7602, 7639, 7639, 7909], [7911, 7911, 7968, 7968, 8560]]}
{"id": "7dlyW7", "name": "Non-Euclidian Lattice", "author": "ShnitzelKiller", "description": "ray tracing portals", "tags": ["fractal"], "likes": 18, "viewed": 364, "published": 3, "date": "1654041058", "time_retrieved": "2024-07-30T16:46:07.250923", "image_code": "#define FDIST 0.5\n#define PI 3.1415926\n#define cameradist 2.5\n#define TIME_T 5.\n#define TIME_H 1.\n#define TIME_L 10.\n\n// raytrace a 2D box with outgoing normal\nvec2 box2d(in vec2 ro, in vec2 rd, in vec2 r, out vec2 no) {\n    vec2 dr = 1.0/rd;\n    vec2 n = ro * dr;\n    vec2 k = r * abs(dr);\n    \n    vec2 pout =  k - n;\n    vec2 pin =  - k - n;\n    float tout = min(pout.x, pout.y);\n    float tin = max(pin.x, pin.y);\n    no = -sign(rd) * step(pout.xy, pout.yx);\n    return vec2(tin, tout);\n}\n\n// Raytrace box, returns (t_in, t_out) and incident normal\nvec2 box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 no) {\n    vec3 dr = 1.0/rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n    \n    vec3 pout =  k - n;\n    vec3 pin =  - k - n;\n    float tout = min(pout.x, min(pout.y, pout.z));\n    float tin = max(pin.x, max(pin.y, pin.z));\n    no = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    return vec2(tin, tout);\n}\n\n//raytrace a wirebox\nvec2 wirebox(in vec3 eye, in vec3 rd, in float r, in float thickness, out vec3 no, out mat3 rot) {\n    float rad = r;\n    rot = mat3(1.0);\n    vec2 t = box(eye, rd, vec3(r), no);\n    //float lastT = t.x;\n    if (t.y > t.x) {\n        //trace the inner walls by tracing infinite rectangular shafts in each face, then repeating once for the inner walls\n        vec3 ro = eye + t.x * rd;\n        for (int i=0; i<16; ++i) {\n            rad -= thickness;\n            float offset = rad + thickness;\n            //transform the ray into tangent space to intersect it with a shaft perpendicular to the normal\n            mat2x3 invproj = mat2x3(no.zxy, no.yzx);\n            mat3x2 proj = transpose(invproj);\n            rot = rot * mat3(no.zxy, no.yzx, no.xyz);\n            vec2 n2;\n            vec2 ro2d = proj * ro;\n            ro2d = mod(ro2d+offset, offset*2.)-offset;\n            vec2 t2 = box2d(ro2d, proj * rd, vec2(rad), n2);\n            if (t2.x > 0. || t2.y < 0.) {\n                break;\n            }\n            t.x += t2.y;\n            ro = eye + t.x * rd - no * (dot(no, ro) - offset);\n            no = invproj * n2;\n            //lastT = t2.y;\n        }\n        \n        t.y += 1000.;\n    }\n    return t;\n}\n\nfloat oscillate(float t)\n{\n    float t_osc = 0.5*(TIME_H+TIME_L)+TIME_T;\n    float h_l = 0.5*TIME_L/t_osc;\n    float h_h = (0.5*TIME_L+TIME_T)/t_osc;\n    return smoothstep(0., 1., (clamp(abs(mod(iTime, t_osc*2.)/t_osc-1.), h_l, h_h) - h_l) / (h_h - h_l));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float THICKNESS = 0.03 + 0.4 * oscillate(iTime);\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n\tfloat ang = iTime * 0.5;\n    \n    vec3 eye;\n    if (iMouse.z > 0.) {\n        float mouseY = (1.0-1.15*iMouse.y/iResolution.y) * 0.5 * PI;\n        float mouseX =  -(iMouse.x/iResolution.x) * 2. * PI;\n        eye = cameradist*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    } else {\n        eye = cameradist*vec3(cos(ang), sin(ang), 0.3 * sin(ang/0.70752)+.3);\n    }\n    vec3 w = -normalize(eye);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(u*uv.x + v*uv.y + FDIST * w);\n    \n    //trace the outer box\n    vec3 n;\n    \n    mat3 rot;\n    vec2 t = wirebox(eye, rd, 1., THICKNESS, n, rot);\n    float objmask = step(0., t.y-t.x);\n    \n    //trace the floor\n    float tfloor = -(eye.z + 2.)/rd.z;\n    float floormask = step(0., tfloor);\n    vec3 bgcol = floormask * vec3(.5, .7, .8);\n    if (floormask > 0.5) {\n        //floor shadow\n        vec3 lightdir = normalize(vec3(-.3, -.5, -1.));\n        vec3 floorpt = eye + tfloor * rd;\n        vec3 ns;\n        vec2 ts = box(floorpt, lightdir, vec3(1.), ns);\n        bgcol *= step(ts.y, ts.x);\n    }\n    mat3 traf = mat3(-.5, .3, 0, 0, .5, 0.5, -0.3, 0.8, -0.4);\n    vec3 col = mix(bgcol, (rot*traf*n)*.5 + .5, objmask);\n    fragColor = vec4(mix(col, vec3(0.5, 0.1, 0.), objmask * min(1., (t.x/50.))), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlyW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 160, 220, 220, 492], [494, 553, 611, 611, 933], [935, 956, 1054, 1054, 2170], [2172, 2172, 2198, 2198, 2429], [2431, 2431, 2488, 2488, 3943]]}
