{"id": "stX3zS", "name": "Easy Voronoi Edges", "author": "oneshade", "description": "Detecting voronoi borders.", "tags": ["2d", "voronoi", "edgedetection", "edges"], "likes": 21, "viewed": 376, "published": 3, "date": "1622494322", "time_retrieved": "2024-07-30T19:18:02.641622", "image_code": "vec2 getPoint(in vec2 cell) {\n    return cell + 0.5 + 0.5 * vec2(sin(cell.x - cell.y + iTime), sin(cell.x) * cos(cell.x + cell.y * iTime));\n}\n\nfloat getId(in vec2 cell) {\n    return fract(sin(cell.x * 4647.543 + cell.y * 2435.32) * 9658.65);\n}\n\nfloat voronoi(in vec2 pixel) {\n    vec2 uv = (pixel - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec2 cell = floor(uv);\n\n    float minDist = 1e20;\n    float id = 0.0;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCell = cell + vec2(i, j);\n            float curDist = length(uv - getPoint(curCell));\n            if (curDist < minDist) {\n                id = getId(curCell);\n                minDist = curDist;\n            }\n        }\n    }\n\n    return id;\n}\n\nvec4 render(in vec2 px) {\n    float dx = (voronoi(px + vec2(1.0, 0.0)) - voronoi(px - vec2(1.0, 0.0)));\n    float dy = (voronoi(px + vec2(0.0, 1.0)) - voronoi(px - vec2(0.0, 1.0)));\n    return vec4(abs(dx) + abs(dy) > 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = (render(fragCoord                 ) +\n                 render(fragCoord + vec2(0.5, 0.0)) +\n                 render(fragCoord + vec2(0.0, 0.5)) +\n                 render(fragCoord + vec2(0.5, 0.5))) / 4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stX3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 141], [143, 143, 170, 170, 243], [245, 245, 275, 275, 750], [752, 752, 777, 777, 977], [979, 979, 1034, 1034, 1258]]}
{"id": "NlX3Rf", "name": "Сollector", "author": "avin", "description": "visual experiment", "tags": ["tubes", "weaving", "weave", "wicker"], "likes": 4, "viewed": 241, "published": 3, "date": "1622486516", "time_retrieved": "2024-07-30T19:18:03.608038", "image_code": "#define PI 3.141592653589\n\n#define COL1 vec3(1.,0.,0.5)\n#define COL2 vec3(1.,0.8,0.2)\n#define SHADOW vec3(0.)\n\n\n\n#define SF 1./min(iResolution.x,iResolution.y)*.5*SCALE\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;  \n    \n    float SCALE = 1.75 + sin(iTime*.5)*.125;\n    \n    ouv *= SCALE;       \n    \n    vec3 col = vec3(0.);\n    \n    for(float ir=0.;ir<2.;ir+=1.){\n    \n        vec2 uv = ouv;\n        \n        \n        float ca = cos(PI * .25 * ir);\n        float sa = sin(PI * .25 * ir);\n        mat2 rot = mat2(ca, -sa, sa, ca);\n        uv *= rot;        \n                \n        // uv = abs(uv);\n    \n        for(int i=0;i<2;i+=1){\n\n            float x;\n            float y;\n\n            float fr = 16.;\n\n            if(i==0){\n                y = uv.x*fr;\n                x = uv.y;\n            } else {\n                y = uv.y*fr;\n                x = uv.x;\n            }\n            \n            float wooble = sin(-iTime*10. + length(uv)*10.)*.25+.5;\n\n\n            float sf = .05 + wooble*.01 ;   \n            float w = .025 + wooble*.01 ;\n            float ssFrom=.05;\n            float ssTo=.02;\n\n            float l = length(uv);\n            float shDraw; \n            if(ir == 0.){\n                shDraw = step(.15, l);\n            } else {\n                shDraw = step(.25, l);\n            }  \n            \n            \n\n            float d1v = abs(x + sin(y)*sf);    \n            float d1 = SS(d1v, w);\n            float d1o = 1. - smoothstep(0., w*2.25, d1v);\n            float d1s = smoothstep(ssFrom, ssTo, d1v) * shDraw;\n\n            float d2v = abs(x + sin(y + PI)*sf);   \n            float d2 = SS(d2v, w);\n            float d2o = 1. - smoothstep(0., w*2.25, d2v);\n            float d2s = smoothstep(ssFrom, ssTo, d2v) * shDraw;\n\n            float v = sin(y +  PI*.25);\n\n\n            if(v > 0.){\n                col = mix(col, COL1 * d1o, d1);                \n                col = mix(col, SHADOW, d2s); \n                col = mix(col, COL2* d2o, d2);  \n            } else {          \n                col = mix(col, COL2* d2o, d2);  \n                col = mix(col, SHADOW, d1s); \n                col = mix(col, COL1* d1o, d1);  \n            }\n\n            col *= SS(.035 + wooble*.015, l);\n\n        }\n    }\n    \n        \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlX3Rf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 266, 266, 2408]]}
{"id": "7ll3D4", "name": "31052021", "author": "Pixdigit", "description": "Some shader practice", "tags": ["circle", "stars"], "likes": 3, "viewed": 264, "published": 3, "date": "1622485329", "time_retrieved": "2024-07-30T19:18:04.548523", "image_code": "const float TAU = 2. * 3.141569;\n\n\nvec3 pal(vec3 val) {\n    return 0.5 + 0.5*cos(val+vec3(0,2,4));\n}\n\nmat2 rot(float deg) {\n    float c = cos(deg);\n    float s = sin(deg);\n    return mat2(-c, s, s, c);\n}\n\nfloat rsin(float minVal, float maxVal, float val) {\n    float r = (maxVal - minVal) * 0.5;\n    return r * sin(val) + r + minVal;\n}\n\n\nfloat rand(float seed) {\n    return fract(sin(dot(vec2(seed),vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 2D SDF for a segment by IQ\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvec2 starTrail(float deg, float time) {\n    vec2 dir = vec2(sin(deg), cos(deg));\n    float phase = mod(time, 10.);\n    float d = pow(100., phase-1.3);\n    return dir*d;\n}\n\nvec3 star(vec2 uv, float seed) {\n\n    float deg = rand(seed+1.) * TAU;\n    float time = iTime*.1+rand(seed+2.)*10.;\n\n    vec3 col;\n    for (int i = 0; i<3; i++) {\n        vec2 trailStart = starTrail(deg, time + float(i) * 0.005);\n        vec2 trailEnd = starTrail(deg, time+0.1+ float(i) * 0.005);\n\n        if (length(trailStart) > length(trailEnd)) {\n            return vec3(0.);\n        }\n        \n        if (i == 0 && (abs(trailStart.y) > 1. || abs(trailStart.x) > iResolution.x / iResolution.y)) {\n            return vec3(0.);\n        }\n\n        float d = sdSegment(uv, trailStart, trailEnd);\n        \n        col[i] = smoothstep(.01, 0., d);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.;\n\n    vec3 waves = vec3(rsin(0.07, .13, length(uv) * 2. - iTime * 1.2));\n\n    vec2 uv2 = rot(iTime) * (uv + vec2(0.5, 0.5));\n    float scale = rsin(.5, 1., iTime);\n    vec3 ring = pal(vec3(uv2 * scale, 1.) * 4.);\n    float ringMask = smoothstep(0.03, 0.0, abs(1.-length(uv)));\n    \n    vec3 stars;\n    for (int i = 0; i < 1000; i++) {\n        stars = stars + star(uv, float(i));\n    }\n    float starMask = clamp(length(stars), 0., 1.);\n\n    col = mix(mix(waves, stars, starMask), ring, ringMask);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ll3D4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 55, 55, 100], [102, 102, 123, 123, 203], [205, 205, 256, 256, 335], [338, 338, 362, 362, 438], [440, 521, 573, 573, 692], [695, 695, 734, 734, 865], [867, 867, 899, 899, 1543], [1546, 1546, 1603, 1603, 2259]]}
{"id": "ftX3zX", "name": "Chinese papercuts 1", "author": "caogtaa", "description": "Chinese papercuts of the character \"囍\"", "tags": ["papercuts"], "likes": 4, "viewed": 271, "published": 3, "date": "1622482111", "time_retrieved": "2024-07-30T19:18:05.531893", "image_code": "// Papercut tutorial: https://www.youtube.com/watch?v=2Wgtj-q2Eig\n\n// Chinese papercuts\n// The character \"囍\", aka. \"Red Double Happiness\", is widely used in wedding since acient times in China.\n// Most Chinese are taught this in their childhood.\n// It is interesting that papercuts use symmetry a lot, just like how we play with shaders :-)\n\n#define PI 3.14159265\n\n// Function from iq\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\n// orange gradient\nvec3 pallette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.);\n    vec3 b = vec3(0.5, 0.31, 0.);\n    vec3 c = vec3(0., 0.15, 0.);\n    vec3 d = vec3(1., 0., 0.);\n    return a + b*cos(2.*PI*(c*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    // keep current uv in st for picking bg color\n    vec2 st = uv;\n    float mask = 1.;\n\n    // scale and cut margins\n    uv *= 1.2;\n    vec2 center = step(abs(uv), vec2(1.));\n    mask *= center.x * center.y;\n    \n    // overlap & cut\n    uv.x = abs(uv.x);\n    uv.x = uv.x > 0.5 ? 1.0 - uv.x : uv.x;\n    \n    // Divide space into 4 * 14 grids, for easy counting\n    // After overlapping, range of x is [0, 0.5], range of y is [-1, 1]\n    const vec2 grids = vec2(4./0.5, 14./2.);\n    \n    vec2 guv = uv * grids;\n    mask = min(mask, sdBox(guv - vec2(1.5, 6.5), vec2(1.5, 0.5)));\n    guv.y = guv.y < -1. ? guv.y + 6. : guv.y;\n    \n    mask = min(mask, sdBox(guv - vec2(2.5, 0.5), vec2(1.5, 0.5)));\n    mask = min(mask, sdBox(guv - vec2(1.5, 2.5), vec2(1.5, 0.5)));\n    mask = min(mask, sdBox(guv - vec2(1.5, 4.5), vec2(1.5, 0.5)));\n    mask = min(mask, sdBox(guv - vec2(0., 0.5), vec2(0.05, 1.5)));\n    \n    float blur = 2./iResolution.y;\n    mask = smoothstep(0., blur, mask);    \n\n    // mix color\n    vec3 col = vec3(0.);\n    col += mix(pallette(length(st)), pallette(2.5), mask);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftX3zX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[367, 438, 473, 473, 558], [560, 579, 603, 603, 773], [775, 775, 832, 832, 2023]]}
{"id": "sllGR2", "name": "GIA 2D Demo", "author": "paniq", "description": "demonstrating how segment tracing with gradient interval arithmetic avoids grazing surfaces. the white circles are all extrapolated from a single map query. the colorcycling point is the next estimated step point.", "tags": ["segmenttracing", "gia"], "likes": 15, "viewed": 809, "published": 3, "date": "1622470936", "time_retrieved": "2024-07-30T19:18:06.624971", "image_code": "\n// Gradient Interval Arithmetic\n// see https://www.shadertoy.com/view/WsKyDW for source shader\n\n//////////////////////////////////////////////////////////\n\n// GIA scalar for rays (1D)\nstruct gia1 {\n    float f0; // sample of f(0)\n    vec2 f1; // interval of f(1) / f'(0)\n};\n    \nstruct gia1x2 {\n    gia1 x;\n    gia1 y;\n};\n\nstruct gia1x3 {\n    gia1 x;\n    gia1 y;\n    gia1 z;\n};\n\n//////////////////////////////////////////////////////////\n\ngia1 gia_const(float x) {\n    return gia1(x, vec2(x));\n}\n\ngia1x3 gia_const(vec3 v) {\n    return gia1x3(gia_const(v.x), gia_const(v.y), gia_const(v.z));\n}\n\ngia1 gia_neg(gia1 x) {\n    return gia1(-x.f0, -x.f1.yx);\n}\n\nvec2 ia_sort(vec2 ia) {\n    return (ia.x > ia.y)?ia.yx:ia;\n}\n\nvec2 ia_merge(vec2 a, vec2 b) {\n    return vec2(min(a.x, b.x), max(a.y, b.y));\n}\n\ngia1 gia_add(gia1 a, gia1 b) {\n    return gia1(a.f0 + b.f0, a.f1 + b.f1);\n}\n\ngia1 gia_add(gia1 a, float b) {\n    return gia1(a.f0 + b, a.f1 + b);\n}\n\ngia1x3 gia_add(gia1x3 a, vec3 b) {\n    return gia1x3(gia_add(a.x, b.x), gia_add(a.y, b.y), gia_add(a.z, b.z));\n}\n\ngia1 gia_sub(gia1 a, gia1 b) {\n    return gia1(a.f0 - b.f0, a.f1 - b.f1.yx);\n}\n\ngia1 gia_sub(float a, gia1 b) {\n    return gia1(a - b.f0, a - b.f1.yx);\n}\n\ngia1 gia_sub(gia1 a, float b) {\n    return gia1(a.f0 - b, a.f1 - b);\n}\n\ngia1x2 gia_sub(gia1x2 a, gia1x2 b) {\n    return gia1x2(gia_sub(a.x,b.x),gia_sub(a.y,b.y));\n}\n\ngia1x3 gia_sub(gia1x3 a, gia1x3 b) {\n    return gia1x3(gia_sub(a.x,b.x),gia_sub(a.y,b.y),gia_sub(a.z,b.z));\n}\n\ngia1x3 gia_sub(gia1x3 a, vec3 b) {\n    return gia1x3(gia_sub(a.x,b.x),gia_sub(a.y,b.y),gia_sub(a.z,b.z));\n}\n\ngia1 gia_max(gia1 a, gia1 b) {\n    vec2 f0_f1min = ((a.f0 > b.f0)?vec2(a.f0, a.f1.x):vec2(b.f0, b.f1.x));\n    return gia1(f0_f1min[0], vec2((a.f0 == b.f0)?max(a.f1.x,b.f1.x):f0_f1min[1], max(a.f1.y, b.f1.y)));\n}\n\ngia1 gia_max(gia1 a, float b) {\n    vec2 f0_f1min = ((a.f0 > b)?vec2(a.f0, a.f1.x):vec2(b));\n    return gia1(f0_f1min[0], vec2((a.f0 == b)?max(a.f1.x,b):f0_f1min[1], max(a.f1.y, b)));\n}\n\ngia1x2 gia_max(gia1x2 a, gia1x2 b) {\n    return gia1x2(gia_max(a.x,b.x),gia_max(a.y,b.y));\n}\n\ngia1x2 gia_max(gia1x2 a, vec2 b) {\n    return gia1x2(gia_max(a.x,b.x),gia_max(a.y,b.y));\n}\n\ngia1x3 gia_max(gia1x3 a, gia1x3 b) {\n    return gia1x3(gia_max(a.x,b.x),gia_max(a.y,b.y),gia_max(a.z,b.z));\n}\n\ngia1x3 gia_max(gia1x3 a, vec3 b) {\n    return gia1x3(gia_max(a.x,b.x),gia_max(a.y,b.y),gia_max(a.z,b.z));\n}\n\ngia1 gia_min(gia1 a, gia1 b) {\n    return gia_neg(gia_max(gia_neg(a), gia_neg(b)));\n}\n\ngia1 gia_min(gia1 a, float b) {\n    return gia_neg(gia_max(gia_neg(a), -b));\n}\n\ngia1 gia_clamp(gia1 x, float mn, float mx) {\n    return gia_min(gia_max(x, mn), mx);\n}\n\ngia1 gia_abs(gia1 a) {\n    float f1min = (a.f0 > 0.0)?a.f1.x:-a.f1.y;\n    return gia1(abs(a.f0), vec2((a.f0 == 0.0)?max(a.f1.x,-a.f1.y):f1min, max(a.f1.y, -a.f1.x)));\n}\n\ngia1x3 gia_abs(gia1x3 a) {\n    return gia1x3(gia_abs(a.x),gia_abs(a.y),gia_abs(a.z));\n}\n\ngia1 gia_sign(gia1 a) {\n    // approximate hack. needs a clear head.\n    float s0 = sign(a.f0);\n    vec2 s1 = sign(a.f1);\n    if ((s0 == s1.x) && (s1.x == s1.y))\n        return gia1(s0, s1);\n    vec2 b = (s0 * a.f1 - abs(a.f1 - a.f0)) / a.f0;\n    b = (b.x < b.y)?b:b.yx;\n    return gia1(s0, ia_merge(b, vec2(min(s0,s1.x),max(s0,s1.y))));\n}\n\nvec2 minmax(vec3 f) {\n\treturn \n        vec2(min(min(f[0],f[1]),f[2]),\n            max(max(f[0],f[1]),f[2])); \n}\n\nvec2 minmax(vec4 f) {\n\treturn \n        vec2(min(min(f[0],f[1]),min(f[2],f[3])),\n            max(max(f[0],f[1]),max(f[2],f[3]))); \n}\n\ngia1 gia_mul(gia1 a, gia1 b) {\n    // bound f(1)\n    vec2 f1 = minmax(a.f1.xxyy * b.f1.xyxy);\n    // bound f'(0)\n    vec2 ff0 = minmax((b.f0*(a.f1 - a.f0)).xxyy + (a.f0*(b.f1 - b.f0)).xyxy);    \n\tfloat f0 = a.f0 * b.f0;\n    return gia1(f0, ia_merge(f0 + ff0, f1));\n}\n\ngia1 gia_mul(gia1 a, float b) {    \n    vec2 q = a.f1.xy * b;\n    return gia1(a.f0 * b, (b < 0.0)?q.yx:q);\n}\n\ngia1x2 gia_mul(gia1 a, vec2 b) {\n    return gia1x2(gia_mul(a, b.x), gia_mul(a, b.y));\n}\n\ngia1x3 gia_mul(gia1 a, vec3 b) {\n    return gia1x3(gia_mul(a, b.x), gia_mul(a, b.y), gia_mul(a, b.z));\n}\n\ngia1 gia_pow2(gia1 a) {\n    // bound f(1)\n    vec2 f1 = minmax(a.f1.xxy * a.f1.xyy);\n    // bound f'(0)\n    vec2 ff0a = a.f0*(a.f1 - a.f0);\n    vec2 ff0 = minmax(ff0a.xxy + ff0a.xyy);\n\tfloat f0 = a.f0 * a.f0;\n    return gia1(f0, ia_merge(f0 + ff0, f1));\n}\n\nfloat safeinv(float x) {\n    return (x == 0.0)?0.0:1.0/x;\n}\n\ngia1 gia_sqrt(gia1 a) {\n    float d = sqrt(a.f0);\n    vec2 ia_f = sqrt(max(vec2(0.0),a.f1));\n    vec2 ia_g = 0.5 * (a.f1 - a.f0) * safeinv(d);    \n    return gia1(d, ia_merge(ia_g + max(0.0, d), ia_f));\n}\n\ngia1 gia_dot(gia1x2 a) {\n    return gia_add(gia_pow2(a.x),gia_pow2(a.y));\n}\n\ngia1 gia_dot(gia1x3 a) {\n    return gia_add(gia_add(gia_pow2(a.x),gia_pow2(a.y)),gia_pow2(a.z));\n}\n\ngia1 gia_dot(gia1x2 a, vec2 b) {\n    return gia_add(gia_mul(a.x, b.x),gia_mul(a.y, b.y));\n}\n\ngia1 gia_length(gia1x2 v) {\n    return gia_sqrt(gia_dot(v));\n}\n\ngia1 gia_length(gia1x3 v) {\n    return gia_sqrt(gia_dot(v));\n}\n\ngia1 gia_mix (gia1 a, gia1 b, gia1 x) {\n    return gia_add(a, gia_mul(gia_sub(b,a),x));\n}\n\ngia1 gia_smin( gia1 a, gia1 b, float k ) {\n    gia1 h = gia_clamp(gia_add(gia_mul(gia_sub(b, a),0.5 / k),0.5), 0.0, 1.0 );\n    return gia_sub(gia_mix( b, a, h ), gia_mul(gia_mul(h, gia_add(gia_neg(h), 1.0)), k));\n}\n\ngia1 map(gia1x3 p) {\n    //return gia_sub(gia_length(p), 0.5);\n   \n    float a = iTime * 0.1;\n    float c = cos(a);\n    float s = sin(a);\n    gia1x3 rp = gia1x3(\n        gia_add(gia_mul(p.x, c), gia_mul(p.y, s)),\n        gia_add(gia_mul(p.x, s), gia_mul(p.y, -c)),\n        p.z\n    );\n    \n    gia1 s1 = gia_sub(gia_length(gia_add(p, vec3(0.0,-0.5,0.0))),0.2);\n    \n    gia1x3 w = gia_abs(rp);\n    gia1 s2 = gia_sub(gia_max(gia_max(w.x, gia_add(w.y,0.45)), w.z),0.5);\n    \n    return gia_min(s2,s1);\n}\n\n//////////////////////////////////////////////////////////\n\nvoid paint() {\n    float d = map(gia_const(vec3(get_origin(), 0.0))).f0;\n    set_source_rgb(hsl(d*10.0, 1.0, (d > 0.0)?0.75:0.25));\n    clear();\n    \n    vec2 p0 = vec2(-1.0, 0.0);\n    vec2 p1 = get_query();\n    set_source_rgb(vec3(0.0));\n    circle(p0, AAINV*3.0);\n    fill();\n    \n    if (iMouse.z > 0.5) {\n        set_source_rgb(vec3(0.0));\n        move_to(p0);\n        line_to(p1);\n        set_line_width_px(1.0);\n        stroke();\n        circle(p1, AAINV*3.0);\n        fill();\n        \n        vec3 ro = vec3(p1, 0.0);\n        vec3 rd = vec3((p0 - p1), 0.0);\n        float t = length(rd);\n        rd /= t;\n        gia1 g = map(gia_add(gia_mul(gia1(0.0, vec2(t)),rd),ro));\n       \n        const int N = 30;\n        for (int i = 0; i < N; ++i) {\n            float q = float(i)/float(N-1);\n            vec3 pos = ro + rd * q * t;\n            vec2 rinv = mix(vec2(g.f0), g.f1, q);\n            float r = (g.f0 < 0.0)?-rinv.y:rinv.x;\n            if (r>=0.0) {\n                set_source_rgb((r < 0.0)?vec3(0.0,0.5,1.0):vec3(1.0));            \n                circle(pos.xy, AAINV*3.0);\n                fill();\n                circle(pos.xy, abs(r));\n                stroke();\n            }\n        }\n        \n        // plot estimated root and next point to step to\n        if (g.f0 > 0.0) {\n            // solve g.f0 + (g.f1.x - g.f0) * q = 0\n            float q = -g.f0 / (g.f1.x - g.f0);\n            if (abs(q - 0.5) <= 0.5) { // has a root in the interval\n                vec3 pos = ro + rd * max(g.f0, q * t);\n                set_source_rgb(hsl(iTime*10.0, 1.0, 0.4));\n                circle(pos.xy, AAINV*3.0);\n                fill();\n            }\n        }\n    }\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n", "image_inputs": [], "common_code": "// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.11\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the new source with the old one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.4;\n\tAAINV = 1.0 / AA;\n    \n    uv = fragCoord.xy / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(sqrt(_color), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color = mix(_color,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[440, 440, 465, 465, 496], [498, 498, 524, 524, 593], [595, 595, 617, 617, 653], [655, 655, 678, 678, 715], [717, 717, 748, 748, 797], [799, 799, 829, 829, 874], [876, 876, 907, 907, 946], [948, 948, 982, 982, 1060], [1062, 1062, 1092, 1092, 1140], [1142, 1142, 1173, 1173, 1215], [1217, 1217, 1248, 1248, 1287], [1289, 1289, 1325, 1325, 1381], [1383, 1383, 1419, 1419, 1492], [1494, 1494, 1528, 1528, 1601], [1603, 1603, 1633, 1633, 1814], [1816, 1816, 1847, 1847, 2001], [2003, 2003, 2039, 2039, 2095], [2097, 2097, 2131, 2131, 2187], [2189, 2189, 2225, 2225, 2298], [2300, 2300, 2334, 2334, 2407], [2409, 2409, 2439, 2439, 2494], [2496, 2496, 2527, 2527, 2574], [2576, 2576, 2620, 2620, 2662], [2664, 2664, 2686, 2686, 2832], [2834, 2834, 2860, 2860, 2921], [2923, 2923, 2946, 2991, 3262], [3264, 3264, 3285, 3285, 3375], [3377, 3377, 3398, 3398, 3508], [3510, 3510, 3540, 3558, 3776], [3778, 3778, 3809, 3809, 3886], [3888, 3888, 3920, 3920, 3975], [3977, 3977, 4009, 4009, 4081], [4083, 4083, 4106, 4124, 4338], [4340, 4340, 4364, 4364, 4399], [4401, 4401, 4424, 4424, 4605], [4607, 4607, 4631, 4631, 4682], [4684, 4684, 4708, 4708, 4782], [4784, 4784, 4816, 4816, 4875], [4877, 4877, 4904, 4904, 4939], [4941, 4941, 4968, 4968, 5003], [5005, 5005, 5044, 5044, 5094], [5096, 5096, 5138, 5138, 5310], [5312, 5312, 5332, 5374, 5812], [5874, 5874, 5888, 5888, 7546], [7608, 7608, 7665, 7665, 7751]]}
{"id": "7tsGR2", "name": "ship searching", "author": "jorge2017a1", "description": "ship searching", "tags": ["2d", "draw", "ship", "poly"], "likes": 2, "viewed": 200, "published": 3, "date": "1622467770", "time_retrieved": "2024-07-30T19:18:07.678155", "image_code": "//por jorgefloresp.  ==jorge2017a1---22/may/2021\n//ship searching\n// Referencia\n//https://www.shadertoy.com/view/XsG3WR\n//Lunar Lander\n//Created by Hamneggs in 2016-01-27\n\n\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define PI 3.14\n#define roundnes 0.025\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n\n\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\n// Channel definitions.\n#define DATA_BUFFER iChannel0\n#define NOISE_TEX iChannel1\n\nconst vec3 ColWhite=vec3(1.0);\nconst vec3 ColBlack=vec3(0.0);\nconst vec3 ColCafe=vec3(0.76,0.596,0.47);\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\n\n\n\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n//https://www.shadertoy.com/view/XsG3WR\n//Lunar Lander\n//Created by Hamneggs in 2016-01-27\n\n/* \n    The FBM that gives rise to the terrain. (literally)\n */\nfloat fbm( in vec2 uv )\n{\n    float result = texture(NOISE_TEX, uv    ).r*1.000;\n    result += texture(NOISE_TEX, uv*2.0).r*.5000;\n    result += texture(NOISE_TEX, uv*4.01).r*.2500;\n    result += texture(NOISE_TEX, uv*8.0).r*.1250;\n    result += texture(NOISE_TEX, uv*16.).r*.0625;\n    return result * .533333; // * (1.0/1.875);\n}\n\n/* \n    The distance to the lunar surface, or rather \n    to a transformed FBM.\n */\nfloat distLunarSurface( in vec2 uv )\n{\n    uv.x *= .0125;\n    vec2 q = uv; q.y=0.0;\n    float f = fbm(q);\n    return uv.y - f*f*1.;\n}\n\n\nvec3 Lunar(vec2 p, vec3 col, vec3 colTierraA,vec3 colTierraB)\n{\n     float dl1=distLunarSurface(p);\n     float dl2=distLunarSurface(p-vec2(0.001,0.025));\n     \n     col= ponerBorde2(colTierraA, col, dl2 );\n     col= ponerBorde2(colTierraB, col, dl1 );\n     \n     \n     return col;\n}\n\n\nfloat sdPolyc001 POLY(7)\nvec2 ptc001[ 7]=vec2[](  \nvec2(.247,.399),vec2(.725,.392),vec2(.446,.456),vec2(.424,.525),vec2(.282,.532),\nvec2(.231,.661),vec2(.247,.399) );\n\n\nfloat sdPolyc002 POLY(5)\nvec2 ptc002[ 5]=vec2[](  \nvec2(.285,.519),vec2(.285,.472),vec2(.415,.465),vec2(.408,.506),vec2(.285,.519) );\n\nfloat sdPolyc003 POLY(7)\nvec2 ptc003[ 7]=vec2[](  \nvec2(.433,.534),vec2(.359,.447),vec2(.406,.337),vec2(.334,.205),vec2(.563,.170),\nvec2(.605,.412),vec2(.433,.534) );\n\nfloat sdPolyc004 POLY(6)\nvec2 ptc004[ 6]=vec2[](  \nvec2(.621,.617),vec2(.470,.489),vec2(.485,.393),vec2(.642,.337),vec2(.681,.458),\nvec2(.621,.617) );\n\nfloat sdPolyc005 POLY(6)\nvec2 ptc005[ 6]=vec2[](  \nvec2(.479,.673),vec2(.398,.567),vec2(.517,.476),vec2(.567,.507),vec2(.531,.598),\nvec2(.479,.673) );\n\n\nvec3 nave(vec2 p, vec3 col)\n{   float sdc001 = sdPolyc001(p, ptc001);\n    col=ponerBorde(vec3(0.0,0.0,0.8),col,sdc001 );   \n    \n    float sdc002 = sdPolyc002(p, ptc002);\n    col=ponerBorde(vec3(1.0),col,sdc002 );\n   return col;\n}\n\n\nvec3 rocaA(vec2 p, vec3 col)\n{\n    float sdc003 = sdPolyc003(p, ptc003);\n    col=ponerBorde(vec3(0.8,0.5,0.6),col,sdc003);\n    return col;\n}\n\nvec3 rocaB(vec2 p, vec3 col)\n{   float sdc004 = sdPolyc004(p, ptc004);\n    col=ponerBorde(vec3(0.6,0.8,0.5),col,sdc004);\n   return col;\n}\n\nvec3 rocaC(vec2 p, vec3 col)\n{   float sdc005 = sdPolyc005(p, ptc005);\n    col=ponerBorde(vec3(0.23,0.5582,0.988),col,sdc005 );\n return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 p=uv*0.5+vec2(0.0+iTime*0.25,0.5);\n    \n    vec2 p2=p;\n    p2.x= opRep1D(p2.x+(iTime*1.5+abs(sin(iTime*0.25))), 10.0 );\n    p2.y+=0.5*sin(iTime);\n    \n    \n    vec3 col=vec3(0.265,0.250,0.780);\n    \n    if (sin(iTime*0.5)>0.0)\n    {\n        col=Lunar(p-vec2(3.0+iTime*0.12,0.25),col,ColWhite, ColBlack );\n        col=Lunar(p,col,ColWhite,ColCafe);\n        col= nave(p+vec2(0.3-iTime*0.25,0.0),col);\n    }\n    else\n     {\n        col=Lunar(p-vec2(3.0+iTime*0.12,0.25),col,ColWhite, ColBlack ); \n        col= nave(p+vec2(0.3-iTime*0.25,0.0),col);\n        \n        col=Lunar(p,col,ColWhite,ColCafe);\n        \n    }\n    col=rocaA(p2, col);\n    col=rocaB(p2-vec2(2.5,0.0), col);\n    col=rocaC(p2-vec2(3.5,0.0), col);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsGR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1119, 1157, 1193, 1193, 1238], [1244, 1244, 1305, 1305, 1429], [1432, 1432, 1492, 1492, 1618], [1624, 1624, 1658, 1658, 1755], [1849, 1913, 1938, 1938, 2243], [2245, 2329, 2367, 2367, 2462], [2465, 2465, 2528, 2528, 2747], [3527, 3527, 3556, 3556, 3757], [3760, 3760, 3790, 3790, 3900], [3902, 3902, 3932, 3932, 4039], [4041, 4041, 4071, 4071, 4183], [4185, 4185, 4242, 4242, 5061]]}
{"id": "7llGzj", "name": "Concert Lights With Noise", "author": "veroro", "description": ".", "tags": ["concertligthsnoise"], "likes": 0, "viewed": 228, "published": 3, "date": "1622458281", "time_retrieved": "2024-07-30T19:18:08.437126", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float Speed = 8.0;\n\n//Reference: https://thebookofshaders.com/10/\nfloat random(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (fragCoord.xy * 40. - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n  vec3 col;\n  vec3 color = vec3(1., 1., random(uv));\n  for(float j = 0.0; j < 5.; j++)\n      for(float i = 1.; i < Speed; i++)\n      {\n          uv.x += uv.y * sin(iTime) / cos(iResolution.x);\n          col[int(j)] = clamp((abs(uv.x+uv.y)), 0.1, 1.0);\n      }\n  \n  vec3 bg = vec3(random(uv), random(uv), random(uv));\n  color = mix(col, bg, abs(sin(iTime)));\n  fragColor = vec4(vec3(color), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llGzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 118, 141, 141, 216], [218, 218, 273, 273, 763]]}
{"id": "stsGRj", "name": "Bouncing Sticks", "author": "dr2", "description": "Dynamics of colliding spherocylinders (mouseable, new runs start automatically or by clicking upper-right)", "tags": ["collision", "dynamics", "physics", "rigidbody"], "likes": 10, "viewed": 481, "published": 3, "date": "1622452693", "time_retrieved": "2024-07-30T19:18:09.728673", "image_code": "// \"Bouncing Sticks\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Based on bits from \"Bouncing Rings 2\" and \"Leaping Glowsticks\", with\n  more effective use of GPU parallelism.\n\n  No. 19 in \"Rigid Body Dynamics\" series\n    \"Stone Spiral\"           (XsyGDc)\n    \"Falling Towers\"         (lsG3W3)\n    \"Destruction\"            (XsKGWc)\n    \"Colliding Blocks\"       (lsG3Wd)\n    \"Jumping Cubes\"          (4s3Xzn)\n    \"Chocolate Dominoes\"     (ldBfz1)\n    \"Boxing Day\"             (ltSfzz)\n    \"Dancing Dumbbells\"      (lstyWr)\n    \"Desert Dumbbells\"       (lsdfD2)\n    \"Bouncing Rings\"         (MdVBD3)\n    \"Bouncing Chain\"         (XdKBDt)\n    \"Molecular Waltz\"        (Wt2GWG)\n    \"Colliding Blocks 2\"     (3tSXWz)\n    \"Dice Leaping\"           (3st3WS)\n    \"Leaping Glowsticks\"     (tttGR4)\n    \"Bouncing Rings 2\"       (3dScWc)\n    \"Floppy Clock With Dice\" (3sXBDr)\n    \"Soup Can Dynamics\"      (3tKyRt)\n*/\n\n#define VAR_ZERO min (iFrame, 0)\n\nmat3 QtToRMat (vec4 q);\nfloat Minv2 (vec2 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\nvec4 Loadv4 (int idVar);\n\nvec3 qHit, qnHit, ltDir;\nfloat tCur, dstFar, cylRad, cylLen, sphGap, sphOff;\nint idObj;\nconst float pi = 3.1415927;\n\n#define BIG_SYS  1  // same in all shaders\n\n#if BIG_SYS\nconst int nObj = 100, nSphObj = 60;\n#else\nconst int nObj = 60, nSphObj = 45;\n#endif\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float r, float h)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w, drz;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - r * r);\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    d /= max (a, 1e-6);\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < h) {\n      dMin = d;\n      vn = vec3 (s.xy, 0.);\n    } else {\n      drz = - h * sign (s.z);\n      ro.z += drz;\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - r * r);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          dMin = d;\n          vn = ro + d * rd;\n        }\n      }        \n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat ObjHit (vec3 ro, vec3 rd)\n{\n  mat3 mRot;\n  vec4 cdn4;\n  vec3 rm, rom, rdm;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = GetR (n);\n    mRot = QtToRMat (GetQ (n));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    cdn4 = CapsHit (rom, rdm, cylRad, cylLen);\n    if (cdn4.x < dMin) {\n      dMin = cdn4.x;\n      qHit = rom + dMin * rdm;\n      qnHit = cdn4.yzw;\n      idObj = n;\n    }\n  }\n  qnHit = QtToRMat (GetQ (idObj)) * normalize (qnHit);\n  return dMin;\n}\n\nfloat ObjHitSh (vec3 ro, vec3 rd, float rng)\n{\n  mat3 mRot;\n  vec4 cdn4;\n  vec3 rm, rom, rdm;\n  float dMin;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rm = GetR (n);\n    mRot = QtToRMat (GetQ (n));\n    rom = (ro - rm) * mRot;\n    rdm = rd * mRot;\n    cdn4 = CapsHit (rom, rdm, cylRad, cylLen);\n    dMin = min (dMin, cdn4.x);\n  }\n  return smoothstep (0.5 * rng, rng, dMin);\n}\n\nvec3 ObjCol (vec3 rd, vec3 vn, float sh)\n{\n  vec3 col;\n  col = HsvToRgb (vec3 (float (idObj) / float (nObj), 0.8, 0.9));\n  if (abs (qHit.z) < 0.3 * cylLen) col *= (0.7 +\n     0.3 * SmoothBump (0.3, 0.7, 0.05, (mod (4. * atan (qHit.y, - qHit.x) / pi, 1.))));\n  col = col * (0.2 +  0.8 * sh * max (dot (vn, ltDir), 0.)) +\n     0.2 * sh * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 vn, float sh)\n{\n  vec3 col;\n  col = (mix (vec3 (0.7, 0.4, 0.2), vec3 (0.4, 0.2, 0.1), Fbm2 (ro.xz * vec2 (1., 0.15))) *\n     (0.8 + 0.2 * smoothstep (0.07, 0.15, mod (ro.x, 4.)))) * (0.2 + 0.8 * sh * max (ltDir.y, 0.));\n  col *= 0.5 + 0.5 * smoothstep (0.92, 0.96, dot (normalize (200. * ltDir - ro), ltDir));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, sh;\n  bool isBg;\n  cylLen = sphGap * 0.5 * (float (nSphObj / 5) - 1.) - 0.1;\n  cylRad = sphGap * sphOff + 0.35;\n  isBg = false;\n  dstObj = ObjHit (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = qnHit;\n  } else {\n    ro += ((0.5 - ro.y) / rd.y) * rd;\n    vn = vec3 (0., 1., 0.);\n    isBg = true;\n  }\n  sh = 0.6 + 0.4 * ObjHitSh (ro + 0.01 * ltDir, ltDir, 40.);\n  if (! isBg) col = ObjCol (rd, vn, sh);\n  else col = BgCol (ro, vn, sh);\n  if (isBg && rd.y < 0.) {\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjHit (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = qnHit;\n      col = mix (col, ObjCol (rd, vn, 1.), 0.3);\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA    0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float az, el, asp, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  sphGap = stDat.y;\n  sphOff = stDat.z;\n  mPtr = Loadv4 (1);\n  dstFar = 250.;\n  az = 0.2 * pi * sin (0.02 * pi * tCur);\n  el = -0.2 * pi;\n  if (mPtr.z > 0. && Minv2 (mPtr.xy + 0.05 * vec2 (1. / asp, 1.) - 0.5) < 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, -0.1 * pi);\n  zmFac = 3.8;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -140.);\n  ltDir = vuMat * normalize (vec3 (0.5, 0.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && Minv2 (uv - vec2 (asp, 1.)) > -0.1) col = mix (col, vec3 (0., 1., 0.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 256.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Bouncing Sticks\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat todCur, nStep, nRun, sphGap, sphOff, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n#define BIG_SYS  1  // = 0/1 (same in all shaders)\n\n#if BIG_SYS\nconst int nObj = 100, nSphObj = 60;\n#else\nconst int nObj = 60, nSphObj = 45;\n#endif\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  return sphGap * vec3 (Rot2D (vec2 (sphOff, 0.), mod (s, 5.) * (2. * pi / 5.)),\n     (s - 0.5 * float (nSphObj)) / 5.);\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 10.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float b, fId;\n  fId = float (mId);\n  b = 2. * Hashff (17.31 * fId + floor (todCur) + 2.11 * (nRun + 1.)) - 1.;\n  rm.xz = 35. * sqrt (fId / float (nObj)) * sin (pi * (3. - sqrt(5.)) * fId + vec2 (0.5 * pi, 0.));\n  rm.y = 0.5 * sphGap * float (nSphObj / 5) + 5. + 3. * b;\n  qm = RMatToQt (DirToRMatT (normalize (vec3 (rm.xz, -80. * (1. + 0.2 * b))).xzy, vec3 (0., -1., 0.)));\n  vm = vec3 (-0.2 * (1. + 0.2 * b) * Rot2D (rm.xz, 0.3 * pi * b), - (1. + b)).xzy;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 5000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    sphGap = 1.5;\n    sphOff = 0.4;\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    sphGap = stDat.y;\n    sphOff = stDat.z;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = sphGap * float (nSphObj / 5) + 2.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, sphGap, sphOff, 0.);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = cross (vu, vd);\n  if (length (vc) > 0.) vc = normalize (vc);\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Bouncing Sticks\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat todCur, nStep, nRun, sphGap, sphOff, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n#define BIG_SYS  1  // = 0/1 (same in all shaders)\n\n#if BIG_SYS\nconst int nObj = 100, nSphObj = 60;\n#else\nconst int nObj = 60, nSphObj = 45;\n#endif\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  return sphGap * vec3 (Rot2D (vec2 (sphOff, 0.), mod (s, 5.) * (2. * pi / 5.)),\n     (s - 0.5 * float (nSphObj)) / 5.);\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 10.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float b, fId;\n  fId = float (mId);\n  b = 2. * Hashff (17.31 * fId + floor (todCur) + 2.11 * (nRun + 1.)) - 1.;\n  rm.xz = 35. * sqrt (fId / float (nObj)) * sin (pi * (3. - sqrt(5.)) * fId + vec2 (0.5 * pi, 0.));\n  rm.y = 0.5 * sphGap * float (nSphObj / 5) + 5. + 3. * b;\n  qm = RMatToQt (DirToRMatT (normalize (vec3 (rm.xz, -80. * (1. + 0.2 * b))).xzy, vec3 (0., -1., 0.)));\n  vm = vec3 (-0.2 * (1. + 0.2 * b) * Rot2D (rm.xz, 0.3 * pi * b), - (1. + b)).xzy;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 5000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    sphGap = 1.5;\n    sphOff = 0.4;\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    sphGap = stDat.y;\n    sphOff = stDat.z;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = sphGap * float (nSphObj / 5) + 2.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, sphGap, sphOff, 0.);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = cross (vu, vd);\n  if (length (vc) > 0.) vc = normalize (vc);\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Bouncing Sticks\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat todCur, nStep, nRun, sphGap, sphOff, farSep;\nconst float pi = 3.1415927;\nconst float txRow = 256.;\n\n#define PAR_SPH 1  // faster (uses extra parallelism, but needs 3 calls to complete)\n\n#define BIG_SYS  1  // = 0/1 (same in all shaders)\n\n#if BIG_SYS\nconst int nObj = 100, nSphObj = 60;\n#else\nconst int nObj = 60, nSphObj = 45;\n#endif\nconst int nSphTot = nObj * nSphObj;\nconst int nPre = 2;\n\nvec3 GetR (int k)\n{\n  return Loadv4 (nPre + 4 * k).xyz;\n}\n\nvec3 GetV (int k)\n{\n  return Loadv4 (nPre + 4 * k + 1).xyz;\n}\n\nvec4 GetQ (int k)\n{\n  return Loadv4 (nPre + 4 * k + 2);\n}\n\nvec3 GetW (int k)\n{\n  return Loadv4 (nPre + 4 * k + 3).xyz;\n}\n\n#if PAR_SPH\n\nvec3 GetAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k).xyz;\n}\n\nvec3 GetWAS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * k + 1).xyz;\n}\n\nvec3 GetRS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k).xyz;\n}\n\nvec3 GetVS (int k)\n{\n  return Loadv4 (nPre + 4 * nObj + 2 * nSphTot + 2 * k + 1).xyz;\n}\n\n#endif\n\nvec3 RSph (float s)\n{\n  return sphGap * vec3 (Rot2D (vec2 (sphOff, 0.), mod (s, 5.) * (2. * pi / 5.)),\n     (s - 0.5 * float (nSphObj)) / 5.);\n}\n\nvec3 FcFun (vec3 dr, float rSep, vec3 dv)\n{\n  vec3 f;\n  float rSepI, vRel, fo, drv;\n  const float fOvlap = 500., fricN = 1., fricT = 2., fricS = 10.;\n  rSepI = 1. / rSep;\n  fo = fOvlap * (rSepI - 1.);\n  drv = dot (dr, dv) * rSepI * rSepI;\n  dv -= drv * dr;\n  vRel = length (dv);\n  fo = max (fo - fricN * drv, 0.);\n  f = fo * dr;\n  if (vRel > 0.001) f -= min (fricT, fricS * abs (fo) * rSep / vRel) * dv;\n  return f;\n}\n\n#if PAR_SPH\n\nvoid StepRS (int sId, out vec3 rms, out vec3 vms)\n{\n  vec3 rs;\n  int mId;\n  mId = sId / nSphObj;\n  rs = QtToRMat (GetQ (mId)) * RSph (float (sId - mId * nSphObj));\n  rms = GetR (mId) + rs;\n  vms = GetV (mId) + cross (GetW (mId), rs);\n}\n\nvoid InitRS (int sId, out vec3 rms, out vec3 vms)\n{\n  rms = vec3 (0.);\n  vms = vec3 (0.);\n}\n\nvoid StepAS (int sId, out vec3 am, out vec3 wam)\n{\n  vec3 dr, rm, rms, vms, fc;\n  float rSep;\n  int mId, sIdN;\n  mId = sId / nSphObj;\n  rm = GetR (mId);\n  rms = GetRS (sId);\n  vms = GetVS (sId);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int mIdN = VAR_ZERO; mIdN < nObj; mIdN ++) {\n    if (mIdN != mId && length (rms - GetR (mIdN)) < farSep) {\n      for (int j = VAR_ZERO; j < nSphObj; j ++) {\n        sIdN = mIdN * nSphObj + j;\n        dr = rms - GetRS (sIdN);\n        rSep = length (dr);\n        if (rSep < 1.) {\n          fc = FcFun (dr, rSep, vms - GetVS (sIdN));\n          am += fc;\n          wam += cross (rms - rm, fc);\n        }\n      }\n    }\n  }\n  rSep = abs (rms.y);\n  if (rSep < 1.) {\n    fc = FcFun (vec3 (0., rms.y, 0.), rSep, vms);\n    am += fc;\n    wam += cross (rms - rm, fc);\n  }\n}\n\nvoid InitAS (int sId, out vec3 am, out vec3 wam)\n{\n  am = vec3 (0.);\n  wam = vec3 (0.);\n}\n\n#endif\n\nvoid StepM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  mat3 mRot;\n  vec3 dr, rs, am, wam, rMom;\n  float rSep, grav, dt;\n#if ! PAR_SPH\n  mat3 mRotN;\n  vec3 rmN, vmN, wmN, rsN, dv, rms, vms, fc;\n#endif\n  grav = 10.;\n  dt = 0.01;\n  rm = GetR (mId);\n  vm = GetV (mId);\n  qm = GetQ (mId);\n  wm = GetW (mId);\n  mRot = QtToRMat (qm);\n  am = vec3 (0.);\n  wam = vec3 (0.);\n#if ! PAR_SPH\n  for (int n = VAR_ZERO; n < nObj; n ++) {\n    rmN = GetR (n);\n    if (n != mId && length (rm - rmN) < farSep) {\n      vmN = GetV (n);\n      mRotN = QtToRMat (GetQ (n));\n      wmN = GetW (n);\n      for (int j1 = VAR_ZERO; j1 < nSphObj; j1 ++) {\n        rs = mRot * RSph (float (j1));\n        rms = rm + rs;\n        vms = vm + cross (wm, rs);\n        dv = vms - vmN;\n        fc = vec3 (0.);\n        for (int j2 = VAR_ZERO; j2 < nSphObj; j2 ++) {\n          rsN = mRotN * RSph (float (j2));\n          dr = rms - (rmN + rsN);\n          rSep = length (dr);\n          if (rSep < 1.) fc += FcFun (dr, rSep, dv - cross (wmN, rsN));\n        }\n        am += fc;\n        wam += cross (rs, fc);\n      }\n    }\n  }\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rs = mRot * rs;\n    dr = rm + rs;\n    rSep = abs (dr.y);\n    if (rSep < 1.) {\n      fc = FcFun (vec3 (0., dr.y, 0.), rSep, vm + cross (wm, rs));\n      am += fc;\n      wam += cross (rs, fc);\n    }\n  }\n#else\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    am += GetAS (mId * nSphObj + j);\n    wam += GetWAS (mId * nSphObj + j);\n  }\n#endif\n  rMom = vec3 (0.);\n  for (int j = VAR_ZERO; j < nSphObj; j ++) {\n    rs = RSph (float (j));\n    rMom += dot (rs, rs) - rs * rs + 1./6.;\n  }\n  rMom /= float (nSphObj);\n  wam = mRot * (wam * mRot / rMom);\n  am.y -=  grav;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam;\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid InitM (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float b, fId;\n  fId = float (mId);\n  b = 2. * Hashff (17.31 * fId + floor (todCur) + 2.11 * (nRun + 1.)) - 1.;\n  rm.xz = 35. * sqrt (fId / float (nObj)) * sin (pi * (3. - sqrt(5.)) * fId + vec2 (0.5 * pi, 0.));\n  rm.y = 0.5 * sphGap * float (nSphObj / 5) + 5. + 3. * b;\n  qm = RMatToQt (DirToRMatT (normalize (vec3 (rm.xz, -80. * (1. + 0.2 * b))).xzy, vec3 (0., -1., 0.)));\n  vm = vec3 (-0.2 * (1. + 0.2 * b) * Rot2D (rm.xz, 0.3 * pi * b), - (1. + b)).xzy;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm, am, wam;\n  vec2 iFrag, canvas;\n  float asp, mxStep, nSubStep;\n  int mId, pxId, kp;\n#if PAR_SPH\n  vec3 rms, vms;\n  int sId, rId;\n#endif\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n#if PAR_SPH\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj + 4 * nSphTot) discard;\n#else\n  if (iFrag.x >= txRow || pxId >= nPre + 4 * nObj) discard;\n#endif\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  kp = nPre + 4 * nObj;\n  mId = (pxId >= nPre && pxId < kp) ? (pxId - nPre) / 4 : -1;\n#if PAR_SPH\n  sId = (pxId >= kp && pxId < kp + 2 * nSphTot) ? (pxId - kp) / 2 : -1;\n  rId = (pxId >= kp + 2 * nSphTot) ? (pxId - (kp + 2 * nSphTot)) / 2 : -1;\n#endif\n  doInit = false;\n  mxStep = 5000.;\n  if (iFrame <= 5) {\n    doInit = true;\n    nRun = 0.;\n    sphGap = 1.5;\n    sphOff = 0.4;\n  } else {\n    stDat = Loadv4 (0);\n    nStep = stDat.x;\n    sphGap = stDat.y;\n    sphOff = stDat.z;\n    stDat = Loadv4 (1);\n    mPtrP.z = stDat.z;\n    nRun = stDat.w;\n    ++ nStep;\n    if (nStep > mxStep || nStep > 50. && mPtr.z > 0. && mPtrP.z < 0. &&\n       Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0.) doInit = true;\n  }\n  if (doInit) {\n    ++ nRun;\n    nStep = 0.;\n  }\n  doInit = (doInit || nStep < 20.);\n  nSubStep = mod (nStep, 3.);\n  farSep = sphGap * float (nSphObj / 5) + 2.;\n#if PAR_SPH\n  if (! doInit && (pxId >= nPre + 4 * nObj && (nSubStep == 2. || nSubStep == 1. && sId < 0 ||\n     nSubStep == 0. && rId < 0))) discard;\n#endif\n  if (mId >= 0) {\n    if (doInit) InitM (mId, rm, vm, qm, wm);\n    else {\n#if PAR_SPH\n      if (nSubStep == 2.) StepM (mId, rm, vm, qm, wm);\n      else {\n        rm = GetR (mId);\n        vm = GetV (mId);\n        qm = GetQ (mId);\n        wm = GetW (mId);\n      }\n#else\n      StepM (mId, rm, vm, qm, wm);\n#endif\n    }\n    kp = nPre + 4 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4 (wm, 0.);\n#if PAR_SPH\n  } else if (sId >= 0) {\n    if (doInit) InitAS (sId, am, wam);\n    else StepAS (sId, am, wam);\n    kp = nPre + 4 * nObj + 2 * sId;\n    if      (pxId == kp + 0) stDat = vec4 (am, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (wam, 0.);\n  } else if (rId >= 0) {\n    if (doInit) InitRS (rId, rms, vms);\n    else StepRS (rId, rms, vms);\n    kp = nPre + 4 * nObj + 2 * nSphTot + 2 * rId;\n    if      (pxId == kp + 0) stDat = vec4 (rms, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vms, 0.);\n#endif\n  } else {\n    if      (pxId == 0) stDat = vec4 (nStep, sphGap, sphOff, 0.);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nRun);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = cross (vu, vd);\n  if (length (vc) > 0.) vc = normalize (vc);\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5)) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsGRj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1520, 1520, 1539, 1539, 1577], [1579, 1579, 1598, 1598, 1636], [1638, 1638, 1689, 1689, 2325], [2327, 2327, 2360, 2360, 2828], [2830, 2830, 2876, 2876, 3225], [3227, 3227, 3269, 3269, 3648], [3650, 3650, 3691, 3691, 4001], [4808, 4808, 4864, 4864, 6134], [6136, 6136, 6161, 6161, 6536], [6538, 6538, 6560, 6560, 6587], [6589, 6589, 6646, 6646, 6729], [6731, 6731, 6761, 6761, 6874], [6876, 6876, 6912, 6912, 7118], [7120, 7120, 7144, 7144, 7261], [7355, 7355, 7380, 7380, 7503], [7537, 7537, 7561, 7561, 7673], [7675, 7675, 7700, 7700, 7886], [7888, 7888, 7909, 7909, 8064]]}
{"id": "Nls3Rj", "name": "Simple raymarching shader", "author": "Danimtz", "description": "Testing out raymarching and signed distance functions combined with basic blinn phong lighting. \n\"Manual\" bounce light added for better looks. Added soft shadows", "tags": ["raymarching", "sdf", "blinnphonglighting"], "likes": 3, "viewed": 302, "published": 3, "date": "1622432838", "time_retrieved": "2024-07-30T19:18:10.579398", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 200.0\n#define SURF_DIST 0.01\n#define AA 2\n\n#define SPHERE1 1.0\n#define PLANE 0.0\nfloat sdSphere(vec3 p, float r)//Signed distance function of sphere\n{\n    return length(p) - r;\n}\n\nvec2 compSDF(vec2 sdf1, vec2 sdf2)\n{\n    return sdf1.x<sdf2.x ? sdf1 : sdf2;\n}\n\nvec2 map(vec3 p) //Scene geometry information\n{\n    vec3 sph_o = vec3(cos(0.2*iTime), 2.0, 10.0+3.0*sin(0.2*iTime));\n    vec2 cur_sdf = vec2(1e10, 0.0);\n\n    cur_sdf = compSDF(cur_sdf, vec2(p.y, PLANE)); //plane\n    cur_sdf = compSDF(cur_sdf, vec2(sdSphere(p-sph_o, 2.0), SPHERE1)); //sphere\n    cur_sdf = compSDF(cur_sdf, vec2(sdSphere(p-sph_o+vec3(3.2,0.5,-0.5), 0.7), SPHERE1)); //sphere\n    \n    return cur_sdf;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.001;\n    vec2 res;\n    for(int i = 0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + dO*rd; //Go along ray\n        res = map(p); //Calc distance to surface, res.x\n        if(res.x < SURF_DIST || dO>MAX_DIST) break;\n        dO += res.x ;\n    }\n    if (dO > MAX_DIST) dO = -1.0;\n    return vec2(dO, res.y);\n}\n\nfloat calcSoftShdw(vec3 ro, vec3 rd, float k)\n{\n    //more info: https://iquilezles.org/articles/rmshadows\n    //Circle circle intersection: https://mathworld.wolfram.com/Circle-CircleIntersection.html\n\n    float res = 1.0; //1.0 if hard shadow\n    float prev_d = 1e10; //previous closest distance to surface\n    for(float t = 0.0; t<MAX_DIST;)\n    {\n        float d = map(ro + t*rd).x;\n        if(d < SURF_DIST){ return 0.0; }\n        float y = d*d/(2.0*prev_d); //y: distance from curr pos to ray midpoint \n        float d_ys = sqrt(d*d-y*y);//d_ms: distance from y to closest surface\n        float sh =  clamp(k*d_ys/max(0.0, t-y),0.0,1.0);\n        \n        res = min(res, sh*sh*(3.0-2.0*sh));//apply smoothstep (3-2x)*x^2\n        prev_d = d;\n        t += d;\n    }\n\n    return res;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    float d = map(p).x; //get distance to surface\n    vec2 e = vec2(0.01, 0);//error bias for difference\n    vec3 n = normalize(vec3( //find normal using small difference\n            d-map(p-e.xyy).x,    \n            d-map(p-e.yxy).x,  \n            d-map(p-e.yyx).x\n    ));\n    return n;\n}\n\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    //Raymarch pixel\n    vec2 res = rayMarch(ro, rd); //distance to point p\n    float d = res.x;\n    //sky colour\n    vec3 col = vec3(0.4, 0.6, 0.8) - 0.7*rd.y;\n    if (d > 0.0){\n\n        vec3 p = ro + d*rd;\n        //colour and lights\n        vec3 mat = vec3(0.0);\n        if(res.y<1.0){ mat = vec3(0.017, 0.02, 0.03);}\n        else if(res.y<2.0){ mat = vec3(0.18);}\n\n        \n\n        vec3 lpos = vec3(1.5, 1.5, -1.0);\n        float speed = 1.0;\n        //lpos.xz += vec2(sin(iTime*speed), cos(iTime*speed))*2.;\n\n        //light & normal vectors\n        vec3 l = normalize(lpos-0.0);\n        vec3 n = calcNormal(p);\n\n        //diffuse light\n        float dif = clamp(dot(n,l), 0.0, 1.0);\n        float sky_dif = clamp(0.5+0.5*dot(n,vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bounce_dif = clamp(0.2+0.2*dot(n,vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        float shdw = calcSoftShdw(p+n*SURF_DIST, l, 16.0); //step(rayMarch((p+n*SURF_DIST), l).x, 0.0);//hard shadows\n        \n        //specular light\n        vec3 h = normalize(l + normalize((ro-p)));\n        float spec = pow(max(0.0, dot(n,h)), 128.0);\n        \n\n        vec3 light_in = vec3(0.0);\n        light_in += vec3(7.0, 5.8, 3.6)*dif*shdw;\n        light_in += vec3(0.5, 0.8, 0.6)*sky_dif;\n        light_in += vec3(0.6, 0.3, 0.1)*bounce_dif;\n\n        col = mat*light_in;\n\n        col += mat*spec*shdw;\n    }\n    return (col);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera/Ray origin\n    vec3 ro = vec3(0.0, 2.7, -1.2);\n\n\n    vec3 avrg_col = vec3(0.0);\n#if AA>1 //Supersampling AA\n    for(int i = 0; i < AA; i++)\n    for(int j = 0; j < AA; j++){\n        //Pixel coordinates\n        vec2 of = vec2(float(i),float(j)) / float(AA) - 0.5;\n        vec2 uv = ((fragCoord+of)- .5*iResolution.xy)/iResolution.y;\n#else\n        \n        vec2 uv = (fragCoord- .5*iResolution.xy)/iResolution.y;\n#endif\n        \n        //Ray direction\n        vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n        \n        //Render scene\n        vec3 col = render(ro,rd);\n        \n        \n\n        avrg_col += col;\n\n#if AA>1      \n    }\n    avrg_col /= float(AA*AA);//Apply AA\n#endif\n    //gamma\n    avrg_col = pow(avrg_col, vec3(0.4545));\n\n    fragColor = vec4(avrg_col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nls3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 189, 189, 217], [219, 219, 255, 255, 297], [299, 299, 346, 346, 716], [718, 718, 751, 751, 1074], [1076, 1076, 1123, 1277, 1862], [1864, 1864, 1889, 1889, 2179], [2183, 2183, 2214, 2235, 3601]]}
{"id": "fls3Rj", "name": "HelloWorldCine", "author": "adamgoodapp", "description": "Testing cineshader", "tags": ["cineshader"], "likes": 1, "viewed": 5674, "published": 3, "date": "1622432580", "time_retrieved": "2024-07-30T19:18:11.385244", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(abs(sin(iTime)),0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3Rj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 314]]}
{"id": "stf3zj", "name": "Atmosphere I guess", "author": "michael0884", "description": "atmosphere", "tags": ["atmosphere"], "likes": 28, "viewed": 736, "published": 3, "date": "1622409209", "time_retrieved": "2024-07-30T19:18:12.282844", "image_code": "//CAMERA stuff\n#define FOV 1.0\n#define ANG 0.001\n\nvec4 rand4blue()\n{\n    return texelFetch(iChannel0, shift2(), 0);\n}\n\n\nvec3 light = normalize(vec3(0,1,0));\nconst float light_bright =1.0;\nconst float light_ang = 0.1;\nconst float samp = 16.0;\n\n\n//atmosphere illuminated by a sun\nvec3 atmo2(vec3 r, vec3 rd)\n{\n    vec2 si0 = sphIntersect(r, rd, vec3(0), R + H*10.0);\n    vec2 si1 = sphIntersect(r, rd, vec3(0), R);\n    \n    //range between the start of the atmosphere and end/surface\n    vec2 range = max(vec2(si0.x, si1.x>0.0?min(si1.x, si0.y):si0.y),0.0);\n    float dr = range.y - range.x;\n    vec3 L = vec3(0.0);\n    float dx = 1.0/samp;\n    vec4 dither = rand4blue();\n    for(float t = dx*dither.x; t <= 1.0; t+=dx)\n    {\n        float td = mix(range.x, range.y, t);\n        vec3 p = r + rd*td;\n        vec4 shadow = atmo(p, light, 1e10);\n        vec4 cam = atmo(r, rd, td);\n        vec3 incoming = shadow.xyz*shadow.w;\n        vec3 scattering = scatter(p, rd, light)*incoming;\n        vec3 visibility = cam.xyz;\n        L += visibility*scattering*dx;\n    }\n    \n    return light_bright*L*dr;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nmat3 get_cam(float phi, float theta)\n{\n    vec3 z_dir = vec3(cos(phi)*sin(theta),  cos(theta), sin(phi)*sin(theta));\n    vec3 x_dir = normalize(cross(z_dir, vec3(0,1,0)));\n    vec3 y_dir = normalize(cross(x_dir, z_dir));\n    return mat3(x_dir, y_dir, z_dir);\n}\n\nvec3 saturate(vec3 c)\n{\n    return tanh(pow(c,vec3(0.65)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rng_initialize(fragCoord, iFrame);\n    init();\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 m = PI*iMouse.xy/iResolution.xy + 1e-3;\n    \n    mat3 cam = get_cam(-PI*0.5,PI*0.05);\n    mat3 cam1 = get_cam(2.0*m.x, PI - m.y);\n    \n    light = cam1*light;\n  \n    vec3 ro = vec3(0,0,1.01+0.007*sin(iTime));\n    vec3 rd = normalize(cam*vec3(FOV*uv, 1.0));\n    \n    vec3 c = atmo2(ro, rd);\n    // Output to screen\n    fragColor = vec4(saturate(c), 1.0);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n\n// basic parameters\nfloat R = 1.;\t\t\t\t\t\t\t\t// planet radius\nfloat H = 0.003;\t\t\t\t\t\t\t// density scale-height of atmosphere (not pressure scale height)\n\n// Rayleigh extinction coefficients, \n// calculated for a nitrogen gas (polarizability 1.82e-30)\n// with temp 290 K, press 101300 Pa, wavelengths 655 (R), 540 (G) and 425 (B) nm,\n// and a scale of 1 unit = 6400 km (earth radius).\nvec3 beta = vec3( 38.05, 82.36, 214.65 );\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n// a small absobtion in the orange band is added\n// to simulate the effect of ozone\nvec3 absorb = vec3( 0.75, 0.85, 1. );\t\t\t\n\n// devrived values\nfloat LN2 = 0.693147181;\nfloat H50;\nvec3 beta50;\nfloat invH50;\nfloat X50;\n\nvoid init()\n{\n   H50 = H * LN2;\n   beta50 = beta * LN2;\n   invH50 = 1. / H50;\n   X50 = R / H50;\n}\n// --------------------------------------------------------\n\n// sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(1e10); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n// --------------------------------------------------------\n\nfloat chapman( float X, float h, float coschi )\n{\n\t// this is the approximate Chapman function,\n\t// corrected for transitive consistency \n\n\tfloat c = sqrt( X + h );    \n    \n\tif( coschi >= 0. )\n\t{\t\n \t\treturn c / ( c * coschi + 1. ) * exp2( -h );\n\t}\n\telse\n\t{\n\t\tfloat x0 = sqrt( 1. - coschi * coschi ) * ( X + h );\n\t\tfloat c0 = sqrt( x0 );    \n\t\treturn 2. * c0 * exp2( X - x0 ) - c / ( 1. - c * coschi ) * exp2( -h );\n\t}\n}\n\n// --------------------------------------------------------\n\nvec3 transmittance( vec3 r, vec3 viewdir )\n{\n\t// a quick function to get the transmittance\n\t// looking from point r into infinity\n\n\tfloat rsq = dot(r,r);\n\tfloat invrl = inversesqrt( rsq );\n\tfloat len = rsq * invrl;\n\tfloat x = len * invH50;\n\tfloat h = x - X50;\n\tfloat coschi = dot( r, viewdir ) * invrl;\n\t\n\treturn beta50 * H50 * chapman( X50, h, coschi ) ;\n}\n\nfloat density(vec3 r)\n{\n\tfloat rsq = dot(r,r);\n\tfloat invrl = inversesqrt( rsq );\n\tfloat len = rsq * invrl;\n\tfloat x = len * invH50;\n\tfloat h = x - X50;\n    return exp2(-h);\n}\n\nfloat HenyeyGreenstein(float g, float costh)\n{\n    return (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}\n\nfloat scatterAnisotropy(vec3 ri, vec3 ro)\n{\n    return mix(1.0, 4.*PI*HenyeyGreenstein(0.5, dot(ri, ro)), 0.33) + HenyeyGreenstein(0.9995, dot(ri, ro));\n}\n\nvec3 scatter(vec3 r, vec3 rd, vec3 ld)\n{\n    return beta50*scatterAnisotropy(rd, ld)*density(r);\n}\n\nvec4 atmo(vec3 r, vec3 rd, float td)\n{\n    vec2 si = sphIntersect(r, rd, vec3(0), R);\n    \n    float inv = sign(dot(rd,r));\n    float hit = 1.0;\n    if(si.x < 1e10 && si.x > 0.0) \n    {\n        td = min(si.x, td);\n        hit = 0.0;\n    }\n    else inv = 1.0;\n    \n    vec3 depth = inv*(transmittance(r, rd*inv) - transmittance(r + rd*td, rd*inv));\n    \n    return vec4(exp2(-depth), hit);\n}\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stf3zj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 68, 68, 117], [244, 278, 307, 307, 1096], [1098, 1098, 1136, 1136, 1201], [1203, 1203, 1241, 1241, 1463], [1465, 1465, 1488, 1488, 1526], [1528, 1528, 1585, 1585, 2063]]}
{"id": "slX3RB", "name": "Water droplets", "author": "sheepmaster", "description": "Wave simulation of randomly distributed water droplets falling onto a surface.", "tags": ["2d", "wave", "water", "droplets"], "likes": 6, "viewed": 538, "published": 3, "date": "1622392040", "time_retrieved": "2024-07-30T19:18:13.100657", "image_code": "const float WAVELENGTH = 30.;\nconst float WAVE_FREQUENCY = 3.;\nconst float INTENSITY_DISTANCE_DROPOFF_SCALE = 0.001;\nconst float INTENSITY_TIME_DROPOFF_SCALE = 1.;\nconst float DROP_FREQUENCY = 2.;\n\n// Minimum amount of time to look back for drops.\nconst float TIME_WINDOW = 10.;\n\nconst float TAU = 8. * atan(1.);\n\n// Samples an exponential distribution with the parameter lambda,\n// given a uniform sample `u` between 0 and 1.\nfloat exponentialSample(float u, float lambda) {\n    return -log(u) / lambda;\n}\n\nfloat sigmoid(float x) {\n    float expX = exp(x);\n    return expX / (expX + 1.);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p + 1.) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n// Calculate the impact of all drops that have fallen between\n// `startTime` and `endTime`. \nfloat calcDrops(vec2 fragCoord, float startTime, float endTime) {\n    float z = 0.;\n    while (true) {\n        vec3 hash = hash31(startTime);\n        vec2 dropCenter = hash.xy * iResolution.xy;\n        \n        // The time between drops is exponentially distributed.\n        float dropTime = startTime + exponentialSample(hash.z, DROP_FREQUENCY);\n        if (dropTime >= endTime) {\n            break;\n        }\n\n        float d = length(fragCoord - dropCenter);\n        float t = (iTime - dropTime) * WAVE_FREQUENCY - d / WAVELENGTH;\n        \n        // Intensity drops off with the square of the distance...\n        float distanceIntensity = min(1., 1. / (d * d * INTENSITY_DISTANCE_DROPOFF_SCALE));\n\n        // ...and exponentially with time.\n        float timeIntensity = t >= 0. ? 1./exp(t * INTENSITY_TIME_DROPOFF_SCALE) : 0.;\n\n        z += sin(t * TAU) * timeIntensity * distanceIntensity;\n        \n        startTime = dropTime;\n    }\n    return z;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float i = floor(iTime / TIME_WINDOW) - 1.;\n    float startTime = i * TIME_WINDOW;\n    float endTime = startTime + TIME_WINDOW;\n    \n    // Split up the calculation into two intervals\n    // to get a total interval length of at least TIME_WINDOW\n    // while keeping the start values stable.\n    float z = calcDrops(fragCoord, startTime, endTime);\n    z += calcDrops(fragCoord, endTime, iTime);\n\n    fragColor = vec4(vec3(sigmoid(z)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slX3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 427, 475, 475, 506], [508, 508, 532, 532, 590], [592, 633, 655, 655, 793], [795, 888, 953, 953, 1844], [1846, 1846, 1898, 1898, 2344]]}
{"id": "flf3Rj", "name": "Simple bubbles raymarch VR", "author": "z0rg", "description": "Testing VR ", "tags": ["vrtest"], "likes": 3, "viewed": 329, "published": 3, "date": "1622382061", "time_retrieved": "2024-07-30T19:18:13.995266", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(1000.,-1.);\n    for (int i = 0; i < 10; ++i)\n    {\n        float fi = float(i)+iTime*0.0025;\n        vec3 pos = p - vec3(sin(fi+iTime*.5), cos(fi*5.), cos(fi))*sin(fi*3.)*7.;\n        float sz = .5+.2*sin(fi);\n        acc = _min(acc, vec2(length(pos)-sz,0.));\n    }\n    for (int i = 0; i < 10; ++i)\n    {\n        float fi = float(i)+10.+iTime*.01;\n        vec3 pos = p - vec3(sin(fi+iTime*fi*.01), cos(fi*5.), cos(fi))*sin(fi*3.)*7.;\n        float sz = .05+.025*sin(fi);\n        acc = _min(acc, vec2(length(pos)-sz,1.));\n    }\n    return acc;\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p += rd * res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+(r*uv.x+u*uv.y)*3.);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 dordr(vec3 ro, vec3 rd)\n{\n    vec3 col = mix(vec3(1.000,0.000,0.349),vec3(.1), pow(sat(2.*abs(dot(rd, vec3(0.,1.,0.)))),.5));\n    vec3 res = trace(ro, rd, 32);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = (n *.5+.5);\n        if (res.z == 0.)\n            col = mix(vec3(1.000,0.000,0.349),vec3(.1,.1,.15), 1.-pow(sat(abs(dot(vec3(0.,1.,0.), n))),2.));\n        else\n            col = mix(vec3(0.094,0.969,0.471),vec3(.1,.1,.15), clamp(sin(n.y*10.),-1.,1.));\n        col = mix(vec3(0.05,0.1,0.2), col, 1.-sat(exp(-res.y*0.1)));\n    }\n    return col;\n}\n\nvec3 rdr2d(vec2 uv)\n{\n    float t = iTime*.5;\n    float d = 7.;\n    vec3 ro = vec3(sin(t)*d,0.,cos(t)*d);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    vec3 col = dordr(ro, rd);\n    return col;\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 col =dordr(fragRayOri,fragRayDir);\n    \n    fragColor = vec4(col,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col =rdr2d(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flf3Rj.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[430, 430, 457, 457, 510], [512, 512, 530, 530, 1094], [1096, 1096, 1137, 1137, 1360], [1362, 1362, 1393, 1393, 1529], [1531, 1531, 1562, 1562, 1676], [1678, 1678, 1708, 1708, 2292], [2294, 2294, 2315, 2315, 2534], [2535, 2535, 2629, 2629, 2711], [2712, 2712, 2769, 2769, 2899]]}
{"id": "7tsGzB", "name": "Rotating Color Balls", "author": "caogtaa", "description": "Rotating Color Balls", "tags": ["fractal"], "likes": 12, "viewed": 352, "published": 3, "date": "1622374673", "time_retrieved": "2024-07-30T19:18:14.829036", "image_code": "// shape control\n#define GRIDS 3.\n#define ITER 5.\n\n// 1/SPEED seconds per round\n#define ROTATE_SPEED  0.05\n\n#define PI 3.14159265\n#define SQRT2 1.41421356\n\nfloat Ring(vec2 uv, vec2 o, float r, float width) {\n\tfloat dist = distance(uv, o);\n\treturn abs(dist - (r - width));\n}\n\nfloat sdCircle(vec2 uv, vec2 o, float r, float blur) {\n    float dist = distance(uv, o);\n    return smoothstep(r, r-0.5-blur, dist);\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    \n    float blur = 3. / iResolution.y;\n    float mask = 0.;\n    float rotate_speed = ROTATE_SPEED;\n    float grids = GRIDS;\n    float part_id = 0.;\n    vec3 bg = vec3(0.);\n    \n    float angle;\n    float dist = length(uv);\n    bg = hsb2rgb(vec3(1./9., dist, 1.0));\n    vec3 last_color = vec3(0.);\n    for (float i = 0.; i < ITER; ++i) {\n        \n        float angle = atan(uv.y, uv.x);\n        \n        // angle = Remap(-PI, PI, 0., 1., angle);\n        angle = angle / (2. * PI) + 0.5;\n        \n        // align angle = 0 to +Y axis, totate by time\n        // angle = 0 对齐到 x正轴，追加一些旋转\n        angle = fract(angle + 0.5 + iTime * rotate_speed);\n\n        // divide area by angle\n        // 等分角度\n        grids = GRIDS + part_id;\n        part_id = floor(angle * grids);\n        float part_angle = fract(angle * grids);\n        \n        float every_other = mod(part_id, 2.0) * 2.0 - 1.0;\n        rotate_speed *= every_other * 2.0;\n        \n        // inverse map uv\n        // 将网格化后的角度重新映射回笛卡尔坐标\n        vec2 guv = vec2(cos(part_angle / grids * 2. * PI), sin(part_angle / grids * 2. * PI)) * dist;\n\n        // map uv to BBox of the inner circle of current sub area, circle radius become 1\n        // gr是(guv区域并uv大圆的)内接圆\n        // guv从[0,1]映射到以内接圆为中心的坐标，内接圆半径长度是1\n        float theta = 2. * PI / grids;\n        float S = sin(theta * 0.5);\n        float gr = S/(1.+S);\n        vec2 go = vec2(sqrt(1.-2.*gr), gr);\n        \n        // 坐标映射\n    \tuv = (guv - go) / gr;\n        dist = length(uv);\n        \n        // scale blur along with uv\n        // 坐标缩放后blur需要变粗\n        blur /= gr;\n        \n        // mix colors        \n        float compX = part_id / grids;\n        last_color = hsb2rgb(vec3(compX, dist, 1.0));\n        bg = bg * 0.75 + last_color * sdCircle(uv, vec2(0.), 1., blur) * 0.5;\n    }\n    \n    float width = 0.01;\n    float ring = Ring(uv, vec2(0.), 1., width);\n    // mask = ring;\n    mask += smoothstep(width+blur, width, ring);\n    \n    vec3 color = vec3(0.);\n    color += bg;\n    color += last_color * mask;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 207, 207, 273], [275, 275, 329, 329, 409], [411, 485, 511, 511, 744], [746, 746, 803, 803, 3086]]}
{"id": "stsGzB", "name": "Wicker2", "author": "avin", "description": "visual experiment", "tags": ["grid", "tiles", "weaving", "weave", "wicker"], "likes": 12, "viewed": 423, "published": 3, "date": "1622368336", "time_retrieved": "2024-07-30T19:18:15.756556", "image_code": "#define SIZE 10.\n#define PI 3.141592653589\n\n#define COL1 vec3(1.,0.,0.5)\n#define COL2 vec3(1.,0.8,0.2)\n#define SHADOW vec3(0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;    \n    \n    float ca = cos(PI * .25);\n    float sa = sin(PI * .25);\n    mat2 rot = mat2(ca, -sa, sa, ca);\n    uv *= rot;\n        \n    uv *= SIZE;\n    vec2 id = floor(uv);\n    uv = fract(uv) - 0.5;          \n\n    float d1 = step(abs(uv.x), .25);\n    float d1s = smoothstep(.5, .10, abs(uv.x));\n    float d2 = step(abs(uv.y), .25);\n    float d2s = smoothstep(.5, .10, abs(uv.y));\n    \n    vec3 col = vec3(0.);\n    \n    if(mod(id.x + id.y, 2.) == 0.){        \n        col = mix(col, COL1, d1);        \n        col = mix(col, SHADOW, d2s);\n        col = mix(col, COL2, d2);\n    } else {\n        col = mix(col, COL2, d2);\n        col = mix(col, SHADOW, d1s);\n        col = mix(col, COL1, d1);    \n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsGzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 185, 185, 996]]}
{"id": "7llGRB", "name": "scary face", "author": "yasuo", "description": "scary face from one of the One Piece animation scenes.", "tags": ["scary"], "likes": 5, "viewed": 366, "published": 3, "date": "1622363495", "time_retrieved": "2024-07-30T19:18:16.580353", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat faceParts(vec2 p) {\n    p.x = abs(p.x);\n    \n    float R = 0.015;\n    vec2 prevP = p;\n    \n    p*=Rot(radians(sin(iTime*60.0)*0.3));\n    p.y+=sin(sin(-iTime*50.0)*0.01);\n    p.x+=sin(p.y*0.1*iTime)*0.01*sin(iTime*53.0)*0.3;\n    float d = sdSegment(p,vec2(0.0,-0.1),vec2(0.0,0.1))-R;\n    p = prevP;\n    \n    p-=vec2(0.03,0.00);\n    p*=Rot(radians(sin(iTime*40.0)*5.15));\n    p.y+=sin(sin(iTime*69.0)*0.009);\n    p.x+=sin(p.y*0.1*iTime)*0.01*-sin(iTime*50.0)*0.3;\n    float d2 = sdSegment(p,vec2(0.0,-0.1),vec2(0.0,0.1))-R;\n    d = min(d,d2);\n    p = prevP;\n    \n    p-=vec2(0.06,0.01);\n    p*=Rot(radians(sin(iTime*50.0)*3.2));\n    p.y+=sin(sin(iTime*68.0)*0.005);\n    p.x+=sin(p.y*0.1*iTime)*0.01*sin(iTime*51.0)*0.3;\n    d2 = sdSegment(p,vec2(0.0,-0.095),vec2(0.0,0.095))-R;\n    d = min(d,d2);\n    p = prevP;\n    \n    p-=vec2(0.09,0.02);\n    p*=Rot(radians(sin(iTime*60.0)*2.22));\n    p.y+=sin(sin(iTime*60.0)*0.008);\n    p.x+=sin(p.y*0.1*iTime)*0.01*-sin(iTime*50.0)*0.3;\n    d2 = sdSegment(p,vec2(0.0,-0.095),vec2(0.0,0.095))-R;\n    d = min(d,d2);\n    p = prevP;\n    \n    p-=vec2(0.12,0.03);\n    p*=Rot(radians(sin(iTime*70.0)*6.23));\n    p.y+=sin(sin(iTime*66.0)*0.006);\n    p.x+=sin(p.y*0.1*iTime)*0.01*sin(iTime*56.0)*0.3;\n    d2 = sdSegment(p,vec2(0.0,-0.0925),vec2(0.0,0.0925))-R;\n    d = min(d,d2);\n    p = prevP;\n    \n    p-=vec2(0.15,0.04);\n    p*=Rot(radians(sin(iTime*80.0)*4.24));\n    p.y+=sin(sin(iTime*65.0)*0.005);\n    p.x+=sin(p.y*0.1*iTime)*0.01*sin(iTime*60.0)*0.3;\n    d2 = sdSegment(p,vec2(0.0,-0.09),vec2(0.0,0.09))-R;\n    \n    d = min(d,d2);\n    p = prevP;\n    \n    p-=vec2(0.18,0.06);\n    p*=Rot(radians(sin(iTime*70.0)*3.25));\n    p.y+=sin(sin(iTime*85.0)*0.008);\n    p.x+=sin(p.y*0.1*iTime)*0.01*-sin(iTime*45.0)*0.3;\n    d2 = sdSegment(p,vec2(0.0,-0.085),vec2(0.0,0.085))-R;\n    d = min(d,d2);\n    p = prevP;\n    \n    p-=vec2(0.21,0.08);\n    p*=Rot(radians(sin(iTime*30.0)*2.3));\n    p.y+=sin(sin(iTime*86.0)*0.006);\n    p.x+=sin(p.y*0.1*iTime)*0.01*sin(iTime*52.0)*0.3;\n    d2 = sdSegment(p,vec2(0.0,-0.08),vec2(0.0,0.08))-R;\n    d = min(d,d2);\n    p = prevP;\n    \n    p-=vec2(0.24,0.11);\n    p*=Rot(radians(sin(iTime*50.0)*5.35));\n    p.y+=sin(sin(iTime*60.0)*0.009);\n    p.x+=sin(p.y*0.1*iTime)*0.01*-sin(iTime*50.0)*0.3;\n    d2 = sdSegment(p,vec2(0.0,-0.075),vec2(0.0,0.075))-R;\n    d = min(d,d2);\n    p = prevP;\n    \n    p-=vec2(0.27,0.15);\n    p*=Rot(radians(sin(iTime*70.0)*7.4));\n    p.y+=sin(sin(iTime*80.0)*0.007);\n    p.x+=sin(p.y*0.1*iTime)*0.01*sin(iTime*53.0)*0.3;\n    d2 = sdSegment(p,vec2(0.0,-0.065),vec2(0.0,0.065))-R;\n    d = min(d,d2);\n    p = prevP;\n    \n    p-=vec2(0.3,0.19);\n    p*=Rot(radians(sin(iTime*70.0)*6.45));\n    p.y+=sin(sin(iTime*65.0)*0.01);\n    p.x+=sin(p.y*0.1*iTime)*0.01*-sin(iTime*54.0)*0.3;\n    d2 = sdSegment(p,vec2(0.0,-0.05),vec2(0.0,0.05))-R;\n    d = min(d,d2);\n    p = prevP;\n    \n    p-=vec2(0.33,0.23);\n    p*=Rot(radians(sin(iTime*70.0)*10.55));\n    p.y+=sin(sin(iTime*60.0)*0.006);\n    p.x+=sin(p.y*0.1*iTime)*0.01*sin(iTime*55.0)*0.3;\n    d2 = sdSegment(p,vec2(0.0,-0.035),vec2(0.0,0.035))-R;\n    d = min(d,d2);\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec3 col = vec3(0.0);\n    \n    /*\n    uv.x+=sin(uv.y*0.1*iTime)*0.01*sin(iTime*50.0)*0.3;\n    float d = sdSegment(uv,vec2(0.0,-0.1),vec2(0.0,0.1))-0.015;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    */\n    \n    uv.x*=0.8;\n    uv.y*=1.1;\n    uv.y+=0.3;\n    float d = faceParts(uv);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv*=2.0;\n    uv.x = abs(uv.x);\n    uv.x-=0.6;\n    uv.y-=0.65;\n    uv*=Rot(radians(180.0));\n    d = faceParts(uv);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    uv = prevUV;\n  \n    fragColor = vec4(col,1.0)*(noise(uv.x*uv.y*iTime*0.1))*5.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 181, 181, 255], [257, 308, 360, 360, 479], [481, 481, 506, 506, 3595], [3597, 3597, 3654, 3654, 4328]]}
{"id": "7tlGRB", "name": "sphere basic /w SDF", "author": "spectrum", "description": "이제 조금 뭔가 알 것 같기도 하고.\nsphere 에 pow 할때 .3 곱하니까 쨍하다.", "tags": ["sdf"], "likes": 1, "viewed": 231, "published": 3, "date": "1622362339", "time_retrieved": "2024-07-30T19:18:17.459004", "image_code": "float sphereSDF(vec2 pos, float r, vec2 center)\n{\n    // center\n    return pow(max(r - length(pos - center), 0.), r*.3)*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 중앙을 (.5,.5)으로 잡는다. 비율은 y기준으로 유지.\n\tvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 val = vec3(0,0,0);\n    \n    val += vec3(sphereSDF(uv, .05*abs(sin(200.+iTime*6.))+.25, vec2(0.,0.)) ,0.,0.);\n    val += vec3(0.,0.,sphereSDF(uv, .05*abs(sin(0.+iTime*6.))+.25, vec2(.4,.0)));\n    val += vec3(0.,sphereSDF(uv, .05*abs(sin(400.+iTime*6.))+.25, vec2(-.4,.0)), 0.);\n\n    fragColor = vec4(vec3(val), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 63, 125], [127, 127, 184, 258, 641]]}
{"id": "7ts3zS", "name": "acedtang_sphere", "author": "wiltchamberian", "description": "my first shader! render sphere , but  why if i set MAX_ITER_TIME =30 ,the image is wrong?", "tags": ["3d", "sphere"], "likes": 0, "viewed": 203, "published": 3, "date": "1622360067", "time_retrieved": "2024-07-30T19:18:18.269836", "image_code": "float sdf_sphere(vec3 p, vec3 center, float radius){\n    return length(p-center)-radius;\n}\n\nfloat sdf(vec3 p){\n    float dis = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.25;\n    return sdf_sphere(p,vec3(0,0,-1),0.5);\n}\n\n//cal color with normal vector\nvec3 calColor(vec3 dir,vec3 p){\n    float pi = 3.1415926535;\n    vec3 sunLight =  vec3(1.,1.,1.);//*sin(pi*2.0*float(iTime)*0.01);\n    \n    vec3 n = normalize(p-vec3(0,0,-1));\n    vec3 ndir = normalize(-dir);\n    \n    const vec3 sunDir = normalize(vec3(-1.,-1.,-1.));\n    vec3 h  = normalize((ndir-sunDir)*0.5);\n    \n    float co = dot(n,h);\n    return sunLight*vec3(0.8,0.2,0.2)*co;\n    //return vec3(0.8,0.2,0.2);\n}\n\n\n//dir should be nomalized\nvec3 rayMarching(vec3 v0, vec3 dir, const int maxIterTimes, float maxDistance,float tol1){\n    vec3 backgroundColor = vec3(0.2,0.2,0.8);\n    float totalDis = 0.0;\n    vec3 v = v0;\n    //return backgroundColor;\n    const float tol = 0.001;\n    const int MAX_ITER_TIME =10;\n    for(int i=0;i<MAX_ITER_TIME;++i){\n        float d = sdf(v);\n        if(d<tol){\n            return calColor(dir,v);\n        }\n        v = v+d*dir;\n        \n        totalDis+=d;\n        if(totalDis>maxDistance){\n            return backgroundColor;\n        }\n    }\n    return backgroundColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415926535;\n    //fragColor = vec4( vec3(1.,1.,1.)*cos(float(iTime)*pi*2.0*0.25),1.0);\n    //return;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 cameraPos = vec3(0.0,0.0,2.0);\n    vec3 leftcorner = vec3(-1.0,-1.0,1.0);\n    float w = 2.0;\n    float h = 2.0;\n    vec3 pixelPoint = leftcorner+ vec3(uv.x*w,uv.y*h,0);\n    vec3 dir = pixelPoint-cameraPos;\n    dir = normalize(dir);\n    vec3 color = rayMarching(cameraPos,dir,50,1000.0,0.001);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ts3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 90], [92, 92, 110, 110, 228], [230, 261, 292, 292, 678], [681, 707, 797, 797, 1274], [1276, 1276, 1333, 1333, 1999]]}
{"id": "sts3RS", "name": "Checkerboard room (raymarch)", "author": "A_KouZ1", "description": "Something something a port of the python script that renders this room", "tags": ["raymarching", "pianomiles", "trigophers"], "likes": 5, "viewed": 157, "published": 3, "date": "1622353134", "time_retrieved": "2024-07-30T19:18:19.028807", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\n\nfloat box(vec3 p,vec3 r){return max(abs(p.x)-r.x,max(abs(p.y)-r.y,abs(p.z)-r.z));}\n\nfloat sdf(vec3 p){return min(\n    -box(p-vec3(0,0,-3),vec3(6,2,6)),min(\n        box(p-vec3(2.5,0,2),vec3(1,4,1)),min(\n            box(p-vec3(-2.5,0,0),vec3(1,4,1)),\n            box(p-vec3(2.5,0,-2),vec3(1,4,1))\n            )\n        )\n    );}\n\nvec3 nrm(vec3 p){ vec3 a = vec3(1e-4,0,0);\n    return normalize(vec3(sdf(p+a.xyz),sdf(p+a.yxz),sdf(p+a.yzx)));\n}\n\nfloat ray(vec3 p,vec3 v){float d=0.;\n    for(int i=0; i<64; i++)d+=sdf(p+v*d);\n    return d;\n}\n\nfloat lit(vec3 p,vec3 q){\n    vec3 v = normalize(q-p);\n    float  d = distance(p,q);\n    float  n = dot(nrm(q),-v);\n    float  r = ray(p,v);\n    float  w = distance(p+r*v,q);\n    return n*min(1.,(1./64.)/w/w)/(d*d+1.);\n}\n\nvec3 rot_xy(vec3 v,float r){\nreturn vec3(v.x*cos(r)-v.y*sin(r),v.x*sin(r)+v.y*cos(r),v.z);}\n\nvec3 rot_xz(vec3 v,float r){\nreturn rot_xy(v.xzy,r).xzy;}\n\nvec3 rot_yz(vec3 v,float r){\nreturn rot_xy(v.yzx,r).zyx;}\n\nvec3 ren(vec2 uv){\n    vec3 p = vec3(0,0,-4);\n    vec3 q = normalize(vec3(uv,1));\n    \n    p = p + vec3(0,0,3.*(1.-cos(iTime)));\n    q = rot_xz(q,iTime/2.);\n    \n    \n    float  d = ray(p,q);\n    vec3 r = p+q*d;\n    \n    vec3 f = floor((.5+r-2.*floor(r/2.+.25))+0.001)-0.5;\n    float  g = f.x+f.y+f.z;\n    float  t = 1.-.7*floor(g-2.*floor(g/2.));\n    float B = 4.*t*(lit(vec3(-3,0,-2),r)+0.01);\n    float A = 4.*t*(lit(vec3(-3,0, 2),r)+0.01);\n    return vec3(2.*A+B/12.,4.*A/3.+B/3.,A/24.+B);//1/d*t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 ra = vec2(iResolution.x/iResolution.y,1);\n    vec2 uv = 2.*fragCoord/iResolution.xy*ra-vec2(ra.x,1);\n    fragColor = vec4(sqrt(ren(1.5*uv)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sts3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 118, 118, 175], [177, 177, 195, 195, 419], [421, 421, 438, 438, 533], [535, 535, 560, 560, 629], [631, 631, 656, 656, 851], [853, 853, 881, 881, 944], [946, 946, 974, 974, 1003], [1005, 1005, 1033, 1033, 1062], [1064, 1064, 1082, 1082, 1568], [1570, 1570, 1626, 1626, 1783]]}
{"id": "fls3RB", "name": "runners", "author": "lennyjpg", "description": "dfghhfgdfgh", "tags": ["fghdghgh"], "likes": 7, "viewed": 237, "published": 3, "date": "1622337528", "time_retrieved": "2024-07-30T19:18:19.866567", "image_code": "float random (vec2 st) {\nreturn fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 u = 10. * fragCoord / iResolution.y - .05;\nu.y += iTime*0.3;\nfloat rnd = random(floor(u));\nu = fract(u);\nfloat angle = -sin(iTime * 1.5 * rnd*5.5)*1.8;\nvec2 r = u + vec2(sin(angle),cos(angle)) * .3;\nfloat c = length(r - .5) * 3.;\nfragColor = vec4(smoothstep(c, c *1.2 ,0.6));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 92], [93, 93, 149, 149, 432]]}
{"id": "Nts3zS", "name": "Line segment Coordinate System", "author": "ircss", "description": "A useful coordinate system for procedural effects around lines for my reference", "tags": ["2d", "line", "coordinatesystem"], "likes": 5, "viewed": 339, "published": 3, "date": "1622326174", "time_retrieved": "2024-07-30T19:18:20.718290", "image_code": "\n// The coordinate is a vec3: X is the projection along the line (dot product), \n// Y is the distance to that projection clamped between the beginning and the end \n// of the segment to the actual pixel, Z is the projection of the error \n// vector on the orthogonal of p1 - p2. Note that \n// the Error vector (projection on line - pixelUV) is not nesssecrly orthogonal to the p1-p2,\n// since this projection is clamped to remain between p1 and p2, to function as a line segment\n// X and Z are good for doing procedural textures around the line, since they nicely/seamlessly wrap\n// around the line. Y is good for actually drawing the line with step and fwidth.\n// -------------------------------\nfloat rand(float seed) \n{\n  return fract(sin(seed *52.02) * 762.2);\n}\n\n\nfloat aaStep(float threshold, float x)\n{\n    float afwidth = clamp(length(vec2(dFdx(x), dFdy(x))) * 0.70710678118654757, 0. ,0.05);\n    return smoothstep(threshold-afwidth, threshold+afwidth, x);\n}\n\n\n// -------------------------------\n// THE ACTUAL LINE COORD FUNCTION\n// Alternativly you could also construct a 3x3 matrix with p2-p1 in x column, ortho to that in the y column and z column coordinates of p1, then multiply the pixel coordinates with that to transform the coordinate to the line coordinate. For line segments you would still have to clamp. This will probably be more instructions due to 3x3 having unnesscerly multiplications on zero entries\nvec3 LineSegCoord(vec2 p1, vec2 p2, vec2 uv){\n    \n\n    vec2 vector = p2 - p1;                      // Find the vector between the two lines\n          uv   -= p1;                           // Move the entire coord system so that the point 1 sits on the origin, it is either that or always adding point 1 when you want to find your actual point\n    float len   = length(vector);               // Find the ditance between the two points\n       vector  /= len;                          // normalize the vector \n    float vUv   = dot(vector, uv);              // Find out how far the projection of the current pixel on the line goes along the line using dot product\n    vec2  p     = vector * clamp(vUv, 0.,len) ; // since vector is normalized, the if you multiplied it with the projection amount, you will get to the coordinate of where the current uv has the shortest distance on the line. The clamp there ensures that this point always remains between p1 and p2, take this out if you want an infinite line\n    vec2 ToLine = p - uv;                       \n    float d     = length(ToLine);               // the actual distance between the current pixel and its projection on the line\n    \n    vec2 ortho    = vec2(vector.y, -vector.x);     // For 3D you would have to use cross product or something\n    float signedD = dot(ortho, ToLine);            // this gives you a signed distance between the current pixel and the line. in contrast to the value d, first this value is signed, so different on the different sides of the line, and second, for a line segment with finite ends, beyond the finit end, the magnitude of this value and d start to differ. This value will continue to get smaller, as you go around the corner on the finit edge and goes into negative\n    \n    return vec3(vUv, d, signedD); \n}\n\n// -------------------------------\nfloat movement(float seed)\n{\n  float speed = 1.;\n  float d = sin(rand(seed           ) * 512.2 + iTime  *0.4 * speed) *0.5;\n        d+= sin(rand(seed*12.+613.52) * 61.2  + iTime  *0.3 * speed) *0.25;\n        d+= sin(rand(seed*83.+22.52 ) * 721.2 + iTime  *1.2 * speed) *0.25;\n\n  return d;\n}\n\n\n\n\n// ---------------------\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// From https://www.shadertoy.com/view/Xd23Dh\nfloat voronoise( in vec2 p, float u)\n{\n\t\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    float shortestDis = 1000.0;\n    \n    for( int y=-1; y<=1; y++ )\n    for( int x=-1; x<=1; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n        float dis = length(d);\n        \n        if(dis<shortestDis) shortestDis = dis;\n    }\n\t\n    return shortestDis;\n}\n// -----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n        uv -= vec2(0.5);\n        uv.x *= iResolution.x/iResolution.y;\n        \n    vec3 col = vec3(0.8);\n\n    vec2 p1 = vec2(movement(0.)      *0.5*iResolution.x/iResolution.y,  movement(52.21) *0.5);\n    vec2 p2 = vec2(movement(251.83)  *0.5*iResolution.x/iResolution.y,  movement(73.521) *0.5);\n    \n    vec3 lCord = LineSegCoord(p1, p2, uv);\n    \n    \n    col = (1.-pow(voronoise(lCord.xz *10., 1.), 3.)) * lCord;\n    col = mix(vec3(1.), col, aaStep(0.005,lCord.y));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nts3zS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 695, 720, 720, 764], [767, 767, 807, 807, 964], [967, 1425, 1470, 1470, 3227], [3229, 3264, 3292, 3292, 3554], [3585, 3585, 3607, 3607, 3758], [3760, 3806, 3844, 3844, 4249], [4250, 4301, 4358, 4408, 4981]]}
{"id": "sls3WM", "name": "Techno Song (sound)", "author": "athibaul", "description": "Trying to quickly compose a song on GPU with an interesting structure.\nThe song structure was inspired by [this video](https://youtu.be/_q3MFMQ8ao4).\n\nI'm pretty happy with this, but transitions are HARD.", "tags": ["2d", "sound", "song", "techno", "vinyl"], "likes": 170, "viewed": 7543, "published": 3, "date": "1622325847", "time_retrieved": "2024-07-30T19:18:21.752526", "image_code": "// ********************************\n// Techno Song - by Alexis THIBAULT\n// 29/05/2021\n// ********************************\n\n// See the \"Common\" tab for sound design and song structure.\n\n\n#define dot2(x) dot(x,x)\n#define hypot(x, y) sqrt((x)*(x) + (y)*(y))\n\nfloat onRing(vec2 p, float r1, float r2, float eps)\n{\n    float d1 = length(p);\n    return smoothstep(r1-eps,r1+eps,d1) * smoothstep(r2+eps,r2-eps,d1);\n}\n\nfloat borromeanRings(vec2 p, float eps)\n{\n    p = p.yx;\n    // rotate p back to the two slices around the positive x axis\n    float th = TAU/3.*round(atan(p.y,p.x)/TAU*3.);\n    p *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    \n    float rings = 0.;\n    float d = 0.65;\n    if(p.y > 0.)\n    {\n        rings += onRing(p-d*vec2(-0.5,-0.866), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(-0.5,0.866), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(-0.5,0.866), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(1,0), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(1,0), 0.9, 1.1, eps);\n    }\n    else\n    {\n        rings += onRing(p-d*vec2(1,0), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(-0.5,-0.866), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(-0.5,-0.866), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(-0.5,0.866), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(-0.5,0.866), 0.9, 1.1, eps);\n    }\n    \n    return rings;\n}\n\nvec4 turningDisk(vec2 p, vec3 baseCol, float eps)\n{\n    float th = -iTime * TAU * 33./60.;\n    \n    float th0 = atan(p.y, p.x);\n    p *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    \n    float d1 = length(p);\n    float th1 = atan(p.y, p.x);\n    float r1 = 0.6, r2 = 0.65;\n    float relAngle = mod(th1,TAU)-TAU/2.;\n    float onEdge = onRing(p, 0.6, 0.65, eps);\n    // Thin stripe on the outer edge\n    float w = 0.02;\n    onEdge *= smoothstep(w-eps,w+eps, abs(p.y)+step(0.,p.x));\n    \n    // Inner circle\n    onEdge += onRing(p, 0.02, 0.18, eps);\n    \n    // Black logo on the inner circle\n    onEdge -= borromeanRings((p - vec2(0.09,0.0))*25., eps*25.);\n    \n    \n    // Flashing color\n    vec3 edgeCol = baseCol;\n    edgeCol = pow(edgeCol, 1.5*vec3(2. - sin(3.*p.y + p.x +iTime)));\n    \n    \n    vec4 col = vec4(edgeCol, onEdge);\n    \n    // Vinyl part\n    \n    float onDisk = onRing(p, 0.18, 0.58, eps);\n    float albedo = clamp(6.+6.*sin(d1*80.), 0., 1.) * (0.8+0.1*noise(2.*th1+0.5*d1/eps)*sin(th1)+0.1*noise(0.5*d1/eps));\n    float lighting = pow(abs(sin(th0+1.0)), 5.);\n    \n    col += albedo*lighting*onDisk * 0.4;\n    \n    return col;\n    \n}\n\nfloat onBox(vec2 p, vec2 r, float rounded, float eps)\n{\n    vec2 q = abs(p) - r + rounded;\n    float d = length(max(q,0.)) - rounded;\n    return smoothstep(1.5*eps,0.,d);\n}\n\nvec4 squarePad(vec2 p, vec2 r, vec3 baseCol, float eps)\n{\n    float onSquare = onBox(p, r, 0.02, eps);\n    vec3 col = pow(baseCol, vec3(2.- sin(iTime)) + 2.*dot2(p/r));\n    return vec4(col, onSquare);\n}\n\nvec4 waveform(vec2 p, vec3 baseCol, float eps)\n{\n    float t = p.x + iTime;\n    float envSq = exp(-10.*mod(t,0.5));\n    envSq += 0.2*exp(-20.*mod(t,0.25)) * (1.+sin(t*4.));\n    envSq += window(0.1,0.2,mod(t,0.25)) * (1.-sin(3.*t)) * 0.02;\n    float envenv = 0.9 + 0.1*smoothstep(0.,0.5,mod(t,0.5)) * 0.8*window(0.,4.,mod(t,8.));\n    envenv *= step(0.,t);\n    envenv *= smoothstep(0.,2.,t);\n    envSq *= envenv;\n    float env = sqrt(envSq) * 0.7;\n    vec3 col = pow(baseCol, 3.*vec3(abs(p.y) + 3.*(1.-envenv)));\n    return vec4(col, smoothstep(env+eps,env-eps,abs(p.y)));\n}\n\nvec4 turntableArm(vec2 p, float eps)\n{\n    p -= vec2(0.65,0.55);\n    float th0 = atan(p.y, p.x);\n    float thMin = -0.2, thMax = -0.6;\n    float th = mix(thMin, thMax, clamp(iTime/146., 0., 1.));\n    \n    p *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    \n    vec4 col = vec4(0);\n    \n    float len = 0.42;\n    float wid = 0.02;\n    vec4 shadow = vec4(0,0,0, onBox(p-vec2(0,-len), vec2(wid,len), 0.1, 0.1) * 0.9);\n    col = mix(col, shadow, shadow.a);\n    float rect = onBox(p-vec2(0.,-len), vec2(wid,len), eps, eps);\n    vec3 armcol = vec3(clamp(0.1 - sin(2.*p.x / sqrt(max(wid*wid - p.x*p.x, 0.0002)) - p.y), 0.07, 1.));\n    col = mix(col, vec4(armcol, 1), rect);\n    \n    \n    float d = length(p);\n    vec3 chromeBrush = vec3(0.8+0.1*noise(5. + 0.5*d/eps));\n    float lighting = mix(0.07, 1., pow(abs(sin(th0+1.0)), 8.));\n    col = mix(col, vec4(chromeBrush*lighting, 1), onRing(p, 0.,0.1, eps));\n    \n    p -= vec2(0,-2.*len);\n    float head1 = onBox(p, vec2(0.03,0.05), eps, eps);\n    col = mix(col, vec4(0.7 - 10.*p.x,0,0,1), head1);\n    float head2 = onBox(p-vec2(0,0.02), vec2(0.04,0.05), eps, eps);\n    float head2sh = onBox(p-vec2(0,0.02), vec2(0.04,0.05), 0.02, 0.02);\n    col = mix(col, vec4(0,0,0,1), head2sh*0.7);\n    vec3 headCol = vec3(0.4);\n    float rings = borromeanRings(50.*(p-vec2(0,0.02)), 50.*eps);\n    headCol = mix(headCol, vec3(0.1,0.1,0.1), rings);\n    headCol *= smoothstep(0.1,-0.1,p.x)*2.;\n    \n    col = mix(col, vec4(headCol, 1), head2);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float eps = 1.5/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    float t = mod(iTime, 0.5);\n    float kickin = (iTime > 2.) ? exp(-t*10.) : 0.;\n    vec3 baseCol = mix(vec3(0.5,0.75,1.000), vec3(1.), kickin);\n    \n    vec2 p = uv - vec2(0.7,-0.2);\n    vec4 diskCol = turningDisk(p, baseCol, eps);\n    col = mix(col, diskCol.xyz, diskCol.a);\n    vec4 armCol = turntableArm(p, eps);\n    col = mix(col, armCol.xyz, armCol.a);\n    \n    \n    p = uv - vec2(-1.0,-0.5);\n    vec2 padC = clamp(round(p/0.2),-1.,4.)*0.2;\n    baseCol = mix(pow(normalize(0.5 + 0.4*cos(iTime+padC.xyx*3.+vec3(0,2,4))), vec3(0.3)), vec3(1.), kickin);\n    vec4 padCol = squarePad(p - padC, vec2(0.092), baseCol, eps);\n    col = mix(col, padCol.xyz, padCol.a);\n    \n    baseCol = mix(vec3(0.95,0.8,0.2), vec3(1.), kickin);\n    vec4 waveformCol = waveform((uv-vec2(0,0.8)) * 5., baseCol, eps * 5.);\n    col = mix(col, waveformCol.xyz, waveformCol.a);\n    \n    //col = vec3(1)*borromeanRings(uv*2.0, 2.*1.5/iResolution.y);\n    \n    \n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "// See \"Common\" tab", "sound_inputs": [], "common_code": "\n// The code below is split into several parts.\n// UTILS - Constants and hash functions and stuff\n// WAVEFORMS - Basic noise and tone generators\n// INSTRUMENTS - Stuff that makes notes\n// PHRASES AND SONG PARTS - What to play, how to play it, up to the final mix.\n\n\n///////////////////////////////\n/////////// UTILS /////////////\n///////////////////////////////\n\n#define TAU (2.*3.1415926)\n// Convert MIDI note number to cycles per second\n#define midicps(n) (440.*exp(log(2.)*(n-69.)/12.))\n\nfloat rand(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 rand2(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n////////////////////////////////////\n/////////// WAVEFORMS //////////////\n////////////////////////////////////\n\nfloat noise(float s){\n    // Noise is sampled at every integer s\n    // If s = t*f, the resulting signal is close to a white noise\n    // with a sharp cutoff at frequency f.\n    \n    // For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\n    // and the former produces fewer artifacts?\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    //sf = sf*sf*sf*(sf*(sf*6.0-15.0)+10.0); // quintic curve\n    // see https://iquilezles.org/articles/texture\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\n}\n\nvec2 noise2(float s){\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    return mix(rand2(float(si)), rand2(float(si+1)), sf) * 2. - 1.;\n}\n\n\nfloat coloredNoise(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    //float n1 = noise(t*df);\n    //float n2 = noise(t*df - 100000.);\n    //vec2 modul = vec2(cos(TAU*fc*t), sin(TAU*fc*t));\n    return sin(TAU*fc*fract(t))*noise(t*df);\n}\n\nvec2 coloredNoise2(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    vec2 noiz = noise2(t*df);\n    vec2 modul = vec2(cos(TAU*fc*t), sin(TAU*fc*t));\n    return modul*noiz;\n}\n\n\nfloat window(float a, float b, float t)\n{\n    return smoothstep(a, (a+b)*0.5, t) * smoothstep(b, (a+b)*0.5, t);\n}\n\nfloat formantSin(float phase, float form)\n{\n    // Inspired by the wavetable \"formant\" option\n    // in software synthesizer Surge (super cool freeware synth!)\n    phase = fract(phase);\n    phase = min(phase*form, 1.);\n    return sin(TAU*phase);\n}\nvec2 formantSin2(vec2 phase, vec2 form)\n{\n    // Inspired by the wavetable \"formant\" option\n    // in software synthesizer Surge (super cool freeware synth!)\n    phase = fract(phase);\n    phase = min(phase*form, 1.);\n    return sin(TAU*phase);\n}\n\n\nfloat lpfSaw(float t, float f, float fc, float Q)\n{\n    // Low-pass-filtered sawtooth wave\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\n    float omega_c = 2.*3.14159*fc/f; // relative\n    t = f*t - floor(f*t);\n    // Compute the exact response of a second order system with those parameters\n    // (value and derivative are continuous)\n    // It is expressed as\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\n    // We need to compute the amplitude A and phase phi.\n    float alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    float tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    float phi = atan(tanphi);\n    float A = -2./(cos(phi) - beta*cos(omega_c+phi));\n    \n    float v = 1.-2.*t + A*exp(-alpha*t) * cos(omega_c*t+phi);\n    return v;\n}\n\nvec2 lpfSaw(float t, vec2 f, float fc, float Q)\n{\n    // Low-pass-filtered sawtooth wave\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\n    vec2 omega_c = 2.*3.14159*fc/f; // relative\n    vec2 t2 = f*t - floor(f*t);\n    // Compute the exact response of a second order system with those parameters\n    // (value and derivative are continuous)\n    // It is expressed as\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\n    // We need to compute the amplitude A and phase phi.\n    vec2 alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    vec2 tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    vec2 phi = atan(tanphi);\n    vec2 A = -2./(cos(phi) - beta*cos(omega_c+phi));\n    \n    vec2 v = 1.-2.*t2 + A*exp(-alpha*t2) * cos(omega_c*t2+phi);\n    return v;\n}\n\n\n///////////////////////////////////\n//////// INSTRUMENTS //////////////\n///////////////////////////////////\n\nvec2 hat1(float t)\n{\n    // Smooth hi-hat, almost shaker-like\n    return coloredNoise2(t, 10000., 5000.) * smoothstep(0.,0.02,t) * smoothstep(0.06,0.01,t) * 0.1;\n}\n\nvec2 hat2(float t, float fc)\n{\n    // Short hi-hat with tuneable center frequency\n    return coloredNoise2(t, fc, fc-1000.) * smoothstep(0.,0.001,t) * smoothstep(0.03,0.01,t) * 0.1;\n}\n\nvec2 snare1(float t)\n{\n    // Composite snare\n    float body = (sin(TAU*t*250.) + sin(TAU*t*320.)) * smoothstep(0.1,0.0,t) * 1.;\n    vec2 timbre = coloredNoise2(t, 1000., 7000.) * exp(-12.*t) * smoothstep(0.5,0.,t) * 8.;\n    vec2 sig = (body+timbre) * smoothstep(0.,0.001,t);\n    sig = sig/(1.+abs(sig)); // distort\n    sig *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    return sig * 0.1;\n}\n\nvec2 snare2(float t)\n{\n    // Basic noise-based snare\n    float noi = coloredNoise(t, 4000., 1000.) + coloredNoise(t, 4000., 3800.) + coloredNoise(t,8000.,7500.) * 0.5;\n    float env = smoothstep(0.,0.001,t) * smoothstep(0.2,0.05,t);\n    env *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    env *= (1. - 0.5*window(0.02,0.1,t)); // fake compression\n    vec2 sig = vec2(noi) * env;\n    sig = sig/(1.+abs(sig));\n    return sig * 0.1;\n}\n\nfloat kick1(float t)\n{\n    // Composite kick\n    \n    // Kick is composed of a decaying sine tone, and a burst of noise,\n    // all of it distorted and shaped with a nice envelope.\n    \n    // frequency is assumed to be f0 + df*exp(-t/dftime);\n    float f0 = 50., df=500., dftime=0.02;\n    float phase = TAU * (f0*t - df*dftime*exp(-t/dftime));\n    float body = sin(phase) * smoothstep(0.15,0.,t) * 2.;\n    float click = coloredNoise(t, 8000., 2000.) * smoothstep(0.01,0.0,t);\n    //float boom = sin(f0*TAU*t) * smoothstep(0.,0.02,t) * smoothstep(0.15,0.,t);\n    float sig = body + click;\n    sig = sig/(1.+abs(sig));\n    //sig += boom;\n    sig *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    sig *= (1. + window(0.05,0.15,t)); // increase tail\n    return sig * 0.2;\n}\n\nvec2 bass1(float t, float f, float cutoff)\n{\n    // Composite bass\n    // (I'm very happy about this one!)\n    \n    // \"Cutoff\" is not actually the cutoff frequency of a filter,\n    // but it controls the amount of high frequencies\n    // we bring in using the \"formantSin\" waveform.\n    cutoff *= exp(-t*5.);\n    float formant = max(cutoff/f, 1.);\n    // Pure sine tone\n    float funda = sin(TAU*f*t);\n    // Phase-modulated sine gives more \"body\" to the sound\n    float body = sin(2.*TAU*f*t + (0.2*formant)*sin(TAU*f*t));\n    // Gritty attack using a truncated sinusoid waveform\n    // (dephased for stereo effect)\n    vec2 highs = formantSin2(f*t + vec2(0,0.5), vec2(formant)) * exp(-t*10.);\n    vec2 sig = body + highs + funda;\n    // Two-rate envelope with a strong transient and long decay\n    sig *= (2.*exp(-t*20.) + exp(-t*2.));\n    sig *= (1. + 0.3*smoothstep(0.05,0.0,t)); // increase transient\n    \n    // Finally, add some distortion\n    //sig = sig / (1. + abs(sig)); // Feel free to try how this one sounds.\n    sig = sin(sig); // This one gives lovely sidebands when pushed hard.\n    return sig * 0.1;\n}\n\nvec2 pad1(float t, vec4 f, float fc, float Q)\n{\n    // Filtered sawtooth-based pad, playing four-note chords\n    \n    // f: frequencies of the four notes\n    // fc, Q: cutoff frequency and quality factor of the 12dB/octave lowpass filter\n    vec2 sig = vec2(0);\n    sig += lpfSaw(t, f.x+vec2(-2,2), fc, Q);\n    sig += lpfSaw(t, f.y+vec2(1.7,-1.7), fc, Q);\n    sig += lpfSaw(t, f.z+vec2(-0.5,0.5), fc, Q);\n    sig += lpfSaw(t, f.w+vec2(1.5,-1.5), fc, Q);\n    return sig * 0.02;\n}\n\nvec2 arp1(float t, vec4 f, float fc, float dur)\n{\n    // Plucky arpeggiator, playing 16th notes.\n    \n    // dur: decay time of the notes (amplitude and filter)\n    vec2 sig = vec2(0);\n    vec4 ts = mod(t-vec4(0,0.125,0.25,0.375), 0.5);\n    sig += lpfSaw(t, f.x, fc*exp(-ts.x/dur), 10.) * smoothstep(0.0,0.01,ts.x) * exp(-ts.x/dur);\n    sig += lpfSaw(t, f.y, fc*exp(-ts.y/dur), 10.) * smoothstep(0.0,0.01,ts.y) * exp(-ts.y/dur);\n    sig += lpfSaw(t, f.z, fc*exp(-ts.z/dur), 10.) * smoothstep(0.0,0.01,ts.z) * exp(-ts.z/dur);\n    sig += lpfSaw(t, f.w, fc*exp(-ts.w/dur), 10.) * smoothstep(0.0,0.01,ts.w) * exp(-ts.w/dur);\n    return sig * 0.04;\n}\n\nvec2 marimba1(float t, float f)\n{\n    // Simple phase-modulation based marimba\n    \n    vec2 sig = vec2(0);\n    // Super basic marimba sound\n    sig += sin(TAU*f*t + exp(-50.*t)*sin(TAU*7.*f*t)) * exp(-5.*t) * step(0.,t);\n    // Fake reverb effect: long-decay, stereo-detuned fundamental\n    sig += sin(TAU*(f+vec2(-2,2))*t) * exp(-1.5*t) * 0.5;\n    return vec2(sig) * 0.05;\n}\n\nvec2 pad2(float t, vec4 f, float fres)\n{\n    // Four-note, phase-modulation-based pad.\n    \n    // fres: center frequency of the faked \"spectral aliasing\"\n    \n    vec2 sig = vec2(0);\n    // Index of modulation\n    // https://en.wikipedia.org/wiki/Frequency_modulation#Modulation_index\n    vec4 iom1 = 2.+0.5*sin(t + vec4(0,1,2,3));\n    // Play an octave lower than asked\n    f *= 0.5;\n    // Modulator has frequency 2f -> odd harmonics only\n    sig += sin(TAU*t*f.x + iom1.x * sin(2.*TAU*t*(f.x+vec2(-1,1)))) * vec2(1,0);\n    sig += sin(TAU*t*f.y + iom1.y * sin(2.*TAU*t*(f.y+vec2(-1.2,0.8)))) * vec2(0.7,0.3);\n    sig += sin(TAU*t*f.z + iom1.z * sin(2.*TAU*t*(f.z+vec2(-0.5,1.5)))) * vec2(0.3,0.7);\n    sig += sin(TAU*t*f.w + iom1.w * sin(2.*TAU*t*(f.w+vec2(-1.3,0.7)))) * vec2(0,1);\n    \n    // Fake spectral aliasing, to add some high-end\n    vec2 warped = vec2(0);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.x)) * vec2(1,0);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.y)) * vec2(0.7,0.3);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.z)) * vec2(0.3,0.7);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.w)) * vec2(0,1);\n    \n    // Mix to taste\n    sig = (sig + 0.01*warped) * 0.02;\n    // Reduce stereo image\n    sig = mix(sig.xy, sig.yx, 0.1);\n    return sig;\n}\n\n\n////////////////////////////////////////////\n/////// PHRASES AND SONG PARTS /////////////\n////////////////////////////////////////////\n\n\nfloat leadphrasenote(float t)\n{\n    // Four-bar lead synth phrase in the final chorus\n    // MIDI note number (or 0. if silence)\n    float note =\n        (t<0.5) ? 69. : (t<1.) ? 71. : (t<1.5) ? 72. : (t<1.75) ? 76. :\n        (t<3.0) ? 74. : (t<3.25) ? 0. : (t<3.5) ? 72. : (t<3.75) ? 74. :\n        (t<5.5) ? 76. : (t<5.75) ? 79. : (t<7.5) ? 71. : 0.;\n    return note;\n}\n\nvec2 leadphrase1(float t, float fc)\n{\n    // Four-bar lead synth phrase in the final chorus\n    \n    float note = leadphrasenote(t);\n    // Add some vibrato\n    float vibStrength = window(2.,3.,t) + window(4.,5.5,t) + window(6.,8.,t);\n    float f = midicps(note + vibStrength*0.01*sin(5.*TAU*t)/(t+0.1));\n    // Cut silence\n    float env = (note > 0.) ? 1. : 0.;\n    \n    // \"Super-saw\" lead\n    vec2 sig = lpfSaw(t, f+vec2(-2,2), fc, 1.);\n    sig += lpfSaw(t, f+vec2(3.2,-3.2), fc, 1.);\n    sig += lpfSaw(t, f, fc, 1.);\n    \n    // Distort\n    sig *= 2.;\n    sig = sig/(1.+abs(sig));\n    \n    return sig * 0.05 * env;\n}\n\nvec2 leadchorus(float t, float fc)\n{\n    // Four-bar lead synth phrase in the final chorus\n    // Add delay effect\n    vec2 sig = leadphrase1(t, fc);\n    sig = mix(sig, sig.yx, 0.3);\n    sig += leadphrase1(mod(t-0.25,8.), fc*0.7).yx * vec2(0.5,-0.5);\n    sig += leadphrase1(mod(t-1., 8.), 1000.) * 0.5;\n    return sig;\n}\n\nvec2 basschorus(float t, float fc)\n{\n    // Bass of the final chorus:\n    // Simply play the fundamental of each bar, with octave jumps\n    \n    // Every second 8th note is an octave above\n    float octave = 12.*step(0.25,mod(t,0.5));\n    // Fundamental of each of the four bars\n    float note = (t<2.) ? 69.-36.+octave : \n                 (t<4.) ? 62.-36.+octave :\n                 (t<6.) ? 60.-36.+octave :\n                 67.-36.+octave;\n    \n    float t1 = mod(t, 0.25);\n    vec2 sig = bass1(t1, midicps(note), fc);\n    \n    return sig;\n}\n\nvec2 padchorus(float t, float fc, float Q)\n{\n    // Pad part for the final chorus\n    // Simply play the (slightly rich) chords\n    // ||: Am(add9) | Dm7 | C(add9) | G(add9) :||\n    vec4 chord = (t<2.) ? vec4(57,60,64,71) : (t<4.) ? vec4(57,62,65,72) : (t<6.) ? vec4(60,62,64,67) : vec4(59,62,67,69);\n    \n    vec2 pad = pad1(t, midicps(chord), fc, Q);\n    return pad;\n}\n\n\nvec2 arpchorus(float t, float fc, float dur)\n{\n    // Arpeggiator part for the final chorus\n    // Simply arpeggiate the four chords\n    vec4 chord = (t<2.) ? vec4(57,60,64,71) : (t<4.) ? vec4(57,62,65,72) : (t<6.) ? vec4(60,62,64,67) : vec4(59,62,67,69);\n    vec2 arp = arp1(t, midicps(chord+12.), fc, dur);\n    return arp;\n}\n\n\nvec2 fullChorus(float time)\n{\n    // Full mix for the final chorus\n    time = mod(time, 8.);\n    vec2 v = vec2(0);\n    \n    // Percussions (with a slight 16th-note swing)\n    v += hat1(mod(time, 0.25)) * vec2(0.8,1.0);\n    v += hat1(mod(time-0.14, 0.25)) * vec2(0.3,-0.2);\n    v += snare1(mod(time-0.5, 1.));\n    v += kick1(mod(time, 0.5));\n    \n    // Low-frequency oscillator on a macro control\n    float cutoff = 300. + 200.*sin(time);\n    \n    float t = mod(time, 0.5);\n    // Another LFO for fake sidechain compression (\"pumping\" effect)\n    float pumping = mix(smoothstep(0.0,0.25,t), smoothstep(0.0,0.5,t), 0.2);\n    \n    v += basschorus(mod(time,8.), cutoff) *mix(pumping, 1.,0.3);\n    \n    vec2 pads = padchorus(mod(time, 8.), 8000.-1000.*sin(time), 2.);\n    pads *= mix(pumping, 1., 0.1);\n    v += pads;\n    \n    // A third LFO to vary the note length of the arpeggiator\n    float dur = 0.2 * exp(0.2*sin(time*0.6));\n    vec2 arp = arpchorus(mod(time, 8.), 5000.-1000.*cos(0.7*time), dur);\n    v += arp * mix(pumping, 1.,0.2);\n    \n    v += leadchorus(mod(time,8.), 10000.) * mix(pumping,1.,0.5);\n    \n    return v;\n}\n\nvec2 padPhraseVerse(float time, float fc)\n{\n    // Pad during the verse: play three chords in four bars\n    // ||: Am(add11) | FMaj7 | Em7 | Em7 :||\n    float t = mod(time, 8.);\n    vec4 chord = (t<2.) ? vec4(57,60,62,64) : (t<4.) ? vec4(53,57,60,64) : vec4(52,55,62,64);\n    // Smoothe out the transitions from one chord to the next,\n    // as they are not masked by percussion.\n    float env = 1. - window(-0.1,0.1,t) - window(1.9,2.1,t) - window(3.9,4.1,t) - window(7.9,8.1,t);\n    // Add some movement with volume automation\n    env *= 1. + 0.2*window(0.25,0.5,mod(t,0.5));\n    return pad1(t, midicps(chord), fc*0.7, 2.) * env;\n}\n\nvec2 padVerse(float time, float fc)\n{\n    // Verse pad with delay effect\n    return padPhraseVerse(time, fc) + 0.5*padPhraseVerse(time-0.5,fc).yx + 0.2*padPhraseVerse(time-1.5,fc);\n}\n\nvec2 marimbaVerse(float t, float fc)\n{\n    // Marimba part for the verse:\n    // just a few notes, always the same.\n    vec2 v = vec2(0);\n    v += marimba1(mod(t-0.00,8.), midicps(72.));\n    v += marimba1(mod(t-0.75,8.), midicps(71.));\n    v += marimba1(mod(t-1.50,8.), midicps(69.));\n    v += marimba1(mod(t-2.25,8.), midicps(64.));\n    v += marimba1(mod(t-7.50,8.), midicps(69.));\n    v += marimba1(mod(t-7.75,8.), midicps(71.));\n    return v;\n}\n\nvec2 arpVerse(float time, float fc, float dur)\n{\n    // Verse arpeggiator: just arpeggiate the chords\n    // (different notes than the pad this time).\n    // Cutoff frequency and note duration will be varied for tension.\n    float t = mod(time, 8.);\n    vec4 chord = (t<2.) ? vec4(57,64,69,71) : (t<4.) ? vec4(57,64,65,72) : vec4(59,64,69,74);\n    return arp1(t, midicps(chord), fc, dur);\n}\n\nvec2 fullVerse(float time)\n{\n    vec2 v = vec2(0);\n    // Cutoff frequency: dark sound initially,\n    // but with a riser in the last four bars.\n    float fc = 400. - 100.*cos(time) + 10000. * pow(clamp((time-24.)/(32.-24.),0.,1.), 4.);\n    v += padVerse(time, fc) * 0.5;\n    v += marimbaVerse(time, fc);\n    if(time > 16.)\n    {\n        // Arpeggiator comes in after 8 bars, and note duration increases\n        // during the riser.\n        float dur = mix(0.05,0.5, smoothstep(24.,32.,time));\n        v += arpVerse(time, fc, dur) * smoothstep(16.,18.,time);\n    }\n    return v;\n}\n\nvec2 bassDrop1(float time)\n{\n    // Groovy four-bar phrase of the bass during the drop.\n    \n    // (In fact, it is the only part of this song with\n    // some melodic/rhythmic complexity and variation.\n    // The rest is extremely mechanical.)\n    \n    vec2 v = vec2(0);\n    \n    time = mod(time, 8.);\n    \n    float sx = floor(time / 0.125); // sixteenth note number\n    float st = mod(time, 0.125);\n    bool isShort = true; // True for 16th note, false for 8th note\n    vec2 nn = vec2(0.,0.); // note number, trigger short note\n    nn = (sx == 0. || sx == 5. || sx==8.) ? vec2(33,1) : \n         (sx == 2.) ? vec2(48,1) :\n         (sx == 3.) ? vec2(45,1) :\n         (sx == 14.) ? vec2(35,1) :\n         (sx == 15. || sx == 35.) ? vec2(36,1) :\n         (sx == 16. || sx == 21. || sx == 24. || sx == 30. || sx == 31.) ? vec2(26,1) :\n         (sx == 18.) ? vec2(41,1) :\n         (sx == 19.) ? vec2(38,1) :\n         (sx == 32. || sx == 37. || sx == 38. || sx == 40.) ? vec2(24,1) :\n         (sx == 34.) ? vec2(40,1) :\n         (sx == 46.) ? vec2(28,1) :\n         (sx == 47.) ? vec2(29,1) :\n         (sx == 48. || sx == 53. || sx == 54. || sx == 56. || sx == 57.) ? vec2(31,1) :\n         (sx == 50.) ? vec2(47,1) :\n         (sx == 51. || sx == 58.) ? vec2(43,1) :\n         (sx == 60. || sx == 61.) ? vec2(32,1) :\n         (sx == 62.) ? vec2(44,1) :\n         vec2(0,0);\n    \n    \n    if(sx == 30. || sx == 56. || sx == 60.)\n    { // First half of 8th notes\n        isShort = false;\n    }\n    if(sx == 31. || sx == 57. || sx == 61.)\n    {  // Second half of 8th notes\n        st += 0.125;\n        isShort = false;\n    }\n    \n    \n    float fc = 400. + 50.*sin(TAU*time);\n    v += bass1(st, midicps(nn.x), fc) * nn.y;\n    \n    // Decay end of note to avoid clicks\n    if(isShort) v *= smoothstep(0.125,0.12,st);\n    else v *= smoothstep(0.125,0.12,st-0.125);\n    \n    return v;\n}\n\nvec2 padDrop1(float time, float fres)\n{\n    // Pad part for the drop : uses pad2 (the phase-modulation based pad)\n    vec2 v = vec2(0);\n    \n    float t = mod(time, 8.);\n    // Very sparse choice of notes.\n    // Chord transitions happen after the start of the bar.\n    vec4 chord = (t < 2.75) ? vec4(69,72,69,72) : \n    (t < 4.75) ? vec4(69,72,69,74) : (t < 6.75) ? vec4(69,72,67,72) : vec4(69,72,69,71);\n    // Funky automation to avoid boredom\n    float env = (0.05 + window(0.,4.,t) + window(4.,8.,t)) * exp(-5.*mod(-t, 0.25));\n    v += pad2(time, midicps(chord), fres) * env;\n    \n    return v;\n}\n\nvec2 fullDrop1(float time)\n{\n    // Full mix of the bass drop.\n    vec2 v = vec2(0);\n    float t = mod(time, 0.5);\n    // Fake sidechain compression again\n    float pumping = mix(smoothstep(0.0,0.25,t), smoothstep(0.0,0.5,t), 0.2);\n    // Hi-hat timbre rises from \"dull\" to \"harsh\"\n    float fhat = 5000. + 3000.*smoothstep(24.,32.,time);\n    \n    v += bassDrop1(time) * mix(pumping, 1., 0.8);\n    v += kick1(mod(time, 0.5) + 0.008);\n    \n    v += padDrop1(time, 8000.) * mix(pumping, 1., 0.05);\n    \n    if(time > 8.)\n    {\n        // Snare comes in after 4 bars.\n        v += snare2(mod(time-0.5, 1.));\n    }\n    if(time > 16.)\n    {\n        // Hi-hat comes in after 8 bars\n        // Short hi-hat sound with fast attack and decay. Slight swing.\n        v += hat2(mod(time, 0.25), fhat) * vec2(0.8,1.0) * 0.7;\n        v += hat2(mod(time-0.14, 0.25), fhat) * vec2(0.3,-0.2) * 0.7;\n    }\n    return v;\n}\n\nvec2 fermata1(float time)\n{\n    // 2-bar fermata after verse\n    vec2 v = vec2(0);\n    // Let the last marimba note decay\n    v += marimba1(time, midicps(69.));\n    // Let the pad go from bright to dark\n    float fc = 10000. * exp(-5.*smoothstep(0.,4.,time));\n    v += pad1(time, midicps(vec4(57,60,62,64)), fc, 2.) * smoothstep(0.,0.1,time) * smoothstep(4.,0.,time);\n    \n    // Riser before drop:\n    // Lots of low-frequency noise + a bit of high-frequency\n    vec2 noise = (coloredNoise2(time, 250., 250.) + 0.1*coloredNoise2(time, 8000., 2000.)) * 0.2 * exp(-6.*smoothstep(4.,1.,time)) * smoothstep(4.,3.99,time);\n    v += noise;\n    \n    return v;\n}\n\n\nvec2 teller1(float time)\n{\n    // 1-bar riser before chorus\n    vec2 v = vec2(0);\n    float t = mod(time, 0.5);\n    float fc = 10000.*exp(2.*(time-2.));\n    // Noise riser\n    vec2 riser = coloredNoise2(time, fc*0.3, fc*0.3);\n    v += riser * smoothstep(0.,2.,time) * 0.3 * exp((time-2.)*3.);\n    // Announce the \"middle A\" played by the lead synth on the chorus\n    vec2 teller = pad1(time, midicps(vec4(69)), fc, 2.);\n    v += teller;\n    return v;\n}\n\n\nvec2 verseTeller(float time)\n{\n    // Pre-announce the first note played by the marimba.\n    float fC5 = midicps(72.);\n    return (sin(TAU*(fC5+vec2(-2,2))*time) + 0.5*sin(TAU*(fC5+vec2(3,-3))*time)) * 0.1 * exp(-5.*(2.-time));\n    \n}\n\nvec2 fullSong(float time)\n{\n    // Combine all parts of the song into a structured whole.\n    \n    vec2 v = vec2(0);\n    \n    if(0.<time && time < 2.)\n    {\n        v += verseTeller(time);\n    }\n    \n    time -= 2.;\n    \n    if(0. < time && time < 32.)\n    {\n        v += fullVerse(time);\n    }\n        \n    time -= 32.;\n    \n    if(0. < time && time < 4.)\n    {\n        v += padVerse(time, 10000.) * smoothstep(0.5,0.,time);\n        v += fermata1(time);\n    }\n    \n    time -= 4.;\n    \n    if(0. < time && time < 32.)\n    {\n        v += fullDrop1(time);\n    }\n    \n    time -= 32.;\n    \n    if(0. < time && time < 4.)\n    {\n        v += bass1(time, midicps(33.), 400.);\n        v += pad2(time, midicps(vec4(69,71,69,72)), 8000.) * (0.5 + 0.3*cos(2.*TAU*time)) \n             * smoothstep(0.,0.5,time) * smoothstep(4.,0.,time);\n        v += verseTeller(time-2.);\n    }\n    \n    time -= 4.;\n    \n    if(0. < time && time < 16.)\n    {\n        v += fullVerse(time+16.);\n    }\n    \n    time -= 16.;\n    \n    if(0. < time && time < 4.)\n    {\n        v += fermata1(time);\n        v += teller1(time-2.) * smoothstep(2.,4.,time);\n    }\n    \n    time -= 4.;\n    \n    if(0. < time)\n    {\n        v += fullChorus(time) * smoothstep(48.,32.,time); // fade out on chorus\n    }\n    \n    return v;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 v = vec2(0);\n    v = fullSong(time);\n    \n    //v = fullChorus(time - 20., 10000.);\n    //v = vec2(kick1(mod(time, 0.5)));\n    \n    //v = fullDrop1(time);\n    \n    //v = fermata1(time);\n    \n    // Avoid clicks at the beginning\n    return v * smoothstep(0.,0.01,time);\n}\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sls3WM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[256, 256, 309, 309, 409], [411, 411, 452, 452, 1379], [1381, 1381, 1432, 1432, 2532], [2534, 2534, 2589, 2589, 2706], [2708, 2708, 2765, 2765, 2910], [2912, 2912, 2960, 2960, 3484], [3486, 3486, 3524, 3524, 4981], [4984, 4984, 5041, 5041, 6168]]}
{"id": "fls3RS", "name": "Styx", "author": "R3N", "description": "A ray marching scene made by combining different types of noise.\nIt'd probably look better with anti-aliasing but I think the shader is already resource-intensive as is.", "tags": ["procedural", "3d", "raymarching", "noise", "water"], "likes": 20, "viewed": 617, "published": 3, "date": "1622323612", "time_retrieved": "2024-07-30T19:18:22.593277", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 500.0\n#define MIN_DIST 0.01\n#define pi acos(-1.0)\n#define sat(t) clamp(t, 0.0, 1.0)\n\n// 2D rotation\nvec2 rot(vec2 p, float a) {\n\treturn p*mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n// random [0,1]\nfloat rand(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.543,514.123)))*4732.12);\n}\n\n// value noise\nfloat noise(vec2 p) {\n\tvec2 f = smoothstep(0.0, 1.0, fract(p));\n\tvec2 i = floor(p);\n\tfloat a = rand(i);\n\tfloat b = rand(i+vec2(1.0,0.0));\n\tfloat c = rand(i+vec2(0.0,1.0));\n\tfloat d = rand(i+vec2(1.0,1.0));\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n\t\n}\n\n// fractal noise\nfloat fbm(vec2 p) {\n    float a = 0.5;\n    float r = 0.0;\n    for (int i = 0; i < 8; i++) {\n        r += a*noise(p);\n        a *= 0.5;\n        p *= 2.0;\n    }\n    return r;\n}\n\n// sky SDF\nfloat sky(vec3 p) {\n    vec2 puv = p.xz;\n    // move clouds\n    puv += vec2(-2, 4)*iTime;\n    // plane with distortion\n\treturn 0.4*(-p.y+25.0+noise(puv/20.0)*1.5*fbm(puv/7.0));\n}\n\n// mountains SDF\nfloat mountains(vec3 p) {\n    // add slope so it forms a valley\n    float addSlope = -clamp(abs(p.x/20.0), 0.0, 7.0);\n    // increase intensity of distortion as it moves away from the river\n    float rockDist = clamp(2.0*abs(p.x/3.0), 0.0, 30.0);\n    // rock formations\n    float rocks = fbm(vec2(0, iTime/5.0)+p.xz/15.0);\n    // plane with distortion\n    return p.y-rockDist*rocks+addSlope+10.0;\n}\n\n// river SDF\nfloat river(vec3 p) {\n    // underwater rocks that disturb the flow of the river\n    // with a modification by pyBlob that adds a pressure hole after each rock\n    float rocks = pow(noise(p.xz/6.0+vec2(0, iTime/1.5)),4.0)\n                  - pow(noise((p.xz-vec2(0,1.5))/6.0+vec2(0, iTime/1.5)),4.0);\n    // surface waves\n    float waves = 0.75*fbm(noise(p.xz/4.0)+p.xz/2.0-vec2(0,iTime/1.75-pow(p.x/7.0,2.0)))\n                  + 0.75*fbm(noise(p.xz/2.0)+p.xz/2.0-vec2(0, iTime*1.5));\n    // Plane with distortion\n    return p.y+4.0-rocks+waves;\n}\n\n// scene\nfloat dist(vec3 p) {\n\treturn min(river(p), min(mountains(p), sky(p)));\n}\n\n// classic ray marcher that returns both the distance and the number of steps\nvec2 rayMarch(vec3 cameraOrigin, vec3 rayDir) {\n\tfloat minDist = 0.0;\n\tint steps = 0;\n\twhile (steps < MAX_STEPS) {\n\t\tvec3 point = cameraOrigin + rayDir * minDist;\n\t\tfloat d = dist(point);\n\t\tminDist += d;\n\t\tif(d < MIN_DIST || minDist > MAX_DIST) {\n\t\t\tbreak;\n\t\t}\n\t\tsteps++;\n\t}\n\treturn vec2(minDist, steps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy/(iResolution.y);\n\tuv -= iResolution.xy/iResolution.y/2.0;\n    // camera setup\n\tvec3 cameraOrigin = vec3(0, noise(vec2(0, iTime/4.0))-1.5, 0);\n\tvec3 ray = normalize(vec3(uv.x, uv.y, 0.4));\n    // camera sway\n    ray.yz = rot(ray.yz, mix(-0.5 , 0.5, 0.25*noise(vec2(0, 0.5+iTime/4.0))+noise(vec2(3.0-iTime/9.0))));\n    ray.xz = rot(ray.xz, mix(-1.0 , 1.0, noise(vec2(5.0+iTime/10.0))));\n    // ray march\n    vec2 rm = rayMarch(cameraOrigin, ray);\n    // color is based on the number of steps and distance\n\tvec4 col = pow(vec4(rm.y/100.0),vec4(3.0))+pow(rm.x/MAX_DIST,2.5);\n    // gamma correction\n\tfragColor = pow(col, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 139, 166, 166, 217], [219, 235, 255, 255, 315], [317, 332, 353, 353, 591], [593, 610, 629, 629, 784], [786, 797, 816, 816, 975], [977, 994, 1019, 1057, 1392], [1394, 1407, 1428, 1566, 1955], [1957, 1966, 1986, 1986, 2038], [2040, 2118, 2165, 2165, 2424], [2426, 2426, 2483, 2483, 3142]]}
{"id": "ftsGRS", "name": "Fabric skirt", "author": "avin", "description": "visual experiment", "tags": ["noise", "lines", "cloth"], "likes": 15, "viewed": 442, "published": 3, "date": "1622313046", "time_retrieved": "2024-07-30T19:18:23.450983", "image_code": "#define PI 3.1415926 \n#define PI2 6.2831852 \n \n#define SF 1./min(iResolution.x,iResolution.y)\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define MOD3 vec3(.1031, .11369, .13787)\n\nfloat hash11(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat snoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{     \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n          \n    float l = length(uv);\n    \n    vec3 result = vec3(0.);     \n    \n    for(float i=40.; i>0.; i-=1.){\n    \n        float a = sin(atan(uv.y, uv.x) + i*.1);\n        float am = abs(a-.5)/4.;\n    \n        float zn = .0125 + snoise(vec3(a,a, 10.*i*.005 + iTime*1.25-i*.11))*i*.0025 + i*.01;\n        float d = SS(l, zn);\n        \n        float rn = hash11(i);\n        vec3 col = hue(rn).rgb;\n        \n        result = mix(result, col, d);\n        \n        float dd =  SS(l, zn) * SS(zn-SF, l);\n        \n        result = mix(result, vec3(0.), dd);\n    }\n    \n\n    fragColor = vec4(vec3(result), 1.0);\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 265, 265, 351], [353, 353, 375, 375, 542], [544, 544, 566, 566, 1212], [1215, 1215, 1270, 1270, 1950]]}
{"id": "NlfGRS", "name": "exit", "author": "lennyjpg", "description": "xx", "tags": ["xx"], "likes": 0, "viewed": 218, "published": 3, "date": "1622308264", "time_retrieved": "2024-07-30T19:18:24.291735", "image_code": "vec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy - .5;  \n     float t = iTime * 0.07;\n    // u.y+= fract(t)*3.0 - 1.5;\n    \n    u.x -= sin(u.x)*0.95;\n    u.y += 0.1 + sin(u.y) * 0.1;\n   \n    // u.y += sin(u.x*4.0)*0.5;\n    uvec2 p = uvec2(fragCoord);\n\tvec3 h = hash3( p.x + 1920U*p.y + (1920U*1080U) );\n    float k = length(u * 1.5) - h.r * 0.0037;\n    \n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 66, 249], [251, 251, 308, 308, 678]]}
{"id": "7tX3RB", "name": "Witchdoctor Who", "author": "xenn", "description": "I absolutely appreciate very very deeply the original 1963 Dr. Who. theme.\nWouldn't call it timeless, More seminal.\nThere's a genuine warmth of human touch, reverence and joy, in the unco-clunky playing of instruments that had NEVER EXISTED BEFORE!", "tags": ["video", "edge", "multipass"], "likes": 3, "viewed": 386, "published": 3, "date": "1622300530", "time_retrieved": "2024-07-30T19:18:25.187342", "image_code": "// Fork of \"another rebirth\" by xenn. https://shadertoy.com/view/slX3zS\n// 2021-05-29 15:01:21\n\n// Fork of \"MAY DAY , MAY DAY !\" by xenn. https://shadertoy.com/view/7sSXWd\n// 2021-05-25 03:06:14\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uuv = uv * 2.0 - 1.0;\n    vec3 c = texture(iChannel0, uv).rgb;\n    vec4 col = vec4(pow(c, vec3(0.5)), 1.0);\n\n    fragColor = mix(vec4(.0), col, 1.-smoothstep(0.,1.,length(uuv)*0.6));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nmat2 rot2D(float theta)\n{\n \treturn mat2(cos(theta), -sin(theta), sin(theta), cos(theta));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // sample the last texture with uv's slightly scaled up\n    vec2 offs = (uv- 0.5) * 0.05 * sin(iTime* 01.2);\n    offs = offs * rot2D(iTime);\n    vec3 overlay = texture(iChannel1, offs + uv).rgb;\n    \n    // Additively blend the colors together\n    vec4 col = vec4(base* 0.8 + overlay*0.4, 2.0);\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// by @paulofalcao\n//\n// Fun with some feedbacks :)\n\nvec3 subImg(in vec2 fragCoord, float xs,float ys, float zs){\n    vec2 xy=fragCoord.xy/iResolution.xy;\n    xy-=0.5;\n    xy+=vec2(sin(iTime*xs)*0.1,cos(iTime*ys)*0.1);//move\n    xy*=(1.1+sin(iTime*zs)*0.1);//scale\n    xy+=0.5;\n    return texture(iChannel0,xy).xyz;\n}\n\nvec3 drawCircle(in vec2 xy){\n    float l=length(xy);\n    return ( l>.233 || l<.184 ) ? vec3(0) : vec3(sin(l*128.0)*.5+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n  fragColor = (texture(iChannel0,uv)-texture(iChannel1,uv)/1.0);\n\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define MaxSteps 22\n#define MinimumDistance 0.0009\n#define normalDistance     0.0002\n\n#define Iterations 9\n#define PI 3.141592\n#define Scale (1.50+(1.0+0.50*sin(iTime/8.0)))\n#define FieldOfView (1.50+(1.0+0.50*sin(iTime/14.0)))\n#define Jitter 0.05\n#define FudgeFactor 0.7\n#define NonLinearPerspective 2.0+(01.10*sin(iTime*0.0010))\n#define DebugNonlinearPerspective false\n\n#define Ambient 0.32184\n#define Diffuse 0.5\n#define LightDir vec3(1.0)\n#define LightColor vec3(1.0,1.0-(01.10*abs(sin(iTime*1.0))),0.858824-(01.10*(cos(iTime*1.0))))\n#define LightDir2 vec3(1.0,-1.0,1.0)\n#define LightColor2 vec3(0.0,0.333333,1.0)\n#define Offset vec3(0.92858-(0.130*sin(iTime/010.50)),0.92858-(0.01250*cos(iTime/2.0)),0.32858)\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a/0.50+(1.0+0.50*sin(iTime/4.0)))*v.x + sin(a/0.50+(1.0+0.50*sin(iTime/4.0)))*v.y, -sin(a*2.0+(1.0+0.50*sin(iTime/4.0)))*v.x + cos(a*2.0+(1.0+0.50*sin(iTime/4.0)))*v.y);\n}\n\n// Two light sources. No specular \nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tvec3 lightDir = normalize(LightDir);\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\t\n\tvec3 lightDir2 = normalize(LightDir2);\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\t\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color);\n}\n\n\n// DE: Infinitely tiled Menger IFS.\n//\n// For more info on KIFS, see:\n// http://www.fractalforums.com/3d-fractal-generation/kaleidoscopic-%28escape-time-ifs%29/\nfloat DE(in vec3 z)\n{\n\t// enable this to debug the non-linear perspective\n\tif (DebugNonlinearPerspective) {\n\t\tz = fract(z);\n\t\tfloat d=length(z.xy-vec2(0.5));\n\t\td = min(d, length(z.xz-vec2(0.5)));\n\t\td = min(d, length(z.yz-vec2(0.5)));\n\t\treturn d-0.01;\n\t}\n\t// Folding 'tiling' of 3D space;\n\tz  = abs(1.0-mod(z,2.0));\n\n\tfloat d = 1000.0;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tz.xy = rotate(z.xy,4.0+sin(iTime/5.0)+2.0+cos( iTime/18.0));\t\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(Scale-1.0);\n\t\tif( z.z<-0.5*Offset.z*(Scale-01.0*(01.10*(cos(iTime*1.0)))))  z.z+=Offset.z*(Scale-01.00*(01.10*(sin(iTime*1.0))));\n\t\td = min(d, length(z) * pow(Scale, float(-n)-1.0));\n\t}\n\t\n\treturn d-0.01;\n}\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0);\n}\n\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i < MaxSteps; i++) {\n\t\t// Non-linear perspective applied here.\n\t\tdir.zy = rotate(dir2.zy,totalDistance*sin( iTime/10.0)*NonLinearPerspective+cos(iTime/2.0));\n\t\t\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\t// Try to smooth the count, to combat banding.\n\tfloat smoothStep =   float(steps) + distance/MinimumDistance;\n\tfloat ao = 0.951-smoothStep/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\t\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor = (color*Ambient+light)*ao;\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera position (eye), and camera target\n\tvec3 camPos = 0.5*iTime*vec3(1.0,0.0,0.0);\n\tvec3 target = camPos + vec3(1.0,0.0*cos(iTime),0.0*sin(0.94*iTime));\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tvec2 coord =-1.0+(2.0+0.50*sin(iTime/4.0))*fragCoord.xy/iResolution.xy;\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tfragColor = rayMarch(camPos, rayDir, fragCoord );\n}\n\n\n\n\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Fork of \"MAY DAY , MAY DAY !\" by xenn. https://shadertoy.com/view/7sSXWd\n// 2021-05-25 03:06:14\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uuv = uv * 2.0 - 1.0;\n    vec3 c = texture(iChannel0, uv).rgb;\n    vec4 col = vec4(pow(c, vec3(0.5)), 1.0);\n\n    fragColor = mix(vec4(.0), col, 1.-smoothstep(0.,1.,length(uuv)*0.6));\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tX3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 253, 253, 487]]}
{"id": "stX3RB", "name": "Labyrinths of Sand", "author": "jarble", "description": "This fractal was generated using triangle waves.", "tags": ["fractal", "sand"], "likes": 5, "viewed": 278, "published": 3, "date": "1622300303", "time_retrieved": "2024-07-30T19:18:26.136802", "image_code": "#define ITERS 6\n\nvec2 triangle_wave(vec2 a){\n    return abs(fract((a/2.))-.5)*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv += vec2((iTime)/30.0,iTime/70.0)*2.5;\n    for(int c=0;c<ITERS;c++){\n        float scale = 1.45;\n        float scale1 = 1.1;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv.x /= -scale1;\n            uv= triangle_wave(uv+((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            \n            uv = triangle_wave(uv.yx/s1)*s1;\n            uv.y *= scale1;\n        }\n        col[2] = abs((uv.y)-(uv.x));\n        col = ((col+col_prev.yzx));\n\t}\n    fragColor = vec4(vec3(col/float(ITERS)),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stX3RB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 44, 44, 84], [86, 86, 143, 143, 891]]}
{"id": "7tfGzS", "name": "Dr.WTF?", "author": "xenn", "description": "I absolutely appreciate very very deeply the original 1963 Dr. Who. theme.\nWouldn't call it timeless, More seminal.\nThere's a genuine warmth of human touch, reverence and joy, in the unco-clunky playing of instruments that had NEVER EXISTED BEFORE!", "tags": ["video", "edge", "multipass"], "likes": 3, "viewed": 384, "published": 3, "date": "1622295597", "time_retrieved": "2024-07-30T19:18:26.962594", "image_code": "// Fork of \"Psychomathic Dive Code Splice\" by xenn. https://shadertoy.com/view/7tf3DN\n// 2021-05-29 13:38:27\n\n// Fork of \"Menger Journey\" by Syntopia. https://shadertoy.com/view/Mdf3z7\n// 2021-05-27 15:10:36\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = max(texture(iChannel0,uv),texture(iChannel1,uv+0.002));\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27289, "src": "https://soundcloud.com/jack-guidera/doctor-who-1980-opening-theme-recreation", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "\nmat2 rot2D(float theta)\n{\n \treturn mat2(cos(theta), -sin(theta), sin(theta), cos(theta));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // sample the last texture with uv's slightly scaled up\n    vec2 offs = (uv- 0.5) * 0.05 * sin(iTime* 01.2);\n    offs = offs * rot2D(iTime);\n    vec3 overlay = texture(iChannel1, offs + uv).rgb;\n    \n    // Additively blend the colors together\n    vec4 col = vec4(base* 0.8 + overlay*0.4, 2.0);\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// by @paulofalcao\n//\n// Fun with some feedbacks :)\n\nvec3 subImg(in vec2 fragCoord, float xs,float ys, float zs){\n    vec2 xy=fragCoord.xy/iResolution.xy;\n    xy-=0.5;\n    xy+=vec2(sin(iTime*xs)*0.1,cos(iTime*ys)*0.1);//move\n    xy*=(1.1+sin(iTime*zs)*0.1);//scale\n    xy+=0.5;\n    return texture(iChannel0,xy).xyz;\n}\n\nvec3 drawCircle(in vec2 xy){\n    float l=length(xy);\n    return ( l>.233 || l<.184 ) ? vec3(0) : vec3(sin(l*128.0)*.5+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n  fragColor = (texture(iChannel0,uv)-texture(iChannel1,uv)/1.0);\n\n}\n", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define MaxSteps 16\n#define MinimumDistance 0.0009\n#define normalDistance     0.0002\n\n#define Iterations 10\n#define PI 3.141592\n#define Scale (1.50+(1.0+0.50*sin(iTime/3.0)))\n#define FieldOfView (1.50+(1.0+0.50*sin(iTime/4.0)))\n#define Jitter 0.05\n#define FudgeFactor 0.7\n#define NonLinearPerspective 2.0+(01.10*sin(iTime*0.010))\n#define DebugNonlinearPerspective false\n\n#define Ambient 0.32184\n#define Diffuse 0.5\n#define LightDir vec3(1.0)\n#define LightColor vec3(1.0,1.0-(01.10*abs(sin(iTime*1.0))),0.858824-(01.10*(cos(iTime*1.0))))\n#define LightDir2 vec3(1.0,-1.0,1.0)\n#define LightColor2 vec3(0.0,0.333333,1.0)\n#define Offset vec3(0.92858+(0.130*sin(iTime/010.50)),0.92858+(0.01250*cos(iTime/2.0)),0.32858)\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Two light sources. No specular \nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tvec3 lightDir = normalize(LightDir);\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\t\n\tvec3 lightDir2 = normalize(LightDir2);\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\t\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color);\n}\n\n\n// DE: Infinitely tiled Menger IFS.\n//\n// For more info on KIFS, see:\n// http://www.fractalforums.com/3d-fractal-generation/kaleidoscopic-%28escape-time-ifs%29/\nfloat DE(in vec3 z)\n{\n\t// enable this to debug the non-linear perspective\n\tif (DebugNonlinearPerspective) {\n\t\tz = fract(z);\n\t\tfloat d=length(z.xy-vec2(0.5));\n\t\td = min(d, length(z.xz-vec2(0.5)));\n\t\td = min(d, length(z.yz-vec2(0.5)));\n\t\treturn d-0.01;\n\t}\n\t// Folding 'tiling' of 3D space;\n\tz  = abs(1.0-mod(z,2.0));\n\n\tfloat d = 1000.0;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tz.xy = rotate(z.xy,4.0+sin(iTime/5.0)+2.0+cos( iTime/18.0));\t\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(Scale-1.0);\n\t\tif( z.z<-0.5*Offset.z*(Scale-01.0*(01.10*(cos(iTime*1.0)))))  z.z+=Offset.z*(Scale-01.00*(01.10*(sin(iTime*1.0))));\n\t\td = min(d, length(z) * pow(Scale, float(-n)-1.0));\n\t}\n\t\n\treturn d-0.01;\n}\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0);\n}\n\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i < MaxSteps; i++) {\n\t\t// Non-linear perspective applied here.\n\t\tdir.zy = rotate(dir2.zy,totalDistance*sin( iTime/10.0)*NonLinearPerspective+cos(iTime/2.0));\n\t\t\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\t// Try to smooth the count, to combat banding.\n\tfloat smoothStep =   float(steps) + distance/MinimumDistance;\n\tfloat ao = 0.951-smoothStep/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\t\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor = (color*Ambient+light)*ao;\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera position (eye), and camera target\n\tvec3 camPos = 0.5*iTime*vec3(1.0,0.0,0.0);\n\tvec3 target = camPos + vec3(1.0,0.0*cos(iTime),0.0*sin(0.94*iTime));\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tvec2 coord =-1.0+(2.0+0.50*sin(iTime/4.0))*fragCoord.xy/iResolution.xy;\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tfragColor = rayMarch(camPos, rayDir, fragCoord );\n}\n\n\n\n\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + overlay*0.78975, 1.0);\n    \n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfGzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 266, 266, 379]]}
{"id": "slf3RS", "name": "triangle thing", "author": "laney", "description": "saw this concrete wall pattern in a book about soviet metro stations, started out trying to replicate it ended up with this.", "tags": ["grid", "triangle"], "likes": 15, "viewed": 312, "published": 3, "date": "1622294429", "time_retrieved": "2024-07-30T19:18:27.739517", "image_code": "vec4 m;\n\nconst float h = 0.9;\nconst mat2 skew = mat2( 1.0, 0.5/h, 0.0, 1.0/h) ;\nconst mat2 unskew = mat2( 1.0, -0.5, 0.0, h);\n\nvec4 tri_grid2(vec2 uv, const float peakY , const float peakZ, float seam_comp) {\n\n  uv *= skew;\n\n  // repeat\n  uv = fract(uv);\n  vec2 seamv = min(abs(uv),abs(uv-1.0));\n  float seam = min(seamv.x,seamv.y);\n  \n  // up or down triangle\n  float d = uv.x-uv.y; \n  seam = min(abs(d),seam);\n  d = sign(d);\n\n  // local coordinates\n  uv *= unskew;\n  uv.y*=d;\n  uv+= d>0.0 ? vec2(-0.5,.0) : vec2(0.0,h);\n  \n  // faces\n  vec2 vs1 = normalize(vec2(1.0,peakY));\n  vec2 vs2 = normalize(vec2(-1.0,peakY));\n\n  float s1 = dot(uv-vec2(-0.5,0.0),vec2(vs1.y,-vs1.x));\n  float s2 = dot(uv-vec2(.5,0.0),vec2(vs2.y,-vs2.x));\n\n  vec4 normal;\n  if(s1>0.0 && s2<0.0) {\n    normal=vec4(normalize(cross(vec3(vs1,peakZ),vec3(vs2,peakZ))),1.0);\n    seam = min(s1,seam);\n    seam = min(-s2,seam);\n  } else if(uv.x < 0.0) {\n    normal=vec4(normalize(cross(vec3(vec2(0.0,-1.0),peakZ),vec3(vs1,peakZ))),0.0);\n    seam = min(-s1,seam);\n    seam = min(-uv.x,seam);\n  } else {\n    normal=vec4(normalize(cross(vec3(vs2,peakZ),vec3(vec2(0.0,-1.0),peakZ))),0.0);\n    seam = min(uv.x,seam);\n    seam = min(s2,seam);\n  }\n\n  normal.y*=d;\n  return vec4(mix(vec3(0.0,0.0,0.3),normal.xyz,smoothstep(0.0,seam_comp,seam)),normal.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 *  iResolution.xy) / iResolution.y;\n    m = iMouse / iResolution.xyxy;\n \n    float w = 4.0*pow(sin(\n      (1.0+length(uv.x*cos(iTime*0.5)*3.0+uv.y*sin(iTime*0.7)*2.0))\n      -0.2*iTime),8.0);\n\n    vec2 uvs = uv*skew;\n    vec2 grid = (uvs.x-uvs.y) > 0.0 ? vec2(8.0,0.01) : vec2(24.0,0.03);\n\n    vec4 normal = tri_grid2(uv*grid.x, w, 0.6*sin(0.5-length(uv*2.0)+iTime*0.2), grid.y);\n\n    vec3 lightDir = normalize(vec3(sin(iTime*0.5)*50.0, cos(iTime*0.7)*30.0, 100.0));\n\n    vec3 c = normal.w >0.0 ? vec3(1,0.24,0.2) : vec3(1.0);\n    fragColor = vec4(vec3(dot(normal.xyz,lightDir))* c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slf3RS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 208, 208, 1314], [1316, 1316, 1373, 1373, 1993]]}
{"id": "stXGRS", "name": "Fibrous ring", "author": "avin", "description": "visual experiment", "tags": ["noise", "lines"], "likes": 13, "viewed": 448, "published": 3, "date": "1622292842", "time_retrieved": "2024-07-30T19:18:28.523421", "image_code": "#define PI 3.1415926 \n#define PI2 6.2831852 \n \n#define SF 1./min(iResolution.x,iResolution.y)\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n\n#define MOD3 vec3(.1031, .11369, .13787)\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat snoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{     \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n          \n    float l = length(uv);\n    \n    float result = 0.;\n    \n    for(float i=0.; i<30.; i+=1.){\n        float zn = .25 + i*.005 + snoise(vec3(uv*i*.5, 10. + iTime*.25))*i*.005;\n        float d = SS(l, zn) * SS(zn, l);\n        result += d;\n    }\n    \n\n    fragColor = vec4(vec3(result), 1.0);\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 198, 198, 365], [367, 367, 389, 389, 1035], [1038, 1038, 1093, 1093, 1467]]}
{"id": "stfGRS", "name": "2D Isometric Projection", "author": "Tech_", "description": "Here is a shader demonstrating the concept of transforming from cartesian coordinates to isometric coordinates.", "tags": ["projection", "isometric", "matrices"], "likes": 2, "viewed": 328, "published": 3, "date": "1622291314", "time_retrieved": "2024-07-30T19:18:29.271421", "image_code": "\nconst mat2 isometricMat = mat2(vec2(-0.5, 0.5), vec2(1.0));\nconst mat2 isometricMatInv = inverse(isometricMat);\n\nvec2 CartesianToIsometric(in vec2 cartesian) {\n    return isometricMat * cartesian;\n}\n\nvec2 IsometricToCartesian(in vec2 isometric) {\n   return isometricMatInv * isometric;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 10.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    uv = mix(uv, CartesianToIsometric(uv), cos(iTime) * 0.5 + 0.5);\n\n    vec3 col;\n    col += step(fract(uv.x), 0.03);\n    col += step(fract(uv.y), 0.03);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 160, 160, 199], [201, 201, 247, 247, 288], [290, 290, 347, 347, 636]]}
{"id": "stXGR7", "name": "Zebra mountains", "author": "z0rg", "description": "Inspired by a work from @krankarta https://twitter.com/krankarta?lang=en", "tags": ["zebra", "moutains"], "likes": 11, "viewed": 373, "published": 3, "date": "1622281524", "time_retrieved": "2024-07-30T19:18:30.043357", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\n\nfloat map(vec3 p)\n{\n    float land = -p.y\n    -(sin(p.x*2.+p.z)*.5\n    -sin(p.x*3.+p.z)*.25\n    -sin(p.x*4.+p.z*5.)*.1)*5.5*(1.-sat(length(p.xz)*.4));\n    return max(max(land,length(p.xz)-2.5), -(land+.05));\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0., 1., 0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01, 0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy), map(p-e.yxy), map(p-e.yyx)));\n}\n\nvec2 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        float res = map(p);\n        if (res < 0.01)\n            return vec2(res, distance(p, ro));\n        p+= rd * res*.1;\n    }\n    return vec2(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(1.);\n    float dist = 5.;\n    float t = iTime*.1;\n    vec3 ro =vec3(sin(t)*dist, -5., cos(t)*dist);\n    vec3 ta = vec3(0., 0., 0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    vec2 res = trace(ro, rd, 512);\n    if (res.y > 0.)\n    {\n        float shp = 2.;\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        vec3 refl = reflect(rd, n);\n        col = mix(col, vec3(sat(p.y+.5)*.5),\n        sat(-(length(p.xz)-2.3)*4.)*sat((sin(p.z*30.+iTime*5.)-.5)*shp)); \n        col = col*.75+col*texture(iChannel0, refl*vec3(1.,-1.,1.)).xyz;\n    }\n    col += vec3(1.)*sat((length(uv-vec2(0.,-.1))-.25)*4.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n\n    { // Not so cheap antialiasing SSAA x4\n        vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n        vec3 acc = col;\n        // To avoid too regular pattern yielding aliasing artifacts\n        mat2 rot = r2d(uv.y*5.); // a bit of value tweaking, appears to be working well\n        acc += rdr(uv-off.xx*rot);\n        acc += rdr(uv-off.xy*rot);\n        acc += rdr(uv-off.yy*rot);\n        acc += rdr(uv-off.yx*rot);\n        col = acc/5.;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXGR7.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[429, 429, 448, 448, 505], [508, 508, 527, 527, 717], [719, 719, 750, 750, 883], [885, 885, 916, 916, 1025], [1027, 1027, 1068, 1068, 1281], [1283, 1283, 1302, 1302, 1978], [1980, 1980, 2037, 2037, 2606]]}
{"id": "NtXGRS", "name": "cut 1", "author": "lennyjpg", "description": "xx", "tags": ["xx"], "likes": 0, "viewed": 203, "published": 3, "date": "1622258268", "time_retrieved": "2024-07-30T19:18:30.847208", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 u = uv - 0.5;\n    u.x -= sin(u.x);\n    if(uv.x > 0.5){\n     u.x = uv.x + sin(u.x * 20.2) - 0.5;\n    }\n    float k = length(u) * 1.5;\n    fragColor = vec4(vec3(k),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXGRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 276]]}
{"id": "7ts3D7", "name": "Continuous MNCA Example 0", "author": "SlackermanzCA", "description": "Continuous Multiple Neighborhood Cellular Automata", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 14, "viewed": 1322, "published": 3, "date": "1622255086", "time_retrieved": "2024-07-30T19:18:31.702920", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch( iChannel0, ivec2(gl_FragCoord[0], gl_FragCoord[1]), 0); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n#define PI 3.14159265359\n\nconst uint MAX_RADIUS = 16u;\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat  tp(uint n, float s) \t\t\t{ return (float(n+1u)/256.0) * ((s*0.5)/128.0); }\nfloat utp(uint v, uint  w, uint o) \t{ return tp(u32_upk(v,w,w*o), 105.507401); }\nfloat bsn(uint v, uint  o) \t\t\t{ return float(u32_upk(v,1u,o)*2u)-1.0; }\n    \nvec3 gdc( ivec2 of, sampler2D tx ) {\n\tfloat \tfx \t\t= gl_FragCoord[0];\n\tfloat \tfy \t\t= gl_FragCoord[1];\n\tfloat\twx \t\t= iResolution.x;\n\tfloat\twy \t\t= iResolution.y;\n\tfloat\twv \t\t= 1.0;\n\tvec2\tdc\t\t= vec2( wx/wv, wy/wv );\n\tfloat\tcx\t\t= mod( fx+float(of[0]), dc[0] ) + floor( fx/dc[0] ) * dc[0];\n\tfloat\tcy\t\t= mod( fy+float(of[1]), dc[1] ) + floor( fy/dc[1] ) * dc[1];\n\tvec4 \tpxdata \t= texelFetch( tx, ivec2(cx, cy), 0);\n\treturn \tvec3( pxdata[0], pxdata[1], pxdata[2] ); }\n    \nfloat gdv( ivec2 of, sampler2D tx, int c ) {\n\tvec3 pxdata = gdc( of, tx );\n\treturn \tpxdata[c]; }\n    \nvec2 nbhd( ivec2 r, sampler2D tx, int c ) {\n\tuint\ttmx = 65536u;\n\tuint\tchk = 2147483648u / (\n\t\t\t\t\t( \tuint(float(r[0])*float(r[0])*PI + float(r[0])*PI + PI\t)\n\t\t\t\t\t- \tuint(float(r[1])*float(r[1])*PI + float(r[1])*PI\t\t) ) * 128u );\n\tfloat\tpsn = (chk >= tmx) ? float(tmx) : float(chk);\n\t\t\tfloat \td = 0.0;\n\t\t\tfloat \ta = 0.0;\n\t\t\tfloat \tb = 0.0;\n\t\t\tfloat\tt = 0.0;\n\tfor(float i = float(r[0])*-1.0; i <= float(r[0]); i+=1.0) {\n\t\tfor(float j = float(r[0])*-1.0; j <= float(r[0]); j+=1.0) {\n\t\t\t\t\td = round(sqrt(i*i+j*j));\n\t\t\tfloat\tw = 1.0;\n\t\t\tif( d <= float(r[0]) && d > float(r[1]) ) {\n\t\t\t\tt  = gdv( ivec2(i,j), tx, c ) * w * psn;\n\t\t\t\ta += t - fract(t);\n\t\t\t\tb += w * psn; } } }\n\treturn vec2(a, b); }\n                \nfloat bitring(vec2[MAX_RADIUS] rings, uint bits) {\n\tfloat sum = 0.0; float tot = 0.0;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tif(u32_upk(bits, 1u, i) == 1u) { sum += rings[i][0]; tot += rings[i][1]; } }\n\treturn sum / tot; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(int seed) {\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1],  2.0, 19.0 + mod(iDate[3]+float(seed),17.0), 23.0 + mod(iDate[3]+float(seed),43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 14.0, 13.0 + mod(iDate[3]+float(seed),29.0), 17.0 + mod(iDate[3]+float(seed),31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1],  6.0, 13.0 + mod(iDate[3]+float(seed),11.0), 51.0 + mod(iDate[3]+float(seed),37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Setup\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n    const \tivec2\torigin  = ivec2(0, 0);\n            vec3\tref_c\t= gdc( origin, txdata );\t//\tOrigin value references\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tuint[4] bitringdata = uint[4]\n\t(\t32766u, \t\t3472619019u, \t32752u, \t\t3675719802u \t);\n\n\tuint[8] ubv \t\t= uint[8]\n\t(\t39879523u, \t\t526972426u, \t2727874005u, \t1461826227u, \n\t\t1300644632u, \t1298224u, \t\t95419984u, \t\t823214418u\t\t);\n\n\tuint[1] ubi \t\t= uint[1]\n\t(\t2390857921u \t\t\t\t\t\t\t\t\t\t\t\t\t);\n\n//\tParameters\n\tconst\tfloat \ts  = mnp *  64.0 *  96.0;\n\tconst\tfloat \tn  = mnp *  64.0 *  16.0;\n\n//\tOutput Values\n\tvec3 res_c = ref_c;\n\n//\tNH Rings\n\tvec2[MAX_RADIUS] nh_rings_r;\n\tfor(uint i = 0u; i < MAX_RADIUS; i++) {\n\t\tnh_rings_r[i] = nbhd( ivec2(i+1u,i), txdata, 0 ); }\n\n\tfloat[4] nhv_r;\n        nhv_r[0] = bitring(nh_rings_r, bitringdata[0]);\n        nhv_r[1] = bitring(nh_rings_r, bitringdata[1]);\n        nhv_r[2] = bitring(nh_rings_r, bitringdata[2]);\n        nhv_r[3] = bitring(nh_rings_r, bitringdata[3]);\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tUpdate Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst uint bt = 8u;\n\n\tif( nhv_r[0] >= utp(ubv[0],bt,0u) && nhv_r[0] <= utp(ubv[0],bt,1u) ) { res_c[0] += bsn(ubi[0], 0u)*s; }\n\tif( nhv_r[0] >= utp(ubv[0],bt,2u) && nhv_r[0] <= utp(ubv[0],bt,3u) ) { res_c[0] += bsn(ubi[0], 1u)*s; }\n\tif( nhv_r[0] >= utp(ubv[1],bt,0u) && nhv_r[0] <= utp(ubv[1],bt,1u) ) { res_c[0] += bsn(ubi[0], 2u)*s; }\n\tif( nhv_r[0] >= utp(ubv[1],bt,2u) && nhv_r[0] <= utp(ubv[1],bt,3u) ) { res_c[0] += bsn(ubi[0], 3u)*s; }\n\n\tif( nhv_r[1] >= utp(ubv[2],bt,0u) && nhv_r[1] <= utp(ubv[2],bt,1u) ) { res_c[0] += bsn(ubi[0], 4u)*s; }\n\tif( nhv_r[1] >= utp(ubv[2],bt,2u) && nhv_r[1] <= utp(ubv[2],bt,3u) ) { res_c[0] += bsn(ubi[0], 5u)*s; }\n\tif( nhv_r[1] >= utp(ubv[3],bt,0u) && nhv_r[1] <= utp(ubv[3],bt,1u) ) { res_c[0] += bsn(ubi[0], 6u)*s; }\n\tif( nhv_r[1] >= utp(ubv[3],bt,2u) && nhv_r[1] <= utp(ubv[3],bt,3u) ) { res_c[0] += bsn(ubi[0], 7u)*s; }\n\n\tif( nhv_r[2] >= utp(ubv[4],bt,0u) && nhv_r[2] <= utp(ubv[4],bt,1u) ) { res_c[0] += bsn(ubi[0], 8u)*s; }\n\tif( nhv_r[2] >= utp(ubv[4],bt,2u) && nhv_r[2] <= utp(ubv[4],bt,3u) ) { res_c[0] += bsn(ubi[0], 9u)*s; }\n\tif( nhv_r[2] >= utp(ubv[5],bt,0u) && nhv_r[2] <= utp(ubv[5],bt,1u) ) { res_c[0] += bsn(ubi[0],10u)*s; }\n\tif( nhv_r[2] >= utp(ubv[5],bt,2u) && nhv_r[2] <= utp(ubv[5],bt,3u) ) { res_c[0] += bsn(ubi[0],11u)*s; }\n\n\tif( nhv_r[3] >= utp(ubv[6],bt,0u) && nhv_r[3] <= utp(ubv[6],bt,1u) ) { res_c[0] += bsn(ubi[0],12u)*s; }\n\tif( nhv_r[3] >= utp(ubv[6],bt,2u) && nhv_r[3] <= utp(ubv[6],bt,3u) ) { res_c[0] += bsn(ubi[0],13u)*s; }\n\tif( nhv_r[3] >= utp(ubv[7],bt,0u) && nhv_r[3] <= utp(ubv[7],bt,1u) ) { res_c[0] += bsn(ubi[0],14u)*s; }\n\tif( nhv_r[3] >= utp(ubv[7],bt,2u) && nhv_r[3] <= utp(ubv[7],bt,3u) ) { res_c[0] += bsn(ubi[0],15u)*s; }\n\n    res_c[0] -= n;\n\tres_c[1] = res_c[0];\n\tres_c[2] = res_c[0];\n    \n    res_c = clamp(res_c,0.0,1.0);\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = 0.0;\n        res_c[2] = 0.0; }\n    if (iFrame == 0) { res_c[0] = reseed(0); res_c[1] = reseed(1); res_c[2] = reseed(2); }\n    fragColor=vec4(res_c[0],res_c[1],res_c[2],1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ts3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[998, 998, 1055, 1055, 1141]]}
{"id": "7tsGW7", "name": "Bio Circuit", "author": "wyatt", "description": "Draw a conduction mask to the right and create an action potential on the left. This is the way neurons communicate and how muscles are controlled. I think that in order to make circuitry you need a 1 way conductor...?", "tags": ["reactiondiffusion"], "likes": 15, "viewed": 563, "published": 3, "date": "1622243078", "time_retrieved": "2024-07-30T19:18:32.572595", "image_code": "Main {\n    Q = get_Q(U);\n    if (U.x<.5*R.x)\n    Q = sin(Q.x*10.+Q.y+vec4(1,2,3,4));\n    vec4 M = get_M(U);\n    Q = mix(vec4(0),Q,M.x);\n        if (U.x<4.||U.y<4.||R.x-U.x<4.||R.y-U.y<4.||abs(U.x-R.x*.5)<4.) Q = vec4(1);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Main {\n    Q = get_Q(U);\n    vec4 M = get_M(U);\n        vec4 \n            p = mouse,\n\t\t\tn = get_Q(U+vec2(0,1)),\n\t\t\te = get_Q(U+vec2(1,0)),\n\t\t\ts = get_Q(U-vec2(0,1)),\n\t\t\tw = get_Q(U-vec2(1,0)),\n\t\t\tl = 0.25*(n.x+e+s+w-4.*Q);\n\t\tfloat dt = M.x;\n\t\tfloat m = Q.x*Q.y*(1.-Q.x);\n\t\tQ.x += dt*(l.x+m-1e-3-.3*Q.x);\n\t\tQ.y += dt*(-m+2e-3*(1.-Q.y));\n\t\tQ.xy = max(Q.xy,0.);\n\t\tif (iFrame <1&&length(U.xy-0.5*R.xy)<10.)\n\t\t\tQ.x = 1.;\n\t\tif (U.x<.5*R.x&&iMouse.z>0.&&length(U.xy-iMouse.xy)<10.)\n\t\t\tQ.x = 1.;\n\t\tif (iFrame<1) {\n\t\t\tQ = vec4(0);\n\t\t}\n\t\tif (iMouse.z>0.) {\n\t\t\tfloat l = ln(U,p.xy,p.zw);\n\t\t\t\n\t\t\tvec2 u = U.xy-iMouse.xy;\n\t\t\tM = mix(M,vec4(1),.01*exp(-.01*dot(u,u)));\n       }\n\t\tif (iFrame < 1)\n\t\t\tM = vec4(0);\n        if (U.x>.5*R.x) Q = M;\n        \n        if (U.x<4.||U.y<4.||R.x-U.x<4.||R.y-U.y<4.||abs(U.x-R.x*.5)<4.) Q = vec4(0);\n        if (length(U-0.5*R)<1.) {\n            if (iMouse.z>0.) {\n                if (p.z>0.) Q =  vec4(iMouse.xy,p.xy);\n                else Q =  vec4(iMouse.xy,iMouse.xy);\n            }\n            else Q = vec4(-iResolution.xy,-iResolution.xy);\n        }\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define get_Q(U) A(U)\n#define get_M(U) A(mod((U),vec2(.5*R.x,R.y))+vec2(.5*R.x,0))\n#define mouse A(.5*R)\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}", "buffer_b_code": "Main {\n    Q = get_Q(U);\n    vec4 M = get_M(U);\n        vec4 \n            p = mouse,\n\t\t\tn = get_Q(U+vec2(0,1)),\n\t\t\te = get_Q(U+vec2(1,0)),\n\t\t\ts = get_Q(U-vec2(0,1)),\n\t\t\tw = get_Q(U-vec2(1,0)),\n\t\t\tl = 0.25*(n.x+e+s+w-4.*Q);\n\t\tfloat dt = M.x;\n\t\tfloat m = Q.x*Q.y*(1.-Q.x);\n\t\tQ.x += dt*(l.x+m-1e-3-.3*Q.x);\n\t\tQ.y += dt*(-m+2e-3*(1.-Q.y));\n\t\tQ.xy = max(Q.xy,0.);\n\t\tif (iFrame <1&&length(U.xy-0.5*R.xy)<10.)\n\t\t\tQ.x = 1.;\n\t\tif (U.x<.5*R.x&&iMouse.z>0.&&length(U.xy-iMouse.xy)<10.)\n\t\t\tQ.x = 1.;\n\t\tif (iFrame<1) {\n\t\t\tQ = vec4(0);\n\t\t}\n\t\tif (iMouse.z>0.) {\n\t\t\tfloat l = ln(U,p.xy,p.zw);\n\t\t\t\n\t\t\tvec2 u = U.xy-iMouse.xy;\n\t\t\tM = mix(M,vec4(1),.01*exp(-.01*dot(u,u)));\n       }\n\t\tif (iFrame < 1)\n\t\t\tM = vec4(0);\n        if (U.x>.5*R.x) Q = M;\n        \n        if (U.x<4.||U.y<4.||R.x-U.x<4.||R.y-U.y<4.||abs(U.x-R.x*.5)<4.) Q = vec4(0);\n        if (length(U-0.5*R)<1.) {\n            if (iMouse.z>0.) {\n                if (p.z>0.) Q =  vec4(iMouse.xy,p.xy);\n                else Q =  vec4(iMouse.xy,iMouse.xy);\n            }\n            else Q = vec4(-iResolution.xy,-iResolution.xy);\n        }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = get_Q(U);\n    vec4 M = get_M(U);\n        vec4 \n            p = mouse,\n\t\t\tn = get_Q(U+vec2(0,1)),\n\t\t\te = get_Q(U+vec2(1,0)),\n\t\t\ts = get_Q(U-vec2(0,1)),\n\t\t\tw = get_Q(U-vec2(1,0)),\n\t\t\tl = 0.25*(n.x+e+s+w-4.*Q);\n\t\tfloat dt = M.x;\n\t\tfloat m = Q.x*Q.y*(1.-Q.x);\n\t\tQ.x += dt*(l.x+m-1e-3-.3*Q.x);\n\t\tQ.y += dt*(-m+2e-3*(1.-Q.y));\n\t\tQ.xy = max(Q.xy,0.);\n\t\tif (iFrame <1&&length(U.xy-0.5*R.xy)<10.)\n\t\t\tQ.x = 1.;\n\t\tif (U.x<.5*R.x&&iMouse.z>0.&&length(U.xy-iMouse.xy)<10.)\n\t\t\tQ.x = 1.;\n\t\tif (iFrame<1) {\n\t\t\tQ = vec4(0);\n\t\t}\n\t\tif (iMouse.z>0.) {\n\t\t\tfloat l = ln(U,p.xy,p.zw);\n\t\t\t\n\t\t\tvec2 u = U.xy-iMouse.xy;\n\t\t\tM = mix(M,vec4(1),.01*exp(-.01*dot(u,u)));\n       }\n\t\tif (iFrame < 1)\n\t\t\tM = vec4(0);\n        if (U.x>.5*R.x) Q = M;\n        \n        if (U.x<4.||U.y<4.||R.x-U.x<4.||R.y-U.y<4.||abs(U.x-R.x*.5)<4.) Q = vec4(0);\n        if (length(U-0.5*R)<1.) {\n            if (iMouse.z>0.) {\n                if (p.z>0.) Q =  vec4(iMouse.xy,p.xy);\n                else Q =  vec4(iMouse.xy,iMouse.xy);\n            }\n            else Q = vec4(-iResolution.xy,-iResolution.xy);\n        }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = get_Q(U);\n    vec4 M = get_M(U);\n        vec4 \n            p = mouse,\n\t\t\tn = get_Q(U+vec2(0,1)),\n\t\t\te = get_Q(U+vec2(1,0)),\n\t\t\ts = get_Q(U-vec2(0,1)),\n\t\t\tw = get_Q(U-vec2(1,0)),\n\t\t\tl = 0.25*(n.x+e+s+w-4.*Q);\n\t\tfloat dt = M.x;\n\t\tfloat m = Q.x*Q.y*(1.-Q.x);\n\t\tQ.x += dt*(l.x+m-1e-3-.3*Q.x);\n\t\tQ.y += dt*(-m+2e-3*(1.-Q.y));\n\t\tQ.xy = max(Q.xy,0.);\n\t\tif (iFrame <1&&length(U.xy-0.5*R.xy)<10.)\n\t\t\tQ.x = 1.;\n\t\tif (U.x<.5*R.x&&iMouse.z>0.&&length(U.xy-iMouse.xy)<10.)\n\t\t\tQ.x = 1.;\n\t\tif (iFrame<1) {\n\t\t\tQ = vec4(0);\n\t\t}\n\t\tif (iMouse.z>0.) {\n\t\t\tfloat l = ln(U,p.xy,p.zw);\n\t\t\t\n\t\t\tvec2 u = U.xy-iMouse.xy;\n\t\t\tM = mix(M,vec4(1),.01*exp(-.01*dot(u,u)));\n       }\n\t\tif (iFrame < 1)\n\t\t\tM = vec4(0);\n        if (U.x>.5*R.x) Q = M;\n        \n        if (U.x<4.||U.y<4.||R.x-U.x<4.||R.y-U.y<4.||abs(U.x-R.x*.5)<4.) Q = vec4(0);\n        if (length(U-0.5*R)<1.) {\n            if (iMouse.z>0.) {\n                if (p.z>0.) Q =  vec4(iMouse.xy,p.xy);\n                else Q =  vec4(iMouse.xy,iMouse.xy);\n            }\n            else Q = vec4(-iResolution.xy,-iResolution.xy);\n        }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "NlXGWM", "name": "pattern study", "author": "sympou", "description": "a nice pattern that reminds me of the late sixties !", "tags": ["pattern"], "likes": 10, "viewed": 268, "published": 3, "date": "1622225977", "time_retrieved": "2024-07-30T19:18:33.637747", "image_code": "const float pixSize = 50.0;\nconst float lineWidth = 0.8;\n\nconst vec3 col1 = vec3(.1,.4, 1.);\nconst vec3 col2 = vec3(.1,.1,.4 );\n\n//Dave_Hoskins's hash function\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 fc = fragCoord+iTime*20.;\n    \n    //coordinates of the cell\n    vec2 uv = floor(fc / pixSize);\n    \n    //position inside the cell (0 to pixSize)\n    vec2 diff = mod(fc,pixSize);\n    \n    //direction of the 2 closest cell boundaries\n    vec2 clo = sign(diff-pixSize*0.5);\n    \n    //////\n    \n    // each cell is assigned a random direction (0 to 3)\n    int r = int(hash12(uv)*4.);\n    // w1 and w2 indicates the direction of our cell's closest walls (same 0 to 3 format)\n    int w1 = int(clo.x + 1.);\n    int w2 = int(max(clo.y*2.0,0.0) + 1.);\n    \n    //\n    \n    //we also check the random number of the 2 neighbour cells\n    int rX = int( hash12(uv + vec2(clo.x,0.0))*4.0 );\n    int rY = int( hash12(uv + vec2(0.0,clo.y))*4.0 );\n    //oposite directions\n    int wX = (w1+2)%4;\n    int wY = (w2+2)%4;\n    \n    ////\n        \n    vec3 pix = vec3(0.0); \n    \n    //is our point inside the width of the line ?\n    vec2 truc = abs(diff-pixSize*0.5) - (1.-lineWidth)*0.5*pixSize;\n    \n    // if so, we add color\n    if ( r==w1 && truc.x>0.0 || r==w2 && truc.y>0.0 ) {\n        pix = col1;\n    }\n    \n    // same thing for the neigbours\n    if ( wX==rX && truc.x>0.0 ) {\n        pix += col1;\n    }\n\n    if ( wY==rY && truc.y>0.0 ) {\n        pix += col1;\n    }\n    \n    //round ends\n    if ( pix==vec3(0) && length(abs(diff-pixSize*0.5)-pixSize*0.5) < pixSize*lineWidth*0.5 ) {\n        pix += col1;\n    }\n\n    //if ( (dot(pix,vec3(1.)) == 0.0) && (length(diff-pixSize*0.5) < pixSize*0.3)) {\n    //    pix = vec3(.1,.1,.7);\n    //}\n    \n    //background\n    if ( pix==vec3(0) ) {\n        pix = col2;\n    }\n    \n    fragColor = vec4(pix,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXGWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 200, 222, 222, 339], [341, 341, 398, 398, 2054]]}
{"id": "flsGD7", "name": "a Spiral of my mishap", "author": "MrNissenDK", "description": "It's from my mishap of a Hue wheel, with a spiral.", "tags": ["spiral", "hue"], "likes": 4, "viewed": 271, "published": 3, "date": "1622219066", "time_retrieved": "2024-07-30T19:18:34.496451", "image_code": "float PI = 3.1415926;\nfloat THI = 6.2831853;\n\nvec3 HSV2RGB(vec3 color){//Based on https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n    color.x = fract(color.x);\n    color = clamp(color,0.,1.);\n    \n    float C = color.z * color.y;\n    float X = C * (1. - abs(mod(color.x*360./60.,2.) - 1.));\n    float m = color.z - C;\n    \n    vec3 RGB_1;\n    switch(int(color.x*6.)){\n        case 0:\n            RGB_1 = vec3(C,X,0);\n            break;\n        case 1:\n            RGB_1 = vec3(X,C,0);\n            break;\n        case 2:\n            RGB_1 = vec3(0,C,X);\n            break;\n        case 3:\n            RGB_1 = vec3(0,X,C);\n            break;\n        case 4:\n            RGB_1 = vec3(X,0,C);\n            break;\n        case 5:\n            RGB_1 = vec3(C,0,X);\n            break;\n            \n    }\n    return vec3((RGB_1.x+m),(RGB_1.y+m),(RGB_1.z+m));\n}\nvec3 hsv2rgb(vec3 c){ //one I found bieng used with in this example\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,clamp(abs(fract(c.x+K.xyz)*6.-K.w)-K.x,0.,1.),c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y) * 3.;\n    \n    vec3 col = vec3(0);\n    \n    col += hsv2rgb(vec3(atan(uv.y,uv.x)/THI + iTime / 5. + pow(length(uv),1.5),length(uv)*4.,4.-length(uv)*4.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsGD7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 139, 860], [861, 861, 882, 928, 1037], [1039, 1039, 1096, 1096, 1348]]}
{"id": "fsBSWd", "name": "pukeodrome", "author": "maeln", "description": "I was experimenting with some motion and ended up finding the absolutelly horrible motion which make me dizzy very quickly.", "tags": ["raymarching", "dizzy"], "likes": 3, "viewed": 251, "published": 3, "date": "1622208481", "time_retrieved": "2024-07-30T19:18:35.339198", "image_code": "#define MAXSTEPS 128\n#define MINDIST  0.0005\n#define MAXDIST  20.0\n#define saturate(x) (clamp(0.0, 1.0, x))\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = 0.5;\n    //\n    // Loop of octaves\n    for (int i = 0; i < 5; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// Primitive fun from Iq: \n// https://iquilezles.org/articles/distfunctions\n\nstruct pLight {\n    vec3 position;\n    vec3 ambiant;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\n\nfloat sdPlane(vec3 p)\n{\n  return p.y;\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\t\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 cubes(vec3 p)\n{\n    p.z = min(p.z, 0.0);\n   \tvec3 c = vec3(1.0, 0.0, 1.0);\n    vec3 q = mod(p,c)-0.5*c;\n    float y = 0.25+0.25*(1.0*2.0);\n    float prism = sdHexPrism(q-vec3(0.0, y, 0.0), vec2(0.25,0.1));\n    float cube = sdBox(q-vec3(0.0, y, 0.0), vec3(0.25));\n    return vec2(mix(cube, prism, (sin(iTime)+1.0)/2.0), 2.0);\n}\n\nvec2 spheres(vec3 p)\n{\n    //p.z = max(p.z, 0.0);\n   \tvec3 c = vec3(2.0, 2.0, 2.0);\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    q = (rotationMatrix(vec3(1.0, 0.0, 0.0), iTime) * vec4(q, 1.0)).xyz;\n    float s1 = sdBox(q-vec3(0,0,0), vec3(0.5));\n    float s2 = sphere(q-vec3(0,1.0,1.0), 0.5);\n    vec2 u1 = vec2(smin(s1,s2,0.3), 1.0);\n    \n    return vec2(s1, 1.0);\n}\n\nvec2 centralSphere(vec3 p) {\n    float centralSphere = sphere(p - vec3(1.0, 1.0+sin(iTime)*sin(iTime*2.0), cos(cos(cos(iTime)*0.3)*2.0)), 0.5);\n    \n    return vec2(centralSphere, 2.0);\n}\n\nvec2 scene(vec3 ray)\n{\n    vec2 plane = vec2(sdPlane(ray), 0);\n    vec2 b1 = cubes(ray);\n    vec2 u1 = spheres(ray);\n    vec2 c = centralSphere(ray);\n    return spheres(ray);\n}\n\nvec2 DE(vec3 ray) {\n    return scene(ray);\n}\n\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0.0, MINDIST);\n\treturn normalize(vec3(\n    DE(pos + eps.yxx).x - DE(pos - eps.yxx).x,\n    DE(pos + eps.xyx).x - DE(pos - eps.xyx).x,\n    DE(pos + eps.xxy).x - DE(pos - eps.xxy).x));\n}\n\nvec2 raymarch(vec3 from, vec3 direction)\n{\n    float t = 1.0*MINDIST;\n    int i = 0;\n    float obj = -1.0;\n    for(int steps=0; steps<MAXSTEPS; ++steps)\n    {\n        ++i;\n        vec2 dist = DE(from + t * direction);\n        if(dist.x < MINDIST || t >= MAXDIST) break;\n        t += dist.x;\n        obj = dist.y;\n    }\n    \n    return vec2(t, t > MAXDIST ? -1.0 : obj);\n}\n\nvec3 fog(vec3 sky, vec3 mat, float dist) {\n    float fogAmount = 1.0 - min(exp(-dist*0.4), 1.0);\n    return mat;\n}\n\nvec3 material(vec2 c, vec3 hit, vec3 sky) {\n    vec3 color = sky;\n    if(c.y < 0.0) return color;\n    color = normalize(vec3(0.3*log2(c.x),0.2,0.8*(1.0-log2(c.x))));\n    return fog(sky, color, c.x);\n}\n\nvec3 phong(vec3 hit, vec3 eye, vec3 N, pLight light, float ks) {\n    vec3 L = normalize(light.position - hit);\n    vec3 V = normalize(eye - hit);\n    vec3 R = reflect(L, N);\n    vec3 ambiant = light.ambiant;\n    vec3 diffuse = max(dot(L,N), 0.0)*light.diffuse;\n    vec3 specular = pow(max(dot(R,V), 0.0), ks)*light.specular;\n    return ambiant + 0.5*(diffuse+specular);\n}\n\nfloat shininess(vec3 hit, vec3 eye, vec3 normal, pLight light) {\n    float ks = 1.0; // Specular component, should be part of the material.\n    vec3 L = light.position - hit;\n    vec3 R = reflect(L, normal);\n    vec3 V = eye - hit;\n    return pow(dot(R, V), ks);\n}\n\nmat3 rotationX(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, c, s,\n                0.0, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pLight l1 = pLight(vec3(iTime-3.0, 2.0*sin(iTime), cos(iTime)*3.0),\n                       vec3(0.8), vec3(1.0, 0.0, 0.0), vec3(0.8, 0.0, 0.0));\n    \n   \tpLight l2 = pLight(vec3(iTime-3.0, -2.0, -3.0),\n                       vec3(0.3), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.8));\n    \n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    int tx = int(uv2.x*512.0);\n    \n    vec3 target  = vec3(iTime-1.0, .5, 0.0);\n\tvec3 eye     = vec3(iTime, sin(iTime), cos(iTime));\n    vec3 up      = vec3(0.0, sin(iTime*0.5), cos(iTime*0.5));\n    target = eye + vec3(1.0, 0.0, 0.0);\n    \n    vec3 eyeDir   = normalize(target - eye);\n    vec3 eyeRight = normalize(cross(up, eye));\n    vec3 eyeUp    = normalize(cross(eye, eyeRight));\n    \n    vec3 rayDir = normalize(eyeRight * uv.x + eyeUp * uv.y + eyeDir);\n    \n    vec3 hi = vec3(255.0, 122.0, 122.0)/255.0;\n    vec3 lo = vec3(134.0, 22.0, 87.0)/255.0;\n    vec3 color = mix(lo, hi, fragCoord.y/iResolution.y);\n    vec3 sky = color;\n    vec2 c = raymarch(eye, rayDir);\n    vec3 hit = eye+c.x*rayDir;\n    vec3 norm = normal(hit);\n    \n    if(c.y >= 0.0) {\n        color = material(c, hit, color);\n        color = color * phong(hit, eye, norm, l1, 2.0);\n    }\n    \n\tfragColor = vec4(color, c.x/MAXDIST);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBSWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 136, 136, 243], [245, 323, 349, 349, 729], [731, 731, 755, 777, 1000], [1002, 1002, 1047, 1047, 1675], [1848, 1848, 1889, 1889, 1982], [1984, 1984, 2015, 2015, 2055], [2058, 2058, 2081, 2081, 2097], [2099, 2099, 2130, 2130, 2158], [2161, 2161, 2197, 2197, 2281], [2283, 2283, 2313, 2313, 2346], [2348, 2348, 2368, 2368, 2679], [2681, 2681, 2703, 2730, 3042], [3044, 3044, 3072, 3072, 3231], [3233, 3233, 3255, 3255, 3409], [3411, 3411, 3430, 3430, 3455], [3458, 3458, 3481, 3481, 3685], [3687, 3687, 3729, 3729, 4058], [4060, 4060, 4102, 4102, 4174], [4176, 4176, 4219, 4219, 4376], [4378, 4378, 4442, 4442, 4749], [4751, 4751, 4815, 4815, 5015], [5017, 5017, 5046, 5046, 5179], [5181, 5181, 5238, 5238, 6548]]}
{"id": "flfGW8", "name": "LED wall", "author": "R3N", "description": "I wanted to try simulating the look of an LED wall where each pixel is a bit separate from it's neighbors.", "tags": ["abstract"], "likes": 20, "viewed": 728, "published": 3, "date": "1622202632", "time_retrieved": "2024-07-30T19:18:36.212862", "image_code": "float rand(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.543,514.123)))*4732.12);\n}\n\nfloat noise(vec2 p) {\n\tvec2 f = smoothstep(0.0, 1.0, fract(p));\n\tvec2 i = floor(p);\n\t\n\tfloat a = rand(i);\n\tfloat b = rand(i+vec2(1.0,0.0));\n\tfloat c = rand(i+vec2(0.0,1.0));\n\tfloat d = rand(i+vec2(1.0,1.0));\n\t\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float n = 2.0;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uvp = fragCoord/iResolution.xy;\n\tuv += 0.75*noise(uv*3.0+iTime/2.0+noise(uv*7.0-iTime/3.0)/2.0)/2.0;\n    float grid = (mod(floor((uvp.x)*iResolution.x/n),2.0)==0.0?1.0:0.0)*(mod(floor((uvp.y)*iResolution.y/n),2.0)==0.0?1.0:0.0);\n    //float grid = (mod(mod(floor((uvp.y)*iResolution.y/n),2.0)+floor((uvp.x)*iResolution.x/n),2.0)==0.0?1.0:0.0);\n    vec3 col = mix(vec3(0), vec3(0.2, 0.4, 1), 5.0*vec3(pow(1.0-noise(uv*4.0-vec2(0.0, iTime/2.0)),5.0)));\n    col *= grid;\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfGW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 80], [82, 82, 103, 103, 345], [347, 347, 404, 404, 1007]]}
{"id": "stf3D7", "name": "Kinda cool, HSV Wheel Mishap", "author": "MrNissenDK", "description": "Well I tried to use the code I found to convert the HSV value to RGB instead, of the one I wrote and this kind of thing comes out of it, I kinda like it.", "tags": ["wheel", "hsv", "mishap"], "likes": 3, "viewed": 269, "published": 3, "date": "1622200559", "time_retrieved": "2024-07-30T19:18:37.038655", "image_code": "float PI = 3.1415926;\nfloat THI = 6.2831853;\n\nvec3 HSV2RGB(vec3 color){//Based on https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n    color.x = fract(color.x);\n    color = clamp(color,0.,1.);\n    \n    float C = color.z * color.y;\n    float X = C * (1. - abs(mod(color.x*360./60.,2.) - 1.));\n    float m = color.z - C;\n    \n    vec3 RGB_1;\n    switch(int(color.x*6.)){\n        case 0:\n            RGB_1 = vec3(C,X,0);\n            break;\n        case 1:\n            RGB_1 = vec3(X,C,0);\n            break;\n        case 2:\n            RGB_1 = vec3(0,C,X);\n            break;\n        case 3:\n            RGB_1 = vec3(0,X,C);\n            break;\n        case 4:\n            RGB_1 = vec3(X,0,C);\n            break;\n        case 5:\n            RGB_1 = vec3(C,0,X);\n            break;\n            \n    }\n    return vec3((RGB_1.x+m),(RGB_1.y+m),(RGB_1.z+m));\n}\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,clamp(abs(fract(c.x+K.xyz)*6.-K.w)-K.x,0.,1.),c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y) * 3.;\n    \n    vec3 col = vec3(0);\n    \n    col += hsv2rgb(vec3(atan(uv.y,uv.x)/THI + iTime / 5.,length(uv)*4.,4.-length(uv)*4.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stf3D7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 139, 860], [861, 861, 882, 882, 991], [993, 993, 1050, 1050, 1280]]}
{"id": "7tfGW7", "name": "Smile sample", "author": "sean1998", "description": "Smile", "tags": ["2d", "smipleface"], "likes": 3, "viewed": 206, "published": 3, "date": "1622194853", "time_retrieved": "2024-07-30T19:18:37.987118", "image_code": "precision mediump float;\n\nfloat plot(vec2 uv, float pct){\n  return smoothstep(0.02, 0.0, abs(uv.y - pct));\n}\n\nvec3 getcolor(vec2 uv, float y){\n    vec3 green = vec3(0,1,0);\n    vec3 black = vec3(0,0,0);\n    float f = plot(uv, y);\n    return mix(black, green, f);\n}\n\nvec3 step1(vec2 uv){\n    float y = sqrt(pow(0.4, 2.0) - pow(uv.x - 0.5, 2.0)) + 0.5;\n    return getcolor(uv, y);\n}\n\nvec3 step2(vec2 uv){\n    float y = sqrt(pow(0.4, 2.0) - pow(uv.x - 0.5, 2.0)) + 0.5;\n    return getcolor(uv, 1.0-y);\n}\n\nvec3 step3(vec2 uv){\n    float y = sqrt(pow(0.1, 2.0)-pow((abs(uv.x - 0.5) - 0.2), 2.0))/2.0 + 0.7;\n    return getcolor(uv, y);\n}\n\nvec3 step4(vec2 uv){\n    float y = - sqrt(pow(0.1, 2.0)-pow((abs(uv.x - 0.5) - 0.2), 2.0)) + 0.65;\n    return getcolor(uv, y);\n}\n\n\nvec3 step5(vec2 uv){\n    float y = sqrt(0.002-pow((abs(uv.x - 0.5 + sin(4.0*iTime)/30.0)-0.2), 2.0))*2.0/3.0 + 0.65;\n    return getcolor(uv, y);\n}\n\nvec3 step6(vec2 uv){\n    float y = 0.35-sqrt(pow(0.3, 2.0)-pow(uv.x - 0.5, 2.0))*(1.0/4.0+pow(0.5+0.5*sin(2.0*3.1415926*iTime),6.0)/10.0);\n    return getcolor(uv, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv = vec2(smoothstep(0.2, 0.7625, uv.x), smoothstep(0.0, 1.0, uv.y));\n    vec3 color =  step1(uv) + step2(uv) + step3(uv) + step4(uv) +step5(uv) + step6(uv);\n\tfragColor = vec4(color.rgb, 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 57, 57, 108], [110, 110, 142, 142, 264], [266, 266, 286, 286, 380], [382, 382, 402, 402, 500], [502, 502, 522, 522, 631], [633, 633, 653, 653, 761], [764, 764, 784, 784, 910], [912, 912, 932, 932, 1080], [1082, 1082, 1138, 1138, 1377]]}
{"id": "stXGDM", "name": "Line sample1", "author": "sean1998", "description": "just show a line", "tags": ["2d", "line"], "likes": 1, "viewed": 242, "published": 3, "date": "1622187014", "time_retrieved": "2024-07-30T19:18:38.895197", "image_code": "precision mediump float;\n\n\nfloat plot(vec2 uv, float pct){\n  return smoothstep(0.02, 0.0, abs(uv.y - pct));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tvec2 uv = fragCoord/iResolution.xy;\n    float y =  smoothstep(0.2,0.5,uv.x) - smoothstep(0.5,0.8,uv.x);\n    vec3 green = vec3(0,1,0);\n    vec3 black = vec3(0,0,0);\n    float mixa = plot(uv, y);\n    vec3 color = mix(black, green, mixa);\n    \n\tfragColor = vec4(color.rgb, 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXGDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 58, 58, 109], [111, 111, 167, 167, 450]]}
{"id": "7tf3WM", "name": "Distance to Voronoi", "author": "oneshade", "description": "Figured it out!", "tags": ["2d", "voronoi", "sdf", "borders", "exact"], "likes": 8, "viewed": 183, "published": 3, "date": "1622186238", "time_retrieved": "2024-07-30T19:18:39.778834", "image_code": "// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\n// Random cycling points\nvec2 getPoint(in vec2 cell) {\n    float freq = Hash11(dot(cell, vec2(393.84, 673.48))) * 3.0 + 1.0;\n    float phase = Hash11(dot(cell, vec2(348.46, 183.37)));\n    float amp = Hash11(dot(cell, vec2(275.35, 741.69)));\n\n    float t = iTime * freq + phase;\n    return cell + 0.5 + 0.5 * vec2(cos(t), sin(t)) * amp;\n}\n\nvec3 sdVoronoi(in vec2 p) {\n    // Get closest point\n    vec2 cell = floor(p), closest = getPoint(cell);\n    float minDist = length(p - closest);\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            if (i == 0 && j == 0) continue;\n            vec2 curCell = cell + vec2(i, j), curPoint = getPoint(curCell);\n            float dist = length(p - curPoint);\n            if (dist < minDist) {\n                closest = curPoint;\n                minDist = dist;\n            }\n        }\n    }\n\n    // Get closest border\n    cell = floor(closest);\n    vec2 p1 = getPoint(cell + 1.0);\n    float dist = dot(p - 0.5 * (closest + p1), normalize(closest - p1));\n    for (int i=-2; i < 3; i++) {\n        for (int j=-2; j < 3; j++) {\n            if ((i == 0 && j == 0) || (i == 1 && j == 1)) continue;\n            vec2 curPoint = getPoint(cell + vec2(i, j));\n            dist = min(dist, dot(p - 0.5 * (closest + curPoint), normalize(closest - curPoint)));\n        }\n    }\n\n    return vec3(closest, dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    vec3 voro = sdVoronoi(uv);\n\n    fragColor = vec4(smoothstep(0.05, 0.0, voro.z) + 0.25 + 0.25 * sin(voro.z * 50.0));\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.8, 0.0), smoothstep(0.05, 0.0, length(uv - voro.xy) - 0.05));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3WM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 115, 115, 201], [203, 228, 257, 257, 540], [542, 542, 569, 594, 1563], [1565, 1565, 1620, 1620, 1927]]}
{"id": "flX3W7", "name": "Fork Bezier Signed Distance", "author": "jorge2017a1", "description": "simple  rostro  con  bezier", "tags": ["2d", "bezier", "distance"], "likes": 2, "viewed": 232, "published": 3, "date": "1622169291", "time_retrieved": "2024-07-30T19:18:40.625570", "image_code": "//modificado por:  jorge2017a1\n//referencia:\n// Signed Distance to a Quadratic Bezier Curve\n// - Adam Simmons (@adamjsimmons) 2015\n//https://www.shadertoy.com/view/ltXSDB\n// Bezier - Signed Distance\n//Created by ajs15822 in 2015-08-12\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * signBezier(A, B, C, p);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 uv=p;\n    p-=vec2(-1.0,-0.5);\n    p.x=p.x*0.5;\n   \n// Get the signed distance to bezier curve\n//puntos control 3  puntos\nvec2 pc1p1=vec2(.386,.451);\nvec2 pc1p2=vec2(.469,.338);\nvec2 pc1p3=vec2(.505,.338);\n\nvec2 pc2p1=vec2(.308,.755);\nvec2 pc2p2=vec2(.363,.552);\nvec2 pc2p3=vec2(.385,.451);\n\nvec2 pc3p1=vec2(.307,.753);\nvec2 pc3p2=vec2(.326,.920);\nvec2 pc3p3=vec2(.413,.931);\n\nvec2 pc4p1=vec2(.413,.931);\nvec2 pc4p2=vec2(.494,.953);\nvec2 pc4p3=vec2(.595,.942);\n\nvec2 pc5p1=vec2(.595,.940);\nvec2 pc5p2=vec2(.671,.915);\nvec2 pc5p3=vec2(.679,.750);\n\nvec2 pc6p1=vec2(.678,.747);\nvec2 pc6p2=vec2(.648,.588);\nvec2 pc6p3=vec2(.615,.462);\n\nvec2 pc7p1=vec2(.614,.464);\nvec2 pc7p2=vec2(.558,.352);\nvec2 pc7p3=vec2(.505,.330);\n\nvec2 pc8p1=vec2(.377,.703);\nvec2 pc8p2=vec2(.389,.654);\nvec2 pc8p3=vec2(.397,.621);\n\nvec2 pc9p1=vec2(.379,.706);\nvec2 pc9p2=vec2(.425,.670);\nvec2 pc9p3=vec2(.469,.624);\n\nvec2 pc10p1=vec2(.469,.624);\nvec2 pc10p2=vec2(.463,.610);\nvec2 pc10p3=vec2(.460,.599);\n\nvec2 pc11p1=vec2(.456,.599);\nvec2 pc11p2=vec2(.431,.613);\nvec2 pc11p3=vec2(.397,.621);\n\nvec2 pc12p1=vec2(.537,.624);\nvec2 pc12p2=vec2(.592,.687);\nvec2 pc12p3=vec2(.620,.706);\n\nvec2 pc13p1=vec2(.621,.706);\nvec2 pc13p2=vec2(.614,.665);\nvec2 pc13p3=vec2(.603,.629);\n\nvec2 pc14p1=vec2(.603,.629);\nvec2 pc14p2=vec2(.569,.615);\nvec2 pc14p3=vec2(.547,.602);\n\nvec2 pc15p1=vec2(.483,.462);\nvec2 pc15p2=vec2(.505,.475);\nvec2 pc15p3=vec2(.523,.462);\n\nvec2 pc16p1=vec2(.536,.624);\nvec2 pc16p2=vec2(.539,.613);\nvec2 pc16p3=vec2(.545,.604);\n    \n\nvec2 pc17p1=vec2(.612,.464);\nvec2 pc17p2=vec2(.634,.253);\nvec2 pc17p3=vec2(.650,.019);\n\nvec2 pc18p1=vec2(.382,.456);\nvec2 pc18p2=vec2(.349,.184);\nvec2 pc18p3=vec2(.354,.014);\n\nvec2 pc19p1=vec2(.491,.503);\nvec2 pc19p2=vec2(.530,.473);\nvec2 pc19p3=vec2(.508,.560);\n\nvec2 pc20p1=vec2(.266,.723);\nvec2 pc20p2=vec2(.285,.819);\nvec2 pc20p3=vec2(.305,.761);\n\nvec2 pc21p1=vec2(.266,.723);\nvec2 pc21p2=vec2(.263,.591);\nvec2 pc21p3=vec2(.318,.558);\n\nvec2 pc22p1=vec2(.318,.558);\nvec2 pc22p2=vec2(.358,.530);\nvec2 pc22p3=vec2(.357,.560);\n\nvec2 pc23p1=vec2(.668,.728);\nvec2 pc23p2=vec2(.727,.827);\nvec2 pc23p3=vec2(.727,.745);\n\nvec2 pc24p1=vec2(.729,.745);\nvec2 pc24p2=vec2(.740,.626);\nvec2 pc24p3=vec2(.665,.549);\n\nvec2 pc25p1=vec2(.643,.566);\nvec2 pc25p2=vec2(.640,.415);\nvec2 pc25p3=vec2(.664,.552);\n\n\nfloat d1= sdBezier(pc1p1,pc1p2,pc1p3,p);\nfloat d2= sdBezier(pc2p1,pc2p2,pc2p3,p);\nfloat d3= sdBezier(pc3p1,pc3p2,pc3p3,p);\n\nfloat d4= sdBezier(pc4p1,pc4p2,pc4p3,p);\nfloat d5= sdBezier(pc5p1,pc5p2,pc5p3,p);\nfloat d6= sdBezier(pc6p1,pc6p2,pc6p3,p);\nfloat d7= sdBezier(pc7p1,pc7p2,pc7p3,p);\nfloat d8= sdBezier(pc8p1,pc8p2,pc8p3,p);\nfloat d9= sdBezier(pc9p1,pc9p2,pc9p3,p);\nfloat d10= sdBezier(pc10p1,pc10p2,pc10p3,p);\nfloat d11= sdBezier(pc11p1,pc11p2,pc11p3,p);\nfloat d12= sdBezier(pc12p1,pc12p2,pc12p3,p);\nfloat d13= sdBezier(pc13p1,pc13p2,pc13p3,p);\nfloat d14= sdBezier(pc14p1,pc14p2,pc14p3,p);\nfloat d15= sdBezier(pc15p1,pc15p2,pc15p3,p);\nfloat d16= sdBezier(pc16p1,pc16p2,pc16p3,p);\n\nfloat d17a= sdCircle(uv-vec2(-0.15,0.15), 0.02 );\nfloat d18a=sdCircle(uv-vec2(0.15,0.15), 0.02 );\n\nfloat d17= sdBezier(pc17p1,pc17p2,pc17p3,p);\nfloat d18= sdBezier(pc18p1,pc18p2,pc18p3,p);\nfloat d19= sdBezier(pc19p1,pc19p2,pc19p3,p);\nfloat d20= sdBezier(pc20p1,pc20p2,pc20p3,p);\nfloat d21= sdBezier(pc21p1,pc21p2,pc21p3,p);\nfloat d22= sdBezier(pc22p1,pc22p2,pc22p3,p);\nfloat d23= sdBezier(pc23p1,pc23p2,pc23p3,p);\nfloat d24= sdBezier(pc24p1,pc24p2,pc24p3,p);\nfloat d25= sdBezier(pc25p1,pc25p2,pc25p3,p);\n \n    fragColor = vec4(0.1,0.4,0.7,1.0);\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d1)) );\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d2)) );\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d3)) );\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d4)) );\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d5)) );\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d6)) );\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d7)) );\n    fragColor = mix(fragColor, vec4(0.0), 1.0-smoothstep(0.0,0.01,abs(d8)) );\n    fragColor = mix(fragColor, vec4(0.0), 1.0-smoothstep(0.0,0.01,abs(d9)) );\n    fragColor = mix(fragColor, vec4(0.0), 1.0-smoothstep(0.0,0.01,abs(d10)) );\n    fragColor = mix(fragColor, vec4(0.0), 1.0-smoothstep(0.0,0.01,abs(d11)) );\n    fragColor = mix(fragColor, vec4(0.0), 1.0-smoothstep(0.0,0.01,abs(d12)) );\n    fragColor = mix(fragColor, vec4(0.0), 1.0-smoothstep(0.0,0.01,abs(d13)) );\n    fragColor = mix(fragColor, vec4(0.0), 1.0-smoothstep(0.0,0.01,abs(d14)));\n    fragColor = mix(fragColor, vec4(0.0), 1.0-smoothstep(0.0,0.01,abs(d15)));\n    fragColor = mix(fragColor, vec4(0.0), 1.0-smoothstep(0.0,0.01,abs(d16)));\n    \n    \n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d17)));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d18)));\n    fragColor = mix(fragColor, vec4(0.0), 1.0-smoothstep(0.0,0.01,abs(d19)));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d20)));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d21)));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d22)));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d23)));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d24)));\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.01,abs(d25)));\n    \n    \n    \n    //ojos\n    fragColor = mix(fragColor, vec4(0.5,0.0,0.15,1.0), 1.0-smoothstep(0.0,0.01,d17a )  );\n    fragColor = mix(fragColor, vec4(0.5,0.0,0.15,1.0), 1.0-smoothstep(0.0,0.01,d18a )  );\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flX3W7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 271, 271, 299], [302, 365, 406, 406, 472], [474, 544, 594, 594, 945], [947, 981, 1025, 1025, 1538], [1540, 1599, 1647, 1647, 2160], [2164, 2164, 2221, 2221, 8005]]}
{"id": "ftfGW7", "name": "Bicubic Interpolation Surface", "author": "oneshade", "description": "2D cubic interpolation.", "tags": ["2d", "3d", "raymarching", "bicubic", "cubic", "surface", "interpolation"], "likes": 10, "viewed": 284, "published": 3, "date": "1622167402", "time_retrieved": "2024-07-30T19:18:41.491256", "image_code": "float bicubic4x4(in vec2 p, in mat4 v) {\n    ivec2 id = ivec2(floor(p));                                         // Cell index\n    vec2 uv = smoothstep(0.0, 1.0, fract(p));                           // Smoothed local cell coordinates\n    return mix(mix(v[id.x    ][id.y    ], v[id.x + 1][id.y    ], uv.x), // Lower horizontal pass\n               mix(v[id.x    ][id.y + 1], v[id.x + 1][id.y + 1], uv.x), // Upper horizontal pass\n               uv.y);                                                   // Vertical pass\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat anim(in float seed) {\n    float a = Hash11(seed * 393.84 + 673.48);\n    float b = Hash11(seed * 348.46 + 183.37);\n    float c = Hash11(seed * 275.35 + 741.69);\n    return 0.5 + 0.5 * sin(iTime * a + b) * c;\n}\n\nfloat mapScene(in vec3 p) {\n    float height = bicubic4x4(p.xz + 1.5, mat4(anim( 1.0), anim( 2.0), anim( 3.0), anim( 4.0),\n                                               anim( 5.0), anim( 6.0), anim( 7.0), anim( 8.0),\n                                               anim( 9.0), anim(10.0), anim(11.0), anim(12.0),\n                                               anim(13.0), anim(14.0), anim(15.0), anim(16.0)));\n\n    return max(p.y - height, max(max(abs(p.x), abs(p.z)) - 1.5, -p.y));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p) * 0.75;\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n\n            fragColor.rgb += smoothstep(0.0, 0.05, abs(fract(p.x + 2.0) - 0.5));\n            fragColor.rgb += smoothstep(0.0, 0.05, abs(fract(p.z + 2.0) - 0.5));\n            fragColor.rgb *= 0.5 * max(0.0, dot(n, -rd));\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 518], [520, 609, 635, 635, 721], [723, 723, 750, 750, 937], [939, 939, 966, 966, 1423], [1425, 1425, 1452, 1452, 1694], [1696, 1696, 1751, 1770, 2823]]}
{"id": "flXGW7", "name": "Noisy Dithering", "author": "lambmeow", "description": "Created a dithering effect by offsetting the pixel screen coordinates.\n\nLooks better in fullscreen", "tags": ["2d", "noise", "fbm", "gradient", "dithering"], "likes": 2, "viewed": 303, "published": 3, "date": "1622166461", "time_retrieved": "2024-07-30T19:18:42.366914", "image_code": "//Noisy Dither\n//Lopea\n//2021\n\n#define time iTime\n\n//IQ's Gradient noise algorithm\n/////////////////////////////////////////////////////////////////////////////\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,331.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    vec2 a  = random(i);\n    vec2 b = random(i + vec2(1,0));\n    vec2 c = random(i + vec2(0, 1));\n    vec2 d = random(i + vec2(1, 1));\n    \n    vec2 u = f * f * f *(f *(f*6. - 15.)+10.);\n    \n    return mix(mix ( dot( a, f), dot(b, f - vec2(1, 0)), u.x),\n        mix ( dot( c, f-vec2(0,1)), dot(d, f - vec2(1, 1)), u.x), u.y);\n\n}\n/////////////////////////////////////////////////////////////////////////////\n\n//fractal brownian motion\nfloat fbm(vec2 uv)\n{\n    //store the result of the noise texture\n    float result = 0.;\n    \n    //store the current amplitude value\n    float amplitude = 1.;\n    \n    //iterate a few times to give noise a more detailed look\n    for(int i = 0; i < 8; i++)\n    {\n        //add to the result ( with a few modifications\n        result += noise(uv + vec2( time - float(i)  +10., -time/25.- float(i)/2.)) * amplitude;\n        \n        //shrink the noise texture for the next iteration\n        uv *= 2.;\n        \n        //make next noise iteration less potent \n        amplitude *= 0.5;\n    }\n    \n   \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //set the threshold for color value, will be compared to screen space.\n    float threshold = fbm(vec2(fbm(uv * 10.), fbm(uv * 10. + 3.)));\n    \n    //create the dithering effect by warping the screen coordinates\n    float coord = sin(uv.x * 1000.) * sin(uv.y * 1000.) * .25;\n    \n    //compare warped screen coords to the threshold and create the color value\n    vec3 color = mix(vec3(0, .04, .1), vec3(0,1,1) , vec3(step(coord, threshold)));\n    \n    //create an outline effect by subracting same algorithm but with a smaller threshold\n    color -= step(clamp(coord, 0., 1.), threshold - .1) * vec3(1);\n    \n    //set the color to the pixel\n    fragColor = vec4(color , 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXGW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 161, 183, 183, 322], [324, 324, 346, 346, 729], [809, 835, 855, 899, 1452], [1454, 1454, 1511, 1561, 2288]]}
{"id": "Nll3WN", "name": "小龙猫 - Shadow Experiment", "author": "totetmatt", "description": "Learning shadow and trying to enhance my personal boiler plate code for shader performance", "tags": ["shadow"], "likes": 1, "viewed": 233, "published": 3, "date": "1622121182", "time_retrieved": "2024-07-30T19:18:43.221629", "image_code": "/*\n\nExperiment on Shadow  + Code Refinement\n\nThe scene is slighty more than just a surface and a volume.\nThe light is between the \"planets\" and the \"torus\" and moving on X axis (so left to right)\n* Little planet should have a shadow on the big planet and torus\n* Big planet should ahve shadow on the torus\n* The Torus **should not** cast any shadow \n\n(Big learning on my side for the algo, if you don't stop properly, \nit's \"bounce back the shadow\" which isn't what we want ... but maybe intersting for effects  ? Who knows ?)\n\n*/\n\n#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec2 sdf(vec3 p){\n  vec2 h;\n  h.x=length(p)-1.;\n  h.y=1.;\n  vec2 t;\n  t.y=1.;\n  \n  t.x=length(vec2(length(p.xz)-10.,p.y+1.+sin(fGlobalTime+atan(p.x,p.z)*3.)))-.5;\n  h=t.x<h.x?t:h;\n  \n   t.x = length(p+vec3(-0.5,+0.01,+1.9))-.1;\n    h=t.x<h.x?t:h;\n  return h;\n}\n\n#define q(s)s*sdf(p+s).x\nvec2 nv=vec2(-.01,.01);\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yyx)+q(nv.yxy)+q(nv.xxx));}\n\nfloat raym(inout vec3 rp,vec3 rd, out vec2 mat) { // Yeah trying ways to organise all this sh***. Not sure will keep that way\n      \n      float i=0.;\n      float accDist = 0.; \n      for(;i<=69.;i++){\n          vec2 d = sdf(rp);\n          if(d.x<=0.001){\n               mat = d;\n               return accDist;\n          }\n          rp+=d.x*rd;\n          accDist +=d.x;\n      }\n      return accDist;\n }\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col=vec3(.01);\n\n    vec3 ro=vec3(0.,0.,-5.),rd=normalize(vec3(uv,1.)),rp=ro;\n    vec3 light=vec3(sin(fGlobalTime)*3.63,.0,-3.3);\n\n    vec2 mat;\n    float res = raym(rp,rd,mat);\n    if(res <= 40.){ // Which correspond to the usual \"far plane limit\" ? \n        vec3 n=norm(rp);\n        col=vec3(.05)+vec3(1.)*max(dot(normalize(light-rp),n),.0);\n    }\n\n    // Shadow compute, march along rp -> light, if you reach something it's a match for shadow, if you reach the light, call a monk\n    rd=normalize(light-rp);\n    float maxLightDist = length(light-rp); // The maximum travel to the light from the point, if the ray pass this limit, then it means nothing was between surface an light = no shadow\n    rp+=rd*.1; // Need to march a little bit to avoid the algo to be lost. I would call that \"L'Offset du cul\"\n    res = raym(rp,rd,mat); // reuse of function, WooOOOOooW\n    if(res < maxLightDist){\n     col *=vec3(.1); // Some people put a value, I tried with a mul, do what please you.\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nll3WN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 576, 576, 623], [624, 624, 641, 641, 884], [935, 935, 953, 953, 1012], [1014, 1014, 1063, 1139, 1416], [1419, 1419, 1476, 1526, 2617]]}
{"id": "slXGDN", "name": "Realtime Extruded Quadtree", "author": "Shane", "description": "Raymarching a random extruded quadtree in realtime.", "tags": ["dof", "random", "block", "quadtree", "extrude"], "likes": 74, "viewed": 2169, "published": 3, "date": "1622116031", "time_retrieved": "2024-07-30T19:18:44.180067", "image_code": "/*\n\n\n    Realtime Extruded Quadtree\n    --------------------------\n    \n    FMS_Cat posted a beautifully rendered, static extruded quadtree example the \n    other day that appealed to me on many levels. Since I already had a realtime  \n    quadtree example tucked away in my account, it inspired me to put on some\n    finishing touches and post it. Designwise, I \"borrowed\" two aspects from \n    FMS_Cat's scene. One was the camera angle, and the other was the hollowing \n    out of random blocks. I added some moving objects to the hollowed blocks to \n    provide a personal touch and to further illustrate the idea that this is a \n    realtime example. \n    \n    The quadtree code itself was based on a 2D quadtree demonstration I posted \n    on Shadertoy a few months ago, which ironically was much harder to produce \n    than this.\n\t\n\tCoding up an extruded quadtree in realtime is still a bit of an ask. \n    Thankfully, unlike my coding skills, machines have improved considerably \n    over the past few years, so it runs reasonably efficiently... Not fantastic, \n    but not too bad on decent machines. Apologies to anyone with a slower system,\n    but even with cost cutting, there's a fair bit of processing going on.\n\n    If you were to code an extruded tri-level quadtree using nested brute force \n    neighboring column repeat methods, you'd need a GPU-burning 64 taps, which \n    isn't satisfactory. However, using a mixture of simultaneous scaling and \n    repeat neighboring methods can get it right down to just 12, which \n    conceptually is about as good as you're going to get... Having said that, \n    there are some freakishly good coders on this site, so it wouldn't shock me \n    if someone got the number down. :)\n    \n    FMS_Cat's scene also included water, which would have been a great addition, \n    but I had to let it go, as it would have required extra passes -- Fake \n    environmental lighting was all I could afford this time around. However, I \n    have a regular extruded block example with water that I'll post later.\n\t\n    \n\n\tInspired by:\n    \n\t// I love static renderings like this.\n    \"Wooden Structure\" - FMS_Cat\n\thttps://www.shadertoy.com/view/sdjXWy\n    \n    // I based the code on this particular example.\n    Sorted Overlapping Quadtree - Shane\n    https://www.shadertoy.com/view/wtjfDy\n\n\n*/\n\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 3.5 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 3.5, coc = 1.;\n    // Linear distance from either side of the focal point.\n    float l = abs(focD - texture(iCh, uv).w);\n    // Using it to calculate the DOF.\n    vec2 dof = clamp((l - coc)/(1.*coc), 0., 1.)/vec2(800, 450); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)*dof).xyz;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n\n// This would normally be a very quick routine that displays\n// the scene and gives it a distance of field effect, but I \n// wanted to put in a little loading bar graphic just to let\n// people know that some precalculation is happening in the \n// background... and to give impatient people like me a visual \n// representation of the time it's going to take. :D\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n     \n    \n    // Apply some depth of field, then present to the screen.\n    vec3 col = DpthFld(iChannel0, fragCoord/iResolution.xy);\n    \n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    The scene itself: It's just standard single pass raymarching code. The only \n    interesting function is the \"block\" function that renders the extruded \n    quadtree structure.\n    \n    \n*/\n\n// Block scale.\n#define GSCALE vec2(1./2.)\n\n// Pylon face shape: Each one has its own appeal.\n// Circles: 0, Square: 1, Rounded Square: 2.\n#define SHAPE 2\n\n// Give the pylon sides the same color as the trim.\n//#define LIGHT_SIDES\n\n// Grayscale, for that artsy look.\n//#define GRAYSCALE\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's texure hash -- I'm taking Flockaroo's word for it that the textureLod\n// function will help avoid artifacts.\nvec3 hash23T(vec2 p){  return textureLod(iChannel2, p, 0.).xyz; }\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D ch, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(ch, fract(p)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\nfloat hm(in vec2 p){ \n    return dot(getTex(iChannel1, p/4.), vec3(.299, .587, .114));\n}\n\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    \n    // Slight rounding. A little nicer, but slower.\n    //const float sf = .025;\n    //vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \t//return min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    \n}\n\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n// Pylon or moving object ID.\nvec2 oID;\n\n// The extruded quadtree.\nvec4 blocks(vec3 q3){\n    \n    // Block dimension.\n    vec2 oDim = GSCALE;\n    vec2 dim = GSCALE; \n    \n    // Distance.\n    float d = 1e5;\n    \n    // Final entry needs to fill in the rest, so you give it a 100% chance of success.\n    // I'd rather not say how long it took me to figure that out. :D\n    //float rndTh[4] = float[4](.25, .333, .5, 1.01);\n    float rndTh[4] = float[4](.333, .5, 1.01, 1.01);    \n    \n    vec2 id = vec2(0);\n    float boxID = 0.;\n    oID = vec2(0);\n    \n     \n    // Three quadtree levels.\n    for(int k=0; k<3; k++){\n \n        // Four block neighbors.\n        for(int j = 0; j<=1; j++){\n            for(int i = 0; i<=1; i++){\n                \n                // For the 12 tap (4-tap IJ loop), we need the \"-.5\" figure to center things.\n        \t\t// For the 27 tap (9-tap IJ loop), take it off the expression.\n        \t    vec2 ip0 = q3.xy/dim + vec2(i, j) - .5;\n\n               \n                float rndIJ[4];\n                rndIJ[0] = hash21(floor(ip0));\n                if(rndIJ[0]>=rndTh[k]) continue;\n\n                rndIJ[1] = hash21(floor(ip0/2.));\n                if(k==1 && rndIJ[1]<rndTh[0]) continue;\n\n                rndIJ[2] = hash21(floor(ip0/4.));\n                if(k==2 && (rndIJ[1]<rndTh[1] || rndIJ[2]<rndTh[0])) continue;\n\n                //rndIJ[3] = hash21(floor(ip0/8.)); \n                //if(k==3 && (rndIJ[1]<rndTh[2] || rndIJ[2]<rndTh[1] || rndIJ[3]<rndTh[0])) continue; \n\n\n                //if(rndIJ[0]<rndTh[k])\n                {\n\n                    //vec2 p = mod(oP, dim) - dim/2.; // Last term for 8 iterations.\n                    vec2 p = q3.xy;\n                    vec2 ip = floor(ip0) + .5;\n                    p -= ip*dim; // Last term for 8 iterations.\n\n                    vec2 idi = ip*dim;\n\n                    // The extruded block height. See the height map function, above.\n                    //float h = hm2(idi/256.);//15 + float(j)*.15;//\n                    float h = hm(idi);//15 + float(j)*.15;//\n\n                    //h = floor(h*15.999)/15.; // Or just, \"h *= .15,\" for nondiscreet heights.\n                    h *= .2;//.2;\n                   \n                    // Offset. Not used here, but it can be.\n                    vec2 off = vec2(0);//(hash22(idi + .37*dim) - .5)*dim*.35;\n\n                    // The 2D blocks.\n                    #if SHAPE == 0\n                    // Circle.\n                    float di2D = length(p - off) - dim.x/2.;\n                    #elif SHAPE == 1\n                    // Rounded squares.\n                    float di2D = sBoxS(p, dim/2. - .01*oDim.x, .0);\n                    #else\n                    // Rounded squares.\n                    float di2D = sBoxS(p, dim/2. - .01*oDim.x, .3*(dim.x));\n                    #endif\n                    \n                    // Some random number.\n                    vec3 r3 = hash23T(idi*7.27183 + .36);\n                    float rnd = r3.x;\n                    if(rnd<.5) {\n                        // Hollow out random pylons.\n                        di2D = abs(di2D + .04*oDim.x) - .04*oDim.x;\n                    \n                    }\n\n\n                    // The extruded distance function value.\n                    float di = opExtrusion(di2D, (q3.z + h - 32.125), h + 32.125);\n                    \n                    // Adding a bit of the face value to put a bit of variation on the top.\n                    di += di2D/8.;\n                    \n\n                    // The moving ball bearings. I made this up quickly, so there'd be\n                    // better ways to go about it.\n                    vec2 toID = vec2(0);\n                    // Only do it for hollowed out pylons for the first two levels.\n                    if(k<2 && rnd<.5) {\n                    \n\n                        float bh = sin(iTime*(r3.y + 5.)/4. + dot(idi, vec2(27.163, 113.457)) + r3.z*6.2831)*(dim.x + 1.);\n                        float qz = q3.z + h - 1. + bh;\n                        float ball = length(vec3(p, qz)) - .3*dim.x*(r3.y*.5 + .5);\n                        //float ball = max(oDi2D + oDim.x*.2, abs(qz) - dim.x*.2);\n                        //float ball2 = max(length(p) - .3*dim.x*(rnd2*.5 + .5), abs(qz) - .0*dim.x);\n                        //ball = max(ball, -(abs(ball2) - .02*dim.x));\n                        \n                        toID.x = di<ball? 0. : 1.;\n                        toID.y = bh;\n                        di = min(di, ball);\n                    \n                    }\n                    \n                    // Random sprinkles.\n                    //di += hash23T((q3.xy + q3.z)/8.).z*.003;\n                    \n\n\n                    // If applicable, update the overall minimum distance value,\n                    // ID, and box ID. \n                    if(di<d){\n                        \n                        d = di;\n                        id = idi;\n                        // Not used in this example, so we're saving the calulation.\n                        boxID = di2D;//float(k*4 + j*2 + (1 - i));\n                        oID = toID;\n                    }\n\n\n                }\n                \n\n\n            }\n        }\n\n        // Halve the dimension for the next iteration.\n        dim /= 2.; \n        \n    }  \n    \n    return vec4(d, id, boxID);\n    \n    \n}\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + 64.251;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.5 : d*.85; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t)*.7;\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .2); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(mod(h, 6.2831))*43758.5453), fract(sin(mod(h + s.x, 6.2831))*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 4.;\n    p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*c*c, c*c, c); // Blueish tinge.\n    \n    return mix(p.zxy, p, n3D2); // Mixing in a bit of red.\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0., iTime/2., -1.8); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(-.5, 4, .9);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n\trd.xy *= rot2(3.14159/5.); // + sin(iTime/6.)/8. + .125\n\trd.yz *= rot2(-3.14159/5.);\n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Global distance.\n    float gDist = t;\n    \n    // Save the block ID, object ID, etc.\n    vec3 svGID = gID;\n    vec2 svoID = oID;\n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 12.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n \t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.  \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n        \n            // Coloring the pylons and moving objects.\n            \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(iChannel3, svGID.xy/8. + .12);\n            \n            // Texture coordinates.\n            vec3 txP = sp;\n           \n            if(svoID.x==1.){\n            \n                // Moving bearing object texture coordinates.\n                txP += vec3(0, 0, svoID.y);\n\n                // Evening out the moving bearing object color. \n                tx = mix(tx, min(1./vec3(dot(tx, vec3(.299, .587, .114))), 1.), .2);\n            }\n            \n            tx = min(tx*1.5, 1.);\n            \n            // Multicolored.\n            //tx = .58 + .42*cos(6.2831*n3D(vec3(svGID.xy, 1))/2. + vec3(0, 1, 2));\n            \n            \n            // Tri-planar texturing.\n            vec3 tx2 = tex3D(iChannel3, txP/2. + svoID.x/2.*0., sn);\n            tx2 = smoothstep(0., .5, tx2);\n            \n            // Pylon color... I need to give the names more meaning, I think. :)\n            texCol = mix(tx, tx*tx2*4., 1.);\n            \n           \n             \n            //diff = pow(diff, 4.)*2.;\n            // Central dots.\n            //vec2 svP = sp.xy - svGID.xy;\n            //texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, length(svP) - .02));\n            \n            // Coloring the pylons only.\n            if(svoID.x==0.){\n            \n                // Face height and value.\n                float ht = hm(svGID.xy)*.2;\n                float face = svGID.z;\n\n                // Top pylon face coloring.\n                float face2 = face;\n                face = max(abs(face), abs(sp.z + ht*2.)) - .02; // Face border.\n                //face = min(face, abs(face2 + .01) - .00125); // Extra border.\n                \n                \n                // Line pattern.\n                float lSc = 30.;\n                float pat = (abs(fract((sp.x - sp.y)*lSc - .5) - .5)*2. - .5)/lSc;\n                //float pat = (abs(fract(hex2*lSc - .5) - .5)*2. - .25)/lSc;\n                \n                // Top color.\n                vec3 tCol = texCol/4.;\n               \n                // Top face color... I hacked this together in a hurry, but I'll tidy it later.\n                vec3 faceCol = mix(texCol, vec3(0), (1. - smoothstep(0., .01, pat))*.25);\n                float ew = .03;\n                tCol = mix(tCol, tx2*vec3(1.3, .9, .3)*4., (1. - smoothstep(0., .002, face2 + .01)));\n                tCol = mix(tCol, texCol/4., (1. - smoothstep(0., .002, face2 + ew)));\n                tCol = mix(tCol, faceCol, (1. - smoothstep(0., .002, face2 + ew + .01)));\n                \n                #ifdef LIGHT_SIDES\n                // Colored sides.\n                texCol = tx2*vec3(1.3, .9, .3)*3.;\n                #endif\n                \n                // Applying the top face color.\n                texCol = mix(texCol, tCol, (1. - smoothstep(0., .002, sp.z + ht*2.)));\n \n            \n                \n            }\n            //else texCol = (tx2*vec3(1.3, .9, .3)*4.);\n           \n            #ifdef GRAYSCALE\n            // Grayscale, for that artistic feel.\n            texCol = vec3(dot(texCol, vec3(.299, .587, .114)));    \n            #endif\n            \n            // Darkening the edges of the open silos, or whatever they are. :)\n            texCol = mix(texCol, vec3(0), smoothstep(0., 1., sp.z));\n            \n        \n \n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + vec3(.04, .08, .12) + vec3(.2, .4, 1)*fre*sh*0. + vec3(1, .7, .4)*spec*freS*sh*8.);\n\n\n        // Fake environment mapping.\n        vec3 cTex = envMap(reflect(rd, sn));\n        col += col*cTex*15.; \n        \n        \n        // Shading.\n        col *= ao*atten;\n          \n\t\n\t}\n    \n\n    // Mild temporal blur... Not really need here.\n    //vec4 oCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //col = mix(oCol.xyz, max(col, 0.), 1./2.);\n    \n    // Rought gamma correction.\n\tfragColor = vec4(max(col, 0.), gDist);\n\t\n}", "buffer_a_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXGDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2340, 3121, 3158, 3204, 3918], [3921, 4285, 4340, 4413, 4554]]}
{"id": "MtfGzn", "name": "SphereMiner", "author": "bloodnok", "description": "An experiment in negative spaces.", "tags": ["raymarched"], "likes": 9, "viewed": 350, "published": 3, "date": "1622109209", "time_retrieved": "2024-07-30T19:18:45.044764", "image_code": "/*\n\tPinching noise and basic raymarching setup from Octavio Good: https://www.shadertoy.com/view/4dSXDd\n*/\n\n// noise functions\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nvec3 noise3(vec3 uv)\n{\n    return vec3(\n        noise(uv),\n        noise(uv.yzx + vec3(35.654,135.7,17.2)),\n        noise(uv.zxy + vec3(19.7,39.7,117.7))\n        );\n}\n\nfloat PI=3.14159265;\n\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\nfloat sdInvSphere( vec3 p, float s )\n{\n\treturn -sdSphere(p,s);\n}\nfloat sdqSphere( vec3 p, float ss )\n{\n\treturn dot(p,p)-ss;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    //vec2 d3 = vec2(-d2.x,d2.y);\n    //return max(-d2,d1);\n    return (-d1.x > d2.x) ? vec2(-d1.x,d1.y) : d2;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\nvec2 distanceToScene(vec3 p)\n{\n    /*\n\tfloat t = sdSphere(p - vec3(0.0), 0.1);\n    t = min(t,sdSphere(p - vec3(0.3), 0.5));\n    t = min(t,sdSphere(p - vec3(-0.1), 0.2));\n    t = min(t,sdSphere(p - vec3(0.0,0.2,-0.2), 0.3));\n    t = min(t,sdSphere(p - vec3(0.1,0.0,-0.5), 0.5));\n    t = t - noise(p*50.0) * 0.01;\n*/\n  \n    vec2 res = vec2(10000.0,0.0);\n    \n//    float t = 10000.0;//sdSphere(p - vec3(0.0), 0.1);\n    \n    \n    for(float i=-0.5;i<5.0;i+=0.9)\n    {\n        res = opU(res,vec2(sdSphere(p - vec3(0.0,-0.05,i), 0.5),1.0));\n        \n        res = opU(res,vec2(sdSphere(p - vec3(-0.5,-0.05,i), 0.1),0.9));\n        res = opU(res,vec2(sdSphere(p - vec3(0.5,-0.05,i), 0.1),0.9));\n    }\n    \n    //t = sqrt(t);\n    //if (camDist<5.0){\n    \n    float ns = 10.0, na = 0.02;\n    float n = 0.0;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    \n    res.x-=n;\n    \n        //t = t - noise(p*20.0) * 0.02;\n        //t = t - noise(p*40.0) * 0.01;\n        //t = t - noise(p*80.0) * 0.005;\n    \t//t = t - noise(p*200.0) * 0.001;\n    //}\n    \n    //return t;\n    return opS(res,vec2(sdSphere(p - vec3(0.0,0.0,-0.5), 50.0),0.0));\n}\n\n//float distanceToScene(vec3 p)\n//{\n//    return distanceToScene(p,0.0).x;\n//}\n    \nvec3 getNormal(vec3 p, float dist)\n{\n    vec3 e = vec3(0.0025, 0, 0);\n    return normalize(vec3(dist - distanceToScene(p - e.xyy).x,\n                        dist - distanceToScene(p - e.yxy).x,\n                        dist - distanceToScene(p - e.yyx).x));\n}\n\nfloat shadowMarch(vec3 p0, vec3 d)\n{\n    vec3 p;\n    float s = 1.0;\n    float t = 0.0;\n    \n    for(int i=0;i<16;i++)\n    {\n        p = p0 + d * t;\n        float dist = distanceToScene(p).x;\n        \n        //s *= (1.0 - smoothstep(0.001,0.002,dist)*0.8);\n       \n        t += max(dist,0.1);\n        //s *= 1.0 - clamp(abs(dist),0.0,1.0);\n        \n        //if (s<0.01) break;\n        //if (abs(dist)<0.001) break;\n            \n        \n        //t+=0.1;\n        //if (s<0.001) break;\n        //p = p0 + d * t * 0.05;\n        //float dist= distanceToScene(p);\n        //s *= (1.0 - smoothstep(0.0,0.001,dist)*0.5);\n\t\t\n    }\n    \n    return s;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = distanceToScene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.025, 0.20 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 tempToColour(float t)\n{\n    return vec3(\n        smoothstep(500.0,2000.0,t) * 0.95,\n        smoothstep(900.0,5000.0,t),\n        smoothstep(2000.0,10000.0,t)\n       )*4.0;\n}\n\nfloat OrenNayar(float roughness, float albedo, vec3 rd, vec3 nor, vec3 light)\n{\n    // oren-nayar\n    //float roughness = 0.5;\n    //float albedo = 1.0;\n    float roughness2 = roughness*roughness;\n    float onA = 1.0 - 0.5 * (roughness / (roughness+0.57));\n    float onB = 0.45 * (roughness / (roughness+0.09));\n\n    float ndotl = dot(nor,light);\n    float ndotv = dot(nor,-rd);\n\n    float ai = acos(ndotl);\n    float ar = acos(ndotv);\n\n    float onAlpha = max(ai,ar);\n    float onBeta = min(ai,ar);\n    float onGamma = dot(-rd - nor * dot(-rd,nor),light - nor * dot(light,nor)); // ?\n\n    return (albedo / 3.1415927) * max(0.0,dot(nor,light)) * (onA + (onB * max(0.0,onGamma) * sin(onAlpha) * tan(onBeta)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 lightV = normalize(vec3(-1.0,0.8,0.0));\n    vec3 lightC = vec3(0.85,0.9,1.0) * 0.05;\n    vec3 camLightC = vec3(0.95,0.92,0.8) * 0.5;\n    \n    vec2 muv = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    \n\tvec3 camPos = vec3(0.0,0.0,1.5+sin(iTime * 0.1) * 2.0);\n    //vec3 camFacing;\n\tvec3 camUp=vec3(0.0,1.0,0.0);\n\tvec3 camLookat=vec3(muv.x*4.0,muv.y*4.0,camPos.z + 1.0);\n    \n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * 0.8 * sideNorm * (iResolution.x/iResolution.y) + uv.y * 0.8 * upNorm;\n\tvec3 relVec = normalize(worldPix - camPos);\n    \n    \n    // material parameters\n    vec3 emmissive = vec3(0.0);\n    vec3 albedo = vec3(0.0);\n    float specexp = 30.0;\n    float spec = 0.0;\n    float roughness = 0.0;\n    \n    \n    // Raymarch\n    float t = 0.0;\n    vec2 dist = vec2(0.1,0.0);\n    float distMax = 20.0;\n    vec3 p = vec3(0.0);\n    \n    for(int i=0;i<64;i++)\n    {\n        if ((dist.x > distMax) || (abs(dist.x) < 0.001)) break;\n        \n        p = camPos + relVec * t*0.95;\n        dist = distanceToScene(p);\n        t += dist.x;//*0.9999;\n    }\n    \n    vec3 nor = getNormal(p,dist.x);\n\n    // material\n    if (dist.y>0.95)\n    {\n        vec3 n3 = noise3(p * 400.0);\n        \n        albedo = vec3(0.3) + n3 * vec3(0.05,0.07,0.1);\n        roughness = 0.9;\n        \n        nor = normalize(nor + (n3 - 0.5) * 0.2);\n        \n        float sn = noise(p*vec3(0.5,9.0,9.0)) + noise(p*30.0) * 0.05;\n        //spec = (smoothstep(0.9,0.92,sn) * (1.0-smoothstep(0.95,0.97,sn))) * smoothstep(0.5,0.7,noise(p*3.0));\n        spec = smoothstep(0.99,0.992,sn);\n        \n        spec += smoothstep(0.7,0.95,noise(p * 15.0)) * 0.05;\n        \n        albedo *= (1.0-spec*0.5); \n        roughness *= (1.0-spec);\n    }\n    else if (dist.y > 0.85)\n    {\n        float temperature = \n            500.0 + \n            smoothstep(0.0,1.0,noise(p*3.0)) * 300.0 + \n            //smoothstep(0.6,1.0,noise(p*40.0)) * 950.0 + \n            smoothstep(0.7,1.0,noise(p*40.0)) * 3000.0;\n        temperature *= abs(sin(iTime * 0.05));\n        emmissive = tempToColour(temperature);\n        albedo = vec3(0.3);\n    }\n    \n    vec3 col = vec3(0.0);\n    //vec3 diffuse = vec3(0.2);\n    \n    // hit\n    if (abs(dist.x) < 0.1)\n    {\n        \n        // diffuse\n        col = albedo * clamp(dot(nor,lightV),0.0,1.0) * lightC;\n        \n        // camera light\n        vec3 camLightV = (camPos-p + vec3(0.1,-0.22,-0.1));\n        float camLightPower = 1.0 / dot(camLightV,camLightV);\n        camLightV = normalize(camLightV);\n        //camLightPower *= shadowMarch(p,-camLightV);\n        //camLightPower *= (softshadow(p,camLightV,0.02, 0.5));\n        \n        float diffuse = OrenNayar(1.0, 1.0, relVec, nor, camLightV);\n        \n        col += albedo * clamp(diffuse,0.0,1.0) * camLightC * camLightPower;\n        \n        // specular\n        vec3 refl = reflect(relVec,nor);\n        col += spec * pow(clamp(dot(refl,camLightV),0.0,1.0),specexp) * camLightC * camLightPower;\n        \n        // emmissive\n        col += emmissive;\n        \n        //col = nor * 0.5 + 0.5;\n    }\n\n    float fog = 1.0 - 1.0 / exp(  t * 0.9);\n    \n    \n    col = mix(col,vec3(0.0),fog);\n    fog = max(0.0,fog-0.2);\n    col = mix(col,vec3(0.6,0.8,1.0)*0.1,fog*fog);\n\n    \n    // gamma\n    col = pow(col,vec3(0.4545));\n\n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtfGzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 127, 150, 150, 223], [224, 224, 247, 247, 318], [319, 319, 342, 342, 428], [429, 429, 470, 470, 513], [551, 551, 575, 575, 848], [849, 849, 871, 871, 1456], [1458, 1458, 1480, 1480, 1624], [1649, 1649, 1684, 1684, 1707], [1708, 1708, 1746, 1746, 1772], [1773, 1773, 1810, 1810, 1833], [1835, 1835, 1865, 1925, 1978], [1980, 1980, 2010, 2010, 2043], [2046, 2046, 2076, 2360, 3323], [3409, 3409, 3445, 3445, 3667], [3669, 3669, 3705, 3705, 4314], [4316, 4316, 4390, 4390, 4664], [4666, 4666, 4694, 4694, 4843], [4845, 4845, 4924, 4997, 5555], [5557, 5557, 5614, 5614, 9156]]}
{"id": "NtlGDH", "name": "Fork GLOW TUTOR vanky 801", "author": "vanky", "description": "A simple glow effect and how to control it.\n\nSee [url]https://www.desmos.com/calculator/eecd6kmwy9[/url] for an illustration as mentioned in the code\n\nSee also P_Malin's comment below and [url]https://www.desmos.com/calculator/f14x5a9lsb[/url]", "tags": ["tutorial", "bloom", "glow"], "likes": 3, "viewed": 390, "published": 3, "date": "1622105842", "time_retrieved": "2024-07-30T19:18:45.910440", "image_code": "// How to achieve and control a simple distance glow effect based on several Shadertoy examples\n// Things to try:\n//  * Make the radius and intensity pulse in time or to input\n//\t* Time varying colour\n//  * Animate several points and add the glow values for each to create metaballs\n//  * Generate more complex shapes\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //***********    Basic setup    **********\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // The ratio of the width and height of the screen\n    float widthHeightRatio = iResolution.x/iResolution.y;\n    vec2 centre = vec2(0.5, 0.5);\n\t// Position of fragment relative to centre of screen\n    vec2 pos = centre - uv;\n    // Adjust y by ratio for uniform transforms\n    pos.y /= widthHeightRatio;\n    \n    //**********         Glow        **********\n    \n    // Equation 1/x gives a hyperbola (n.双曲线,y=1/x)which is a nice shape to use for drawing glow as \n    // it is intense near 0 followed by a rapid fall off and an eventual slow fade\n    float dist = 1./length(pos);\n    \n    //**********        Radius       **********\n    \n    // Dampen (vt. 抑制) the glow to control the radius\n    dist *= 0.1;\n    \n    //**********       Intensity     **********\n    \n    // Raising the result to a power allows us to change the glow fade behaviour\n    // See https://www.desmos.com/calculator/eecd6kmwy9 for an illustration\n    // (Move the slider of m to see different fade rates)\n    dist = pow(dist, 0.8);\n    \n    //Knowing the distance from a fragment to the source of the glow, the above can be written compactly as: \n    //\tfloat getGlow(float dist, float radius, float intensity){\n    //\t\treturn pow(radius/dist, intensity);\n\t//\t}\n    //The returned value can then be multiplied with a colour to get the final result\n       \n    // Get colour\n    vec3 col = dist * vec3(1.0, 0.5, 0.25);\n\t\n    // See comment by P_Malin\n    col = 1.0 - exp( -col );\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlGDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 375, 482, 2054]]}
{"id": "7tf3DN", "name": "Psychomathic Dive Code Splice", "author": "xenn", "description": "whatever", "tags": ["video", "edge", "multipass"], "likes": 5, "viewed": 340, "published": 3, "date": "1622105364", "time_retrieved": "2024-07-30T19:18:46.827987", "image_code": "// Fork of \"Menger Journey\" by Syntopia. https://shadertoy.com/view/Mdf3z7\n// 2021-05-27 15:10:36\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = max(texture(iChannel0,uv),texture(iChannel1,uv+0.002));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nmat2 rot2D(float theta)\n{\n \treturn mat2(cos(theta), -sin(theta), sin(theta), cos(theta));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // sample the last texture with uv's slightly scaled up\n    vec2 offs = (uv- 0.5) * 0.05 * sin(iTime* 01.2);\n    offs = offs * rot2D(iTime);\n    vec3 overlay = texture(iChannel1, offs + uv).rgb;\n    \n    // Additively blend the colors together\n    vec4 col = vec4(base* 0.8 + overlay*0.4, 2.0);\n    \n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// by @paulofalcao\n//\n// Fun with some feedbacks :)\n\nvec3 subImg(in vec2 fragCoord, float xs,float ys, float zs){\n    vec2 xy=fragCoord.xy/iResolution.xy;\n    xy-=0.5;\n    xy+=vec2(sin(iTime*xs)*0.1,cos(iTime*ys)*0.1);//move\n    xy*=(1.1+sin(iTime*zs)*0.1);//scale\n    xy+=0.5;\n    return texture(iChannel0,xy).xyz;\n}\n\nvec3 drawCircle(in vec2 xy){\n    float l=length(xy);\n    return ( l>.233 || l<.184 ) ? vec3(0) : vec3(sin(l*128.0)*.5+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n  fragColor = (texture(iChannel0,uv)-texture(iChannel1,uv)/1.0);\n\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define MaxSteps 16\n#define MinimumDistance 0.0009\n#define normalDistance     0.0002\n\n#define Iterations 10\n#define PI 3.141592\n#define Scale 3.0\n#define FieldOfView 1.0\n#define Jitter 0.05\n#define FudgeFactor 0.7\n#define NonLinearPerspective 2.0+(01.10*sin(iTime*0.10))\n#define DebugNonlinearPerspective false\n\n#define Ambient 0.32184\n#define Diffuse 0.5\n#define LightDir vec3(1.0)\n#define LightColor vec3(1.0,1.0-(01.10*abs(sin(iTime*1.0))),0.858824-(01.10*(cos(iTime*1.0))))\n#define LightDir2 vec3(1.0,-1.0,1.0)\n#define LightColor2 vec3(0.0,0.333333,1.0)\n#define Offset vec3(0.92858+(0.01250*sin(iTime/01.50)),0.92858+(0.01250*cos(iTime/2.0)),0.32858)\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Two light sources. No specular \nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tvec3 lightDir = normalize(LightDir);\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\t\n\tvec3 lightDir2 = normalize(LightDir2);\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\t\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color);\n}\n\n\n// DE: Infinitely tiled Menger IFS.\n//\n// For more info on KIFS, see:\n// http://www.fractalforums.com/3d-fractal-generation/kaleidoscopic-%28escape-time-ifs%29/\nfloat DE(in vec3 z)\n{\n\t// enable this to debug the non-linear perspective\n\tif (DebugNonlinearPerspective) {\n\t\tz = fract(z);\n\t\tfloat d=length(z.xy-vec2(0.5));\n\t\td = min(d, length(z.xz-vec2(0.5)));\n\t\td = min(d, length(z.yz-vec2(0.5)));\n\t\treturn d-0.01;\n\t}\n\t// Folding 'tiling' of 3D space;\n\tz  = abs(1.0-mod(z,2.0));\n\n\tfloat d = 1000.0;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tz.xy = rotate(z.xy,4.0+sin(iTime/5.0)+2.0+cos( iTime/18.0));\t\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(Scale-1.0);\n\t\tif( z.z<-0.5*Offset.z*(Scale-01.0*(01.10*(cos(iTime*1.0)))))  z.z+=Offset.z*(Scale-01.00*(01.10*(sin(iTime*1.0))));\n\t\td = min(d, length(z) * pow(Scale, float(-n)-1.0));\n\t}\n\t\n\treturn d-0.01;\n}\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0);\n}\n\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i < MaxSteps; i++) {\n\t\t// Non-linear perspective applied here.\n\t\tdir.zy = rotate(dir2.zy,totalDistance*sin( iTime/10.0)*NonLinearPerspective+cos(iTime/2.0));\n\t\t\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\t// Try to smooth the count, to combat banding.\n\tfloat smoothStep =   float(steps) + distance/MinimumDistance;\n\tfloat ao = 0.951-smoothStep/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\t\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor = (color*Ambient+light)*ao;\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera position (eye), and camera target\n\tvec3 camPos = 0.5*iTime*vec3(1.0,0.0,0.0);\n\tvec3 target = camPos + vec3(1.0,0.0*cos(iTime),0.0*sin(0.94*iTime));\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tfragColor = rayMarch(camPos, rayDir, fragCoord );\n}\n\n\n\n\n", "buffer_c_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3DN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 156, 156, 269]]}
{"id": "tlVcDR", "name": "Underwater (Pool)", "author": "oneshade", "description": "Look around with the mouse.", "tags": ["voronoi", "refraction", "water", "caustic", "pool"], "likes": 12, "viewed": 259, "published": 3, "date": "1622088088", "time_retrieved": "2024-07-30T19:18:47.595933", "image_code": "struct Surface {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n    float dist;\n    bool iswater;\n};\n\nSurface opUnion(in Surface surf1, in Surface surf2) {\n    Surface surfUnion = surf1;\n    if (surf2.dist < surf1.dist) {\n        surfUnion = surf2;\n    }\n\n    return surfUnion;\n}\n\nSurface opInter(in Surface surf1, in Surface surf2) {\n    Surface surfInter = surf1;\n    if (surf2.dist > surf1.dist) {\n        surfInter = surf2;\n    }\n\n    return surfInter;\n}\n\nSurface opSub(in Surface surf1, in Surface surf2) {\n    return opInter(surf1, Surface(surf2.ambient, surf2.diffuse, surf2.specular, surf2.gloss, -surf2.dist, surf2.iswater));\n}\n\nmat2 Rotate(in float r) {\n    float c = cos(r), s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\n// I modified it to try avoiding some annoying symmetry hash13() appears to have on the xy plane.\nfloat noise(in vec3 p) {\n\tp = fract(p * 0.731 - p.x * 253.567);\n    p += dot(p + p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);                       // Left, Down, Back\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = noise(cell + 1.0);                 // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat fnoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat smin(in float a, in float b, in float s) {\n    float i = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0);\n    return mix(b, a, i) - s * i * (1.0 - i);\n}\n\nvec2 getCellPoint(in vec2 p) {\n    float rndx = Hash11(p.x + 1000.0) * 2.0, rndy = Hash11(p.y + 1000.0) * 2.0;\n    return 0.5 + 0.5 * vec2(sin(p.x * rndx + p.y * rndy + iTime * rndx), cos(p.y * rndx - p.x * rndy + 2.0 * iTime * rndy * rndx));\n}\n\nfloat voronoi(in vec2 uv) {\n    vec2 cellLocation = floor(uv);\n\n    float minDist = 1000000000.0;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCellLocation = cellLocation + vec2(i, j);\n            vec2 curCellPoint = curCellLocation + getCellPoint(curCellLocation);\n            minDist = smin(minDist, length(uv - curCellPoint), 0.1);\n        }\n    }\n\n    return minDist;\n}\n\nfloat fakeCaustic(in vec2 uv) {\n    float color = voronoi(uv);\n    color *= color * color;\n    return color;\n}\n\nSurface mapScene(in vec3 p) {\n    p.z -= iTime;\n\n    Surface sphere = Surface(vec3(0.0), vec3(1.0, vec2(0.0)), vec3(1.0), 8.0, 1000000.0, false);\n\n    float waterDisp = fnoise(vec3(p.xz, 0.25 * iTime), 1.0, 3.0);\n    Surface water = Surface(vec3(0.0), vec3(0.0), vec3(1.0), 128.0, waterDisp - p.y, true);\n\n    vec3 groundCol = vec3(1.0);\n    groundCol -= smoothstep(0.02, 0.0, abs(mod(p.x, 1.0) - 0.5) - 0.025) * 0.5;\n    groundCol -= smoothstep(0.02, 0.0, abs(mod(p.z, 1.0) - 0.5) - 0.025) * 0.5;\n    groundCol += fakeCaustic(p.xz * 0.75);\n    Surface ground = Surface(groundCol, vec3(0.0), vec3(0.0), 0.0, p.y + 4.0, false);\n\n    return opUnion(sphere, opUnion(water, ground));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvec3 applyFog(in vec3 color, in float dist) {\n    return mix(color, vec3(0.25, 0.25, 1.0), 1.0 - exp(-dist * 0.15)) / max(1.0, 0.125 * dist);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd) {\n    if (rd.y > 0.1) {\n        vec2 uv = ro.xz + (5.0 - ro.y) / rd.y * rd.xz;\n        float clouds = fnoise(vec3(uv, 0.0) + iTime, 0.3, 5.0);\n        return mix(vec3(0.5, 0.5, 1.0), vec3(1.0), clouds * clouds * 1.5);\n    }\n\n    return vec3(0.25, 0.25, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    mouse.y *= -1.0;\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, -2.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Mouse control\n    float cx = cos(mouse.y), sx = sin(mouse.y);\n    rd.yz *= mat2(cx, sx, -sx, cx);\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    bool hitSky = true, hitWater = false, missed = false;\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t; p.z *= 1.0;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001 * (t * 5.0 + 1.0)) {\n            vec3 n = getNormal(p);\n            vec3 l = normalize(vec3(-1.0, 1.0, 1.0));\n            vec3 r = reflect(l, n);\n\n            if (!scene.iswater) {\n                fragColor.rgb = scene.ambient;\n                float lambert = max(0.0, dot(n, l));\n                fragColor.rgb += scene.diffuse * lambert;\n                if (lambert > 0.0) {\n                    fragColor.rgb += scene.specular * min(1.0, pow(max(0.0, dot(r, rd)), scene.gloss));\n                }\n\n                fragColor.rgb = applyFog(fragColor.rgb, t);\n\n                hitSky = false;\n                break;\n            }\n\n            if (scene.iswater) {\n                fragColor.rgb = scene.ambient;\n                if (dot(-n, l) > 0.0) {\n                    fragColor.rgb += scene.specular * min(1.0, pow(max(0.0, dot(-r, rd)), scene.gloss));\n                }\n\n                rd = refract(rd, n, 1.003 / 1.333);\n                hitWater = true;\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            fragColor.rgb = vec3(0.0);\n            missed = true;\n            break;\n        }\n\n        t += scene.dist;\n    }\n\n    if (hitSky && !missed) {\n        fragColor.rgb += getSky(ro, rd);\n        if (hitWater) {\n            fragColor.rgb = applyFog(fragColor.rgb, t);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVcDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 180, 180, 304], [306, 306, 359, 359, 483], [485, 485, 536, 536, 661], [663, 663, 688, 688, 754], [756, 944, 968, 968, 1082], [1084, 1084, 1109, 1109, 2033], [2035, 2035, 2094, 2094, 2380], [2382, 2382, 2408, 2408, 2494], [2496, 2496, 2544, 2544, 2647], [2649, 2649, 2679, 2679, 2893], [2895, 2895, 2922, 2922, 3313], [3315, 3315, 3346, 3346, 3425], [3427, 3427, 3456, 3456, 4108], [4110, 4110, 4137, 4137, 4413], [4415, 4415, 4460, 4460, 4558], [4560, 4560, 4597, 4597, 4856], [4858, 4858, 4913, 4913, 6966]]}
{"id": "7lf3D4", "name": "Your Grandmother's Other Quilt", "author": "stseagle", "description": "A happy accident while trying to achieve another effect", "tags": ["2d", "grid", "geometry"], "likes": 3, "viewed": 245, "published": 3, "date": "1622084695", "time_retrieved": "2024-07-30T19:18:48.408760", "image_code": "vec2 diamonds (vec2 st) {\n    vec2 r = vec2(0.0);\n    r.x = st.x;\n    r.y = abs(0.5-fract(st.x))+st.y*sign(fract(st.y)-0.5);\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y);\n    \n    uv *= 5.;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    uv = diamonds(uv);\n    vec2 pos = floor(uv);\n\n\n    // honeycomb the 2D grid\n    col.r = 0.8*mod(pos.x+pos.y,1.6+0.5*sin(0.2432*iTime));\n    col.g = 0.2*mod(pos.y,2.5+0.7*sin(0.1124*iTime));\n    col.b = 0.3333*mod(pos.x+pos.y,3.2+0.8*sin(0.0845*iTime));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lf3D4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 145], [147, 147, 204, 254, 710]]}
{"id": "slfGD4", "name": "v1-  Bezier-Fake girl", "author": "jorge2017a1", "description": "False girl ... a woman from behind ... I got from a tiktok video ..... but it is necessary to add hands, feet ... etc", "tags": ["2d", "bezier", "draw"], "likes": 5, "viewed": 863, "published": 3, "date": "1622076895", "time_retrieved": "2024-07-30T19:18:49.649443", "image_code": "//-----Modificado por\n//------jorge2017a1\n//descripcion:\n//False girl ... a woman from behind ... I got from a tiktok video .....\n//but it is necessary to add hands, feet ... etc\n\n//Referencia----------\n//https://www.shadertoy.com/view/XdBXDt    ..... de Casteljau\n//Created by vgs in 2014-11-25\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.55),b,d)\n#define Sv(d,b,v) smoothstep(antialiasing(v),b,d)\n\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 colBlanco= vec3(1.0);\nconst vec3 colRojo= vec3(1.0,0.0,0.0);\nconst vec3 colVerde= vec3(0.0,1.0,0.0);\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\n\nstruct Bezier {\n    vec2 a, b, c, d;\n};\n\n// splits a bezier B (t = 0.5) into beziers L and R.\nvoid decasteljau(in Bezier B, out Bezier L, out Bezier R) {\n\tL.a = B.a;          R.d = B.d;\n    L.b = .5*(B.a+B.b); R.c = .5*(B.c+B.d); \n    vec2 tmp = .5*(B.b+B.c);\n    L.c = .5*(L.b+tmp); R.b = .5*(R.c+tmp);\n    L.d = R.a = .5*(L.c+R.b);\n}\n\n// distance to the control points.\nfloat distCP(vec2 p, Bezier B) {\n    return min(min(length(p - B.a), length(p - B.b)),\n               min(length(p - B.c), length(p - B.d)));\n}\n\n// distance to a line segment.\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 ap = p - a, ab = b - a;\n    float k = clamp(dot(ap, ab)/dot(ab,ab), 0.0, 1.0);\n    return length(ap - k*ab);\n}\n\n// distance to the linear approximation.\nfloat distLinear(vec2 p, Bezier B) {\n    return min(min(segment(p, B.a, B.b), segment(p, B.b, B.c)), segment(p, B.c, B.d));\n}\n\n\n\nfloat HacerFiguraBezier(vec2  uv, vec2 PA,\tvec2 PB ,vec2 PC ,vec2 PD )\n{\n\nBezier bezier[16]; \n    bezier[0] = Bezier(PA, PB, PC, PD);\n    float dCP  = distCP(uv, bezier[0]);\n    float dLCP = distLinear(uv, bezier[0]);\n    \n    \n    // just an unrolled recursion, yey! :D\n    decasteljau(bezier[0], bezier[0], bezier[8]); \n    decasteljau(bezier[0], bezier[0], bezier[4]);\n    /*\n    decasteljau(bezier[8], bezier[8], bezier[12]);   decasteljau(bezier[0], bezier[0], bezier[2]);\n    decasteljau(bezier[4], bezier[4], bezier[6]);    decasteljau(bezier[8], bezier[8], bezier[10]);\n    decasteljau(bezier[12], bezier[12], bezier[14]); decasteljau(bezier[0], bezier[0], bezier[1]);\n    decasteljau(bezier[2], bezier[2], bezier[3]);    decasteljau(bezier[4], bezier[4], bezier[5]);\n    decasteljau(bezier[6], bezier[6], bezier[7]);    decasteljau(bezier[8], bezier[8], bezier[9]);\n    decasteljau(bezier[10], bezier[10], bezier[11]); decasteljau(bezier[12], bezier[12], bezier[13]);\n    decasteljau(bezier[14], bezier[14], bezier[15]);\n    */\n    \n    \tfloat dLA = 100.0;\n    for (int i = 0; i < 16; ++i)\n        dLA = min(dLA, distLinear(uv, bezier[i]));\n    \n   \n    return  dLA;\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    /*vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;    */\n    uv*=0.65;\n    uv-=vec2(-0.3,-0.3);\n    \n    // Control points .\n\nvec2 pc1p1=vec2(.177,.718);\nvec2 pc1p2=vec2(.172,.832);\nvec2 pc1p3=vec2(.214,.911);\nvec2 pc1p4=vec2(.236,.932);\n\nvec2 pc2p1=vec2(.236,.932);\nvec2 pc2p2=vec2(.260,.949);\nvec2 pc2p3=vec2(.304,.953);\nvec2 pc2p4=vec2(.327,.919);\n\nvec2 pc3p1=vec2(.326,.921);\nvec2 pc3p2=vec2(.373,.843);\nvec2 pc3p3=vec2(.402,.777);\nvec2 pc3p4=vec2(.443,.690);\n\nvec2 pc4p1=vec2(.440,.692);\nvec2 pc4p2=vec2(.458,.648);\nvec2 pc4p3=vec2(.461,.595);\nvec2 pc4p4=vec2(.438,.559);\n\nvec2 pc5p1=vec2(.245,.511);\nvec2 pc5p2=vec2(.339,.531);\nvec2 pc5p3=vec2(.388,.542);\nvec2 pc5p4=vec2(.438,.558);\n\nvec2 pc6p1=vec2(.175,.723);\nvec2 pc6p2=vec2(.186,.634);\nvec2 pc6p3=vec2(.208,.559);\nvec2 pc6p4=vec2(.244,.510);\n\nvec2 pc7p1=vec2(.178,.732);\nvec2 pc7p2=vec2(.246,.751);\nvec2 pc7p3=vec2(.354,.755);\nvec2 pc7p4=vec2(.425,.733);\n\nvec2 pc8p1=vec2(.174,.732);\nvec2 pc8p2=vec2(.225,.515);\nvec2 pc8p3=vec2(.242,.441);\nvec2 pc8p4=vec2(.224,.374);\n\nvec2 pc9p1=vec2(.426,.732);\nvec2 pc9p2=vec2(.484,.532);\nvec2 pc9p3=vec2(.395,.460);\nvec2 pc9p4=vec2(.440,.381);\n\nvec2 pc10p1=vec2(.224,.375);\nvec2 pc10p2=vec2(.290,.375);\nvec2 pc10p3=vec2(.348,.376);\nvec2 pc10p4=vec2(.440,.380);\n\nvec2 pc11p1=vec2(.221,.374);\nvec2 pc11p2=vec2(.178,.236);\nvec2 pc11p3=vec2(.141,.090);\nvec2 pc11p4=vec2(.171,.006);\n\nvec2 pc12p1=vec2(.173,.006);\nvec2 pc12p2=vec2(.232,.007);\nvec2 pc12p3=vec2(.291,.006);\nvec2 pc12p4=vec2(.330,.008);\n\nvec2 pc13p1=vec2(.332,.010);\nvec2 pc13p2=vec2(.313,.101);\nvec2 pc13p3=vec2(.378,.135);\nvec2 pc13p4=vec2(.327,.208);\n\nvec2 pc14p1=vec2(.348,.106);\nvec2 pc14p2=vec2(.351,.015);\nvec2 pc14p3=vec2(.349,.035);\nvec2 pc14p4=vec2(.350,.005);\n\nvec2 pc15p1=vec2(.358,.004);\nvec2 pc15p2=vec2(.411,.004);\nvec2 pc15p3=vec2(.461,.004);\nvec2 pc15p4=vec2(.509,.009);\n\nvec2 pc16p1=vec2(.380,.220);\nvec2 pc16p2=vec2(.334,.149);\nvec2 pc16p3=vec2(.339,.058);\nvec2 pc16p4=vec2(.443,.046);\n\nvec2 pc17p1=vec2(.440,.382);\nvec2 pc17p2=vec2(.487,.283);\nvec2 pc17p3=vec2(.544,.139);\nvec2 pc17p4=vec2(.513,.004);\nvec3  col=vec3(0.0);\n\n\nfloat d1= HacerFiguraBezier(uv,pc1p1,pc1p2,pc1p3,pc1p4);\nfloat d2= HacerFiguraBezier(uv,pc2p1,pc2p2,pc2p3,pc2p4);\nfloat d3= HacerFiguraBezier(uv,pc3p1,pc3p2,pc3p3,pc3p4);\nfloat d4= HacerFiguraBezier(uv,pc4p1,pc4p2,pc4p3,pc4p4);\nfloat d5= HacerFiguraBezier(uv,pc5p1,pc5p2,pc5p3,pc5p4);\nfloat d6= HacerFiguraBezier(uv,pc6p1,pc6p2,pc6p3,pc6p4);\nfloat d7= HacerFiguraBezier(uv,pc7p1,pc7p2,pc7p3,pc7p4);\nfloat d8= HacerFiguraBezier(uv,pc8p1,pc8p2,pc8p3,pc8p4);\nfloat d9= HacerFiguraBezier(uv,pc9p1,pc9p2,pc9p3,pc9p4);\nfloat d10= HacerFiguraBezier(uv,pc10p1,pc10p2,pc10p3,pc10p4);\nfloat d11= HacerFiguraBezier(uv,pc11p1,pc11p2,pc11p3,pc11p4);\nfloat d12= HacerFiguraBezier(uv,pc12p1,pc12p2,pc12p3,pc12p4);\nfloat d13= HacerFiguraBezier(uv,pc13p1,pc13p2,pc13p3,pc13p4);\nfloat d14= HacerFiguraBezier(uv,pc14p1,pc14p2,pc14p3,pc14p4);\nfloat d15= HacerFiguraBezier(uv,pc15p1,pc15p2,pc15p3,pc15p4);\nfloat d16= HacerFiguraBezier(uv,pc16p1,pc16p2,pc16p3,pc16p4);\nfloat d17= HacerFiguraBezier(uv,pc17p1,pc17p2,pc17p3,pc17p4);\n\ncol=ponerBorde(colBlanco,col,d1);\ncol=ponerBorde(colBlanco,col,d2);\ncol=ponerBorde(colBlanco,col,d3);\ncol=ponerBorde(colBlanco,col,d4);\ncol=ponerBorde(colBlanco,col,d5);\ncol=ponerBorde(colBlanco,col,d6);\ncol=ponerBorde(colRojo,col,d7);\ncol=ponerBorde(colRojo,col,d8);\ncol=ponerBorde(colRojo,col,d9);\ncol=ponerBorde(colVerde,col,d10);\ncol=ponerBorde(colVerde,col,d11);\ncol=ponerBorde(colVerde,col,d12);\ncol=ponerBorde(colVerde,col,d13);\ncol=ponerBorde(colVerde,col,d14);\ncol=ponerBorde(colVerde,col,d15);\ncol=ponerBorde(colVerde,col,d16);\ncol=ponerBorde(colVerde,col,d17);\n\n  \n\tfragColor = vec4(pow(col, vec3(1.0/6.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfGD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[653, 653, 713, 713, 837], [841, 885, 932, 932, 959], [961, 961, 1004, 1004, 1031], [1033, 1033, 1081, 1081, 1109], [1199, 1252, 1311, 1311, 1493], [1495, 1530, 1562, 1562, 1673], [1675, 1706, 1745, 1745, 1865], [1867, 1908, 1944, 1944, 2033], [2037, 2037, 2109, 2109, 3214], [3220, 3220, 3277, 3277, 7129]]}
{"id": "sll3WH", "name": "First Shader Fun", "author": "MrNissenDK", "description": "Just me playing around with Shadertoy", "tags": ["fun", "shader"], "likes": 3, "viewed": 291, "published": 3, "date": "1622065647", "time_retrieved": "2024-07-30T19:18:50.500168", "image_code": "float res = 7.;\nint seed = 50152;\nfloat pixel = 0.;\n\nint mod2(int v, int m)\n{\n    return int(mod(float(v), float(m)));\n}\nfloat GetDigitOfPi(int i)\n{\n    float[] randomDigitsPi = float[](\n        3799.6274,9567.3518,8575.2724,\n        8912.2793,8183.0119,4912.9833,\n        6733.6244,0656.6430,8602.1394,\n        9463.9522,4737.1907,0217.9860,\n        9437.0277,0539.2171,6939.9375\n    );\n    return randomDigitsPi[abs(mod2(randomDigitsPi.length() + i, randomDigitsPi.length()))];\n}\nfloat GetDigitOfPi(float i)\n{\n    return GetDigitOfPi(int(i));\n}\n\nvec3 Hash32(vec2 src)\n{\n    src = mod(src,50.);\n    float x = floor(src.x);\n    float y = floor(src.y);\n    {\n        float _x = x;\n        float _y = y;\n        x *= _x;\n        y *= _y;\n        \n        y += _x;\n        x += _y;\n    }\n    float rand1 = GetDigitOfPi(y * GetDigitOfPi(seed + 2) + GetDigitOfPi(seed + 4));\n    float rand2 = GetDigitOfPi(x * GetDigitOfPi(seed + 3) + GetDigitOfPi(seed + 5));\n    \n    vec3 hash = vec3(fract(floor(src) * vec2(rand1,rand2)),0);\n    hash += dot(hash, hash+GetDigitOfPi(seed + 6));\n    \n    hash.z = length(hash)+rand1+rand2;\n    \n    return fract(hash);\n}\n\nfloat cirkle(vec2 uv)\n{\n    float dist = length(uv);\n    float m = smoothstep(.2, .05, dist);\n    \n    return m;\n}\n\nfloat Pixels(int n, bool left)\n{\n    if(left)\n        return pixel*float(n) -.5;\n    return .5 - pixel*float(n);\n}\nfloat Pixels(int n)\n{\n    return Pixels(n,false);\n}\nfloat Pixel(bool left){\n    return Pixels(1,left);\n}\nfloat Pixel(){\n    return Pixels(1,false);\n}\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n//      clamp(v,0.,1.)\n#endif\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y) * res;\n    pixel = iResolution.x / iResolution.y * res / iResolution.x;\n    \n    uv += vec2(iTime,sin(iTime));\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec3 col = vec3(0);\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 offset = vec2(x,y);\n            vec3 pos = Hash32(id + offset) -.5;\n            vec3 addCol = hsv2rgb(vec3(pos.z, 1 ,cirkle(gv + pos.xy - offset)));\n            col += addCol;\n        }\n    }\n    \n    /*if(\n        gv.x >= Pixel() || gv.x <= Pixel(true) || \n        gv.y >= Pixel() || gv.y <= Pixel(true)   ) col.r = 1.;\n    */\n    fragColor = vec4(col,1);\n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 77, 77, 120], [482, 482, 511, 511, 546], [548, 548, 571, 571, 1149], [1151, 1151, 1174, 1174, 1265], [1267, 1267, 1299, 1299, 1381], [1382, 1382, 1403, 1403, 1433], [1434, 1434, 1457, 1457, 1486], [1487, 1487, 1501, 1501, 1531], [1614, 1614, 1635, 1635, 1741], [1743, 1743, 1800, 1800, 2526]]}
{"id": "ftX3DN", "name": "Green Screen and Color Matching", "author": "milesWaugh", "description": "Just an attempt at green-screening this guy, haha", "tags": ["greenscreen"], "likes": 4, "viewed": 298, "published": 3, "date": "1622063117", "time_retrieved": "2024-07-30T19:18:51.345907", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    float sl = uv.y*.25-uv.x + iTime*.1;\n    float slc = 1./6.;\n    float sl2 = fract(sl*5.);\n    sl = fract(sl);\n    vec3 g = vec3(0.15,0.63,0.2);\n    vec3 col = textureLod(iChannel0,uv,0.).rgb;\n    float a = 1.-dot(col-g,col-g)*5.;\n    a = smoothstep(0.,1.,clamp(a,0.,1.));\n    if(sl>slc){\n        col = mix(col,vec3(0.),a);\n    }\n    if(sl>slc&&sl<1.75*slc){\n        col = vec3(a);\n    }\n    if(abs(sl-slc)<0.02){\n        col = g;\n    }\n    float a2 = (((col.r+col.b)*.5-col.g)+0.15)*5.;\n    vec3 gr = vec3(col.r+col.g+col.b)/3.;\n    a2 = smoothstep(0.,1.,a2);\n    gr *= vec3(1.,0.85,0.55);\n    if(sl>3.75*slc){\n        col = mix(gr,col,a2)*pow(clamp(a2+.05,0.,1.),0.1);\n    }\n    if(sl>3.*slc&&sl<3.75*slc){\n        col = vec3((((col.r+col.b)*.5-col.g)+0.15)*5.);\n    }\n    col*=smoothstep(0.,1.,abs(fract(sl-0.5)-slc*0.05-0.5)*150.-1.);\n    float xt = fract(uv.x-iTime*.1);\n    if(abs(xt-0.14)<0.008 && abs(uv.y-0.88)<0.08){\n        col = vec3(1.,.6,.8);\n    }\n    if((abs(fract(xt+0.008))-0.008<0.008||abs(xt-0.97)<0.008) && abs(uv.y-0.88)<0.08){\n        col = vec3(0.1,0.2,0.5);\n    }\n    if((abs(xt-0.86)<0.008||abs(xt-0.82)<0.008||abs(xt-0.78)<0.008) && abs(uv.y-0.88)<0.08){\n        col = vec3(1.,.75,.4);\n    }\n    if(abs((-abs(xt-0.685)+(uv.y+0.01)*.2)-0.17)<0.008&&uv.y<.96||abs(xt-0.64)<0.008 && abs(uv.y-0.88)<0.08){\n        col = vec3(.1,.5,.5);\n    }\n    if(abs((-abs(xt-0.4)+(uv.y+0.01)*.2)-0.17)<0.008&&uv.y<.96){\n        col = vec3(0.7,1.,.7);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftX3DN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 1599]]}
{"id": "NtXGDN", "name": "Swirled Series C010011012", "author": "cmarangu", "description": "@C010011012 / chase marangu 's submission to @cs_kaplan's https://isohedral.ca/swirled-series/", "tags": ["voxel", "penrose", "swirledseries"], "likes": 13, "viewed": 389, "published": 3, "date": "1622060275", "time_retrieved": "2024-07-30T19:18:52.384637", "image_code": "\n\n// Current code for: Swirled Series C010011012\n// Date: Made around 2020 November 22nd\n// Tags: swirledseries, penrose, voxel\n// Description: @C010011012 / chase marangu 's submission to @cs_kaplan's https://isohedral.ca/swirled-series/\n\n\n// ↓ i know more\n#define PI 3.14159265358979323846264338327950288419716939937510582\n#define TAU 6.28318530718\n\n#define arg mod(float(iFrame)/60./3., 1.)\n\n#define cam_maus 0\n#define cam_psp 0\n\n#define rrg min(2.*min(2.*arg, 2.-2.*arg), 1.)\n//#define R mix(.05, .5, min(2.*arg, 2.-2.*arg))\n#define R mix(.01, .1, rrg)\n//#define R 0.\n\n//\n//#define sund normalize(vec3(1., .2, -.2))\n#define sund normalize(vec3(1., .0, -.0))\n//vec3 sky_map (vec3 d) {\n    //return vec3(0.);\n    //return vec3(.0, .0, 100./255.);\n    //return vec3(0., 1., 0.);\n    //return texture(iChannel2, d).rgb;\n//}\n\n#define inter_sky vec4(vec3(0.), 1e9)\n\n\n//\n//#define SDF(p) (length(p-vec3(.5) )-.49)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.4), 0.) )-.02)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.3), 0.) )-.18)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.465), 0.) )-.02)\n#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.5-R-.002), 0.) )-R)\n// try mini n=(1, 0, 0) cylinder\n//#define SDF(p) ( length((p).yz-.5)-.49 )\n//#define SDF(p) ( length((p).xy-.5)-.49 )\n\nvec4 inter_SDF (vec3 p, vec3 d) {\n    //\n    vec3 camp = p;\n    float SDFp;\n    for (int i=0; i<6020; ++i) {\n        SDFp = SDF(p);\n        if (SDFp > 1.8) { // sqrt(3)\n        //if (SDFp > .18) {\n        //if (SDFp > 20.) {\n            break;\n        }\n        else if (abs(SDFp) < 3e-5) {\n            return vec4(\n                normalize(-SDFp+vec3(\n                    SDF(p+vec3(1e-3, 0., 0.)),\n                    SDF(p+vec3(0., 1e-3, 0.)),\n                    SDF(p+vec3(0., 0., 1e-3))\n                )),\n                length(p-camp)\n            );\n            #undef inf\n        }\n        p += d*abs(SDFp)*.99;\n    }\n    return inter_sky;\n}\n\n#define SDF_plane(p, c, n) ( dot(normalize(p-c), n)*length(p-c) )\n#define inter_plane_short(p, d, c, n) (\\\n    dot(-n, d) > 1e-6 ? vec4(n, dot(c-p, -n)/dot(-n, d)) : inter_sky\\\n)\n#define inter_plane_dist(p, d, c, n) (\\\n    dot(-n, d) > 1e-6 ? dot(c-p, -n)/dot(-n, d) : inter_sky\\\n)\nvec4 inter_plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n    vec4 inter_plane1;\n    inter_plane1 = inter_plane_short(p, d, c, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, c, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n\n\n\nvec4 inter_minecraft (vec3 p, vec3 d) {\n    // return inter_SDF(fract(p), d);\n    float dist; vec4 inter_current; bool blockhere;\n    vec3 camp = p, qm, qf;\n    int missedsdf = 0;\n    // space skipping\n    vec3 pane1c = vec3(0., 6., 0.);\n    vec3 pane1n = normalize(vec3(0., 1., 0.));\n    pane1n = normalize(vec3(1.));\n    #if 1\n    if (SDF_plane(p, pane1c, pane1n) > 0.) {\n        inter_current = inter_plane(p, d, pane1c, pane1n);\n        if (inter_current.w >= inter_sky.w) {\n            // never hit bounding cube\n            return inter_sky;\n        }\n        else {\n            //\n            p += d*inter_current.w;\n            p += d*1e-3;\n        }\n    }\n    #else\n    inter_current = inter_rectprism(p_m_bouc, d, bouwhl);\n    return inter_current;\n    #endif\n    for (int voxjumps=0; voxjumps<140; ++voxjumps) {\n        //\n        if (SDF_plane(p, pane1c, pane1n) > .2) {\n            return inter_sky;\n        }\n        //\n        qf = floor(p);\n        qm = fract(p);\n        //\n        //\n        //\n        blockhere = true;\n        //\n        //\n        //blockhere = qf.y <= 0. && blockhere;\n        //blockhere = qf.x+qf.y+qf.z <= 0.;\n        blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) <= 0.;\n        //blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) >= -0. && blockhere;\n        //\n        //\n        //\n        if (blockhere) {\n            //\n            inter_current = inter_SDF(qm, d);\n            //\n            //\n            inter_current.w += length(p-camp);\n            vec3 wasp = p;\n            p = camp+d*inter_current.w;\n            if (inter_current.w < inter_sky.w) {\n                return inter_current;\n            }\n            p = wasp;\n            ++missedsdf;\n            if (missedsdf >= 4) {\n                return inter_sky;\n            }\n        }\n        //\n        //\n        dist = inter_sky.w;\n        // macro method\n        #if 0\n    //#define inter_plane_dist(p, d, c, n) (dot(n, d)>1e-6?dot(c-p, n)/dot(n, d):inter_sky.w)\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(-1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., -1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., 0., -1.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(1., 0., 0.), vec3(1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 1., 0.), vec3(0., 1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 0., 1.), vec3(0., 0., 1.)) );\n        #else\n        // optimized method\n        dist = min(dist, qm.x/-d.x+ max(d.x +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.y/-d.y+ max(d.y +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.z/-d.z+ max(d.z +1e-6, 0.)*1e20 );\n        //\n      dist = min(dist,dot(vec3(1., 0., 0.)-qm, vec3(1., 0., 0.))/d.x+max(-d.x +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 1., 0.)-qm, vec3(0., 1., 0.))/d.y+max(-d.y +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 0., 1.)-qm, vec3(0., 0., 1.))/d.z+max(-d.z +1e-6, 0.)*1e20);\n        //\n        #endif\n        //\n        p += d*dist; p += d*2e-3;\n    }\n    //\n    return inter_sky;\n}\n\nvec3 sky_map2 (vec3 p, vec3 d) {\n    return vec3(0.4);\n    vec4 inter_current, inter_closest;\n    inter_closest = inter_sky;\n    inter_current = inter_plane(p, d, vec3(0., 30., 0.), normalize(vec3(-1.)) );\n    p += d*inter_current.w;\n    //return texture(iChannel1, p.xz*40.).rgb;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    //\n    //\n    vec3 randy; vec2 screen, maus; float samplei2, samplei, ox, oy;\n    //\n    vec3 retina; vec4 inter_current, inter_closest; float shiny; vec3 TEXp;\n    vec3 camp, camd, p, d; mat2 azimuth, zenith; float th, ph;\n    //\n    if (abs( (fragCoord.x-iResolution.x/2.)/(iResolution.y/2.)) > 1.) {\n        //fragColor = vec4(0., 1., 1., 1.);\n        //return;\n    }\n    //\n    th = 0.;\n    ph = 0.;\n    #if cam_maus\n    //#if 0\n    maus = (iMouse.xy-iResolution.xy/2.)/iResolution.y*2.;\n    th += maus.x*PI;\n    ph += maus.y*PI;\n    #endif\n    //\n    //\n    ph -= PI*.5-.001;\n    th += PI;\n    //ph += (.5+.5*sin(arg*PI) )*PI*.5;\n    //ph += arg*TAU;\n    ph += arg*PI*.5;\n    th += arg*PI*.5;\n    //\n    //\n    azimuth = mat2(\n        cos(th), cos(PI*.5+th),\n        sin(th), sin(PI*.5+th)\n    );\n    zenith = mat2(\n        cos(ph), cos(PI*.5+ph),\n        sin(ph), sin(PI*.5+ph)\n    );\n    //\n    #define spp 1.\n    #define spw 1.\n    fragColor.xyz = vec3(0.);\n    //\n    for (samplei2=0.; samplei2<spp*spw*spw; ++samplei2) {\n        ox = mod(samplei2, spw);\n        oy = mod(samplei2/spw, spw);\n        samplei = mod(samplei2/spw/spw, spp);\n        #if 1\n        randy = vec3(\n            fract(sin(\n                mod(\n                    samplei*21.463049023049+\n                    (float(iFrame)+fragCoord.x)*0.021415,\n                    TAU\n                )+fragCoord.y*52.2324352432\n            )),\n            fract(sin(\n                mod(\n                    samplei*421.83743204984+\n                    (float(iFrame)+fragCoord.x)*8.234203,\n                    TAU\n                )+fragCoord.y*123.242543465\n            )),\n            fract(sin(\n                mod(\n                    samplei*952.13454543556+\n                    float(iFrame)*8.234203,\n                    TAU\n                )+fragCoord.y*.003432443\n            ))\n        );\n        #undef samplei\n        #else\n        randy = vec3(0.);\n        #endif\n        //\n        screen = (fragCoord+randy.rg-iResolution.xy/2.)/iResolution.y*2.;\n        //\n        retina = vec3(0.);\n        shiny = 1.;\n        //\n        #if cam_psp\n        //#if 0\n        camp = vec3(0., 0., 0.)*.4;\n        camd = normalize(camp+vec3(screen.xy, 1.)-camp );\n        #else\n        camp = vec3(screen.xy, 0.)*4.;\n        camd = normalize(vec3(0., 0., 1.));\n        camp -= camd*4.;\n        #endif\n        //\n        camd.yz = zenith*camd.yz;\n        camp.yz = zenith*camp.yz;\n        camd.xz = azimuth*camd.xz;\n        camp.xz = azimuth*camp.xz;\n        //\n        camd = normalize(camd);\n        camp.y += 10.;\n        //\n        //\n        //\n        //\n        p = camp; d = camd;\n        int reflcount = 0;\n        //\n        for (int bounces=0; bounces<33; ++bounces) {\n        //for (int bounces=0; bounces<2; ++bounces) {\n            // only have 2 bounces anyways\n            if (shiny < .1) { break; }\n            inter_closest = inter_minecraft(p, d);\n            //\n            if (inter_closest.w >= inter_sky.w) {\n                // hits sky - no shading\n                break;\n            }\n            p += d*inter_closest.w;\n            //\n            //\n            if (true) {\n                // hits object\n                //TEXp = abs(inter_closest.xyz);\n                TEXp = vec3(1.);\n                //TEXp = mix(TEXp, .5+.5*inter_closest.xyz, rrg);\n                //TEXp = vec3(1.);\n                //\n                #if 1\n                TEXp *= mod(1.+floor(p.x-.01)+floor(p.y-.01)+\n                        floor(p.z-.01), 2.);\n                #endif\n                //TEXp = vec3(1.);\n                //#define shininess .29999993\n                //#define shininess .9999993\n                #define shininess mix(1., .7, rrg);\n                //\n                //#if 0\n                // failed shadows attempt\n                //vec3 temppT;\n                //vec4 inter_shado1 = inter_tribar(p+sund*1e-2, sund, temppT);\n                //if (inter_shado1.w < inter_sky.w) {\n                //    TEXp *= .5;\n                //}\n                //#endif\n                //\n                retina += TEXp*shiny*shininess;\n                shiny *= 1.-shininess;\n                #undef shininess\n                d = reflect(d, inter_closest.xyz);\n                ++reflcount;\n                if (reflcount >= 4) {\n                    break;\n                }\n                //break;\n            }\n            //p += d*1e-3;\n            p += d*9e-3;\n        }\n        if (shiny >= 1.) {\n            //retina = vec3(0., 0., 100./255.);\n            //shiny *= 0.;\n        }\n        //retina += shiny*sky_map(d);\n        retina += shiny*sky_map2(p, d);\n        fragColor.rgb += retina;\n    }\n    //\n    fragColor.rgb /= spp*spw*spw;\n    fragColor.rgb = vec3(fragColor.r+fragColor.g+fragColor.b)/3.;\n    fragColor.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXGDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2238, 2238, 2289, 2289, 2633], [2637, 2637, 2676, 2714, 5826], [5828, 5828, 5860, 5860, 6110]]}
{"id": "7tlGDr", "name": "Ellipse & Circle", "author": "mla", "description": "Drawing an ellipse as an affine transformation of a circle.\n\nMouse changes the transformation. 'x' to see untransformed configuration.", "tags": ["ellipse", "affine"], "likes": 9, "viewed": 343, "published": 3, "date": "1622052106", "time_retrieved": "2024-07-30T19:18:53.163555", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Drawing an ellipse as an affine transformation of a circle. mla, 2021\n//\n// Mouse changes transformation\n//\n// The inner ellipse is inscribed in the yellow triangle (and passes through\n// the midpoints of its sides, making it Steiner's inellipse) and the triangle\n// is inscribed in the outer ellipse, which is just double the inner. The\n// the sides of the blue parallelogram are also tangent at their midpoints and\n// the cross lines in the parallelogram are conjugate diameters of the ellipse.\n//\n// The whole configuration is just an affine transformation of a circle in a\n// square and an equilateral triangle.\n\n// 'x' to see untransformed configuration.\n// 'h' for extra hyperbolae\n// 'a' for a different regular transformation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat lwidth1 = 0.02;\nfloat lwidth2 = 0.04;\n\nvec3 doline(vec3 col, vec3 linecol, float d) {\n  return mix (linecol, col, mix(0.1,1.0,smoothstep(lwidth1,lwidth2,d)));\n}\n\nvec3 diagram(const vec2 p, const vec2 mouse) {\n  // Main transformation matrix\n  mat2 X = mat2(1,0,0.5,1);\n  // Set from mouse\n  if (iMouse.x > 0.0) X = mat2(0.5,mouse.y,mouse.x,0.5);\n  if (key(CHAR_X)) X = mat2(1,0,1e-5,1); // (Almost) untransformed\n  // Add an extra rotation - this leaves ellipse invariant\n  float t = 0.2*PI*iTime;\n  {\n    mat2 A = mat2(cos(t),sin(t),-sin(t),cos(t));\n    if (key(CHAR_A)) A = mat2(tan(t),0,0,1.0/tan(t));\n    X *= A;\n  }\n  mat2 Xinv = inverse(X);\n  \n  // Equilateral triangle\n  vec2 A = X*vec2(0,2);\n  vec2 B = X*vec2(-sqrt(3.0),-1);\n  vec2 C = X*vec2(+sqrt(3.0),-1);\n  // Midpoints of sides\n  vec2 AB = 0.5*(A+B);\n  vec2 BC = 0.5*(B+C);\n  vec2 CA = 0.5*(C+A);\n  // Square corners\n  vec2 F = X*vec2(1,1);\n  vec2 G = X*vec2(1,-1);\n\n  // Compute vertices & foci of ellipse\n  // See: https://en.wikipedia.org/wiki/Ellipse#General_ellipse_2\n  vec2 f1 = X*vec2(1,0);\n  vec2 f2 = X*vec2(0,1);\n  // Ellipse is p = cos(t)*f1 + sin(t)*f2\n  // Tangent at p = -sin(t)*f1 + cos(t)*f2\n  // So tangent is perpendicular to p when:\n  // (cos(t)*f1 + sin(t)*f2).(-sin(t)*f1 + cos(t)*f2) = 0\n  float t0 = 0.5*atan(2.0*dot(f1,f2)/(dot(f1,f1)-dot(f2,f2)));\n\n  // The four vertices are ±v0, ±v1\n  vec2 v0 = f1*cos(t0)+f2*sin(t0);\n  vec2 v1 = f1*cos(t0+0.5*PI)+f2*sin(t0+0.5*PI);\n\n  // Calculate focus from axes\n  float a2 = 0.25*dot(v0,v0);\n  float b2 = 0.25*dot(v1,v1);\n  float c2 = a2-b2;\n  // Which foci are real?\n  vec2 focus = c2 >= 0.0 ? v0*sqrt(c2/a2) : v1*sqrt(-c2/b2);\n\n  // Do the drawing\n  float var = 0.5+texture(iChannel0,0.25*p).y;\n  lwidth1 *= var;\n  lwidth2 *= var;\n  \n  vec3 col = vec3(1,1,0.8);\n  float d;\n\n  // Axes of ellipse\n  d = 1e8;\n  d = min(d,abs(segment(p,v0,-v0)));\n  d = min(d,abs(segment(p,v1,-v1)));\n  col = doline(col,RED,d);\n\n  d = 1e8;\n  d = min(d,abs(segment(p,A,B)));\n  d = min(d,abs(segment(p,B,C)));\n  d = min(d,abs(segment(p,C,A)));\n  //d = min(d,abs(segment(p,A,BC)));\n  //d = min(d,abs(segment(p,B,CA)));\n  //d = min(d,abs(segment(p,C,AB)));\n  col = doline(col,YELLOW,d);\n\n  // The square\n  d = 1e8;\n  d = min(d,abs(segment(p,F,G)));\n  d = min(d,abs(segment(p,F,-G)));\n  d = min(d,abs(segment(p,-F,G)));\n  d = min(d,abs(segment(p,-F,-G)));\n\n  //d = min(d,abs(segment(p,F,-F)));\n  //d = min(d,abs(segment(p,G,-G)));\n  d = min(d,abs(line(p,X*vec2(0,-1),X*vec2(0,1))));\n  d = min(d,abs(line(p,X*vec2(-1,0),X*vec2(1,0))));\n  col = doline(col,BLUE,d);\n\n  d = 1e8;\n  d = min(d,abs(segment(p,focus,BC)));\n  d = min(d,abs(segment(p,-focus,BC)));\n  col = doline(col,vec3(0.1),d);\n\n  // Implicit function is f(inverse(X)*p) where f is circle function\n  // Gradient is transpose(X)*f'(inverse(X)*p)\n  vec2 p1 = Xinv*p;\n  // Use circle implicit function, but use transpose transform to adjust gradient.\n  // Implicit function is x^2+y^2 = 1, so gradient is (2x,2y)\n  float d2 = dot(p1,p1);\n  d = abs(d2-1.0);\n  d = min(d,abs(d2-4.0)); // Circumellipse\n  vec2 grad = 2.0*p1;\n  grad *= Xinv; // Postmultiply for transpose\n  d /= length(grad);\n  col = doline(col,RED,d);\n  if (key(CHAR_H)) {\n    // Conjugate hyperbolae, tangent to ellipse.\n    d = min(abs(p1.x*p1.y-0.5),abs(-p1.x*p1.y-0.5));\n    d /= length(p1.yx*Xinv);\n    col = doline(col,GREEN,d);\n  }\n  \n  d = length(p);\n  d = min(d,distance(p,focus));\n  d = min(d,distance(p,-focus));\n#if 0\n  d = min(d,distance(p,v0));\n  d = min(d,distance(p,-v0));\n  d = min(d,distance(p,v1));\n  d = min(d,distance(p,-v1));\n#endif\n  d = min(d,distance(p,A));\n  d = min(d,distance(p,B));\n  d = min(d,distance(p,C));\n  //d = min(d,distance(p,AB));\n  //d = min(d,distance(p,BC));\n  //d = min(d,distance(p,CA));\n  d = min(d,distance(p,X*vec2(1,0)));\n  d = min(d,distance(p,X*vec2(-1,0)));\n  d = min(d,distance(p,X*vec2(0,1)));\n  d = min(d,distance(p,X*vec2(0,-1)));\n  col = mix(vec3(0), col, smoothstep(lwidth2,2.0*lwidth2,d));\n  col *= 0.5+0.5*texture(iChannel0,0.25*p).x;\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 2.0;\n  vec2 p = vec2(scale*(2.0*fragCoord-iResolution.xy)/iResolution.y);\n  p *= 1.05;\n  vec2 mouse = iMouse.x <= 0.0 ? vec2(0,0)\n    : vec2(scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n  vec3 col = diagram(p,mouse);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.1415927;\n\nvec3 colors[] =\n  vec3[](vec3(0.996078,0.152941,0.0705882),\n         vec3(0.988235,0.376471,0.0392157),\n         vec3(0.984314,0.6,0.00784314),\n         vec3(0.988235,0.8,0.101961),\n         vec3(0.996078,0.996078,0.2),\n         vec3(0.698039,0.843137,0.196078),\n         vec3(0.4,0.690196,0.196078),\n         vec3(0.203922,0.486275,0.596078),\n         vec3(0.00784314,0.278431,0.996078),\n         vec3(0.266667,0.141176,0.839216),\n         vec3(0.52549,0.00392157,0.686275),\n         vec3(0.760784,0.0784314,0.376471),\n         vec3(0.0705882,0.152941,0.996078));\n\n#define RED (colors[0])\n#define REDORANGE (colors[1])\n#define ORANGE (colors[2])\n#define YELLOWORANGE (colors[3])\n#define YELLOW (colors[4])\n#define YELLOWGREEN (colors[5])\n#define GREEN (colors[6])\n#define BLUEGREEN (colors[7])\n#define BLUE (colors[8])\n#define BLUEPURPLE (colors[9])\n#define PURPLE (colors[10])\n#define REDPURPLE (colors[10])\n\n#define DARK(c) (0.5*(c))\n#define LIGHT(c) (0.5+0.5*(c))\n\nconst int CHAR_A = 65;\nconst int CHAR_H = 72;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a;\n  b -= a;\n  float h = clamp(dot(p,b)/dot(b,b), 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  p -= a;\n  b -= a;\n  float h = dot(p,b)/dot(b,b);\n  return length(p-b*h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[951, 951, 997, 997, 1072], [1074, 1074, 1120, 1152, 4947], [4949, 4949, 5002, 5002, 5290]]}
{"id": "fls3zH", "name": "SDFSphere", "author": "nialred", "description": "Basic sphere using signed distance function. Added a box and a lot of distortion.", "tags": ["sdf", "sphere"], "likes": 4, "viewed": 493, "published": 3, "date": "1622048385", "time_retrieved": "2024-07-30T19:18:53.908562", "image_code": "/*\n\nReferences:\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttps://michaelwalczyk.com/blog-ray-marching.html\nhttps://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays\nhttps://www.shadertoy.com/view/4sdSDN\n\n*/\n\nconst int MAX_MARCHING_STEPS = 500; // Max steps you are willing to search for a \"hit\"\nconst float MAX_DIST = 1000.0; // Max distance to search for a \"hit\"\nconst float MIN_DIST = 0.0; // Where to start the march \nconst float EPSILON = 0.001; // How close you need to be to be considered a hit\n\nfloat wave = 0.0;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n    float radius; // fillet\n};\n\n// I don't know where I should define this cause I don't know how this scales\n// once you introduce multiple shapes and whatnot, so I just made it global\nSphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 25.0);\nBox box = Box(vec3(0.0, 0.0, 200.0), vec3(50.0, 100.0, 50.0), 60.0);\n\nvoid rotate_2d(float freq, inout vec2 p)\n{\n    float c = cos(freq);\n    float s = sin(freq);\n    p = vec2((p.x*c) - (p.y*s), (p.x*s) + (p.y*c));\n}\n\nfloat distort_surface(float freq, vec3 point)\n{\n    return sin(freq * point.x) * sin(freq * point.x) * sin(freq * point.y) * sin(freq * point.y)* sin(freq * point.y)* sin(freq * point.z)/ sin(freq * point.z)/ sin(freq * point.z);\n    //return sin(freq * point.x) * tan(freq * point.x) * cos(freq * point.x) * sin(freq * point.y) * sin(freq * point.y)* sin(freq * point.y)/ sin(freq * point.z)/ sin(freq * point.z)/ tan(2.0*freq * point.z);\n    //return sin(freq * point.x) / cos(freq * point.y) / sin(0.025*point.z);\n    //return sin(freq * point.x) * sin(freq * point.x);\n    //return 2.75*sin(freq * point.x) * sin(freq * point.y) * sin(freq * point.z);\n    //return point.x/point.z*point.y/point.x;\n    //return sin(freq*point.x/2.0) * sin(point.y/2.0) * sin(point.z/2.0);\n}\n\nvec3 ray_direction(float fieldOfView, vec2 uv) \n{ \n    float z = 1.0 / tan(radians(fieldOfView) / 2.0); // Distance to image plane\n    return normalize(vec3(uv, z));\n}\n\nfloat sphere_sdf(vec3 point)\n{\n    return length(point - sphere.center) - sphere.radius; // Return distance from sphere\n}\n\nfloat sd_box(vec3 point, Box box_obj, float is_rounded) // box and rounded box\n{\n    vec3 diff = abs(point-box_obj.center) - box_obj.size;\n    return length(max(diff, 0.0)) + \n           min(max(diff.x,max(diff.y,diff.z)),0.0) - // not sure\n           (box_obj.radius * is_rounded);\n}\n\nfloat map_world(vec3 point)\n{   \n    rotate_2d(iTime/15.0, point.xz);\n    float displacement = distort_surface(0.5, point);\n    float dist = sphere_sdf(point); // Distance from sphere \n    float box_dist = sd_box(point, box, 1.0);\n    return min(dist, box_dist) + displacement;\n}\n\nfloat shortest_distance_to_surface(vec3 eye_pos, vec3 march_dir, float start, float end)\n{\n    float depth = start; // Starting point for ray march (0.0)\n    float dist = 0.0;    // Initalize distance from sphere variable\n    int i = 0;           \n    \n    while (i < MAX_MARCHING_STEPS)\n    {\n        dist = map_world(eye_pos + (depth * march_dir)); // Distance to sphere (distorted)\n        \n        if (dist < EPSILON) // If at the surface, return the depth from image plane\n        {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= end) // If at the max marching distance, return the max value\n        {\n            return end;\n        }\n        \n        i += 1;\n     }\n     \n     return end;\n}\n\nvec3 estimate_normal(vec3 point)\n{   \n    vec3 step = vec3(EPSILON, 0.0, 0.0);\n    \n    float gradient_x = map_world(point + step) - map_world(point - step);\n    float gradient_y = map_world(point + step.yxz) - map_world(point - step.yxz);\n    float gradient_z = map_world(point + step.yzx) - map_world(point - step.yzx);\n    \n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    \n    return normalize(normal);\n}\n\nfloat diffuse(vec3 current_pos, vec3 light_pos, vec3 normal)\n{\n    vec3 light_dir = normalize(light_pos - current_pos);\n    float intensity = max(0.0, dot(normal, light_dir));\n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    wave = 2.0*texture(iChannel0, uv).x;\n    float aspect_ratio = iResolution.x/iResolution.y;\n    uv.x = uv.x * aspect_ratio; // Account for image aspect ratio\n\n    // Define camera position\n    vec3 cam_pos = vec3(0.0, 0.0, -75.0);\n     \n    // Define ray as vector from camera position to pixel position\n    Ray ray = Ray(cam_pos, ray_direction(45.0, uv));\n      \n    // Define light position as a 3D vector\n    vec3 light_pos = vec3(20.0, 50.0, -40.0);\n    \n    // Find distance to surface\n    float dist = shortest_distance_to_surface(ray.origin, ray.direction, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) // If sphere doesn't exist at this pixel draw bg\n    { \n        // Eventually want to have the background be a cubic room \n        fragColor = vec4(0.2, 0.2, 0.2, 0.0);\n    }\n    \n    else // If sphere does exist at this pixel, draw color accordingly using basic lighting\n    {\n        vec3 point = ray.origin + dist*ray.direction;\n        vec3 normal = estimate_normal(point);\n        float intensity = diffuse(point, light_pos, normal);\n        normal = vec3(0.85, 0.95, 0.95) * (intensity);\n        normal = normal + 0.25;\n        fragColor = vec4(normal, 1.0);\n    }\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1071, 1071, 1113, 1113, 1217], [1219, 1219, 1266, 1266, 1996], [1998, 1998, 2047, 2047, 2165], [2167, 2167, 2197, 2197, 2288], [2290, 2290, 2370, 2370, 2574], [2576, 2576, 2605, 2605, 2855], [2857, 2857, 2947, 2947, 3605], [3607, 3607, 3641, 3641, 4030], [4032, 4032, 4094, 4094, 4231], [4233, 4233, 4290, 4344, 5599]]}
{"id": "stlGDH", "name": "Colorful Mandelbulb", "author": "Zi7ar21", "description": "Just experimenting, check out https://www.shadertoy.com/view/fll3D8", "tags": ["raymarching", "fractal", "ray", "raymarch", "raymarched", "mandelbulb", "colorful", "color", "shadows", "raymarcher", "softshadows", "soft"], "likes": 6, "viewed": 323, "published": 3, "date": "1622041582", "time_retrieved": "2024-07-30T19:18:54.657559", "image_code": "// ####### Colorful Mandelbulb #######\n// Made by Zi7ar21 on May 26th, 2021\n// Last Updated: May 26th, 2021 at 11:35 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/stlGDH\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n\n// Inspired by \"Raymarched Mandelbulb\" by Dumb Psycho:\n// https://www.shadertoy.com/view/fll3D8\n\n// ##### PARAMETERS #####\n\n#define gamma   2.2\n#define camfov  1.0\n#define hitDist 1E-3\n#define maxDist 8.00\n#define maxStep 128\n\n#define iterations 6\n\n// ##### CONSTANTS #####\n\n// Traditional Input Names\n#define resolution iResolution\n#define time iTime\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// ##### RENDERING #####\n\n// Material Datatype\nstruct material {\n    vec3 albedo;\n    vec3 normal;\n};\n\n// Rotate a 3-Component Vector\nvec3 rotate(vec3 vec, vec3 rot)\n{\n    vec3 s = sin(rot), c = cos(rot);\n\n    mat3 rotx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n    mat3 roty = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n    mat3 rotz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    mat3 rotmat = rotx*roty*rotz;\n\n    /*\n    rotmat[0] = normalize(rotmat[0]);\n    rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n    */\n\n    return (vec.x*rotmat[0])+(vec.y*rotmat[1])+(vec.z*rotmat[2]);\n}\n\n// Scene Distance Estimator\nfloat DE(in vec3 pos, out vec3 orbitTrap)\n{\n    // Performance Increase\n    if(dot(pos, pos) > 8.0)\n    {\n        return length(pos)-1.3;\n    }\n\n    pos = rotate(pos, pi*vec3(time*0.125*0.125, time*0.125, 0.0));\n\n    //const float power = 8.0;\n    float power = (sin(0.125*0.5*pi*time)*2.0)+8.0;\n\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n\n    orbitTrap = vec3(1.0);\n\n    for(int i = 0; i < iterations; i++)\n    {\n        r = length(z);\n\n        if(r > 4.0)\n        {\n            break;\n        }\n\n        // Convert to Polar Coordinates\n        float theta = acos(z.z/r)*power;\n        float phi = atan(z.y, z.x)*power;\n        dr = pow(r, power-1.0)*power*dr+1.0;\n\n        // Scale and Rotate the Point\n        float zr = pow(r, power);\n\n        // Convert back to Cartesian Coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\n        // Compute Orbit Trap Color\n        orbitTrap = min(orbitTrap, abs(z));\n\n        z += pos;\n    }\n\n    // Return the Distance to the Fractal\n    return 0.5*log(r)*r/dr;\n}\n\n// Distance Estimator Tetrahedron Numerical Normals\nvec3 getNormal(vec3 pos)\n{\n    const vec2 k = vec2(-1.0, 1.0);\n\n    vec3 n;\n\n    return normalize(\n    k.xxx*DE(pos+k.xxx*hitDist, n)+\n    k.xyy*DE(pos+k.xyy*hitDist, n)+\n    k.yxy*DE(pos+k.yxy*hitDist, n)+\n    k.yyx*DE(pos+k.yyx*hitDist, n));\n}\n\n// Distance Estimator Ray-Marching\nfloat intersectDE(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    // Set-Up Variables\n    float t = 0.0;\n\n    for(int i = 0; i < maxStep; i++)\n    {\n        if(t > maxDist)\n        {\n            break;\n        }\n\n        float td = DE(ro+rd*t, materialProperties.albedo);\n\n        if(td < hitDist)\n        {\n            materialProperties.normal = getNormal(ro+rd*t);\n            return t;\n        }\n\n        t += td;\n    }\n\n    // No Intersection\n    return -1.0;\n}\n\n// Intersection Function\nfloat intersect(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    // Compute the Intersection\n    float t = intersectDE(ro, rd, materialProperties);\n\n    // Return the Intersection\n    return t;\n}\n\n// Distance Estimator Soft Shadows\nfloat softShadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    float ph = 1E4;\n    vec3 n;\n    for(int i = 0; i < maxStep; i++)\n    {\n        float h = DE(ro+rd*t, n);\n        float y = i == 0 ? 0.0 : h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n\n        res = min(res, 10.0*d/max(0.0, t-y));\n\n        t += h;\n\n        if(res < hitDist || t > maxDist){break;}\n    }\n\n    res = clamp(res, 0.0, 1.0);\n\n    return res*res*(3.0-2.0*res);\n}\n\n// Rendering\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    material materialProperties;\n\n    // Compute the Intersection\n    float t = intersect(ro, rd, materialProperties);\n\n    // If there was no Intersection\n    if(t < 0.0)\n    {\n        // Return Background Color\n        return (max(vec3(0.4, 0.8, 1.0)*dot(rd, vec3(0.0, 1.0, 0.0)), 0.0)*0.9)+0.1;\n    }\n\n    //vec3 lightPosition = vec3(sin(pi*time)*2.0, 4.0, (cos(pi*time)*2.0)-4.0);\n    const vec3 lightPosition = vec3(4.0, 4.0, -4.0);\n\n    // Direction of the Light\n    vec3 lightDirection = normalize(lightPosition-(ro+rd*t));\n\n    // Compute Lighting\n    float lighting0 = max(dot(materialProperties.normal, lightDirection), 0.0);\n    float lighting1 = max(dot(materialProperties.normal,-lightDirection), 0.0)*0.1;\n    float lighting = lighting0+lighting1+0.2;\n    lighting = mix(softShadow(ro+(rd*t)+(materialProperties.normal*hitDist), lightDirection)*lighting, lighting, 0.4);\n\n    // Return Final Result\n    return materialProperties.albedo*lighting;\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(gl_FragCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Set-Up Variables\n    const vec3 ro = vec3(2.0, -1.0, -2.0);\n\n    /*\n    const mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    //rotmat[0] = normalize(rotmat[0]);\n    //rotmat[1] = normalize(rotmat[1]);\n    //rotmat[2] = normalize(rotmat[2]);\n    */\n\n    const vec3 camtarget = vec3(0.0);\n\n    // Calculate the Direction of the Ray\n    vec3 targetdir = normalize(camtarget-ro);\n    vec3 left = cross(targetdir, vec3(0.0, 1.0, 0.0));\n    vec3 up = cross(left, targetdir);\n    mat3 rotmat = mat3(left, up, targetdir);\n    vec3 rd = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Frame\n    vec3 color = radiance(ro, rd);\n\n    // HDR Tonemapping\n    color = clamp(pow(color/(color+1.0), vec3(1.0/gamma)), 0.0, 1.0);\n\n    // Output the Rendered Frame\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlGDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1130, 1161, 1194, 1194, 1705], [1707, 1735, 1778, 1806, 2792], [2794, 2846, 2872, 2872, 3091], [3093, 3128, 3204, 3228, 3609], [3611, 3636, 3710, 3742, 3845], [3847, 3882, 3918, 3918, 4337], [4339, 4352, 4385, 4409, 5371], [5373, 5404, 5459, 5488, 6418]]}
{"id": "NlXGDH", "name": "[OUTLINE 2021] - Le Mandel Cube", "author": "totetmatt", "description": "1st Showdown from Outline 2021 :\n\nAs usual, not fully identical to bonzomatic, find original here :\n https://psenough.github.io/shader_summary/shader_file_sources/outline_shader_showdown_2021/outline_2021_totetmatt_1.glsl", "tags": ["mandelbrot", "cube", "outline", "showdown"], "likes": 8, "viewed": 350, "published": 3, "date": "1622020702", "time_retrieved": "2024-07-30T19:18:55.533218", "image_code": "vec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\n\n#define texFFTIntegrated (floor(iTime*.5)+pow(fract(iTime*.5),.125))*.43\n#define texFFTIntegrated2 (floor(iTime*.33)+pow(fract(iTime*.33),.5))*.37\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\n\n\nfloat mandel(vec2 uv,float l){\n    float bi3 = texFFTIntegrated;\n    vec2 z = uv;\n    vec2 c = vec2(-.856,.401);\n    float i=0.;\n    for(;i<=l;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+ c;\n        z*=rot(floor(bi3*20.));\n        if(length(z) >=2.) break;\n        \n    }\n    return i/l;\n}\nfloat box(vec3 p,vec3 b){\n\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n }\nvec2 sdf(vec3 p){\n    float _bit3 = texFFTIntegrated;\n  float _bit6 = texFFTIntegrated2;\n    p.xz *=rot(iTime);\n    vec3 pp= p;\n      p.xy *=rot(floor(_bit3*50.)*6.66);\n     p.zy *=rot(floor(_bit6*75.)*3.66);\n     vec2 mandeluv = vec2(abs(atan(p.x,abs(p.z))),p.y);\n    float q = mandel(mandeluv,10.);\n    vec2 h;\n    h.x = box(p,vec3(1.0-q*.1));\n    h.x = max(h.x,-box(p,vec3(.9-q*.1)));\n    h.y = 1.-q;\n    h.x *=.9;\n  \n    vec2 t;\n    t.x = -box(pp,vec3(10.));\n  \n     pp = abs(pp)-2.5;\n     t.x  = min(box(pp,vec3(1.)),t.x);\n    t.y = t.x == box(pp,vec3(1.)) ? 3.:2.;\n  \n      h = h.x < t.x ? h:t; \n    return h;\n}\nvec2 nv=vec2(-.001,.001);\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n      float _bit3 = texFFTIntegrated;\n     _bit3 = cos(texNoise(vec2(uv*.5),iChannel1).r+floor(_bit3*33.)*6.66)*.5;\n   \n  vec3 ro = vec3(0.,0.,-5.),rd=normalize(vec3(uv,1.-_bit3 )),rp=ro;\n  vec3 light= vec3(1.,2.,-3.);\n  \n  \tvec3 col =vec3(.1);\n  \n  vec3 acc = vec3(0.);\n  for(float i=0.;i<=69.;i++){\n      vec2 d = sdf(rp);\n     \n      if(d.y <=.1) {\n          acc += vec3(.1,7,.2)*exp(-abs(d.x))/59.;\n          d.x = max(0.02,abs(d.x));\n      }\n    \n    \n      if(d.x<=0.01) {\n          vec3 n= norm(rp);\n        \n        \n         if(d.y>.1 && d.y <=1.){\n             if(d.y >.5) {\n          col = vec3(.2,.5,.7)*max(0.,dot(normalize(light-rp),n));\n             } else {\n                 col = vec3(9.,.5,.1)*max(0.,dot(normalize(light-rp),n));\n               }\n             break;\n         } \n         if(d.y ==2.){\n             float noize = texNoise(rp.xz*10.,iChannel1).r*.01;\n             col*=vec3(.1,.7,.5)*1.2;\n             rd = reflect(rd,n+noize);\n             rp+=rd*.01;\n           }\n                    if(d.y ==3.){\n             float noize = texNoise(rp.xz*10.,iChannel1).r*.01;\n             col*=vec3(.1,.7,.5)*2.2;\n             rd = reflect(rd,n+noize);\n             rp+=rd*.01;\n           }\n        \n      }\n      rp+=rd*d.x;\n  }\n  col += acc;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXGDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 332], [481, 481, 499, 499, 546], [550, 550, 580, 580, 846], [847, 847, 872, 872, 965], [966, 966, 983, 983, 1583], [1636, 1636, 1654, 1654, 1713], [1714, 1714, 1771, 1821, 3204]]}
{"id": "ftfGWH", "name": "[OUTLINE 2021] - Le tunnel", "author": "totetmatt", "description": "2nd Showdown from Outline 2021 :\n\nAs usual, not fully identical to bonzomatic, found it here :\n https://psenough.github.io/shader_summary/shader_file_sources/outline_shader_showdown_2021/outline_2021_totetmatt_2.glsl", "tags": ["outline", "showdown"], "likes": 7, "viewed": 377, "published": 3, "date": "1622020697", "time_retrieved": "2024-07-30T19:18:56.325101", "image_code": "vec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(0.,.4,.6)));}\n#define texFFTIntegrated (floor(iTime)+pow(fract(iTime),.25))*.2\nvec3 grid(vec2 uv,float off){\n    vec2 uuv=uv;\n    float tt = texFFTIntegrated;\n    float ttt =texNoise(uv*.01,iChannel1).r;\n    float tttt=texture(iChannel0,vec2(.6)).r*50.;\n    uv*=rot(floor(tt*50.)*.785*.5);\n    uv = abs(fract(uv+ttt*tttt)-.5);\n\n    if(uv.x <=.002) return pal(.1+off)*length(uv)*2.*clamp((length(uuv)-.5),.0,1.);\n     return vec3(.0);\n}\n\nvec3 layer(vec2 uv,float off){\n uv.x +=off*.2;\n   uv.y +=off*.2;\n  float tuv = abs(atan(uv.x,abs(uv.y)))*.05;\n  float tt =texFFTIntegrated;\n  float ttt =texture(iChannel0,fract(vec2(floor(100.*tuv)/100.))).r*.2;\n  \n  float d = length(uv)-.2-ttt ;\n  d = abs(d)-.01+cos(tt)*.02;\n  d = abs(d)-.0020-ttt*.1;\n  d = smoothstep(fwidth(d),0.,d);\n  return vec3(d)*pal(off+ttt*10.)+grid(uv+ttt,off*3.33);;\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n\tvec3 col = vec3(.01);\n   float d = 0.;\n  float tttt=texFFTIntegrated;\n  const float lim = 20.;;\n  for(float i=0.;i<=lim;i++){\n    float it=i/lim;\n    float itt = fract(it+iTime*.01+tttt*.005);\n    \n   float z = mix(.001,20.,itt);\n    vec3 d = layer((uv*z)*rot(.785*i), it);\n    col +=vec3(d)*(1.-itt);\n  }\n  \n   /*vec3 pcol = texture(texPreviousFrame,puv).rgb;\n   col = mix(col,pcol,.7);*/\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27239, "src": "https://soundcloud.com/virgill/amiga-facebook-malefiz", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfGWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 332], [334, 334, 352, 352, 399], [400, 400, 418, 418, 464], [530, 530, 559, 559, 886], [888, 888, 918, 918, 1288], [1290, 1290, 1347, 1397, 1911]]}
{"id": "flsGDH", "name": "\"Closest Neighbour\" Boundaries", "author": "blackle", "description": "exploring domain repetition", "tags": ["domainrepetition", "closest", "neighbour", "domainrep"], "likes": 27, "viewed": 852, "published": 3, "date": "1622014331", "time_retrieved": "2024-07-30T19:18:57.080082", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is further explorations in how domain repetition works\n//and under what scenarios a naively domain repeated object might fail to be an SDF\n\n//this is a visualization of how the closest neighbour SDF inside a domain changes as those SDFs change\n//if we imagine a point within a domain, we can ask \"what is the closest neighbouring SDF?\"\n//in this case, we have 6 boxes in the immediate neighbouring domains.\n//as we move a point within the central domain around, the closest box to that point will change\n//we can visualze the boundaries at which a point stops being closest to one box, and starts being closest to a different box\n//inside the middle box of this shader is such a visualization\n//as the dimensions of the neighbouring boxes change, the shape of the boundaries change.\n\n//when the boxes are perfect cubes, we can model the boundaries with\n//the \"face\" function in this shader: https://www.shadertoy.com/view/Wl3fD2\n//see also the youtube video: https://youtu.be/I8fmkLK1OKg\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat box(vec3 p, vec3 d) {\n    p = abs(p)-d;\n    return length(max(p,0.)) + min(0.,max(max(p.x,p.y),p.z));\n}\n\nfloat obj(vec3 p) {\n    return box(p, vec3(.25,.25,.25+sin(iTime)*.24)) - .01;\n}\n\nbool sort(inout float a, inout float b) {\n    if (b < a) {\n        float tmp = a;\n        a = b; b = tmp;\n        return true;\n    }\n    return false;\n}\n\nint gid;\nfloat scene(vec3 p) {\n    float u = obj(p - vec3(0,0,1));\n    float d = obj(p - vec3(0,0,-1));\n    float e = obj(p - vec3(0,1,0));\n    float w = obj(p - vec3(0,-1,0));\n    float n = obj(p - vec3(1,0,0));\n    float s = obj(p - vec3(-1,0,0));\n    \n    gid = 0;\n    if (sort(u,d)) gid = 1;\n    sort(d,e);\n    sort(e,w);\n    sort(w,n);\n    sort(n,s);\n    \n    if (sort(u,d)) gid = 2;\n    sort(d,e);\n    sort(e,w);\n    sort(w,n);\n    \n    if (sort(u,d)) gid = 3;\n    sort(d,e);\n    sort(e,w);\n    \n    if (sort(u,d)) gid = 4;\n    sort(d,e);\n    \n    if (sort(u,d)) gid = 5;\n    \n    float closest = u;\n    float secondclosest = d;\n    float boundary = (abs(closest-secondclosest)-.01)/2.;\n    boundary = max(boundary, box(p, vec3(.5)));\n    \n    return min(closest,boundary);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.0001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 palette( float t )\n{\n    return cos(t+vec3(0,1.8,3.2))*.4+.6;\n}\n\nvec3 shade(vec3 p, vec3 cam) {\n    float fid = float(gid);\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float fres = 1.-abs(dot(cam,n))*.98;\n    float fact = length(sin(r*3.5)*.5+.5)/sqrt(3.0);\n    return palette(fid)*(fact*.5 + pow(fact,5.)*4.*fres);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    vec3 cam = normalize(vec3(.8,uv));\n    vec3 init = vec3(-2.5,0,0);\n    float yrot = .2;\n    float zrot = iTime/2.;\n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    \n    \n    vec3 col = vec3(0);\n    float atten = .7;\n    float k = 1.;\n    for (int i = 0; i < 200; i++ ) {\n        float dist = scene(p);\n        p += cam*dist*k;\n        if (dist*dist < 1e-7) {\n            col += shade(p, cam)*atten;\n            atten *= .7;\n            p += cam*.005;\n            k = sign(scene(p));\n        }\n        if(distance(p,init)>100.)break;\n    }\n    vec3 spec = shade(p, cam);\n    fragColor = vec4(sqrt(smoothstep(0.,1.,col)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsGDH.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1190, 1190, 1228, 1228, 1292], [1294, 1294, 1321, 1321, 1403], [1405, 1405, 1424, 1424, 1485], [1487, 1487, 1528, 1528, 1639], [1650, 1650, 1671, 1671, 2422], [2424, 2424, 2443, 2443, 2562], [2564, 2608, 2633, 2633, 2676], [2678, 2678, 2708, 2708, 2941], [2943, 2943, 3000, 3000, 3848]]}
{"id": "ftlGDH", "name": "staple pigeon on the shit", "author": "yasuo", "description": "For Jeff staple T-shirts design contest", "tags": ["pigepn"], "likes": 18, "viewed": 360, "published": 3, "date": "1622008425", "time_retrieved": "2024-07-30T19:18:57.831074", "image_code": "vec2 glitchEfect(vec2 uv, float shift) {\n    float glitchBlock = 10.0;\n    vec2 uv2 = fract(uv*glitchBlock)-0.5;\n    vec2 id = floor(uv2);\n    \n    vec2 n2 = fract(sin(id*123.456)*789.125);\n    n2+=dot(id.x,id.y*567.89);\n    float n = fract(n2.x+n2.y);\n    \n    if(mod(iTime,1.0)<0.5){\n        float glitchDist = 0.01;\n        float glitchTime = iTime*19.0;\n        uv.x-=(fract(floor(uv.y+n2.y*glitchBlock)*glitchTime)*glitchDist);\n        uv.y-=(fract(floor(uv.x+n2.x*glitchBlock)*glitchTime)*glitchDist);\n        uv.x+=sin(glitchTime*2.0)*shift;\n        uv.x+=sin(floor(uv.y*glitchBlock*1.2)*iTime*20.)*glitchDist;\n        uv.y+=sin(floor(uv.x*glitchBlock*1.2)*iTime*21.)*glitchDist;\n    }\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 r_uv = glitchEfect(uv,0.0);\n    vec2 g_uv = glitchEfect(uv,0.015);\n    vec2 b_uv = glitchEfect(uv,0.025);\n    \n\n    float r = texture(iChannel0,r_uv).r;\n    float g = texture(iChannel0,g_uv).g;\n    float b = texture(iChannel0,b_uv).b;\n    \n    vec3 col = vec3(r,g,b);\n    vec2 size = vec2(1.0,0.03);\n    \n    float t = mod(iTime,1.0);\n    if(t<0.5){\n        for(float i = 1.;i<6.0; i++){\n            vec2 pos = p;\n            pos.y+=sin(floor(iTime*2.1*i))*1.0;\n            size.x = 0.5+abs(cos(floor(iTime*2.1*i))*1.5);\n            size.y = 0.02+sin(floor(iTime*2.1*i))*0.03;\n            float d = smoothstep(0.,0.001,-max(abs(pos.x)-size.x,abs(pos.y)-size.y));\n            col = mix(col,vec3(b,r,g)*1.05,d); \n        }\n    }\n    \n    //fragColor = vec4(texture(iChannel0,uv).xyz,1.0);\n    fragColor = vec4(col*1.3,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 80.\n#define SURF_DIST .001\n#define EDGE_WIDTH 0.02\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define hash(h) fract(sin(h) * 43758.5453123)\n#define PI 3.141592653589793\n\n// noise and fbm function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//-----------------------------------------------------------------------------\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat edge;\n\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2, float k){\n    vec4 res1 = val1;\n    vec4 res2 = val2;\n    res1.w = smin(val2.w,val1.w,k);\n    res2.w = smin(val1.w,val2.w,k);\n    return (val1.w < val2.w)?res1:res2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat foot(vec3 p) {\n    vec3 prevP = p;\n    \n    p.x = abs(p.x);\n    p.x-=0.1;\n    p*=matRotateY(radians(-30.0));\n    float d = sdEllipsoid(p,vec3(0.05,0.05,0.15));\n    p = prevP;\n    float d2 = sdEllipsoid(p-vec3(0.0,0.0,-0.08),vec3(0.05,0.05,0.15));\n    d = smin(d,d2,0.02);\n    d2 = sdEllipsoid(p-vec3(0.0,0.0,0.12),vec3(0.05,0.05,0.15));\n    d = smin(d,d2,0.02);\n    p*=matRotateX(radians(-20.0));\n    d2 = sdEllipsoid(p-vec3(0.0,0.2,0.05),vec3(0.05,0.2,0.05));\n    d = smin(d,d2,0.03);\n    return d;\n}\n\nfloat leg(vec3 p) {\n    vec3 prevP = p;\n    p*=matRotateX(radians(-20.0));\n    float d = sdRoundCone(p-vec3(0.0,0.2,0.05),0.05,0.15,0.3);\n    return d;\n}\n\nfloat body(vec3 p){\n    vec3 prevP = p;\n    p-=vec3(0,0.8,-0.2);\n    const float k = 1.5; // or some other amount\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    \n    float d = sdEllipsoid(q,vec3(0.5,0.4,0.9));\n    return d;\n}\n\nfloat tail(vec3 p){\n    vec3 prevP = p;\n    \n    float d = sdEllipsoid(p-vec3(0,0.8,0.7),vec3(0.3,0.12,0.7));\n    p*=matRotateX(radians(-15.0));\n    float d2 = sdEllipsoid(p-vec3(0,0.85,0.7),vec3(0.3,0.12,0.8));\n    return smin(d,d2,0.1);\n}\n\nfloat head(vec3 p){\n    vec3 prevP = p;\n    p*=matRotateX(radians(10.0));\n    float d = sdRoundCone(p-vec3(0,1.3,-0.28),0.3,0.23,0.5);\n    p = prevP;\n    float d2 = length(p-vec3(0,1.6,-0.65))-0.25;\n    d = smin(d,d2,0.05);\n    return d;\n}\n\nfloat wing(vec3 p){\n    vec3 prevP = p;\n    p*=matRotateX(radians(-10.0))*matRotateY(radians(5.0));\n    \n    float d = sdEllipsoid(p-vec3(0.05,1.0,-0.1),vec3(0.1,0.25,0.65));\n    p*=matRotateX(radians(10.0));\n    float d2 = sdEllipsoid(p-vec3(-0.05,1.05,0.2),vec3(0.1,0.25,0.65));\n    return smin(d,d2,0.05);\n}\n\nfloat mouth(vec3 p){\n    vec3 prevP = p;\n    float d = sdEllipsoid(p-vec3(0,1.6,-0.95),vec3(0.1,0.04,0.1));\n    return d;\n}\n\nfloat mouth2(vec3 p){\n    vec3 prevP = p;\n    float d = sdCappedTorus(p-vec3(0,1.55,-0.91),vec2(0.1,0.04),0.13,0.02);\n    return d;\n}\n\nfloat eye(vec3 p){\n    vec3 prevP = p;\n    p.y*=1.3;\n    float d = length(p-vec3(-0.02,1.74,-0.76))-0.05;\n    return d;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    \n    p.x = abs(p.x);\n    p.x-=0.25;\n    p*=matRotateY(radians(-20.0));\n    float fd = foot(p);\n    float ld = leg(p);\n    \n    p = prevP;\n    p*=matRotateX(radians(-20.0));\n    float bd = body(p);\n    p = prevP;\n    float hd = head(p);\n    float td = tail(p);\n    \n    p.x = abs(p.x);\n    p.x-=0.39;\n    float wd = wing(p);\n    \n    p = prevP;\n    float md = mouth(p);\n    float md2 = mouth2(p);\n    \n    p.x = abs(p.x);\n    p.x-=0.16;\n    p.y-=0.4;\n    p.z+= 0.01;\n    float ed = eye(p);\n    \n    p = prevP;\n    p*=2.0;\n    p.x = abs(p.x);\n    p.x-=0.37;\n    p.y-=2.16;\n    p.z+= 0.84;\n    float ed2 = eye(p);\n    \n    p = prevP;\n    p.x*=fbm(p*1.5)*4.5;\n    p.z*=fbm(p*2.6)*4.0;\n    p.x*=0.6;\n    p.y*=12.0;\n    p.y+=1.7;\n    float shit = (length(p-vec3(0.0,0.0,0.3))-0.7)*0.3;\n    \n    float n = hash12(p.xz*10.0)*0.12;\n    vec4 resFoot = vec4(vec3(0.9,0.5,0.4)+n,fd);\n    vec4 resLeg = vec4(vec3(0.5,0.5,0.5)+n,ld);\n    vec4 resBody = vec4(vec3(0.8,0.8,0.8)+n,bd);\n    vec4 resHead = vec4(vec3(0.4,0.4,0.45)+n,hd);\n    vec4 resTail = vec4(vec3(0.2,0.2,0.2)+n,td);\n    vec4 resWing = vec4(vec3(0.55,0.6,0.6)+n,wd);\n    vec4 resMouth = vec4(vec3(1.0,0.5,0.6)+n,md);\n    vec4 resMouth2 = vec4(vec3(1.0)+n,md2);\n    vec4 resEye = vec4(vec3(1.0,0.6,0.6)+n,ed);\n    vec4 resEye2 = vec4(vec3(0.1)+n,ed2);\n    vec4 resShit = vec4(vec3(0.9)+n,shit*0.6);\n    \n    vec4 model = combine(resFoot,resLeg,0.03);\n    model = combine(model,resBody,0.1);\n    model = combine(model,resHead,0.07);\n    model = combine(model,resTail,0.1);\n    model = combine(model,resWing,0.1);\n    model = combine(model,resMouth,0.1);\n    model = combine(model,resMouth2,0.02);\n    model = combine(model,resEye,0.07);\n    model = combine(model,resEye2,0.0);\n    model = combine(model,resShit,0.0);\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 r = vec4(0.0,0.0,0.0,1.0);\n    \n    float lastDistEval = 1e10; \n    float dist;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*r.w;\n        vec4 dS = GetDist(p);\n        dist =  dS.w;\n        r.w += dS.w;\n        r.rgb = dS.xyz;\n        \n\t\tif (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n            edge = 1.0;\n\t\t}\n        if (dist < lastDistEval) lastDistEval = dist;\n        \n        if(r.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return r;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(3,5,0);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.2;\n    \n\n    \n    return vec2((lambert+dif),0.9) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3.5, 0.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-45.0));\n    ro.xz *= Rot(radians((sin(t*0.2)*80.0)));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,0.9,0), 1.0);\n\tvec4 r = RayMarch(ro, rd);\n    \n    if(r.w<MAX_DIST) {\n        vec3 p = ro + rd * r.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*r.rgb;\n        col *= dif.y;\n        \n    } else {\n        // background\n        //col =.84*max(mix(vec3(1.1)+(.1-length(uv.xy)/3.),vec3(1),.1),0.);\n        col = vec3(1.0);\n    }\n    \n    col = mix(col,vec3(0.1,0.1,0.1),edge);\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlGDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 709], [711, 711, 768, 768, 1705]]}
{"id": "NtsGWH", "name": "Box Edges Sorted By Proximity", "author": "blackle", "description": "a function that returns vectors representing the edges of a rectangle, ordered by distance to a given point. only valid within the box. colours in box cycle between the boundaries for the 1st, 2nd, 3rd, and 4th closest edge.", "tags": ["rectangle", "box", "sorting", "edges", "sorted", "closeness"], "likes": 10, "viewed": 373, "published": 3, "date": "1622007733", "time_retrieved": "2024-07-30T19:18:58.590045", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat nozerosgn(float x) { return step(0.,x)*2.-1.; }\nvec2  nozerosgn(vec2  x) { return step(0.,x)*2.-1.; }\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4) {\n//this probably has some really elegant underlying structure, but I'm too tired to figure it out\n    vec3 p3 = vec3(nozerosgn(p), 0); //this lets us construct the edge vectors\n    p = abs(p);\n    float c2 = nozerosgn(p.x+p.y-d.x-d.y+min(d.x,d.y)*2.);\n    e1 = (p.x-d.x < p.y-d.y) ? p3.zy : p3.xz;\n    e2 =  c2*((c2 < 0. == p.x-d.x < p.y-d.y) ? p3.zy : p3.xz);\n    e3 = -c2*((c2 < 0. == p.x+d.x < p.y+d.y) ? p3.zy : p3.xz);\n    e4 = (p.x+d.x < p.y+d.y) ? -p3.zy : -p3.xz;\n}\n\n//rest of this is visualization code\n//colours in box cycle between the boundaries for the 1st, 2nd, 3rd, and 4th closest edge.\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return length(p-mix(a,b,clamp(k,0.,1.)));\n}\nvec2 closestonline(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return mix(a,b,clamp(k,0.,1.));\n}\n\nfloat aa(float x) {\n    return smoothstep(0., 1.5/iResolution.y, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 mouse = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n\n    vec2 d = vec2(sin(iTime/3.)*.5+1., -sin(iTime/3.)*.5+1.)*.3;\n    vec2 p = vec2(sin(iTime), cos(iTime*3./2.))*min(d.x,d.y);\n    if (iMouse.z > 0.) p = mouse;\n\n    vec2 e1, e2, e3, e4;\n    edge4(p, d, e1, e2, e3, e4);\n\n    float d1 = linedist(uv, d*e1 + d*e1.yx, d*e1 - d*e1.yx);\n    float d2 = linedist(uv, d*e2 + d*e2.yx, d*e2 - d*e2.yx);\n    float d3 = linedist(uv, d*e3 + d*e3.yx, d*e3 - d*e3.yx);\n    float d4 = linedist(uv, d*e4 + d*e4.yx, d*e4 - d*e4.yx);\n    \n    vec2 c1 = closestonline(p, d*e1 + d*e1.yx, d*e1 - d*e1.yx);\n    vec2 c2 = closestonline(p, d*e2 + d*e2.yx, d*e2 - d*e2.yx);\n    vec2 c3 = closestonline(p, d*e3 + d*e3.yx, d*e3 - d*e3.yx);\n    vec2 c4 = closestonline(p, d*e4 + d*e4.yx, d*e4 - d*e4.yx);\n    float dd1 = linedist(uv, p, c1);\n    float dd2 = linedist(uv, p, c2);\n    float dd3 = linedist(uv, p, c3);\n    float dd4 = linedist(uv, p, c4);\n\n    edge4(uv, d, e1, e2, e3, e4);\n    bool vb1 = sin(iTime/4.) < 0.;\n    bool vb2 = sin(iTime/2.) < 0.;\n    vec2 vis = vb1 ? (vb2 ? e1 : e3) : (vb2 ? e2 : e4);\n    \n    vec3 col = length(max(abs(uv)-d,0.)) > 0. ? vec3(1) : vec3(vis*.3+.7,1.);\n    float dmin = min(min(min(d1,dd1),min(d2,dd2)),min(min(d3,dd3),min(d4,dd4)));\n    col = mix(vec3(.00), col, aa(dmin-.007));\n    col = mix(vec3(.75), col, aa(min(d4,dd4)-.005));\n    col = mix(vec3(.50), col, aa(min(d3,dd3)-.005));\n    col = mix(vec3(.25), col, aa(min(d2,dd2)-.005));\n    col = mix(vec3(.00), col, aa(min(d1,dd1)-.005));\n    col = mix(vec3(.85,.05,.05), col, aa(distance(p,uv)-.020));\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGWH.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 220, 220, 247], [248, 248, 274, 274, 301], [303, 448, 536, 633, 1009], [1011, 1139, 1179, 1179, 1268], [1269, 1269, 1313, 1313, 1392], [1394, 1394, 1413, 1413, 1464], [1466, 1466, 1523, 1523, 3230]]}
{"id": "Nll3WH", "name": "swarm pillars", "author": "ufffd", "description": "played around with stephaneginier's editSDF, very pleased with what came out", "tags": ["editsdf"], "likes": 3, "viewed": 257, "published": 3, "date": "1622005199", "time_retrieved": "2024-07-30T19:18:59.626274", "image_code": "#define SHADERTOY\n#define SHADERTOY_ZOOM 2.0\n#define BLEND_COLOR\nprecision mediump float;\nuniform vec3 uOrigin;\nuniform mat3 uView;\nuniform vec2 uInvSize;\n\n\n#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n// raymarching code from https://www.shadertoy.com/view/Xds3zN\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending(const in float sd, const in vec4 a, const in vec4 b) {\n  float ra = clamp(sd / a.x, 0.0, 1.0);\n  float rb = clamp(sd / b.x, 0.0, 1.0);\n  return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(min(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec3 colorInter(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(max(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec2 pR45(const in vec2 p) {\n  return (p + vec2(p.y, -p.x)) * SQRT1_2;\n}\n\n/////////////\n// PRIMITIVES\n/////////////\n\nfloat cullPlane(const in vec3 p) {\n  return p.y >= -0.502 ? p.y + 0.5 : 20.0;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) {\n  return length(p) - s;\n}\n\nfloat sdBox(const in vec3 p, const in vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\nfloat sdTorus(const in vec3 p, const in vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat sdCapsule(const in vec3 p, const in vec2 rh) {\n  return mix(length(p.xz) - rh.x, length(vec3(p.x, abs(p.y) - rh.y, p.z)) - rh.x, step(rh.y, abs(p.y)));\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n///////////////\n// COMBINATIONS\n///////////////\n\n// UNION\nfloat opUnion(const in float a, const in float b) {\n  return min(a, b);\n}\nvec4 opUnion(const in vec4 a, const in vec4 b) {\n  return (a.x < b.x) ? a : b;\n}\n\n// INTER\nfloat opInter(const in float a, const in float b) {\n  return max(a, b);\n}\nvec4 opInter(const in vec4 a, const in vec4 b) {\n  return (a.x > b.x) ? a : b;\n}\n\n// SUB\nfloat opSub(const in float a, const in float b) {\n  return max(-b, a);\n}\nvec4 opSub(const in vec4 a, const in vec4 b) {\n  // to keep b material on diff intersection instead of a mat\n  // return (-b.x > a.x) ? vec4(-b.x, b.yzw) : a);\n  return vec4(max(-b.x, a.x), a.yzw);\n}\n\n// see hg_sdf.glsl\n/////////////////////\n// COMBINATIONS ROUND\n/////////////////////\n\n// UNION ROUND (soft media mol version)\nfloat opUnionRound(const in float a, const in float b, const in float r) {\n  float e = max(r - abs(a - b), 0.0);\n  return min(a, b) - e * e * 0.25 / r;\n}\nvec4 opUnionRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionRound(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER ROUND\nfloat opInterRound(const in float a, const in float b, const in float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0.0));\n  return min(-r, max(a, b)) + length(u);\n}\nvec4 opInterRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB ROUND\nfloat opSubRound(const in float a, const in float b, const in float r) {\n  return opInterRound(a, -b, r);\n}\nvec4 opSubRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, -b.x, r), a.yzw);\n}\n\n///////////////////////\n// COMBINATIONS CHAMFER\n///////////////////////\n\n// UNION CHAMFER\nfloat opUnionChamfer(const in float a, const in float b, const in float r) {\n  return min(min(a, b), (a - r + b) * SQRT1_2);\n}\nvec4 opUnionChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionChamfer(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER CHAMFER\nfloat opInterChamfer(const in float a, const in float b, const in float r) {\n  return max(max(a, b), (a + r + b) * SQRT1_2);\n}\nvec4 opInterChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB CHAMFER\nfloat opSubChamfer(const in float a, const in float b, const in float r) {\n  return opInterChamfer(a, -b, r);\n}\nvec4 opSubChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, -b.x, r), a.yzw);\n}\n\n//////////////////////\n// COMBINATION COLUMNS\n//////////////////////\n\n// UNION COLUMNS\nfloat opUnionColumns(const in float a, const in  float b, const in vec2 rn) {\n  float r = rn.x;\n  float n = rn.y;\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n    p = pR45(p);\n    p.x -= SQRT1_2 * r;\n    p.x += columnradius * SQRT2;\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    // At this point, we have turned 45 degrees and moved at a point on the\n    // diagonal that we want to place the columns on.\n    // Now, repeat the domain along this direction and place a circle.\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n    float result = length(p) - columnradius;\n    result = min(result, p.x);\n    result = min(result, a);\n    return min(result, b);\n  } \n\n  return min(a, b);\n}\nvec4 opUnionColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionColumns(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// SUB COLUMNS\nfloat opSubColumns(const in float ain, const float b, const vec2 rn) {\n  float a = -ain;\n  float r = rn.x;\n  float n = rn.y;\n  float m = min(a, b);\n  //avoid the expensive computation where not needed (produces discontinuity though)\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / n / 2.0;\n    columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n\n    p = pR45(p);\n    p.y += columnradius;\n    p.x -= SQRT1_2 * (r + columnradius);\n\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n\n    float result = -length(p) + columnradius;\n    result = max(result, p.x);\n    result = min(result, a);\n    return -min(result, b);\n  }\n\n  return -m;\n}\nvec4 opSubColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, b.x, rn), a.yzw);\n}\n\n// INTER COLUMNS\nfloat opInterColumns(const in float a, const in float b, const in vec2 rn) {\n  return opSubColumns(a, -b, rn);\n}\nvec4 opInterColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, -b.x, rn), colorInter(a, b));\n}\n\n/////////////////////\n// COMBINATION STAIRS\n/////////////////////\n// UNION STAIRS\nfloat opUnionStairs(const in float a, const in float b, const in vec2 rn) {\n  float s = rn.x / rn.y;\n  float u = b - rn.x;\n  return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2.0 * s)) - s)));\n}\nvec4 opUnionStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionStairs(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// INTER STAIRS\nfloat opInterStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, -b, rn);\n}\nvec4 opInterStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, -b.x, rn), colorInter(a, b));\n}\n\n// SUB STAIRS\nfloat opSubStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, b, rn);\n}\nvec4 opSubStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, b.x, rn), a.yzw);\n}\n\n/////////////\n// REPETITION\n/////////////\n\nvec3 pMod(const in vec3 p, const in vec3 size) {\n  vec3 pmod = p;\n  if(size.x > 0.0) pmod.x = mod(p.x + size.x * 0.5, size.x) - size.x * 0.5;\n  if(size.y > 0.0) pmod.y = mod(p.y + size.y * 0.5, size.y) - size.y * 0.5;\n  if(size.z > 0.0) pmod.z = mod(p.z + size.z * 0.5, size.z) - size.z * 0.5;\n  return pmod;\n}\n\n////////////\n// HELPERS\n////////////\nvec4 mapDistanceColor(const in vec3 point) {\n  vec4 tmpPrim_117 = vec4(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, vec3(0.1) * (mod(floor(5.0 * point.z) + floor(5.0 * point.x), 2.0)) + 0.4);\nvec4 tmpPrim_118 = vec4(sdBox(pMod((mat4(1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,-0.673682451248169,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(4.8500000000000005,1.71,5.0)), vec4(0.1,0.78,0.1,0.09)) * 0.6877309083938599, vec3(0.30639375,0.35338712499999997,0.52));\nvec4 tmpComb_267 = opUnionColumns(tmpPrim_117, tmpPrim_118, vec2(0.3,5.96));\nvec4 tmpPrim_119 = vec4(sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(1.6400000000000001,2.09,6.7700000000000005)), 0.28) * 1.0, vec3(0.5215065625,0.49989843749999996,0.77));\nvec4 tmpComb_268 = tmpComb_267;\nvec4 tmpComb_269 = opUnionColumns(tmpComb_268, tmpPrim_119, vec2(0.3,10.0));\nvec4 tmpPrim_120 = vec4(sdBox(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,3.44)), vec4(0.33,0.01,0.53,0.0)) * 1.0, vec3(0.5215065625,0.49989843749999996,0.77));\nvec4 tmpComb_270 = tmpComb_269;\nvec4 tmpComb_271 = opSubColumns(tmpComb_270, tmpPrim_120, vec2(0.17,10.0));\nvec4 tmpPrim_121 = vec4(sdSphere(pMod((mat4(3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,5.372418403625488,-0.0015462442534044385,0.008526071906089783,1.0) * vec4(point, 1.0)).xyz, vec3(0.1,0.1,0.1)), 0.01) * 0.30537912249565125, vec3(0.11024278124999998,0.04005781250000002,0.31000000000000005));\nvec4 tmpComb_272 = tmpComb_271;\nvec4 tmpComb_273 = opInterColumns(tmpComb_272, tmpPrim_121, vec2(0.01,7.0));\nreturn tmpComb_273;\n}\n\nfloat mapDistance(const in vec3 point) {\n  float tmpComb_274 = opUnionColumns(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, sdBox(pMod((mat4(1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,-0.673682451248169,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(4.8500000000000005,1.71,5.0)), vec4(0.1,0.78,0.1,0.09)) * 0.6877309083938599, vec2(0.3,5.96));\nfloat tmpComb_275 = tmpComb_274;\nfloat tmpComb_276 = opUnionColumns(tmpComb_275, sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(1.6400000000000001,2.09,6.7700000000000005)), 0.28) * 1.0, vec2(0.3,10.0));\nfloat tmpComb_277 = tmpComb_276;\nfloat tmpComb_278 = opSubColumns(tmpComb_277, sdBox(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,3.44)), vec4(0.33,0.01,0.53,0.0)) * 1.0, vec2(0.17,10.0));\nfloat tmpComb_279 = tmpComb_278;\nfloat tmpComb_280 = opInterColumns(tmpComb_279, sdSphere(pMod((mat4(3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,5.372418403625488,-0.0015462442534044385,0.008526071906089783,1.0) * vec4(point, 1.0)).xyz, vec3(0.1,0.1,0.1)), 0.01) * 0.30537912249565125, vec2(0.01,7.0));\nreturn tmpComb_280;\n}\n    \nvec4 castRay(const in vec3 ro, const in vec3 rd) {\n  float t = 1.0;\n  float tmax = 50.0;\n\n  float precis = 0.002;\n  for(int i = 0; i < 50; i++) {\n    float dist = mapDistance(ro + rd * t);\n    if(dist < precis || t > tmax)\n      break;\n    t += dist;\n  }\n\n  vec3 m = t > tmax ? vec3(-1.0) : mapDistanceColor(ro + rd * t).yzw;\n  return vec4(t, m);\n}\n\nfloat softshadow(const in vec3 ro, const in vec3 rd) {\n  float t = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 16; i++) {\n    float h = mapDistance(ro + rd * t);\n    res = min(res, 20.0 * h / t);\n    t += clamp( h, 0.02, 0.10 );\n    if(h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(const in vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),\n      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),\n      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));\n  return normalize(nor);\n}\n\nfloat calcAO(const in vec3 pos, const in vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i = 0; i < 5; i++) {\n      float hr = 0.01 + 0.03 * float(i);\n      vec3 aopos = nor * hr + pos;\n      occ += (hr - mapDistance(aopos)) * sca;\n      sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    \n}\n\nvec3 render(const in vec3 ro, const in vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n\n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n        \n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n    lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n    lin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n    col = res.yzw * lin;\n  }\n\n  return clamp(col, 0.0, 1.0);\n}\n\n#ifdef SHADERTOY\nmat3 setCamera( const in vec3 ro, const in vec3 ta, const float cr ){\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 15.0 + iTime;\n\n  // camera \n  vec3 ro = SHADERTOY_ZOOM * vec3( -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n  vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n  fragColor = vec4(render(ro, rd), 1.0);\n}\n\n#else\n\nvec3 raymarch(const in vec3 origin, const in mat3 view, const in vec2 uv, const in vec2 invSize) {\n  vec2 p = -1.0 + 2.0 * uv;\n  p.x *= invSize.y / invSize.x;\n  vec3 rd = normalize(view * vec3(p, 2.0));\n  return render(origin, rd);\n}\n\nvoid main() {\n  gl_FragColor = vec4(raymarch(uOrigin, uView, gl_FragCoord.xy * uInvSize, uInvSize), 1.0);\n}\n\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nll3WH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "7tsGWr", "name": "Koch Snowflake fractal", "author": "Hitthesurf", "description": "Koch Snowflake fractal, with working pan and zoom :)\nUp/Left/Down/Right = WASD\nRotation = Q/E\nZoom = I/O", "tags": ["fractal", "rotation", "panandzoom"], "likes": 5, "viewed": 311, "published": 3, "date": "1621960741", "time_retrieved": "2024-07-30T19:19:00.388237", "image_code": "vec2 my_reflect(in vec2 pos, in vec2 n)\n{\n    n = normalize(n);\n    pos -= 2.*min(0.0, dot(pos, n))*n;\n    return pos;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.xy;\n    vec3 col = vec3(0);\n    float scale = 1.;\n    \n    \n    \n    //Pan and Zoom and Rotation\n    vec4 qp = textureLod(iChannel0, vec2(0.0,0.0), 0.0);\n    vec4 zoom = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy,0.0);\n    // angle, angle vel, cos(angle), sin(angle)\n    vec4 rot = textureLod(iChannel0, vec2(0.5,10.5)/iResolution.xy,0.0);\n    \n    \n    uv *= zoom.z;\n    scale *= zoom.z;\n    uv = vec2(uv.x*rot.z-uv.y*rot.w, uv.x*rot.w + uv.y*rot.z);\n    uv.xy += qp.xy;\n    \n    //col.rg += uv;    \n\n  \n\n    \n    uv.x +=.5;\n    for (int i = 0; i < 12; i++) {\n        uv *= 3.;\n        scale *=3.;\n        uv.x -= 1.5;\n        uv.x = abs(uv.x); //reflection\n        uv.x -= 0.5;\n        uv = my_reflect(uv, vec2(0.866,-0.5));\n\n    } \n\n    float d = length(uv - vec2(clamp(uv.x,-1.,1.),0.0));//closest position to line segment\n    col += smoothstep(1./iResolution.y,0.00,d/scale);//only change color if far enough away\n    uv /= scale;\n    col += texture(iChannel1, uv*sin(iTime*0.1)).rgb;\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Keyboard Code to make it work\n// keys are javascript keycode\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\n\nconst float speed = 0.03;\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n    //Only run once each frame\n    \n    /*\n    if (ivec2(fragCoord.xy) == ivec2(0,0))\n    {\n    \n    //Load previous offset x, offset y, zoom and rotation\n    vec4 visual = textureLod(iChannel0, vec2(0.0,0.0), 0.0);\n    //Zoom\n    visual.z += ReadKey(Key_I)-ReadKey(Key_O);\n    \n    \n    visual.x += ReadKey(Key_D)-ReadKey(Key_A);\n    visual.y += ReadKey(Key_W)-ReadKey(Key_S);\n    \n    \n    fragColor = visual;\n    \n    }\n    */\n    \n    \n    //Panning\n    if (ivec2(fragCoord.xy) == ivec2(0,0))\n    {\n    //float speed = 0.05;\n    \n    //Load previous x_pos, y_pos, x_vel, y_vel\n    vec4 qp = textureLod(iChannel0, vec2(0.0,0.0), 0.0);\n    //Need zoom as zoom level impacts offset\n    vec4 zoom = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy,0.0);\n    \n    //Need Rot as rotatoin impacts offset\n    vec4 rot = textureLod(iChannel0, vec2(0.5,10.5)/iResolution.xy,0.0);\n    \n    //Velocity\n    qp.z = (ReadKey(Key_D)-ReadKey(Key_A))*speed*zoom.z; //Change input\n    qp.w = (ReadKey(Key_W)-ReadKey(Key_S))*speed*zoom.z; //velocity on zoom level\n    \n    //Deal with rotation\n    qp.zw = vec2(qp.z*rot.z-qp.w*rot.w, qp.z*rot.w + qp.w*rot.z);\n    \n\n    \n    \n    //New Position\n    qp.x += qp.z; //*time delta\n    qp.y += qp.w;\n    \n    fragColor = qp;\n    \n    }\n    \n    //Zoom\n    if (ivec2(fragCoord.xy) == ivec2(10,10) )\n    {\n    \n        vec4 zoom = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy,0.0);\n        //Number of times zoom in - zoom out has happend\n        \n        zoom.y = (ReadKey(Key_I)-ReadKey(Key_O)); //Zoom velocity\n        zoom.x += zoom.y; //*time delta\n        zoom.z = pow(2.71,-zoom.x*speed);\n        \n        //Save Zoom data to bufferA pixel (10,10)\n        fragColor = zoom;\n    }\n    \n    //Rotation\n    if (ivec2(fragCoord.xy) == ivec2(0,10) )\n    {\n        // angle, angle vel, cos(angle), sin(angle)\n        vec4 rot = textureLod(iChannel0, vec2(0.5,10.5)/iResolution.xy,0.0);\n        //Number of times zoom in - zoom out has happend\n        \n        rot.y = (ReadKey(Key_Q)-ReadKey(Key_E))*speed; //Rot velocity\n        rot.x += rot.y; //*time delta\n        rot.z = cos(rot.x);\n        rot.w = sin(rot.x);\n        \n        //Save Zoom data to bufferA pixel (10,10)\n        fragColor = rot;\n    }\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 121], [123, 123, 180, 180, 1377]]}
{"id": "stlGWn", "name": "Hydroclaudic Acid", "author": "andypea", "description": "Click anywhere to create a new pattern.", "tags": ["2d", "wave", "interactive", "psychedelic", "flashing", "waveequation"], "likes": 1, "viewed": 300, "published": 3, "date": "1621923802", "time_retrieved": "2024-07-30T19:19:01.258909", "image_code": "float hslToRgbHelper(float n, vec3 hsl) {\n    float h = hsl.x;\n    float s = hsl.y;\n    float l = hsl.z;\n    \n    float k = mod((n + h / 30.0), 12.0);\n    float a = s * min(l, 1.0 - l);\n    \n    return l - a * max(-1.0, min(min(k - 3.0, 9.0 - k), 1.0));\n}\n\nvec3 hslToRgb(vec3 hsl) {\n    return vec3(hslToRgbHelper(0.0, hsl),\n                hslToRgbHelper(8.0, hsl),\n                hslToRgbHelper(4.0, hsl));  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cutoff = 0.01;\n    vec3 greenScreen = vec3(13.0/256.0, 163.0/256.0, 37.0/256.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n        \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 claud = texture(iChannel1, uv);\n    \n    float nonGreen = smoothstep(0.1, 0.3, distance(claud.rgb, greenScreen));\n    float nonBlack = smoothstep(0.55, 0.65, distance(claud.rgb, black));\n    float claudiness = min(nonGreen, nonBlack);\n    \n    float phi = texture(iChannel0, uv).x;\n    vec3 hsl = vec3(pow(phi, 1.0) * 360.0, \n                        1.0, \n                        abs(phi) > cutoff ? 0.5: 0.0);\n                              \n    vec4 background = vec4(hslToRgb(hsl), 1.0);\n    vec4 foreground = vec4(1.0, 1.0, 1.0, 2.0) - background;\n    \n    fragColor = (1.0 - claudiness) * background + claudiness * foreground;\n}", "image_inputs": [{"id": 20, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   const float c = 1e-4;\n   const float h = 1e-1;\n   const float ht = 1.0;\n   const float blobRadius = 3e-2;\n\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if (iFrame < 2) {\n        // Startup\n        float d = distance(uv, vec2(0.5, 0.5));\n        float phiNew = smoothstep(blobRadius, 0.0, d);\n        fragColor = vec4(phiNew, phiNew, 0, 0);\n    }\n    else {  \n        // Time evolution\n        const vec2 hx = vec2(h, 0.0);\n        const vec2 hy = vec2(0.0, h);\n        const float h2Inv = pow(h, -2.0);\n        \n        vec4 phi = texture(iChannel0, uv);\n        vec4 phiNegX = texture(iChannel0, uv + hx);\n        vec4 phiPosX = texture(iChannel0, uv - hx);\n        vec4 phiNegY = texture(iChannel0, uv + hy);\n        vec4 phiPosY = texture(iChannel0, uv - hy);\n                  \n        float d2Phi = (phiPosX.x + phiPosY.x + phiNegX.x + phiNegY.x - 4.0 * phi.x) * h2Inv;\n        \n        float phiNew = c * ht * ht * d2Phi + 2.0 * phi.x - phi.y;\n        \n        fragColor = vec4(phiNew, phi.x, 0, 0);\n            \n            \n        if (iMouse.z > 0.0) {\n            // Interaction\n            vec2 mouseUv = iMouse.xy / iResolution.xy;\n            float d = distance(uv, mouseUv);\n            float phiNew = smoothstep(blobRadius, 0.0, d);\n            fragColor = vec4(phiNew, phiNew, 0, 0);\n        }\n    }    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 255], [257, 257, 282, 282, 413], [415, 415, 472, 472, 1292]]}
{"id": "fllGDr", "name": "Light Blast", "author": "andypea", "description": "Click anywhere to create a new pattern.", "tags": ["2d", "wave", "interactive", "psychedelic", "flashing", "waveequation"], "likes": 2, "viewed": 328, "published": 3, "date": "1621922401", "time_retrieved": "2024-07-30T19:19:02.032840", "image_code": "float hslToRgbHelper(float n, vec3 hsl) {\n    float h = hsl.x;\n    float s = hsl.y;\n    float l = hsl.z;\n    \n    float k = mod((n + h / 30.0), 12.0);\n    float a = s * min(l, 1.0 - l);\n    \n    return l - a * max(-1.0, min(min(k - 3.0, 9.0 - k), 1.0));\n}\n\nvec3 hslToRgb(vec3 hsl) {\n    return vec3(hslToRgbHelper(0.0, hsl),\n                hslToRgbHelper(8.0, hsl),\n                hslToRgbHelper(4.0, hsl));  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cutoff = 0.01;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float phi = texture(iChannel0, uv).x;\n    \n    vec3 hsl = vec3(pow(phi, 1.0) * 360.0, \n                    1.0, \n                    abs(phi) > cutoff ? 0.5: 0.0); \n    fragColor = vec4(hslToRgb(hsl), 1.0);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   const float c = 1e-4;\n   const float h = 1e-1;\n   const float ht = 1.0;\n   const float blobRadius = 3e-2;\n\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if (iFrame < 2) {\n        // Startup\n        float d = distance(uv, vec2(0.5, 0.5));\n        float phiNew = smoothstep(blobRadius, 0.0, d);\n        fragColor = vec4(phiNew, phiNew, 0, 0);\n    }\n    else {  \n        // Time evolution\n        const vec2 hx = vec2(h, 0.0);\n        const vec2 hy = vec2(0.0, h);\n        const float h2Inv = pow(h, -2.0);\n        \n        vec4 phi = texture(iChannel0, uv);\n        vec4 phiNegX = texture(iChannel0, uv + hx);\n        vec4 phiPosX = texture(iChannel0, uv - hx);\n        vec4 phiNegY = texture(iChannel0, uv + hy);\n        vec4 phiPosY = texture(iChannel0, uv - hy);\n                  \n        float d2Phi = (phiPosX.x + phiPosY.x + phiNegX.x + phiNegY.x - 4.0 * phi.x) * h2Inv;\n        \n        float phiNew = c * ht * ht * d2Phi + 2.0 * phi.x - phi.y;\n        \n        fragColor = vec4(phiNew, phi.x, 0, 0);\n            \n            \n        if (iMouse.z > 0.0) {\n            // Interaction\n            vec2 mouseUv = iMouse.xy / iResolution.xy;\n            float d = distance(uv, mouseUv);\n            float phiNew = smoothstep(blobRadius, 0.0, d);\n            fragColor = vec4(phiNew, phiNew, 0, 0);\n        }\n    }    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllGDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 255], [257, 257, 282, 282, 413], [415, 415, 472, 472, 752]]}
{"id": "Ntl3Wr", "name": "Daisy chainsaw", "author": "xenn", "description": "wot he said,\n\"Another fly through, this time through a Menger system (with some perturbations). \nThe 'roto-perspective' may be adjusted using the 'NonLinearPerspective' define.\"", "tags": ["raymarching", "fractals", "menger"], "likes": 6, "viewed": 373, "published": 3, "date": "1621912486", "time_retrieved": "2024-07-30T19:19:02.828712", "image_code": "// Fork of \"MAY DAY , MAY DAY !\" by xenn. https://shadertoy.com/view/7sSXWd\n// 2021-05-25 03:06:14\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uuv = uv * 2.0 - 1.0;\n    vec3 c = texture(iChannel0, uv).rgb;\n    vec4 col = vec4(pow(c, vec3(0.5)), 1.0);\n\n    fragColor = mix(vec4(.0), col, 1.-smoothstep(0.,1.,length(uuv)*0.6));\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"Menger Journey\" by Syntopia. https://shadertoy.com/view/Mdf3z7\n// 2021-05-17 16:50:31\n\n#define MaxSteps 22\n#define MinimumDistance 0.0009\n#define normalDistance     0.0002\n\n#define Iterations 8\n#define PI 3.141592\n#define Scale 3.0*abs(01.1-cos(iTime*0.25)/2.0)\n#define FieldOfView 1.0\n#define Jitter 0.05\n#define FudgeFactor 0.7\n#define NonLinearPerspective 3.0*abs(01.0+sin(iTime*0.35)/2.0)\n#define DebugNonlinearPerspective false\n\n#define Ambient 0.0184\n#define Diffuse 0.5\n#define LightDir vec3(1.0)\n#define LightColor vec3(1.0*abs(1.1-sin(iTime*0.5)/4.0),1.0,0.858824-cos(iTime*0.5)/2.0)\n#define LightDir2 vec3(1.0*abs(01.1-sin(iTime*01.5)/2.0),-1.0*abs(01.1-sin(iTime*0.5)/2.0),1.0/abs(01.1-sin(iTime*0.5)/0.50))\n#define LightColor2 vec3(0.0+abs(sin(iTime*1.0)),0.333333,1.0*abs(01.1-sin(iTime*0.25)/2.0))\n#define Offset vec3(0.92858+(01.1*(sin(iTime*0.35))/19.50),0.92858090,0.2858090*(02.1+cos(iTime*0.0235)/8.0))\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Two light sources. No specular \nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tvec3 lightDir = normalize(LightDir);\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\t\n\tvec3 lightDir2 = normalize(LightDir2);\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\t\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color);\n}\n\n\n// DE: Infinitely tiled Menger IFS.\n//\n// For more info on KIFS, see:\n// http://www.fractalforums.com/3d-fractal-generation/kaleidoscopic-%28escape-time-ifs%29/\nfloat DE(in vec3 z)\n{\n\t// enable this to debug the non-linear perspective\n\tif (DebugNonlinearPerspective) {\n\t\tz = fract(z);\n\t\tfloat d=length(z.xy-vec2(0.5));\n\t\td = min(d, length(z.xz-vec2(0.5)));\n\t\td = min(d, length(z.yz-vec2(0.5)));\n\t\treturn d-0.01;\n\t}\n\t// Folding 'tiling' of 3D space;\n\tz  = abs(1.0-mod(z,2.0));\n\n\tfloat d = 1000.0;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tz.xy = rotate(z.xy,4.0+2.0*cos( iTime/8.0));\t\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(Scale-1.0);\n\t\tif( z.z<-0.5*Offset.z*(Scale-0.50))  z.z+=Offset.z*(Scale-1.0);\n\t\td = min(d, length(z) * pow(Scale, float(-n)-1.0));\n\t}\n\t\n\treturn d-0.001;\n}\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0);\n}\n\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i < MaxSteps; i++) {\n\t\t// Non-linear perspective applied here.\n\t\tdir.zy = rotate(dir2.zy,totalDistance*cos( iTime/4.0)*NonLinearPerspective);\n\t\t\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\t// Try to smooth the count, to combat banding.\n\tfloat smoothStep =   float(steps) + distance/MinimumDistance;\n\tfloat ao = 1.1-smoothStep/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\t\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor = (color*Ambient+light)*ao;\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera position (eye), and camera target\n\tvec3 camPos = 0.05*iTime*vec3(1.0,0.0,0.0);\n\tvec3 target = camPos + vec3(1.0,0.0*cos(iTime),0.0*sin(0.4*iTime));\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tfragColor = rayMarch(camPos, rayDir, fragCoord );\n}\n\n\n\n\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base * overlay*0.8975, 1.0);\n    \n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*01.1;\n    vec2 vUv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel0, vUv);\n\tfloat random = rand(vUv+time*0.1);\n\n\tfragColor = mix(vec4(random), tex-random*0.5, clamp(time*0.50, 0.0,0.95));\n    \n    fragColor.rgb = clamp(fragColor.rgb,vec3(0.0), vec3(01.0)); \n\tfragColor.a = 1.0;\n}", "buffer_c_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// This buffer is the feedback loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert the uv's to polar coordinates to scale up  \n    vec2 polarUv = (uv * 2.0 - 1.0);\n    float angle = atan(polarUv.y, polarUv.x);\n    \n    // Scale up the length of the vector by a noise function feeded by the angle and length of the vector\n    float ll = length(polarUv)*0.4915;\n    \n    vec3 base = texture(iChannel0, uv).rgb;\n    \n    // Convert the scaled coordinates back to cartesian\n    vec2 offs = vec2(cos(angle)*ll + 0.5, sin(angle)*ll + 0.5);\n    \n    // sample the last texture with uv's slightly scaled up\n    vec3 overlay = texture(iChannel1,offs).rgb;\n\n        // Additively blend the colors together\n    vec4 col = vec4(base + overlay*0.78975, 1.0);\n    \n    fragColor = col;\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntl3Wr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 157, 157, 391]]}
{"id": "ftsGDn", "name": "amogus", "author": "Zi7ar21", "description": "amogus", "tags": ["amogus"], "likes": 37, "viewed": 1043, "published": 3, "date": "1621909228", "time_retrieved": "2024-07-30T19:19:03.700381", "image_code": "// ####### amogus #######\n// Made by Zi7ar21 on May 24th, 2021 at 20:20 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, you can find the original and possibly updated version at:\n// https://www.shadertoy.com/view/ftsGDn\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n\n// Image Preview\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Final Image\n    vec3 color = texel0.rgb;\n\n    // HDR Tonemapping\n    color = clamp(pow(color/(color+1.0), vec3(1.0/gamma)), 0.0, 1.0);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27237, "src": "https://soundcloud.com/ser-g-o/amogus", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// ##### Preprocessor #####\n\n/*\n#if __VERSION__ < 300\n#error This shader requires GLSL 300 ES to run!\n#endif\n*/\n\n// Page 6:\n// https://www.khronos.org/files/webgl20-reference-guide.pdf\n// - Debug info off by default, no need to disable it\n// - Optimization on by default, no need to enable it\n\n// Old version but also useful:\n// https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf\n\n//#pragma debug(on)\n//#pragma optimize(off)\n\n//#pragma debug(off)\n//#pragma optimize(on)\n\n// ##### Parameters #####\n\n#define gamma 2.2\n\n#define camfov  1.00\n#define hitDist 1E-4\n#define maxDist 8.00\n#define maxStep 512U\n\n#define MAX_BOUNCES 8u\n\n// ##### Constants #####\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\nconst float pi     = 3.141592653589793; // Pi\nconst float two_pi = 6.283185307179586; // 2 * Pi\nconst float inv_pi = 0.318309886183790; // 1 / Pi\n\n// aaaaah stuff below shart I will replace later\n\n// Traditional Input Names\n#define resolution iResolution\n#define frame iFrame\n\n// Sample Buffers\n#define texel0 texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0)\n#define texel1 texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0)\n#define texel2 texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0)\n#define texel3 texelFetch(iChannel3, ivec2(gl_FragCoord.xy), 0)\n\n// ##### RNG #####\n// Taken from michael0884's Usage of PCG Random\n// (He has since improved these, I like the old ones though... yeet!)\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n// https://www.pcg-random.org/\n\nuint ns;\n#define INIT_RNG ns = uint(frame)*uint(resolution.x*resolution.y)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x)\n\n// PCG Random Number Generator\nvoid pcg()\n{\n    uint state = ns * 0x2C9277B5u + 0xAC564B05u;\n    uint word  = ( (state >> ( (state >> 28u) + 4u) ) ^ state ) * 0x108EF2D9u;\n    ns = (word >> 22U) ^ word;\n}\n\n// Random Floating-Point Scalars/Vectors\nfloat rand(){pcg(); return float(ns)/float(0xffffffffU);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random Vectors\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x   ))*vec2(cos(two_pi*Z.y), sin(two_pi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy ))*vec3(cos(two_pi*Z.z), sin(two_pi*Z.z), cos(two_pi*Z.w));}\nvec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(two_pi*Z.z), sin(two_pi*Z.z), cos(two_pi*Z.w), sin(two_pi*Z.w));}", "buffer_a_code": "// Material Datatype\nstruct material {\n    uint ID;\n    vec3 albedo;\n    vec3 normal;\n    float rough;\n};\n\n// Material Properties Lookup\nmaterial getMaterial(material materialProperties)\n{\n    uint ID = materialProperties.ID;\n    materialProperties.albedo = ID == 0U ? vec3(0.6) : (ID == 1U ? vec3(0.5, 0.25, 0.125) : vec3(0.8));\n    materialProperties.rough  = ID == 0U ? 1.0 : (ID == 1U ? 0.2 : 0.05);\n    return materialProperties;\n}\n\n// Smooth Boolean Operations\nfloat smoothUnion(float d0, float d1, float k)\n{\n    float h = clamp(0.5+0.5*(d1-d0)/k, 0.0, 1.0);\n    return mix(d1, d0, h)-k*h*(1.0-h);\n}\n\nfloat smoothSubtraction(float d0, float d1, float k)\n{\n    float h = clamp(0.5-0.5*(d1+d0)/k, 0.0, 1.0);\n    return mix(d1,-d0, h)+k*h*(1.0-h);\n}\n\nfloat smoothIntersection(float d0, float d1, float k) {\n    float h = clamp(0.5-0.5*(d1-d0)/k, 0.0, 1.0);\n    return mix(d1, d0, h)+k*h*(1.0-h);\n}\n\n// I saw red vent! sus! sus! impasta!\nfloat amogus(vec3 pos, out uint id)\n{\n    if(length(pos.xz) > 1.5)\n    {\n        return length(pos.xz)-1.0;\n    }\n\n    // Cylinder\n    float bean = max(length(pos.xz)-0.5, abs(pos.y)-0.25);\n\n    // Cylinder Caps\n    bean = min(bean, min(length(pos-vec3(0.0, 0.25, 0.0))-0.5, length((pos+vec3(0.0, 0.25, 0.0))*vec3(1.0, 2.0, 1.0))-0.5));\n\n    // Legs\n    float legs = max(length(vec2(abs(pos.x)-0.25, pos.z))-0.2, abs(pos.y+0.6)-0.15);\n    legs = min(legs, length(vec3(abs(pos.x)-0.25, pos.y+0.45, pos.z))-0.2);\n\n    // Legs\n    bean = smoothUnion(bean, legs, 0.2);\n\n    // Backpack\n    bean = smoothUnion(bean, max(max(abs(pos.x)-0.5, abs(pos.y-0.1)-0.5), abs(pos.z-0.5)-0.2), 0.05);\n\n    float visor = length((pos+vec3(0.0, -0.2, 0.5))*vec3(1.0, 2.0, 3.0))-0.35;\n\n    id = bean < visor ? 1U : 2U;\n\n    // Return the Sussy Bean Man\n    return min(bean, visor);\n}\n\n// Scene Distance Estimator\nfloat DE(vec3 pos, out uint id)\n{\n    // Scene Floor\n    float DE0 = pos.y;\n\n    // Bean Man\n    float DE1 = amogus(pos-vec3(0.0, 0.75, 0.0), id);\n\n    id = DE0 < DE1 ? 0U : id;\n    return min(DE0, DE1);\n}\n\n// Tetrahedron Numerical Normals\nvec3 getNormal(vec3 pos)\n{\n    const vec2 k = vec2(-1.0, 1.0);\n    uint n;\n    return normalize(\n    k.xxx*DE(pos+k.xxx*hitDist, n)+\n    k.xyy*DE(pos+k.xyy*hitDist, n)+\n    k.yxy*DE(pos+k.yxy*hitDist, n)+\n    k.yyx*DE(pos+k.yyx*hitDist, n));\n}\n\n// Distance Estimator Ray-Marching\nfloat intersectDE(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    float t = 0.0;\n\n    for(uint i = 0U; i < maxStep; i++)\n    {\n        if(t > maxDist)\n        {\n            break;\n        }\n\n        float td = DE(ro+rd*t, materialProperties.ID);\n\n        if(td < hitDist)\n        {\n            materialProperties.normal = getNormal(ro+rd*t);\n            return t-hitDist;\n        }\n\n        t += td*0.5;\n    }\n\n    return -1.0;\n}\n\n// Scene Intersection Function\nfloat intersect(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    float t0 = intersectDE(ro, rd, materialProperties);\n\n    materialProperties = getMaterial(materialProperties);\n\n    return t0;\n}\n\nvec3 skyColor(vec3 dir)\n{\n    if(dot(dir, normalize(vec3(-1.0, 0.5, -1.0))) > 0.8)\n    {\n        return vec3(10.0);\n    }\n\n    return vec3((max(dot(dir, vec3(0.0, 1.0, 0.0)), 0.0)*0.8)+0.2);\n}\n\n// Render the Frame and Calculate Shading\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    vec3 raypos = ro;\n\n    material materialProperties;\n\n    vec3 attenuation = vec3(1.0);\n\n    for(uint i = 0U; i < MAX_BOUNCES; i++)\n    {\n        float t = intersect(raypos, rd, materialProperties);\n\n        if(t < 0.0)\n        {\n            return attenuation*skyColor(rd);\n        }\n\n        raypos += rd*t;\n        raypos += materialProperties.normal*hitDist;\n        attenuation = clamp(attenuation*materialProperties.albedo, 0.0, 1.0);\n        rd = reflect(rd, normalize(nrand3(materialProperties.rough, materialProperties.normal)));\n    }\n\n    return vec3(-1.0);\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    // Progressive Rendering\n    fragColor = frame != 0 ? texel0 : vec4(0.0);\n\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(nrand2(0.5, gl_FragCoord.xy)-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Set-Up Variables\n    const vec3 ro = vec3(1.5, 0.75, -1.5);\n    mat3 rotmat = mat3(0.5, 0.0, 0.5, 0.0, 1.0, 0.0, -0.5, 0.0, 0.5);\n    rotmat[0] = normalize(rotmat[0]);\n    //rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n\n    vec3 rd = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Frame\n    vec3 color = radiance(ro, rd);\n\n    // Output the Rendered Frame\n    fragColor += any(lessThan(color, vec3(0.0))) || any(isinf(color)) || any(isnan(color)) ? vec4(0.0) : vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// ##### IMAGE EXPORT #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Render Buffer\n    vec4 texel = texel0;\n\n    // Output the Final Image\n    fragColor = vec4(texel0.a == 0.0 ? texel0.rgb : texel0.rgb/texel.a, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsGDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[385, 402, 457, 484, 676]]}
{"id": "7tf3Dr", "name": "Twisting Skies", "author": "Tater", "description": "Made with creative direction from my sister. ", "tags": ["3d", "raymarch", "sun", "ocean", "twist", "reflective", "pillar", "chains"], "likes": 13, "viewed": 384, "published": 3, "date": "1621908672", "time_retrieved": "2024-07-30T19:19:04.572051", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.141596\n#define STEPS 200.0\n#define MDIST 250.0\n#define pmod(p,x) (mod(p, x) - (x)*0.5)\n\nvec3 g1 = vec3(0);\nfloat donut( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 map2(vec3 p){\n    vec3 po = p;\n    float t = iTime*0.2;\n\n    vec2 a = vec2(1);\n    a.x = donut(p,vec2(2,0.5));\n    vec2 b = vec2(2);\n    p.yz*=rot(pi/2.0);\n    b.x = donut(p+vec3(2.5,0,0),vec2(2,0.5));\n    \n    //Colors\n    a.y = mix(1.0,2.0,clamp(30.0*sin(p.y*7.0+t*3.0),0.0,1.0));\n    vec3 p2 = p;\n    p2+=t*4.0;\n    b.y = mix(1.0,2.0,step(sin((p2.x)*10.0)*sin((p2.y)*10.0)*sin((p2.z)*10.0),-0.5));\n\n    b = (b.x < a.x) ? b:a;\n    \n    a = vec2(donut(p+vec3(-2.5,0,0),vec2(2,0.5)),3.0);\n    g1 += 0.05/(0.5+abs(a.x))*vec3(1.000,0.588,0.122);\n    b = (b.x < a.x) ? b:a;\n    \n    return b;\n}\nvec2 map3(vec3 p){\n    vec3 po = p;\n    float sep = 15.0;\n    p.x = pmod(p.x,sep);\n    vec2 a = map2(p);\n    p = po;\n    p.x+=sep*0.5;\n    p.x = pmod(p.x,sep);\n    p.zy*=rot(pi/2.0);\n    vec2 b = map2(p);\n    b = (b.x < a.x) ? b:a;\n    return b;\n}\nvec2 map(vec3 p){\n    vec3 po2 = p;\n    p.zy*=rot(pi/2.0);\n    \n    \n    vec3 po = p;\n    float t = iTime;\n    p.y+=6.0;\n    float th = atan(po.y,po.x)/(2.0*pi)+0.5;\n    float r = length(po.yx)-10.;\n    th*=60.0;\n    p.y = r;\n    p.x = th;\n    p.x+=t*9.0;\n    vec2 a = map3(p);\n    \n    po.xy*=rot(p.z*0.05);\n    //Big rings\n    float size = 15.0;\n    vec3 p2 = po; \n    \n    p2.xy = abs(p2.xy)-vec2(1,1)*4.5;\n    p2.xy*=rot(-0.9);\n    p2.y-=size*10.0;\n    p2.xz*=rot(pi/2.0);\n    p2.xy*=rot(t*0.2);\n    p = p2;\n    \n    th = atan(p2.y,p2.x)/(2.0*pi)+0.5;\n    \n    r = length(p2.yx)-10.0*size;\n    th*=60.0*size;\n    p.y = r;\n    p.x = th;\n\n    \n    vec2 b = map3(p);\n    b.x*=0.7;\n    b = (b.x < a.x) ? b:a;\n    \n    //Cut Cynlinder\n    p = po;\n    a.x = length(p.xy)-50.0;\n    a.y = 2.0;\n    b.x = max(a.x,b.x);\n\n    p.z+=sin(p.x+t*6.0)*0.025;\n    p.z+=sin(p.y+t*6.0)*0.02;\n    a = vec2(length(p.z),4.0);\n    b = (b.x < a.x) ? b:a;\n\n    //Pillars\n    p = po2;\n    p.xz = abs(p.xz)-vec2(70);\n    a = vec2(length(p.xz)-6.5,5.0);\n    a.x*=0.7;\n    b = (b.x < a.x) ? b:a;\n    \n    return b;\n}\n\n\nvec3 norm(vec3 p){\n    vec2 e= vec2(0.0005,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    float t2 = t*0.05;\n    float outside = 80.0;\n    \n    vec2 off = vec2(outside*sin(t2),outside*cos(t2));\n    \n    vec3 ro = vec3(off.x,8.0,off.y);\n    vec3 lk = vec3(0,14,0);\n    vec3 f = normalize(lk-ro);\n    vec3 ra = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*1.0+uv.x*ra+uv.y*cross(f,ra);\n    vec3 p = ro;\n    float shad = 0.0;\n    float dO = 0.0;\n    float dO2;\n    vec2 d;\n    float bnc = 0.0;\n    float dist = 0.0;\n    for(float i = 0.0; i < STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        d.x = abs(d.x);\n        if(abs(d.x) < 0.001) {\n            if(d.y==3.0) {\n               d.x=0.1;\n            }\n            else{\n            shad = (i)/(STEPS);\n            if(bnc == 0.0)dist=dO;\n            if(bnc== 1.0||d.y!=4.0) {shad=i/STEPS; break; d.y = 0.0;}\n            ro += rd*dO;\n            vec3 n = norm(ro);\n            rd = reflect(rd,n);\n            ro += 0.1;\n            dO = 0.0;\n            i=0.0;\n            bnc++;\n            }\n            \n        }\n        if(dO2>MDIST){\n        if(bnc==0.0)p = ro+rd*MDIST;\n        d.y = 0.0;\n        break;\n        }\n        dO += d.x;\n        dO2 += d.x;\n    }\n    vec3 po = p;\n    p.y-=5.0;\n    vec3 sky = mix(vec3(0.012,0.490,0.647),vec3(0.145,0.118,0.522),clamp(p.y*0.01,0.0,1.0));\n    sky = mix(sky,vec3(1.000,0.773,0.141) * clamp(pow(abs(1.0 / (100.0 * length(p.xy*0.0004))),3.0),0.0,0.9),\n    pow(abs(1.0 / (100.0 * length(p.xy*0.0004))),3.9));\n    p=po;\n    vec3 al = vec3(0);\n    if(d.y!=0.0)shad = 1.0-shad;\n    if(d.y==1.0){\n    al = vec3(0.310,0.122,1.000);\n    }\n    if(d.y==2.0) {\n    al = vec3(1.000,0.588,0.122);\n    }\n    if(d.y==5.0) {\n    al = vec3(0.8);\n    }\n    if(d.y==4.0) {\n    al = sky;\n    }\n    vec3 n = norm(p);\n    vec3 ld = vec3(1,1,-1);\n    float spec = pow(max(dot(n,normalize(-rd)),0.0),30.0);\n    col = vec3(shad)*al;\n    if(d.y!=0.0&&d.y!=5.0){\n    col+=spec;\n    }\n    if(d.y==5.0){\n    col+=spec*0.2;\n    }\n    if(d.y==0.0)col = mix(col,sky,clamp(dO2/200.0,0.0,1.0));\n    col += min(g1*0.25,1.0);\n    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3Dr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 201, 201, 266], [268, 268, 286, 286, 864], [865, 865, 883, 883, 1112], [1113, 1113, 1130, 1130, 2203], [2206, 2206, 2224, 2224, 2352], [2353, 2353, 2410, 2410, 4572]]}
{"id": "7djGzh", "name": "Custom wavelength function", "author": "milesWaugh", "description": "Just a little regression I made from the lookup table for Blender's wavelength node :)", "tags": ["wavelength"], "likes": 4, "viewed": 339, "published": 3, "date": "1621886179", "time_retrieved": "2024-07-30T19:19:05.391859", "image_code": "float a1 =  246.611;\nfloat c1 =  101.012;\nfloat a2 =  84.9146;\nfloat d2 =  51.6093;\nfloat c2 =  41.4358;\nfloat a3 = -74.9107;\nfloat d1 =  248.567;\nfloat c3 = -26.0807;\nfloat a4 = -18.3549;\nfloat c4 =  153.137;\n\nfloat a5 =  93.6835;\nfloat d5 =  301.903;\nfloat c5 =  43.6979;\nfloat a6 =  220.991;\nfloat d6 =  220.999;\nfloat c6 = -84.7918;\nfloat a7 = -35.6888;\nfloat d7 =  105.534;\nfloat c7 = -16.4446;\nfloat a8 =  4004.65;\nfloat d8 =  .313595;\nfloat c8 =  .313595;\nfloat f1 = -2.9286;\n\nfloat a9  =  5145600.;\nfloat d9  =  101.985;\nfloat c9  =  67.7637;\nfloat a10 =  23566.2;\nfloat d10 =  82.649;\nfloat c10 =  65.8543;\nfloat a11 = -5167000.;\nfloat d11 =  101.899;\nfloat c11 =  67.78;\nfloat k   =  .714803;\n\nfloat r(float x){\n    if(x>591.){\n        return 0.;\n    }\n\n    if(125.5<x && x<250.2){\n        return 0.;\n    }\n        float e1 = (x-350.)/c1;\n        float s1 = a1*exp(-e1*e1);\n        float e2 = (x-d2)/c2;\n        float s2 = a2*exp(-e2*e2);\n        float e3 = (x-d1)/c3;\n        float s3 = a3*exp(-e3*e3);\n        float e4 = (x-d1)/c4;\n        float s4 = a4*exp(-e4*e4);\n        return (s1+s2+s3+s4)/255.;\n}\n\nfloat g(float x){\n    if(100.>x || x>402.){\n        return 0.;\n    }\n        float e1 = (x-d5)/c5;\n        float s1 = a5*exp(-e1*e1);\n        float e2 = (x-d6)/c6;\n        float s2 = a6*exp(-e2*e2);\n        float e3 = (x-d7)/c7;\n        float s3 = a7*exp(-e3*e3);\n        float e4 = (x-d8)/c8;\n        e4 = e4*e4*e4;\n        float s4 = a8*exp(-e4*e4);\n        return max(s1+s2+s3+s4+f1,0.)/255.;\n}\n\nfloat b(float x){\n    if(x>220.){\n        return 0.;\n    }\n        float e1 = (x-d9 )/c9 ;\n        float s1 = a9 *exp(-e1*e1);\n        float e2 = (x-d10)/c10;\n        float s2 = a10*exp(-e2*e2);\n        float e3 = (x-d11)/c11;\n        float s3 = a11*exp(-e3*e3);\n        return min(max(s1+s2+s3+k,0.)/255.,1.);\n}\n\nvec3 wave(float wavelength){\n    float x = (wavelength-400.)*(512./300.);\n    return(vec3(r(x), g(x), b(x)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float x = 300.+500.*(fragCoord.x/iResolution.x);\n    vec3 col = wave(x);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djGzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[704, 704, 721, 721, 1115], [1117, 1117, 1134, 1134, 1514], [1516, 1516, 1533, 1533, 1828], [1830, 1830, 1858, 1858, 1941], [1943, 1943, 1997, 1997, 2128]]}
{"id": "slfGWr", "name": "Real Time Path Tracing", "author": "ockiller", "description": "Animated and biased version of [url]https://www.shadertoy.com/view/7ll3zN[/url]\nSimple scene + simple material (no-caustics hack) + lots of care of the sampling strategy + a tiny bit of temporal accumulation\n=\nAlmost noise free realtime path tracing !", "tags": ["raytracing", "pathtracing", "bluenoise", "smallpt", "lowdiscrepancy", "r2"], "likes": 31, "viewed": 1438, "published": 3, "date": "1621884982", "time_retrieved": "2024-07-30T19:19:06.152824", "image_code": "// See Buffer A\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pow(texelFetch(iChannel0, ivec2(fragCoord), 0), vec4(1.0 / 2.2));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define RAYS_PER_PIXEL 32\n#define MAX_BOUNCES    4\n#define TEMPORAL       0.75\n#define NEXT_EVENT_ESTIMATION\n\n\n\n///////////////////////\n// Scene description //\n///////////////////////\n\n#define DIFF   0\n#define GLOSSY 1\n#define METAL  2\n\nstruct Sphere {\n    vec3 color, position;\n    float radius;\n    int material;\n};\n\n#define NB_LIGHTS 1\nSphere lights[NB_LIGHTS] = Sphere[](\n    Sphere(vec3(10.0), vec3(0.0), 0.2, 0) // position set in main\n);\n\n#define RWALL 1e2    // Radius of wall spheres\n#define RADIUS 0.4   // Radius of spheres\n#define NB_SPHERES 7\nconst Sphere spheres[NB_SPHERES] = Sphere[](\n    Sphere(vec3(0.9, 0.9, 0.9), vec3( 0.0  ,  0.0  ,  RWALL       ), RWALL - 1.0, DIFF  ), // top\n    Sphere(vec3(0.9, 0.9, 0.9), vec3( 0.0  ,  0.0  , -RWALL       ), RWALL - 1.0, DIFF  ), // bottom\n    Sphere(vec3(0.9, 0.9, 0.9), vec3( RWALL,  0.0  ,  0.0         ), RWALL - 1.0, DIFF  ), // front\n    Sphere(vec3(0.9, 0.1, 0.1), vec3( 0.0  ,  RWALL,  0.0         ), RWALL - 1.0, DIFF  ), // left red\n    Sphere(vec3(0.1, 0.1, 0.9), vec3( 0.0  , -RWALL,  0.0         ), RWALL - 1.0, DIFF  ), // right blue\n    Sphere(vec3(0.1, 0.9, 0.1), vec3(-0.4  , -0.4  ,  RADIUS - 1.0), RADIUS     , GLOSSY), // green sphere\n    Sphere(vec3(0.9, 0.9, 0.1), vec3( 0.4  ,  0.4  ,  RADIUS - 1.0), RADIUS     , METAL )  // yellow sphere\n);\n\n\n\n////////////////\n// Raytracing //\n////////////////\n\n// Intersect a sphere with a ray starting at O with direction D\n// If intersection is found before tmax, return true and update tmax with the new intersection distance\n// Back faces are ignored\nbool intersect(Sphere s, vec3 O, vec3 D, inout float tmax) {\n    vec3 L = s.position - O;\n    float tc = dot(D, L);\n    float t = tc - sqrt(s.radius * s.radius + tc * tc - dot(L, L));\n    if (t > 0.0 && t < tmax) {\n        tmax = t;\n        return true;\n    }\n    return false;\n}\n\n// Intersect all the spheres\n// Return the intersected sphere index, or -1 if no sphere found before tmax\n// If intersection is found, tmax is updated with the new intersection distance\nint intersectSpheres(vec3 O, vec3 D, inout float tmax) {\n    int imin = -1;\n    for (int i = 0; i < NB_SPHERES; i++)\n        if (intersect(spheres[i], O, D, tmax))\n            imin = i;\n    return imin;\n}\n\n// Intersect all the lights\n// Return the intersected light index, or -1 if no light found before tmax\n// If intersection is found, tmax is updated with the new intersection distance\nint intersectLights(vec3 O, vec3 D, inout float tmax) {\n    int imin = -1;\n    for (int i = 0; i < NB_LIGHTS; i++)\n        if (intersect(lights[i], O, D, tmax))\n            imin = i;\n    return imin;\n}\n\n// Evaluate diffuse direct lighting from all lights, for next event estimation\n#ifdef NEXT_EVENT_ESTIMATION\nvec3 directLighting(vec3 O, vec3 N, vec2 r) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < NB_LIGHTS; i++) {\n        Sphere l = lights[i];\n        vec3 LC = l.position - O;\n        float d2 = dot(LC, LC);\n        float invd = inversesqrt(d2);\n        float cosL = sqrt(d2 - l.radius * l.radius) * invd;\n        vec3 L = coneSample(LC * invd, cosL, r);\n        float t = 1e5;\n        if (intersect(l, O, L, t) && intersectSpheres(O, L, t) < 0)\n            color += 2.0 * (1.0 - cosL) * max(0.0, dot(N, L)) * l.color;\n    }\n\n    return color;\n}\n#endif\n\n// Compute the light radiance along a ray starting at O, with direction D.\n// The computation may need to continue with a new ray to get the final color (accumulation),\n// in which case it returns true and update O and D as the new ray to cast.\n// indirectOnly is set to true when direct light evaluation has been done just before,\n// to avoid taking direct illumination into account twice.\nbool radiance(inout vec3 O, inout vec3 D, inout vec3 accumulation, inout vec3 throughput, inout bool indirectOnly, int bounces) {\n    float t = 1e5;\n    int iSphere = intersectSpheres(O, D, t);\n    int iLight = indirectOnly ? -1 : intersectLights(O, D, t);\n\n    if (iLight >= 0) {\n        // A light has been hit, terminate the path\n        accumulation += throughput * lights[iLight].color;\n    } else if (iSphere >= 0) {\n        // A sphere has been hit, evaluate material\n        Sphere s = spheres[iSphere];\n        O += t * D;\n        vec3 N = normalize(O - s.position);\n        float cosND = max(0.0, dot(N, -D));\n        \n        // Choose whether to evaluate specular or diffuse for glossy material\n        bool evalSpecular = rand.z < fresnel(cosND, vec3(0.04)).x;\n        bool allowCaustics = bounces < 1; // hack to avoid noise from caustics\n        indirectOnly = false;\n        \n        if (s.material == METAL && allowCaustics) {\n            // Tinted mirror\n            throughput *= fresnel(cosND, s.color);\n            D = reflect(D, N);\n        } else if (s.material == GLOSSY && evalSpecular && allowCaustics) {\n            // Mirror white specular\n            D = reflect(D, N);\n        } else {\n            // Diffuse, attenuate color with sphere color\n            throughput *= s.color;\n            \n            // Evaluate direct lighting to help converge faster\n            #ifdef NEXT_EVENT_ESTIMATION\n                accumulation += throughput * directLighting(O, N, rand.xy);\n                indirectOnly = true;\n            #endif\n\n            // Continue bouncing around randomly\n            D = cosineSample(N, rand.xy);\n        }\n        \n        return true;\n    }\n    // Else: the ray hits nothing, it escapes the scene and will not contribute\n\n    return false;\n}\n\n\n\n//////////\n// Main //\n//////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const uint raysPerPixel = uint(RAYS_PER_PIXEL);\n    vec3 blueNoiseSeed = texelFetch(iChannel0, ivec2(fragCoord) & 0x3FF, 0).xyz;\n    \n    // Animate light\n    if (iMouse.z < 0.5) {\n        lights[0].position.xy = 0.5 * vec2(cos(0.5 * iTime), sin(iTime));\n        lights[0].position.z = 0.15 * sin(0.25 * iTime) + 0.4;\n    } else {\n        lights[0].position.xyz = 1.5 * (iMouse.xxy / iResolution.xxy - 0.5);\n        lights[0].position.y *= -1.0;\n    }\n\n    // Camera initialization\n    const vec3 camPos = vec3(-2.0, 0.25, -0.5);\n    const float fovy = 60.0, tanFov = tan(fovy * PI / 360.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Raytrace the pixel and accumulate result\n    fragColor.rgb = vec3(0.0);\n    for (uint r = 0u; r < raysPerPixel + uint(ZERO); r++) {\n        // Reset random seed for maximum coherency. Blue noise takes care of the decorrelation.\n        perFrameSeed = uint(iFrame) * raysPerPixel + r;\n        rand = toroidalJitter(sequence3D(perFrameSeed), blueNoiseSeed);\n\n        // Ray setup\n        vec2 uv = 2.0 * (fragCoord + rand.yz) / iResolution.xy - 1.0;\n        uv.x *= -aspectRatio;\n        vec3 O = camPos;\n        vec3 D = normalize(vec3(1.0, tanFov * uv));\n        vec3 accumulation = vec3(0.0);\n        vec3 throughput = vec3(1.0); // Neutral value\n\n        // Trace\n        int bounces = 0;\n        bool indirectOnly = false;\n        while (radiance(O, D, accumulation, throughput, indirectOnly, bounces) && bounces++ < MAX_BOUNCES)\n            rand = toroidalJitter(sequence3D(perFrameSeed = lcg(perFrameSeed)), blueNoiseSeed);\n\n        fragColor.rgb += accumulation;\n    }\n\n    fragColor.rgb *= 1.0 / float(raysPerPixel);\n    fragColor.a = 1.0;\n    \n    // Accumulate with previous frames\n    fragColor.rgb = mix(fragColor.rgb, texelFetch(iChannel1, ivec2(fragCoord), 0).rgb, TEMPORAL);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415927\n#define ZERO min(0.0, iTime)\n\n\n\n////////////\n// Random //\n////////////\n\n// Seeds are initialized in main\nuint perFrameSeed;\nvec3 rand;\n\nuint lcg(uint i) {\n    return 1103515245u * i + 12345u;\n}\n\n// Return the i-th term of the golden ratio sequence\nfloat goldenSequence(uint i) {\n    return float(2654435769u * i) / 4294967296.0;\n}\n\n// Return the i-th vector of Martin Roberts' R2 sequence\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec2 plasticSequence(uint i) {\n    return vec2(3242174889u * i, 2447445414u * i) / 4294967296.0;\n}\n\n// Combine the two previous sequences\nvec3 sequence3D(uint i) {\n    return vec3(plasticSequence(i), goldenSequence(i));\n}\n\nvec3 toroidalJitter(vec3 x, vec3 jitter) {\n    return 2.0 * abs(fract(x + jitter) - 0.5);\n}\n\n\n\n//////////////\n// Sampling //\n//////////////\n\n// Generate an orthonormal vector basis around N\nvoid genTB(vec3 N, out vec3 T, out vec3 B) {\n    float s = N.z < 0.0 ? -1.0 : 1.0;\n    float a = -1.0 / (s + N.z);\n    float b = N.x * N.y * a;\n    T = vec3(1.0 + s * N.x * N.x * a, s * b, -s * N.x);\n    B = vec3(b, s + N.y * N.y * a, -N.y);\n}\n\n// Generate a random direction around N\n// The direction probability is proportional to the cosinus of the angle relative to N\n// Takes two uniformly distributed random values (r)\nvec3 cosineSample(vec3 N, vec2 r) {\n    vec3 T, B;\n    genTB(N, T, B);\n    r.x *= 2.0 * PI;\n    float s = sqrt(1.0 - r.y);\n    return T * (cos(r.x) * s) + B * (sin(r.x) * s) + N * sqrt(r.y);\n}\n\n// Generate a uniformly distributed random direction in a cone around N\n// Takes two uniformly distributed random values (r)\nvec3 coneSample(vec3 N, float cosTmax, vec2 r) {\n    vec3 T, B;\n    genTB(N, T, B);\n    r.x *= 2.0 * PI;\n    r.y = 1.0 - r.y * (1.0 - cosTmax);\n    float s = sqrt(1.0 - r.y * r.y);\n    return T * (cos(r.x) * s) + B * (sin(r.x) * s) + N * r.y;\n}\n\n\n\n/////////////\n// Shading //\n/////////////\n\n// Schlick-Fresnel approximation\nvec3 fresnel(float cosEN, vec3 F0) {\n    float e = 1.0 - cosEN;\n    float e5 = e * e; e5 *= e5 * e;\n    return (1.0 - e5) * F0 + e5;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfGWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 72, 72, 156]]}
{"id": "slXGWn", "name": "Day 522", "author": "jeyko", "description": "potater", "tags": ["feedback", "mdtmjvm"], "likes": 22, "viewed": 420, "published": 3, "date": "1621878506", "time_retrieved": "2024-07-30T19:19:06.904814", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0,fragCoord/iResolution.xy).rgb;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    float md = 3.;\n    float stSz = R.y*0.01*(1.);\n    int idx = iFrame / 1144 % 3;\n    vec2 U = fragCoord;\n    vec2 dF = vec2( \n        T(U+vec2(1,0)*stSz)[idx]-T(U-vec2(1,0)*stSz)[idx],\n        T(U+vec2(0,1)*stSz)[idx]-T(U-vec2(0,1)*stSz)[idx]\n    );\n    col = mix(smoothstep(0.,1.,1.-col),col,1.-float(iMouse.z>0.));\n    col = pow(max(col,0.),vec3(0.4545 ));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pal(a,b,c,d,e) (a+(b)*sin((c)*(d) +e))\nvoid mainImage( out vec4 fragColor, in vec2 U )\n{\n    vec2 oU = U;\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n    float T = iTime*0.5;\n    U.x += sin(T + sin(T))*0.4;\n    \n    float du = 0.1;\n    float stSz = R.y*0.004*(1. + sin(iTime + dot(uv,uv)*10.));\n    int idx = iFrame / 1144 % 3;\n    vec2 dF = vec2( \n        T(U+vec2(1,0)*stSz)[idx]-T(U-vec2(1,0)*stSz)[idx],\n        T(U+vec2(0,1)*stSz)[idx]-T(U-vec2(0,1)*stSz)[idx]\n    );\n    float stSzB = stSz;\n    vec4 n = T(U+vec2(0,1)*stSzB), e = T(U+vec2(1,0)*stSzB), s = T(U-vec2(0,1)*stSzB), w = T(U-vec2(1,0)*stSzB), m = 0.25*(n+e+s+w); \n    \n    float div = 0.25*(n.y-s.y+e.x-w.x);\n    \n    \n    vec3 prevFr = T(U + dF*stSz*2.*(.2 + sin(iTime)*0.05 + dot(dF,dF) )).xyz;\n\n    vec3 col = mix(vec3(0.96,0.9,0.8 - dot(uv,uv)*0.1 ), prevFr,0.99 + sin(iTime*4.)*0.009);\n    \n    float ddf =  dot(dF,dF)*1.;\n    float cenv = max(sin(iTime*0.6),0.);\n    cenv = smoothstep(0.,1.,cenv);\n    for(float i = 0.; i < 130.; i++){\n        vec2 p = uv + vec2(sin(i)*0.25*cenv,0);\n        p *= rot(i*10. + (iTime +sin(iTime + i*2.1)*1.)*0.4*sin(i));\n        //p.y += sin(i*240.)*5.;\n        \n        p = vec2(length(p),atan(p.xy));\n        \n        float env = mod(sin(i)*10.2 + iTime*0.1,1.)*1. + sin(iTime)*0.15;\n        p.x -= env;\n        \n        float d = length(p )\n            - 0.02*smoothstep(0.,0.6,env)\n            + 0.04*smoothstep(0.1,-0.04,env)\n            + 0.04*smoothstep(0.,0.3,env);\n        vec3 c = pal(vec3(1.,1.,0.4),vec3(0.4,0.8,0.9),vec3(3,2,1),1.,i*3. + iTime + p.x*3. - ddf + p.x*47. + 0.*smoothstep(0.03,0.1,d));\n        //col = mix(col,c -col*vec3(0.4,1.,1.),smoothstep(fwidth(d),0.,d));\n        col = mix(col,c -col*vec3(0.4,1.,1.),smoothstep(0.04 + sin(iTime*0.7 + sin(i))*0.02,0.,d ));\n        \n    }\n\n    if(iFrame < 2)\n        col -= col - 1.;\n    \n      \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define T(u) texture(iChannel0,(u)/R)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXGWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 589]]}
{"id": "7lf3Wn", "name": "Marden's Theorem", "author": "neozhaoliang", "description": "This shader illustrates Marden's theorem on the Steiner inellipse of a triangle.", "tags": ["2d", "ellipse", "marden", "saddlepoint"], "likes": 27, "viewed": 913, "published": 3, "date": "1621876254", "time_retrieved": "2024-07-30T19:19:07.663785", "image_code": "/* Marden's theorem on Steiner inellipse, Zhao Liang.\n\nMotivated by this tweet:\n\n    https://twitter.com/theAlbertChern/status/1395468792788967428?s=20\n*/\n#define PI 3.141592653\n\nfloat sl;\n\nconst float palNum = 70.;\n\n\nfloat sFract(float x, float sm)\n{\n    // Extra smoothing factor. \"1\" is the norm.\n    const float sf = 1.;\n\n    // The hardware \"fwidth\" is cheap, but you could take the expensive route and\n    // calculate it by hand if more quality was required.\n    vec2 u = vec2(x, fwidth(x)*sf*sm);\n\n    // Ollj's original formula with a transcendental term omitted.\n    u.x = fract(u.x);\n    u += (1. - 2.*u)*step(u.y, u.x);\n    return clamp(1. - u.x/u.y, 0., 1.); // Cos term ommitted.\n}\n\n// Only correct for nonnegative values, but in this example, numbers aren't negative.\nfloat sFloor(float x)\n{\n    return x - sFract(x, 1.);\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r )\n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    \n\tvec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    float d = length(max(w,0.0));\n    return ((k>0.0)?d:-d) + r;\n}\n\n\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\n    return clamp(p*hr, 0., 1.);\n}\n\nfloat msign(in float x)\n{\n    return x < 0.0 ? -1.0 : 1.0;\n}\n\nmat2 rot2d(float a)\n{\n    float c=cos(a), s=sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 cmul(vec2 p, vec2 q)\n{\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\nvec2 csqrt(vec2 p)\n{\n    float a = atan(p.y, p.x) / 2.;\n    return vec2(cos(a), sin(a)) * sqrt(length(p));\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n    vec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v)/dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\n// iq's triangle signed distance function\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// ellipse signed distance function\nfloat sdEllipse( vec2 p, vec2 cen, float theta, in vec2 ab )\n{\n    p -= cen;\n    float c = cos(theta), s = sin(theta);\n    p *= mat2(c, s, -s, c);\n    vec2 pab = p / (ab * ab);\n    return (0.5 * dot(pab, p) - 0.5) / length(pab);\n}\n\nfloat sdEllipseFromTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2, out vec2 f1, out vec2 f2)\n{\n    vec2 m = (p0 + p1 + p2) / 3.;\n    vec2 n = (cmul(p0, p1) + cmul(p1, p2) + cmul(p2, p0)) / 3.;\n    f1 = m + csqrt(cmul(m, m) - n);\n    f2 = m - csqrt(cmul(m, m) - n);\n    vec2 mid = (p0 + p1) / 2.;\n    float a = (length(mid - f1) + length(mid - f2)) / 2.;\n    vec2 cen = (f1 + f2) / 2.;\n    vec2 dir = (f1 - f2) / 2.;\n    float b = sqrt(a*a -dot(dir, dir));\n    float theta = atan(dir.y, dir.x);\n    return sdEllipse(p, cen, theta, vec2(a, b));\n}\n\nfloat getVoltage( vec2 p, vec2 p0, vec2 p1, vec2 p2 )\n{\n    float c = length(p - p0) * length(p - p1) * length(p - p2);\n    c = log(max(c, 0.001));\n    c = c / 10. + 0.5;\n    c = clamp(c, 0., 1.);\n    float level = sFloor(c*(palNum - .001));\n    sl = level;\n    return clamp(level/(palNum - 1.), 0., 1.) * .85 + .15 * c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float sf = 2. / iResolution.y;\n    vec2 p = uv * 2.;\n\n    // triangle vertices\n    vec2 A = vec2(1.5*sin(iTime), 1.5);\n    vec2 B = vec2(-2.+0.4*cos(iTime*0.7), -1.+0.6*cos(iTime*0.7));\n    vec2 C = vec2(1.8+cos(iTime), -1.6);\n\n    // distance to the triangle\n    float dtri = sdTriangle(p, A, B, C);\n\n    // foci of the Steiner inscribed ellipse.\n    vec2[2] foci;\n\n    // solve the ellipse and foci\n    vec2 m = (A + B + C) / 3.;\n    vec2 n = (cmul(A, B) + cmul(B, C) + cmul(C, A)) / 3.;\n    foci[0] = m + csqrt(cmul(m, m) - n);\n    foci[1] = m - csqrt(cmul(m, m) - n);\n    // the tangent point is the middle point of an edge.\n    vec2 mid = (A + B) / 2.;\n    // semi-axis\n    float a = (length(mid - foci[0]) + length(mid - foci[1])) / 2.;\n    vec2 cen = (foci[0] + foci[1]) / 2.;\n    vec2 dir = (foci[0] - foci[1]) / 2.;\n    float b = sqrt(a*a - dot(dir, dir));\n    float theta = atan(dir.y, dir.x);\n    // now we have the distance to the ellipse and the foci\n    float dellipse = sdEllipse(p, cen, theta, vec2(a, b));\n    float dfoci = min(length(p - foci[0]), length(p - foci[1])) - 0.04;\n\n    // distance to the medians\n    float dlines = 1e5;\n    dlines = min(dlines, dseg(p, A, (B+C)/2.));\n    dlines = min(dlines, dseg(p, B, (A+C)/2.));\n    dlines = min(dlines, dseg(p, C, (B+A)/2.));\n\n    // inside the ellipse/between ellipse and triangle/outside the triangle\n    float sgn = dellipse < 0. ? -2. : (dtri < 0. ?  0. : 1.);\n\n    // get voltage at this point\n    float volt = getVoltage(p, A, B, C);\n    float ssl = sl;\n\n    vec2 e = vec2(8./clamp(iResolution.y, 300., 800.), 0);\n    float fxl = getVoltage(p + e.xy, A, B, C);\n    float fxr = getVoltage(p - e.xy, A, B, C);\n    float fyt = getVoltage(p + e.yx, A, B, C);\n    float fyb = getVoltage(p - e.yx, A, B, C);\n\n    // color the region between voltage contours\n    vec3 col = vec3(0.4, 0.7, 0.4) - sgn*vec3(0.2, 0., 0.2)*ssl/palNum;\n    // dissipate the colors by doing some rotation\n    col = rotHue(col, -(min(ssl/palNum, 0.85))*12.+1.);\n    // darken the edges\n    col *= max(1. - (abs(fxl - fxr) + abs(fyt - fyb))*10., 0.);\n    // make some highlight\n    fxl = getVoltage(p + e.xy*1.5, A, B, C);\n    fyt = getVoltage(p + e.yx*1.5, A, B, C);\n    col += vec3(.9, .7, 1.)*(max(volt - fyt, 0.) + max(volt - fxl, 0.)\n                             + max(volt - fxr, 0.) + max(volt - fyb, 0.))*ssl;\n    // draw the triangle\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dtri)-0.01);\n    // draw the ellipse\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dellipse)-0.005);\n    // draw the medians\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dlines)-0.002);\n    // draw the segment connecting the foci\n    col = mix(col, vec3(0.91, 0.1, 0.1), 1.-smoothstep(0., 0.005+2.*sf, dseg(p, foci[0], foci[1])-0.01));\n\n    // decorate the vertices and foci\n    vec2[3] verts; verts[0] = A; verts[1] = B; verts[2] = C;\n    float lw = 0.02;\n\n    for (int i=0; i<3; i++)\n    {\n        float dv = length(p - verts[i]) - .12;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(1, .7, .6), 1. - smoothstep(0., sf, dv + lw*1.6));\n        float cro = sdCross(p - verts[i], vec2(0.06, 0.012), 0.01);\n        cro = abs(cro);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, cro - lw));\n    }\n    for (int i=0; i<2; i++)\n    {\n        float dv = length(p - foci[i]) - .07;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(.4, .6, 1.), 1. - smoothstep(0., sf, dv + lw*1.2));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .075 - lw));\n    }\n    \n    col *= 1.25 - 0.2*length(p);\n    \n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lf3Wn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 251, 299, 695], [697, 783, 806, 806, 838], [840, 840, 888, 888, 1097], [1100, 1100, 1130, 1130, 1491], [1493, 1493, 1518, 1518, 1553], [1555, 1555, 1576, 1576, 1638], [1640, 1640, 1667, 1667, 1720], [1722, 1722, 1742, 1742, 1830], [1832, 1885, 1921, 1921, 2035], [2037, 2079, 2146, 2146, 2773], [2775, 2811, 2873, 2873, 3041], [3043, 3043, 3133, 3133, 3583], [3585, 3585, 3640, 3640, 3907]]}
{"id": "7tfGDn", "name": "Green Mercury", "author": "dr2", "description": "Metallic slime (mercury?) in channels formed by random rectangular tiling (mouseable, click upper-right for new run)", "tags": ["collision", "metaballs", "dynamics", "physics"], "likes": 13, "viewed": 358, "published": 3, "date": "1621872912", "time_retrieved": "2024-07-30T19:19:08.607262", "image_code": "// \"Green Mercury\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// (Mix of \"Channeling Slime\" and \"Marble Paths\")\n\nfloat PrSphDf (vec3 p, float r);\nfloat Minv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nmat3 DirVuMat (vec3 vd);\nfloat Hashfv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\n#define VAR_ZERO min (iFrame, 0)\n\n\nconst int nBall = 60;\nvec3 vnObj, ltDir;\nfloat tCur, dstFar, surfHt, surfScl;\nint idBall;\nconst float pi = 3.1415927;\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = Hashfv2 (ip);\n  hm = vec4 (Hashfv2 (ip + e.zy), Hashfv2 (ip + e.xy), Hashfv2 (ip + e.yz), Hashfv2 (ip + e.yx));\n  hc = vec4 (Hashfv2 (ip + e.zz), Hashfv2 (ip + e.xx), Hashfv2 (ip + e.xz), Hashfv2 (ip + e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++) \n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nfloat SurfRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  s = - (ro.y - surfHt) / rd.y;\n  sLo = s;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + s * rd;\n    h = p.y - SurfHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.2, 0.4 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > SurfHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float d;\n  d = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++)\n     d = SmoothMin (d, PrSphDf (p - Loadv4 (3 * n).xyz, 0.45), 2.);\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, bgCol;\n  float dstObj, dstSurf, sh, nDotL;\n  bgCol = vec3 (0.6, 0.6, 0.55);\n  dstObj = ObjRay (ro, rd);\n  dstSurf = (rd.y < 0.) ? SurfRay (ro, rd) : dstFar;\n  col = bgCol;\n  if (min (dstObj, dstSurf) < dstFar) {\n    sh = 1.;\n    if (dstObj < dstSurf) {\n      ro += dstObj * rd;\n      col4 = vec4 (0.7, 0.8, 0.2, 0.3);\n      vn = ObjNf (ro);\n    } else {\n      ro += dstSurf * rd;\n      col4 = vec4 (mix (vec3 (0.4, 0.3, 0.2), vec3 (0.6, 0.6, 0.5),\n         smoothstep (0., 0.1, ro.y)), 0.05);\n      vn = VaryNf (2. * ro, SurfNf (ro), 1. - smoothstep (0.5, 0.7, dstSurf / dstFar));\n      sh = ObjSShadow (ro + 0.01 * ltDir, ltDir);\n    }\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (dstObj < dstSurf) nDotL *= nDotL;\n    col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    col = mix (bgCol, col, min (1., exp2 (8. * (1. - 1.2 * min (dstObj, dstSurf) / dstFar))));\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA    0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr, bMid;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float az, el, asp, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (3 * nBall + 0);\n  surfHt = stDat.x;\n  surfScl = stDat.y;\n  mPtr.xyz = Loadv4 (3 * nBall + 1).xyz;\n  if (mPtr.z > 0. && Minv2 (mPtr.xy + 0.05 * vec2 (1. / asp, 1.) - 0.5) < 0.) {\n    az = -2. * pi * mPtr.x;\n    el = -0.5 * pi * mPtr.y;\n  } else {\n    az = 0.;\n    el = 0.;\n  }\n  az -= 0.01 * pi * tCur;\n  el = clamp (el + pi * (0.17 + 0.1 * sin (0.031 * pi * tCur)), 0.05 * pi, 0.4 * pi);\n  bMid = Loadv4 (3 * nBall + 2);\n  ro = bMid.xyz + min (5. * bMid.w, 120.) * vec3 (cos (el) * sin (az + vec2 (0.5 * pi, 0.)), 2. * sin (el)).xzy;\n  vuMat = DirVuMat (normalize (bMid.xyz - ro));\n  zmFac = 4.;\n  dstFar = 250.;\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && Minv2 (uv - vec2 (asp, 1.)) > -0.1) col = mix (col, vec3 (1., 0.3, 0.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}  \n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Green Mercury\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 60;\nfloat todCur, nStep, surfHt, surfScl;\nconst float pi = 3.14159;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = Hashfv2 (ip);\n  hm = vec4 (Hashfv2 (ip + e.zy), Hashfv2 (ip + e.xy), Hashfv2 (ip + e.yz), Hashfv2 (ip + e.yx));\n  hc = vec4 (Hashfv2 (ip + e.zz), Hashfv2 (ip + e.xx), Hashfv2 (ip + e.xz), Hashfv2 (ip + e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++) \n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (3 * mId).xyz;\n  vm = Loadv4 (3 * mId + 1).xyz;\n  wm = Loadv4 (3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (3 * n + 1).xyz;\n      wmN = Loadv4 (3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    am += ((n / (nBall / 5) == mId / (nBall / 5) && abs (float (n - mId)) <= 1.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, bMid;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, b;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 1.6;\n  surfScl = 0.125;\n  mId = (pxId < 3 * nBall) ? pxId / 3 : -1;\n  doInit = (iFrame <= 5);\n  if (! doInit) {\n    nStep = Loadv4 (3 * nBall).z;\n    ++ nStep;\n    mPtrP.z = Loadv4 (3 * nBall + 1).z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId == 3 * nBall + 2) {\n    bMid = vec4 (0.);\n    for (int n = VAR_ZERO; n < nBall; n ++) {\n      b = Loadv4 (3 * n).xz;\n      bMid.xzw += vec3 (b, dot (b, b));\n    }\n    bMid.xz /= float (nBall);\n    bMid.y = 0.1;\n    bMid.w = sqrt (max (bMid.w / float (nBall) - dot (bMid.xz, bMid.xz), 0.));\n  }\n  if (pxId < 3 * nBall) {\n    kp = 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 3 * nBall;\n    if      (pxId == kp + 0) stDat = vec4 (surfHt, surfScl, nStep, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, 0.);\n    else if (pxId == kp + 2) stDat = bMid;\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Green Mercury\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 60;\nfloat todCur, nStep, surfHt, surfScl;\nconst float pi = 3.14159;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = Hashfv2 (ip);\n  hm = vec4 (Hashfv2 (ip + e.zy), Hashfv2 (ip + e.xy), Hashfv2 (ip + e.yz), Hashfv2 (ip + e.yx));\n  hc = vec4 (Hashfv2 (ip + e.zz), Hashfv2 (ip + e.xx), Hashfv2 (ip + e.xz), Hashfv2 (ip + e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++) \n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (3 * mId).xyz;\n  vm = Loadv4 (3 * mId + 1).xyz;\n  wm = Loadv4 (3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (3 * n + 1).xyz;\n      wmN = Loadv4 (3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    am += ((n / (nBall / 5) == mId / (nBall / 5) && abs (float (n - mId)) <= 1.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, bMid;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, b;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 1.6;\n  surfScl = 0.125;\n  mId = (pxId < 3 * nBall) ? pxId / 3 : -1;\n  doInit = (iFrame <= 5);\n  if (! doInit) {\n    nStep = Loadv4 (3 * nBall).z;\n    ++ nStep;\n    mPtrP.z = Loadv4 (3 * nBall + 1).z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId == 3 * nBall + 2) {\n    bMid = vec4 (0.);\n    for (int n = VAR_ZERO; n < nBall; n ++) {\n      b = Loadv4 (3 * n).xz;\n      bMid.xzw += vec3 (b, dot (b, b));\n    }\n    bMid.xz /= float (nBall);\n    bMid.y = 0.1;\n    bMid.w = sqrt (max (bMid.w / float (nBall) - dot (bMid.xz, bMid.xz), 0.));\n  }\n  if (pxId < 3 * nBall) {\n    kp = 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 3 * nBall;\n    if      (pxId == kp + 0) stDat = vec4 (surfHt, surfScl, nStep, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, 0.);\n    else if (pxId == kp + 2) stDat = bMid;\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Green Mercury\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 60;\nfloat todCur, nStep, surfHt, surfScl;\nconst float pi = 3.14159;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = Hashfv2 (ip);\n  hm = vec4 (Hashfv2 (ip + e.zy), Hashfv2 (ip + e.xy), Hashfv2 (ip + e.yz), Hashfv2 (ip + e.yx));\n  hc = vec4 (Hashfv2 (ip + e.zz), Hashfv2 (ip + e.xx), Hashfv2 (ip + e.xz), Hashfv2 (ip + e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++) \n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (3 * mId).xyz;\n  vm = Loadv4 (3 * mId + 1).xyz;\n  wm = Loadv4 (3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (3 * n + 1).xyz;\n      wmN = Loadv4 (3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    am += ((n / (nBall / 5) == mId / (nBall / 5) && abs (float (n - mId)) <= 1.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, bMid;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, b;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 1.6;\n  surfScl = 0.125;\n  mId = (pxId < 3 * nBall) ? pxId / 3 : -1;\n  doInit = (iFrame <= 5);\n  if (! doInit) {\n    nStep = Loadv4 (3 * nBall).z;\n    ++ nStep;\n    mPtrP.z = Loadv4 (3 * nBall + 1).z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId == 3 * nBall + 2) {\n    bMid = vec4 (0.);\n    for (int n = VAR_ZERO; n < nBall; n ++) {\n      b = Loadv4 (3 * n).xz;\n      bMid.xzw += vec3 (b, dot (b, b));\n    }\n    bMid.xz /= float (nBall);\n    bMid.y = 0.1;\n    bMid.w = sqrt (max (bMid.w / float (nBall) - dot (bMid.xz, bMid.xz), 0.));\n  }\n  if (pxId < 3 * nBall) {\n    kp = 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 3 * nBall;\n    if      (pxId == kp + 0) stDat = vec4 (surfHt, surfScl, nStep, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, 0.);\n    else if (pxId == kp + 2) stDat = bMid;\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Green Mercury\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Maxv2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 60;\nfloat todCur, nStep, surfHt, surfScl;\nconst float pi = 3.14159;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat RandRect (vec2 p)\n{\n  vec4 hm, hc;\n  vec3 e;\n  vec2 pMid[4], pEdge[4], ip;\n  float dMin, hp, eFac;\n  ip = floor (p) + 0.5;\n  e = vec3 (-1., 0., 1.);\n  hp = Hashfv2 (ip);\n  hm = vec4 (Hashfv2 (ip + e.zy), Hashfv2 (ip + e.xy), Hashfv2 (ip + e.yz), Hashfv2 (ip + e.yx));\n  hc = vec4 (Hashfv2 (ip + e.zz), Hashfv2 (ip + e.xx), Hashfv2 (ip + e.xz), Hashfv2 (ip + e.zx));\n  if (mod (ip.x + ip.y, 2.) < 0.5) {\n    pEdge[0] = vec2 (hm.z - hm.y, hc.z - hp);\n    pEdge[1] = vec2 (hm.x - hm.z, hc.x - hp);\n    pEdge[2] = vec2 (hm.x - hm.w, hp - hc.w);\n    pEdge[3] = vec2 (hm.w - hm.y, hp - hc.y);\n    pMid[0] = vec2 (hm.z, hp);\n    pMid[1] = pMid[0];\n    pMid[2] = vec2 (hm.w, hp);\n    pMid[3] = pMid[2];\n  } else {\n    pEdge[0] = vec2 (hp - hc.z, hm.z - hm.y);\n    pEdge[1] = vec2 (hc.x - hp, hm.z - hm.x);\n    pEdge[2] = vec2 (hc.w - hp, hm.x - hm.w);\n    pEdge[3] = vec2 (hp - hc.y, hm.y - hm.w);\n    pMid[0] = vec2 (hp, hm.y);\n    pMid[1] = vec2 (hp, hm.x);\n    pMid[2] = pMid[1];\n    pMid[3] = pMid[0];\n  }\n  eFac = 0.3;\n  for (int k = 0; k < 4; k ++) {\n    pEdge[k] = eFac * pEdge[k] + 0.5;\n    pMid[k] = 2. * eFac * (pMid[k] - 0.5);\n  }\n  pMid[0] += pEdge[0] * e.xz;\n  pMid[1] += pEdge[1] * e.zz;\n  pMid[2] += pEdge[2] * e.zx;\n  pMid[3] += pEdge[3] * e.xx;\n  dMin = 1e6;\n  for (int k = 0; k < 4; k ++) \n     dMin = min (dMin, length (max (abs (p - ip - pMid[k]) - pEdge[k] + eFac - 0.05, 0.)) - 0.01);\n  return dMin;\n}\n\nfloat SurfHt (vec2 p)\n{\n  return surfHt * (1. - smoothstep (0., 0.2, RandRect (surfScl * p)));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.5;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (3 * mId).xyz;\n  vm = Loadv4 (3 * mId + 1).xyz;\n  wm = Loadv4 (3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (3 * n + 1).xyz;\n      wmN = Loadv4 (3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    am += ((n / (nBall / 5) == mId / (nBall / 5) && abs (float (n - mId)) <= 1.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (Rot2D (vec2 (fPull, 0.), pi * (0.25 + 0.1 * sin (0.001 * nStep))),\n     - grav).xzy - fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = 0.7 * mIdf * vec2 (1., -1.) + 35. * mod (todCur, 10.);\n  rm.y = surfHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, bMid;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, b;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  surfHt = 1.6;\n  surfScl = 0.125;\n  mId = (pxId < 3 * nBall) ? pxId / 3 : -1;\n  doInit = (iFrame <= 5);\n  if (! doInit) {\n    nStep = Loadv4 (3 * nBall).z;\n    ++ nStep;\n    mPtrP.z = Loadv4 (3 * nBall + 1).z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId == 3 * nBall + 2) {\n    bMid = vec4 (0.);\n    for (int n = VAR_ZERO; n < nBall; n ++) {\n      b = Loadv4 (3 * n).xz;\n      bMid.xzw += vec3 (b, dot (b, b));\n    }\n    bMid.xz /= float (nBall);\n    bMid.y = 0.1;\n    bMid.w = sqrt (max (bMid.w / float (nBall) - dot (bMid.xz, bMid.xz), 0.));\n  }\n  if (pxId < 3 * nBall) {\n    kp = 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 3 * nBall;\n    if      (pxId == kp + 0) stDat = vec4 (surfHt, surfScl, nStep, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (mPtr.xyz, 0.);\n    else if (pxId == kp + 2) stDat = bMid;\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfGDn.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[570, 570, 595, 595, 1991], [1993, 1993, 2016, 2016, 2089], [2091, 2091, 2125, 2125, 2653], [2655, 2655, 2677, 2677, 2816], [2818, 2818, 2840, 2840, 2989], [2991, 2991, 3024, 3024, 3207], [3209, 3209, 3230, 3230, 3480], [3482, 3482, 3519, 3519, 3762], [3764, 3764, 3799, 3799, 4811], [4830, 4830, 4886, 4886, 6368], [6370, 6370, 6403, 6403, 6430], [6432, 6432, 6454, 6454, 6481], [6483, 6483, 6528, 6528, 6620], [6624, 6624, 6654, 6654, 6767], [6769, 6769, 6794, 6794, 6963], [6997, 6997, 7021, 7021, 7081], [7083, 7083, 7107, 7107, 7219], [7221, 7221, 7246, 7246, 7432], [7434, 7434, 7463, 7463, 7675], [7677, 7677, 7716, 7716, 7968], [8062, 8062, 8087, 8087, 8210]]}
{"id": "stfGDn", "name": "Jewel room", "author": "butadiene", "description": "2 hour coding\nhttps://www.youtube.com/watch?v=LlR4BXY3cWg", "tags": ["raymarching"], "likes": 6, "viewed": 452, "published": 3, "date": "1621872034", "time_retrieved": "2024-07-30T19:19:09.357257", "image_code": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\n#define T iTime\n\nconst float PI = 3.141592;\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat box2d(vec2 p,vec2 s){\n  vec2 q = abs(p);\n  vec2 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(m.x,m.y);\n}\n\nfloat crobox(vec3 p,float sca){\n  float dx = box2d(p.yz,vec2(sca));\n  float dy = box2d(p.xz,vec2(sca));\n  float dz = box2d(p.xy,vec2(sca));\n  return min(min(dx,dy),dz);\n}\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(m.z,min(m.x,m.y));\n}\n\nfloat ease(float t,float k){\n  return -exp(-1.0*mod(t,k))+floor(t/k);\n}\n\nvec4 nanika(vec3 p){\n  float kt =T;/// 2.*ease(time*2.,3.);\n  p.xz *= rot(kt);\n  p.yz *= rot(kt);\n  vec3 acol = vec3(0.);\n  float sct = 0.23;\n  vec3 col1 = vec3(0.6,0.6,0.2);\n  vec3 col2 = vec3(0.2,0.6,0.6);\n  vec3 col3 = vec3(0.6,0.6,0.2);\n  for(int i = 0;i<8;i++){\n    p = abs(p)-0.2;\n    p.xy *= rot(sct);\n    p.xz *= rot(sct);\n    p.yz *= rot(sct);\n    if(p.x<p.y&&p.x<p.z){acol += col1;}\n    else if(p.y<p.z){acol += col2;}\n    else{acol += col3;}\n  }\n  \n  float d = length(p)-0.2;\n  d = crobox(p,0.05);\n  vec3 col =1.*acol*exp(-3.0*d);\n  return vec4(col,d);\n}\n\nvec4 yuka(vec3 p,float t){\n  p.y -= 0.;\n  p.z += T*10.;\n  float k = 1.5;\n  float sc = k*40.;\n  float rsc = 0.2;\n  \n  p.y = -abs(p.y);\n  \n  float xzmod = 80.0;\n  p.xz = mod(p.xz,xzmod)-0.5*xzmod;\n  vec3 acol = vec3(0);\n  for(int i = 0;i<7;i++){\n    p.xz = abs(p.xz)-sc;\n    sc *= 0.5;\n    p.xy *= rot(rsc);\n    p.zy *= rot(rsc);\n    p.xz *= rot(0.3);\n    if(p.x<p.z){ acol += vec3(0.2,0.6,0.8);}\n    else{acol += vec3(0.6,0.2,0.5); }\n  }\n  \n\n  float size = k*0.5-0.1;\n  float d = box(p,vec3(size,10.,size));\n  vec3 col = vec3(0);\n  return vec4(2.2*acol*exp(-1.0*d)*exp(-0.08*t),d);\n}\n\nvec4 dist(vec3 p,float totalt){\n  float k = 0.6;\n  //p = mod(p,k)-0.5*k;\n  float scy = 1.0;\n  vec4 yukad = yuka(p*scy,totalt)/scy;\n  float scn = 0.6;\n  vec4 nanikad = nanika(p*scn);\n  float d = min(nanikad.w/scn,yukad.w);\n  vec3 col = nanikad.xyz;\n  col += yukad.xyz;\n  return vec4(col,d);\n}\n\nvec3 gn(vec3 p){\n  vec2 e = vec2(0.001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy,1.).w-dist(p-e.xyy,1.).w,\n    dist(p+e.yxy,1.).w-dist(p-e.yxy,1.).w,\n    dist(p+e.yyx,1.).w-dist(p-e.yyx,1.).w\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){vec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\nvec2 uv = gl_FragCoord.xy/r;\n\nfloat ra = 14.0;\nfloat kt = T*0.3;\nvec3 ro = vec3(ra*cos(kt),6.,ra*sin(kt));\nvec3 ta = vec3(0);\n\nvec3 cdir = normalize(ta-ro);\nvec3 side = cross(cdir,vec3(0,1,0));\nvec3 up = cross(side,cdir);\nvec3 rd = normalize(side*p.x+cdir*0.8+up*p.y);\n\nfloat d,t= 0.;\nfloat es = 0.0001;\nvec3 ac = vec3(0.);\nfor(int i = 0;i<76;i++){\n  vec4 rsd = dist(ro+rd*t,t);\n  d = rsd.w;\n  t += d;\n  ac += rsd.xyz;\n  if(d<es)break;\n}\n\nvec3 col = vec3(0);\ncol = ac*0.01;\n\nif(yuka(ro+rd*t,1.).w<es){\n  vec3 sro =ro;\n  vec3 srd =rd;\n  vec3 sp = ro+rd*t;\n  vec3 normal = gn(sp);\n  rd = reflect(rd,normal);\n  ro = sp;\n  t = 0.01;\n  ac = vec3(0.);\n  for(int i = 0;i<36;i++){\n    vec4 rsd = dist(ro+rd*t,length(rd*t+sp));\n    d = rsd.w;\n    t += d;\n    \n    ac += rsd.xyz;\n    if(d<es)break;\n  }\n  col += 0.01*ac;\n}\n\n\n\nfloat et = 0.1/abs(uv.y*4.-ease(uv.x*16.,4.));\ncol = 1.2*pow(col,vec3(1.2));\nfragColor=vec4(col,1);}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfGDn.jpg", "access": "api", "license": "mit", "functions": [[160, 160, 178, 178, 225], [227, 227, 254, 254, 342], [344, 344, 375, 375, 514], [516, 516, 541, 541, 638], [640, 640, 668, 668, 711], [713, 713, 733, 733, 1278], [1280, 1280, 1306, 1306, 1862], [1864, 1864, 1895, 1895, 2155], [2157, 2157, 2173, 2173, 2363], [2365, 2365, 2421, 2421, 3395]]}
{"id": "NtXGDr", "name": "Bunch of fish in noisy water", "author": "ahmaderfani12", "description": "My practice of using noises. ", "tags": ["noise", "gradient", "gradientnoise"], "likes": 3, "viewed": 718, "published": 3, "date": "1621858646", "time_retrieved": "2024-07-30T19:19:10.210974", "image_code": "vec2 random2d(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n// Gradient Noise by Inigo Quilez\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2d(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2d(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2d(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2d(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 scale2d(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat circle(vec2 st,float r,vec2 pos,vec2 scale){\n    st -=pos;\n    st = scale2d(scale) * st;\n    st +=pos;\n    \n    float dist = distance(st,pos);\n    dist = smoothstep(r,r+0.003,dist);\n    return dist;\n}\n\nfloat square(vec2 st, float size, vec2 pos,vec2 scale, float angle){\n    st +=pos;\n    st = scale2d(scale) * st;\n    st=rotate2d(angle) * st;\n   \n    float b = smoothstep((size),(size+0.003),abs(st.x))+  smoothstep((size),(size+0.003),abs(st.y));\n    return (clamp(b,0.0,1.));\n}\n\nvec3 fish(vec2 st,float size,vec2 pos, vec3 colorTint){\n\t\n    float time = iTime/2. * random(pos.x)*2.;\n   \t\n    float y=abs(sin(time*1.57)) * (floor(sin(time*3.14))+1.)*1.2 -0.1;\n  \t\n    pos.y=y;\n    \n   float col = circle(st,size,pos,vec2(0.910,0.480)) * ( square(st,size/1.2,1. -pos + vec2(-1.,-0.98),vec2(0.850,0.40),0.78));    \n    col = 1. - col;\n    return col * colorTint;\n}\n\nvec3 drawFishes(vec2 st){\n    vec3 fishes = vec3(0.0);\n    for(int i = 0; i <= 200; i++) { \n        fishes +=vec3(fish(st,0.005,vec2(random(float(i))*2.,0.0),vec3(0.660,0.010,0.073)));   \n    }\n   return fishes;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  //Adjust uv\n    vec2 st = fragCoord/iResolution.xy;\n    st.x *=  iResolution.x/iResolution.y;\n    \n    //St scaler\n    float gridMultiplier=10.;\n    \n    //Fish and water colors\n    vec3 color = vec3(0.0);\n\tvec3 colorA=vec3(0.017,0.037,0.975);\n    vec3 colorB=vec3(0.379,1.000,0.962);\n    \n    //Set uvs(st)\n    st *=gridMultiplier;\n     vec2 fishSt= st+(noise(st+(iTime*1.0)))/3.;\n\tst += noise(st+vec2(0.0,-iTime*2.2));  \n    \n    //Get noise for water\n    float waterWave = noise(st)*0.5 + 0.5;\n    \n    color =  mix(colorA, colorB, waterWave);\n    color  = color +  drawFishes(fishSt/gridMultiplier) ;\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXGDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 162], [163, 163, 190, 190, 222], [223, 257, 279, 279, 687], [689, 689, 715, 715, 778], [779, 779, 807, 807, 893], [895, 895, 945, 945, 1101], [1103, 1103, 1171, 1171, 1381], [1383, 1383, 1438, 1438, 1765], [1767, 1767, 1792, 1792, 1980], [1982, 1982, 2039, 2053, 2681]]}
{"id": "7tlGz7", "name": "Terrain Water Demo", "author": "milesWaugh", "description": "Just a little test", "tags": ["test", "simple", "terrain", "water"], "likes": 10, "viewed": 510, "published": 3, "date": "1621846774", "time_retrieved": "2024-07-30T19:19:11.058708", "image_code": "vec3 tex(vec2 c) {\n    return textureLod(iChannel0, c / iResolution.xy, 0.0).rgb;\n}\n\nvec3 gl(vec3 z) {\n    return vec3(z.x * z.x, z.y * z.y, z.z * z.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 fc = tex(fragCoord);\n    \n    for(int i = -3; i < 4; i++) {\n        fc += gl(tex(fragCoord + vec2(i, 0)) / (abs(float(i)) + 1.));\n    }\n    for(int i = -3; i < 4; i++) {\n        fc += gl(tex(fragCoord + vec2(0, i)) / (abs(float(i)) + 1.));\n    }\n    \n    fc *= 1.6;\n    fc = fc / (fc + vec3(1.));\n    fc *= 1.0;\n    fc = smoothstep(0., 1., fc);\n    fc = vec3(sqrt(fc.r), sqrt(fc.g), sqrt(fc.b));\n    fc = max(fc, 0.);\n    \n    fragColor = vec4(fc, 0.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define s sqrt(.5)\n#define l normalize(vec3(0.5,0.4,1))\n#define pi 3.141592653589793\n#define cam vec3(0.,0.,iTime)\n\n//DAVE HOSKINS' HASH FUNCTIONS\n//https://www.shadertoy.com/view/4djSRW\nvec3 rnd32(vec2 p) {\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nfloat rnd12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 rnd23(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n//Thanks to Inigo for helping me a bunch with the artifacts created \n//when I was using the built-in noise textures!\nvec3 textu(sampler2D sam, vec2 uv) {\n    ivec2 res = textureSize(sam, 0).xy;\n    uv = uv * vec2(res) - 0.5;\n    ivec2 iuv = ivec2(floor(uv));\n    vec2 f = fract(uv);\n    f = f * f * (3.0 - 2.0 * f);\n    vec4 rg1 = texelFetch(sam, (iuv + ivec2(0, 0)) & (res - 1), 0);\n    vec4 rg2 = texelFetch(sam, (iuv + ivec2(1, 0)) & (res - 1), 0);\n    vec4 rg3 = texelFetch(sam, (iuv + ivec2(0, 1)) & (res - 1), 0);\n    vec4 rg4 = texelFetch(sam, (iuv + ivec2(1, 1)) & (res - 1), 0);\n    return mix(mix(rg1, rg2, f.x), mix(rg3, rg4, f.x), f.y).rgb;\n}\n\nfloat tex(vec3 z) {\n    z += cam;\n    float t = 0.;\n    for(int i = 0; i < 10; i++) {\n        float p = 2.;\n        float p2 = pow(2.5, float(i));\n        vec2 pos = pow(p, float(i)) * z.xz / 30.;\n        pos += p2 / 1000.;\n        pos *= 20.;\n        /*pos*=512.;\n        pos.x = sin(pi*(fract(pos.x)-.5))*.5+floor(pos.x)+0.5;\n        pos.y = sin(pi*(fract(pos.y)-.5))*.5+floor(pos.y)+0.5;\n        pos/=512.;\n        t += textu(iChannel0,pos).r/p2;*/\n        float pff = rnd12(vec2(floor(pos.x), floor(pos.y)));\n        float pcf = rnd12(vec2(ceil(pos.x), floor(pos.y)));\n        float pfc = rnd12(vec2(floor(pos.x), ceil(pos.y)));\n        float pcc = rnd12(vec2(ceil(pos.x), ceil(pos.y)));\n        float pxf = mix(pff, pcf, smoothstep(0., 1., fract(pos.x)));\n        float pxc = mix(pfc, pcc, smoothstep(0., 1., fract(pos.x)));\n        t += mix(pxf, pxc, smoothstep(0., 1., fract(pos.y))) / p2;\n    }\n    return t;\n}\n\nfloat tex2(vec3 z) {\n    z += cam;\n    z *= 50.;\n    float t = 0.;\n    \n    for(int i = 0; i < 5; i++) {\n        float p = 2.;\n        float p2 = pow(2.5, float(i));\n        vec2 pos = pow(p, float(i)) * z.xz / 30.;\n        pos += p2 / 1000.;\n        pos *= 26.;\n        /*pos*=512.;\n        pos.x = sin(pi*(fract(pos.x)-.5))*.5+floor(pos.x)+0.5;\n        pos.y = sin(pi*(fract(pos.y)-.5))*.5+floor(pos.y)+0.5;\n        pos/=512.;\n        t += textu(iChannel0,pos).r/p2;*/\n        float pff = rnd12(vec2(floor(pos.x), floor(pos.y)));\n        float pcf = rnd12(vec2(ceil(pos.x), floor(pos.y)));\n        float pfc = rnd12(vec2(floor(pos.x), ceil(pos.y)));\n        float pcc = rnd12(vec2(ceil(pos.x), ceil(pos.y)));\n        float pxf = mix(pff, pcf, smoothstep(0., 1., fract(pos.x)));\n        float pxc = mix(pfc, pcc, smoothstep(0., 1., fract(pos.x)));\n        t += mix(pxf, pxc, smoothstep(0., 1., fract(pos.y))) / p2;\n    }\n    \n    return t;\n}\n\nvec3 albedo(vec3 n, vec3 z) {\n    return vec3(0.5, (pow(n.y, 10.) + tex2(z) * 0.35 - 0.3) * .5 + 0.25, 0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 pcol = texture(iChannel1, fragCoord / iResolution.xy);\n    vec2 uv = 2. * ((fragCoord + rnd23(vec3(fragCoord.xy, iTime))) - iResolution.xy * .5) / iResolution.x;\n    vec3 inc = normalize(vec3(uv, 1.));\n    inc = vec3(inc.x, inc.y * s - inc.z * s, inc.z + inc.y);\n    float raylength = 0.;\n    vec3 z = vec3(0.);\n    int iters = 0;\n    float sdf = 1.;\n    vec3 n, nr;\n    bool pass = false;\n    float rw = 0.;\n    vec3 zo;\n    vec3 incr = inc;\n    float ter, wat;\n    bool inter = false;\n    \n    while(iters < 500) {\n        iters++;\n        float t = tex(z);\n        ter = z.y - (t * 0.8 - 2.25);\n        wat = z.y + 1.5;\n        float d = 0.0001;\n        bool terbol = abs(sdf - ter) < 0.00001;\n        \n        if(pass) {\n            sdf = ter;\n            if(abs(sdf) < 0.001 || iters > 128 || raylength > 10.) {\n                float t2 = tex(z + vec3(0., 0., d));\n                float t4 = tex(z + vec3(d, 0., 0.));\n                n = normalize(vec3(t - t4, d, t - t2));\n                inter = true;\n                break;\n            }\n        } else {\n            sdf = min(ter, wat);\n            rw = raylength;\n            if(abs(sdf) < 0.000001 || iters > 128 || raylength > 10.) {\n                if(terbol) {\n                    float t2 = tex(z + vec3(0., 0., d));\n                    float t4 = tex(z + vec3(d, 0., 0.));\n                    n = normalize(vec3(t - t4, d, t - t2));\n                    inter = false;\n                    break;\n                } else {\n                    pass = true;\n                    float t5 = tex2(z);\n                    float t6 = tex2(z + vec3(0.0002, 0., 0.));\n                    float t7 = tex2(z + vec3(0., 0., 0.0002));\n                    vec3 n2 = normalize(vec3(t6 - t5, 0.001, t7 - t5));\n                    nr = normalize(vec3(0., 1., 0.) + n2 / 32.);\n                    zo = z;\n                    incr = inc;\n                    inc = refract(inc, nr, 0.7);\n                    inter = true;\n                    if(inc == vec3(0.)) {\n                        break;\n                    }\n                }\n            }\n        }\n        \n        raylength += sdf * (terbol ? 1. : .9);\n        z = pass ? inc * (raylength - rw) + zo : inc * raylength;\n    }\n    \n    vec3 nre;\n    incr = normalize(incr);\n    vec3 refl = reflect(incr, nr);\n    \n    if(inter) {\n        iters = 0;\n        sdf = 1.;\n        float rayr = .001;\n        vec3 camp = zo;\n        z = camp + refl * rayr;\n        \n        while(iters < 500) {\n            iters++;\n            float t = tex(z);\n            ter = z.y - (t * 0.8 - 2.25);\n            float d = 0.0001;\n            sdf = ter;\n            \n            if(abs(sdf) < 0.001) {\n                float t2 = tex(z + vec3(0., 0., d));\n                float t4 = tex(z + vec3(d, 0., 0.));\n                nre = normalize(vec3(t - t4, d, t - t2));\n                break;\n            }\n            if(rayr > 10. || iters > 128) {\n                nre = vec3(0.);\n                break;\n            }\n            \n            rayr += sdf * .9;\n            z = refl * rayr + camp;\n        }\n    }\n    \n    vec3 li = vec3(1., .7, .35);\n    vec3 am = vec3(0.6, 0.8, 1.);\n    float rd = (raylength - rw) * 100.;\n    vec3 r = reflect(incr, nr);\n    float fresnel = 1. + dot(incr, nr);\n    fresnel = 0.05 + 0.95 * fresnel * fresnel * fresnel * fresnel * fresnel;\n    vec3 spec = vec3(max(dot(r, l), 0.));\n    spec = vec3(pow(spec.x, 250.) * 30. * fresnel * li);\n    vec3 absorb = vec3(exp(-rd), exp(-rd * 0.2), exp(-rd * 0.1));\n    float scatter = exp(-raylength * .033);\n    float lambert = max(dot(n, l), 0.);\n    \n    if(inter) {\n        if(dot(nre, nre) > 0.5) {\n            spec = (am * .08 + lambert * 2. * vec3(1., 0.9, 0.7)) * albedo(n, z) * fresnel;\n        } else {\n            spec = fresnel * (am * .8 + 5. * spec * li);\n        }\n    } else {\n        spec += lambert * lambert * lambert * lambert * .5 * vec3(1., 0.9, 0.7) * fresnel;\n    }\n    \n    vec3 dif = (am * .08 + li * lambert * 2.5) * albedo(n, z);\n    vec3 col = dif * absorb + spec;\n    col = vec3(max(col.r, 0.), max(col.g, 0.), max(col.b, 0.));\n    col = mix(am, col, scatter);\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 83], [85, 85, 102, 102, 154], [156, 156, 211, 211, 675]]}
{"id": "7ll3R7", "name": "MNCA Example 0", "author": "SlackermanzCA", "description": "\n", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 9, "viewed": 1332, "published": 3, "date": "1621827037", "time_retrieved": "2024-07-30T19:19:11.816681", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bufA = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = bufA;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n\nconst uint MAX_NH_SIZE = 16u;\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat tp(uint n, float s) {\n\t\t\tfloat\tpscale\t= s * 0.5;\nreturn (float(n+1u)/256.0) * (pscale/128.0); }\n    \nfloat gdv(ivec2 off, sampler2D tx, int v) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n\tivec4\tdm\t\t= ivec4(iResolution.x,iResolution.y,1,0);\n\tvec4 \tfc \t\t= gl_FragCoord;\n\tvec2\tdc\t\t= vec2( dm[0]/dm[2], dm[1]/dm[2] );\n\tfloat\tcx\t\t= mod(fc[0]+float(off[0]), dc[0]) + floor(fc[0]/dc[0])*dc[0];\n\tfloat\tcy\t\t= mod(fc[1]+float(off[1]), dc[1]) + floor(fc[1]/dc[1])*dc[1];\n\tvec4 \tpxdata \t= texelFetch( txdata, ivec2(cx, cy), 0);\n\treturn \tpxdata[v]; }\n\nvec2 ring( vec2 r, sampler2D tx, int c ) {\n\tconst\tfloat\tw = 1.0; // atan(1.0*(1.0-(d*PI)/r));\n\tconst\tuint\ttmx = 65536u;\n//\tconst\tuint\tchk = 2147483648u / (\n//\t\t\t\t\t( \tuint(float(r[0])*float(r[0])*PI + float(r[0])*PI + PI\t)\n//\t\t\t\t\t- \tuint(float(r[1])*float(r[1])*PI + float(r[1])*PI\t\t) ) * 128 );\n//\tconst\tfloat\tpsn = (chk >= tmx) ? float(tmx) : float(chk);\n\tconst\tfloat\tpsn = float(tmx);\n\t\t\tfloat \td = 0.0;\n\t\t\tfloat \ta = 0.0;\n\t\t\tfloat \tb = 0.0;\n\t\t\tfloat\tt = 0.0;\n\tfor(float i = -r[0]; i <= r[0]; i+=1.0) {\n\t\tfor(float j = -r[0]; j <= r[0]; j+=1.0) {\n\t\t\td = round(sqrt(i*i+j*j));\n\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\tt  = gdv( ivec2(i,j), tx, c ) * w * psn;\n\t\t\t\ta += t - fract(t);\n\t\t\t\tb += w * psn; } } }\n\treturn vec2(a, b); }\n                \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(int seed) {\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1],  2.0, 19.0 + mod(iDate[3]+float(seed),17.0), 23.0 + mod(iDate[3]+float(seed),43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 14.0, 13.0 + mod(iDate[3]+float(seed),29.0), 17.0 + mod(iDate[3]+float(seed),31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1],  6.0, 13.0 + mod(iDate[3]+float(seed),11.0), 51.0 + mod(iDate[3]+float(seed),37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Setup\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst \tivec2\torigin  = ivec2(0, 0);\n            float\tref_r\t= gdv( origin, txdata, 0 );\t//\tOrigin value reference\n            float\tref_g\t= gdv( origin, txdata, 1 );\t//\tOrigin value reference\n            float\tref_b\t= gdv( origin, txdata, 2 );\t//\tOrigin value reference\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tOutput Values\n\tvec3 res_c = vec3(ref_r, ref_g, ref_b );\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tTransition Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    vec2 nh_0 = ring(vec2(7,4),txdata,0);\n    float nh0 = nh_0[0] / nh_0[1];\n\n    vec2 nh_1 = ring(vec2(3,0),txdata,0);\n    float nh1 = nh_1[0] / nh_1[1];\n\n    if( nh0 >= 0.210\t&& nh0 <= 0.220 ) { res_c[0] = 1.0; }\n    if( nh0 >= 0.350\t&& nh0 <= 0.500 ) { res_c[0] = 0.0; }\n    if( nh0 >= 0.750\t&& nh0 <= 0.850 ) { res_c[0] = 0.0; }\n    if( nh1 >= 0.100\t&& nh1 <= 0.280 ) { res_c[0] = 0.0; }\n    if( nh1 >= 0.430\t&& nh1 <= 0.550 ) { res_c[0] = 1.0; }\n    if( nh0 >= 0.120\t&& nh0 <= 0.150 ) { res_c[0] = 0.0; }\n\n\tres_c[1] = res_c[0];\n\tres_c[2] = res_c[0];\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = 0.0;\n        res_c[2] = 0.0; }\n    if (iFrame == 0) { res_c[0] = reseed(0); res_c[1] = reseed(1); res_c[2] = reseed(2); }\n    fragColor=vec4(res_c[0],res_c[1],res_c[2],1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ll3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[998, 998, 1055, 1105, 1235]]}
{"id": "sll3R7", "name": "MNCA Example 1", "author": "SlackermanzCA", "description": "\n", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 13, "viewed": 881, "published": 3, "date": "1621826979", "time_retrieved": "2024-07-30T19:19:12.571662", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bufA = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = bufA;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n\nconst uint MAX_NH_SIZE = 16u;\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat tp(uint n, float s) {\n\t\t\tfloat\tpscale\t= s * 0.5;\nreturn (float(n+1u)/256.0) * (pscale/128.0); }\n    \nfloat gdv(ivec2 off, sampler2D tx, int v) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n\tivec4\tdm\t\t= ivec4(iResolution.x,iResolution.y,1,0);\n\tvec4 \tfc \t\t= gl_FragCoord;\n\tvec2\tdc\t\t= vec2( dm[0]/dm[2], dm[1]/dm[2] );\n\tfloat\tcx\t\t= mod(fc[0]+float(off[0]), dc[0]) + floor(fc[0]/dc[0])*dc[0];\n\tfloat\tcy\t\t= mod(fc[1]+float(off[1]), dc[1]) + floor(fc[1]/dc[1])*dc[1];\n\tvec4 \tpxdata \t= texelFetch( txdata, ivec2(cx, cy), 0);\n\treturn \tpxdata[v]; }\n\nvec2 ring( vec2 r, sampler2D tx, int c ) {\n\tconst\tfloat\tw = 1.0; // atan(1.0*(1.0-(d*PI)/r));\n\tconst\tuint\ttmx = 65536u;\n//\tconst\tuint\tchk = 2147483648u / (\n//\t\t\t\t\t( \tuint(float(r[0])*float(r[0])*PI + float(r[0])*PI + PI\t)\n//\t\t\t\t\t- \tuint(float(r[1])*float(r[1])*PI + float(r[1])*PI\t\t) ) * 128 );\n//\tconst\tfloat\tpsn = (chk >= tmx) ? float(tmx) : float(chk);\n\tconst\tfloat\tpsn = float(tmx);\n\t\t\tfloat \td = 0.0;\n\t\t\tfloat \ta = 0.0;\n\t\t\tfloat \tb = 0.0;\n\t\t\tfloat\tt = 0.0;\n\tfor(float i = -r[0]; i <= r[0]; i+=1.0) {\n\t\tfor(float j = -r[0]; j <= r[0]; j+=1.0) {\n\t\t\td = round(sqrt(i*i+j*j));\n\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\tt  = gdv( ivec2(i,j), tx, c ) * w * psn;\n\t\t\t\ta += t - fract(t);\n\t\t\t\tb += w * psn; } } }\n\treturn vec2(a, b); }\n                \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(int seed) {\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1],  2.0, 19.0 + mod(iDate[3]+float(seed),17.0), 23.0 + mod(iDate[3]+float(seed),43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 14.0, 13.0 + mod(iDate[3]+float(seed),29.0), 17.0 + mod(iDate[3]+float(seed),31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1],  6.0, 13.0 + mod(iDate[3]+float(seed),11.0), 51.0 + mod(iDate[3]+float(seed),37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Setup\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst \tivec2\torigin  = ivec2(0, 0);\n            float\tref_r\t= gdv( origin, txdata, 0 );\t//\tOrigin value reference\n            float\tref_g\t= gdv( origin, txdata, 1 );\t//\tOrigin value reference\n            float\tref_b\t= gdv( origin, txdata, 2 );\t//\tOrigin value reference\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tOutput Values\n\tvec3 res_c = vec3(ref_r, ref_g, ref_b );\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tTransition Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    vec2 nh_0 = ring(vec2(7,4),txdata,0);\n    float nh0 = nh_0[0] / nh_0[1];\n\n    vec2 nh_1 = ring(vec2(3,0),txdata,0);\n    float nh1 = nh_1[0] / nh_1[1];\n\n    if( nh0 >= 0.185\t&& nh0 <= 0.200 ) { res_c[0] = 1.0; }\n    if( nh0 >= 0.343\t&& nh0 <= 0.580 ) { res_c[0] = 0.0; }\n    if( nh0 >= 0.750\t&& nh0 <= 0.850 ) { res_c[0] = 0.0; }\n    if( nh1 >= 0.150\t&& nh1 <= 0.280 ) { res_c[0] = 0.0; }\n    if( nh1 >= 0.445\t&& nh1 <= 0.680 ) { res_c[0] = 1.0; }\n    if( nh0 >= 0.150\t&& nh0 <= 0.180 ) { res_c[0] = 0.0; }\n\n\tres_c[1] = res_c[0];\n\tres_c[2] = res_c[0];\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = 0.0;\n        res_c[2] = 0.0; }\n    if (iFrame == 0) { res_c[0] = reseed(0); res_c[1] = reseed(1); res_c[2] = reseed(2); }\n    fragColor=vec4(res_c[0],res_c[1],res_c[2],1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[998, 998, 1055, 1105, 1235]]}
{"id": "fll3R7", "name": "The Dip", "author": "lennyjpg", "description": "a", "tags": ["asdfa"], "likes": 3, "viewed": 213, "published": 3, "date": "1621825238", "time_retrieved": "2024-07-30T19:19:13.333625", "image_code": "float rand(vec2 n) { \nreturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\nvec2 ip = floor(p);\nvec2 u = fract(p);\nu = u*u*(3.0-2.0*u);\nfloat res = mix(\n    mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n    mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\nreturn res*res;\n}\n\nvec3 red = vec3(234,77,83)/255.0;\nvec3 dark = vec3(.1);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord/iResolution.y;\nuv.x*=0.5;\nvec2 u = uv * 5.0 ;\nfloat index = ceil(u.x) * ceil(u.y);\nfloat t = iTime * 0.5 + index;\nu = fract(u);\n\n\nfloat width = noise(floor(u) + index) * .1 + .05;\nfloat labelY = step(abs(1.0 - u.y - 0.1),0.05);\nfloat labelX = step(abs(1.0 - u.x-width - 0.02), width);\nfloat label = labelX * labelY;\n\n\n\nfloat j = noise(floor(u)+index+t*20.0)*0.7+0.3;\nfloat w = step(0.5-abs(u.y),0.2);\n//w -= step(abs(u.x-0.1),j);\n//k = max(k,w);\n\n\nfloat lines = clamp(floor(mod(fragCoord.x,10.0)), 0.0, 1.0);\n\nfloat q = u.x;\nvec2 dir = vec2(1,0);\nu += dir * t;\n\nfloat medium = noise((u + index * 133.77 ) * vec2(7.0 , 0.1)),\n small = noise((u + index * 848.33) * vec2(37.57 , 0.1)),\n large = noise((u + index * 1723.456) * vec2(0.572 , 0.1)),\n offset = large - medium*0.78 - small*0.06;\n \n float medium2 = noise((u + index * 1033.77 ) * vec2(7.0 , 0.1)),\n small2 = noise((u + index * 48.33) * vec2(37.7 , 0.1)),\n large2 = noise((u + index * 723.456) * vec2(0.72 , 0.1)),\n offset2 = large2 - medium2*0.78 - small2*0.06;\n \n\nfloat e = step(u.y + offset, 1.0 - q);  \nfloat e2 = step(u.y + offset2, 1.0 - q);  \n\nvec3 col = mix(red, dark, max(e, label));\nvec3 foo = vec3(1.0);\ncol = mix(col, foo, e2*0.8);\n\nfragColor = vec4(col , 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fll3R7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 86], [88, 88, 108, 108, 314], [374, 374, 431, 431, 1684]]}
{"id": "stsGR7", "name": "sad face", "author": "jorge2017a1", "description": "sad face", "tags": ["2d"], "likes": 3, "viewed": 189, "published": 3, "date": "1621822928", "time_retrieved": "2024-07-30T19:19:14.088607", "image_code": "//por jorge2017a1 ----jorgeFloresP---23/may/2021\n// referencia \n//sad face\n\n////-------------------\n/// IQ funciones....librerias\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n#define Sv(d,b,v) smoothstep(antialiasing(v),b,d)\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 colBlanco= vec3(1.0);\nconst vec3 colRojo= vec3(1.0,0.0,0.0);\nconst vec3 col0= vec3(0.49,0.93,0.29);\nconst vec3 col1= vec3(1.00,0.67,0.31);\nconst vec3 col2= vec3(1.00,0.72,0.67);\nconst vec3 col3= vec3(0.47,0.54,0.00);\nconst vec3 col4= vec3(0.71,0.65,1.00);\nconst vec3 col5= vec3(0.49,0.93,0.29);\nconst vec3 col6= vec3(1.00,0.69,0.34);\nconst vec3 col7= vec3(1.00,0.70,0.47);\nconst vec3 col8= vec3(0.47,0.53,0.00);\nconst vec3 col9= vec3(0.73,0.61,0.15);\nconst vec3 col10= vec3(1.00,0.67,0.31);\nconst vec3 col11= vec3(1.00,0.1,0.1);\nconst vec3 col12= vec3(0.2,0.82,0.42);\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//Uneven Capsule - exact   (https://www.shadertoy.com/view/4lcBWn)\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\n//***------------****-----------****------------******-------\nvec3 Rostro2d(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n   float r1=0.6;float r2=0.8;float h=0.9; \n  float sdcabeza= sdUnevenCapsule( p, r1,  r2,  h );\n \n  \n  r1=0.15;r2=0.15;h=0.2;\n  float sdOjoIzq= sdUnevenCapsule( p-vec2(-0.25,0.7), r1,  r2,  h );\n  float sdOjoDer= sdUnevenCapsule( p-vec2(0.25,0.7), r1,  r2,  h );\n  \n  float sdOjoIzqR= sdUnevenCapsule( p-vec2(-0.25,0.7), r1,  r2,  h );\n  float sdOjoDerR= sdUnevenCapsule( p-vec2(0.25,0.7), r1,  r2,  h );\n  \n  \n  r1=0.05;r2=0.05;h=0.1;\n  float sdPupilaIzq= sdUnevenCapsule( p-vec2(-0.25,0.7), r1,  r2,  h );\n  float sdPupilaDer= sdUnevenCapsule( p-vec2(0.25,0.7), r1,  r2,  h );\n  \n  float sube=0.1*sin(iTime);\n  float sParpadoOjoIzq=sdOrientedBox(p,vec2(-0.3,0.8+sube), vec2(-0.2,0.4), 0.5 );\n  float sParpadoOjoDer=sdOrientedBox(p,vec2(0.3,0.85+sube), vec2(0.2,0.4), 0.5 );\n  \n  //parpado\n  sdOjoIzq =differenceSDF(sdOjoIzq,sParpadoOjoIzq);\n  sdOjoDer =differenceSDF(sdOjoDer,sParpadoOjoDer);\n  col=ponerBorde(col8,col,sdcabeza);\n  \n  //ojo  real\n  col=ponerBorde(colBlanco,col,sdOjoIzqR);\n  col=ponerBorde(colBlanco,col,sdOjoDerR);\n  //parpado\n  col=ponerBorde(col1,col,sdOjoIzq);\n  col=ponerBorde(col1,col,sdOjoDer);\n  \n  sdPupilaDer= differenceSDF(sdPupilaDer,  sdOjoDer);\n  sdPupilaIzq= differenceSDF(sdPupilaIzq,  sdOjoIzq);\n  \n  col=ponerBorde(colNegro,col,sdPupilaIzq);\n  col=ponerBorde(colNegro,col,sdPupilaDer);\n  \n  \n  //nariz\n  r1=0.12; r2=0.05; h=0.2; \n  float  snariz= sdUnevenCapsule(  p-vec2(0.0,0.2),  r1,  r2,  h );\n  col=ponerBorde(colRojo,col,snariz);\n  \n  \n  //Boca\n  r1=0.25; r2=0.05; h=0.3; \n  \n  float  sboca= sdCircle( p-vec2(0.0,0.0+sube), 0.3 );\n  float  sbocab= sdBox(p-vec2(0.0,0.2), vec2(0.32,0.3) );\n  sboca= differenceSDF(sboca,  sbocab);\n  \n  //dientes\n  float r1t=0.006; float r2t=0.05; float he=0.1;\n  float  sdienteA= sdTrapezoid( p-vec2(-0.1,-0.2), r1t, r2t, he );\n  sboca= differenceSDF(sboca,  sdienteA);\n  \n  col=ponerBorde(colBlanco,col,sdienteA);\n  col=ponerBorde(colNegro,col,sboca);\n  \n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec2 p=uv*1.5;\n    vec3 col=colBlanco;\n     \n    col= Rostro2d(p-vec2(0.0,-0.3), col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsGR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 384, 431, 431, 458], [460, 460, 503, 503, 530], [532, 532, 580, 580, 608], [656, 656, 716, 716, 842], [1457, 1457, 1488, 1488, 1509], [1510, 1510, 1535, 1535, 1554], [1555, 1555, 1580, 1580, 1599], [1600, 1600, 1636, 1636, 1664], [1734, 1734, 1796, 1796, 2035], [2037, 2037, 2089, 2089, 2208], [2210, 2210, 2247, 2247, 2327], [2329, 2329, 2395, 2395, 2612], [2614, 2614, 2649, 2649, 2677], [2679, 2679, 2744, 2744, 3054], [3057, 3119, 3157, 3157, 5120], [5122, 5122, 5179, 5179, 5400]]}
{"id": "sls3zM", "name": "Smile :)", "author": "oneshade", "description": "Recreating the shadertoy smiley emoji :)", "tags": ["pixel", "smiley", "emoji"], "likes": 5, "viewed": 172, "published": 3, "date": "1621819804", "time_retrieved": "2024-07-30T19:19:14.959279", "image_code": "// Codegolfed a bit for fun\nvoid mainImage(out vec4 c, in vec2 p) {\n    vec2 r = iResolution.xy;\n    p = round((p - .5 * r) / r.y / .01) * .01;\n\n    c = vec4(1);\n    float d = dot(p, p) - .125;\n    c.b = step(0., d);\n    c -= step(0., .0075 - abs(d));\n\n    vec2 u = vec2(abs(p.x) - .125, p.y - .1);\n    c -= step(0., 1e-5 - dot(u * u * u, u));\n\n    u = vec2(abs(p.x + .02) - .125, u.y - .02);\n    c = max(c, 0.) + step(0., 5e-4 - dot(u, u));\n\n    u = vec2(p.x, p.y + .2 * cos(5. * p.x) - .01);\n    u.x -= clamp(u.x, -.2, .2);\n    c -= step(0., 2e-4 - dot(u, u));\n\n    u = vec2(abs(p.x) - .2, p.y + .01);\n    c = mix(c, vec4(1, 0, 0, 0), .24 - 12. * dot(u, u));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sls3zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 28, 67, 67, 662]]}
{"id": "NtlGz7", "name": "2D Physics (balls)", "author": "TDM", "description": "Simulation of ball shaped bodies. It solves normal and frictional impulses. There's no broad phase so the complexity is n^2. Press mouse to add explosion force.", "tags": ["2d", "collision", "simulation", "ball", "solver", "physics", "angular", "friction", "elasticity"], "likes": 56, "viewed": 2015, "published": 3, "date": "1621794144", "time_retrieved": "2024-07-30T19:19:15.728223", "image_code": "/*\n * \"2D Physics (balls)\" by Alexander Alekseev aka TDM - 2021\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n *\n * Render\n */\n \n#define PIX length(fwidth(p))\nconst vec3[] COLORS = vec3[4] (\n    vec3(72, 123, 240) / 255.,\n    vec3(240, 46, 80) / 255.,\n    vec3(255, 191, 0) / 255.,\n    vec3(68, 188, 98) / 255.\n);\n\nfloat circle(vec2 p, vec2 c, float w) {\n    float dist = length(p - c) - w;\n    return smoothstep(PIX,0.0,dist);\n}\n\nfloat frame(vec2 p, vec2 size, float w) {\n    const float SMOOTH = 0.2;\n    size -= SMOOTH;\n\tp = abs(p)-size;\n    float dist = length(p-min(p,0.0)) - SMOOTH;\n    float shad = 1.0 - dist * 2.0;\n    shad = 1.0 - shad * shad * shad;\n    shad = 1.0 - (1.0 - shad) * smoothstep(0.0,PIX,dist);\n    return shad * 0.1 + 0.9;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse.y = 0.0;\n    \n    vec3 c = vec3(1.0);\n    vec2 ires = 1.0 / iChannelResolution[0].xy;\n        \n    \n    // objects\n    for(int i = 0; i < NUM_OBJECTS; i++) {\n        Body body = getBody(iChannel0, ires, i);\n        float ba = circle(uv,body.pos,BALL_SIZE*0.98);\n        ba *= 1.0-circle(uv,body.pos,BALL_SIZE*0.3);\n                  \n        for(int j = 0; j < 5; j++) {\n            float ang = body.ang + float(j) * (360./5.) * DEG2RAD;\n            vec2 o = rotateZ(vec2(0.0,BALL_SIZE*1.25), ang);\n            ba *= 1.0 - circle(uv, body.pos + o, BALL_SIZE * 0.4);\n        }  \n        c = mix(c,COLORS[i%4],ba);\n    }\n    c *= frame(uv,vec2(FRAME_SIZE*1.08),0.01);\n    \n    // final\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * \"2D Physics (balls)\" by Alexander Alekseev aka TDM - 2021\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com \n */\n \nconst int NUM_OBJECTS = 20;\nconst float BALL_SIZE = 0.15;\nconst float MAX_VELOCITY = 4.0;\nconst float ELASTICITY = 0.5;\nconst vec2 FRAME_SIZE = vec2(1.2,0.8);\nconst vec2 GRAVITY = vec2(0.0,-1.0);\n\nconst float PI = 3.141592;\nconst float DEG2RAD = PI / 180.0;\n\n/*\n * math\n */\n \nvec3 hash3( uint n ) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\nfloat cross2(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\nvec2 cross2(vec2 a, float b) {\n    return vec2(a.y * b, a.x * -b);\n}\nvec2 cross2(float a, vec2 b) {\n    return vec2(b.y * -a, b.x * a);\n}\nvec2 rotateZ(vec2 v, float a) {\n    lowp vec2 sc = vec2(sin(a),cos(a));\n    lowp vec2 ret = v;\n    ret.x = v.x * sc.y - v.y * sc.x;\n    ret.y = v.x * sc.x + v.y * sc.y;\n    return ret;\n}\n\n/*\n * body\n */\n\nstruct Body {\n    vec2 pos;\n    vec2 vel;\n    float ang;\n    float ang_vel;\n    float inv_mass;\n    float inv_inertia;\n};\n\nBody getBody(sampler2D buf, vec2 ires, int i) {\n    vec4 data0 = texture(buf, (vec2(float(i),0.0) + 0.5) * ires);\n    vec4 data1 = texture(buf, (vec2(float(i),1.0) + 0.5) * ires);\n    \n    Body body;\n    body.pos = data0.xy;\n    body.vel = data0.zw;\n    body.ang = data1.x;\n    body.ang_vel = data1.y;\n    body.inv_mass = data1.z;\n    body.inv_inertia = data1.w;\n    return body;\n}\n\nvoid initBody(int id, inout Body body) {\n    vec3 rnd = hash3(uint(id));\n    body.pos = (rnd.xy * 2.0 - 1.0) * 0.4;\n    body.vel = cross2(1.0,body.pos) * 2.0;\n    body.ang_vel = length(body.pos) * -8.0;\n    body.inv_mass = 1.0;\n    body.inv_inertia = 1.0 / (0.5 * (1.0/body.inv_mass) * BALL_SIZE * BALL_SIZE);\n}\n\n/*\n * solver\n */\n\nvec2 collisionWithPlane(inout Body b0, vec3 plane) {\n    vec2 normal = normalize(plane.xy);\n    float dist = dot(b0.pos,normal) + plane.z;\n    float penetration = BALL_SIZE - dist;\n    if(penetration > 0.0) {\n        vec2 r0 = -normal * BALL_SIZE;        \n\n        // normal\n        vec2 vel0 = b0.vel + cross2(b0.ang_vel,r0);\n        vec2 rel_vel = vel0;  \n        \n        float w1 = cross2(r0,normal);\n\n        float a = (1.0 + ELASTICITY) * dot(normal,rel_vel);\n        float b = b0.inv_mass + w1 * w1 * b0.inv_inertia;\n        float lambda = max(-a / b, 0.0);\n\n        b0.vel += normal * (lambda * b0.inv_mass);\n        b0.ang_vel += cross2(r0, normal) * lambda * b0.inv_inertia;\n\n        // friction\n        vel0 = b0.vel + cross2(b0.ang_vel,r0);\n        rel_vel = vel0;  \n\n        vec2 tangent = cross2(normal,1.0);\n        w1 = cross2(r0,tangent);\n\n        a = (1.0 + ELASTICITY) * dot(tangent,rel_vel);\n        b = b0.inv_mass + w1 * w1 * b0.inv_inertia;\n        float lambdaF = clamp(-a / b, -lambda, lambda);\n\n        b0.vel += tangent * (lambdaF * b0.inv_mass);\n        b0.ang_vel += cross2(r0, tangent) * lambdaF * b0.inv_inertia;\n        \n        return normal * penetration;\n    }\n    return vec2(0.0);\n}\n\nvec2 collisionWithBody(inout Body b0, in Body b1) {\n    vec2 normal = b0.pos - b1.pos;\n    float dist = length(normal);\n    float penetration = 2.0 * BALL_SIZE - dist;\n    if(penetration > 0.0) {\n        normal /= dist;\n\n        vec2 r0 = -normal * BALL_SIZE;\n        vec2 r1 = normal * BALL_SIZE;\n        \n        // normal\n        vec2 vel0 = b0.vel + cross2(b0.ang_vel,r0);\n        vec2 vel1 = b1.vel + cross2(b1.ang_vel,r1);\n        vec2 rel_vel = vel0 - vel1;\n        \n        float w1 = cross2(r0,normal);\n        float w2 = cross2(r1,normal);\n\n        float a = (1.0 + ELASTICITY) * dot(normal,rel_vel);\n        float b = b0.inv_mass + b1.inv_mass +\n            w1 * w1 * b0.inv_inertia +\n            w2 * w2 * b1.inv_inertia;\n        float lambda = max(-a / b, 0.0);\n\n        b0.vel += normal * (lambda * b0.inv_mass);\n        b0.ang_vel += cross2(r0, normal) * lambda * b0.inv_inertia;\n        b1.vel -= normal * (lambda * b1.inv_mass);\n        b1.ang_vel -= cross2(r1, normal) * lambda * b1.inv_inertia;\n\n        // friction\n        vel0 = b0.vel + cross2(b0.ang_vel,r0);\n        vel1 = b1.vel + cross2(b1.ang_vel,r1);\n        rel_vel = vel0 - vel1;  \n\n        vec2 tangent = cross2(normal,1.0);\n        w1 = cross2(r0,tangent);\n        w2 = cross2(r1,tangent);\n\n        a = (1.0 + ELASTICITY) * dot(tangent,rel_vel);\n        b = b0.inv_mass + b1.inv_mass +\n            w1 * w1 * b0.inv_inertia +\n            w2 * w2 * b1.inv_inertia;\n        float lambdaF = clamp(-a / b, -lambda, lambda);\n\n        b0.vel += tangent * (lambdaF * b0.inv_mass);\n        b0.ang_vel += cross2(r0, tangent) * lambdaF * b0.inv_inertia;\n        \n        return normal * penetration * 0.5;\n    }\n    return vec2(0.0);\n}\n\nvoid solve(sampler2D data, inout Body b0, int id, vec2 ires) {\n    vec2 displace = vec2(0.0);\n    \n    // collision detection\n    for(int i = 0; i < NUM_OBJECTS; i++) {\n        if(i == id) continue;\n        \n        Body b1 = getBody(data, ires, i);\n        displace += collisionWithBody(b0,b1);\n    }\n    \n    // walls\n    displace += collisionWithPlane(b0, vec3(0.0,1.0,FRAME_SIZE.y));\n    displace += collisionWithPlane(b0, vec3(0.0,-1.0,FRAME_SIZE.y));\n    displace += collisionWithPlane(b0, vec3(1.0,0.0,FRAME_SIZE.x));\n    displace += collisionWithPlane(b0, vec3(-1.0,-.0,FRAME_SIZE.x));\n\n    b0.pos += displace;\n}\n\n/*\n * store\n */\n\nfloat isInside( vec2 p, vec2 c ) { \n    vec2 d = abs(p-0.5-c) - 0.5;\n    return -max(d.x,d.y);\n}\nvoid storeBody(in int id, in Body b, inout vec4 col, in vec2 uv) {\n    col = isInside(uv,vec2(float(id),0)) > 0.0 ? vec4(b.pos,b.vel) : col;\n    col = isInside(uv,vec2(float(id),1)) > 0.0 ? vec4(b.ang,b.ang_vel,b.inv_mass,b.inv_inertia) : col;\n}", "buffer_a_code": "/*\n * Dynamics\n */\n \nvec2 getForce(vec2 x, vec2 v) {\n    vec2 force = vec2(0.0);\n    \n    if(iMouse.z > 0.5) {\n        vec2 mouse = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n        mouse.x *= iResolution.x / iResolution.y;\n        vec2 dir = x.xy - mouse;\n        float p = length(dir);        \n        force += 5.0 * normalize(dir) / p;\n    }\n    \n    return force;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int id = int(fragCoord.x);\n    if(id >= NUM_OBJECTS) discard;\n    vec2 ires = 1.0 / iChannelResolution[0].xy;\n    \n    // load    \n    Body body = getBody(iChannel0, ires, id);\n    if(iFrame == 0) initBody(id, body); // init\n    \n    float dt = min(iTimeDelta, 0.07);\n    \n    // integrate forces\n    vec2 pvel = body.vel;\n    float pang_vel = body.ang_vel;\n    vec2 force = getForce(body.pos, body.vel);\n    body.vel += (force * body.inv_mass + GRAVITY) * dt;\n    \n    // limit max velocity\n    float len2 = dot(body.vel,body.vel);\n    if(len2 > MAX_VELOCITY * MAX_VELOCITY)\n        body.vel *= inversesqrt(len2) * MAX_VELOCITY;\n    \n    // integrate velocity\n    body.pos += (pvel + body.vel) * 0.5 * dt;\n    body.ang += (pang_vel + body.ang_vel) * 0.5 * dt;\n    \n    // store\n    fragColor = vec4(0.0);\n    storeBody(id, body, fragColor, fragCoord);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n * Collision solver (1st iteration)\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int id = int(fragCoord.x);\n    if(id >= NUM_OBJECTS) discard;\n    vec2 ires = 1.0 / iChannelResolution[0].xy;\n    \n    // solve collisions    \n    Body body = getBody(iChannel0, ires, id);\n    solve(iChannel0,body,id,ires);\n    \n    // store\n    fragColor = vec4(0.0);\n    storeBody(id, body, fragColor, fragCoord);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/*\n * Collision solver (2nd iteration)\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int id = int(fragCoord.x);\n    if(id >= NUM_OBJECTS) discard;\n    vec2 ires = 1.0 / iChannelResolution[0].xy;\n    \n    // solve collisions    \n    Body body = getBody(iChannel0, ires, id);\n    solve(iChannel0,body,id,ires);\n    \n    // store\n    fragColor = vec4(0.0);\n    storeBody(id, body, fragColor, fragCoord);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlGz7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[385, 385, 424, 424, 499], [501, 501, 542, 542, 819], [821, 821, 878, 878, 1805]]}
{"id": "Nts3RM", "name": "Multiple Neighborhood CA", "author": "SlackermanzCA", "description": "\n", "tags": ["2d", "simulation", "diffusion", "automata", "life", "chaos", "cellular", "conway", "gameoflife", "cellularautomata", "cellularautomata", "cgol"], "likes": 6, "viewed": 1358, "published": 3, "date": "1621779678", "time_retrieved": "2024-07-30T19:19:16.661727", "image_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 bufA = texture(iChannel0, uv);\n\n    // Output to screen\n    fragColor = bufA;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\t----    ----    ----    ----    ----    ----    ----    ----\n//  Shader developed by Slackermanz\n//\n//  Info/Code:\n//  ﻿ - Website: https://slackermanz.com\n//  ﻿ - Github: https://github.com/Slackermanz\n//  ﻿ - Shadertoy: https://www.shadertoy.com/user/SlackermanzCA\n//  ﻿ - Discord: https://discord.gg/hqRzg74kKT\n//  \n//  Socials:\n//  ﻿ - Discord DM: Slackermanz#3405\n//  ﻿ - Reddit DM: https://old.reddit.com/user/slackermanz\n//  ﻿ - Twitter: https://twitter.com/slackermanz\n//  ﻿ - YouTube: https://www.youtube.com/c/slackermanz\n//  ﻿ - Older YT: https://www.youtube.com/channel/UCZD4RoffXIDoEARW5aGkEbg\n//  ﻿ - TikTok: https://www.tiktok.com/@slackermanz\n//  \n//  Communities:\n//  ﻿ - Reddit: https://old.reddit.com/r/cellular_automata\n//  ﻿ - Artificial Life: https://discord.gg/7qvBBVca7u\n//  ﻿ - Emergence: https://discord.com/invite/J3phjtD\n//  ﻿ - ConwayLifeLounge: https://discord.gg/BCuYCEn\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n#define txdata (iChannel0)\n\nconst uint MAX_NH_SIZE = 16u;\n\nuint u32_upk(uint u32, uint bts, uint off) { return (u32 >> off) & ((1u << bts)-1u); }\n\nfloat tp(uint n, float s) {\n\t\t\tfloat\tpscale\t= s * 0.5;\nreturn (float(n+1u)/256.0) * (pscale/128.0); }\n    \nfloat gdv(ivec2 off, sampler2D tx, int v) {\n//\tGet Div Value: Return the value of a specified pixel\n//\t\tx, y : \tRelative integer-spaced coordinates to origin [ 0.0, 0.0 ]\n//\t\tv\t :\tColour channel [ 0, 1, 2 ]\n\tivec4\tdm\t\t= ivec4(iResolution.x,iResolution.y,1,0);\n\tvec4 \tfc \t\t= gl_FragCoord;\n\tvec2\tdc\t\t= vec2( dm[0]/dm[2], dm[1]/dm[2] );\n\tfloat\tcx\t\t= mod(fc[0]+float(off[0]), dc[0]) + floor(fc[0]/dc[0])*dc[0];\n\tfloat\tcy\t\t= mod(fc[1]+float(off[1]), dc[1]) + floor(fc[1]/dc[1])*dc[1];\n\tvec4 \tpxdata \t= texelFetch( txdata, ivec2(cx, cy), 0);\n\treturn \tpxdata[v]; }\n\nvec2 ring( vec2 r, sampler2D tx, int c ) {\n\tconst\tfloat\tw = 1.0; // atan(1.0*(1.0-(d*PI)/r));\n\tconst\tuint\ttmx = 65536u;\n//\tconst\tuint\tchk = 2147483648u / (\n//\t\t\t\t\t( \tuint(float(r[0])*float(r[0])*PI + float(r[0])*PI + PI\t)\n//\t\t\t\t\t- \tuint(float(r[1])*float(r[1])*PI + float(r[1])*PI\t\t) ) * 128 );\n//\tconst\tfloat\tpsn = (chk >= tmx) ? float(tmx) : float(chk);\n\tconst\tfloat\tpsn = float(tmx);\n\t\t\tfloat \td = 0.0;\n\t\t\tfloat \ta = 0.0;\n\t\t\tfloat \tb = 0.0;\n\t\t\tfloat\tt = 0.0;\n\tfor(float i = -r[0]; i <= r[0]; i+=1.0) {\n\t\tfor(float j = -r[0]; j <= r[0]; j+=1.0) {\n\t\t\td = round(sqrt(i*i+j*j));\n\t\t\tif( d <= r[0] && d > r[1] ) {\n\t\t\t\tt  = gdv( ivec2(i,j), tx, c ) * w * psn;\n\t\t\t\ta += t - fract(t);\n\t\t\t\tb += w * psn; } } }\n\treturn vec2(a, b); }\n                \nfloat sizring(uint r, vec2[MAX_NH_SIZE] rings) {\n\tfloat e0_sum = 0.0;\n\tfloat e1_sum = 0.0;\n\tuint idx_min = MAX_NH_SIZE;\n\tuint idx_max = 0u;\n\tfor(uint i = 0u; i < MAX_NH_SIZE; i++) {\n\t\tif(u32_upk(r,1u,i) == 1u) { \n\t\t\tidx_max = i;\n\t\t\tif(idx_min == MAX_NH_SIZE) { idx_min = i; } } }\n\tfor(uint i = idx_min; i < idx_max; i++) {\n\t\te0_sum += rings[i][0];\n\t\te1_sum += rings[i][1]; }\n\treturn e0_sum / e1_sum; }\n\nfloat bitring(uint r, vec2[MAX_NH_SIZE] rings){\n\tfloat e0_sum = 0.0;\n\tfloat e1_sum = 0.0;\n\tfor(uint i = 0u; i < MAX_NH_SIZE; i++) {\n\t\tif(u32_upk(r,1u,i) == 1u) {\n\t\t\te0_sum += rings[i][0];\n\t\t\te1_sum += rings[i][1]; } }\n\treturn e0_sum / e1_sum; }\n    \n//\tUsed to reseed the surface with lumpy noise\nfloat get_xc(float x, float y, float xmod) {\n\tfloat sq = sqrt(mod(x*y+y, xmod)) / sqrt(xmod);\n\tfloat xc = mod((x*x)+(y*y), xmod) / xmod;\n\treturn clamp((sq+xc)*0.5, 0.0, 1.0); }\nfloat shuffle(float x, float y, float xmod, float val) {\n\tval = val * mod( x*y + x, xmod );\n\treturn (val-floor(val)); }\nfloat get_xcn(float x, float y, float xm0, float xm1, float ox, float oy) {\n\tfloat  xc = get_xc(x+ox, y+oy, xm0);\n\treturn shuffle(x+ox, y+oy, xm1, xc); }\nfloat get_lump(float x, float y, float nhsz, float xm0, float xm1) {\n\tfloat \tnhsz_c \t= 0.0;\n\tfloat \txcn \t= 0.0;\n\tfloat \tnh_val \t= 0.0;\n\tfor(float i = -nhsz; i <= nhsz; i += 1.0) {\n\t\tfor(float j = -nhsz; j <= nhsz; j += 1.0) {\n\t\t\tnh_val = round(sqrt(i*i+j*j));\n\t\t\tif(nh_val <= nhsz) {\n\t\t\t\txcn = xcn + get_xcn(x, y, xm0, xm1, i, j);\n\t\t\t\tnhsz_c = nhsz_c + 1.0; } } }\n\tfloat \txcnf \t= ( xcn / nhsz_c );\n\tfloat \txcaf\t= xcnf;\n\tfor(float i = 0.0; i <= nhsz; i += 1.0) {\n\t\t\txcaf \t= clamp((xcnf*xcaf + xcnf*xcaf) * (xcnf+xcnf), 0.0, 1.0); }\n\treturn xcaf; }\nfloat reseed(int seed) {\n\tvec4\tfc = gl_FragCoord;\n\tfloat \tr0 = get_lump(fc[0], fc[1],  2.0, 19.0 + mod(iDate[3]+float(seed),17.0), 23.0 + mod(iDate[3]+float(seed),43.0));\n\tfloat \tr1 = get_lump(fc[0], fc[1], 14.0, 13.0 + mod(iDate[3]+float(seed),29.0), 17.0 + mod(iDate[3]+float(seed),31.0));\n\tfloat \tr2 = get_lump(fc[0], fc[1],  6.0, 13.0 + mod(iDate[3]+float(seed),11.0), 51.0 + mod(iDate[3]+float(seed),37.0));\n\treturn clamp((r0+r1)-r2,0.0,1.0); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n//  PatternConfigData\n\tuint[4/*48*/] SCD = uint[4/*48*/] (\n\t\t745624173u, 394657945u, 114691695u, 3408256734u/*, \n\t\t3562138900u, 2689676514u, 1537616700u, 514376187u, \n\t\t2561585874u, 1457975831u, 3873655792u, 829274244u, \n\t\t1345991250u, 2384637002u, 3327897501u, 4181019822u, \n\t\t3280585563u, 3404707033u, 3478088402u, 3404599677u, \n\t\t1895706143u, 2111688054u, 711043543u, 170845113u, \n\t\t705654093u, 4286820695u, 1774033677u, 2025664183u, \n\t\t87072028u, 2350900182u, 3118097579u, 2505681268u, \n\t\t442538555u, 527807101u, 3277062214u, 2927821985u, \n\t\t4087906097u, 3986167603u, 3770457043u, 291982664u, \n\t\t2617331523u, 132764912u, 3513872062u, 2912623567u, \n\t\t3126111208u, 3641509413u, 632489908u, 1232640552u*/ );\n\t\t\n\tuint[1/*4*/] UBI = uint[1/*4*/] (\n\t\t2028247922u/*, 1229167981u, 1124204384u, 3289825991u*/ );\n\t\t\n\tuint[8/*48*/] UBV = uint[8/*48*/] (\n\t\t2881800762u, 1689308279u, 207967308u, 403478124u, \n\t\t2024363340u, 1838559275u, 487054279u, 965651142u/*, \n\t\t1303859839u, 3241637042u, 3234350862u, 2128598581u, \n\t\t3821254548u, 1610900416u, 950297306u, 1751528927u, \n\t\t512984747u, 2826875305u, 1534335949u, 653135108u, \n\t\t438611155u, 2121883655u, 335884606u, 2096964339u, \n\t\t291409380u, 1406257945u, 2409962099u, 197265851u, \n\t\t3010279700u, 907997333u, 2168248334u, 1929616449u, \n\t\t1290274009u, 2928033625u, 1749564286u, 626410207u, \n\t\t770787243u, 2662863700u, 697663404u, 3447431416u, \n\t\t3329121672u, 2605203859u, 4129638779u, 1636176142u, \n\t\t2123096153u, 440566377u, 1065434181u, 2065065723u*/ );\n\t\t\n\tfloat SCL = 291.428680;\n    \n\tfloat PZM = 1.600000;\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Setup\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tconst \tivec2\torigin  = ivec2(0, 0);\n\tconst\tfloat \tmnp \t= 1.0 / 65536.0;\t\t\t//\tMinimum value of a precise step for 16-bit channel\n\n            float\tref_r\t= gdv( origin, txdata, 0 );\t//\tOrigin value reference\n            float\tref_g\t= gdv( origin, txdata, 1 );\t//\tOrigin value reference\n            float\tref_b\t= gdv( origin, txdata, 2 );\t//\tOrigin value reference\n\n//\tParameters\n\tconst\tfloat \ts  = 1.0;//mnp *  64.0 *  96.0;\n\tconst\tfloat \tc  = mnp *  32.0 *   4.0;\n\tconst\tfloat \tb  = mnp *  32.0 *  12.0 * 0.0;\n\tconst\tfloat \tn  = mnp *  64.0 *  16.0 * 1.0;\n\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tRule Initilisation\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n//\tOutput Values\n\tvec3 res_c = vec3(ref_r, ref_g, ref_b );\n\n//\tNeighbourhood Rings\n\tvec2[MAX_NH_SIZE] rings_r;\n\tfor(uint i = 0u; i < MAX_NH_SIZE; i++) {\n\t\trings_r[i] = ring( vec2(float(i+1u), float(i)), txdata, 0 ); }\n\n//\tGet Neighbourhood Values\n\t \tfloat[4/*48*/] nhv_r = float[4/*48*/] (\n\t\tsizring(SCD[ 0], rings_r), bitring(SCD[ 1], rings_r), \n\t\tsizring(SCD[ 2], rings_r), bitring(SCD[ 3], rings_r)/*, \n\t\tbitring(SCD[ 4], rings_r), bitring(SCD[ 5], rings_r), \n\t\tbitring(SCD[ 6], rings_r), bitring(SCD[ 7], rings_r), \n\t\tsizring(SCD[ 8], rings_r), bitring(SCD[ 9], rings_r), \n\t\tsizring(SCD[10], rings_r), bitring(SCD[11], rings_r), \n\t\tsizring(SCD[12], rings_r), bitring(SCD[13], rings_r), \n\t\tsizring(SCD[14], rings_r), bitring(SCD[15], rings_r), \n\t\tbitring(SCD[16], rings_r), sizring(SCD[17], rings_r), \n\t\tbitring(SCD[18], rings_r), sizring(SCD[19], rings_r), \n\t\tbitring(SCD[20], rings_r), sizring(SCD[21], rings_r), \n\t\tbitring(SCD[22], rings_r), sizring(SCD[23], rings_r), \n\t\tsizring(SCD[24], rings_r), sizring(SCD[25], rings_r), \n\t\tsizring(SCD[26], rings_r), sizring(SCD[27], rings_r), \n\t\tsizring(SCD[28], rings_r), sizring(SCD[29], rings_r), \n\t\tsizring(SCD[30], rings_r), sizring(SCD[31], rings_r), \n\t\tsizring(SCD[32], rings_r), sizring(SCD[33], rings_r), \n\t\tsizring(SCD[34], rings_r), sizring(SCD[35], rings_r), \n\t\tsizring(SCD[36], rings_r), sizring(SCD[37], rings_r), \n\t\tsizring(SCD[38], rings_r), sizring(SCD[39], rings_r), \n\t\tsizring(SCD[40], rings_r), sizring(SCD[41], rings_r), \n\t\tsizring(SCD[42], rings_r), sizring(SCD[43], rings_r), \n\t\tsizring(SCD[44], rings_r), sizring(SCD[45], rings_r), \n\t\tsizring(SCD[46], rings_r), sizring(SCD[47], rings_r)*/ );\n\n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tTransition Functions\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n\tuint mn = 4u;\n\tuint vc = 48u / mn;\n\tuint bt = 8u;\n    \n/*\tif( nhv_r[0] >= tp(u32_upk(UBV[0],bt,bt*0u),SCL)\t&& nhv_r[0] <= tp(u32_upk(UBV[0],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 0u)); }\n\tif( nhv_r[0] >= tp(u32_upk(UBV[0],bt,bt*2u),SCL)\t&& nhv_r[0] <= tp(u32_upk(UBV[0],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 1u)); }\n\tif( nhv_r[0] >= tp(u32_upk(UBV[1],bt,bt*0u),SCL)\t&& nhv_r[0] <= tp(u32_upk(UBV[1],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 2u)); }\n\tif( nhv_r[0] >= tp(u32_upk(UBV[1],bt,bt*2u),SCL)\t&& nhv_r[0] <= tp(u32_upk(UBV[1],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 3u)); }\n\n\tif( nhv_r[1] >= tp(u32_upk(UBV[2],bt,bt*0u),SCL)\t&& nhv_r[1] <= tp(u32_upk(UBV[2],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 4u)); }\n\tif( nhv_r[1] >= tp(u32_upk(UBV[2],bt,bt*2u),SCL)\t&& nhv_r[1] <= tp(u32_upk(UBV[2],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 5u)); }\n\tif( nhv_r[1] >= tp(u32_upk(UBV[3],bt,bt*0u),SCL)\t&& nhv_r[1] <= tp(u32_upk(UBV[3],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 6u)); }\n\tif( nhv_r[1] >= tp(u32_upk(UBV[3],bt,bt*2u),SCL)\t&& nhv_r[1] <= tp(u32_upk(UBV[3],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 7u)); }\n\n\tif( nhv_r[2] >= tp(u32_upk(UBV[4],bt,bt*0u),SCL)\t&& nhv_r[2] <= tp(u32_upk(UBV[4],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 8u)); }\n\tif( nhv_r[2] >= tp(u32_upk(UBV[4],bt,bt*2u),SCL)\t&& nhv_r[2] <= tp(u32_upk(UBV[4],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u, 9u)); }\n\tif( nhv_r[2] >= tp(u32_upk(UBV[5],bt,bt*0u),SCL)\t&& nhv_r[2] <= tp(u32_upk(UBV[5],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,10u)); }\n\tif( nhv_r[2] >= tp(u32_upk(UBV[5],bt,bt*2u),SCL)\t&& nhv_r[2] <= tp(u32_upk(UBV[5],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,11u)); }\n\n\tif( nhv_r[3] >= tp(u32_upk(UBV[6],bt,bt*0u),SCL)\t&& nhv_r[3] <= tp(u32_upk(UBV[6],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,12u)); }\n\tif( nhv_r[3] >= tp(u32_upk(UBV[6],bt,bt*2u),SCL)\t&& nhv_r[3] <= tp(u32_upk(UBV[6],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,13u)); }\n\tif( nhv_r[3] >= tp(u32_upk(UBV[7],bt,bt*0u),SCL)\t&& nhv_r[3] <= tp(u32_upk(UBV[7],bt,bt*1u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,14u)); }\n\tif( nhv_r[3] >= tp(u32_upk(UBV[7],bt,bt*2u),SCL)\t&& nhv_r[3] <= tp(u32_upk(UBV[7],bt,bt*3u),SCL) ) { res_c[0] = float(u32_upk(UBI[0],1u,15u)); }\n*/\n\n    if( nhv_r[0] >= 0.262364076538086\t&& nhv_r[0] <= 0.902710297241211 ) { res_c[0] = 0.0; }\n    if( nhv_r[0] >= 0.876029204711914\t&& nhv_r[0] <= 0.764857985839844 ) { res_c[0] = 1.0; }\n    if( nhv_r[0] >= 0.533621850585938\t&& nhv_r[0] <= 0.911603994750977 ) { res_c[0] = 0.0; }\n    if( nhv_r[0] >= 0.787092229614258\t&& nhv_r[0] <= 0.449131724243164 ) { res_c[0] = 0.0; }\n\n    if( nhv_r[1] >= 0.342407354125977\t&& nhv_r[1] <= 0.377982144165039 ) { res_c[0] = 1.0; }\n    if( nhv_r[1] >= 0.453578572998047\t&& nhv_r[1] <= 0.057809033813477 ) { res_c[0] = 1.0; }\n    if( nhv_r[1] >= 0.484706514282227\t&& nhv_r[1] <= 0.671474161987305 ) { res_c[0] = 1.0; }\n    if( nhv_r[1] >= 0.057809033813477\t&& nhv_r[1] <= 0.11117121887207  ) { res_c[0] = 0.0; }\n\n    if( nhv_r[2] >= 0.342407354125977\t&& nhv_r[2] <= 0.382428992919922 ) { res_c[0] = 1.0; }\n    if( nhv_r[2] >= 0.755964288330078\t&& nhv_r[2] <= 0.53806869934082  ) { res_c[0] = 1.0; }\n    if( nhv_r[2] >= 0.195661345214844\t&& nhv_r[2] <= 0.217895588989258 ) { res_c[0] = 0.0; }\n    if( nhv_r[2] >= 0.671474161987305\t&& nhv_r[2] <= 0.489153363037109 ) { res_c[0] = 1.0; }\n\n    if( nhv_r[3] >= 0.889369750976563\t&& nhv_r[3] <= 0.978306726074219 ) { res_c[0] = 1.0; }\n    if( nhv_r[3] >= 0.035574790039063\t&& nhv_r[3] <= 0.133405462646484 ) { res_c[0] = 0.0; }\n    if( nhv_r[3] >= 0.88492290222168\t&& nhv_r[3] <= 0.760411137084961 ) { res_c[0] = 0.0; }\n    if( nhv_r[3] >= 0.635899371948242\t&& nhv_r[3] <= 0.257917227783203 ) { res_c[0] = 1.0; }\n\n\tres_c[1] = res_c[0];\n\tres_c[2] = res_c[0];\n    \n//\t----    ----    ----    ----    ----    ----    ----    ----\n//\tShader Output\n//\t----    ----    ----    ----    ----    ----    ----    ----\n\n    if (iMouse.z > 0. && length(iMouse.xy - fragCoord) < 14.0) {\n        res_c[0] = round(mod(float(iFrame),2.0));\n        res_c[1] = 0.0;\n        res_c[2] = 0.0; }\n    if (iFrame == 0) { res_c[0] = reseed(0); res_c[1] = reseed(1); res_c[2] = reseed(2); }\n    fragColor=vec4(res_c[0],res_c[1],res_c[2],1.0);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nts3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[998, 998, 1055, 1105, 1235]]}
{"id": "stsGzN", "name": "kd-house", "author": "sympou", "description": "well, it seems to work (for positive values),\nbut it's a bit complicated for raymarching.", "tags": ["kdtree"], "likes": 6, "viewed": 351, "published": 3, "date": "1621776593", "time_retrieved": "2024-07-30T19:19:17.426682", "image_code": "#define iterations      3\n#define amplitude       0.7\n#define wallThickness   0.03\n#define doorSize        0.1\n\n//Dave_Hoskins's hash function\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec4 kdCell( vec2 p, vec4 limits ) {\n\n    float seed  = floor(iTime*0.25   )*123.456 + 1.111;\n    float seed2 = floor(iTime*0.25+1.)*123.456 + 1.111;\n    float transition = fract(iTime*0.25);\n\n    int k = 1;\n    for (int i = 0; i < iterations; i++) {\n\n        int j = i % 2;\n\n        float r = mix( hash11(seed), hash11(seed2), transition);\n        \n        r = ( (r-0.5)*amplitude + 0.5 ) * (limits[j+2]-limits[j]) + limits[j];\n\n        int c = int(r>p[j]);\n\n        limits[j+c*2] = r;\n        \n        float add = float(k*c);\n        seed  += add;\n        seed2 += add;\n        \n        k += k;\n    }\n    return limits;\n}\n\nfloat sdHouse( in vec2 pos, in vec2 boxSize) {\n\n    //draw ext. corners\n    if ( abs(pos.x)>boxSize.x+wallThickness && abs(pos.y)>boxSize.y+wallThickness ) {\n        vec2 walls2 = abs(pos.xy)-boxSize.xy-wallThickness;\n        return length(walls2);\n    }\n    \n    // current cell coordinates (left up -- right down)\n    vec4 walls = vec4(-boxSize,boxSize);\n    \n    //we find the divided box we are in\n    vec4 cellWalls = kdCell(pos,walls);\n\n    // direction of closest wall (from outside)\n    vec2 w2 = abs(pos) - boxSize;\n    vec2 centerDir = sign(pos) * ( (w2.x>w2.y) ? vec2(1,0) : vec2(0,1));\n\n    //w : side of closest wall (0 to 3)\n    int w = int(centerDir.x + max(centerDir.y*2.0,0.0) + 1.);\n\n    //number of cells to check (1 or 4)\n    //if we are outside of the house, we only check one wall\n    int check = 1 + 3 * int( abs(pos.x)<boxSize.x && abs(pos.y)<boxSize.y );\n\n    float dist2 = 999999.9;\n\n    for (int i = 0; i<check; i++) { \n\n        int w2 = (i+w)%4;\n        int j = (w2+1)%2;\n        int k = 1-j;\n\n        vec2 normals = vec2(j * w2 - j, k * w2 - k * 2);\n\n        //distance from the wall\n        float wallDist = abs(cellWalls[w2]-pos[k]);\n\n        //a point on the other side of the wall\n        vec2 pos2 = pos + normals * ( 0.0001 + wallDist );\n\n        //walls from neighbour cell\n        vec4 cellWalls2 = kdCell(pos2,walls);\n\n        //we place the door on the segment\n        vec2 segment = vec2(max(cellWalls[j],cellWalls2[j]),min(cellWalls[j+2],cellWalls2[j+2]));\n        float center = (segment.x + segment.y)*0.5;\n        float len = abs(segment.x-segment.y)*0.5;\n        float centerDist = abs(center - pos[j]);\n        \n        //closest point\n        vec2 closest = vec2(doorSize - centerDist, wallDist - wallThickness);\n        \n        //adaptative doors (uncomment and remove condition)\n        //closest.x = min(closest.x, len - wallThickness - centerDist);\n\n        //condition : remove door if space is too small\n        closest.x *= float(len - wallThickness > doorSize);\n\n        closest = max(closest, vec2(0.0));\n\n        dist2 = min(dist2, dot( closest,closest ));\n\n    }\n    return sqrt(dist2);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 pos = uv*2.0-1.0;\n    pos.x *= iResolution.x/iResolution.y;\n    pos *= 0.75;\n    \n    //\n    \n    vec2 boxSize = vec2(1.0,0.5);\n\n    float dist = sdHouse(pos,boxSize)*2.;\n    \n    \n    //iq's distance color style\n    //https://www.shadertoy.com/view/3ltSW2\n    vec3 col = vec3(1.0) - sign(dist)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(dist));\n\tcol *= 0.8 + 0.2*cos(150.0*dist);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(dist)) );\n    \n    //masking the inside\n    if (dist<0.0) { col = vec3(1.0); }\n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 183, 206, 206, 291], [293, 293, 329, 329, 916], [918, 918, 964, 989, 3070], [3072, 3072, 3129, 3129, 3744]]}
{"id": "7tf3RM", "name": "Spherical Delinquency", "author": "Fahrenheitrequited", "description": "q", "tags": ["q"], "likes": 2, "viewed": 270, "published": 3, "date": "1621757546", "time_retrieved": "2024-07-30T19:19:18.182660", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and PART_COUNT if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(round(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\nvec3 kifs(vec3 p) \n{\n  \n  float t = surge(time);\n  float s = 1.;\n  for ( float i = 0.; i <5.; i++ ) {\n  \n    p.xy *= rot((t-i));\n    p.yz *= rot((t+i) * .7);\n    p = abs(p);\n    p -= s;\n    s *= 0.65;\n  }\n  return p;\n}\n\nfloat map(vec3 p) {\n\n /*\n  float r = sph(p, 4.);\n\n  float t1 = time;\n  vec3 q = vec3(0);\n  q += kifs(p + kifs(p)/4.);\n  q += kifs(p + kifs(p)/5.);\n  \n  \n  p = rep(p, vec3(0,15,15) * sin(surge(t1 * .17)));\n  float s = sph(p + vec3(8,0,0) , 2.);\n  \n  \n  float f1= cylcap(q,3.,.1);\n  float f2 = min(f1,s);\n  \n return f2;\n */\n  float t1 = time;\n  float t = tor(p + vec3(0,0,5), vec2(3.,1.));\n  \n  vec3 q = rep(p, vec3(20,20,0) * sin(surge(t1 * .17)));\n  float s = sph(q , 1.);\n  return min(s,t);\n \n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist)*3.0,0.0,1.0);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = surge(iTime/1.);\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0.0,0.0,-20.);\n  s.xz *= rot(time);\n  s.yz *= rot(time * .83);\n  \n  \n  vec3 t=vec3(0,0,0);\n  s.xy *= rot(surge(time*1.));\n  s.xz *= rot(surge(time*1.) * .61);\n  s *= sin(surge(iTime)) * .5 + 0.9;\n  float t2 = time*0.5;\n\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n  float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  float dither=0.5+0.1*rand;\n  \n  for(float z=0.; z<100.; ++z) {\n    i = z;\n    d=map(p) *.5;\n    if(d<0.01) {\n      vec3 n = norm(p);\n      r = reflect(n,r);\n      d = 2.;\n      //break;\n    }\n    if ( dd > 100.) break;\n    dd += d;\n    p+=r*d;\n  }\n\n  vec3 col=vec3(0);\n  vec3 n = norm(p);\n  vec3 l =normalize(vec3(-0.2,0.2,0.5));\n  float t1=sin(time*0.2);\n  l.xz *= rot(t1);\n  l.xy *= rot(t1*3.2);\n  vec3 h = normalize(l-r);\n  float f = pow(1.0-abs(dot(n,r)), 3.0);\n  float fog = pow(1.0-float(i)/100.0,2.0);\n  \n  \n  col = 1. - pow(vec3(i/300.),vec3(.8));\n  col *= fog ;\n  fragColor = vec4(col, 1);\n\n  //float aodist=0.7;\n  //float ao = getao(p,n,aodist*0.2) * (getao(p,n,aodist*0.35)*0.5+0.5) * (getao(p,n,aodist*0.6)*0.25+0.75);\n  //float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n\n  //vec3 back = mix(vec3(0.7,0.2,0.1), vec3(1,0.7,0.2), pow(max(0.0,dot(r,l)),5.0));\n\n  //float diff = fbm(p*15.0);\n  //diff=abs(diff-0.3)*2;\n  //diff=pow(smoothstep(0.1,0.9,diff),5.0)*2.7+0.9;\n  \n  //col += max(0.0,dot(n,l)*0.5+0.5) * fog * ao * (vec3(1,0.7,0.3) + pow(max(0.0,dot(n,h)),20.0));\n  //col += vec3(0.7,0.2,0.1)*0.5*pow(n.y*0.5+0.5,3.0);\n  //col += sss * fog * back * vec3(1,0.2,0.2) * 1.5 * diff;\n  //col += 3.0*f*(-n.y*0.5+0.5)*fog;\n  \n  //float len = length(p-s);\n  //col += back * max(clamp(d,0.0,1.0), clamp(dot(p-s,p-s)/200.0,0.0,1.0));\n\n  //vec3 col2 = vec3(0);\n  //for(int j=1; j<PART_COUNT; ++j) {\n  //  float dist = float(j) * 0.2/r.z;\n  //  if(dist>len) break;\n  //  vec3 vp = vec3(s.x,s.y,0) + r*dist;\n  //  vp.xy *=rot(sin(vp.z*10.0+time*0.2));\n  //  \n  //  col2 += dots(vp, float(j)) * clamp(1.0-dist/float(PART_COUNT), 0.0,1.0);\n  //}\n  //col += col2 * back;\n\n  //col *= pow(clamp(1.2-length(uv),0.0,1.0)*1.3,1.7);\n  //col = vec3(rnd(uv));\n  \n  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3RM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 365, 365, 433], [435, 435, 463, 463, 487], [488, 488, 517, 517, 604], [605, 605, 647, 647, 754], [756, 756, 784, 784, 810], [812, 812, 840, 840, 873], [876, 876, 923, 923, 969], [973, 973, 1014, 1014, 1182], [1184, 1184, 1203, 1203, 1272], [1274, 1274, 1295, 1295, 1586], [1588, 1588, 1607, 1607, 1715], [1717, 1717, 1756, 1756, 1833], [1835, 1835, 1871, 1871, 1949], [1951, 1951, 1971, 1971, 2065], [2088, 2088, 2112, 2112, 2167], [2169, 2169, 2189, 2189, 2387], [2389, 2389, 2408, 2710, 2884], [2886, 2886, 2905, 2905, 3024], [3026, 3026, 3067, 3067, 3113], [3115, 3115, 3157, 3157, 3202], [3204, 3204, 3224, 3224, 3267], [3269, 3269, 3288, 3288, 3367], [3370, 3370, 3427, 3427, 5892]]}
{"id": "Nd23Dt", "name": "Solving Quintic Equations Study", "author": "oneshade", "description": "Working on ways to solve quintic equations. I'm hoping to implement the exact solution (not necessarily \"in radicals\"). Idea for testing based on mattz's analytic quartic solver shader.", "tags": ["math", "equation", "quintic", "polynomial"], "likes": 9, "viewed": 207, "published": 3, "date": "1621740674", "time_retrieved": "2024-07-30T19:19:19.301669", "image_code": "//#define CONSTRUCT_FROM_ROOTS\n#define METHOD 3\n\n// Arrays seem buggy so I tried using structs\nstruct GeneralQuintic { float a; float b; float c; float d; float e; float f; };\nstruct ReducedQuintic { float p; float q; float r; float s; float offs; };\nstruct Float5 { float _0; float _1; float _2; float _3; float _4; };\nstruct Roots5 { int nroots; Float5 roots; };\n\n// Hack to prevent loop unrolling (linear search is heavy on it)\n#define ZERO min(iFrame, 0)\n\n// Getters and setters for every field! XD See https://www.youtube.com/watch?v=-AQfQFcXac8\n// I don't care too much for these so I've squashed them into single lines to keep them out of the way\nfloat get(in Float5 arr, in int idx) { switch(idx) { case 0: return arr._0; case 1: return arr._1; case 2: return arr._2; case 3: return arr._3; case 4: return arr._4; } }\nvoid set(inout Float5 arr, in int idx, in float val) { switch(idx) { case 0: arr._0 = val; case 1: arr._1 = val; case 2: arr._2 = val; case 3: arr._3 = val; case 4: arr._4 = val; } }\n\n// Evaluates the quintic equation\nfloat evalQuintic(in float x, in GeneralQuintic q) {\n    return ((((q.a * x + q.b) * x + q.c) * x + q.d) * x + q.e) * x + q.f;\n}\n\nfloat evalReducedQuintic(in float x, in ReducedQuintic q) {\n    return (((x * x + q.p) * x + q.q) * x + q.r) * x + q.s;\n}\n\n// Evaluates the derivative of the quintic equation\nfloat evalQuinticPrime(in float x, in GeneralQuintic q) {\n    return (((5.0 * q.a * x + 4.0 * q.b) * x + 3.0 * q.c) * x + 2.0 * q.d) * x + q.e;\n}\n\nfloat evalReducedQuinticPrime(in float x, in ReducedQuintic q) {\n    return ((5.0 * x * x + 3.0 * q.p) * x + 2.0 * q.q) * x + q.r;\n}\n\n// Generates coefficients for a quintic with five real roots\n// The idea is to construct five linear factors that share the roots and multiply them out\n// The choice is somewhat arbitrary but I chose:\n// (x - x1)(x - x2)(x - x3)(x - x4)(x - x5)\nvoid quinticFromRoots(in float x1, in float x2, in float x3, in float x4, in float x5, inout GeneralQuintic q) {\n    q.a = 1.0;\n    q.b = -x1 - x2 - x3 - x4 - x5;\n    q.c = x1 * x2 + x3 * x4 + (x1 + x2) * (x3 + x4) + (x1 + x2 + x3 + x4) * x5;\n    q.d = -(x1 + x2) * x3 * x4 - x1 * x2 * (x3 + x4) - (x1 * x2 + x3 * x4 + (x1 + x2) * (x3 + x4)) * x5;\n    q.e = x1 * x2 * x3 * x4 + ((x1 + x2) * x3 * x4 + x1 * x2 * (x3 + x4)) * x5;\n    q.f = -x1 * x2 * x3 * x4 * x5;\n}\n\n// Eliminates the x^4 term and divides by the leading coefficient\n// The resulting equation has roots offset from the original by -b/5a\n// and has the form: y^5 + py^3 + qy^2 + ry + s\n// TODO: simplify out lots of reused values\nReducedQuintic tschirnhausLinear(in GeneralQuintic eq) {\n    float a = eq.a, b = eq.b, c = eq.c, d = eq.d, e = eq.e, f = eq.f;\n    b /= a, c /= a, d /= a, e /= a, f /= a;\n    float p = c - 2.0 * b * b / 5.0;\n    float q = d - 3.0 * b * c / 5.0 + 4.0 * b * b * b / 25.0;\n    float r = e - 2.0 * b * d / 5.0 + 3.0 * b * b * c / 25.0 - 3.0 * b * b * b * b / 125.0;\n    float s = f -       e * b / 5.0 +       b * b * d / 25.0 -       b * b * b * c / 125.0 + 4.0 * b * b * b * b * b / 3125.0;\n    return ReducedQuintic(p, q, r, s, b / 5.0);\n}\n\n// Linear searching method for solving a quintic equation, pretty low quality\nRoots5 solveQuinticLinSearch(in GeneralQuintic eq, in float bmin, in float bmax, in float epsilon, in bool wrap, in int searches, in int iters) {\n    Roots5 roots = Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    float interval = 1.0 / float(searches);\n    float start = 0.0;\n\n    // Take equally spaced steps over the interval\n    for (int search=ZERO; search < searches; search++) {\n        // Apply newton-raphson\n        float root = mix(bmin, bmax, start);\n        for (int nrIter=0; nrIter < iters; nrIter++) {\n            float nrStep = root -= evalQuintic(root, eq) / evalQuinticPrime(root, eq);\n            if (wrap) root = bmin + mod(root - bmin, bmax - bmin); // Wrap to stay in the interval\n            if (abs(nrStep) < epsilon) break; // Potential early out\n        }\n\n        // Make sure this is a unique root (get rid of solutions that converge to the same spot)\n        bool unique = true;\n        for (int n=ZERO; n < roots.nroots; n++) {\n            if (abs(root - get(roots.roots, n)) < epsilon) {\n                unique = false;\n                break;\n            }\n        }\n\n        // Only use this solution if it is nearly a true root and is unique\n        if (abs(evalQuintic(root, eq)) < epsilon && unique) {\n            set(roots.roots, roots.nroots, root);\n            roots.nroots++;\n        }\n\n        // Step forward and take another chance at an early out\n        start += interval;\n        if (roots.nroots == 5) break;\n    }\n\n    return roots;\n}\n\n// Quartic solver from this paper: https://www.maa.org/sites/default/files/pdf/upload_library/22/Ford/auckly29.pdf\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = c - 0.375 * bb;\n    float q = d -   0.5 * b * c + 0.125 * bb * b;\n    float r = e -  0.25 * b * d +         bb * c / 16.0 - 3.0 * bb * bb / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\n// Preliminary root searching guaranteed to converge on the root if it is bracketed\nfloat bisection(in GeneralQuintic eq, in float bmin, in float bmax, in int bisections) {\n    for (int bisection=0; bisection < bisections; bisection++) {\n        float v1 = evalQuintic(bmin, eq), v2 = evalQuintic(bmax, eq);\n        if (abs(v1) > abs(v2)) bmin = 0.5 * (bmin + bmax);\n        else bmax = 0.5 * (bmin + bmax);\n    }\n\n    return 0.5 * (bmin + bmax);\n}\n\n// Converges faster than bisection but sensitive to the starting point, used in the final step\nfloat newton(in GeneralQuintic eq, in float x0, in float bmin, in float bmax, in int newtonSteps) {\n    float backup = x0;\n    for (int nrStep=0; nrStep < newtonSteps; nrStep++) {\n        x0 -= evalQuintic(x0, eq) / evalQuinticPrime(x0, eq);\n        if (x0 < bmin || x0 > bmax) return backup; // Early out if newton-raphson goes out of bounds (safe to assume nonconvergence)\n    }\n\n    // Prevent the root from getting messed up by newton-raphson because of big or small slope\n    float v1 = evalQuintic(backup, eq), v2 = evalQuintic(x0, eq);\n    if (abs(v1) < abs(v2)) return backup;\n    else return x0;\n}\n\n// Searches for roots between the critical points (local minima and maxima)\n// Fails when there are no critical points, ex. x^5 + x - 1\nRoots5 solveQuinticBracket(in GeneralQuintic eq, in int bisections, in int newtonSteps) {\n    // Solve for the roots of the derivative (a quartic) to get the critical points\n    vec4 brackets;\n    Roots5 roots = Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    int nBrackets = solveQuartic(5.0 * eq.a, 4.0 * eq.b, 3.0 * eq.c, 2.0 * eq.d, eq.e, brackets);\n\n    // No brackets, failed to find roots\n    // TODO: these cases are pretty simple quintics, look for another root finding solution\n    if (nBrackets == 0) return Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n\n    // Search for roots between critical points\n    for (int n=0; n < nBrackets - 1; n++) {\n        float brack1 = brackets[n], brack2 = brackets[n + 1];\n        float e1 = evalQuintic(brack1, eq), e2 = evalQuintic(brack2, eq);\n\n        // Bracketed section doesn't cross the x axis, no roots\n        if (!(min(e1, e2) < 0.0 && max(e1, e2) > 0.0)) return Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n\n        // Apply bisection, then newton-raphson\n        float bmin = min(brack1, brack2), bmax = max(brack1, brack2);\n        set(roots.roots, roots.nroots, newton(eq, bisection(eq, bmin, bmax, bisections), bmin, bmax, newtonSteps));\n        roots.nroots++;\n    }\n\n    // Flip inner bracket on one side to the outside to try capturing roots outside the critical points\n    // Not sure if this is foolproof but it appears to work and make sense\n    float brack1 = 2.0 * brackets[0] - brackets[1], brack2 = brackets[0];\n    float e1 = evalQuintic(brack1, eq), e2 = evalQuintic(brack2, eq);\n    if (!(min(e1, e2) < 0.0 && max(e1, e2) > 0.0)) return Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    float bmin = min(brack1, brack2), bmax = max(brack1, brack2);\n    set(roots.roots, roots.nroots, newton(eq, bisection(eq, bmin, bmax, bisections), bmin, bmax, newtonSteps));\n    roots.nroots++;\n\n    // Repeat on opposite side\n    brack1 = brackets[nBrackets - 1], brack2 = 2.0 * brackets[nBrackets - 1] - brackets[nBrackets - 2];\n    e1 = evalQuintic(brack1, eq), e2 = evalQuintic(brack2, eq);\n    if (!(min(e1, e2) < 0.0 && max(e1, e2) > 0.0)) return Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    bmin = min(brack1, brack2), bmax = max(brack1, brack2);\n    set(roots.roots, roots.nroots, newton(eq, bisection(eq, bmin, bmax, bisections), bmin, bmax, newtonSteps));\n    roots.nroots++;\n\n    return roots;\n}\n\nRoots5 solveQuinticPolyDiv(in GeneralQuintic eq, in int newtonSteps) {\n    Roots5 roots = Roots5(1, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    //ReducedQuintic rEq = tschirnhausLinear(eq);\n\n    // TODO: choose better starting point (or is this good enough???)\n    float x1 = -0.2 * eq.b / eq.a; // Inflection point\n    float y1 = abs(evalQuintic(x1, eq));\n\n    // SOSO (Same Opposite Same Opposite) approximation of roots\n    // Roots are approximately solutions to:\n    // ax^5 + bx^4 + cx^3 + dx^2 + ex + f = ax^5 - bx^4 + cx^3 - dx^2 + ex - f\n    // ---> bx^4 + dx^2 + f = 0 ---> b(x^2)^2 + d(x^2) + f = 0\n    // Which is a quadratic in x^2 that has four roots:\n    // x1, x2, x3, x4 = (+/-)sqrt((-d +/- sqrt(d^2 - 4bf))/2b)\n    float h = eq.d * eq.d - 4.0 * eq.b * eq.f;\n    if (h > 0.0) {\n        h = sqrt(h);\n        float da = 2.0 * eq.b;\n\n        float x2 = (-eq.d + h) / da;\n        if (x2 > 0.0) {\n            x2 = sqrt(x2);\n            float y2 = abs(evalQuintic(x2, eq));\n            if (y2 < y1) x1 = x2, y1 = y2;\n\n            x2 = -x2;\n            y2 = abs(evalQuintic(x2, eq));\n            if (y2 < y1) x1 = x2, y1 = y2;\n        }\n\n        x2 = (-eq.d - h) / da;\n        if (x2 > 0.0) {\n            x2 = sqrt(x2);\n            float y2 = abs(evalQuintic(x2, eq));\n            if (y2 < y1) x1 = x2, y1 = y2;\n\n            x2 = -x2;\n            y2 = abs(evalQuintic(x2, eq));\n            if (y2 < y1) x1 = x2, y1 = y2;\n        }\n    }\n\n    for (int n=0; n < newtonSteps; n++) {\n        float newtonStep = evalQuintic(x1, eq) / evalQuinticPrime(x1, eq);\n        x1 -= newtonStep;//min(abs(newtonStep), 1.0) * sign(newtonStep);\n    }\n\n    set(roots.roots, 0, x1);\n    vec4 factorRoots;\n    float qa = eq.a, qb = qa * x1 + eq.b, qc = qb * x1 + eq.c, qd = qc * x1 + eq.d, qe = qd * x1 + eq.e;\n    int nFactorRoots = solveQuartic(qa, qb, qc, qd, qe, factorRoots);\n    for (int n=0; n < nFactorRoots; n++) { set(roots.roots, n + 1, factorRoots[n]); }\n    roots.nroots += nFactorRoots;\n\n    return roots;\n}\n\nvec2 cmul(in vec2 z, in vec2 w) { return mat2(z, -z.y, z.x) * w; }\nvec2 cdiv(in vec2 z, in vec2 w) { return cmul(z, vec2(w.x, -w.y)) / dot(w, w); }\nRoots5 solveQuinticDurandKerner(in GeneralQuintic q) {\n    // TODO: refactor\n    // Reduction to x^5 + px^3 + qx^2 + rx + s\n    ReducedQuintic r = tschirnhausLinear(q);\n\n    float bound = 1.0 + max(1.0, max(abs(r.p), max(abs(r.q), max(abs(r.r), abs(r.s)))));\n    //bound *= 0.414213562373; // Correction if perturbing with random([-1...1])\n    bound *= 0.5; // Keep safely within bounds\n\n    vec2[5] roots;\n    roots[0] = vec2(bound, 0.0); // QuinticRootOfUnity^0\n    roots[1] = vec2(0.309016994375, 0.951056516295) * bound; // QuinticRootOfUnity^1\n    roots[2] = vec2(-0.809016994375, 0.587785252292) * bound; // QuinticRootOfUnity^2\n    roots[3] = vec2(-0.809016994375, -0.587785252292) * bound; // QuinticRootOfUnity^3\n    roots[4] = vec2(0.309016994375, -0.951056516295) * bound; // QuinticRootOfUnity^4\n\n    for (int iter=0; iter < 25; iter++) {\n        float maxEval = -1e20;\n        for (int root=0; root < 5; root++) {\n            vec2 z = roots[root];\n            vec2 quinticVal = cmul(cmul(cmul(cmul(z, z) + vec2(r.p, 0.0), z) + vec2(r.q, 0.0), z) + vec2(r.r, 0.0), z) + vec2(r.s, 0.0);\n            maxEval = max(maxEval, max(abs(quinticVal.x), abs(quinticVal.y)));\n\n            vec2 denom = z - roots[(root + 1) % 5];\n            denom = cmul(denom, z - roots[(root + 2) % 5]);\n            denom = cmul(denom, z - roots[(root + 3) % 5]);\n            denom = cmul(denom, z - roots[(root + 4) % 5]);\n\n            roots[root] -= cdiv(quinticVal, denom);\n        }\n\n        if (maxEval < 1e-7) break;\n    }\n\n    // Undo substitution y = x + b/5a\n    // and weed out complex roots\n    Roots5 realRoots = Roots5(0, Float5(0.0, 0.0, 0.0, 0.0, 0.0));\n    for (int root=0; root < 5; root++) {\n        vec2 z = roots[root];\n        if (abs(z.y) < 1e-7) {\n            set(realRoots.roots, realRoots.nroots, z.x - r.offs);\n            realRoots.nroots++;\n        }\n    }\n\n    return realRoots;\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n    float time = iTime;\n\n    #ifdef CONSTRUCT_FROM_ROOTS\n    time *= 0.25;\n    #endif\n\n    // Generate random animated roots\n    #ifdef CONSTRUCT_FROM_ROOTS\n    float state = 0.0;\n    Float5 x = Float5(0.0, 0.0, 0.0, 0.0, 0.0);\n    for (int n=0; n < 5; n++) {\n        set(x, n, mix(Hash11(floor(time) + state), Hash11(ceil(time) + state), smoothstep(0.0, 1.0, fract(time))) * 6.0 - 3.0);\n        state += 17.13;\n    }\n\n    GeneralQuintic q;\n    quinticFromRoots(x._0, x._1, x._2, x._3, x._4, q);\n\n    #else\n    GeneralQuintic q;\n    q.a = sin(time * 0.25) * 1.25;\n    q.b = sin(time) * 2.0;\n    q.c = sin(time) * 2.0;\n    q.d = cos(time * 0.75);\n    q.e = sin(time * 0.5);\n    q.f = cos(time);\n\n    #endif\n\n    // Draw root bounds\n    if (-max(0.0, 1.0 + max(q.b / q.a, max(-q.c / q.a, max(q.d / q.a, max(-q.e / q.a, q.f / q.a))))) < uv.x &&\n        uv.x < max(0.0, 1.0 + max(-q.b / q.a, max(-q.c / q.a, max(-q.d / q.a, max(-q.e / q.a, -q.f / q.a)))))) {\n        color.rb += 0.5;\n    }\n\n    // Draw the x axis and quintic equation\n    float fx = evalQuintic(uv.x, q);\n    float dx = evalQuinticPrime(uv.x, q); // Derivative for distance estimation\n    color.b += smoothstep(unit, 0.0, abs(uv.y));\n    color.rg += smoothstep(unit, 0.0, abs(uv.y - fx) / sqrt(1.0 + dx * dx));\n\n    // Draw the critical points\n    vec4 critical;\n    int nCritical = solveQuartic(5.0 * q.a, 4.0 * q.b, 3.0 * q.c, 2.0 * q.d, q.e, critical);\n    for (int n=0; n < nCritical; n++) {\n        color = mix(color, vec3(1.0, 0.25, 0.0), smoothstep(unit, 0.0, length(uv - vec2(critical[n], evalQuintic(critical[n], q))) - 0.05));\n    }\n\n    // Solve and draw expected versus found roots\n    #if METHOD == 0\n    Roots5 roots = solveQuinticLinSearch(q, -4.0, 4.0, 0.001, true, 20, 10);\n    #endif\n\n    #if METHOD == 1\n    Roots5 roots = solveQuinticBracket(q, 10, 3);\n    #endif\n\n    #if METHOD == 2\n    Roots5 roots = solveQuinticPolyDiv(q, 25);\n    #endif\n\n    #if METHOD == 3\n    Roots5 roots = solveQuinticDurandKerner(q);\n    #endif\n\n    for (int n=0; n < 5; n++) {\n        if (n < roots.nroots) color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - vec2(get(roots.roots, n), 0.0)) - 0.05));\n\n        #ifdef CONSTRUCT_FROM_ROOTS\n        color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(length(uv - vec2(get(x, n), 0.0)) - 0.1)));\n        #endif\n    }\n\n    // Debug bisection solver (I accidentally made it incorrect at first)\n    if (iMouse.z > 0.0) {\n        float test = bisection(q, min(mouse.x, mouse.z), max(mouse.x, mouse.z), 25);\n        if (uv.x > min(mouse.x, mouse.z) && max(mouse.x, mouse.z) > uv.x) color = mix(color, vec3(1.0, 0.0, 1.0), 0.5);\n        color = mix(color, vec3(0.0, 1.0, 0.8), smoothstep(unit, 0.0, length(uv - vec2(test, 0.0)) - 0.05));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd23Dt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[460, 654, 692, 692, 825], [826, 826, 880, 880, 1008], [1010, 1044, 1096, 1096, 1172], [1174, 1174, 1233, 1233, 1295], [1297, 1349, 1406, 1406, 1494], [1496, 1496, 1560, 1560, 1628], [1630, 1875, 1987, 1987, 2339], [2341, 2569, 2625, 2625, 3107], [3109, 3187, 3332, 3332, 4668], [4670, 4785, 4809, 4809, 4852], [4853, 4853, 4949, 4949, 6940], [6942, 7026, 7114, 7114, 7390], [7392, 7487, 7586, 7586, 8093], [8095, 8231, 8320, 8404, 10597], [10599, 10599, 10669, 10669, 12604], [12606, 12606, 12639, 12639, 12672], [12673, 12673, 12706, 12706, 12753], [14651, 14740, 14766, 14766, 14852], [14854, 14854, 14909, 14928, 17989]]}
{"id": "NlXGR7", "name": "Double pendulum Fractal", "author": "Txoka", "description": "Every double pendulum initialization plotted.", "tags": ["rk4", "doublependulum"], "likes": 11, "viewed": 540, "published": 3, "date": "1621725209", "time_retrieved": "2024-07-30T19:19:20.159375", "image_code": "vec3 palete(float x){return 0.7+0.3*sin(x/20.+vec3(1,2,3));}\n//#define TEXTURE\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 pos=tf(iChannel0,ivec2(fragCoord),0).xy;\n    fragColor=vec4(palete((pos.x+pos.y)*pi*10.),0);\n    //fragColor=tf(iChannel0,ivec2(fragCoord),0);\n    //fragColor*=fragColor;\n#ifdef TEXTURE\n    fragColor=texture(iChannel1,pos.xy/pi/2.+0.5);\n#endif\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define tf texelFetch\nconst float pi=4.*atan(1.);\n\n\nconst float m1=\t1.;\nconst float m2= 1.;\n\nconst float l1=\t0.5;\nconst float l2=\t0.5;\n\nconst float g=9.8;\n\nconst float dt=\t1./60.;", "buffer_a_code": "\nbool keyPress(int ascii) { return (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.); }\n\nvec4 acc(vec4 s){\n\tvec4 f;\n\tf.x = s.z*dt;\n\tf.y = s.w*dt;\n\t\n    float d=s.x-s.y;\n    float c1=cos(d);\n    float s1=sin(d);\n    \n    float a=2.*m1+m2*(1.-cos(2.*d));\n    \n\tf.z =-g*(2.*m1+m2)*sin(s.x)-m2*g*sin(s.x-2.*s.y)-2.*s1*m2*(s.w*s.w*l2+s.z*s.z*l1*c1);\n\tf.z/=l1*a;\n    f.z*=dt;\n    \n    f.w =2.*s1*(s.z*s.z*l1*(m1+m2)+g*(m1+m2)*cos(s.x)+s.w*s.w*l2*m2*c1);\n\tf.w/=l2*a;\n    f.w*=dt;\n    \n    return f;\n}\n\nvoid RK4(inout vec4 s){\n\tvec4 k1 = acc(s\t\t\t);\n\tvec4 k2 = acc(s + k1*.5\t);\n\tvec4 k3 = acc(s + k2*.5\t);\n\tvec4 k4 = acc(s + k3\t);\n    vec4 d=(k1 + k4) / 6. + (k2 + k3) / 3.;\n\ts += d;\n    s.xy = mod(s.xy + pi, 2. * pi) - pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 s=texelFetch(iChannel0,ivec2(fragCoord),0);\n    RK4(s);\n    if(iFrame==0||keyPress(32))s=vec4(2.*pi*fragCoord.xy/iResolution.xy-pi,0,0);\n    fragColor=s;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXGR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 60], [61, 79, 135, 135, 390]]}
{"id": "Nlf3zM", "name": "Overlapping (codegolf)", "author": "oneshade", "description": "Can it get shorter?\nDrag the blue square around with the mouse.", "tags": ["intersection", "twotweets", "overlap", "codegolf"], "likes": 3, "viewed": 142, "published": 3, "date": "1621722928", "time_retrieved": "2024-07-30T19:19:20.935300", "image_code": "/* Shorter version by Xor (157 chars) */\nvoid mainImage(out vec4 o, vec2 u) {\n    o = vec4(u, iMouse) / iResolution.xyxy - .5;\n    o = abs(vec4(o.xy - o.zw, o)) - vec2(.15, .2).xyyx;\n    o.rb = step(max(o.zx, o.wy), u - u);\n    o.g = o.r * o.b;\n}\n/**/\n\n/* Original version (187 chars) *\nvoid mainImage(out vec4 o, in vec2 u) {\n    o = iResolution.xyxy, o = (vec4(iMouse.xy, u) - .5 * o) / o;\n    o = abs(vec4(o.zw - o.xy, o.zw)) - vec2(.15, .2).xyyx;\n    o.rb = vec2(max(o.z, o.w) < 0., max(o.x, o.y) < 0.);\n    o.g = o.r * o.b;\n}\n**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlf3zM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 77, 77, 246]]}
{"id": "7ll3zN", "name": "smallerpt", "author": "ockiller", "description": "Yet another path tracer inspired from Kevin Beason excellent smallpt. No refractions, but introduced some more advanced sampling strategies.\nNow should be unbiased.", "tags": ["raytracing", "pathtracing", "bluenoise", "smallpt", "lowdiscrepancy", "r2"], "likes": 20, "viewed": 1682, "published": 3, "date": "1621717349", "time_retrieved": "2024-07-30T19:19:21.687290", "image_code": "// See Buffer A\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = sqrt(fragColor / fragColor.w); // cheap sRGB\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define RAYS_PER_PIXEL 6\n#define NEXT_EVENT_ESTIMATION\n\n\n\n///////////////////////\n// Scene description //\n///////////////////////\n\n#define DIFF   0\n#define GLOSSY 1\n#define METAL  2\n\nstruct Sphere {\n    vec3 color, position;\n    float radius;\n    int material;\n};\n\n#define NB_LIGHTS 1\nSphere lights[NB_LIGHTS] = Sphere[](\n    Sphere(vec3(6.0), vec3(0.0, 0.0, 1.5), 0.75, 0)\n);\n\n#define RWALL 1e2    // Radius of wall spheres\n#define RADIUS 0.5   // Radius of spheres\n#define NB_SPHERES 7\nconst Sphere spheres[NB_SPHERES] = Sphere[](\n    Sphere(vec3(0.9, 0.9, 0.9), vec3( 0.0  ,  0.0  ,  RWALL       ), RWALL - 1.0, DIFF  ), // top\n    Sphere(vec3(0.9, 0.9, 0.9), vec3( 0.0  ,  0.0  , -RWALL       ), RWALL - 1.0, DIFF  ), // bottom\n    Sphere(vec3(0.9, 0.9, 0.9), vec3( RWALL,  0.0  ,  0.0         ), RWALL - 1.0, DIFF  ), // front\n    Sphere(vec3(0.9, 0.1, 0.1), vec3( 0.0  ,  RWALL,  0.0         ), RWALL - 1.3, DIFF  ), // left red\n    Sphere(vec3(0.1, 0.1, 0.9), vec3( 0.0  , -RWALL,  0.0         ), RWALL - 1.3, DIFF  ), // right blue\n    Sphere(vec3(0.1, 0.9, 0.1), vec3(-0.4  , -0.5  ,  RADIUS - 1.0), RADIUS     , GLOSSY), // green sphere\n    Sphere(vec3(0.9, 0.9, 0.1), vec3( 0.4  ,  0.5  ,  RADIUS - 1.0), RADIUS     , METAL )  // yellow sphere\n);\n\n\n\n////////////////\n// Raytracing //\n////////////////\n\n// Intersect a sphere with a ray starting at O with direction D\n// If intersection is found before tmax, return true and update tmax with the new intersection distance\n// Back faces are ignored\nbool intersect(Sphere s, vec3 O, vec3 D, inout float tmax) {\n    vec3 L = s.position - O;\n    float tc = dot(D, L);\n    float t = tc - sqrt(s.radius * s.radius + tc * tc - dot(L, L));\n    if (t > 0.0 && t < tmax) {\n        tmax = t;\n        return true;\n    }\n    return false;\n}\n\n// Intersect all the spheres\n// Return the intersected sphere index, or -1 if no sphere found before tmax\n// If intersection is found, tmax is updated with the new intersection distance\nint intersectSpheres(vec3 O, vec3 D, inout float tmax) {\n    int imin = -1;\n    for (int i = 0; i < NB_SPHERES; i++)\n        if (intersect(spheres[i], O, D, tmax))\n            imin = i;\n    return imin;\n}\n\n// Intersect all the lights\n// Return the intersected light index, or -1 if no light found before tmax\n// If intersection is found, tmax is updated with the new intersection distance\nint intersectLights(vec3 O, vec3 D, inout float tmax) {\n    int imin = -1;\n    for (int i = 0; i < NB_LIGHTS; i++)\n        if (intersect(lights[i], O, D, tmax))\n            imin = i;\n    return imin;\n}\n\n// Evaluate diffuse direct lighting from all lights, for next event estimation\n#ifdef NEXT_EVENT_ESTIMATION\nvec3 directLighting(vec3 O, vec3 N, vec2 r) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < NB_LIGHTS; i++) {\n        Sphere l = lights[i];\n        vec3 LC = l.position - O;\n        float d2 = dot(LC, LC);\n        float invd = inversesqrt(d2);\n        float cosL = sqrt(d2 - l.radius * l.radius) * invd;\n        vec3 L = coneSample(LC * invd, cosL, r);\n        float t = 1e5;\n        if (intersect(l, O, L, t) && intersectSpheres(O, L, t) < 0)\n            color += 2.0 * (1.0 - cosL) * max(0.0, dot(N, L)) * l.color;\n    }\n\n    return color;\n}\n#endif\n\n// Compute the light radiance along a ray starting at O, with direction D.\n// The computation may need to continue with a new ray to get the final color (accumulation),\n// in which case it returns true and update O and D as the new ray to cast.\n// indirectOnly is set to true when direct light evaluation has been done just before,\n// to avoid taking direct illumination into account twice.\nbool radiance(inout vec3 O, inout vec3 D, inout vec3 accumulation, inout vec3 throughput, inout bool indirectOnly) {\n    float t = 1e5;\n    int iSphere = intersectSpheres(O, D, t);\n    int iLight = indirectOnly ? -1 : intersectLights(O, D, t);\n\n    if (iLight >= 0) {\n        // A light has been hit, terminate the path\n        accumulation += throughput * lights[iLight].color;\n    } else if (iSphere >= 0) {\n        // A sphere has been hit, evaluate material\n        Sphere s = spheres[iSphere];\n        O += t * D;\n        vec3 N = normalize(O - s.position);\n        float cosND = max(0.0, dot(N, -D));\n        \n        // Choose whether to evaluate specular or diffuse for glossy material\n        bool evalSpecular = rand.z < fresnel(cosND, vec3(0.04)).x;\n        indirectOnly = false;\n        \n        if (s.material == METAL) {\n            // Tinted mirror\n            throughput *= fresnel(cosND, s.color);\n            D = reflect(D, N);\n        } else if (s.material == GLOSSY && evalSpecular) {\n            // Mirror white specular\n            D = reflect(D, N);\n        } else {\n            // Diffuse, attenuate color with sphere color\n            throughput *= s.color;\n            \n            // Evaluate direct lighting to help converge faster\n            #ifdef NEXT_EVENT_ESTIMATION\n                accumulation += throughput * directLighting(O, N, rand.xy);\n                indirectOnly = true;\n            #endif\n\n            // Continue bouncing around randomly\n            D = cosineSample(N, rand.xy);\n        }\n        \n        return true;\n    }\n    // Else: the ray hits nothing, it escapes the scene and will not contribute\n\n    return false;\n}\n\n\n\n//////////\n// Main //\n//////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const uint raysPerPixel = uint(RAYS_PER_PIXEL);\n    uint frameSeed = uint(iMouse.z > 0.5 ? 0 : iFrame);\n    vec3 blueNoiseSeed = texelFetch(iChannel0, ivec2(fragCoord) & 0x3FF, 0).xyz;\n    \n    // Camera initialization\n    vec2 uv = iMouse.xy == vec2(0.0) ? vec2(0.4, 0.25) : 2.0 * iMouse.xy / iResolution.xy - 1.0;\n    vec3 camPos = vec3(-2.5, uv.x, -uv.y);\n    const float fovy = 60.0, tanFov = tan(fovy * PI / 360.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Raytrace the pixel and accumulate result\n    fragColor.rgb = vec3(0.0);\n    for (uint r = 0u; r < raysPerPixel + uint(ZERO); r++) {\n        // Reset random seed for maximum coherency. Blue noise takes care of the decorrelation.\n        perFrameSeed = frameSeed * raysPerPixel + r;\n        rand = toroidalJitter(sequence3D(perFrameSeed), blueNoiseSeed);\n\n        // Ray setup\n        vec2 uv = 2.0 * (fragCoord + rand.yz) / iResolution.xy - 1.0;\n        uv.x *= -aspectRatio;\n        vec3 O = camPos;\n        vec3 D = normalize(vec3(1.0, tanFov * uv));\n        vec3 accumulation = vec3(0.0);\n        vec3 throughput = vec3(1.0); // Neutral value\n\n        // Trace\n        bool indirectOnly = false;\n        const float russianRoulette = 0.9; // Max albedo of the scene\n        while (radiance(O, D, accumulation, throughput, indirectOnly) && rand.z < russianRoulette) {\n            throughput *= 1.0 / russianRoulette;\n            rand = toroidalJitter(sequence3D(perFrameSeed = lcg(perFrameSeed)), blueNoiseSeed);\n        }\n\n        fragColor.rgb += accumulation;\n    }\n\n    fragColor.rgb *= 1.0 / float(raysPerPixel);\n    fragColor.a = 1.0;\n    \n    if (iMouse.z < 0.5)\n        fragColor += texelFetch(iChannel1, ivec2(fragCoord), 0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415927\n#define ZERO min(0.0, iTime)\n\n\n\n////////////\n// Random //\n////////////\n\n// Seeds are initialized in main\nuint perFrameSeed;\nvec3 rand;\n\nuint lcg(uint i) {\n    return 1103515245u * i + 12345u;\n}\n\n// Return the i-th term of the golden ratio sequence\nfloat goldenSequence(uint i) {\n    return float(2654435769u * i) / 4294967296.0;\n}\n\n// Return the i-th vector of Martin Roberts' R2 sequence\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec2 plasticSequence(uint i) {\n    return vec2(3242174889u * i, 2447445414u * i) / 4294967296.0;\n}\n\n// Combine the two previous sequences\nvec3 sequence3D(uint i) {\n    return vec3(plasticSequence(i), goldenSequence(i));\n}\n\nvec3 toroidalJitter(vec3 x, vec3 jitter) {\n    return 2.0 * abs(fract(x + jitter) - 0.5);\n}\n\n\n\n//////////////\n// Sampling //\n//////////////\n\n// Generate an orthonormal vector basis around N\nvoid genTB(vec3 N, out vec3 T, out vec3 B) {\n    float s = N.z < 0.0 ? -1.0 : 1.0;\n    float a = -1.0 / (s + N.z);\n    float b = N.x * N.y * a;\n    T = vec3(1.0 + s * N.x * N.x * a, s * b, -s * N.x);\n    B = vec3(b, s + N.y * N.y * a, -N.y);\n}\n\n// Generate a random direction around N\n// The direction probability is proportional to the cosinus of the angle relative to N\n// Takes two uniformly distributed random values (r)\nvec3 cosineSample(vec3 N, vec2 r) {\n    vec3 T, B;\n    genTB(N, T, B);\n    r.x *= 2.0 * PI;\n    float s = sqrt(1.0 - r.y);\n    return T * (cos(r.x) * s) + B * (sin(r.x) * s) + N * sqrt(r.y);\n}\n\n// Generate a uniformly distributed random direction in a cone around N\n// Takes two uniformly distributed random values (r)\nvec3 coneSample(vec3 N, float cosTmax, vec2 r) {\n    vec3 T, B;\n    genTB(N, T, B);\n    r.x *= 2.0 * PI;\n    r.y = 1.0 - r.y * (1.0 - cosTmax);\n    float s = sqrt(1.0 - r.y * r.y);\n    return T * (cos(r.x) * s) + B * (sin(r.x) * s) + N * r.y;\n}\n\n\n\n/////////////\n// Shading //\n/////////////\n\n// Schlick-Fresnel approximation\nvec3 fresnel(float cosEN, vec3 F0) {\n    float e = 1.0 - cosEN;\n    float e5 = e * e; e5 *= e5 * e;\n    return (1.0 - e5) * F0 + e5;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ll3zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 72, 72, 195]]}
{"id": "sll3RN", "name": "scene eggs'n'milk", "author": "sirjofri", "description": "trying a more complex scene", "tags": ["raymarching", "sdf"], "likes": 3, "viewed": 297, "published": 3, "date": "1621705086", "time_retrieved": "2024-07-30T19:19:22.444266", "image_code": "// define AA for better performance\n//#define AA\n\nfloat sdist = .002;      // bigger: better performance\nfloat culldist = 20.;    // smaller: better performance\nfloat maxlightdist = 4.; // smaller: better performance\nint basesteps = 256;     // smaller: better performance\nint shadowsteps = 24;    // smaller: better performance\n\nvec3 ambi = vec3(.6, .7, .9);\nvec3 sky = vec3(.3, .35, 1.2);\n\nstruct Sample{\nfloat dist;\nvec3 wp;\nvec3 norm;\nvec3 shadow;\nfloat ao;\nvec3 col;\nint mat;\n};\n\nstruct Map{\nfloat d;\nint m;\n};\n\nstruct Light{\nvec3 p;\nvec3 c;\nfloat d;\n};\n\nMap sdSphere(vec3 p, vec3 pos, float r, int mat)\n{\n    float d = distance(pos, p) - r;\n    return Map(d, d < sdist ? mat : 0);\n}\n\nMap sdBush(vec3 p, vec3 pos, float r, int mat)\n{\n    float d = distance(pos, p) - r - smoothstep(0., 1., texture(iChannel0, p.yz*vec2(.03, .07)+sin(iTime*1.6+p.z*5.)*vec2(0.005, .0)).r)*.6;\n    return Map(d, d < sdist ? mat : 0);\n}\n\nMap sdBox(vec3 p, vec3 pos, vec3 dim, int mat)\n{\n    float d = length(max(vec3(0), abs(p-pos)-dim));\n    return Map(d, d < sdist ? mat : 0);\n}\n\nMap sdGround(vec3 p, float h, int mat)\n{\n    float d = distance(p, vec3(p.x, p.y, h));\n    return Map(d, d < sdist ? mat : 0);\n}\n\nvec3 rotate(vec3 p, vec3 r)\n{\n    mat3 yaw = mat3(\n        cos(r.x), -sin(r.x), 0.,\n        sin(r.x),  cos(r.x), 0.,\n        0.      ,  0.      , 1.\n    );\n    mat3 pitch = mat3(\n        1.,       0.,        0.,\n        0., cos(r.y), -sin(r.y),\n        0., sin(r.y),  cos(r.y)\n    );\n    mat3 roll = mat3(\n         cos(r.z), 0., sin(r.z),\n               0., 1.,       0.,\n        -sin(r.z), 0., cos(r.z)\n    );\n    \n    p *= roll;\n    p *= pitch;\n    p *= yaw;\n    return normalize(p);\n}\n\nMap opUnion(Map a, Map b)\n{\n    float d = min(a.d, b.d);\n    int m = max(a.m, b.m);\n    return Map(d, m);\n}\n\nMap opSubtract(Map a, Map b)\n{\n    float d = max(-a.d, b.d);\n    int m = max(a.m, b.m);\n    return Map(d, m);\n}\n\nMap opIntersect(Map a, Map b)\n{\n    float d = max(a.d, b.d);\n    int m = max(a.m, b.m);\n    return Map(d, m);\n}\n\nMap map(vec3 p)\n{\n    Map bush1 = sdBush(p*vec3(1., 1., .6), vec3(4., -17., 1.1), .5, 6); // right bush\n    Map bush2 = sdBush(p*vec3(1., 1., .6), vec3(1., -17., 1.3), .5, 6); // left bush\n    Map bush3 = sdBush(p*vec3(1., 1., .5), vec3(13., -33., .8), .5, 6); // distant bush right\n    Map bush4 = sdBush(p*vec3(1., 1., .5)-vec3(0., 0., .3), vec3(7.5, -30., -.1), .5, 6); // distant bush left\n    Map ball1 = sdSphere(p*vec3(1., 1., 1.3), vec3(-2.1, -13.5, 1.58), .15, 5); // left ball\n    Map ball2 = sdSphere(p*vec3(1., 1., 1.5), vec3(-1.6, -13.7, 1.79), .15, 5); // right ball\n    Map box = sdBox(p, vec3(-1.4, -13.2, .5), vec3(1.3, 1., .5), 4);\n    Map boxTop = sdBox(p, vec3(-1.4, -13.2, 1.), vec3(1.32, 1.02, .1), 4);\n    Map obox = sdBox(p, vec3(-.7, -13.5, 1.3), vec3(.22, .18, .6), 7);\n    Map wallA = sdBox(p, vec3(-9.5, -15., 3.), vec3(10., .5, 3.), 3);\n    Map wallB = sdBox(p, vec3(1.5, -15, 5.), vec3(1., .5, 1.), 3);\n    Map wallC = sdBox(p, vec3(1.5, -15, .7), vec3(1., .5, .7), 3);\n    Map wallD = sdBox(p, vec3(5.5, -15, 3.), vec3(3., .5, 3.), 3);\n    Map wall = opUnion(opUnion(opUnion(wallA, wallB), wallC), wallD);\n    Map ground = sdGround(p, 0., 1);\n    Map bushes = opUnion(opUnion(bush1, bush2), opUnion(bush3, bush4));\n    Map objects = opUnion(opUnion(opUnion(ball1, ball2), obox), bushes);\n    return opUnion(opUnion(opUnion(wall, ground), opUnion(box, boxTop)), objects);\n}\n\n/* Thanks iq */\nvec3 getNormal(vec3 p)\n{\n    const float h = 0.0002;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.);\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(p+e*h).d; /* btw: s/pos/p */\n    }\n    return normalize(n);\n}\n\nfloat getAO(Sample s)\n{\n    float d = .18;\n    return clamp(mix(.5, 1., map(s.wp + s.norm*d).d/d), 0., 1.);\n}\n\nvec3 wood(Sample s)\n{\n    vec3 col = vec3(1., .4, .05);\n    float top = texture(iChannel0, s.wp.xy*vec2(.3, 1.)).r;\n    float left = texture(iChannel0, s.wp.yz*vec2(.1, 1.)).r;\n    float front = texture(iChannel0, s.wp.xz*vec2(.1, 1.)).r;\n    float m = mix(left, front, dot(s.norm, vec3(0., 1., 0.)));\n    m = mix(m, top, dot(s.norm, vec3(0., 0., 1.)));\n    \n    return col*pow(m, 1.8);\n}\n\nvec3 clay(Sample s)\n{\n    vec3 col = vec3(1., .4, .4);\n    float top = texture(iChannel1, s.wp.xy*2.).r;\n    float left = texture(iChannel1, s.wp.yz*2.).g;\n    float front = texture(iChannel1, s.wp.xz*2.).b;\n    float m = mix(left, front, dot(s.norm, vec3(0., 1., 0.)));\n    m = mix(m, top, dot(s.norm, vec3(0., 0., 1.)));\n    \n    return col*pow(m, .6);\n}\n\nvec3 concrete(Sample s)\n{\n    vec3 top = texture(iChannel0, s.wp.xy).rgb;\n    vec3 left = texture(iChannel0, s.wp.yz).rgb;\n    vec3 front = mix(texture(iChannel0, s.wp.xz).rgb, texture(iChannel0, s.wp.xz+vec2(.3, -.2)).rgb, smoothstep(0.3, .8, texture(iChannel1, s.wp.xz*.01).r));\n    vec3 m = mix(left, front, dot(s.norm, vec3(0., 1., 0.)));\n    m = mix(m, top, dot(s.norm, vec3(0., 0., 1.)));\n    return pow(m, vec3(2.2));\n}\n\nvec3 getColor(Sample s)\n{\n    switch (s.mat){\n    case 0:\n        return vec3(1.);\n    case 1:\n        return vec3(.1, .3, 0.)*smoothstep(0., 1., texture(iChannel0, s.wp.xy*.3).r);\n    case 2:\n        return vec3(0., 1., 0.);\n    case 3:\n        return concrete(s);\n    case 4:\n        return wood(s);\n    case 5:\n        return clay(s);vec3(.4, .3, .9);\n    case 6:\n        return vec3(.1, .3, .0);\n    case 7:\n        return vec3(mix(vec3(.05, .1, 1.), vec3(.7, .7, 1.), smoothstep(.4, .55, sin(s.wp.z*8.-s.wp.x-5.2)*.5+.5)));\n    }\n    return vec3(1., 0., 1.);\n}\n\nSample march(vec3 ro, vec3 rd, int ms, float md)\n{\n    Sample o;\n    Map m;\n    o.dist = 0.;\n    o.mat = 0;\n    float d = 0.;\n    for (int i=0; i<ms; i++){\n        m = map(ro + o.dist*rd);\n        o.dist += m.d;\n        if (m.d < sdist || m.d > md){\n            o.wp = ro + o.dist*rd;\n            o.mat = m.m;\n            o.norm = getNormal(o.wp);\n            o.ao = getAO(o);\n            o.col = getColor(o);\n            return o;\n        }\n    }\n    o.wp = ro + o.dist*rd;\n    o.norm = getNormal(o.wp);\n    o.ao = getAO(o);\n    o.col = getColor(o);\n    return o;\n}\n\nSample clight(Sample s, Light l)\n{\n    vec3 rd = normalize(l.p-s.wp);\n    float n = dot(rd, s.norm);\n    float dist = clamp(distance(l.p, s.wp), 0., l.d);\n    float d = clamp(min(n, march(s.wp+(sdist+.02)*rd, rd, shadowsteps, maxlightdist).dist/dist), 0.05, 1.);\n    s.shadow += d*l.c;\n    return s;\n}\n\nSample calcLight(Sample s)\n{\n    Light l1 = Light(\n        vec3(2., 0., 4.),\n        vec3(1.),\n        80.\n    );\n    Light l2 = Light(\n        vec3(-5., -3., 3.),\n        vec3(.7, .4, .3),\n        80.\n    );\n    s = clight(s, l1);\n    s = clight(s, l2);\n    return s;\n}\n\nvec3 composite(Sample s)\n{\n    s = calcLight(s);\n    vec3 col = mix(s.col * s.ao * s.shadow, sky, step(100., s.dist));\n    float fog = clamp(s.dist*.01-.1, 0., 1.)*smoothstep(0.2, .8, clamp(4.8-s.wp.z*.2, 0., 1.));\n  //  return vec3(fog);\n    return mix(col, ambi, fog);\n}\n\n/* stolen from https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/ */\n/* thanks, demofox */\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    float d = iResolution.x/iResolution.y;\n    uv.x *= d;\n    \n    float f = -2.4;\n    \n    vec3 cr = vec3(0.3+cos(iTime*3.21)*.001-sin(iTime)*.2, 0.05+sin(iTime*3.6)*.001, .0+sin(iTime*2.6)*.002);\n    vec3 cp = vec3(sin(iTime)-2.7, -8.0, 2.);\n    vec3 rd = rotate(vec3(uv.x, f, uv.y), cr);\n    \n    Sample s = march(cp, rd, basesteps, culldist);\n    vec3 col = composite(s);\n    \n#ifdef AA\n    /* sample neighbor pixels (2x2 only) */\n    /*  xx  */\n    /*  x   */\n    vec2 diff = ((fragCoord+vec2(1.))-fragCoord)/2./iResolution.xy;\n    rd = rotate(vec3(uv.x, f, uv.y+diff.y), cr);\n    s = march(cp, rd, basesteps, culldist);\n    col += composite(s);\n    rd = rotate(vec3(uv.x+diff.x, f, uv.y), cr);\n    s = march(cp, rd, basesteps, culldist);\n    col += composite(s);\n    col /= 3.;\n#endif\n\n    col = pow(ACESFilm(col*.6), vec3(1./2.2));\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3RN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[560, 560, 610, 610, 688], [690, 690, 738, 738, 921], [923, 923, 971, 971, 1065], [1067, 1067, 1107, 1107, 1195], [1197, 1197, 1226, 1226, 1684], [1686, 1686, 1713, 1713, 1793], [1795, 1795, 1825, 1825, 1906], [1908, 1908, 1939, 1939, 2019], [2021, 2021, 2038, 2038, 3424], [3426, 3442, 3466, 3466, 3739], [3741, 3741, 3764, 3764, 3850], [3852, 3852, 3873, 3873, 4240], [4242, 4242, 4263, 4263, 4598], [4600, 4600, 4625, 4625, 5026], [5028, 5028, 5053, 5053, 5593], [5595, 5595, 5645, 5645, 6161], [6163, 6163, 6197, 6197, 6464], [6466, 6466, 6494, 6494, 6736], [6738, 6738, 6764, 6764, 7010], [7012, 7128, 7151, 7151, 7306], [7308, 7308, 7365, 7365, 8292]]}
{"id": "ftl3R4", "name": "Rising Sword (2nd Reality)", "author": "xjorma", "description": "Remake of another \"Second Reality\" effect from \"Future Crew\".\nInitially I remade this effect for my latest demo (So why not releasing it on ShaderToy too)\nhttps://youtu.be/p8BjSBb0mj4\nUse the mouse the move around.\n", "tags": ["demoscene", "demo", "demoeffect", "sword", "first", "second", "reality", "secondreality", "future", "reproduction", "rising", "crew"], "likes": 5, "viewed": 621, "published": 3, "date": "1621702201", "time_retrieved": "2024-07-30T19:19:23.371786", "image_code": "// Rising Sword by David \"Xjorma\" Gallardo 2021\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define GAMMA 0\n\n#define MAXDIST 100.0\n\nfloat sphIntersect(in vec3 ro, in vec3 rd, in vec3 ce, float ra)\n{\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b * b - c;\n    if (h < 0.0) return MAXDIST; // no intersection\n    h = sqrt(h);\n    float t = -b - h;\n    if(t > 0.0)\n        return -b - h;\n    else\n        return MAXDIST;\n}\n\nfloat floorIntersect(in vec3 ro, in vec3 rd)\n{\n    if (rd.y < -0.01)\n    {\n        return ro.y / -rd.y;\n    }\n    return MAXDIST;\n}\n\nvec2 pR(in vec2 p, float a)\n{\n    return cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nvec3 GetPixel(in vec2 uv, out float alpha)\n{\n    vec4 col = texelFetch(iChannel0, ivec2(uv), 0);\n    alpha = col.a;\n    return col.rgb;\n}\n\nfloat SwordIntersect(in vec3 ro, in vec3 rd, float iTime, out vec3 color)\n{\n    float t = ro.z / -rd.z;\n    vec3 pos = ro + t * rd;\n    vec2 uv = pos.xy;\n    uv = pR(uv, radians(- 70.0)) * 0.25;\n    uv.y *= 8.0;\n    uv += vec2(0.5, 0.5);\n    uv.x += mod(iTime, 40.f) / 25.0 - 0.47;\n    float alpha;\n    color = GetPixel(uv*vec2(400,35), alpha);\n    if (t > 0.0 && alpha > 0.5)\n        return t;\n    else \n        return MAXDIST;\n}\n\n\nvec2 minVec(vec2 v0, vec2 v1)\n{\n    if (v0.x < v1.x)\n    {\n        return v0;\n    }\n    else\n    {\n        return v1;\n    }\n}\n\n// Contributed by @Cubeleo\nvec4 getSkyColor(vec3 ro, vec3 rd)\n{\n    vec3 blue = smoothstep(.2, 1., rd.y) * vec3(0, 0, .5);\n    float nDotL = clamp(dot(rd, normalize(vec3(-1, 1, 0))), 0., 1.);\n    vec3 highlight = vec3(pow(nDotL, 100.) * 2.0);\n    return vec4(blue + highlight, 1);\n}\n\n\n#define GEN_RENDER(NAME,RECUR) \t\\\nvec4 NAME(in vec3 ro, in vec3 rd) \\\n{ \\\n    const vec3 sphCenter0 = vec3(0.5, 0.20, 0.5); \\\n    const vec3 sphCenter1 = vec3(0.5, 0.20, -0.5); \\\n    vec2 sph0 = vec2(sphIntersect(ro, rd, sphCenter0, 0.45), 0); \\\n    vec2 sph1 = vec2(sphIntersect(ro, rd, sphCenter1, 0.45), 1); \\\n    vec2 plane = vec2(floorIntersect(ro, rd), 2); \\\n    vec3 swordCol; \\\n    vec2 swordInter = vec2(SwordIntersect(ro, rd, iTime, swordCol), 3); \\\n    vec2 t = minVec(minVec(minVec(sph0, sph1), plane), swordInter); \\\n    vec3 position = ro + t.x * rd; \\\n    if (t.x < MAXDIST && position.y > -0.01 && max(abs(position.x), abs(position.z)) < 2.7) \\\n    { \\\n        vec3 normal; \\\n        if (t.y > 2.5) \\\n        { \\\n            return vec4(swordCol, 1); \\\n        } \\\n        if (t.y < 0.5) \\\n        { \\\n            normal = normalize(position - sphCenter0); \\\n        } \\\n        else if (t.y < 1.5) \\\n        { \\\n            normal = normalize(position - sphCenter1); \\\n        } \\\n        else \\\n        { \\\n            float d = length(position.xz); \\\n            vec2 dir = position.xz / d; \\\n            float s = sin(d * 15.0 - iTime * 2.0); \\\n            normal = normalize(vec3(s * dir.x, 15.0, s * dir.y)); \\\n        } \\\n        vec3 nrd = reflect(rd, normal); \\\n        vec4 color = RECUR(position, nrd); \\\n        return vec4(color.xyz, 1); \\\n    } \\\n    else \\\n    { \\\n        return getSkyColor(ro, rd); \\\n    } \\\n} \n\nGEN_RENDER(render3, getSkyColor)\nGEN_RENDER(render2, render3)\nGEN_RENDER(render1, render2)\nGEN_RENDER(render , render1)\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 desaturate(in vec3 c, in float a)\n{\n    float l = dot(c, vec3(1. / 3.));\n    return mix(c, vec3(l), a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);   \n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        \n        float theta\t= radians(-45.0) + radians(360.0) * (iMouse.x/iResolution.x-0.5);\n        float phi\t= radians(45.0) + radians(45.0) * (iMouse.y/iResolution.y-0.5);\n        vec3 ro = 1.5 * vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n        \n        vec3 col = render(ro, rd).xyz;\n      \ttot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n    \n    tot = desaturate(tot, -0.4);\n    tot = vignette(tot, fragCoord / iResolution.xy, 1.2);\n    #if GAMMA\n    \ttot = pow(tot, vec3(1. / 2.2));\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27194, "src": "https://soundcloud.com/hexen-1/second-reality-future-crew", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "const vec2 size = vec2(400, 35);\n\nconst uint palette[256] = uint[](\n        0U, 6513599U, 4934559U, 7566287U, 2302859U, 2829195U, 10461135U, 3355543U,\n        2302843U, 3881867U, 12040175U, 9934791U, 7566279U, 1250179U, 4408215U, 11513831U,\n        12040167U, 9145279U, 8092583U, 7566239U, 11513823U, 1776515U, 3355523U, 6513591U,\n        3355531U, 6513615U, 7039895U, 4934515U, 5460927U, 6513559U, 10987487U, 6513547U,\n        8092599U, 4934551U, 10987479U, 2302851U, 1250171U, 13092855U, 4408171U, 14145535U,\n        11513847U, 2302871U, 5987203U, 9934815U, 151U, 1776507U, 8092615U, 2302835U,\n        9145303U, 4408203U, 5460867U, 5460859U, 5460903U, 10461159U, 3881827U, 723835U,\n        3355551U, 10987503U, 8618959U, 9934799U, 7039927U, 6513583U, 1250163U, 12566519U,\n        7566271U, 1776499U, 12040183U, 11513839U, 10461151U, 7566255U, 3355483U, 9145295U,\n        3355515U, 5460895U, 2829179U, 5460887U, 9934807U, 723811U, 13619199U, 723827U,\n        3881859U, 4408179U, 1776491U, 6513567U, 2302771U, 1250155U, 2302795U, 5460875U,\n        10987495U, 4934531U, 8618951U, 4408195U, 9145287U, 7566263U, 8092607U, 2302827U,\n        3355507U, 9934823U, 8618943U, 6513575U, 13092863U, 7039919U, 2829171U, 4934523U,\n        5987231U, 2302803U, 3355491U, 2302819U, 3881851U, 1776483U, 10987511U, 723819U,\n        1250147U, 12566527U, 4408187U, 10461143U, 3355499U, 5987223U, 2302811U, 4934539U,\n        8092631U, 2829163U, 1776475U, 4934575U, 7039911U, 12040191U, 139U, 3881843U,\n        9145319U, 1776435U, 8618935U, 1776467U, 1251119U, 2829155U, 11513855U, 5987211U,\n        1250139U, 3881835U, 1776451U, 7039951U, 723803U, 2829147U, 4408231U, 10461167U,\n        131U, 1776523U, 1776443U, 1250131U, 1776459U, 3881887U, 2829139U, 99U,\n        123U, 8618975U, 83U, 723795U, 51U, 115U, 75U, 2829131U,\n        5987255U, 723787U, 67U, 43U, 107U, 1250123U, 1250075U, 723723U,\n        19U, 35U, 2829207U, 723779U, 723739U, 1250091U, 723755U, 91U,\n        11U, 723771U, 1250115U, 723731U, 1250083U, 0U, 59U, 1250107U,\n        723763U, 27U, 1250099U, 723747U, 1250199U, 723843U, 159U, 14671871U,\n        16777131U, 16513939U, 16511867U, 16509799U, 16245587U, 16242491U, 15713071U, 15184675U,\n        14656279U, 14127887U, 13598471U, 12807943U, 11755271U, 10964736U, 10175232U, 9385728U,\n        8596224U, 7807744U, 7018240U, 6229760U, 5442304U, 4654848U, 3866624U, 3080192U,\n        4132623U, 4662051U, 5190451U, 5456707U, 5984079U, 6774627U, 7301999U, 8091519U,\n        8617871U, 9146271U, 9674671U, 10464183U, 11253699U, 12044239U, 12571611U, 13361127U,\n        12582847U, 10742691U, 9427855U, 7850871U, 6535011U, 5482323U, 4429635U, 3376947U,\n        2585383U, 1794843U, 1266451U, 5709568U, 7025431U, 7551775U, 8341287U, 8868655U,\n        9396027U, 10185539U, 10711887U, 11240283U, 12029799U, 12557171U, 13084547U, 13875091U\n);\n\nconst uint image[3500] = uint[](\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 240U, 4025548800U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 61163U, 3958370560U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 15723241U, 3975016177U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 14352384U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 4025215209U, 3958172653U, 4043309056U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 14352384U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 14145280U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 4060086272U, 4076863488U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 239U, 3957909737U, 3975015661U, 4025548800U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 14079959U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 15921907U, 4076863488U, 0U,\n        0U, 0U, 0U, 0U, 62208U, 0U, 0U, 0U, 0U, 61418U, 3907578090U, 3958304751U, 4008702208U, 0U, 0U, 0U,\n        0U, 0U, 0U, 219U, 223U, 0U, 0U, 0U, 219U, 0U, 55552U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 55040U, 0U, 0U, 0U, 215U, 3621246720U, 14090455U, 3590379008U, 3607101440U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 62195U, 4092788736U, 0U, 0U, 0U, 0U, 0U, 15987456U, 0U, 0U, 0U, 0U, 61420U, 3941264364U, 3991924977U,\n        4059165184U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 3688562688U, 0U, 14352384U, 3674210304U, 14352384U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 55255U, 3607101440U, 0U, 0U, 3607156480U, 55040U,\n        3621191680U, 3590324438U, 14090240U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 16053235U, 15987456U, 0U, 0U, 0U, 0U, 0U, 4092788736U, 0U, 0U, 0U,\n        0U, 239U, 3958107373U, 3975016433U, 4059168768U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 14671616U, 0U, 0U,\n        14352384U, 0U, 14352384U, 217U, 0U, 3640655872U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 14145280U, 0U, 0U, 0U, 14079959U, 3590379479U, 3621246934U, 3621246934U,\n        0U, 0U, 14145238U, 3604349143U, 3621246679U, 214U, 3587626967U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 4109697024U, 4110417920U, 0U, 0U, 0U, 0U, 62451U,\n        4109693939U, 4076863488U, 243U, 15925248U, 0U, 0U, 4025282030U, 3991727599U, 4060086515U, 4126405619U, 242U, 0U, 0U, 0U, 56064U, 56064U,\n        0U, 3638231040U, 0U, 0U, 15064320U, 0U, 0U, 0U, 0U, 0U, 55769U, 0U, 55552U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 14145495U, 0U, 0U, 0U,\n        14145495U, 3604348928U, 55255U, 3604403927U, 3590324224U, 14079959U, 3604403925U, 3587560917U, 3587560917U, 3587561173U, 55255U, 3621191680U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 15987699U, 62451U, 0U, 0U, 0U, 0U, 0U, 4109697024U, 243U, 0U,\n        0U, 0U, 0U, 4092982515U, 243U, 4076863488U, 243U, 4092788736U, 0U, 0U, 15000803U, 3856851425U, 62453U, 4076863731U, 4076925682U, 0U,\n        0U, 3640656089U, 3671710940U, 0U, 14155776U, 56064U, 15007744U, 56797U, 0U, 0U, 0U, 221U, 0U, 55769U, 55552U, 0U,\n        55552U, 0U, 0U, 3623878656U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        14145280U, 14145495U, 0U, 215U, 3621246679U, 14145494U, 3607156695U, 3621246934U, 3621246678U, 3590379222U, 3587560403U, 3520188880U, 3553743825U, 3553874901U, 3604337920U, 3621181399U,\n        3607101440U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 243U, 4092851444U, 4076863488U, 0U, 0U, 0U,\n        4092917239U, 4110417920U, 4076925939U, 4109693952U, 0U, 0U, 243U, 4126470912U, 0U, 4092851188U, 4109628160U, 15925248U, 0U, 0U, 15000546U, 3856851424U,\n        15987955U, 4075945984U, 4092850944U, 0U, 0U, 0U, 3657433305U, 220U, 3755794140U, 3690987520U, 229U, 15007744U, 3741319168U, 56576U, 219U, 0U,\n        3688693979U, 220U, 55552U, 0U, 0U, 3654877401U, 0U, 14155776U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 14090240U, 3621246935U, 3638024151U, 3621246935U, 3604338389U, 3587560917U, 3587626454U, 3604207318U, 14145494U, 3604338387U, 3536965838U, 3436236494U,\n        3452882896U, 3503345872U, 3553875413U, 3587692246U, 3587637248U, 3607101440U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 15987699U, 4076863731U,\n        4109565952U, 0U, 0U, 15988215U, 4160157685U, 4159897600U, 16054007U, 4193909236U, 1409286144U, 0U, 62453U, 4109628403U, 4076863731U, 4126668791U, 4160223221U, 4092919808U,\n        0U, 0U, 14869219U, 3856851424U, 4092982016U, 15859712U, 0U, 0U, 0U, 218U, 3657433088U, 3674210304U, 0U, 58339U, 3724600064U, 229U,\n        3755859935U, 58624U, 0U, 3707764736U, 14408960U, 56064U, 56320U, 14276864U, 3674265344U, 217U, 0U, 0U, 0U, 55296U, 0U, 216U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 55255U, 3607101440U, 55255U, 3621246935U, 3621246933U, 3587494867U, 3553874899U, 3553875157U, 3520266454U,\n        3554072017U, 3587297997U, 3519794379U, 3435908043U, 3436039883U, 3452685516U, 3469791955U, 3587561431U, 3621246935U, 3607101440U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 15987456U, 0U, 4092916480U, 0U, 243U, 4126668790U, 4093048307U, 4159897600U, 4092917750U, 4109694969U, 4093640704U, 0U, 4092983028U, 4092788736U,\n        62453U, 4160091124U, 4109628919U, 4126474240U, 0U, 0U, 14935013U, 3890537185U, 4126536448U, 0U, 0U, 0U, 0U, 0U, 55808U, 0U,\n        3623935744U, 3638484480U, 14607843U, 3856786176U, 59136U, 223U, 0U, 56576U, 0U, 221U, 14221532U, 55552U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 55040U, 14145495U, 3604403669U, 3587560917U, 3587560660U, 3553875411U,\n        3536966095U, 3486503120U, 3503411666U, 3553744081U, 3570717138U, 3503345104U, 3452816845U, 3385444809U, 3402222536U, 3385445578U, 3419131344U, 3537098197U, 3587571927U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 243U, 4092788736U, 0U, 15987959U, 0U, 62454U, 4160156416U, 4093113088U, 4159897600U, 4109891060U, 62711U,\n        4176999424U, 62453U, 4160090880U, 0U, 15988215U, 4126343168U, 0U, 4126668032U, 0U, 0U, 14935526U, 3890602977U, 4143248128U, 4092983028U, 4076925941U, 4143248128U,\n        4092983028U, 4076925941U, 4143248128U, 4092983028U, 4091150336U, 57061U, 3789881569U, 3823165923U, 3856522717U, 14673664U, 15198175U, 3741319168U, 57088U, 0U, 0U, 14408448U,\n        0U, 0U, 3654877184U, 3640655872U, 14155776U, 216U, 3623878656U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 14145280U, 3621181184U,\n        3587560403U, 3553612496U, 3503477458U, 3520319952U, 3503280080U, 3469594319U, 3469725647U, 3503345873U, 3520122321U, 3452881868U, 3402221769U, 3368469955U, 3284386758U, 3334719174U, 3334916297U, 3368667850U,\n        3402353869U, 3435907787U, 3402353869U, 3469660371U, 3573602003U, 3520057553U, 3536966355U, 3570783959U, 3607101655U, 3604338134U, 3621312471U, 3604404698U, 3688619229U, 3739082461U, 3722370781U, 3756056541U,\n        4158447328U, 4158579427U, 3823033562U, 56545U, 3757504228U, 3839817717U, 4125156577U, 3738828800U, 56801U, 3857048805U, 3839876063U, 3790992866U, 3789479132U, 3722239454U, 3789940709U, 3890603236U,\n        4092917239U, 4193974775U, 4109629433U, 4176934387U, 4160354806U, 4109629433U, 4176934387U, 4177262811U, 3705659870U, 3657490917U, 3789750493U, 3722698981U, 3856787200U, 3890735069U, 15139039U, 3741377764U,\n        3806265344U, 14409472U, 3806461952U, 220U, 56064U, 3755728349U, 219U, 3674210304U, 0U, 55512U, 0U, 0U, 3623878656U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        55255U, 3607101440U, 3621246934U, 3604338133U, 3570586578U, 3520254417U, 3520057551U, 3503345360U, 3469659597U, 3452883150U, 3452816846U, 3452882382U, 3452882381U, 3435973578U, 3368601542U, 3301032899U,\n        3284386497U, 3267675590U, 3351889864U, 3385510859U, 3436039887U, 3503279820U, 3452948174U, 3452817103U, 3520319951U, 3486503378U, 3520122832U, 3520189140U, 3604469718U, 3554072535U, 3621246678U, 3654933210U,\n        3688685022U, 3739148255U, 3772900065U, 3806197495U, 4175356129U, 4176994017U, 3806453983U, 3671842787U, 3789551352U, 4143445472U, 3857049317U, 3873628123U, 3688751332U, 3873826276U, 3856981987U, 3824547296U,\n        3806453725U, 3722436577U, 3857114854U, 3890537699U, 3757437942U, 4210817268U, 4093049595U, 4176802806U, 4210817268U, 4093049595U, 4176802808U, 4244298716U, 3773096932U, 3823492826U, 3856720101U, 3823362273U,\n        3856915939U, 3890208743U, 14942208U, 15000576U, 3755991775U, 3791651042U, 57311U, 56576U, 57088U, 14811136U, 0U, 3640711641U, 3654877184U, 14614528U, 0U, 3623878656U,\n        0U, 3623934208U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 215U, 3621246677U, 3587494867U, 3536900559U, 3486502863U, 3486502862U, 3469725648U, 3503149264U, 3452882129U, 3436104654U, 3435974348U,\n        3419196363U, 3402287303U, 3351693763U, 3284189634U, 3250700739U, 3318204362U, 3385510603U, 3402419662U, 3486503121U, 3537032146U, 3536965839U, 3486436813U, 3452817102U, 3486568914U, 3537097939U, 3553808849U,\n        3553875155U, 3604469463U, 3621181142U, 3654998747U, 3705527773U, 3739082975U, 3789742562U, 3789676278U, 3739345631U, 3774412766U, 3789743074U, 3756122596U, 3840270328U, 4192264934U, 3873892070U, 3840337122U,\n        3806651366U, 3823429093U, 3840140259U, 3806328821U, 3789611231U, 3755991527U, 3857114855U, 3890537442U, 3789551097U, 4261148403U, 4126801403U, 4143183353U, 4261148403U, 4126801403U, 4143183610U, 4227324638U,\n        3806651619U, 3840140261U, 3789612515U, 3856915941U, 3772901345U, 3789415907U, 3890732509U, 3755991778U, 3741319387U, 3774930944U, 3789283810U, 14811136U, 14278619U, 14408671U, 3657490176U, 3755727616U,\n        14211840U, 3688487387U, 3674210304U, 0U, 3688366080U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 3621246720U, 0U, 3621191680U, 3587560916U, 3537032145U, 3520057296U, 3503280079U, 3486634449U, 3469660369U,\n        3469726157U, 3436170445U, 3435973835U, 3419130571U, 3402287818U, 3385444550U, 3385181123U, 3250700484U, 3317941703U, 3385182666U, 3334981833U, 3385445068U, 3469726162U, 3554006741U, 3553808849U, 3503345614U,\n        3469660112U, 3520254931U, 3570783701U, 3587494610U, 3537031890U, 3554006742U, 3621246678U, 3638090202U, 3688685021U, 3722371039U, 3772899810U, 3806585079U, 3757043680U, 3823433975U, 3773031909U, 3857048805U,\n        3857049337U, 4210548966U, 4024887270U, 3890603235U, 3789874662U, 3890735078U, 4025477094U, 3873895925U, 3823560166U, 3857114855U, 3890735079U, 3907117022U, 3739154171U, 4294571507U, 4143710201U, 4126406395U,\n        4294571507U, 4143710201U, 4126406908U, 4193639389U, 3806651364U, 3823428580U, 3773031392U, 3672368605U, 3739608039U, 3823362532U, 3875594203U, 3688750043U, 3688618971U, 14811360U, 3758096384U, 14868992U,\n        226U, 14408667U, 14539520U, 3674210527U, 14352603U, 14352601U, 3688693979U, 14408448U, 216U, 3638034432U, 55552U, 14277376U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 55255U, 0U, 54784U, 14145494U, 3604338133U, 3553874899U, 3553742799U,\n        3503411411U, 3520189138U, 3536966610U, 3536965840U, 3503345358U, 3469660368U, 3519925964U, 3419131594U, 3385444811U, 3368602055U, 3335112132U, 3301229511U, 3368405703U, 3351760333U, 3419065291U, 3436039630U,\n        3486568657U, 3537163734U, 3621246677U, 3570651858U, 3553940950U, 3621246935U, 3604403925U, 3553809365U, 3604337875U, 3536965841U, 3554006485U, 3654866905U, 3671841756U, 3705462237U, 3739148255U, 3755997174U,\n        4025474527U, 3772834040U, 4158578912U, 3773820919U, 3756056569U, 4177130975U, 4024426463U, 3739214306U, 3789677281U, 3806454498U, 3823300591U, 4193908215U, 3773096932U, 3840140002U, 3840271845U, 3789545182U,\n        3722245883U, 4277859827U, 4143709946U, 4126406395U, 4277859827U, 4143709946U, 4126406908U, 4193704670U, 3772899809U, 3856720353U, 3823363039U, 3722699741U, 3823494628U, 3840139751U, 3823101925U, 3873892066U,\n        14671839U, 3890405345U, 14737634U, 3806003200U, 14614528U, 3806519259U, 3739081690U, 3674210521U, 3741319168U, 3688880603U, 3688618457U, 3638089728U, 55296U, 14352600U, 3674210304U, 3674210304U,\n        55552U, 14276864U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 3621191680U, 3621246935U, 3621246422U,\n        3604338389U, 3587495636U, 3570586065U, 3520385234U, 3520254674U, 3570718165U, 3587559889U, 3553743313U, 3520123344U, 3503279823U, 3469659597U, 3452751051U, 3419065034U, 3402156233U, 3351889605U, 3385181894U,\n        3318073029U, 3351955402U, 3435842253U, 3436039887U, 3503411923U, 3553875157U, 3587626452U, 3553808851U, 3570783701U, 3587561174U, 3587494866U, 3570783958U, 3587560917U, 3553809107U, 3587627224U, 3654811863U,\n        3654998746U, 3671841755U, 3688618972U, 3705534454U, 4141801439U, 3772837855U, 4160217314U, 3789414127U, 3756122104U, 3774281717U, 4024360412U, 3705462238U, 3739213791U, 3756057057U, 3789741793U, 3824810487U,\n        4125352930U, 3806453985U, 3823494372U, 3755859676U, 3707172345U, 4244371188U, 4126801147U, 4143183353U, 4244371187U, 4126801147U, 4143183610U, 4227324893U, 3739148255U, 3722831326U, 3739081946U, 15064803U,\n        3822839267U, 3722699747U, 3722634978U, 3890077151U, 3791651035U, 3688882139U, 3674268386U, 14737375U, 14867200U, 3806519263U, 14811355U, 3755727837U, 3688618971U, 14278400U, 3655064537U, 3674210525U,\n        3638091227U, 3674266368U, 14221529U, 217U, 55552U, 55769U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        3621191680U, 55255U, 14145280U, 3607101440U, 54741U, 3587691988U, 3604272340U, 3553874899U, 3587560917U, 3621181142U, 3604403669U, 3587560915U, 3553808849U, 3503346127U, 3486437070U, 3503148492U,\n        3419130313U, 3418999497U, 3368536263U, 3318007236U, 3335179210U, 3402222283U, 3435973579U, 3452816846U, 3486568913U, 3537163733U, 3570717650U, 3520320725U, 3604403925U, 3587494867U, 3537097941U, 3587626967U,\n        3604403926U, 3587495381U, 3604601305U, 3654746112U, 3621378779U, 3688619228U, 3705461981U, 3722246110U, 3722238684U, 3739348975U, 3740786401U, 3722042590U, 4160223479U, 3772839671U, 4125023965U, 3705264604U,\n        3739147999U, 3772834017U, 3755923934U, 3789808373U, 4158710498U, 3772833759U, 3806586340U, 3772701916U, 4109759478U, 4210817269U, 4093049595U, 4176868342U, 4210817269U, 4093049595U, 4176868344U, 4244240091U,\n        3722436574U, 3739081947U, 3672441059U, 3823494629U, 3856522725U, 3823364069U, 3806191069U, 3806324480U, 3806322432U, 3755989979U, 3688618752U, 14410459U, 3674267615U, 3741375451U, 3674266587U, 56064U,\n        3707764955U, 3654932953U, 3655064025U, 55296U, 0U, 14211840U, 219U, 14276864U, 217U, 14277083U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 14090455U, 3621191680U, 215U, 3621191895U, 3621191680U, 3573601749U, 3587561174U, 3604338390U, 3604348928U, 14079703U, 14145495U, 0U,\n        3587560404U, 3553940435U, 3537097169U, 3486502606U, 3469528267U, 3419130569U, 3418933448U, 3368535492U, 3301493194U, 3419196621U, 3436039884U, 3436039885U, 3520057553U, 3553874900U, 3587429073U, 3537031890U,\n        3553940947U, 3553874642U, 3570783959U, 3607101440U, 14145237U, 3570651858U, 3587626712U, 3607101440U, 55257U, 3705462237U, 3722305246U, 3723950043U, 3654735832U, 3688685537U, 3791124445U, 3640711644U,\n        3740792799U, 3705659638U, 4160085726U, 3640656089U, 3705593566U, 3739213789U, 3705209049U, 3722568181U, 4160217570U, 3789676768U, 3789677796U, 3755859420U, 4092917239U, 4177132279U, 4143183865U, 4210554611U,\n        4160355063U, 4143183865U, 4210554611U, 4160485878U, 3688750556U, 3688552448U, 227U, 15066079U, 3823363043U, 3688882141U, 3722306271U, 3755727836U, 3791708672U, 223U, 3756186368U, 3688562688U,\n        14868224U, 3756188383U, 3654934489U, 14352603U, 3654932696U, 14483456U, 14352384U, 14155776U, 3674210304U, 3674210304U, 3640655872U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 215U, 14145494U, 3604403712U, 3607156695U,\n        3621246720U, 3604414678U, 3590324224U, 3604403968U, 14079702U, 3587560448U, 3587428561U, 3536900303U, 3436105165U, 3435842251U, 3385510345U, 3385444552U, 3368798408U, 3402353869U, 3452882895U, 3486568659U,\n        3503608787U, 3537557760U, 14155992U, 3638034432U, 3621191895U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 15988211U, 243U, 4126536448U,\n        62194U, 4093048820U, 4092983284U, 0U, 4109890816U, 243U, 4143445491U, 0U, 4092917748U, 0U, 0U, 244U, 4160090880U, 15988211U, 14737892U, 3772701402U,\n        4143248128U, 4092983028U, 4076925941U, 4143248128U, 4092983028U, 4076925941U, 4143248128U, 4092983028U, 4091150556U, 0U, 3724599013U, 3856524259U, 3755993059U, 3755991005U, 3741375744U, 3755802624U,\n        3674210527U, 14352384U, 14680064U, 57311U, 3741319168U, 3805927936U, 56064U, 219U, 3674210304U, 0U, 14211072U, 0U, 0U, 14155776U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 14090240U,\n        3607101655U, 3621246935U, 55255U, 215U, 0U, 0U, 0U, 54999U, 3604414464U, 3621246933U, 3554006227U, 3553677777U, 3503279310U, 3402418890U, 3368602315U, 3368668107U,\n        3385576138U, 3419196877U, 3469660112U, 3520188882U, 3537032665U, 3654867160U, 3638024151U, 3621246935U, 14145495U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 62453U, 4092851188U, 4126343168U, 15921907U, 4143248128U, 15988471U, 4093640948U, 4160156416U, 0U, 4093048564U, 4076863731U, 4109890803U, 0U, 0U, 243U,\n        4126667763U, 4109759232U, 14672095U, 3805993690U, 0U, 0U, 0U, 0U, 218U, 3671775744U, 0U, 0U, 220U, 3724598272U, 3724542179U, 0U,\n        14671845U, 3755737309U, 55552U, 56797U, 56284U, 3674210304U, 0U, 0U, 3671719936U, 3657433088U, 0U, 55296U, 55296U, 14155776U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 3607101440U, 0U, 0U, 0U, 0U, 14145280U, 14090455U, 3621181139U, 3587429331U,\n        3553742799U, 3469659596U, 3435908042U, 3402287562U, 3385445326U, 3469594318U, 3486568657U, 3553940692U, 3587823872U, 3638089687U, 3621246935U, 3607101440U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 243U, 4109694196U, 4076863488U, 62452U, 4109565952U, 62454U, 4160223223U, 4126343168U, 0U, 15987957U, 4109628662U,\n        4143248371U, 4076863488U, 0U, 0U, 4092917237U, 4126405376U, 14606049U, 3822902491U, 0U, 0U, 0U, 0U, 0U, 14286848U, 14342656U, 3691044572U,\n        220U, 219U, 3724599014U, 230U, 3755933696U, 3741375744U, 56064U, 219U, 3674210304U, 0U, 3738884608U, 14221530U, 0U, 0U, 14286848U, 216U,\n        0U, 0U, 0U, 55296U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 55255U, 0U, 0U, 0U, 0U, 0U,\n        14145280U, 14145280U, 3621246720U, 3604337620U, 3553743313U, 3436105421U, 3452816588U, 3419196620U, 3436105165U, 3469726161U, 3520254931U, 3570718421U, 3637958616U, 3638024151U, 55040U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 243U, 4092850931U, 4076863488U, 0U, 4092916979U,\n        0U, 15987699U, 15987699U, 4109759989U, 4092788979U, 4076007936U, 0U, 0U, 4092851187U, 4092788736U, 14671583U, 3805993946U, 0U, 0U, 0U, 0U,\n        0U, 0U, 55808U, 0U, 0U, 3640655872U, 3690987520U, 14548992U, 56537U, 56832U, 219U, 0U, 55808U, 3739090944U, 14211288U, 3640656090U,\n        0U, 0U, 0U, 3623878656U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 55255U, 3621246720U, 14090240U, 3607156692U, 3587429329U, 3520123086U, 3503345868U, 3503279310U, 3469725904U, 3503477972U, 3587495126U, 3604404440U,\n        3623933911U, 3621191680U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 15987456U,\n        61952U, 0U, 0U, 0U, 0U, 243U, 4076863488U, 15987699U, 0U, 0U, 0U, 242U, 4060086272U, 0U, 4008241643U, 3975081195U,\n        3976200192U, 0U, 0U, 0U, 0U, 0U, 0U, 3674266588U, 56832U, 0U, 14473689U, 14417920U, 217U, 3691043072U, 14474240U, 0U,\n        3707764736U, 218U, 0U, 55808U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 14145280U, 0U, 3621246421U, 3553874899U, 3570652115U, 3553874897U,\n        3553875411U, 3587560917U, 3604403712U, 14145752U, 55040U, 3621191680U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 15859712U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 61952U,\n        0U, 238U, 3957975273U, 3958172653U, 4025483264U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 14417920U, 0U, 3705461760U,\n        3640655872U, 0U, 14278108U, 0U, 0U, 3638155776U, 0U, 14286848U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 55255U, 3607101655U,\n        55255U, 3587560917U, 3587560917U, 3587560917U, 3587560917U, 3604403927U, 3607156695U, 3607101440U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 61163U, 3941198312U, 3941330415U, 4025479424U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 14474240U, 56320U, 0U, 0U, 217U, 0U, 216U, 14286848U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 215U, 3607101655U, 3621246933U, 3621115863U, 3621246935U, 3621246935U, 0U, 215U, 3607101440U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 60650U, 3941263849U, 3907907567U, 4025544448U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 216U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 3621246935U, 3621191680U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 238U, 3958106858U, 3924816370U,\n        4075945984U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 4008439018U, 3941724145U, 4060086272U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 15657964U, 3941659122U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 61420U, 3958501888U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 239U, 3992059904U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U,\n        0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U\n);\n\nvec3 GetPixel(vec2 uv)\n{\n    uint id;\n    if(uv.x < 0.0 || uv.x >= size.x || uv.y < 0.0 || uv.y >= size.y )\n    {\n        id = 0U;\n    }\n    else\n    {\n        int off = int(uv.y) * (int(size.x) / 4) + int(uv.x) / 4;\n        id = (image[off] >> ( 3U - uint(uv.x) & 3U) * 8U) & 255U;\n    }\n    return vec3(float(palette[id] >> 16) / 255.0, float((palette[id] >> 8) & 255U) / 255.0, float(palette[id] & 255U ) / 255.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec3 col = GetPixel(fragCoord);\n        float alpha = dot(col, col) > 0.05 ? 1.0 : 0.0;\n        fragColor = vec4(GetPixel(fragCoord), alpha);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftl3R4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 202, 202, 479], [481, 481, 527, 527, 612], [614, 614, 643, 643, 695], [697, 697, 741, 741, 834], [836, 836, 911, 911, 1266], [1269, 1269, 1300, 1300, 1394], [1396, 1423, 1459, 1459, 1678], [3248, 3248, 3290, 3290, 3454], [3457, 3457, 3501, 3501, 3600], [3602, 3602, 3642, 3642, 3712]]}
{"id": "slsGRN", "name": "4D Rounded box (Bluey)", "author": "ollj", "description": "forked: \nRaymarched 3D hyperslice of a 4D roundedBox.\nhyperslice-vec4 in 4D space rotates by 2*quaternions, that are normalize(oscillating vec4())\n3d hyperslice (of 4d map() object) has 3d normals and a shadow in 3d space.\nNote this is NOT 4D raymarching\n", "tags": ["raymarching", "sdf", "4d", "box", "bluey"], "likes": 2, "viewed": 249, "published": 3, "date": "1621693976", "time_retrieved": "2024-07-30T19:19:24.504758", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// I raymarched a 3D slice of a 4D rounded box. The 3D slice (plane) that\n// cuts the 4D box is animated over time, and the cube itself is rotating\n// in 4D space. Note this is NOT 4D raymarching, it is 3D raymarching (of\n// a 3D slice of a 4D world).\n\n\n//colors\n#define blueBright (vec3(127,200,245)/255.)\n#define grey vec3(1.,.8,.6)\n\n#if HW_PERFORMANCE==0\n#define AA 0\n#else\n#define AA 0  // Set AA to 1 if your machine is too slow\n#endif\n\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n\nfloat sdBox(vec4 p,vec4 b){p=abs(p)-b//squared distance to roundedBox4d\n ;return min(max(max(p.x,p.y),max(p.z,p.w)),0.)+dd(max(p,0.));}\n\n//quaternion to 4d rotation (within 3d slice of a 4d point)\nmat4x4 q2m(vec4 q){return mat4x4(q.x,-q.y,-q.z,-q.w,q.y, q.x,-q.w, q.z\n                                ,q.z, q.w, q.x,-q.y,q.w,-q.z, q.y, q.x);}\n\n//return distance of p.xyz to a 4d roundedBox\n//a hyperslice is defined by a vec4, that is quaterion-rotated over time\nfloat map(vec3 pos, float time\n){vec4 p = vec4(pos,0.5*sin(time*0.513));//hyperslice-vector\n //rotate 3D point into 4D /todo, replace 4d rotation matrices by something more intuitive.\n ;vec4 a=normalize(cos(.2*time*vec4(1.0,1.7,1.1,1.5)+vec4(0.0,1.0,5.0,4.0)))//quaternion\n ;vec4 b=normalize(cos(.2*time*vec4(1.9,1.7,1.4,1.3)+vec4(3.0,2.0,6.0,5.0)))//quaternion\n ;p=q2m(b)*p*q2m(a)//2 rotation matrices\n ;return sqrt(sdBox(p,vec4(.8,.5,.7,.2)))-.16// 4D box\n ;}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 u,in float t\n){vec2 e=vec2(1.,-1.)*.5773;const float p=.00025\n ;return normalize(e.xyy*map(u+e.xyy*p,t)+e.yyx*map(u+e.yyx*p,t)\n\t\t\t\t  +e.yxy*map(u+e.yxy*p,t)+e.xxx*map(u+e.xxx*p,t));}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow(vec3 u,vec3 d,float a,float b,float t//rayOrigin,direction,min,max,time\n){float r=1.,m=a\n ;for(int i=0;i<32;i++ //good continuity of basic shapes needs only 32 shadow iterations\n ){float h=map(u+d*m,t);r=min(r,16.*h/m);m+=clamp(h,.01,.25);if(r<.001||m>b)break;}\n  return sat(r);}\n\nvec2 intersect( in vec3 ro, in vec3 rd, in float time\n){vec2 res = vec2(1e20,-1.0)\n ;{float t = (-1.0-ro.y)/rd.y;if( t>0.0 ) res = vec2(t,1.0);}    // plane\n ;{float tmax = min(6.0,res.x)\n  ;float t = 0.4\n  ;for( int i=0; i<128; i++ //marching loop for 4f\n  ){vec3 pos = ro + t*rd\n   ;float h = map(pos, time) //distancew field of 4d object\n   ;if( h<0.001 || t>tmax ) break\n   ;t += h\n   ;}\n  ;if( t<tmax && t<res.x ) res = vec2(t,2.0)\n  ;}    // plane\n  ;return res;}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy ){\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ ){\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float di = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+di)/float(AA*AA-1);\n        \n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // create view ray\n        vec3 ro = vec3(-0.5,0.0,2.5);\n        vec3 rd = normalize( vec3(p,-1.8) );\n         // ray differentials\n        vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n        vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n        vec3 rdx = normalize( vec3(px,-1.8) );\n        vec3 rdy = normalize( vec3(py,-1.8) );\n\n        // raymarch\n        vec2 tm = intersect( ro, rd, time );\n        vec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n        if( tm.y>0.0 ){\n            // shading/lighting\t\n            vec3 pos = ro + tm.x*rd;\n            vec3 nor = (tm.y<1.5)?vec3(0.0,1.0,0.0):calcNormal(pos,time);\n            vec3 color=blueBright;\n            vec3 lig = normalize(vec3(0.8,0.4,0.6));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            vec3  hal = normalize(lig-rd);\n            float sha = calcSoftshadow( pos+0.001*nor, lig, 0.001, 4.0, time );\n            float amb = 0.6 + 0.4*nor.y;\n            float bou = clamp(-nor.y,0.0,1.0);\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            col  = color*dif*sha*3.5;\n            col += vec3(0.12,0.18,0.24)*amb*4.;\n            col += vec3(0.30,0.20,0.10)*bou*2.;\n            \n            if( pos.y<-.99 ){\n                // project pixel footprint into the plane\n                vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n                vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n                float f = checkersGradBox( 2.0*pos.xz, 2.0*dpdx.xz, 2.0*dpdy.xz );\n                col *= 0.2 + f*vec3(0.05);\n            }\n            else                col *= 0.25;\n            \n            col += 0.2*pow(spe,8.0)*dif*sha;\n            \n            col = mix( col, vec3(0.6,0.7,0.8), 1.0-exp(-0.001*tm.x*tm.x) );           \n        }\n\n        // gamma        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    tot = pow( tot, vec3(0.45) );\n    \n    tot = clamp(tot,0.0,1.0);\n        \n    tot = tot*tot*(3.0-2.0*tot);\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "buffer_a_code": "// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n\n// Analytical computation of the exact bounding box for a cubic bezier segment\n// See https://iquilezles.org/articles/bezierbbox\n\n\n#define AA 0\n\nstruct bound3{vec3 mMin;vec3 mMax;};\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (https://iquilezles.org/articles/bezierbbox)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2 )\n{\n    // extremes\n    vec3 mi = min(p0,p2);\n    vec3 ma = max(p0,p2);\n\n    // p = (1-t)^2*p0 + 2(1-t)t*p1 + t^2*p2\n    // dp/dt = 2(t-1)*p0 + 2(1-2t)*p1 + 2t*p2 = t*(2*p0-4*p1+2*p2) + 2*(p1-p0)\n    // dp/dt = 0 -> t*(p0-2*p1+p2) = (p0-p1);\n\n    vec3 t = clamp((p0-p1)/(p0-2.0*p1+p2),0.0,1.0);\n    vec3 s = 1.0 - t;\n    vec3 q = s*s*p0 + 2.0*s*t*p1 + t*t*p2;\n\n    mi = min(mi,q);\n    ma = max(ma,q);\n    \n    return bound3( mi, ma );\n}\n\n\n// ray-ellipse intersection\nfloat iEllipse( in vec3 ro, in vec3 rd,         // ray: origin, direction\n             in vec3 c, in vec3 u, in vec3 v )  // disk: center, 1st axis, 2nd axis\n{\n\tvec3 q = ro - c;\n\tvec3 r = vec3(\n        dot( cross(u,v), q ),\n\t\tdot( cross(q,u), rd ),\n\t\tdot( cross(v,q), rd ) ) / \n        dot( cross(v,u), rd );\n    \n    return (dot(r.yz,r.yz)<1.0) ? r.x : -1.0;\n}\n\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\nfloat length2( in vec3 v ) { return dot(v,v); }\n\nvec3 iSegment( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b )\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p =  a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( th, length2( p-q ) );\n    \n}\n\n\nfloat iBezier( in vec3 ro, in vec3 rd, in vec3 p0, in vec3 p1, in vec3 p2, in float width)\n{\n    const int kNum = 50;\n    \n    float hit = -1.0;\n    float res = 1e10;\n    vec3 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        vec3 b = mix(mix(p0,p1,t),mix(p1,p2,t),t);\n        vec3 r = iSegment( ro, rd, a, b );\n        if( r.z<width*width )\n        {\n            res = min( res, r.x );\n            hit = 1.0;\n        }\n        a = b;\n    }\n    \n    return res*hit;\n    \n    \n}\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n    // camera position\n\tvec3 ro = vec3( -0.5, 0.4, 1.5 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // bezier animation\n    float time = iTime*0.5;\n    vec3 p0 = vec3(0.8,0.6,0.8)*sin( time*0.7 + vec3(3.0,1.0,2.0) );\n    vec3 p1 = vec3(0.8,0.6,0.8)*sin( time*1.1 + vec3(0.0,6.0,1.0) );\n    vec3 p2 = vec3(0.8,0.6,0.8)*sin( time*1.3 + vec3(4.0,2.0,3.0) );\n\tfloat thickness = 0.01;\n        \n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace bezier\n    float t = iBezier( ro, rd, p0, p1, p2, thickness);\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3);\n\t}\n\n    // compute bounding box for bezier\n    bound3 bbox = BezierAABB( p0, p1, p2 );\n    bbox.mMin -= thickness;\n    bbox.mMax += thickness;\n\n    \n    // raytrace bounding box\n    vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n    vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n\tvec2 tbox = iBox( ro, rd, bcen, brad );\n\tif( tbox.x>0.0 )\n\t{\n        // back face\n        if( tbox.y < tmin )\n        {\n            vec3 pos = ro + rd*tbox.y;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n        }\n        // front face\n        if( tbox.x < tmin )\n        {\n            vec3 pos = ro + rd*tbox.x;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n        }\n\t}\n\t\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0-0.5)/256.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsGRN.jpg", "access": "api", "license": "mit", "functions": [[1574, 1574, 1601, 1601, 1709], [1711, 1771, 1790, 1790, 1915], [1917, 2036, 2069, 2069, 2497], [2499, 2545, 2581, 2581, 2748], [2750, 2795, 2890, 2890, 3095], [3097, 3097, 3153, 3153, 3566], [3568, 3620, 3683, 3704, 3937]]}
{"id": "stl3z4", "name": "大龙猫 - Offworld Colony", "author": "totetmatt", "description": "So not 100% fidelity to the bonzomatic but close enough. Can find original glsl here :  https://github.com/totetmatt/shader_summary/blob/main/shader_file_sources/shadow_demoparty_2021/sender_shadow_totetmatt.glsl\n \n", "tags": ["jam", "demoparty"], "likes": 5, "viewed": 367, "published": 3, "date": "1621693784", "time_retrieved": "2024-07-30T19:19:25.359471", "image_code": "\n/*\nShader done as a Jam for the Shadow Demoparty 2021.\n\nCheck the others : Evvvvil, z0rg, NuSan, ponk and lamogui that also participated and performed great compo !!!\n\nAlso thanks and cheers to the folks : evvvvil, flopine, psenough, FMS_cat, yx, cosamentale, blackle, antic0re, wrighter, rimina and all the other that I forgot :) \n*/\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n#define fGlobalTime iTime\nfloat box(vec3 p,vec3 b){\n    vec3 q= abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nvec2 sdf(vec3 p){\n   vec3 op = p;\n   float bt = fract(iTime*.01); // This should be fftIntegrated\n  \n   p += vec3(6,3.,-0.0); // Offset the planet, to have some composition\n   p.xy *= rot(-.785); // Rotation of the planet, yes it's cheap trick and not correct but it works\n  \n  float tt = texNoise(vec2(atan(p.x,p.z),p.y)*.025+bt,iChannel2).r; // TexNoise to have the planet geology\n \n \n  float ttt = texture(iChannel1,fract(vec2(atan(p.x,p.z)+tt*6.+fGlobalTime))).r *.15; // Blyatiful\n/*                                ^----^           ^        ^       ^---- So the whole turns around the planet\n                                  ^                ^        ^------------ This will shift the line, with the noise texture, creating a nice effect\n                                  ^                ^--------------------- Spherical projection (as I phrase it, sorry if it's not correct)\n                                  ^-------------------------------------- This is not needed on bonzomatic as the fftTexture is wrapped repeat                        \n*/\n   tt = floor(tt*100.)/100.; // Create the stairs geology effect\n  \n  vec2 h;\n\n  h.x = length(p)-5.-tt; // That's a sphere with the displacement\n  h.y = 1.-(ttt); // Ok here is the dirty secret, When the fft pass a threshold, it will trigger later the glow\n  \n  vec2 t; // Boring stuff, that utlimately finished as a space Auror Borealis\n   \n  op.x -=2.;\n   op.z = mod(op.z,5.)-2.5;\n   op.y +=sin(op.z*5.+bt);\n   op.xy *=rot(fGlobalTime);\n   op.xz *=rot(floor(bt*20.)*1.33);\n  t.x = box(op,vec3(.9)); // Yeah, a cube as a start, was it necessary ? LOL.\n  t.y = 2.;\n  \n  h = t.x < h.x ? t:h;\n  \n  h.y = max(h.y,.1);\n  return h;\n  }\n  \n/* Normal Routine */\nvec2 nv=vec2(-.005,.005);\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yyx)+q(nv.yxy)+q(nv.xxx));}\n/* End Normal Routine */\n\n// Da Iq Palette color\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(.0,.3,.7)));}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   \n   // The raymarch init\n   vec3 ro=vec3(.0,.0,-7.),rd=normalize(vec3(uv,1.)),rp=ro;\n   vec3 light = vec3(1.,2.,-3.);\n   \n   float bt = texture(iChannel1,vec2(.2)).r*.1; // did I mention I like to abuse texNoise and texFFT ? \n   float tt = texture(iChannel1,vec2(floor(abs(uv.x)*100.)/100.)).r*.01; // in a unreasonable manner ? \n   tt =sqrt(tt)*3.; \n  \n   vec3 col= vec3(tt)*pal(tt*1.); // The background\n  vec3 acc = vec3(0.); // The glow accumulator \n  \n  for(float i=0.;i<=69.;i++){ // LETS MARCH !\n      vec2 d = sdf(rp); // Get the dist\n      \n     if(d.y <=.92){ // Remember the texture trick ? Here we are \n     // This will accumulate only when fft is high enough, like most of us ?\n       acc += pal(d.y*1.2+fGlobalTime*.1)*max(0.,exp(10.*-abs(d.x))/(25.-d.y*20.))*exp(-abs(i/20.));\n       \n     } \n     if(d.y == 2.) { // The right auror borealis\n       \n        acc += vec3(.1,.8,.4)*max(0.,exp(1.*-abs(d.x))/(39.));\n        d.x  = max(0.1,abs(d.x));\n      }\n    \n      rp +=rd*d.x;\n      if(d.x <=.001){ // march to something\n           // Yolo  simple lighting \n           vec3 n = norm(rp);\n           float fre  = pow(1.-dot(-rd,n),5.);\n           if(d.y <=1.){ // only light the planet\n             col = fre*vec3(.1,.5,.8)+vec3(.3)*max(0.,dot(n,normalize(light-rp)));\n             break; // Don't forget to break \n           } \n        }\n    \n    }\n   \n  col+=acc; // add the glow\n  fragColor = vec4(col,1.0); // See you space cowboy\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27190, "src": "https://soundcloud.com/bubba-zen/07-track-7", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stl3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 336, 374, 374, 668], [669, 669, 687, 687, 734], [761, 761, 786, 786, 876], [877, 877, 894, 894, 2560], [2637, 2637, 2655, 2655, 2714], [2741, 2764, 2782, 2782, 2828], [2831, 2831, 2888, 2938, 4453]]}
{"id": "7ll3R4", "name": "KIF screensaver", "author": "leon", "description": "originally made for shadow party 2021 live shader coding", "tags": ["kif"], "likes": 14, "viewed": 579, "published": 3, "date": "1621679924", "time_retrieved": "2024-07-30T19:19:26.113456", "image_code": "// KIF screensaver\n// originally made for shadow party 2021 live shader coding\n//\n// by Leon Denise 2021.05.19\n// \n// thanks to Inigo Quilez, Dave Hoskins, Koltes, NuSan\n// for sharing useful lines of code\n//\n// Licensed under hippie love conspiracy\n\nvoid mainImage( out vec4 color, in vec2 position )\n{\n    // display the result of buffer A tab\n    color = texture(iChannel0, position/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// KIF screensaver\n// originally made for shadow party 2021 live shader coding\n//\n// by Leon Denise 2021.05.19\n// \n// thanks to Inigo Quilez, Dave Hoskins, Koltes, NuSan\n// for sharing useful lines of code\n//\n// Licensed under hippie love conspiracy\n\n#define time iTime\n\nfloat dither;\nfloat material;\n\n// rng function\nfloat hash (vec2 seed)\n{\n    return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.);\n}\n\n// rotation matrix\nmat2 rot (float a)\n{\n    float c=cos(a), s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat map(vec3 p)\n{\n    float dist = 1000.;\n    float shape = 1000.;\n\n    float r = 1.5; // distance from center\n    float s = 0.1; // geometry radius\n    float f = 1.8; // falloff after each iteration\n    float h = 0.4; // geometry height\n    float a = 1.0; // amplitude\n    float t = time*0.5+dither*0.05+p.x*.2;\n    \n    // kaleidoscopic iterated function system\n    const int count = 6;\n    for (int index = count; index > 0; --index)\n    {\n        // rotations\n        p.xy *= rot(0.1*t/a);\n        p.xz *= rot(sin(t/a)+t);\n        p.yz *= rot(t+sin(t*4.));\n        \n        // mirror\n        p.z = abs(p.z)-r*a;\n        \n        // cylinder shape\n        shape = max(length(p.xz)-s*a, abs(p.y)-h*a);\n        \n        // material management (inspired by evvvvil)\n        material = shape < dist ? float(index) : material;\n        \n        // shape union\n        dist = min(shape, dist);\n        \n        // falloff amplitude\n        a /= f;\n    }\n    \n    // sphere bump\n    float spawn = pow(sin(fract(time)*3.14), 10.);\n    dist = min(dist, length(p)-.05*spawn);\n\n    return dist;\n}\n\nvoid mainImage( out vec4 color, in vec2 pixel )\n{\n    // init color\n    color = vec4(0);\n    \n    // coordinates\n    vec2 uv = (pixel.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(0,0,-6);\n    vec3 ray = normalize(vec3(uv, 1.));\n    vec3 pos = eye;\n    \n    // random\n    dither = hash(uv+fract((time)));\n\n    // raymarch loop\n    const int steps = 20;\n    for (int index = steps; index > 0; --index)\n    {\n        // distance estimation\n        float dist = map(pos);\n        if (dist < 0.01)\n        {\n            // shadow from iteration steps\n            float shade = float(index)/float(steps);\n            \n            // rainbow palette from iq (https://iquilezles.org/articles/palettes)\n            vec3 tint = vec3(0.25)+vec3(0.75)*cos(vec3(1,2,3)*.8+material*.4+1.+pos.z*2.+uv.y*1.+shade);\n            \n            // coloring\n            color.rgb = tint * shade;\n            \n            // stop raymarch\n            break;\n        }\n        // step further\n        pos += dist * ray;\n    }\n\n    // frame offset\n    vec2 offset = -20. * uv * length(uv) / iResolution.xy;\n    vec4 frame = texture(iChannel0, pixel.xy/iResolution.xy+offset);\n\n    // frame additive\n    color = max(color, frame*0.99);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ll3R4.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[251, 251, 303, 345, 404]]}
{"id": "NtlGRN", "name": "basic  excitebike", "author": "jorge2017a1", "description": "basic  excitebike", "tags": ["basicexcitebike"], "likes": 12, "viewed": 316, "published": 3, "date": "1621649647", "time_retrieved": "2024-07-30T19:19:26.880405", "image_code": "//por jorge2017a1 ----jorgeFloresP---21/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \n\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 col0= vec3(0.49,0.93,0.29);\nconst vec3 col1= vec3(1.00,0.67,0.31);\nconst vec3 col2= vec3(1.00,0.72,0.67);\nconst vec3 col3= vec3(0.47,0.54,0.00);\nconst vec3 col4= vec3(0.71,0.65,1.00);\nconst vec3 col5= vec3(0.49,0.93,0.29);\nconst vec3 col6= vec3(1.00,0.69,0.34);\nconst vec3 col7= vec3(1.00,0.70,0.47);\nconst vec3 col8= vec3(0.47,0.53,0.00);\nconst vec3 col9= vec3(0.73,0.61,0.15);\nconst vec3 col10= vec3(1.00,0.67,0.31);\nconst vec3 col11= vec3(1.00,0.1,0.1);\nconst vec3 col12= vec3(0.2,0.82,0.42);\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\n\nfloat sdPolyc000 POLY(7)\nvec2 ptc000[ 7]=vec2[](  \nvec2(.019,.502),vec2(.050,.500),vec2(.048,.529),vec2(.045,.536),vec2(.025,.536),\nvec2(.017,.529),vec2(.019,.502) );\n\nfloat sdPolyc001 POLY(7)\nvec2 ptc001[ 7]=vec2[](  \nvec2(.081,.500),vec2(.113,.500),vec2(.111,.529),vec2(.105,.538),vec2(.088,.538),\nvec2(.080,.530),vec2(.081,.500) );\n\nfloat sdPolyc002 POLY(5)\nvec2 ptc002[ 5]=vec2[](  \nvec2(.000,.464),vec2(.997,.466),vec2(.997,.250),vec2(.000,.252),vec2(.000,.464) );\n\nfloat sdPolyc003 POLY(5)\nvec2 ptc003[ 5]=vec2[](  \nvec2(.000,.416),vec2(.991,.418),vec2(.989,.411),vec2(.000,.411),vec2(.000,.416) );\n\nfloat sdPolyc004 POLY(5)\nvec2 ptc004[ 5]=vec2[](  \nvec2(.003,.364),vec2(.991,.364),vec2(.991,.357),vec2(.003,.357),vec2(.003,.364) );\n\n\nfloat sdPolyc005 POLY(5)\nvec2 ptc005[ 5]=vec2[](  \nvec2(.003,.309),vec2(.991,.311),vec2(.991,.304),vec2(.003,.304),vec2(.003,.309) );\n\n\nfloat sdPolyc006 POLY(5)\nvec2 ptc006[ 5]=vec2[](  \nvec2(.000,.250),vec2(.995,.248),vec2(.997,.180),vec2(.000,.180),vec2(.000,.250) );\n\n\nfloat sdPolyc007 POLY(5)\nvec2 ptc007[ 5]=vec2[](  \nvec2(.000,.750),vec2(.994,.750),vec2(.995,.470),vec2(.000,.466),vec2(.000,.750) );\n\n\nfloat sdPolyc008 POLY(5)\nvec2 ptc008[ 5]=vec2[](  \nvec2(.000,.998),vec2(.998,.998),vec2(.995,.750),vec2(.000,.750),vec2(.000,.998) );\n\n\nfloat sdPolyc009 POLY(5)\nvec2 ptc009[ 5]=vec2[](  \nvec2(.000,.857),vec2(.994,.855),vec2(.992,.752),vec2(.000,.752),vec2(.000,.857) );\n\n\nfloat sdPolyc010 POLY(7)\nvec2 ptc010[ 7]=vec2[](  \nvec2(.453,.252),vec2(.516,.321),vec2(.522,.330),vec2(.542,.330),vec2(.547,.321),\nvec2(.609,.254),vec2(.453,.252) );\n\nfloat sdPolyc011 POLY(5)\nvec2 ptc011[ 5]=vec2[](  \nvec2(.455,.254),vec2(.453,.466),vec2(.520,.538),vec2(.519,.329),vec2(.455,.254) );\n\nfloat sdPolyc012 POLY(7)\nvec2 ptc012[ 7]=vec2[](  \nvec2(.550,.325),vec2(.547,.536),vec2(.552,.536),vec2(.614,.466),vec2(.614,.254),\nvec2(.609,.254),vec2(.550,.325) );\n\n\nfloat sdPolyc013 POLY(12)\nvec2 ptc013[ 12]=vec2[](  \nvec2(.517,.534),vec2(.525,.538),vec2(.528,.545),vec2(.541,.545),vec2(.544,.538),\nvec2(.547,.536),vec2(.550,.329),vec2(.547,.325),vec2(.541,.330),vec2(.525,.332),\nvec2(.519,.323),vec2(.517,.534) );\n\n\n\nfloat sdPolyc014 POLY(4)\nvec2 ptc014[ 4]=vec2[](  \nvec2(.477,.361),vec2(.538,.427),vec2(.538,.359),vec2(.477,.361) );\n\nfloat sdPolyc015 POLY(5)\nvec2 ptc015[ 5]=vec2[](  \nvec2(.473,.363),vec2(.475,.463),vec2(.536,.538),vec2(.538,.423),vec2(.473,.363) );\n\nfloat sdPolyc016 POLY(9)\nvec2 ptc016[ 9]=vec2[](  \nvec2(.244,.211),vec2(.238,.213),vec2(.238,.234),vec2(.242,.241),vec2(.270,.239),\nvec2(.277,.236),vec2(.275,.220),vec2(.270,.213),vec2(.244,.211) );\n\n\nfloat sdPolyc017 POLY(6)\nvec2 ptc017[ 6]=vec2[](  \nvec2(.450,.261),vec2(.447,.461),vec2(.569,.530),vec2(.572,.330),vec2(.569,.325),\nvec2(.450,.261) );\n\n\nfloat sdPolyc018 POLY(5)\nvec2 ptc018[ 5]=vec2[](  \nvec2(.445,.254),vec2(.569,.325),vec2(.573,.320),vec2(.456,.254),vec2(.445,.254) );\n\n\nfloat sdPolyc019 POLY(5)\nvec2 ptc019[ 5]=vec2[](  \nvec2(.455,.252),vec2(.572,.318),vec2(.605,.323),vec2(.725,.255),vec2(.455,.252) );\n\n\nfloat sdPolyc020 POLY(5)\nvec2 ptc020[ 5]=vec2[](  \nvec2(.566,.536),vec2(.569,.321),vec2(.606,.323),vec2(.608,.536),vec2(.566,.536) );\n\n\nfloat sdPolyc021 POLY(6)\nvec2 ptc021[ 6]=vec2[](  \nvec2(.608,.323),vec2(.608,.534),vec2(.730,.466),vec2(.733,.254),vec2(.727,.255),\nvec2(.608,.323) );\n\n\nfloat sdPolyc022 POLY(31)\nvec2 ptc022[ 31]=vec2[](  \nvec2(.139,.652),vec2(.139,.673),vec2(.150,.673),vec2(.156,.670),vec2(.164,.666),\nvec2(.164,.664),vec2(.155,.655),vec2(.169,.654),vec2(.170,.657),vec2(.175,.657),\nvec2(.180,.643),vec2(.175,.643),vec2(.169,.643),vec2(.156,.645),vec2(.155,.634),\nvec2(.155,.625),vec2(.166,.609),vec2(.170,.609),vec2(.167,.604),vec2(.155,.605),\nvec2(.147,.616),vec2(.141,.604),vec2(.127,.604),vec2(.127,.609),vec2(.131,.611),\nvec2(.131,.621),vec2(.138,.629),vec2(.131,.632),vec2(.131,.648),vec2(.134,.652),\nvec2(.139,.652) );\n\n\nvec3   HacerPista(vec2 p,  vec3  col)\n{\n     float sdc002 = sdPolyc002(p, ptc002);     //pista\n    col=ponerBorde(col1,col,sdc002 );\n    \n    float sdc003 = sdPolyc003(p, ptc003);    //linea1  pista\n    col=ponerBorde(col11,col,sdc003 );\n\n    float sdc004 = sdPolyc004(p, ptc004);  //linea2  pista\n    col=ponerBorde(col11,col,sdc004 );\n\n    float sdc005 = sdPolyc005(p, ptc005);  //linea3  pista\n    col=ponerBorde(col11,col,sdc005 );\n\n  return col;\n}\n\n\n\nvec3 HacerPiaremide1(vec2  p, vec3 col)\n{\n\n    float sdc010 = sdPolyc010(p, ptc010);  //piramide1\n    col=ponerBorde(col3,col,sdc010 );\n\n    float sdc011 = sdPolyc011(p, ptc011);\n    col=ponerBorde(col3,col,sdc011 );\n\n    float sdc012 = sdPolyc012(p, ptc012);\n    col=ponerBorde(col2,col,sdc012 );\n\n    float sdc013 = sdPolyc013(p, ptc013);\n    col=ponerBorde(col1,col,sdc013 );\nreturn col;\n}\n\nvec3  HacerPiramideV2(vec2 p, vec3 col)\n{\n   //triangulo  chico\n    float sdc014 = sdPolyc014(p, ptc014);  //piramide 2\n    col=ponerBorde(col3,col,sdc014 );\n    \n    float sdc015 = sdPolyc015(p, ptc015);\n    col=ponerBorde(col10,col,sdc015 );\n\n  return col;\n}\n\nvec3  HacerPiramideV3(vec2 p, vec3   col)\n{\n    float sdc017 = sdPolyc017(p, ptc017);   //piramide  3\n    col=ponerBorde(col3,col,sdc017 );\n\n    float sdc018 = sdPolyc018(p, ptc018);\n    col=ponerBorde(col1,col,sdc018 );\n\n  float sdc019 = sdPolyc019(p, ptc019);\n    col=ponerBorde(col3,col,sdc019 );\n\n    float sdc020 = sdPolyc020(p, ptc020);\n    col=ponerBorde(col1,col,sdc020 );\n\n  float sdc021 = sdPolyc021(p, ptc021);\n  col=ponerBorde(col2,col,sdc021 );\nreturn  col;\n}\n\n//***------------****-----------****------------******-------\nvec3 ExciteBikeNes(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n  vec2  pr0=p;\n  pr0.x=mod(pr0.x,0.065);\n  \n     float sdc000 = sdPolyc000(pr0, ptc000);\n     col=ponerBorde(col1,col,sdc000 );  //arbolito1\n    vec2  pr=p, pr1=p,pr2=p,pr3=p;\n   \n    pr.x=mod(pr.x,0.95);\n    col=HacerPista(pr,col) ;\n   \n    float sdc006 = sdPolyc006(pr, ptc006);  //parte  inferior  piso\n    col=ponerBorde(col5,col,sdc006 );\n  \n    float sdc008 = sdPolyc008(pr, ptc008);   //publico\n    col=ponerBorde(colNegro,col,sdc008 );   \n    \n    float sdc009 = sdPolyc009(pr, ptc009);  //pared  publico\n    col=ponerBorde(col4,col,sdc009 );\n    \n    pr1.x=mod(pr1.x,1.5);  \n    col= HacerPiaremide1(pr1-vec2(0.35,0.0),col);\n    \n    vec2  pr4=p;\n    pr4.x=mod(pr4.x,0.37);\n    float sdc016 = sdPolyc016(pr4, ptc016);     //flores  2\n    col=ponerBorde(col4,col,sdc016 );\n    \n    pr2.x=mod(pr2.x,0.746);  \n    col=  HacerPiramideV2(pr2,col);\n    \n    pr3.x=mod(pr3.x,2.5);  \n    col=  HacerPiramideV3(pr3-vec2(0.0,0.0), col);\n    \n    float sdc022 = sdPolyc022(pr, ptc022);     //persona\n    col=ponerBorde(col8,col,sdc022 );\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.35;\n    vec2 p=uv*0.4-vec2(-0.45-t,-0.6);\n    vec3 col=col12;\n     \n    col=ExciteBikeNes(p, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlGRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 315, 351, 351, 396], [403, 403, 464, 464, 588], [591, 591, 651, 651, 777], [1319, 1319, 1350, 1350, 1371], [5590, 5590, 5629, 5629, 6042], [6046, 6046, 6087, 6087, 6438], [6440, 6440, 6481, 6503, 6700], [6702, 6702, 6745, 6745, 7174], [7176, 7238, 7281, 7281, 8352], [8354, 8354, 8411, 8411, 8660]]}
{"id": "7tX3zN", "name": "pinch effect", "author": "yonechen", "description": "pinch effect", "tags": ["distort", "deform", "stretch", "pinch"], "likes": 7, "viewed": 910, "published": 3, "date": "1621621246", "time_retrieved": "2024-07-30T19:19:27.719162", "image_code": "#define RANGE .5\nvec2 pinch(vec2 uv, vec2 targetPoint, vec2 vector, float range) \n{ \n    vec2 center = targetPoint + vector;\n    float dist = distance(uv, targetPoint);\n    vec2 point = targetPoint +  smoothstep(0., 1., dist / range) * vector;\n    return uv - center + point;\n}\nvoid mainImage(out vec4 fragColor, vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    // vec2 pos = iMouse.xy / iResolution.xy;\n    vec2 pos = vec2(.5);\n    vec2 pinchVector = vec2( sin(iTime * 5.), cos(iTime * 10.)) * .1;\n    uv = pinch(uv, pos, pinchVector, RANGE);\n    vec3 color = texture(iChannel0, uv).rgb;\n    fragColor.rgb = color;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tX3zN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 83, 83, 277], [278, 278, 326, 326, 624]]}
{"id": "slfGzN", "name": "twirl effect", "author": "yonechen", "description": "twirl effect", "tags": ["distort", "deform", "vortex", "twirl"], "likes": 11, "viewed": 1118, "published": 3, "date": "1621620201", "time_retrieved": "2024-07-30T19:19:28.580858", "image_code": "#define Range .5\n#define SPEED 1.\n#define STRENGTH 6.28\n\nmat2 rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nvec2 twirl(vec2 uv, vec2 center, float range, float strength) {\n    float d = distance(uv,center);\n    uv -=center;\n    // d = clamp(0.,strength,-strength/range * d + strength);\n    d = smoothstep(0.,range,range-d) * strength;\n    uv *= rotate(d);\n    uv+=center;\n    return uv;\n}\nvoid mainImage(out vec4 fragColor, vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    // vec2 pos = iMouse.xy / iResolution.xy;\n    vec2 pos = vec2(.5);\n    float cTime = STRENGTH *sin(iTime * SPEED);\n    uv = twirl(uv, pos, Range,cTime);\n    vec3 color = texture(iChannel0, uv).rgb;\n    fragColor.rgb = color;\n} ", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 79, 79, 152], [153, 153, 216, 216, 433], [434, 434, 482, 482, 751]]}
{"id": "7lXGzN", "name": "inflate effect", "author": "yonechen", "description": "inflate effect", "tags": ["distort", "deform", "inflate", "enlarge"], "likes": 6, "viewed": 801, "published": 3, "date": "1621619456", "time_retrieved": "2024-07-30T19:19:29.459509", "image_code": "#define SPEED 2.\n#define RANGE .5\n#define Strength .5\n\nvec2 inflate(vec2 uv, vec2 center, float radius, float strength) {\n    float dist = distance(uv , center);\n    vec2 dir = normalize(uv - center);\n    float scale = 1.-strength + strength *smoothstep(0.,1.,dist/radius);\n    float newDist = dist * scale;\n    return center + newDist * dir;\n}\nvoid mainImage(out vec4 fragColor, vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    // vec2 pos = iMouse.xy / iResolution.xy;\n    vec2 pos = vec2(.5);\n    uv = inflate(uv, pos, RANGE, Strength * sin(iTime * SPEED));\n    vec3 color = texture(iChannel0, uv).rgb;\n    fragColor.rgb = color;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXGzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 121, 121, 344], [345, 345, 393, 393, 641]]}
{"id": "7d2XDd", "name": "kd-tree sdf", "author": "sympou", "description": "something that happenend while working on randomized house plans :)\nthis seems to be a kd-tree, with one division per cell.\ni would like to add doors now, but this is the problem of another day.", "tags": ["kdtree"], "likes": 25, "viewed": 745, "published": 3, "date": "1621615277", "time_retrieved": "2024-07-30T19:19:30.335168", "image_code": "#define iterations  4\n#define texMode     false\n#define amplitude   0.7\n\n//Dave_Hoskins's hash function\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 pos = uv*2.0-1.0;\n    pos.x *= iResolution.x/iResolution.y;\n    pos *= 0.75;\n    \n    vec2 boxSize = vec2(1.0);\n        \n    // box SDF\n    // https://iquilezles.org/articles/distfunctions\n    vec2 q = abs(pos) - 0.5*boxSize;\n    float dist = length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n    \n    //at the end, each cell has a different number\n    int num = 0;\n    \n    // current cell coordinates\n    // (left up -- right down)\n    vec4 corners = vec4(-0.5,-0.5, 0.5,0.5)*boxSize.xyxy;\n\n    //seed\n    float seed  = floor(iTime*0.25   )*123.456 + 1.111;\n    float seed2 = floor(iTime*0.25+1.)*123.456 + 1.111;\n    float transition = fract(iTime*0.25);\n    \n    //now, we divide the box into random sized smaller boxes\n    int k = 1;\n    for (int i = 0; i < iterations; i++) {\n    \n        //x or y ?\n        int j = i % 2;\n        \n        //random line (inside current cell)\n        float r = mix( hash11(seed+float(num)), hash11(seed2+float(num)), transition);\n        r = ( (r-0.5)*amplitude + 0.5 ) * (corners[j+2]-corners[j]) + corners[j];\n                \n        // condition : which side are we on ?\n        int c = int(max(sign(r-pos[j]),0.0));\n        \n        //actualize closest wall coordinate\n        corners[j+c*2] = r;\n        \n        //the cell number gets bigger, or not\n        num += k*c;\n        k += k;\n    }\n  \n    //distance from closest line\n    dist = max(dist, -abs(corners[0]-pos.x));\n    dist = max(dist, -abs(corners[1]-pos.y));\n    dist = max(dist, -abs(corners[2]-pos.x));\n    dist = max(dist, -abs(corners[3]-pos.y));\n    \n    //\"walls\"\n    //dist = abs(dist)-0.02;\n    \n    //\n    \n    \n    //iq's distance color style\n    //https://www.shadertoy.com/view/3ltSW2\n    vec3 col = vec3(1.0) - sign(dist)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(dist));\n\tcol *= 0.8 + 0.2*cos(150.0*dist);\n    \n    if (texMode == true) {\n        vec2 uv2 = (pos - corners.xy)/(corners.zw-corners.xy);\n        if (max(abs(uv2.x-0.5),abs(uv2.y-0.5))<=0.5) {\n            col = texture(iChannel0, uv2).rgb;\n        }\n    }\n    \n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(dist)) );\n    \n    fragColor = vec4(col,1.0);\n\n\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2XDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 144, 167, 167, 252], [254, 254, 311, 311, 2517]]}
{"id": "stfGz4", "name": "another glitch effect", "author": "yasuo", "description": "glitch", "tags": ["glitch"], "likes": 7, "viewed": 476, "published": 3, "date": "1621607331", "time_retrieved": "2024-07-30T19:19:31.512022", "image_code": "vec2 glitchEfect(vec2 uv, float shift) {\n    float glitchBlock = 3.0;\n    vec2 uv2 = fract(uv*glitchBlock)-0.5;\n    vec2 id = floor(uv2);\n    \n    vec2 n2 = fract(sin(id*123.456)*789.125);\n    n2+=dot(id.x,id.y*567.89);\n    float n = fract(n2.x+n2.y);\n    \n    if(mod(iTime,1.0)<0.5){\n        float glitchDist = 0.01;\n        float glitchTime = iTime*19.0;\n        uv.x-=(fract(floor(uv.y+n2.y*glitchBlock)*glitchTime)*glitchDist);\n        uv.y-=(fract(floor(uv.x+n2.x*glitchBlock)*glitchTime)*glitchDist);\n        uv.x+=sin(glitchTime*2.0)*shift;\n        uv.x+=sin(floor(uv.y*glitchBlock*1.2)*iTime*20.)*glitchDist;\n        uv.y+=sin(floor(uv.x*glitchBlock*1.2)*iTime*21.)*glitchDist;\n    }\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 r_uv = glitchEfect(uv,0.0);\n    vec2 g_uv = glitchEfect(uv,0.015);\n    vec2 b_uv = glitchEfect(uv,0.025);\n    \n\n    float r = texture(iChannel0,r_uv).r;\n    float g = texture(iChannel0,g_uv).g;\n    float b = texture(iChannel0,b_uv).b;\n    \n    vec3 col = vec3(r,g,b);\n    vec2 size = vec2(1.0,0.03);\n    \n    float t = mod(iTime,1.0);\n    if(t<0.5){\n        for(float i = 1.;i<6.0; i++){\n            vec2 pos = p;\n            pos.y+=sin(floor(iTime*2.1*i))*1.0;\n            size.x = 0.5+abs(cos(floor(iTime*2.1*i))*1.5);\n            size.y = 0.02+sin(floor(iTime*2.1*i))*0.03;\n            float d = smoothstep(0.,0.001,-max(abs(pos.x)-size.x,abs(pos.y)-size.y));\n            col = mix(col,vec3(b,r,g)*1.05,d); \n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfGz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 708], [710, 710, 767, 767, 1645]]}
{"id": "ftX3z4", "name": "Into the triverse", "author": "maeln", "description": "zoooom", "tags": ["raymarching"], "likes": 0, "viewed": 296, "published": 3, "date": "1621607082", "time_retrieved": "2024-07-30T19:19:32.584155", "image_code": "#define PI 3.1415\n#define MAXSTEPS 128\n#define MINDIST  0.0005\n#define MAXDIST  20.0\n#define saturate(x) (clamp(0.0, 1.0, x))\n#define f1(x) (clamp(x, 0.0, 1.0))\n#define rep(p, r) (mod(p - r*.5, r) - r*.5)\n\nvec3 hi = vec3(0.0, 0.0, 0.0)/255.0;\nvec3 lo = vec3(0.0, 0.0, 0.0)/255.0;\n\nstruct pLight {\n    vec3 position;\n    vec3 ambiant;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n    \nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p);\n    return sqrt(max(0.0, dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\n// Compute the position of particle {i} at the time {iTime}.\nvec3 calcPos(int i) {\n    float fi = float(i);\n    float dx = sin((fi/4.0)+iTime) + mix(2.0, 0.0, f1(iTime-4.0));\n    float dy = sin(2.0*PI*(fi/10.0) + iTime) - mix(0.0, sin(2.0*PI*(fi/10.0) + iTime), f1(iTime/1.5-20.0));\n    float dz = cos(2.0*PI*(fi/10.0) + iTime) - mix(0.0, cos(2.0*PI*(fi/10.0) + iTime), f1(iTime/1.5-20.0));\n    \n    vec3 dir = vec3(dx, dy, dz);\n    vec3 p = dir;\n    \n    return p;\n}\n\nfloat sdTriangle(vec3 ray) {\n    vec3 p1 = vec3(0.0);\n    vec3 p2 = vec3(0.0, 0.0, 1.0);\n    vec3 p3 = vec3(0.0, sqrt(1.0), 0.5);\n    return min(min(sdCapsule(ray, p1, p2, 0.01), sdCapsule(ray, p2, p3, 0.01)), sdCapsule(ray, p3, p1, 0.01));\n}\n\n\nvec2 enter(vec3 ray) {\n    float mi = 0.0;\n    float de = MAXDIST;\n    for(int i=1; i<50; ++i) {\n        float fi = float(i);\n        float zr = 2. - random(vec2(fi, 5.0)) * 4.0;\n        float yr = 2. - random(vec2(fi, 2.0)) * 4.0;\n        float xr = -10.0 + mix((fi/50.0*10.0), 0.0, saturate(iTime/20.0)) + mod(iTime*2.0+(random(vec2(fi, 1.0))*20.0), 20.0);\n        vec3 q = ray - vec3(xr, yr, zr);\n        float rx = 2. - random(vec2(fi, 5.0)) * 4.0;\n        q = (rotationMatrix(vec3(rx, yr, zr), iTime) * vec4(q, 1.0)).xyz;\n        float di = sdTriangle(q);\n        if(de > di) {\n            de = di;\n            mi = fi;\n        }\n    }\n    return vec2(de, mi);\n}\n\nvec2 dancingSphere(vec3 ray) {\n    float mi = 0.0;\n    float de = MAXDIST;\n    for(int i=0; i<10; ++i) {\n        float di = sdSphere(ray-calcPos(i), 0.1);\n        if(de > di) {\n            de = di;\n            mi = float(i)+1.0;\n        }\n    }\n    \n    return vec2(de, mi);\n}\n\n// Draw all the particles\nvec3 scene(vec3 ray)\n{\n    vec2 init = enter(ray);\n    vec2 spheres = dancingSphere(ray);\n    \n    float kmi = init.y;\n    float kde = init.x;\n    float koi = 0.0;\n    \n    if(spheres.x < init.x) {\n        kmi = spheres.y;\n        kde = spheres.x;\n        koi = 1.0;\n    }\n    \n    return vec3(kde, kmi, koi);\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0.0, MINDIST);\n\treturn normalize(vec3(\n    scene(pos + eps.yxx).x - scene(pos - eps.yxx).x,\n    scene(pos + eps.xyx).x - scene(pos - eps.xyx).x,\n    scene(pos + eps.xxy).x - scene(pos - eps.xxy).x));\n}\n\nvec4 raymarch(vec3 from, vec3 direction)\n{\n    float t = 1.0*MINDIST;\n    int i = 0;\n    vec3 march = vec3(MAXDIST, -1.0, -1.0);\n    for(int steps=0; steps<MAXSTEPS; ++steps)\n    {\n        ++i;\n        march = scene(from + t * direction);\n        if(march.x < MINDIST || t >= MAXDIST) break;\n        t += march.x;\n    }\n    return vec4(t, t > MAXDIST ? -1.0 : march.y, march.z, float(i));\n}\n\nvec3 phong(vec3 hit, vec3 eye, vec3 N, pLight light, float ks) {\n    vec3 L = normalize(light.position - hit);\n    vec3 V = normalize(eye - hit);\n    vec3 R = reflect(L, N);\n    vec3 ambiant = light.ambiant;\n    vec3 diffuse = max(dot(L,N), 0.0)*light.diffuse;\n    vec3 specular = pow(max(dot(R,V), 0.0), ks)*light.specular;\n    return ambiant + 0.5*(diffuse+specular);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pLight l1 = pLight(vec3(sin(iTime/3.0), sin(iTime/4.0), cos(iTime/6.0)),\n                       vec3(0.0), vec3(0.0), vec3(1.8));\n    \n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 target  = vec3(0.0, 0.0, 0.0);\n\tvec3 eye     = vec3(2.0, 0.0, 0.0);\n    vec3 up      = vec3(0.0, 1.0, 0.0);\n    \n    vec3 eyeDir   = normalize(target - eye);\n    vec3 eyeRight = normalize(cross(up, eye));\n    vec3 eyeUp    = normalize(cross(eye, eyeRight));\n    \n    vec3 rayDir = normalize(eyeRight * uv.x + eyeUp * uv.y + eyeDir);\n       \n    vec3 skyCol = mix(lo, hi, gl_FragCoord.y/iResolution.y);\n    vec3 color = skyCol;\n    \n    vec4 march = raymarch(eye, rayDir);\n    color = vec3(0.3, 0.0, 1.0) * march.w / float(MAXSTEPS) * 4.0;\n    if(march.y>0.0) {\n        color = vec3(1.0);\n        if(march.z>0.0) {\n            vec3 hit = eye+march.x*rayDir;\n            vec3 norm = normal(hit);\n            color *= phong(hit, eye, norm, l1, 16.0);\n        }\n    }\n    \n    \n    // LOGO\n    // left-down circle\n    float d = sdCircle(uv + vec2(1.25, 0.5), 0.1);\n    color = mix(color, vec3(1.0), smoothstep(3.0/iResolution.y, 0.0, d));\n    \n    // left down arc\n    float ta = PI/2.0 * iTime*2.0;// 3.14*(0.5+0.5*cos(iTime*0.52+2.0));\n    float tb = PI/4.0 * (1.0-sin(iTime)/2.0); //3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n    d = sdArc(uv + vec2(1.25, 0.5),vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.2, 0.02);\n    color = mix(color, vec3(1.0), smoothstep(4.0/iResolution.y, 0.0, d));\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftX3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[375, 375, 402, 402, 509], [511, 511, 556, 556, 1184], [1186, 1186, 1238, 1238, 1338], [1344, 1344, 1389, 1389, 1671], [1673, 1673, 1706, 1706, 1734], [1736, 1736, 1788, 1788, 1909], [1911, 1911, 1944, 1944, 1972], [1974, 1974, 2052, 2052, 2241], [2243, 2304, 2325, 2325, 2710], [2712, 2712, 2740, 2740, 2954], [2957, 2957, 2979, 2979, 3624], [3626, 3626, 3656, 3656, 3902], [3904, 3930, 3952, 3952, 4241], [4243, 4243, 4266, 4266, 4488], [4490, 4490, 4532, 4532, 4880], [4882, 4882, 4946, 4946, 5253], [5255, 5255, 5312, 5312, 6846]]}
{"id": "sdsXRf", "name": "dotflow", "author": "frhun", "description": "The sad remainder from what was planned to be a single pass vector field flow visualization, but didn't work out too well.", "tags": ["hexagon", "dot"], "likes": 4, "viewed": 316, "published": 3, "date": "1621601855", "time_retrieved": "2024-07-30T19:19:33.336144", "image_code": "const float maxRad = 0.433012702,\n            vs = 0.866025404,\n            scaling = 10.;\n\nvec2 nearestHexCenter(in vec2 coord){\n    vec2 nearest = \n                    vec2(\n                         floor(coord.x) + (1. + 2.*floor(mod(coord.x, 1.) - 0.5)) * floor(mod(coord.y / vs, 2.)) * 0.5,\n                         floor(coord.y / vs) * vs\n                        )\n                  + vec2(.5, vs * 0.5);\n    return nearest;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y);\n    \n    \n    vec2 coord = uv * scaling;\n    float distPerPix = scaling / min(iResolution.x, iResolution.y);\n    float val = 0.5 * (1. + sin(iTime + uv.x * 5.));\n    vec3 col = mix(vec3(0.776,0.776,0.776), vec3(0.024,0.596,1.000),\n               smoothstep(val * maxRad - distPerPix, val * maxRad,\n                          distance(coord, nearestHexCenter(coord))\n                          )\n                   );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 129, 129, 433], [435, 435, 492, 542, 1074]]}
{"id": "slfGR4", "name": "Frog eggs", "author": "zero2021", "description": "Frog eggs", "tags": ["frogeggs"], "likes": 7, "viewed": 296, "published": 3, "date": "1621601757", "time_retrieved": "2024-07-30T19:19:34.119051", "image_code": "#define PI 3.1415926535897932384626\n\nvec2 grid_random(vec2 p) {\n  return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n  \n void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 mn = iResolution.xy / 40.0;\n\n    vec4 _o = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float scale = 0.4;\n    for(int l = 0; l < 8; l++){\n      vec2 _uv = uv;\n      float rad = iTime * scale * 0.1;\n      _uv.x += cos(rad);\n      _uv.y += sin(rad);\n      _uv *= mn / scale;\n      vec2 i = floor(_uv);\n      vec2 f = fract(_uv);\n\n      float m_dist = 1.0;\n      vec2 m_point;\n      for (float j = -1.0; j <= 1.0; j++) {\n        for(float k = -1.0; k <= 1.0; k++) {\n          vec2 neighbor = vec2(k, j);\n          vec2 point = grid_random(i + neighbor);\n          point = 0.5 + 0.5 * sin(iTime + point * PI * 2.0);\n          float dist = distance(neighbor + point, f);\n          if (dist < m_dist) {\n            m_dist = dist;\n            m_point = point;\n          }\n        }\n      }\n      m_dist = 1.0 - m_dist;\n      float value = (smoothstep(0.65, 0.7, m_dist) - smoothstep(0.75, 0.8, m_dist)) * 0.3;\n      value += smoothstep(0.85, 0.9, m_dist);\n      _o.xyz = mix(_o.xyz, vec3(scale, scale, scale), value);\n      scale *= 1.1;\n    }\n\n    // Output to screen\n    fragColor = _o;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfGR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 63, 63, 161], [166, 166, 223, 273, 1398]]}
{"id": "slXGRH", "name": "Shadertoy 2021", "author": "iapafoto", "description": "A better physics engine based on https://en.m.wikipedia.org/wiki/Collision_response#  and many shadertoy inputs\n", "tags": ["sdf", "physics", "pbr", "rigidbody", "impulse"], "likes": 42, "viewed": 726, "published": 3, "date": "1621593919", "time_retrieved": "2024-07-30T19:19:35.069510", "image_code": "//-----------------------------------------------------\n// Created by sebastien durand - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n// [PMalin]         Shader Rally             - https://www.shadertoy.com/view/XdcGWS\n// [ThomasSchander] Interactive Bunny Physics- https://www.shadertoy.com/view/XlfyzN\n// [iq]             Capsule - soft shadow    - https://www.shadertoy.com/view/MlGczG\n// [iq]             Balls and shadows        - https://www.shadertoy.com/view/lsSSWV\n// [Shane]          Desert Canyon            - https://www.shadertoy.com/view/Xs33Df\n//-----------------------------------------------------\n\n\n#define WITH_AO\n\n// -----------------------------------------------------------\n\nconst vec3 light = normalize( vec3(-.4, .3, -1.5) );\nconst float dstFar = 200.;\n\nvec3 vnBall;\nint idBall;\n\nint[] txt = int[] (83,104,97,100,101,114,0);\n\nfloat sample_dist_gaussian(vec2 uv) {\n    const int nstep = 3;\n    const float w[3] = float[3](1., 2., 1.);\n    float d, wij, dsum = 0., wsum = 0.;    \n    for (int i=0; i<nstep; ++i) {\n        for (int j=0; j<nstep; ++j) {\n            vec2 delta = vec2(float(i-1), float(j-1))/1024.;\n            d = textureLod(iChannel3, uv-delta, 0.).w - 127./255.;\n            wij = w[i]*w[j];\n            dsum += wij * d;\n            wsum += wij;\n        }\n    }\n    return dsum / wsum;\n}\n\nfloat sdFont(vec2 p, int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), sample_dist_gaussian(uv));\n}\n\n\n//----------------------------------------------------------\n// Adapted from\n//  [FabriceNeyret2] https://www.shadertoy.com/view/llyXRW\n//----------------------------------------------------------\nfloat sdMessage(vec2 p, int[7] text, int start, float scale, float bold, float italic) { // --- to alter in the icon with the alter message\n    p /= scale;\n    p.x += p.y*italic;\n    float d = 9999.;\n    for (int i=min(iFrame,0)+start; i<text.length(); i++) { // COompile time 2s [Thanks iq :)]   \n        if (text[i] == 0) break;\n        d = min(d, sdFont(p, text[i]));\n        p.x-=.5;\n\n    }\n    return d*scale - bold;\n}\n\n\n// +-------------------------------------+\n// |         Geometric tools             |\n// +-------------------------------------+\n\n// Distance to point\nfloat dista(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro,rd));\n}\n\n// dean_the_code - Inception totem - https://www.shadertoy.com/view/wl3czM\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec2 h = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\treturn mix(h.x, h.y, p.y);\n}\n\nfloat n11(float p) {\n\tfloat ip = floor(p);\n\tp = fract(p);\n\tvec2 h = fract(sin(vec2(ip, ip + 1.) * 12.3456) * 43.5453);\n\treturn mix(h.x, h.y, p * p * (3. - 2. * p));\n}\n\nfloat wood(vec2 p) {\n\tp.x *= 71.;\n\tp.y *= 1.9;\n\treturn n11(n21(p) * 30.);\n}\n\nvec3 woodColor(vec3 p) {\n    return mix(mix(vec3(.17, .1, .05), vec3(.08, .05, .03), wood(p.xz)), vec3(.5, .4, .2) * .4, .3 * wood(p.xz * .2));\n}\n\n//-------------------------------------------------------------------------------------------\n// Capsules related functions\n//-------------------------------------------------------------------------------------------\n// [iq] Capsule - soft shadow - https://www.shadertoy.com/view/MlGczG\n//-------------------------------------------------------------------------------------------\n\nfloat capShadow( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r, in float k ) {\n    vec3 ba =  b - a, oa = ro - a;\n    // closest distance between ray and segment\n\tfloat oad  = dot( oa, rd ), dba  = dot( rd, ba ),\n\t\t  baba = dot( ba, ba ), oaba = dot( oa, ba );\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\tth.x = max(   th.x, .0001 );\n\tth.y = clamp( th.y, .0, 1. );\n\tvec3  p =  a + ba*th.y, q = ro + rd*th.x;\n    float d = length( p-q )-r;\n    // fake shadow\n    float s = clamp( k*d/th.x, 0., 1. );\n    return s*s*(3.-2.*s);\n}\n\n// Intersection avec la mine\nvec4 iCappedCone( in vec3  ro, in vec3  rd, \n                  in vec3  pa, in vec3  pb, \n                  in float ra, in float rb ) {\n    vec3  ba = pb - pa, oa = ro - pa;\n    float m0 = dot(ba,ba), m1 = dot(oa,ba)*.942, m3 = dot(rd,ba)*.942,\n          m4 = dot(rd,oa), m5 = dot(oa,oa),\n          rr = ra - rb,\n          hy = m0 + rr*rr,   \n          k2 = m0*m0    - m3*m3*hy,\n          k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.),\n          k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2. - m0*ra),\n          h = k1*k1 - k2*k0;\n    if( h<0. ) return vec4(-1);\n    float t = (-k1-sqrt(h))/k2;\n    float y = m1 + t*m3;\n    return y>0. && y<m0 ?\n            vec4(t, normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y)) :\n            vec4(-1);\n}\n\n\n// compute normal\nvec3 capNormal(in vec3 pos, in vec3 a, in vec3 b, in float r ) {\n    vec3  ba = b - a, pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return (pa - h*ba)/r;\n}\n\n// intersect capsule\nvec4 capIntersect( in vec3 ro, in vec3 rd, in vec3 pa0, in vec3 pb0, in float r ) {\n    vec3  n = normalize(pb0 - pa0);\n    vec3  pa = pa0 + n*.12, pb = pb0;\n    vec3  ba = pb - pa, oa = ro - pa;\n    float baba = dot(ba,ba), bard = dot(ba,rd),\n    \t  baoa = dot(ba,oa), rdoa = dot(rd,oa), oaoa = dot(oa,oa);\n    float a = baba - bard*bard,\n          b = baba*rdoa - baoa*bard,\n          c = baba*oaoa - baoa*baoa - r*r*baba,\n          h = b*b - a*c;          \n    if( h>=0.) {\n        float t = (-b-sqrt(h))/a,\n              y = baoa + t*bard;\n        // body\n        if (y>0. && y<baba) return vec4(t, capNormal(ro+rd*t, pa0, pb0, r));\n        // caps\n        if (y>0.) {\n            vec3 oc = y<=0. ? oa : ro - pb;\n            b = dot(rd,oc);\n            h = b*b - dot(oc,oc) + r*r;\n            if (h>0.) {\n                t = -b - sqrt(h);\n                return vec4(t, capNormal(ro+rd*t, pa0, pb0, r));\n            }\n        } else {\n            return iCappedCone(ro, rd, pa, pa0-n*.1, r, r*.65);\n        }\n    }\n    return vec4(-1);\n}\n\n\n// fake occlusion\nfloat capOcclusion( in vec3 p, in vec3 n, in vec3 a, in vec3 b, in float r ) {\n    vec3 ba = b - a, pa = p - a,\n         d = pa - ba * clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    float l = length(d), o = 1. - max(0.,dot(-d,n))*r*r/(l*l*l);\n    return o;\n}\n\nfloat occlusion(in vec3 pos, in vec3 nor ) {\n\tfloat res = 1.;\n    float r = 0.;\n    vec3 p=vec3(0), p0=vec3(0), p1=vec3(0);\n    for (int n =min(iFrame,0); n<NB_BODY; n++) {\n        loadBSphere(iChannel0, n, p, r);\n        if (distance(pos, p) < 1.5*r) {\n            loadBodyPosFromC(iChannel0, n, p, p0, p1, r);\n            res *= capOcclusion(pos, nor, p0, p1, r);  \n        }\n    }\n    return res;\t\t\t\t\t  \n}\n\nfloat PencilHit(vec3 ro, vec3 rd, float maxDist) {\n    vec4 d;\n    float dMin = maxDist;\n\tfloat res = 1.;\n    float r = 0.;\n    vec3 nor=vec3(0),p=vec3(0), p0=vec3(0), p1=vec3(0);\n    for (int n =min(iFrame,0); n<NB_BODY; n++) {\n        loadBSphere(iChannel0, n, p, r);\n        if (dista(ro,rd,p) < r) {\n            loadBodyPosFromC(iChannel0, n, p, p0, p1, r);\n            d = capIntersect(ro, rd, p0, p1, r);\n            if (d.x > 0. && d.x < dMin) {\n                dMin = d.x;\n                vnBall = d.yzw;\n                idBall = n;\n            }\n        }\n    }\n    return dMin;\n}\n\n\n// +--------------------------------+\n// |          Rendering             |\n// +--------------------------------+\n\n// iq- Palettes - https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 rainbow(float x) {\n    return sqrt(pal( x, vec3(.5),vec3(.5),vec3(1),vec3(0.0,0.33,0.67) ));\n}\n\n//------------------------------------------------------------------------\n// [Shane] - Desert Canyon - https://www.shadertoy.com/view/Xs33Df\n//------------------------------------------------------------------------\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Grey scale.\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps;             \n    grad -= nor*dot(nor, grad);          \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\nvec3 shade( in vec3 rd, in vec3 pos, in vec3 nor, in int id, in float dis ) {    \n    // Color\n    vec3 col;\n    float kspe = 2.;\n    if (id<0) {\n         col = pow(2.*woodColor(.1*pos),vec3(.5));\n         nor = doBumpMap(iChannel1, vec3(.3,.3,.3)*pos, nor, .003);\n    } else {\n        Body body = loadBody(iChannel0, id);\n        vec3 uvw  = worldPtToBody(body, pos);\n        float zstart = uvw.z + body.h_2;\n        float zend = uvw.z - body.h_2-.08;\n        vec3 col0 = rainbow(mod(float(id)*.101,1.));\n        col = col0;\n        if (uvw.y > 0.) {\n            float dTxt = sdMessage(uvw.zx+vec2(body.h_2-.28,.02), txt, 0, .14, 0., -.3);\n            col = mix(col, vec3(0), .8*smoothstep(.005,.0, abs(dTxt-.008)-.0025)); \n        }\n        col = mix(col, sqrt(.43+2.*woodColor(.5*uvw)), smoothstep(.0,.02, zend+.2));        \n        col *= .4 + .6* smoothstep(.10,.11, abs(zstart-.07));    \n        col *= .2+.8*smoothstep(.0,.01, abs(zstart-.2)-.005);    \n        col *= .2+.8*smoothstep(.0,.01, zstart+.05);    \n        col *= .9+.1*(wood(.5*uvw.yz) + wood(.5*uvw.xz));\n\n        // mine\n        float end = mix(.055,.095, hash(float(id)))-.03;\n        col = mix(col, pow(col0,vec3(1.2)), smoothstep(.0,.01, zend + end ));    \n        col = mix(col, vec3(0),.2*smoothstep(.02,.0, abs(zend + end)+.005 ));    \n        // todo specularity\n        if (zend < -.2) {\n            nor = doBumpMap(iChannel2, .3*uvw, nor, .0005);\n            kspe = 2.;\n        } else {\n            kspe = .5;\n        }\n    }\n    \n#ifdef WITH_AO\n    float occ = occlusion( pos, nor );\n    occ = occ*.5 + .5*occ*occ;\n#else\n    float occ = 1.f;\n#endif\n    vec3  ref = reflect(rd,nor);\n    float dif = max( dot( light, nor ), 0.), // Diffuse term.\n    \t  spe = pow(max(dot( reflect(-light, nor), -rd ), 0.), 29.), // Specular term.\n    \t  fre = clamp(1. + dot(rd, nor), 0., 1.); \n    float Schlick = pow( 1. - max(dot(rd, normalize(rd + light)), 0.), 5.);\n    float fre2 = mix(.2, 1., Schlick);\n    // Overal global ambience.\n    float amb = .6*fre*fre2 + .2*occ;\n    float h = dot(pos,vec3(127.1,311.7,758.5453123));\t\n    return (col*(dif + .1) + fre2*spe*kspe)*occ + amb*col;\n}    \n\n// Render scene using raytracing (to save gpu)\nvec4 ShowScene (vec3 ro, vec3 rd, vec3 backColor) {\n    // Intersection with ground\n    float dMin = -ro.y/rd.y;\n    idBall = -2;\n    vnBall = vec3(0,1,0);        \n    // Intersection with pencils\n    float d = PencilHit(ro, rd, dMin);\n    // Shading\n    return vec4(shade(rd, ro + d*rd, vnBall, idBall, d), d);\n}\n\n\n// Create camera base matrix\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n    cr = .1*cos(.11*iTime);\n\tvec3 w = normalize(ta-ro),\n\t \t p = vec3(0., cos(cr), -sin(cr)),\n         u = normalize( cross(w,p) ),\n         v = normalize( cross(u,w) );\n    return mat3(u,v,w);\n}\n\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord) {\n    vnBall=vec3(0,1,0);\n    idBall=-1;;\n\n\n    // Normalize pixels\n    vec2 canvas = iResolution.xy,\n         uv = 2. * fragCoord.xy/canvas - 1.;\n    uv.x *= canvas.x / canvas.y;\n    \n\t// Camera      \n    float gAnim = mod(iTime,35.);\n\n    // Distance\n    float camDist;\n    camDist = mix(3.5,4.5, smoothstep(9.,11.,gAnim));\n    camDist = mix(camDist,6., smoothstep(17.,23.,gAnim));\n    camDist = mix(camDist,3.5, smoothstep(34.,35.,gAnim));\n    \n    // Target\n    vec3 ta = vec3(-.25,.2,.5);\n    \n    // Camera position\n    vec3 a = mix(vec3(cos(.5*iTime), .6, sin(.5*iTime)), vec3(1,.5,1), smoothstep(1.,0.,iTime)); \n    vec3 ro = ta + mix(5.,mix(10.,20.,smoothstep(30.,60.,iTime)),.75+.5*sin(-1.5+.1*iTime))*a;\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 1.);\n    \n    // current ray direction\n    vec3 rd = ca * normalize( vec3(uv.xy, 4.5) );\n\n    // Background color\n    vec2 q = fragCoord.xy/canvas;\n    float h = dot(vec3(q,1.),vec3(127.1,311.7,758.5453123));\t\n\tvec3 backColor = vec3(.2) + .05*fract(sin(h)*43758.5453123);\n    \n    // Render scene (xyz = color, w = distance)\n    vec4 result = ShowScene (ro, rd, backColor);\n    \n    // Post traitment\n   \tvec3 col = pow(1.2*result.xyz,vec3(.6));\n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .5);\n        \n    fragColor = vec4(col, result.w);\n}\n\n\n\n\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  mainLoop( fragColor, fragCoord, iChannel0, iFrame, iTimeDelta*.4);\n}", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.141592653589\n\n#define NB_BODY 300\n\n#define NB_STEP 5.\n#define DT0 .006\n#define DT (DT0/NB_STEP)\n\n\n#define DENSITY_WOOD    350. // wood   kg/m³\n#define DENSITY_WOOD2   700. // wood   kg/m³  // little hack for big DT\n#define DENSITY_WATER   997. // water  kg/m³\n#define DENSITY_MARBLE 2650. // marble kg/m³\n#define DENSITY_STEEL  7860. // acier  kg/m³\n\n\n#define SPHERE 0.\n#define CAPS   1.\n\n#define SIZEOF_BODY 6\n\n\n#define txRow 256\n\n\n#define fAccel_MpS   -9.81   // meter per seconds\n\n#define FLOOR_RESTITUTION_COEFF   .2\n#define PENCIL_RESTITUTION_COEFF  .5\n\n// Friction\n// https://en.m.wikipedia.org/wiki/Friction\n#define staticFrictionPencil  .25   // must be > dynamic  \n#define dynamicFrictionPencil .2 \n\n#define staticFrictionFloor  .35   // must be > dynamic\n#define dynamicFrictionFloor .32  \n\n#define MAX_IMPULSE 1000.\n#define MAX_VEL 100.\n#define MAX_AVEL 100.\n\n\nfloat hash(float h) {\n    return fract(sin(h)*43758.5453123);\n}\n\n\n// project vector on plane\nvec3 projVecOnPlane(vec3 u, vec3 n) {\n    return u - dot(u,n)*n;\n}\n\n// project point on plane\nvec3 projPtOnPlane(vec3 p, vec3 pPlane, vec3 nPlane) {\n    return pPlane + projVecOnPlane(p-pPlane, nPlane) ;\n}\n\n// add thickness\nbool removeThickness(float e0, float e1, inout vec3 out0, inout vec3 out1, inout vec3 n) {\n    float d = length(out0 - out1);\n    n = normalize(out1 - out0);\n    out0 += e0*n;\n    out1 -= e1*n;\n    return d < e0+e1;\n}\n\n\n//---------------------------------------------------------\n// Find the closest points between two segments\n//---------------------------------------------------------\nvoid closestSegmentSegment(vec3 p00, vec3 p01, vec3 p10, vec3 p11, inout vec3 inout0, inout vec3 inout1) {\n    vec3   u = p01 - p00, v = p11 - p10, w = p00 - p10;\n    float  a = dot(u,u), b = dot(u,v), c = dot(v,v),\n           k0, k1, k = a*c - b*b;\n    if (k < 1e-6) { \n        // the lines are almost parallel\n        k0 = dot(u,p10-p00) / a;\n        k1 = dot(u,p11-p00) / a;\n             if (max(k1,k0)<0.) { inout0 = p00; inout1 = k1>k0 ? p11 : p10;}\n        else if (min(k1,k0)>1.) { inout0 = p01; inout1 = k1>k0 ? p10 : p11;}\n        else { inout0 = p00 + u * clamp(k1, 0., 1.);\n               inout1 = inout0 + (p10 - (p00 + k0*u)); \n        }\n        return;\n    } else {\n        float e = dot(v,w), d = dot(u,w); \n        k0 = b*e - c*d;\n        k1 = k0 > k ? (e+b)/c : k0 < 0. ? e/c : (a*e - b*d)/k;\n        k0 = k1 < 0. ? -d/a : k1 > 1. ? (b-d)/a : clamp(k0/k, 0., 1.);\n    }\n    inout0 = p00 + u * clamp(k0, 0., 1.);\n    inout1 = p10 + v * clamp(k1, 0., 1.);\n}\n\n//---------------------------------------------------------\n// Find the closest points between two caps\n//---------------------------------------------------------\n\nbool closestCapsCaps(vec3 p00, vec3 p01, float e0, vec3 p10, vec3 p11, float e1, inout vec3 inout0, inout vec3 inout1, inout vec3 n) {\n    closestSegmentSegment(p00, p01, p10, p11, inout0, inout1);\n    return removeThickness(e0, e1, inout0, inout1, n);\n}\n\nbool closestCapsPlane(vec3 p1Line, vec3 p2Line, float ep, vec3 pPlane0, vec3 nPlane, inout vec3 out0, inout vec3 out1, inout vec3 n) {\n //   closestSegmentPlane(p1Line, p2Line, pPlane-nPlane*10., nPlane, out0, out1);\n    vec3 rd = normalize(p2Line - p1Line),\n         pdk, pPlane = pPlane0 - nPlane*10.;\n    float a = dot(rd, nPlane),\n          d = -(dot(p1Line, nPlane)-dot(nPlane,pPlane))/a;\n    // Just project sommets of line on plane and select the closest\n    vec3 p1OnPlane = projPtOnPlane(p1Line, pPlane, nPlane),\n         p2OnPlane = projPtOnPlane(p2Line, pPlane, nPlane);   \n    if (distance(p1Line, p1OnPlane) < 10. && distance(p2Line, p2OnPlane) < 10.) {\n        out0 = (p1Line+p2Line)*.5;\n        out1 =projPtOnPlane(out0, pPlane, nPlane);\n    } else if (distance(p1Line, p1OnPlane) < distance(p2Line, p2OnPlane)) {\n        out0 = p1Line;\n        out1 = p1OnPlane;\n    } else {\n        out0 = p2Line;\n        out1 = p2OnPlane;\n    }\n    return removeThickness(ep, 10., out0, out1, n);\n}\n\n//---------------------------------------------------------\n/*\nvec4 QuatMul(vec4 a, vec4 b) {\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n*/\n\nvec4 QuatMul (vec4 q1, vec4 q2) {\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 QuatFromVec3( vec3 vRot ) {\n    float l = length( vRot );\n    return l <= 0. ? vec4(0,0,0,1) : vec4(vRot * sin(l) / l, cos(l));\n}\n\n\n// PMalin\nmat3 QuatToMat3(vec4 q ) {\n\tvec4 s = q * q;\n\tfloat xy = q.x * q.y * 2.,\n          xz = q.x * q.z * 2.,\n          yz = q.y * q.z * 2.,\n          wx = q.w * q.x * 2.,\n          wy = q.w * q.y * 2.,\n          wz = q.w * q.z * 2.;\n\treturn mat3( \n\t\t s.w+s.x-s.y-s.z, xy-wz,           xz+wy,\n\t\t xy+wz,           s.w-s.x+s.y-s.z, yz-wx,\n\t\t xz-wy,           yz+wx,           s.w-s.x-s.y+s.z);\n}\n\n// r: m\n// h: m\n// density: kg/m³\nfloat massCaps(float r, float h, float density) {\n    float vcy = h*r*r*PI,        // volume cylinder m³\n          vhs = 4.*r*r*r*PI/3.;  // volume sphere m³\n    return (vhs + vcy) * density; // masse \n}\n\nfloat massSphere(float r, float density) {\n    float v = 4.*r*r*r*PI/3.;  // volume sphere m³\n    return v * density; // masse \n}\n\n// https://www.gamedev.net/tutorials/programming/math-and-physics/capsule-inertia-tensor-r3856/\nmat3 inverseInertiaTensorCaps(float r, float h, float density) {\n    float vcy = PI*h*r*r,       // volume cylinder\n          vhs = 4.*r*r*r*PI/3., // volume sphere\n          mcy = density*vcy, mhs = density*vhs; // masses des elements\n    float ix = mcy*(3.*r*r + h*h)/12. + mhs*(r*r*.4 + h*h*.25 + 3.*h*r/8.),\n          iz = mcy*r*r*.5             + mhs*(r*r*.4);\n\treturn mat3(1./ix,0,0, 0,1./ix,0, 0,0,1./iz);\n}\n\n// for sphere Rayon: meter, Density: kg/m³\nmat3 inverseInertiaTensorSphere(float r, float density) {\n    float v = 4.*r*r*r*PI/3.; // m³\n    float m = v*density;      // kg\n    float it = 5./(2.*m*r*r); \n\treturn mat3(it,0,0,  0,it,0, 0,0,it);\n}\n\n\n// --------------------------------------------------\n//                Load Save Datas\n// --------------------------------------------------\nvec4 Loadv4(sampler2D txBuf, int fi) {\n  return texelFetch(txBuf, ivec2(fi%txRow, fi/txRow),0);\n}\n\nvec3 Loadv3(sampler2D txBuf, int fi) {\n  return texelFetch(txBuf, ivec2(fi%txRow, fi/txRow),0).xyz;\n}\n\nvoid Savev4(int fi, vec4 val, inout vec4 fCol, vec2 fCoord) {\n  vec2 d = abs(fCoord - vec2(fi%txRow, fi/txRow) - .5);\n  if (max(d.x, d.y) < .5) fCol = val;\n}\n\nvoid Savev3(int fi, vec3 val, inout vec4 fCol, vec2 fCoord) {\n  vec2 d = abs(fCoord - vec2(fi%txRow, fi/txRow) - .5);\n  if (max(d.x, d.y) < .5) fCol = vec4(val,1);\n}\n\n\n// ---------------------------\n// Mecanic Body\n// PMalin - https://www.shadertoy.com/view/XdcGWS\n// ---------------------------\nstruct Body {\n    // Persistent State\n    vec3 vPos;\n    vec4 qRot;\n    vec3 vMomentum;\n    vec3 vAngularMomentum;\n    float h_2; // half length meter\n    float r;   // radius meter\n    float type;\n    float density; // km/m³\n  // Derived\n    mat3 mRot;\n    // Constant\n    mat3 invI;  // inverse inertia tensor 1./kg·m2\n    float invM; // 1/kg\n    // Per frame\n    vec3 vForce;\n    vec3 vTorque;\n};\n\n\nvoid finalizeBody(inout Body body) {\n\t// Calculate \n\tbody.mRot = QuatToMat3(body.qRot);\n    if (body.type == SPHERE) {\n        body.invM = 1./massSphere(body.r, body.density);\n        body.invI = inverseInertiaTensorSphere(body.r, body.density);\n    } else {\n        // fake r on intertia tensor gives better results!\n        body.invM = 1./massCaps(body.r, 2.*body.h_2, DENSITY_WOOD); \n        body.invI = inverseInertiaTensorCaps(2.*body.r, 2.*body.h_2, DENSITY_WOOD);\n    }\n    // invI in world coordinates\n    body.invI = transpose(body.mRot) * body.invI * body.mRot;\n}\n\nBody loadBody(sampler2D txBuf, int idBody) {\n    int p = idBody*SIZEOF_BODY;\n    Body body;\t\n    vec4 bSphere          = Loadv4(txBuf, p+0);\n    body.vPos             = bSphere.xyz;\n    body.qRot             = Loadv4(txBuf, p+1);\n    body.vMomentum        = Loadv3(txBuf, p+2);\n    body.vAngularMomentum = Loadv3(txBuf, p+3);\n    vec4 geom             = Loadv4(txBuf, p+4);\n    body.h_2 = geom.x;\n    body.r = geom.y;\n    body.type = geom.z;\n    body.density = DENSITY_WOOD;\n    finalizeBody(body);\n    return body;\n}\n\n\nvoid loadBodyPos(sampler2D txBuf, int idBody, inout vec3 pos1, inout vec3 pos2, inout float r) {\n    int p = idBody*SIZEOF_BODY;\n    vec4 pc = Loadv4(txBuf, p+0),\n         pe = Loadv4(txBuf, p+5);\n    r = pe.w;\n    pos1 = pe.xyz;\n    pos2 = 2.*pc.xyz - pos1;\n}\n\nvoid loadBSphere(sampler2D txBuf, int idBody, inout vec3 c, inout float r) {\n    vec4 pc = Loadv4(txBuf, idBody*SIZEOF_BODY);\n    r = pc.w;\n    c = pc.xyz;\n}\n\nvoid loadBodyPosFromC(sampler2D txBuf, int idBody, vec3 pc, inout vec3 pos1, inout vec3 pos2, inout float r) {\n    vec4 pe = Loadv4(txBuf, idBody*SIZEOF_BODY + 5);\n    r = pe.w;\n    pos1 = pe.xyz;\n    pos2 = 2.*pc.xyz - pos1;\n}\n\nvoid saveBody(int idBody, Body body, inout vec4 fc, in vec2 uv) {\n    int p = idBody*SIZEOF_BODY;\n    float rbSph = body.h_2 + body.r;\n    Savev4(p+0, vec4(body.vPos, rbSph),fc, uv);  // gives bounding sphere \n    Savev4(p+1, body.qRot,             fc, uv); \n    Savev3(p+2, body.vMomentum,        fc, uv);\n    Savev3(p+3, body.vAngularMomentum, fc, uv);\n    Savev4(p+4, vec4(body.h_2, body.r, body.type, body.density),  fc, uv);\n    Savev4(p+5, vec4(body.vPos + vec3(0,0,body.h_2)*body.mRot, body.r), fc, uv);\n}\n\n// Accessor\nvec3 getAngularVelocityWorld(Body body) {\n    return body.vAngularMomentum*body.invI;\n}\n\nvec3 BodyPointVelocity(Body body, vec3 vWorldPos ) {\n    vec3 vVel = body.vMomentum * body.invM;\n    vec3 vAngVel = getAngularVelocityWorld(body);\n    return vVel + cross(vAngVel, vWorldPos - body.vPos);\n}\n\nvec3 bodyPtToWorld(Body body, vec3 pt) {\n    return body.vPos + pt*body.mRot;       \n}\n\nvec3 worldPtToBody(Body body, vec3 pt) {\n    return body.mRot*(pt-body.vPos);       \n}\n\nvoid BodyIntegrate(inout Body body, float dt ) {\n    body.vMomentum += body.vForce * dt; \n    body.vAngularMomentum += body.vTorque*dt;\n    \n    vec3 vVel = body.vMomentum * body.invM;\n    vec3 vAngVel = getAngularVelocityWorld(body);\n    \n    if (length(vVel) > MAX_VEL) {\n        vVel = normalize(vVel)*MAX_VEL;\n    }\n    if (length(vAngVel) > MAX_AVEL) {\n        vAngVel = normalize(vAngVel)*MAX_AVEL;\n    }\n    body.vPos += vVel * dt;\n    vec4 qAngDelta = QuatFromVec3(vAngVel * dt);\n    body.qRot = normalize(QuatMul(qAngDelta, body.qRot));\n    body.mRot = QuatToMat3(body.qRot);  // update rot\n    body.vMomentum *= pow(.91,10.*DT);\n    body.vAngularMomentum *= pow(.93,10.*DT); \n}\n\nvoid BodyResetForFrame(inout Body body ) {\n    body.vForce = body.vTorque = vec3(0);\n}\n\nvoid BodyApplyForce(inout Body body, vec3 vPos, vec3 vForce) {    \n    body.vForce += vForce;\n    body.vTorque += cross(vPos - body.vPos, vForce);   \n}\n\nvoid BodyApplyImpulse(inout Body body, vec3 vPos, vec3 vImpulse) {    \n    body.vMomentum += vImpulse;\n    body.vAngularMomentum += cross(vPos - body.vPos, vImpulse);    \n}\n\n\nvec3 getCoulombFriction(Body body, vec3 vr, vec3 n, float jr, float sf, float df) {\n    vec3 t = vec3(0);\n    if (abs(dot(vr,n)) > 1e-4) {\n        t = normalize(projVecOnPlane(vr, n));\n    } else if (abs(dot(body.vForce,n)) > 1e-4) {\n        t = normalize(projVecOnPlane(body.vForce, n));\n    }\n    if (length(t) >0.) {\n        float js = sf * abs(jr),\n              jd = df * abs(jr), \n              jf = -jd;\n        if (abs(dot(vr,t)) < 1e-4 && dot(vr/body.invM,t) <= js) {\n            jf = -dot(vr/body.invM,t);\n        }\n        return t*min(jf, MAX_IMPULSE);\n    }\n    return vec3(0);\n}\n\n\n        \n        \n// https://en.m.wikipedia.org/wiki/Collision_response#\n#define VEPS 1e-3\nvoid mainLoop( inout vec4 fragColor, in vec2 fragCoord , sampler2D txBuf, int frameId, float dt) {\n    \n    vec2 iFrag = floor(fragCoord); \n    int bodyId = int((iFrag.y*256.) + iFrag.x)/SIZEOF_BODY;\n    \n    if (bodyId>NB_BODY) {\n        fragColor = vec4(0);\n\n    } else {\n    \n        Body body;\n\n        if (frameId < 30) {\n        // ------------------------------\n        // initialisation\n        // ------------------------------\n            body.vPos = vec3( .5+hash(43.6*float(bodyId)), 1.+mix(32.,6.,smoothstep(10.,40.,float(bodyId)))*float(bodyId), .5-hash(4.6*float(bodyId)) );\n            body.vMomentum = vec3( 0 );\n            body.qRot = normalize(vec4(hash(41.6*float(bodyId)),hash(1.27*float(bodyId)),hash(float(bodyId)), 1 ));\n            body.vAngularMomentum = vec3( .25, 3, .25 );  \n            body.h_2 = (.9+.45*cos(float(bodyId)));\n            body.r = .12;\n            body.type = CAPS;\n            body.density = DENSITY_WOOD;\n            finalizeBody(body);\n\n        } else {\n            body = loadBody(txBuf, bodyId);\n          \n            // The coefficient of restitution e       \n            float e = 0.5;\n            // normal at contact point\n  \n            for (float st=0.; st<NB_STEP; st++) { \n                 \n                BodyResetForFrame(body);\n                // Add gravity force\n                body.vForce.y += fAccel_MpS/body.invM;\n\n                vec3 p00 = bodyPtToWorld(body, vec3(0,0, body.h_2)),\n                     p01 = bodyPtToWorld(body, vec3(0,0,-body.h_2));\n                float r0 = body.h_2+body.r;\n                // contact with others\n                e = PENCIL_RESTITUTION_COEFF;\n                vec3 c = vec3(0);\n                vec3 p10 = vec3(0), p11 = vec3(0); \n                vec3 n = vec3(0,1,0), inout0 = vec3(0), inout1 = vec3(0);\n                float r = 0.;\n\n                for(int id = min(0,frameId); id<NB_BODY; id++) {\n                    if (id == bodyId) continue; // self\n\n                    loadBSphere(txBuf, id, c, r);\n                    if (distance(c,body.vPos) < r0+r) {\n\n                        loadBodyPosFromC(txBuf, id, c, p10, p11, r);\n        // ------------------------------\n        // contact with other pencils\n        // ------------------------------\n                        if (closestCapsCaps(p00, p01, body.r, p10, p11, r, inout0, inout1, n)) {\n                            // Intersection : on charge completement la shape \n                            Body body2 = loadBody(txBuf, id);\n                            //vec3 pContact = (inout0 + inout1) *.5;\n                            // Caps are in contact\n                            vec3 vp1 = BodyPointVelocity(body,  inout0),\n                                 vp2 = BodyPointVelocity(body2, inout1),\n                                 r1 = inout0 - body.vPos,  // offset of the shared contact point from the centre of mass\n                                 r2 = inout1 - body2.vPos, // offset of the shared contact point from the centre of mass\n                                 vr = vp1-vp2;\n                            float vrn = dot(vr,n);\n                            if (vrn < VEPS) { \n                               // moving away\n                            } else if (vrn < -VEPS) { \n                               // resting contact\n                            } else if (vrn > 0.) { \n                                // collision impulse magnitude jr\n                                float jr = -(1.+e)*vrn / \n                                           (body.invM + body2.invM + dot(\n                                               body .invI*cross(cross(r1,n),r1) + \n                                               body2.invI*cross(cross(r2,n),r2), n));\n                                vec3 impulse = max(jr, -MAX_IMPULSE)*n;\n                                BodyApplyImpulse(body, inout0, impulse); \n\n                                // Coulomb friction\n                                vec3 jft = getCoulombFriction(body, vr, n, jr, staticFrictionPencil, dynamicFrictionPencil);\n                                if (length(jft) > 0.) {\n                                    BodyApplyImpulse(body, inout0, jft);\n                                }\n                            }\n                            body.vPos -= .5*n*length(inout0-inout1);\n                        }\n                    }\n                }\n// ------------------------------\n// contact with ground\n// ------------------------------\n                // The coefficient of restitution e       \n                e = FLOOR_RESTITUTION_COEFF;\n                float maxPenetration = 0.;\n            \n                n = vec3(0, 1, 0);\n            \n                if (closestCapsPlane(p00, p01, body.r, vec3(0), n, inout0, inout1, n)) {\n                    vec3 vr = BodyPointVelocity(body, inout0),\n                         r1 = inout0 - body.vPos;\n                    float vrn = dot(vr,n);\n                    if(vrn > VEPS) { // if moving into the surface             \n                        float jr = -(1.+e)*vrn / \n                                   (body.invM + dot(body.invI*cross(cross(r1,n),r1), n));\n                        vec3 impulse = max(jr, -MAX_IMPULSE)*n;\n                        BodyApplyImpulse(body, inout0, impulse); \n\n                        // Coulomb friction\n                        vec3 jft = getCoulombFriction(body, vr, n, jr, staticFrictionFloor, dynamicFrictionFloor);\n                        if (length(jft) > 0.) {\n                            BodyApplyImpulse(body, inout0, jft);\n                        }\n                    }\n                    body.vPos -= n*length(inout0-inout1);\n                }\n\n                BodyIntegrate(body, DT); //min(dt,DT));\n            }\n\n        }\n        \n        saveBody(bodyId, body, fragColor, fragCoord);\n    }\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  mainLoop( fragColor, fragCoord , iChannel0, iFrame, iTimeDelta*.54);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  mainLoop( fragColor, fragCoord , iChannel0, iFrame, iTimeDelta*.4);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  mainLoop( fragColor, fragCoord , iChannel0, iFrame, iTimeDelta*.4);\n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXGRH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[954, 954, 991, 991, 1430], [1432, 1432, 1461, 1461, 1618], [2374, 2395, 2434, 2434, 2468], [2470, 2545, 2564, 2564, 2794], [2796, 2796, 2816, 2816, 2962], [2964, 2964, 2984, 2984, 3039], [3041, 3041, 3065, 3065, 3186], [3571, 3571, 3660, 3660, 4141], [4143, 4172, 4308, 4308, 4906], [4909, 4927, 4991, 4991, 5105], [5107, 5128, 5211, 5211, 6169], [6172, 6190, 6268, 6268, 6441], [6443, 6443, 6487, 6487, 6851], [6853, 6853, 6903, 6903, 7442], [7560, 7616, 7683, 7683, 7726], [7728, 7728, 7751, 7751, 7827], [8047, 8201, 8251, 8251, 8397], [8399, 8414, 8436, 8436, 8480], [8482, 8564, 8637, 8637, 9052], [9054, 9054, 9131, 9148, 11210], [11216, 11263, 11314, 11346, 11576], [11579, 11608, 11659, 11659, 11854], [11857, 11857, 11910, 11910, 13243]]}
{"id": "flX3zH", "name": "2D physics engine", "author": "mdb", "description": "simple 2D physics engine with circles\n\ncould be upgrade with some kind of k-tree to check collisions faster", "tags": ["physicsengine"], "likes": 12, "viewed": 588, "published": 3, "date": "1621584833", "time_retrieved": "2024-07-30T19:19:35.943174", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv += 0.5;\n\n    vec3 col = vec3(0.1);\n    \n    col = vec3(0.1);\n    float touch = 0.0;;\n    vec3 col2 = vec3(0.0, 0.0, 0.5);\n    for(int i = 0; i < entity; i++){\n        vec4 ball = getData(i, iChannel0);\n        if (ballRadius*ballRadius*1.8 > dot(uv - ball.xy, uv - ball.xy)) {\n            touch += 1.0;\n            col2.xy = mix(col2.xy, 1.0/(1.0 + exp(-ball.zw)), 1.0/touch);\n        }\n    }\n    if(touch != 0.0){\n        col = col2;\n    }\n    \n\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define highp float\n\n// from https://gamedevelopment.tutsplus.com/tutorials/how-to-create-a-custom-2d-physics-engine-the-basics-and-impulse-resolution--gamedev-6331\nstruct Circle\n{\n  vec2 position;\n  vec2 velocity;\n};\n\nbool intersect(Circle A, Circle B){\n    return dot(A.position - B.position, A.position - B.position) <= 4.0*ballRadius*ballRadius;\n}\n\nvoid ResolveCollision(inout Circle A, Circle B, vec2 normal, bool wall)\n{\n  // Calculate relative velocity\n  vec2 rv = B.velocity - A.velocity;\n \n  // Calculate relative velocity in terms of the normal direction\n  float velAlongNormal = dot(rv, normal);\n \n  // Do not resolve if velocities are separating\n  if(velAlongNormal > 0.0)\n    return;\n \n  // Calculate impulse scalar\n  float j = - 0.5 * (1.0 +  restitution) * velAlongNormal;\n  \n  if(wall) j *= 2.0;\n  \n  // Apply impulse\n  A.velocity -= j * normal;\n  return;\n}\n\nvoid PositionalCorrection(inout Circle A, Circle B, vec2 normal, float penetrationDepth, bool wall)\n{\n  const float percent = 0.1;\n  vec2 correction = 0.5 * penetrationDepth * percent * normal;\n  if(wall) correction *= 2.0;\n  \n  A.position -= correction;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int idx = int(fragCoord.x) + int(fragCoord.y)*int(texDimX);\n    if( idx >= entity || fragCoord.x >= float(texDimX)){\n        fragColor = vec4(0.0);\n        return;\n    }\n    if( iFrame < 6 ){\n        float y;\n        float x = 0.1 + modf(float(idx)*0.03, y)*0.8;\n        fragColor = vec4(x, 0.2 + y*0.025, 0.0, -0.9);\n        return;    \n    }\n    vec4 a = getData(idx, iChannel0);\n    Circle A = Circle(a.xy, a.zw);\n    \n    for(int i = 0; i < entity; i++){\n        if(i != idx){\n            vec4 raw = getData(i, iChannel0);\n            Circle B = Circle(raw.xy, raw.zw);\n            if(intersect(A, B)){\n                vec2 normal = normalize(B.position - A.position);\n                ResolveCollision(A, B, normal, false);\n                \n                float depth = distance(A.position, B.position) - 2.0 * ballRadius;\n                PositionalCorrection(A, B, -normal, depth, false);\n                \n            }\n        }\n    }\n    \n    //collition with walls\n    Circle Bfake =  Circle(vec2(0.0), vec2(0.0));\n    \n    if(A.position.x + ballRadius >= 1.0){\n        ResolveCollision(A, Bfake, vec2(1.0, 0.0), true);\n        float depth = A.position.x + ballRadius - 1.0;\n        PositionalCorrection(A, Bfake, vec2(1.0, 0.0), depth, true);\n    }\n    if(A.position.x - ballRadius <= 0.0){\n        ResolveCollision(A, Bfake, vec2(-1.0, 0.0), true);\n        float depth = -(A.position.x - ballRadius);\n        PositionalCorrection(A, Bfake, vec2(-1.0, 0.0), depth, true);\n    }\n        \n    if(A.position.y + ballRadius >= 1.0){\n        ResolveCollision(A, Bfake, vec2(0.0, 1.0), true);\n        float depth = A.position.y + ballRadius - 1.0;\n        PositionalCorrection(A, Bfake, vec2(0.0, 1.0), depth, true);\n    }\n    if(A.position.y - ballRadius <= 0.0){\n        ResolveCollision(A, Bfake, vec2(0.0, -1.0), true);\n        float depth = -(A.position.y - ballRadius);\n        PositionalCorrection(A, Bfake, vec2(0.0, -1.0), depth, true);\n    }\n    \n    \n    \n    float dt = min(iTimeDelta, maxdt);\n    A.velocity += vec2(0.0, -gravity) * dt;\n    A.position += A.velocity * dt;\n    \n    if(mod(float(iFrame), 700.0)<=0.01)A.velocity = vec2(-(A.position.x - 0.5)*2.0, 3.0);\n    \n    \n    fragColor = vec4(A.position, A.velocity);\n}\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define entity 1632\n#define maxdt 0.002\n#define gravity 9.81\n\n#define ballRadius 0.01\n#define ballMass 0.8\n#define restitution 0.7\nconst float invMass = 1.0/ballMass;\n\n#define texDimX 420\nvec4 getData(int i, sampler2D tex){\n    ivec2 coord = ivec2(i % texDimX, i / texDimX);\n    return texelFetch(tex, coord, 0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flX3zH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 647]]}
{"id": "NtX3z4", "name": "大龙猫 - Quicky#053", "author": "totetmatt", "description": "Reading this iq article to extend my knowledge https://iquilezles.org/articles/fbm/fbm.htm\nUsed the fbm code and then this happend", "tags": ["fbm", "quicky"], "likes": 7, "viewed": 259, "published": 3, "date": "1621583149", "time_retrieved": "2024-07-30T19:19:36.703142", "image_code": "// Complete copy of https://iquilezles.org/articles/fbm\n// https://www.shadertoy.com/view/WsV3zz\nfloat gnoise( float nn ) \n{\n    int n = int(nn);\n    n = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\nfloat fbm( in float x, in float G )\n{    \n    x += 25.06;\n    float n = -.30;\n    float s = 1.20;\n    float a = 1.10;\n    float f = .50+sin(floor(iTime*8.)*6.66);    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\nvec3 pal(float t){return .5+.5*cos(6.2813*(1.*t+vec3(.0,.3,.7)));}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    uv*=2.;\n    \n    \n    vec3 d =vec3(0.);\n    const float lim=100.;\n  \n    for(float i =0.;i<=lim;i++){\n    uv*=rot(.1);\n    float f = fract(i/lim+iTime*.1);\n    float s = mix(12.,.1,f);\n    vec2 uuv = uv*s;\n    uuv.y = -abs(uuv.y);\n    float q = fbm(uuv.x+sin(i*3.33-gnoise(i/lim)*.4)*2.,.25-gnoise(i/lim)*.2);\n    d += pal(i/lim)*step(0.,1.-abs(uuv.y+3.)-q)*f;\n    }\n    d/=lim;\n    vec3 col = vec3(d);\n    col = mix(col,1.-col,sqrt(col)*1.5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtX3z4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 97, 124, 124, 290], [291, 291, 328, 328, 612], [613, 613, 631, 631, 679], [680, 680, 698, 698, 745], [746, 746, 801, 801, 1346]]}
{"id": "3ljfRK", "name": "Ulysses 31", "author": "xjorma", "description": "A tribute to my favorite TV-Show of all the time!\nIniatially I wanted to a more ambitious shader. But I lost the motivation to finish it, since it's sleeping on my private shader since a while I decide to release it as is.", "tags": ["31", "cineshader", "ulysses"], "likes": 11, "viewed": 6969, "published": 3, "date": "1621569620", "time_retrieved": "2024-07-30T19:19:37.636646", "image_code": "// Ulysses 31 by David \"Xjorma\" Gallardo 2021\n\n\n// Exported from Houdini\n\nconst int numVertices = 765;\n\nconst uint vertices[765] = uint[](\n  80367615U,    667647U,  40807423U, 294277119U, 373968895U, 373857279U, 406474751U, 388537343U, 388648959U, 598252543U, 518560767U, 573270015U,\n 707304447U, 642292735U, 692807679U, 859538431U, 931699711U, 856202239U,1018731519U, 946379775U, 996894719U, 420479999U, 370298879U, 431116287U,\n 627136511U, 605029375U, 605116415U,  95419392U,  95420415U,   4194303U,  80366592U,  80367615U,  95420415U, 138038272U, 138039295U,  80367615U,\n 124779520U, 124780543U, 138039295U, 210762752U, 210763775U, 124780543U, 210675712U, 210676735U, 210763775U, 175024128U, 175025151U, 210676735U,\n 210381824U, 210382847U, 175025151U, 177772544U, 177773567U, 210382847U,  40409088U,  40410111U, 177773567U,    666624U,    667647U,  40410111U,\n  40806400U,  40807423U,    667647U,   4106240U,   4107263U,  40807423U,   4193280U,   4194303U,   4107263U, 294648832U, 294649855U, 236978175U,\n 294276096U, 294277119U, 294649855U, 373967872U, 373968895U, 294277119U, 373856256U, 373857279U, 373968895U, 236492800U, 236493823U, 373857279U,\n 236977152U, 236978175U, 236493823U, 403700736U, 403701759U, 334495743U, 439241728U, 439242751U, 403701759U, 479198208U, 479199231U, 439242751U,\n 551549952U, 551550975U, 479199231U, 475822080U, 475823103U, 551550975U, 475679744U, 475680767U, 475823103U, 493505536U, 493506559U, 475680767U,\n 493393920U, 493394943U, 493506559U, 388536320U, 388537343U, 493394943U, 388647936U, 388648959U, 388537343U, 406473728U, 406474751U, 388648959U,\n 406616064U, 406617087U, 406474751U, 334494720U, 334495743U, 406617087U, 653261824U, 653262847U, 573571071U, 598568960U, 598569983U, 653262847U,\n 652960768U, 652961791U, 598569983U, 598251520U, 598252543U, 652961791U, 518559744U, 518560767U, 598252543U, 573268992U, 573270015U, 518560767U,\n 523071488U, 523072511U, 573270015U, 573570048U, 573571071U, 523072511U, 765459456U, 765460479U, 689963007U, 714960896U, 714961919U, 765460479U,\n 769352704U, 769353727U, 714961919U, 707303424U, 707304447U, 769353727U, 642291712U, 642292735U, 707304447U, 692806656U, 692807679U, 642292735U,\n 638414848U, 638415871U, 692807679U, 689961984U, 689963007U, 638415871U, 921697280U, 921698303U, 856686591U, 859632640U, 859633663U, 921698303U,\n 924644352U, 924645375U, 859633663U, 924549120U, 924550143U, 924645375U, 859537408U, 859538431U, 924550143U, 931698688U, 931699711U, 859538431U,\n 856201216U, 856202239U, 931699711U, 769391616U, 769392639U, 856202239U, 856685568U, 856686591U, 769392639U,1070595072U,1070596095U, 994050047U,\n1015902208U,1015903231U,1070596095U,1073439744U,1073440767U,1015903231U,1018730496U,1018731519U,1073440767U, 946378752U, 946379775U,1018731519U,\n 996893696U, 996894719U, 946379775U, 939356160U, 939357183U, 996894719U, 994049024U, 994050047U, 939357183U, 587686912U, 587687935U, 420964351U,\n 515104768U, 515105791U, 587687935U, 587202560U, 587203583U, 515105791U, 420478976U, 420479999U, 587203583U, 370297856U, 370298879U, 420479999U,\n 431115264U, 431116287U, 370298879U, 449926144U, 449927167U, 431116287U, 485577728U, 485578751U, 449927167U, 445898752U, 445899775U, 485578751U,\n 485871616U, 485872639U, 445899775U, 450220032U, 450221055U, 485872639U, 431290368U, 431291391U, 450221055U, 370472960U, 370473983U, 431291391U,\n 420963328U, 420964351U, 370473983U, 685204480U, 685205503U, 617048063U, 684807168U, 684808191U, 685205503U, 706827264U, 706828287U, 684808191U,\n 706740224U, 706741247U, 706828287U, 605028352U, 605029375U, 706741247U, 605115392U, 605116415U, 605029375U, 627135488U, 627136511U, 605116415U,\n 627421184U, 627422207U, 627136511U, 612694016U, 612695039U, 627422207U, 569702400U, 569703423U, 612695039U, 617047040U, 617048063U, 569703423U,\n 569702400U, 617047040U, 569703423U, 612694016U, 569702400U, 612695039U, 627421184U, 612694016U, 627422207U, 627135488U, 627421184U, 627136511U,\n 605115392U, 627135488U, 605116415U, 605028352U, 605115392U, 605029375U, 706740224U, 605028352U, 706741247U, 706827264U, 706740224U, 706828287U,\n 684807168U, 706827264U, 684808191U, 685204480U, 684807168U, 685205503U, 617047040U, 685204480U, 617048063U, 370472960U, 420963328U, 370473983U,\n 431290368U, 370472960U, 431291391U, 450220032U, 431290368U, 450221055U, 485871616U, 450220032U, 485872639U, 445898752U, 485871616U, 445899775U,\n 485577728U, 445898752U, 485578751U, 449926144U, 485577728U, 449927167U, 431115264U, 449926144U, 431116287U, 370297856U, 431115264U, 370298879U,\n 420478976U, 370297856U, 420479999U, 587202560U, 420478976U, 587203583U, 515104768U, 587202560U, 515105791U, 587686912U, 515104768U, 587687935U,\n 420963328U, 587686912U, 420964351U, 939356160U, 994049024U, 939357183U, 996893696U, 939356160U, 996894719U, 946378752U, 996893696U, 946379775U,\n1018730496U, 946378752U,1018731519U,1073439744U,1018730496U,1073440767U,1015902208U,1073439744U,1015903231U,1070595072U,1015902208U,1070596095U,\n 994049024U,1070595072U, 994050047U, 769391616U, 856685568U, 769392639U, 856201216U, 769391616U, 856202239U, 931698688U, 856201216U, 931699711U,\n 859537408U, 931698688U, 859538431U, 924549120U, 859537408U, 924550143U, 924644352U, 924549120U, 924645375U, 859632640U, 924644352U, 859633663U,\n 921697280U, 859632640U, 921698303U, 856685568U, 921697280U, 856686591U, 638414848U, 689961984U, 638415871U, 692806656U, 638414848U, 692807679U,\n 642291712U, 692806656U, 642292735U, 707303424U, 642291712U, 707304447U, 769352704U, 707303424U, 769353727U, 714960896U, 769352704U, 714961919U,\n 765459456U, 714960896U, 765460479U, 689961984U, 765459456U, 689963007U, 523071488U, 573570048U, 523072511U, 573268992U, 523071488U, 573270015U,\n 518559744U, 573268992U, 518560767U, 598251520U, 518559744U, 598252543U, 652960768U, 598251520U, 652961791U, 598568960U, 652960768U, 598569983U,\n 653261824U, 598568960U, 653262847U, 573570048U, 653261824U, 573571071U, 406616064U, 334494720U, 406617087U, 406473728U, 406616064U, 406474751U,\n 388647936U, 406473728U, 388648959U, 388536320U, 388647936U, 388537343U, 493393920U, 388536320U, 493394943U, 493505536U, 493393920U, 493506559U,\n 475679744U, 493505536U, 475680767U, 475822080U, 475679744U, 475823103U, 551549952U, 475822080U, 551550975U, 479198208U, 551549952U, 479199231U,\n 439241728U, 479198208U, 439242751U, 403700736U, 439241728U, 403701759U, 334494720U, 403700736U, 334495743U, 236492800U, 236977152U, 236493823U,\n 373856256U, 236492800U, 373857279U, 373967872U, 373856256U, 373968895U, 294276096U, 373967872U, 294277119U, 294648832U, 294276096U, 294649855U,\n 236977152U, 294648832U, 236978175U,   4106240U,   4193280U,   4107263U,  40806400U,   4106240U,  40807423U,    666624U,  40806400U,    667647U,\n  40409088U,    666624U,  40410111U, 177772544U,  40409088U, 177773567U, 210381824U, 177772544U, 210382847U, 175024128U, 210381824U, 175025151U,\n 210675712U, 175024128U, 210676735U, 210762752U, 210675712U, 210763775U, 124779520U, 210762752U, 124780543U, 138038272U, 124779520U, 138039295U,\n  80366592U, 138038272U,  80367615U,  95419392U,  80366592U,  95420415U,   4193280U,  95419392U,   4194303U, 617048063U, 627422207U, 569703423U,\n 569703423U, 627422207U, 612695039U, 617048063U, 685205503U, 627422207U, 685205503U, 684808191U, 627422207U, 684808191U, 627136511U, 627422207U,\n 684808191U, 706741247U, 605029375U, 684808191U, 706828287U, 706741247U, 684808191U, 605029375U, 627136511U, 420964351U, 431291391U, 370473983U,\n 420964351U, 450221055U, 431291391U, 420964351U, 587687935U, 485872639U, 420964351U, 485872639U, 450221055U, 587687935U, 515105791U, 485872639U,\n 515105791U, 485578751U, 445899775U, 515105791U, 587203583U, 485578751U, 587203583U, 420479999U, 485578751U, 515105791U, 445899775U, 485872639U,\n 485578751U, 420479999U, 449927167U, 420479999U, 431116287U, 449927167U, 994050047U,1015903231U, 939357183U, 939357183U,1015903231U, 996894719U,\n1015903231U,1073440767U, 996894719U, 996894719U,1073440767U,1018731519U, 994050047U,1070596095U,1015903231U, 856686591U, 859633663U, 769392639U,\n 769392639U, 859538431U, 856202239U, 769392639U, 859633663U, 859538431U, 859633663U, 924550143U, 859538431U, 859633663U, 924645375U, 924550143U,\n 856686591U, 921698303U, 859633663U, 689963007U, 714961919U, 638415871U, 638415871U, 714961919U, 692807679U, 714961919U, 769353727U, 692807679U,\n 692807679U, 769353727U, 707304447U, 689963007U, 765460479U, 714961919U, 573571071U, 598569983U, 523072511U, 523072511U, 598569983U, 573270015U,\n 573270015U, 598569983U, 652961791U, 573270015U, 652961791U, 598252543U, 573571071U, 653262847U, 598569983U, 334495743U, 403701759U, 406617087U,\n 403701759U, 439242751U, 406617087U, 439242751U, 475823103U, 406617087U, 406617087U, 475823103U, 475680767U, 439242751U, 479199231U, 475823103U,\n 479199231U, 551550975U, 475823103U, 475680767U, 493394943U, 406474751U, 475680767U, 493506559U, 493394943U, 475680767U, 406474751U, 406617087U,\n 493394943U, 388537343U, 406474751U, 236978175U, 294277119U, 236493823U, 236978175U, 294649855U, 294277119U, 294277119U, 373857279U, 236493823U,\n   4194303U,  40807423U,   4107263U,   4194303U,  95420415U,  40807423U,  95420415U,  80367615U,  40807423U,  80367615U,  40410111U,    667647U,\n  80367615U, 177773567U,  40410111U,  80367615U, 138039295U, 177773567U, 138039295U, 175025151U, 210382847U, 138039295U, 210382847U, 177773567U,\n 138039295U, 124780543U, 175025151U, 124780543U, 210763775U, 175025151U, 210763775U, 210676735U, 175025151U );\n\nvec3 getVertex( uint id )\n{\n\tuint d = vertices[id];\n\tvec3 v = vec3(ivec3(d >> 20, d >> 10, d)&1023) / 1023.0;\n    v.z *= -1.;\n\treturn v * vec3(4.4848484993, 2.0, 1.00000011921) + vec3(-2.24242424965, -1.0, -0.500000059605);\n}\n\nconst vec3 bboxSiz = vec3(2.24242424965, 1.0, 0.500000059605);\nconst vec3 bboxCtr = vec3(0.0, 0.0, 0.0);\n\nconst float pi = radians(180.);\nconst vec3 logoColor0 = vec3(255., 223., 0.) / 255.;\nconst vec3 logoColor1 = vec3(255., 102., 0.) / 255.;\n\n// https://iquilezles.org/articles/intersectors\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\n#define ZERO_NOLOOP min(0,iFrame)\n\nbool intersectMesh( in vec3 ro, in vec3 rd, in float tmax, out float oDis, out vec3 oNor)\n{\n    bool\tres = false;\n    float\ttmin = tmax;\n    for( int i = ZERO_NOLOOP; i < numVertices / 3; i++ )\n    {\n        // get the triangle        \n        vec3 v0 = getVertex(uint(i*3));\n        vec3 v1 = getVertex(uint(i*3 + 2));\n        vec3 v2 = getVertex(uint(i*3 + 1));\n\n        vec3 h = triIntersect( ro, rd, v0, v1, v2 );\n        if( h.x > 0. && h.x < tmin)\n        {\n            tmin = h.x;\n            oNor = normalize(cross(v1 - v0, v2 - v0));;\n            oDis = tmin;\n            res = true;\n        }\n    }\n    \n    return res;\n}\n\n// Star field by Del https://www.shadertoy.com/view/wsKXRK\nfloat vDrop(vec2 uv,float t)\n{\n    uv.x = uv.x*128.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.05;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.2 +.7;\t\t\t// speed\n    float trail = mix(55.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*pi)*(s*5.0);\n    float d2 = sin(dx*pi);\n    return yv*(d2*d2);\n}\n\nvec3 drawStarField(in vec2 uv)\n{\n    vec2 p = uv;\n    float d = length(p);\n\tp = vec2(atan(p.x, p.y) / pi, 2.5 / d);\n    float t =  iTime*0.4;\n    vec3 col = vec3(vDrop(p, t));\n\treturn col*(pow(d,1.5));\n}\n\n\nvec4 renderLogo(in vec3 ro, in vec3 rd)\n{\n    float d;\n    vec3  n;\n    if(intersectMesh( ro, rd, 20., d, n))\n    {\n        if(n.z > 0.5)\n            return vec4(logoColor0, 1);\n        return vec4(logoColor1, 1);;\n    }\n    return vec4(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float\ta = atan(p.y, p.x);\n    float\tl = length(p);\n    \n\tfloat\tv = smoothstep(0.1, 0.25, l) * smoothstep(2., 0.8, l) * pow(abs(sin(a)), 1.3);\n    vec3 col = vec3(v);\n    \n    vec3 rd = normalize(vec3(p ,1.5));\n    vec3 ro = vec3(0, 0, -4);\n    \n    col = drawStarField(p);\n    vec4 logo = renderLogo(ro, rd);    \n    col = mix(col, logo.rgb, logo.a);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 23872, "src": "https://soundcloud.com/david-gallardo-492062428/ulysses-31-full-intro-restored", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9386, 9386, 9413, 9413, 9611], [9858, 9906, 9987, 9987, 10346], [10383, 10383, 10474, 10474, 11014], [11016, 11075, 11105, 11105, 11553], [11555, 11555, 11587, 11587, 11758], [11761, 11761, 11802, 11802, 12003], [12006, 12006, 12063, 12063, 12537]]}
{"id": "stfGzn", "name": "Mermaid scales", "author": "stseagle", "description": "A fantasy shader inspired by the mermaid scale textures\n", "tags": ["2d", "fish", "fantasy", "scales", "mermaid"], "likes": 2, "viewed": 239, "published": 3, "date": "1621566419", "time_retrieved": "2024-07-30T19:19:38.392625", "image_code": "float random (vec2 st) {\n    // Book of Shaders pseudo-random\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// The shadows that give the scales the primary shape\nfloat fishScale (in vec2 _st) {\n    float _radius =1.15;\n    vec2 dist = (_st-vec2(0.5,1.0));\n    dist = vec2(dist.x, dist.y*0.55);\n\tfloat shadow = 1.- smoothstep(_radius-(_radius*0.03),\n                         _radius+(_radius*0.03),\n                         dot(dist,dist)*4.6509) + \n           smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.23),\n                         dot(dist,dist)*4.560);\\\n    \n    \n    return shadow;\n}\n\nfloat highlights (in vec2 _st, in vec2 fragCoord) {\n    float _radius =1.15;\n    vec2 dist = (_st-vec2(0.5,1.0));\n    dist = vec2(dist.x, dist.y*0.55);\n    float highlight = smoothstep(_radius-(_radius*0.1),\n                         _radius+(_radius*0.3),\n                         dot(dist,dist)*6.1960) - \n           smoothstep(_radius-(_radius*0.2),\n                         _radius+(_radius*0.2),\n                         dot(dist,dist)*4.9) ;\n    \n    \n    return 0.7 * highlight * (1. - _st.y);\n}\n\nfloat glitter(in vec2 _st, in vec2 fragCoord) {\n    _st *= 30.;\n    _st.x /= .55;\n    \n    float glitter = random(floor(_st + fragCoord));\n    \n    _st *= 0.95;\n    float drop = random(floor(_st + fragCoord + iTime));\n    \n    return glitter * glitter * glitter * drop;\n}\n\n// Make some of the scales a slightly different color\nvec4 colorMod(in vec2 _st, in vec2 _coords) \n{\n    vec3 forward = vec3(.8,0.65,0.4);\n    vec3 behind = vec3(0.3,0.3,0.6);\n    \n    float _radius =0.8;\n    vec2 dist = (_st-vec2(0.5,1.0));\n    dist = vec2(dist.x, dist.y*0.55);\n    \n    vec3 mod = mix(forward, behind, random(_coords));\n    float cutoff = 1.-step(_radius, dot(dist,dist)*3.3);\n    return vec4(mod, .4 * (1. - _st.y)*cutoff);\n     \n}\n\n\n// Either darken or lighten a channel. Use negative amt to darken\nfloat amp(float inChannel, float amt) {\n    return inChannel + amt*(1.- inChannel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scaleSize = 150.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/max(iResolution.y, iResolution.x);\n    uv.x*=0.55;\n\n    // Time varying pixel color\n    vec3 col = 0.45 + 0.4*cos(0.05*iTime+uv.xyx+vec3(4,2,0));\n    vec3 highlightCol = vec3(amp(col.r, 0.6), amp(col.g, 0.6), amp(col.b, 0.2));\n    \n    \n    // Overlay the fishscales\n    // brick tile formula from the Book of Shaders\n    vec2 st = uv * floor(iResolution.x/scaleSize);\n         st.x += step(1., mod(st.y,2.0)) * 0.5;\n    vec2 coords = floor(st); \n    st = fract(st);\n    \n    float highlightRipple = 0.75+ 0.25*sin(iTime + 6.28*(fragCoord.x + fragCoord.y));\n    \n    \n    col = mix(col,highlightCol, highlightRipple * highlights(st, uv));\n    col = mix(col,highlightCol, highlightRipple * glitter(st, uv));\n    col *= fishScale(st);\n    \n    vec4 cm = colorMod(st, coords);\n    \n    col = mix(col, cm.rgb, cm.a); \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfGzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 61, 168], [170, 224, 255, 255, 685], [687, 687, 738, 738, 1188], [1190, 1190, 1237, 1237, 1461], [1463, 1517, 1563, 1563, 1914], [1917, 1983, 2022, 2022, 2068], [2070, 2070, 2127, 2127, 3107]]}
{"id": "7lsGRH", "name": "extrusion", "author": "pugbyte", "description": "Using Buffer A to slowly decay color values from previous frames gives a neat 3D look. The effect is very sensitive to low or highly variable frame rates. But, tried my best to make the effect account for timing differences.", "tags": ["2d", "buffer", "kinda3d"], "likes": 3, "viewed": 291, "published": 3, "date": "1621563962", "time_retrieved": "2024-07-30T19:19:39.302193", "image_code": "//\n// Buffer A contains all the fun bits.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159\n#define TAU (2.*PI)\n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat rect(vec2 uv, vec2 size) {\n    float a = 1.-step(size.x, abs(uv.x));\n    float b = 1.-step(size.y, abs(uv.y));\n    return a * b;\n}\n\nfloat circle(vec2 uv, float radius) {\n    return 1.0-step(radius, length(uv));\n}\n\nfloat pipe(vec2 uv, float radius) {\n    float outer = 1.0-step(radius, length(uv));\n    float inner = 1.0-step(radius*0.2, length(uv));\n    return outer - inner;\n}\n\n// Trying to make the effect look the same regardless of framerate.\n// \n// When I tried to use iTimeDelta to compute the decay rate, the\n// rate ended up being too jittery and the effect didn't look smooth.\n// Maybe iTimeDelta's precision is just too low for what I want?\n// Maybe I have no idea what I'm doing...\n// \n// Instead, the frame rate is estimated using a rolling average\n// in Buffer B. Doing a simple (iFrame/iTime) will quickly settle\n// on a rate and then never change. However, say for example, going\n// fullscreen may result in significant frame rate drops on some\n// devices so the rolling average captures this better.\nfloat coefficientOfDecay() {\n    // This certainly is easier...\n    //float frame_rate = float(iFrame) / iTime;\n    \n    // Fetch computed frame rate from Buffer B\n    float frame_rate = texelFetch(iChannel1, ivec2(0), 0).x;\n    \n    // Works well for 144hz\n    //return 0.99;\n    \n    float d;\n    \n    if (iFrame < 1) {\n        // Avoid divide by zero.\n        d = 0.01;\n    } else {\n        // Compute decay based on what I thought looked good on a 144 hz monitor.\n        d = 144. / frame_rate * 0.01;\n    }\n    return 1.0 - clamp(d, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime-1.5;\n    vec3 col = vec3(.0);\n    \n    // Decay previous frame\n    col = texture(iChannel0, fragCoord / iResolution.xy).rgb * coefficientOfDecay();\n    \n    // Centered and aspect corrected\n    vec2 uv = (fragCoord - iResolution.xy*0.5) / iResolution.yy;\n    \n    // Move the whole world\n    vec2 uv_noise = vec2( simplex(vec2(t*.01, 0.0)), simplex(vec2(.0, t*0.01)) );\n    uv_noise -= 0.5;\n    uv_noise *= 1.4;\n    uv += mix(vec2(.0), uv_noise, sin(t)*0.5+0.5);\n    \n    // Rotate and scale the whole world\n    uv *= rot(t*0.5);\n    uv *= mix(3.0, 4.0, sin(t*0.5)*0.5+0.5);\n    \n    // Subdivide the world and recenter\n    uv = fract(uv);\n    uv -= 0.5;\n    \n    // More spin\n    uv *= rot(t);\n    \n    // Fixed size blue rect\n    //col = mix(col, vec3(0.2, sin(t)*0.2+0.5, 1.), rect(uv, vec2(0.1, 0.2)));\n    \n    // Pipe\n    float radius = mix(0.1, 0.45, sin(t*0.5)*0.5+0.5);\n    vec3 pipecolor = hsv2rgb(vec3(length(uv), .9, .9));\n    \n    col = mix(col, pipecolor, pipe(uv, radius));\n    \n    \n    // Candy cane stripes\n    #define offset(radius, phase) vec2(sin(t+phase), cos(t+phase))*radius\n    \n    uv *= rot(t*2.);\n    \n    vec3 stripecol = hsv2rgb(vec3(1.0-length(uv), .9, .9));\n    vec2 stripesize = vec2(mix(0.0, 0.02, pow(1.-radius / 0.45, 2.0) ));\n    \n    col = mix(col, stripecol, rect(uv+offset(radius, 0.),     stripesize));\n    col = mix(col, stripecol, rect(uv+offset(radius, PI*0.5), stripesize));\n    col = mix(col, stripecol, rect(uv+offset(radius, PI),     stripesize));\n    col = mix(col, stripecol, rect(uv+offset(radius, PI*1.5), stripesize));\n    col = mix(col, stripecol, rect(uv+offset(radius, PI*2.),  stripesize));\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Simplex Noise (http://en.wikipedia.org/wiki/Simplex_noise), a type of gradient noise\n// that uses N+1 vertices for random gradient interpolation instead of 2^N as in regular\n// latice based Gradient Noise.\n\n\n// Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n// Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n// Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n// Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n// Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n// Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n// Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n// Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n// Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n// Wave     Noise 2D             : https://www.shadertoy.com/view/tldSRj\n\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat simplex(vec2 uv) {\n    float f = 0.0;\n    \n    uv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    \n    return f;\n}", "buffer_b_code": "// This buffer estimates framerate with a rolling average.\n// The intention is for the gradient to be smooth even if\n// there is a fair amount of jitter in the real frame rate.\n// Jitter ruins this shaders decay effect.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int count = 60;\n\n    ivec2 c = ivec2(fragCoord);\n    \n    if (c == ivec2(0)){\n        // Compute the average frame time.\n        float sum = .0;\n        for (int i = 0; i < count; i++) {\n            sum += texelFetch(iChannel0, ivec2(i, 1), 0).x;\n        }\n        float avg = sum / float(count);\n        \n        // Store estimated frame rate.\n        if (avg <= 0.0) {\n            fragColor = vec4(144.);\n        } else {\n            fragColor = vec4(1.0 / avg);\n        }\n    } else if (c.y == 1 && c.x == iFrame % count) {\n        // Store the current frame time\n        fragColor = vec4(iTimeDelta);\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsGRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 153, 295]]}
{"id": "fslSRs", "name": "Tennis Ball Sections", "author": "oneshade", "description": "Tennis ball sections.", "tags": ["sphere", "intersection", "sections", "tennisball"], "likes": 10, "viewed": 136, "published": 3, "date": "1621561863", "time_retrieved": "2024-07-30T19:19:40.187825", "image_code": "// Settings\n#define AA 3.0 // Subsamples for antialiasing\n#define hc 0.5 // Curve slope\n#define rb 2.0 // Ball radius\n\n// Intersection info\nstruct Intersect {\n    float dist;\n    vec3 pos;\n    vec3 nor;\n};\n\n// Hyperbolic-parabola intersection\nvec3 iHyperParab(in vec3 ro, in vec3 rd, in float h) {\n    float a = rd.y * rd.y - rd.z * rd.z;\n    float b = h * rd.x + ro.y * rd.y - ro.z * rd.z;\n    float c = 2.0 * h * ro.x + ro.y * ro.y - ro.z * ro.z;\n    float discr = b * b - a * c;\n    if (discr < 0.0) return vec3(-1.0, -1.0, 0.0);\n    return vec3((vec2(-1.0, 1.0) * sqrt(discr) - b) / a, 2.0);\n}\n\n// Hyperbolic-parabola normal\nvec3 nHyperParab(in vec3 p, in float h) {\n    return normalize(vec3(h, p.y, -p.z));\n}\n\n// Hyperbolic-parabola implicit equation\nfloat hyperParabImplicit(in vec3 p, in float h) {\n    return 2.0 * h * p.x + p.y * p.y - p.z * p.z;\n}\n\n// Sphere intersection (rd must be normalized)\nvec3 iSphere(in vec3 ro, in vec3 rd, in float r) {\n    float b = dot(ro, rd), c = dot(ro, ro) - r * r;\n    float discr = b * b - c;\n    if (discr < 0.0) return vec3(-1.0, -1.0, 0.0);\n    return vec3(vec2(-1.0, 1.0) * sqrt(discr) - b, 2.0);\n}\n\n// Sphere normal\nvec3 nSphere(in vec3 p, in float r) {\n    return p / r;\n}\n\n// Sphere implicit equation\nfloat sphereImplicit(in vec3 p, in float r) {\n    return dot(p, p) - r * r;\n}\n\n// Map of half of the shape\nIntersect mapHalf(in vec3 ro, in vec3 rd) {\n    float t = -1.0;\n    vec3 tSphere = iSphere(ro, rd, rb), hitPos, n;\n    for (int i=0; i < int(tSphere[2]); i++) {\n        vec3 hitCandid = ro + rd * tSphere[i];\n        if (tSphere[i] > 0.0 && hyperParabImplicit(hitCandid, hc) > 0.0 && (t < 0.0 ? true : (tSphere[i] < t))) {\n            t = tSphere[i];\n            hitPos = hitCandid;\n            n = nSphere(hitPos, rb);\n        }\n    }\n\n    vec3 tCurve = iHyperParab(ro, rd, hc);\n    for (int i=0; i < int(tCurve[2]); i++) {\n        vec3 hitCandid = ro + rd * tCurve[i];\n        if (tCurve[i] > 0.0 && sphereImplicit(hitCandid, rb) < 0.0 && (t < 0.0 ? true : (tCurve[i] < t))) {\n            t = tCurve[i];\n            hitPos = hitCandid;\n            n = nHyperParab(hitPos, hc);\n        }\n    }\n\n    return Intersect(t, hitPos, n);\n}\n\n// Combined\nIntersect mapScene(in vec3 ro, in vec3 rd) {\n    float offs = 0.5 + 0.5 * sin(iTime);\n\n    Intersect h1 = mapHalf(vec3(ro.x - offs, ro.y, ro.z), rd);\n    Intersect h2 = mapHalf(vec3(-ro.x - offs, ro.z, ro.y), vec3(-rd.x, rd.z, rd.y));\n    h2.nor.yz = -h2.nor.zy;\n\n    Intersect whole = h1;\n    if (whole.dist < 0.0 && h2.dist > 0.0 ? true : (h2.dist < 0.0 ? false : (h2.dist < whole.dist))) whole = h2;\n    return whole;\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat noise(in vec3 p3) {\n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Tricubic noise interpolation\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p), local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);                       // Left, Down, Back\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = noise(cell + 1.0);                 // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x), mix(ldf, rdf, local.x), local.z),\n               mix(mix(lub, rub, local.x), mix(luf, ruf, local.x), local.z),\n               local.y);\n}\n\n// FBM\nfloat fnoise(in vec3 p, in float scale, in int octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int octave=0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvec4 render(in vec2 pixel) {\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 3.14;\n    vec2 uv = (pixel - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0, 0.25, 0.0);\n\n    vec3 ro = vec3(0.0, 0.0, 6.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Render the shape if hitting\n    Intersect scene = mapScene(ro, rd);\n    if (scene.dist > 0.0) {\n        float diff = abs(dot(scene.nor, -rd));\n        color = vec3(0.5, 1.0, 0.0) * (0.75 + 0.5 * fnoise(scene.pos, 5.0, 5));\n        color += 10.0 * max(0.0, 1.0 - max(max(hyperParabImplicit(scene.pos, hc), sphereImplicit(scene.pos, rb)) + 0.75, -sphereImplicit(scene.pos, rb + 0.15)));\n        color *= diff;\n    }\n\n    color = pow(color, vec3(0.75));\n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float aaStep = 1.0 / AA;\n    for (float xOffs=0.0; xOffs < 1.0; xOffs += aaStep) {\n        for (float yOffs=0.0; yOffs < 1.0; yOffs += aaStep) {\n            fragColor += render(fragCoord + vec2(xOffs, yOffs));\n        }\n    }\n\n    fragColor /= AA * AA;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslSRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 243, 297, 297, 597], [599, 629, 670, 670, 714], [716, 757, 806, 806, 858], [860, 907, 957, 957, 1148], [1150, 1167, 1204, 1204, 1224], [1226, 1254, 1299, 1299, 1331], [1333, 1361, 1404, 1404, 2193], [2195, 2207, 2251, 2251, 2629], [2631, 2721, 2746, 2746, 2850], [2852, 2884, 2909, 2909, 3746], [3748, 3755, 3812, 3812, 4094], [4096, 4096, 4124, 4124, 5175], [5177, 5177, 5232, 5232, 5518]]}
{"id": "stl3z8", "name": "Exp - Checkerboard", "author": "Andrew314", "description": "checkerboard pattern", "tags": ["experiment"], "likes": 2, "viewed": 234, "published": 3, "date": "1621557603", "time_retrieved": "2024-07-30T19:19:41.151249", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // remove the trig funcs to get normal checkerboard\n    float k = sin(iTime)*10.;\n    float a = cos(iTime)*10.;\n    uv += vec2(cos(iTime), sin(iTime));\n    vec3 col = mix(vec3(0,0,0), vec3(1,1,1), step(1./a,mod(uv.x+ceil(uv.y*k)/k, 2./a)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stl3z8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 508]]}
{"id": "wlVyDm", "name": "Portal Experiment", "author": "oneshade", "description": "Another old shader I was working on. Raymarching portals is ridiculously tricky since the ray has to keep switching directions and marching right off the surface of portals=super_tiny_steps. Plus, if you write one faulty line of code the compiler crashes!", "tags": ["experiment", "portals", "noneuclidean", "teleport"], "likes": 10, "viewed": 228, "published": 3, "date": "1621555771", "time_retrieved": "2024-07-30T19:19:42.028902", "image_code": "struct PortalInfo {\n    bool isPortal;\n    vec3 inPosition;\n    vec3 outPosition;\n    vec2 portDirection; // Yaw, Pitch\n};\n\nstruct SurfInfo {\n    float dist;\n    vec3 color;\n    PortalInfo portalInfo;\n};\n\nfloat sdBox(vec3 p, vec3 b) {\n   vec3 q = abs(p) - b;\n   return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCapsule(in vec3 p, in float h, in float r) {\n    return length(vec3(p.x, max(0.0, abs(p.y) - h), p.z)) - r;\n}\n\nSurfInfo mapScene(in vec3 p) {\n    vec3 lp = p + vec3(4.0, 0.0, 0.0);\n    float surf1 = sdBox(lp, vec3(2.0, 0.1, 3.0)) - 0.1;\n\n    vec3 rp = p - vec3(4.0, 0.0, 0.0);\n    float surf2 = sdBox(rp, vec3(2.0, 0.1, 3.0)) - 0.1;\n\n    SurfInfo baseScene = SurfInfo(surf1, vec3(1.0, 0.0, 0.0), PortalInfo(false, vec3(0.0), vec3(0.0), vec2(0.0)));\n    if (surf2 < surf1) {\n        baseScene = SurfInfo(surf2, vec3(0.0, 0.0, 1.0), PortalInfo(false, vec3(0.0), vec3(0.0), vec2(0.0)));\n    }\n\n    lp.yz -= vec2(1.6, -2.0);\n    float portalFrame1 = sdBox(lp, vec3(1.0, 1.5, 0.1)) - 0.1;\n    float portal1 = sdBox(lp, vec3(0.8, 1.3, 0.21));\n    float port1 = min(portalFrame1, portal1);\n    if (port1 < baseScene.dist) {\n        baseScene = SurfInfo(port1, vec3(0.0, 0.0, 1.0), PortalInfo(portal1 < portalFrame1, vec3(-4.0, 1.6, 0.0), vec3( 4.0, 1.6, 0.0), vec2(0.0, 0.0)));\n    }\n\n    rp.yz -= vec2(1.6, -2.0);\n    float portalFrame2 = sdBox(rp, vec3(1.0, 1.5, 0.1)) - 0.1;\n    float portal2 = sdBox(rp, vec3(0.8, 1.3, 0.21));\n    float port2 = min(portalFrame2, portal2);\n    if (port2 < baseScene.dist) {\n        baseScene = SurfInfo(port2, vec3(1.0, 0.0, 0.0), PortalInfo(portal2 < portalFrame2, vec3( 4.0, 1.6, 0.0), vec3(-4.0, 1.6, 0.0), vec2(0.0, 0.0)));\n    }\n\n    return baseScene;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(mapScene(p + GRAD_STEP.xyy).dist - mapScene(p - GRAD_STEP.xyy).dist,\n                          mapScene(p + GRAD_STEP.yxy).dist - mapScene(p - GRAD_STEP.yxy).dist,\n                          mapScene(p + GRAD_STEP.yyx).dist - mapScene(p - GRAD_STEP.yyx).dist));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = getViewPosition();\n    mat3 cam = getCamera(getViewDirection());\n    vec3 rd = normalize(FOCAL_LENGTH * cam[2] + uv.x * cam[0] + uv.y * cam[1]);\n\n    bool travelling = true;\n    int teleports = 0;\n    float tt = 0.0;\n    while (travelling) {\n        float t = 0.0;\n        bool stopTravelling = true;\n        for (int i=0; i < MAX_ITERATIONS; i++) {\n            vec3 p = ro + rd * t;\n            SurfInfo d = mapScene(p);\n            if (d.dist < MIN_HIT_DISTANCE) {\n                vec3 n = getNormal(p);\n\n                if (d.portalInfo.isPortal) {\n                    mat3 portalMat = getOriMat(d.portalInfo.portDirection);\n\n                    ro = p - d.portalInfo.inPosition;\n                    ro = portalMat * ro;\n                    ro += d.portalInfo.outPosition;\n                    ro += n * 10000.0 * MIN_HIT_DISTANCE; // WHYYYYYYY???\n\n                    rd = portalMat * rd;\n\n                    teleports++;\n                }\n\n                stopTravelling = false;\n                if (!d.portalInfo.isPortal) {\n                    vec3 l = normalize(vec3(-1.0, 1.0, 1.0));\n\n                    fragColor.rgb += d.color;\n                    fragColor.rgb *= max(0.0, dot(n, l));\n\n                    vec3 fogColor = mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y); // Same as sky color\n                    fragColor.rgb = mix(fragColor.rgb, fogColor, 1.0 - exp(-tt * 0.15)); // Fog technique from Inigo Quilez's fog article (https://iquilezles.org/articles/fog)\n\n                    stopTravelling = true;\n                    break;\n                }\n            }\n\n            if (t > MAX_TRACE_DISTANCE || teleports > MAX_TELEPORTS) {\n                vec3 skyColor = mix(vec3(0.25, 0.25, 1.0), vec3(1.0), 0.5 + 0.5 * rd.y);\n                fragColor.rgb += skyColor;\n                stopTravelling = true;\n                break;\n            }\n\n            t += d.dist;\n            tt += d.dist;\n        }\n\n        travelling = !stopTravelling; // Doing this in the if statements causes my compiler to crash x_x\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Raymarching constants:\nconst vec3 GRAD_STEP = vec3(0.001, 0.0, 0.0);\n\nconst float MAX_TRACE_DISTANCE = 200.0;\nconst int MAX_TELEPORTS = 3;\n\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_ITERATIONS = 200;\n\nconst float FOCAL_LENGTH = 1.0;\n\n// Math constants:\nconst float TWO_PI = 6.2832;\nconst float PI = 3.1516;\n\n// Amount by which the camera moves and rotates:\nconst float STEP_SIZE = 0.1;\nconst float ROTATION_SPEED = 1.0;//0.5;\n\n// Addresses to viewing data:\nconst ivec2  VIEW_POSITION_ADDR = ivec2(0, 0);\nconst ivec2 VIEW_DIRECTION_ADDR = ivec2(1, 0);\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\nconst int    KEY_UP = 38;\nconst int  KEY_DOWN = 40;\nconst int KEY_RIGHT = 39;\nconst int  KEY_LEFT = 37;\n\n// Data fetching functions:\n#define  getViewPosition() texelFetch(iChannel0, VIEW_POSITION_ADDR, 0).xyz\n#define getViewDirection() texelFetch(iChannel0, VIEW_DIRECTION_ADDR, 0).xy\n\n#define     keyUpPressed() bool(texelFetch(iChannel1, ivec2(38, 0), 0).x)\n#define   keyDownPressed() bool(texelFetch(iChannel1, ivec2(40, 0), 0).x)\n#define  keyRightPressed() bool(texelFetch(iChannel1, ivec2(39, 0), 0).x)\n#define   keyLeftPressed() bool(texelFetch(iChannel1, ivec2(37, 0), 0).x)\n\n// Calculates camera axes:\nmat3 getCamera(in vec2 viewDirection) {\n    vec2 c = cos(viewDirection); vec2 s = sin(viewDirection);\n    return mat3(       c.x, 0.0,         s.x,  // Camera right axis (x)\n                s.x * -s.y, c.y, -c.x * -s.y,  // Camera up axis (y)\n                s.x *  c.y, s.y, -c.x *  c.y); // Camera forward axis (z)\n}\n\n// Calculates axes for yaw/pitch rotation:\nmat3 getOriMat(in vec2 ori) {\n    vec2 c = cos(ori); vec2 s = sin(ori);\n    return mat3(       c.x, 0.0,        s.x,  // Right axis (x)\n                 s.x * s.y, c.y, -c.x * s.y,  // Up axis (y)\n                -s.x * c.y, s.y,  c.x * c.y); // Forward axis (z)\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 address = ivec2(fragCoord);\n    if (iFrame == 0) {\n        if (address == VIEW_POSITION_ADDR) {\n            fragColor = vec4(4.5, 2.0, 1.0, 1.0);\n        }\n\n        if (address == VIEW_DIRECTION_ADDR) {\n            fragColor = vec4(-0.8, -0.1, 0.0, 1.0);\n        }\n    }\n\n    if (iFrame > 0) {\n        if (address == VIEW_POSITION_ADDR) {\n            fragColor = vec4(getViewPosition(), 1.0);\n            mat3 cam = getCamera(getViewDirection());\n            if (keyUpPressed()) {\n                fragColor.xyz += cam[2] * STEP_SIZE;\n            }\n\n            if (keyDownPressed()) {\n                fragColor.xyz -= cam[2] * STEP_SIZE;\n            }\n\n            if (keyRightPressed()) {\n                fragColor.xyz += cam[0] * STEP_SIZE;\n            }\n\n            if (keyLeftPressed()) {\n                fragColor.xyz -= cam[0] * STEP_SIZE;\n            }\n        }\n\n        if (address == VIEW_DIRECTION_ADDR) {\n            vec2 viewDirection = getViewDirection();\n            if (iMouse.z > 0.0) {\n                viewDirection = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TWO_PI * ROTATION_SPEED;\n            }\n\n            fragColor = vec4(viewDirection, 0.0, 1.0);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVyDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 234, 234, 327], [329, 329, 381, 381, 446], [448, 448, 478, 478, 1725], [1727, 1727, 1754, 1754, 2043], [2045, 2045, 2100, 2100, 4271]]}
{"id": "7lf3RH", "name": "raymarched particle system", "author": "maeln", "description": "this is a very simple implementation of a particle system using raymarching.\nThe whole idea is to make the position of each particle fully deterministic so that at each point of time, we know exactly where the particle should be.", "tags": ["raymarching", "particles", "particle"], "likes": 2, "viewed": 585, "published": 3, "date": "1621518030", "time_retrieved": "2024-07-30T19:19:42.818790", "image_code": "#define PI 3.1415\n#define MAXSTEPS 128\n#define MINDIST  0.0005\n#define MAXDIST  20.0\n#define saturate(x) (clamp(0.0, 1.0, x))\n\nstruct pLight {\n    vec3 position;\n    vec3 ambiant;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\n// Compute the position of particle {i} at the time {iTime}.\nvec3 calcPos(int i) {\n    float g = 8.91;\n    float period = 5.0;\n    float mTime = iTime+(float(i)*0.2);\n    \n    // we change the direction of the particle every {period} seconds.\n    float dv = floor(mTime/period+1.0);\n    \n    // Our \"random\" is deterministic so it will give us the same output\n    // if we give the same input, this how we can generate the same direction verctor\n    // for particle {i}\n    float dx = 0.5-random(vec2(i,i)*dv);\n    float dy = 0.5-random(vec2(i-1,i+1)*dv);\n    float dz = 0.5-random(vec2(i+1,i-1)*dv);\n    \n    vec3 dir = vec3(dx, dy, dz);\n    \n    // We skew the direction upward\n    dir += vec3(0.0, 1.0, 0.0);\n    \n    // We compute its position at time {iTime%period}\n    // We multiply direction {dir} by the {iTime} modulo {period} so that we reset the particle position every {period} seconds \n    vec3 p = (dir*3.0 + vec3(0.0,-g/10.0,0.0)*(mod(mTime,period))) * mod(mTime,period);\n    \n    return p;\n}\n\n// Draw all the particles\nvec2 scene(vec3 ray)\n{\n    float de = MAXDIST;\n    float m = 0.0;\n    for(int i=0; i<100; ++i) {\n        // if we just want the distance \n        // de = min(sphere(ray-calcPos(i), 0.1), de);\n        \n        // So that we can return the \"material id\"\n        // probably slower, but we can color each particle differently !\n        float di = sphere(ray-calcPos(i), 0.1);\n        if(di < de) {\n            de = di;\n            m = float(i);\n        }\n    }\n    \n    return vec2(de, m);\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0.0, MINDIST);\n\treturn normalize(vec3(\n    scene(pos + eps.yxx).x - scene(pos - eps.yxx).x,\n    scene(pos + eps.xyx).x - scene(pos - eps.xyx).x,\n    scene(pos + eps.xxy).x - scene(pos - eps.xxy).x));\n}\n\nvec2 raymarch(vec3 from, vec3 direction)\n{\n    float t = 1.0*MINDIST;\n    int i = 0;\n    float obj = -1.0;\n    for(int steps=0; steps<MAXSTEPS; ++steps)\n    {\n        ++i;\n        vec2 dist = scene(from + t * direction);\n        if(dist.x < MINDIST || t >= MAXDIST) break;\n        t += dist.x;\n        obj = dist.y;\n    }\n    \n    return vec2(t, t > MAXDIST ? -1.0 : obj);\n}\n\nvec3 material(vec2 c, vec3 hit, vec3 sky) {\n    vec3 color = sky;\n    float r = random(vec2(c.y,c.y));\n    float g = random(vec2(c.y-1.0,c.y+1.0));\n    float b = random(vec2(c.y+1.0,c.y-1.0));\n    return vec3(r,g,b);\n}\n\nvec3 phong(vec3 hit, vec3 eye, vec3 N, pLight light, float ks) {\n    vec3 L = normalize(light.position - hit);\n    vec3 V = normalize(eye - hit);\n    vec3 R = reflect(L, N);\n    vec3 ambiant = light.ambiant;\n    vec3 diffuse = max(dot(L,N), 0.0)*light.diffuse;\n    vec3 specular = pow(max(dot(R,V), 0.0), ks)*light.specular;\n    return ambiant + 0.5*(diffuse+specular);\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p);\n    return sqrt(max(0.0, dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pLight l1 = pLight(vec3(iTime-3.0, 2.0*sin(iTime), cos(iTime)*3.0),\n                       vec3(0.8), vec3(1.0, 0.0, 0.0), vec3(0.8, 0.0, 0.0));\n    \n   \tpLight l2 = pLight(vec3(iTime-3.0, -2.0, -3.0),\n                       vec3(0.3), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.8));\n    \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 target  = vec3(0.0, 0.0, 0.0);\n\tvec3 eye     = vec3(2.0, 2.0, 2.0);\n    vec3 up      = vec3(0.0, 1.0, 0.0);\n    \n    vec3 eyeDir   = normalize(target - eye);\n    vec3 eyeRight = normalize(cross(up, eye));\n    vec3 eyeUp    = normalize(cross(eye, eyeRight));\n    \n    vec3 rayDir = normalize(eyeRight * uv.x + eyeUp * uv.y + eyeDir);\n    \n    vec3 hi = vec3(255.0, 122.0, 122.0)/255.0;\n    vec3 lo = vec3(134.0, 22.0, 87.0)/255.0;\n    vec3 color = mix(lo, hi, fragCoord.y/iResolution.y);\n    vec3 sky = color;\n    vec2 c = raymarch(eye, rayDir);\n    vec3 hit = eye+c.x*rayDir;\n    vec3 norm = normal(hit);\n    \n    if(c.y>0.0) {\n        color = material(c, hit, color);\n        color = color * phong(hit, eye, norm, l1, 2.0);\n    }\n    \n    \n    // LOGO\n    // left-down circle\n    float d = sdCircle(uv + vec2(1.25, 0.5), 0.1);\n    color = mix(color, vec3(1.0), smoothstep(3.0/iResolution.y, 0.0, d));\n    \n    // left down arc\n    float ta = PI/2.0 * iTime*2.0;// 3.14*(0.5+0.5*cos(iTime*0.52+2.0));\n    float tb = PI/4.0 * (1.0-sin(iTime)/2.0); //3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n    d = sdArc(uv + vec2(1.25, 0.5),vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.2, 0.02);\n    color = mix(color, vec3(1.0), smoothstep(4.0/iResolution.y, 0.0, d));\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lf3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 248, 248, 355], [357, 357, 388, 388, 416], [1428, 1454, 1476, 1476, 1942], [1944, 1944, 1967, 1967, 2189], [2191, 2191, 2233, 2233, 2565], [2567, 2567, 2610, 2610, 2785], [2787, 2787, 2851, 2851, 3158], [3160, 3160, 3193, 3193, 3221], [3223, 3223, 3301, 3301, 3490], [3492, 3492, 3549, 3549, 5196]]}
{"id": "ftXGzH", "name": "rotate fanshaped", "author": "vanky", "description": "中心旋转", "tags": ["2d", "rotate", "sector"], "likes": 0, "viewed": 235, "published": 3, "date": "1621495874", "time_retrieved": "2024-07-30T19:19:43.576764", "image_code": "const float PI=3.141592653589793;\n\n\nconst vec2 center = vec2(0.5,0.5);\nconst vec4 lineColor = vec4(0.900,0.799,0.746,1.000);\nconst vec4 backgroundColor = vec4(0.568,0.665,0.265,1.000);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // 定时旋转\n    mat2 rotate=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n    \n    float delat=PI/20.;\n    \n    // 构建纹理中心点为原点的UV坐标\n    vec2 dist = center-uv;\n    // 二维旋转\n    dist=rotate * dist;\n    if (fract(atan(dist.y,dist.x)/ delat) < 0.180) {\n        fragColor = lineColor;\n    } else {\n       fragColor = backgroundColor;\n       // discard;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXGzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 243, 293, 736]]}
{"id": "NtX3zr", "name": "microbial life", "author": "pugbyte", "description": "Color is combined using only xor. You can enable a Conway's Game of Life version of microbes but I couldn't get it to look very good.", "tags": ["2d", "xor", "twotone"], "likes": 7, "viewed": 319, "published": 3, "date": "1621485837", "time_retrieved": "2024-07-30T19:19:44.456412", "image_code": "// Toggle primary effects\n#define CIRCLE_FILTER 1\n#define SPLIT_FILTER 1\n#define LENS_FILTER 0\n#define LENS_ANIMATE_DISTORTION 1\n\n// Display gradient showing lens distortion curve\n#define LENS_DEBUG 0\n\n// Lens zoom reveals basic dots darting around\n#define MICROBES_PARTICLE 1\n\n// Lens zoom reveals microbes found in Game of Life\n// Notes:\n//   1) it looks bad\n//   2) the seed is bad\n//   3) resizing window messes it up\n#define MICROBES_GAME_OF_LIFE 0\n\n// Displays raw Buffer A contents which contains the Game of Life simulation\n#define GAME_OF_LIFE_DEBUG 0\n\n#define PI 3.14159\n#define TAU (2.*PI)\n\nmat2 rot(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  \n  return mat2(c, s, -s, c);\n}\n\nfloat circle(vec2 uv, vec2 p, float r) {\n  return 1.0-step(r, length(uv - p));\n}\n\n// uv from 0 to 1\nint texel(vec2 uv) {\n    return int(step(0.5, texture(iChannel2, uv).x));\n}\n\nfloat screen_filter(vec2 uv, float t, float wiggle_displacement) {\n    vec2 filter_pos = vec2(sin(t*0.13), cos(t*0.13))*0.4;\n    float filter_radius = clamp(sin(t*0.1)*1.5, 0., 2.);\n    \n    float wiggle_amount = mix(0.0, wiggle_displacement, smoothstep(0.00, 0.07, filter_radius));\n    \n    return circle(uv, filter_pos, filter_radius+wiggle_amount);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\n    vec2 uv = (fragCoord - iResolution.xy*0.5) / iResolution.yy;\n    uv *= 1.0;\n    \n    // Test Game of Life\n#if GAME_OF_LIFE_DEBUG\n    uv = fragCoord / iResolution.xy;\n    fragColor = vec4(texture(iChannel2, uv).x,0.,0.,1.);\n    return;\n#endif\n    \n    // Rotation is sickening\n    //uv *= rot(mix(0.0, 0.3, sin(t*0.1)));\n    \n    // Softly zoom\n    uv *= mix(0.85, .7, sin(t*0.1));\n\n    // Color is set exclusively (pun intended) using xor.\n    int b = 1;\n    \n    vec2 p = vec2(sin(t*0.2), cos(t*0.2));\n    \n    //float lens_radius = 0.19;\n    float lens_radius = 0.4;\n    vec2 lens_pos = vec2(-0.1)+p*-0.2;\n    \n    int lens = int(circle(uv, lens_pos, lens_radius));\n    b ^= lens;\n    \n    // Outer ring\n    b ^= int(circle(uv, lens_pos, lens_radius+0.04));\n    \n    vec2 bp = vec2(sin(t), cos(t));\n    \n    if (lens > 0) {\n        // Coordinates centered around lens\n        vec2 cuv = uv - lens_pos;\n        \n        // Distance from edge: 0 on edge, 1 center\n        float dist = length(uv - lens_pos);\n        float nd = 1.0 - clamp(dist, 0., lens_radius)/lens_radius;\n        \n        float curve = 1.0 - pow(abs(nd-1.), 5.);\n\n#if LENS_ANIMATE_DISTORTION\n        // Animate the lens distortion\n        curve *= clamp(sin(t*0.5)*2.0+0.5, 0., 1.);\n#endif\n\n#if LENS_DEBUG\n        // Test lens curve\n        fragColor = vec4(0.,curve,0.,1.);\n        return;\n#endif\n        \n        cuv *= mix(1.0, 0.4, curve);\n        cuv += lens_pos;\n        \n        \n        b ^= int(circle(cuv, bp*0.21, texture(iChannel0, cuv).x ));\n        b ^= int(circle(cuv, bp*0.22, texture(iChannel0, cuv).y ));\n        \n#if MICROBES_GAME_OF_LIFE\n        // Microbes using Conway's Game of Life (not happy with it)\n        int microbe = texel(cuv / lens_radius * 0.5 + 0.5) * int(step(0.01, curve));\n        // Vary the percent of microbe texture that is visible based on curve.\n        // This prevents all microbes from popping into existance at once.\n        microbe *= int(step( 1.0-curve, mod(cuv, 0.0001) / 0.0001 ));\n        \n        b ^= microbe;\n#endif\n        \n#if MICROBES_PARTICLE\n        // Microbes using circles\n        for (int i = 0; i < 100; i ++) {\n            \n            // Slow down time for microbes\n            float mt = t * 0.003;\n            \n            float muvx = sin(mt+float(i)+203.);\n            float muvy = cos(mt+float(i));\n            \n            // Offset in the range -1 to 1\n            vec2 microbe_offset = vec2(\n                texture(iChannel1, vec2(muvx)).x,\n                texture(iChannel1, vec2(muvy)).y\n            ) * 2.0 - 1.0;\n            \n            // Stretch so they fill the lense\n            microbe_offset *= lens_radius;\n            \n            b ^= int(circle(cuv, lens_pos + microbe_offset, 0.001));\n        }\n#endif\n        \n    } else {\n        b ^= int(circle(uv, bp*0.21, texture(iChannel0, uv).x ));\n        b ^= int(circle(uv, bp*0.22, texture(iChannel0, uv).y ));\n    }\n    \n    float wiggle_displacement = texture(iChannel0, vec2(t*0.007,uv.y*0.1)).x*0.05;\n    \n#if LENS_FILTER\n    // Lens filter\n    float rt = clamp(sin(t*.1)*2.+0.5, 0., 1.);\n    float lens_filter_radius = lens_radius * rt;\n    b ^= int(circle(uv, lens_pos, lens_filter_radius));\n#endif\n\n#if CIRCLE_FILTER\n    //TODO: screen filter should expand white, then expand black, etc. never shrink\n    b ^= int(screen_filter(uv, t, wiggle_displacement));\n#endif\n\n#if SPLIT_FILTER\n    // Screen split filter\n    float split_offset = sin(t*0.2)*1.5;\n    b ^= int(step(split_offset+wiggle_displacement*1.5, uv.x));\n#endif\n\n    vec3 col = mix(vec3(0.9), vec3(0.1), float(b));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "int texel(vec2 pos) {\n    return int(step(0.5, texelFetch(iChannel0, ivec2(pos), 0).x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // This cell\n    int cell = texel(fragCoord + vec2(0, 0));\n    \n    int ms = int(floor(iTime * 1000.0));\n\n    if (iFrame == 0) {\n        // Initialize the microbes\n        float v = texture(iChannel1, uv).x;\n        fragColor = vec4(step(0.5, v),0.0,0.0,1.0);\n        return;\n    //} else if ((ms % 100) > 0) {\n    } else if (iFrame % 10 > 0) {\n        fragColor = vec4(cell,0.0,0.0,1.0);\n        return;\n    }\n    \n    // Check neighbors\n    int sum;\n    \n    sum += texel(fragCoord + vec2(-1, 1));\n    sum += texel(fragCoord + vec2(-1, 0));\n    sum += texel(fragCoord + vec2(-1, -1));\n    \n    sum += texel(fragCoord + vec2(0, 1));\n    //sum += cell;\n    sum += texel(fragCoord + vec2(0, -1));\n    \n    sum += texel(fragCoord + vec2(1, 1));\n    sum += texel(fragCoord + vec2(1, 0));\n    sum += texel(fragCoord + vec2(1, -1));\n    \n    int next;\n    \n    if (cell == 1 && sum < 2) {\n        next = 0;\n    } else if (cell == 1 && sum > 3) {\n        next = 0;\n    } else if (cell == 0 && sum == 3) {\n        next = 1;\n    } else {\n        next = cell;\n    }\n    \n    \n    fragColor = vec4(next,0.0,1.0,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtX3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[602, 602, 621, 621, 694], [696, 696, 736, 736, 776], [778, 796, 816, 816, 871], [873, 873, 939, 939, 1226], [1228, 1228, 1285, 1285, 4964]]}
{"id": "sts3Rr", "name": "Just testing buffers", "author": "mkellogg999", "description": "yup", "tags": ["derp"], "likes": 0, "viewed": 175, "published": 3, "date": "1621462943", "time_retrieved": "2024-07-30T19:19:45.476684", "image_code": "void mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec2 UV = fragCoord/iResolution.xy;\n\tfragColor = texture(iChannel0,UV);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,1.0, mod(iTime,1.),1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sts3Rr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 132]]}
{"id": "7dBXzd", "name": "Long Flowing Hair", "author": "Plento", "description": "Salon quality hair! Learned about the directional blur thing from here: https://www.shadertoy.com/view/4dlGDN", "tags": ["2d", "mouse", "hair"], "likes": 52, "viewed": 1318, "published": 3, "date": "1621450740", "time_retrieved": "2024-07-30T19:19:46.508924", "image_code": "\n// Cole Peterson\n\n\n// Image: Apply simple bump and lighting \n\nvec3 bump(vec2 uv, float strength){\n    float h = 0.001;\n    \n    vec3 p = texA(uv); \n    float dx = texA(uv).r - texA(uv + vec2(h, .0)).r;\n    float dy = texA(uv).r - texA(uv + vec2(0., h)).r;\n    \n    return normalize( vec3(0., 0., -1.) + vec3(dx, dy, 0.)*strength);\n}\n\n#define scl .9\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    vec3 lp = vec3(-0.22+cos(iTime)*.1, 0.2+sin(iTime)*.1, -1.0);\n    \n    if(iMouse.z>0.)\n        lp = vec3(m.x*.7, m.y*.7, -1.0);\n    \n    vec3 sp = vec3(uv, 0.0);\n    vec3 ro = vec3(0, 0, -1.0);\n    vec3 rd = normalize(sp - ro);\n    vec3 ld = lp - sp;\n    \n    float dist = max(length(ld), 0.001);\n    ld /= dist;\n    vec3 tex = texA((u/R)*scl);\n    \n    vec3 norm = bump((u/R)*scl, 15.);\n  \t\n    float dif = max(dot(norm, ld), 0.);  \n    float spec = pow(max(dot( reflect(-ld, norm), -rd), 0.), 16.); \n    \n    vec3 col = (tex*(dif + 0.3) + vec3(.5, .6, .7)*spec*.2);\n    \n    col = pow(col*1., vec3(3.));\n    col = 1. - exp(-col);\n    \n    f = vec4(col, 1.0); \n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Buffer A: Make the wavy noise with base color from a texture\n\n// Directional blur learned from here: https://www.shadertoy.com/view/4dlGDN\n\nvec2 hash22( vec2 x ){\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gdns(vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = smoothstep(0., 1., f);\n    \n    vec2 a = hash22(i);\n    vec2 b = hash22( i + vec2(1.,0.));\n    vec2 c = hash22( i + vec2(.0,1.));\n    vec2 d = hash22( i + vec2(1));\n    \n    \n    float nse = mix( mix( dot( a, f - vec2(0.0,0.0) ), \n                     dot( b, f - vec2(1.0,0.0) ), u.x),\n                mix( dot( c, f - vec2(0.0,1.0) ), \n                     dot( d, f - vec2(1) ), u.x), u.y);\n    return nse + 0.5;\n}\n\nfloat octnse(vec2 p, int oct){\n    float a = 1.;\n    float n = 0.;\n    \n    for(int i = 0; i < oct; i++){\n     \tn += gdns(p) * a;\t\n        p*=2.;\n        a *= .5;\n    }\n    \n    return n;\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    uv.y -= iTime*.1;\n\n    vec3 sum = vec3(0);\n    float n = 28., scl = 30., prd = 7., h = iTime*.4;\n    \n    for(float i = 0.; i < n; i++){\n        vec2 p = .01*vec2(cos(uv.y*prd + h), sin(uv.x*prd + h));\n        \n        float a = octnse(p * 4., 4)*25.;\n        vec3 nc = texA(uv).xyz;\n        vec2 v = vec2(cos(a), sin(a));\n        \n        sum += nc;\n        \n        uv += v*.0025;\n    }\n    \n    sum /= n;\n    \n    f = vec4(sum, 1.0);\n}\n\n", "buffer_a_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n  \n#define texA(p) texture(iChannel0,  p).xyz\n\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBXzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 98, 98, 333], [351, 351, 391, 391, 1105]]}
{"id": "fllGRr", "name": "animated tiling  2", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "tiling", "short"], "likes": 15, "viewed": 390, "published": 3, "date": "1621434684", "time_retrieved": "2024-07-30T19:19:47.425473", "image_code": "// variant of https://shadertoy.com/view/flsGzn\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,S,\n         U = 6.*u/R.y;\n\n    ivec2 I = ivec2(U); bool b = (I.x+I.y)%2 < 1;\n    U = 2.* fract( U ) - 1.;\n    \n    float h = 1.41*fract(iTime/2.+ .2*u.x/R.x),\n          c = 1., p = 9./R.y; \n    if (h>.707) U=U.yx, h=1.41-h;                          // 2nd half of the animation\n    \n    U *= mat2(cos( asin(h) + 1.57*vec4(0,1,-1,0) ));       // rotation\n    U = abs( U.x*U.y > 0. ? c=.5, U : vec2(-U.y,U.x) );    // 4-fold symmetry + c = checker coloring\n    if (b) c = 1.5-c;\n    \n    if (u.y < R.y/2.)                                      // draw contours\n        S =  smoothstep( 2.*p, 0., abs(U-h ) ),\n        O = vec4(   S.y\n                 +( U.y<h ? S.x : 0. )\n                );\n    else                                                   // draw regions\n        S =  smoothstep( p, -p, h-U ),\n        O =  vec4(       S.y * c\n                   + (1.-S.y)*S.x * (1.5-c)\n               //  + (1.-S.x)*(1.-S.y)* ( b ? .5 : 1. )*(h)\n                 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 1076]]}
{"id": "flsGzn", "name": "animated tiling ", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "tiling", "short"], "likes": 12, "viewed": 270, "published": 3, "date": "1621434473", "time_retrieved": "2024-07-30T19:19:48.268220", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,S,\n         U = 6.*u/R.y;\n\n    ivec2 I = ivec2(U); bool b = (I.x+I.y)%2 < 1;\n    U = 2.* fract( U ) - 1.;\n    \n    float h = 1.41*fract(iTime/2.),\n          c = 1., p = 9./R.y; \n    if (h>.707) U=U.yx, h=1.41-h;                          // 2nd half of the animation\n    \n    U *= mat2(cos( asin(h) + 1.57*vec4(0,1,-1,0) ));       // rotation\n    U = abs( U.x*U.y > 0. ? c=.5, U : vec2(-U.y,U.x) );    // 4-fold symmetry + c = checker coloring\n    if (b) c = 1.5-c;\n    \n    if (u.x < R.x/2.)                                      // draw contours\n        S =  smoothstep( 2.*p, 0., abs(U-h ) ),\n        O = vec4(   S.y\n                 +( U.y<h ? S.x : 0. )\n                );\n    else                                                   // draw regions\n        S =  smoothstep( p, -p, h-U ),\n        O =  vec4(       S.y * c\n                   + (1.-S.y)*S.x * (1.5-c)\n               //  + (1.-S.x)*(1.-S.y)* ( b ? .5 : 1. )*(h)\n                 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsGzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 1015]]}
{"id": "ftl3Rn", "name": "specular Ray-Marching", "author": "vjbob0", "description": "i practiced writing raymarching and diffuse/specular lighting. \nI dont know why i needed to do the mod in line 55 instead of the scene(), but this way it works.", "tags": ["raymarching", "specular"], "likes": 4, "viewed": 403, "published": 3, "date": "1621432328", "time_retrieved": "2024-07-30T19:19:49.116951", "image_code": "#define pi (acos(-1.))\n\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat tick(float t)\n{\n    t = smoothstep(0.,1.,t);\n    t = smoothstep(0.,1.,t);\n    t = smoothstep(0.,1.,t);\n    return t;\n}\n\nfloat noise(float a)\n{\n    return fract(sin(a*12.4312)*432.432423);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat scene(vec3 p)\n{\n    float fmode = (noise(floor(iTime/2.))*4.);\n    int mode = int(fmode);\n    float t = tick(fract(iTime/2.));\n    \n    \n    \n    \n    if (mode == 0)\n    p.xz = rotate(p.xz, t * pi /2.);\n    \n    if (mode == 1)\n    p.xz = rotate(p.xz, t * pi /-2.);\n    \n    if (mode == 2)\n    p.yx = rotate(p.yx, t * pi /-2.);\n    \n    if (mode == 3)\n    {\n        p.yx = rotate(p.yx, t * pi /2.);\n        p.xz = rotate(p.xz, t * pi /-2.);\n    }\n\n\n    return opSmoothSubtraction(sdOctahedron(p, 1.4),max(sdRoundBox(p, vec3(.8,.8,.8),.1),length(p)-1.2), .03);\n}\n\nvec3 getNormal(vec3 p)\n{\n\t//Sampling around the point\n\tvec2 o = vec2(0.01, 0.0);\n\tfloat d = scene(p);\n\tvec3 n = d - vec3(\n\t\t\t\t\tscene(p-o.xyy),\n\t\t\t\t\tscene(p-o.yxy),\n\t\t\t\t\tscene(p-o.yyx));\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 cam = vec3(0., 0, -3.);\n    vec3 dir = normalize(vec3(uv, 1));\n    vec3 lightPos = vec3(3., 3., -8.);\n    vec3 lightPos2 = vec3(-2, -3, -4.);\n    \n    float fmode = (noise(floor(iTime/2.))*5.);\n    int mode = int(fmode);\n    float tick = tick(fract(iTime/2.));\n    \n    \n    \n    \n    if (mode == 0)\n        cam.z += tick*20.;\n    \n    if (mode == 1)\n    {\n        cam.yx = rotate(cam.yx, tick*pi/2.);\n        dir.yx = rotate(dir.yx, tick*pi/2.);\n        lightPos.yx = rotate(lightPos.yx, tick*pi/2.);\n        lightPos2.yx = rotate(lightPos2.yx, tick*pi/2.);\n    }\n    if (mode == 2)\n    {\n        cam.xz = rotate(cam.xz, tick*pi/2.);\n        dir.xz = rotate(dir.xz, tick*pi/2.);\n        lightPos.xz = rotate(lightPos.xz, tick*pi/2.);\n        lightPos2.xz = rotate(lightPos2.xz, tick*pi/2.);\n    }\n    \n    if (mode == 3)\n    {\n        cam.xz = rotate(cam.xz, tick*pi/-2.);\n        dir.xz = rotate(dir.xz, tick*pi/-2.);\n        lightPos.xz = rotate(lightPos.xz, tick*pi/-2.);\n        lightPos2.xz = rotate(lightPos2.xz, tick*pi/-2.);\n    }\n    if (mode == 4)\n        cam.z += tick*-20.;\n    \n    \n    \n    float t = 0.;\n    float k = 0.;\n    int i;\n    vec3 p;\n    for(i; i<100; i++)\n    {\n        p = cam + dir * t;\n        p = mod(p, 4.)-2.;\n        k = scene(p);\n        t += k;\n        if(k < 0.001) break;\n    }\n    \n    vec3 h = cam + dir * t;\n    h = mod(h, 4.)-2.;\n    vec3 n = getNormal(h);\n    \n    //diffuse light\n    vec3 light = normalize(lightPos - h);\n    vec3 diffuse_color = vec3(0.784, 0.086, 0.792)*.7;\n    diffuse_color = dot(h, light) * diffuse_color;\n    \n    float shininess = 30.0;\n    float specular_intensity = pow(max(dot(n, light), 0.0), shininess);\n    vec3 specular_color = vec3( 0.941, 0.662, 0.498); // red\n    specular_color = specular_intensity * specular_color;\n    \n    vec3 light2 = normalize(lightPos2 - h);\n    vec3 diffuse_color2 = vec3(0.086, 0.749, 0.792);\n    diffuse_color2 = dot(h, light2) * diffuse_color2;\n    \n    float shininess2 = 100.0;\n    float specular_intensity2 = pow(max(dot(n, light2), 0.0), shininess2);\n    vec3 specular_color2 = vec3(0.133, 0.788, 0.737); // red\n    specular_color2 = specular_intensity2 * specular_color2;\n    \n    float fog = 1. - (float(i)/100.);\n\n    \n    fragColor.rgb = ((diffuse_color + specular_color) + (diffuse_color2 + specular_color2)/2.) * fog;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftl3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 54, 54, 177], [179, 179, 237, 237, 337], [339, 339, 360, 360, 463], [465, 465, 487, 487, 534], [536, 536, 581, 581, 672], [674, 674, 712, 712, 765], [767, 767, 788, 788, 1333], [1335, 1335, 1359, 1388, 1544]]}
{"id": "slX3zr", "name": "color histogram Gaussian approx", "author": "FabriceNeyret2", "description": "Display Gaussian approx of color histogram  ( i.e. mean col + covariant matrix = ellipsoid ).\n\ncan be used for normalizing colors before blending textures, cf https://www.shadertoy.com/view/XtjBDw  /  https://hal.inria.fr/hal-00765799", "tags": ["color", "filtering", "lod", "gpmipmap"], "likes": 10, "viewed": 381, "published": 3, "date": "1621421283", "time_retrieved": "2024-07-30T19:19:49.986626", "image_code": "// Fork of private \"color histogram: Gaussian approx\" https://shadertoy.com/view/7sBXWc\n\n#define rot(a) mat2( cos( a + vec4(0,11,33,0) ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 r = iResolution.xy,\n         U = u/r,\n         V = 2.*U - 1.;\n         \n    // accessing CubeMaps is such a pain !\n    vec3 cC[] = vec3[]( vec3( V.x,-V.y, 1), vec3( -V.x,-V.y, 1).zyx, vec3( V.x,V.y, 1).xzy ),\n         cM[] = vec3[]( vec3(  0 ,  0 , 1), vec3(   0 ,  0 , 1).zyx, vec3(  0 , 0 , 1).xzy ),\n         cS[] = vec3[]( vec3(  .5, .5, -1), vec3( -.5 , .5, -1).zyx, vec3( -.5, .5,-1).xzy ),\n         cT[] = vec3[]( vec3( -.5,-.5, -1), vec3(  .5 ,-.5, -1).zyx, vec3(  .5,-.5,-1).xzy );\n         \n    int i= int(iTime/2.)%3;                                 // alternate textures 0,1,2\n    vec4 C = texture   (iChannel0, cC[i]     ),             // texture\n         M = textureLod(iChannel0, cM[i], 10.),             // means.\n         S = textureLod(iChannel0, cS[i],  9.) - M*M,       // variances\n         T = textureLod(iChannel0, cT[i],  9.) - M*M.yzxw;  // covariances\n         \n    // covariant matrix.\n    // to get ellipsoid axes and radius, compute eigenvectors and eigenvalues of Q such that G = Q^t.Q = R^t.D².R\n    mat3 G = mat3( S.x,T.x,T.z,  T.x,S.y,T.y, T.z,T.y,S.z); \n\n    // Implicit display of the ellipsoid\n    G = inverse(4.*G);\n    O -= O;\n    vec2 m = iMouse.xy;\n    m = length(m)>10. ? 3.14*(2.*m/r-1.) : vec2(iTime);                // mouse control or auto-demo\n    for( float t=-1.5; t<1.5; t+= .01 ) {                              // ray-march in the RGB volume\n        vec3 X = 1.05*vec3( ( 2.*u-r)/r.y ,t ), A,S;                   // candidate voxel\n        X.xz *= rot( m.x);\n        X.xy *= rot(-m.y);\n        if ( dot(X,G*X) <= 1. && O.a==0.) O.rgb = M.rgb + .5*X, O.a++; // trace ellipsoid as quadratic form\n        A = abs(X), S = step( .02, abs(1. - A)  ); S*=S.yzx;\n        if ( max(S.x,max(S.y,S.z)) < 1. &&  max(A.x,max(A.y,A.z)) < 1. && O.a==0.) O.rgb = .5+.5*X, O.a++; // box\n    }\n    O += (1.-O.a) * C;\n     \n    O = pow( O, vec4(1./2.2) );                                        // convert to sRGB    \n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// color analysis of 3 textures in parallel ( for static textures, could be done just once ).\n// 3 axes = 3 texture.\n// face + : flat-space texture.  max LOD = order 1 statistics\n// face - :  maxLOD - 1 = order 2 statistics. corner (0,0): R²,G²,B²  corner(1,1): RG,GB,BR\n\n// attention: noise texture & fonts, set gamma = 1.\n// ( strange: blue noise let with gamma 2.2 is not an ellipsoid: sigma < 0. probably Half precision issue. )\n\n#define read(ch) pow( texture( ch, U ), vec4(2.2) ) // read texture and convert to flat color space\n\nvoid mainCubemap( out vec4 O,  vec2 U, vec3 c, vec3 D )\n{\n    U /= 1024.;\n    vec3 A = abs(D);\n    int i =  A.x > max(A.y,A.z) ? 0                 // 3 faces directions manage 3 textures\n           : A.y > max(A.x,A.z) ? 1                 // max LOD = order 1 statistics ( R,G,B means ).\n                                : 2;\n    if ( D[i] < 0. ) U *= 2.;                         \n    O =   i == 0 ? read(iChannel0)\n        : i == 1 ? read(iChannel1)\n                 : read(iChannel2);\n              \n    if ( D[i] < 0. )                                // anti-faces store order 2 statistics.\n        O *= max(U.x,U.y) < 1. ? O : O.gbra;        // corner (0,0): R²,G²,B²  corner(1,1): RG,GB,BR\n     \n  //if ( D[i] < 0. ) O = vec4(max(U.x,U.y) < 1.,  min(U.x,U.y)>1., 0,0); // to test correct mapping\n}", "cube_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slX3zr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "stfGzr", "name": "Reaction Diffusion labyrinth", "author": "lomateron", "description": "watched https://www.youtube.com/watch?v=ga1xt5zkmPI\nto port that here clamp() is also needed...took me sometime to figure that out\nthe shape is squared because the kernel has that shape...it's easy to make it not squared\ncode only uses blur convolutions", "tags": ["kernel"], "likes": 38, "viewed": 672, "published": 3, "date": "1621418323", "time_retrieved": "2024-07-30T19:19:50.738615", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,u);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    vec4 a = A(u+vec2(0,0));\n    float b = 0.;\n    \n    //kernel convolution that blurs\n    {\n        float z = 4.;//kernel convolution size\n        float t = z*2.+1.;\n              t = 1./(t*t-1.);\n        float blur = 1./z;\n        for(float i = -z; i<=z;++i){\n        for(float j = -z; j<=z;++j){\n          float s = 0.;\n          for(float i2 = -z; i2<=z;++i2){\n          for(float j2 = -z; j2<=z;++j2){\n          vec2 c = vec2(i2,j2)*blur;\n          s += 1./exp(dot(c,c));\n          }}\n          if(s==0.)s = 1.;\n          vec2 c = -vec2(i,j)*blur;\n          float d = A(u+vec2(i,j)).x;\n          b -= d/s/exp(dot(c,c))*9.;\n        }}\n    }\n    //kernel convolution that blurs a little bit less\n    {\n        float z = 4.;//kernel convolution size\n        float t = z*2.+1.;\n              t = 1./(t*t-1.);\n        float blur = 1.5/z;\n        for(float i = -z; i<=z;++i){\n        for(float j = -z; j<=z;++j){\n          float s = 0.;\n          for(float i2 = -z; i2<=z;++i2){\n          for(float j2 = -z; j2<=z;++j2){\n          vec2 c = vec2(i2,j2)*blur;\n          s += 1./exp(dot(c,c));\n          }}\n          if(s==0.)s = 1.;\n          vec2 c = -vec2(i,j)*blur;\n          float d = A(u+vec2(i,j)).x;\n          b += d/s/exp(dot(c,c))*9.8;\n        }}\n    }\n    b = clamp(b,0.,1.);\n    a = vec4(b,a.xyz);\n\n    if(iMouse.z>0.)\n    {\n        vec2 m1 = 2.*(u-iMouse.xy)/iResolution.y;\n        a *= 1.-+1./exp(pow(max(length(m1)-.1,0.),2.)*111.);\n    }\n    if(iFrame==0)\n    {\n        vec2 m1 = (2.*u-iResolution.xy)/iResolution.y+vec2(.2,0);\n        vec2 m2 = (2.*u-iResolution.xy)/iResolution.y-vec2(.2,0);\n        a += +1./exp(pow(max(length(m1)-.2,0.),2.)*5555.);\n        a += -1./exp(pow(max(length(m2)-.2,0.),2.)*5555.);\n    }\n    float keyA  = texture( iChannel1, vec2(65.5/256.,.25) ).x;\n    if(keyA!=0.)a = texture( iChannel2, u/iResolution.xy);\n    fragColor = a;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfGzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 136]]}
{"id": "7tf3zn", "name": "OpenSimplex2 Domain Warp Noise", "author": "KdotJPG", "description": "No longer do we need to warp each individual axis.\n\nTo use the ordinary noise value, take result.w (left)\nTo use the warping vector, take result.xyz (center)\nTo apply the warping vector, add it back onto the coordinate with some multiplier (right)", "tags": ["noise", "simplex", "opensimplex", "domainwarp"], "likes": 4, "viewed": 433, "published": 3, "date": "1621406436", "time_retrieved": "2024-07-30T19:19:51.767863", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1 on largest axis)\n    vec2 uv = fragCoord / max(iResolution.x, iResolution.y) * 24.0;\n    \n    // Input point\n    vec3 X = vec3(uv, mod(iTime, 578.0) * 0.8660254037844386);\n    \n    // Evaluate noise\n    vec4 noiseResult = openSimplex2_ImproveXYPlanes(X);\n    \n    vec3 col;\n    if (fragCoord.x < iResolution.x / 3.0)\n        col = noiseResult.www;\n    else if (fragCoord.x < iResolution.x * (2.0 / 3.0))\n        col = noiseResult.xyz;\n    else {\n        col = openSimplex2_ImproveXYPlanes(X * 0.75 + noiseResult.xyz * 0.375 + 32.).www;\n    }\n    col = col * 0.5 + 0.5;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "// CC0 license https://creativecommons.org/share-your-work/public-domain/cc0/\n\n/////////////// K.jpg's OpenSimplex2, domain-warping vector-output variant ///////////////\n////////////////////// Output: vec4(warpX, warpY, warpZ, fullValue) //////////////////////\n\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 257.0);\n}\n\n// Gradient set is a cuboctahedron\nvec3 grad(float hash) {\n    vec2 g2 = mod(trunc(hash * vec2(1.0, 0.5)), 2.0) - 0.5;\n    vec2 gMove = trunc(hash * 0.125 + vec2(0.0, 0.5)) * g2;\n    vec3 grad = vec3(g2, 0.0) + vec3(-1.0, 1.0, 0.0) * gMove.x + vec3(0.0, -1.0, 1.0) * gMove.y;\n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec4 openSimplex2_UnrotatedBase(vec3 X) {\n    \n    // First half-lattice, closest edge\n    vec3 v1 = round(X);\n    vec3 d1 = X - v1;\n    vec3 score1 = abs(d1);\n    vec3 dir1 = step(max(score1.yzx, score1.zxy), score1);\n    vec3 v2 = v1 + dir1 * sign(d1);\n    vec3 d2 = X - v2;\n    \n    // Second half-lattice, closest edge\n    vec3 X2 = X + 144.5;\n    vec3 v3 = round(X2);\n    vec3 d3 = X2 - v3;\n    vec3 score2 = abs(d3);\n    vec3 dir2 = step(max(score2.yzx, score2.zxy), score2);\n    vec3 v4 = v3 + dir2 * sign(d3);\n    vec3 d4 = X2 - v4;\n    \n    // Gradient hashes for the four points, two from each half-lattice\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0));\n    \n    hashes = mod(hashes, 289.0);\n    vec4 whashes = mod(hashes / 12.0, 12.0);\n    hashes = mod(hashes, 12.0);\n    \n    // Gradient extrapolations & kernel function\n    vec4 a = max(0.6 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    \n    vec3 og1 = grad(whashes.x); vec3 og2 = grad(whashes.y);\n    vec3 og3 = grad(whashes.z); vec3 og4 = grad(whashes.w);\n    \n    vec4 extrapolationsX = extrapolations * vec4(og1.x, og2.x, og3.x, og4.x);\n    vec4 extrapolationsY = extrapolations * vec4(og1.y, og2.y, og3.y, og4.y);\n    vec4 extrapolationsZ = extrapolations * vec4(og1.z, og2.z, og3.z, og4.z);\n    \n    // Return it all as a vec4\n    return vec4(dot(aaaa, extrapolationsX), dot(aaaa, extrapolationsY), dot(aaaa, extrapolationsZ), dot(aaaa, extrapolations))*vec4(32.69428253173828125*2.);\n}\n\n// Use this if X and Y are horizontal, and Z is vertical or time (or unused).\nvec4 openSimplex2_ImproveXYPlanes(vec3 X) {\n    \n    // Rotate so Z points down the main diagonal. Not a skew transform.\n    mat3 orthonormalMap = mat3(\n         0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187,  0.788675134594813, -0.577350269189626,\n         0.577350269189626,  0.577350269189626,  0.577350269189626);\n    \n    vec4 result = openSimplex2_UnrotatedBase(orthonormalMap * X);\n    return vec4(result.xyz * orthonormalMap, result.w);\n}\n\n// Use this if X and Z are horizontal, and Y is vertical or time (or unused).\nvec4 openSimplex2_ImproveXZPlanes(vec3 X) {\n    \n    // Rotate so Z points down the main diagonal. Not a skew transform.\n    mat3 orthonormalMap = mat3(\n         0.788675134594813, -0.577350269189626, -0.211324865405187,\n         0.577350269189626 , 0.577350269189626,  0.577350269189626,\n        -0.211324865405187, -0.577350269189626,  0.788675134594813);\n    \n    vec4 result = openSimplex2_UnrotatedBase(orthonormalMap * X);\n    return vec4(result.xyz * orthonormalMap, result.w);\n}\n\n// Use this if neither of the above make sense.\nvec4 openSimplex2_Classical(vec3 X) {\n    \n    // Rotate around the main diagonal. Not a skew transform.\n    vec4 result = openSimplex2_UnrotatedBase(dot(X, vec3(2.0/3.0)) - X);\n    return vec4(dot(result.xyz, vec3(2.0/3.0)) - result.xyz, result.w);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3zn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 126, 737]]}
{"id": "WlcfDj", "name": "2D Particle Sandbox", "author": "oneshade", "description": "An old shader I was working on.", "tags": ["2d", "simulation", "particles"], "likes": 19, "viewed": 570, "published": 3, "date": "1621398228", "time_retrieved": "2024-07-30T19:19:52.629560", "image_code": "float movingDisk(in vec2 p, in vec2 o, in float r, in vec2 v, in float Dt) {\n    vec2 p0 = p - o, p1 = v * Dt;\n\n    float a = dot(p1, p1);\n    float b = dot(p0, p1);\n    float c = dot(p0, p0) - r * r;\n\n    float h = b * b - a * c;\n    if (h > 0.0) {\n        vec2 t = clamp((vec2(-1.0, 1.0) * sqrt(h) - b) / a, 0.0, 1.0);\n        return t.y - t.x;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    // Draw particles\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    for (int id=0; id < PARTICLES; id++) {\n        Particle p = loadParticle(id);\n        vec3 color = mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), p.radius / 0.025);\n        fragColor.rgb += color * movingDisk(uv, p.pos, p.radius, p.vel, 1.0);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Settings\n#define PARTICLES 200\n\n#define GRAVITY 0.00001\n#define DECAY 0.8\n#define dt 1.0\n\n#define EPSILON 0.001\n\n// Utilities\nstruct Particle {\n    int id;\n    vec2 pos;\n    vec2 vel;\n    float mass;\n    float radius;\n};\n\n// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// Initialize\nvec4 initParticle(in ivec2 addr) {\n    if (addr.x < PARTICLES) {\n        float x = float(addr.x) + iDate.w;\n        if (addr.y == 0) return vec4(Hash12(x + 274.937) - 0.5, 0.0, 0.0);\n        if (addr.y == 1) return vec4((Hash12(x + 385.583) - 0.5) * 0.001, 0.0, 0.0);\n        if (addr.y == 2) return vec4(max(0.1, Hash11(x + 858.938) * 0.25), 0.0, 0.0, 0.0);\n        if (addr.y == 3) return vec4(max(0.01, Hash11(x + 374.497) * 0.025), 0.0, 0.0, 0.0);\n        return vec4(0.0);\n    }\n\n    return vec4(0.0);\n}\n\n// Load/store\n#define loadParticle(pid)                                \\\n    Particle(pid,                                        \\\n             texelFetch(iChannel0, ivec2(pid, 0), 0).xy, \\\n             texelFetch(iChannel0, ivec2(pid, 1), 0).xy, \\\n             texelFetch(iChannel0, ivec2(pid, 2), 0).x,  \\\n             texelFetch(iChannel0, ivec2(pid, 3), 0).x)  \\\n\nvec4 storeParticle(in Particle p, in ivec2 addr) {\n    if (addr.y == 0) return vec4(p.pos, 0.0, 0.0);\n    if (addr.y == 1) return vec4(p.vel, 0.0, 0.0);\n    if (addr.y == 2) return vec4(p.mass, 0.0, 0.0, 0.0);\n    if (addr.y == 3) return vec4(p.radius, 0.0, 0.0, 0.0);\n}", "buffer_a_code": "// Force particles to stay within boundaries\nvec2 constrain(in vec2 pos, in vec2 constraints, in float radius) {\n    constraints -= radius - EPSILON;\n    return clamp(pos, -constraints, constraints);\n}\n\nParticle updateParticle(in Particle p, in vec2 constraints) {\n    vec2 f = vec2(0.0); // Force vector (all forces get added into it)\n    f.y -= GRAVITY;\n\n    float t = iTime * 10.0;\n    f += vec2(cos(t), sin(t)) * 0.0001;\n\n    // Boundary collisions\n    if (abs(p.pos.x) > constraints.x - p.radius) {\n        p.vel.x *= -1.0;\n        p.vel *= DECAY;\n    }\n\n    if (abs(p.pos.y) > constraints.y - p.radius) {\n        p.vel.y *= -1.0;\n        p.vel *= DECAY;\n    }\n\n    // Particle-particle collisions\n    for (int id=0; id < PARTICLES; id++) {\n        if (id != p.id) {\n            Particle p2 = loadParticle(id);\n            vec2 dir = p.pos - p2.pos;\n            float dist = length(dir);\n            float rsum = p.radius + p2.radius;\n            if (dist < rsum) {\n                vec2 n = dir / dist;\n                p.pos -= n * (dist - rsum);\n                vec2 pn = n.yx * vec2(-1.0, 1.0);\n                p.vel = dot(p2.vel, n) * n + dot(p.vel, pn) * pn; // How to account different masses?\n            }\n        }\n    }\n\n    // Update\n    p.vel += f / p.mass * dt;\n    p.pos = constrain(p.pos + p.vel * dt, constraints, p.radius);\n\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 constraints = vec2(iResolution.x / iResolution.y * 0.5, 0.5);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) fragColor = initParticle(iFragCoord);\n    if (iFrame > 0) {\n        if (iFragCoord.x < PARTICLES && iFragCoord.y < 4) {\n            Particle p = loadParticle(iFragCoord.x);\n            p = updateParticle(p, constraints);\n            fragColor = storeParticle(p, iFragCoord);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlcfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 76, 76, 371], [373, 373, 428, 428, 851]]}
{"id": "7lf3Rn", "name": "Distance to Polyspline", "author": "oneshade", "description": "Distance to a polyspline constructed of many quadratic bezier curves.", "tags": ["2d", "sdf", "bezier", "spline", "distance"], "likes": 20, "viewed": 350, "published": 3, "date": "1621393844", "time_retrieved": "2024-07-30T19:19:53.488263", "image_code": "// Number of vertices in the polyspline\n#define N 10\n\n// Helper functions\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat sdPolyspline(in vec2 p, in vec2[N] cp) {\n    // Complete the first segment of the polyspline\n    vec2 v1 = cp[0], v2 = vec2(0.0), v3 = 0.5 * (cp[1] + v1);\n    vec2 pa = p - v1, ba = v3 - v1;\n    float d = dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n\n    // Combine distances to quadratic beziers spanning each corner (vertex)\n    for (int n=1; n < N - 1; n++) {\n        v1 = 0.5 * (cp[n - 1] + cp[n]), v2 = cp[n], v3 = 0.5 * (cp[n] + cp[n + 1]);\n\n        vec2 c1 = p - v1;\n        vec2 c2 = 2.0 * v2 - v3 - v1;\n        vec2 c3 = v1 - v2;\n\n        // Solve a cubic to minimize the distance for the parameter\n        float t3 = dot(c2, c2);\n        float t2 = dot(c3, c2) * 3.0 / t3;\n        float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n        float t0 = dot(c1, c3) / t3;\n\n        float t22 = t2 * t2;\n        vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n        float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n        float p2 = abs(pq.x);\n        float r1 = 1.5 / pq.x * pq.y;\n\n        if (qq * 0.25 + ppp / 27.0 > 0.0) {\n            float r2 = r1 * sqrt(3.0 / p2), root;\n            if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n            else root = sinh(asinh(r2) / 3.0);\n            root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n            d = min(d, dot2(p - mix(mix(v1, v2, root), mix(v2, v3, root), root)));\n        }\n\n        else {\n            float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n            vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n            d = min(d, dot2(p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x)));\n            d = min(d, dot2(p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y)));\n        }\n    }\n\n    // Complete the last segment of the polyspline\n    v1 = cp[N - 1], v2 = vec2(0.0), v3 = 0.5 * (cp[N - 2] + v1);\n    pa = p - v1, ba = v3 - v1;\n    d = min(d, dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)));\n\n    return sqrt(d);\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    // Generate control points\n    vec2[N] controlPoints;\n    for (int id=0; id < N; id++) {\n        controlPoints[id] = mix(Hash22(vec2(id, floor(iTime))), Hash22(vec2(id, ceil(iTime))), smoothstep(0.0, 1.0, fract(iTime))) * 3.0 - 1.5;\n    }\n\n    float d = sdPolyspline(uv, controlPoints) * 0.5;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\n    // Draw lines and control points\n    for (int n=0; n < N - 1; n++) {\n        vec2 pa = uv - controlPoints[n], ba = controlPoints[n + 1] - controlPoints[n];\n        color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - 0.001));\n        color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - controlPoints[n]) - 0.03));\n    }\n\n    // Draw last control point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - controlPoints[N - 1]) - 0.03));\n\n    // Draw the polyspline\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, d));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lf3Rn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 74, 97, 97, 117], [2187, 2276, 2300, 2300, 2435]]}
{"id": "ftXGRr", "name": "Fork reaction d mds2 647", "author": "mds2", "description": "evolving animal print as background to music video", "tags": ["diffusion", "reaction"], "likes": 1, "viewed": 278, "published": 3, "date": "1621369637", "time_retrieved": "2024-07-30T19:19:54.242247", "image_code": "#define BW 1 // set to 1 to make the output black and white\n// set to 0 to make it a mix of cyan, red, black, and white\n\nfloat hill_val(in vec2 uv, in vec3 selector) {\n  uv = mod(uv, vec2(1.0));\n  float val = dot(selector, texture(iChannel0, uv).rgb) - 0.5;\n  return val;\n}\n\nvec2 hill_grad(in vec2 uv, in vec3 selector) {\n  float f = hill_val(uv, selector);\n  return 1000.0 * vec2(hill_val(uv + vec2(0.001, 0.0), selector) - f,\n                       hill_val(uv + vec2(0.0, 0.001), selector) - f);\n}\n\nfloat coverage(in vec2 uv, in vec3 selector) {\n    float val = hill_val(uv, selector);\n    float grad_mag = length(hill_grad(uv, selector)/iResolution.xy);\n    \n    float to_zero = val / grad_mag;\n    \n    float cov = max(0.0, min(0.5 + to_zero, 1.0));\n    return cov;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    float cyan = coverage(uv, vec3(1.0, 0.0, 0.0));\n    float red = coverage(uv, vec3(0.0, 1.0, 0.0));\n\n#if BW\n    cyan = red;\n#endif\n\n    vec3 col = vec3(red, cyan, cyan);\n    \n    \n    //////////////////////////////////////////////////////////\n    // GREENSCREENING\n    //\n    // The greenscreening below is custom hacked for this video, and doesn't even work\n    // very well for that.\n    // So, if you want to copy this and use it for your own live VJ performance, or, whatever,\n    // you might^H^H^H^H^Hwill have to rewrite the greenscreen code yourself --\n    // or use a third-party greenscreener to get your video in with an alpha channel\n    vec3 vid_color = texture(iChannel1, uv).rgb;\n    \n    const vec3 green = vec3(0.1, 0.54, 0.15);\n    const vec3 fg = vec3(0.75, 0.47, 0.29);\n\n    float greenness = length(vid_color - green)/ max(0.1, length(vid_color));\n    \n    float alpha = smoothstep(0.5, 0.6, greenness);\n    vid_color = green + (vid_color - green) / max(alpha, 0.1);\n    \n    col = mix(col, vid_color, alpha);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float diffuse_weight = 0.5; // higher means less diffusion.  set greater than 0 and less than 1\nconst float react_weight = 0.25; // reaction speed : don't exceed 0.25.  higher is faster reaction\n\n// in the function \"greatest\" there are two calls to \"color_to_val_4\"\n// change those to \"color_to_val_1\", \"color_to_val_2\" etc to get different effects\n\nvec2 to_uv(in vec2 in_pixels) {\n    return in_pixels / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    \n    vec4 color = texture(iChannel1, to_uv(p));\n    \n    // color.rg = mod(10.0 * to_uv(p), vec2(1.0));\n    color.b = 1.0 - 0.5 * color.r - 0.5 * color.g;\n    \n\n    if (iTime < 0.5 || texelFetch(iChannel3, ivec2(32, 0), 0).r > 0.01) {\n\t    fragColor = vec4(color.rgb, 1.0);\n        return;\n    }\n   \n    \n    color = diffuse_weight * texture(iChannel0, to_uv(p));\n    \n    vec2 dir = 0.25 * normalize(mod(to_uv(p), vec2(0.5)) - vec2(0.25));\n      // vec2(0.95 * smoothstep(0.05, 0.0, abs(mod(to_uv(p).x, 0.25) - 0.125)), 0.0);\n      // vec2(0.0, 0.95);\n    mat2 diffuse_tensor = mat2(1.0 - dir.x * dir.x, -dir.x * dir.y,\n                               -dir.x*dir.y, 1.0 - dir.y * dir.y);\n    \n    float w = 0.25 * (1.0 - diffuse_weight);\n    const float scale = 2.0;\n    color = color +  w * texture(iChannel0, to_uv(p + scale * diffuse_tensor * vec2(1.1, 0.0)));\n    color = color +  w * texture(iChannel0, to_uv(p + scale * diffuse_tensor * vec2(0.0, 1.1)));\n    color = color +  w * texture(iChannel0, to_uv(p - scale * diffuse_tensor * vec2(1.1, 0.0)));\n    color = color +  w * texture(iChannel0, to_uv(p - scale * diffuse_tensor * vec2(0.0, 1.1)));\n    \n    color.rgb = color.rgb + react_weight * (1.0 * color.rgb * color.gbr - color.rgb * color.brg);//  + 0.005;\n    \n    color.a = 1.0;\n    color.rgb = max(vec3(0.0), min(vec3(1.0), color.rgb));\n\n    float delta = 1.5 - dot(color.rgb, vec3(1.0));\n\n    color.rgb += 0.01 * delta;\n    \n \n    fragColor = vec4(color.rgb,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXGRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 167, 167, 273], [275, 275, 321, 321, 500], [502, 502, 548, 548, 776], [778, 778, 835, 885, 2018]]}
{"id": "sdjSDd", "name": "Rocket 2d y scroller", "author": "jorge2017a1", "description": "Rocket 2d y scroller", "tags": ["rocket2dyscroller"], "likes": 5, "viewed": 284, "published": 3, "date": "1621347426", "time_retrieved": "2024-07-30T19:19:55.047096", "image_code": "//Modificado por JorgeFloresP. ---jorge2017a1\n//Fork\n//2d sidescroller.....Created by onak in 2019-10-15\n//2D Rocket...........Created by antoineMoPa in 2017-06-28\n//https://www.shadertoy.com/view/lslBDX\n//https://www.shadertoy.com/view/tsKGDc\n\nfloat pixelsize = 2.0;\nfloat scrollSpeed = 0.3;\nfloat roughness = 0.55;\n\nfloat PI = 3.14159265359;\n\n/**\n * compares x to f and returns a value between 1.0 and 0.0\n * depending on the difference as long as its below threshold\n *\n * always returns 1.0 for differences above the threshold\n */\nfloat plot2d(in float x, in float f, in float threshold) {\n    float deviation = abs(x - f);\n    \n    if (deviation < threshold) {\n        return (deviation / threshold);\n    }\n    \n    return 1.0;\n} \n\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283);\n}\n\nfloat perlin_noise(vec2 p) {\n\tvec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\nfloat noise_fBM(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    \n    for (int i = 1; i <= octaves; i++) {\n        c += perlin_noise(coord * size) * p;\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n\n/**\n * two-dimensional fractal Brownian motion\n */\nfloat fBM(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    \n    for (int i = 1; i <= octaves; i++) {\n        // apply noise function for the current octave\n        c += p * sin(coord.x * PI * size);\n        \n        // prepare parameters for next octave\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    \n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n\n\nfloat fBMYaX(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    \n    for (int i = 1; i <= octaves; i++) {\n        // apply noise function for the current octave\n        c += p * sin(coord.y * PI * size);\n        \n        // prepare parameters for next octave\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    \n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n// photoshop blend modes: https://www.shadertoy.com/view/XdS3RW\nvec4 blend_lighten(vec4 s, vec4 d) {\n    return max(s, d);\n}\nvec3 blend_lighten(vec3 s, vec3 d) {\n    return max(s, d);\n}\n\n\n\n\nvec4 rocket(vec2 pos)\n{\n    vec4 col = vec4(0.0);\n    \n    // Clip (because otherwise a sine is repeated)\n    if(pos.x < -0.5 || pos.x > 0.5){\n        return col;\n    }\n    \n    if(\n      // Base parabolic shape\n      pos.y + 0.02 * cos(12.0 * pos.y + 0.1) * pos.y < 0.5 - pow(3.88 * pos.x, 2.0) && pos.y > -0.1 \n      ||\n        // Lower rectangle\n       ( pos.y < 0.0 && pos.y > -0.2 \n            && \n                // Lower left arc\n                (pos.x > -0.1 || distance(pos, vec2(-0.1,-0.1)) < 0.10) \n                // Lower right arc\n            &&     (pos.x < 0.1  || distance(pos, vec2(0.1,-0.1)) < 0.10)\n       )\n      )\n    {\n        // Window\n        if (\n            distance(pos, vec2(0.0,0.2)) < 0.05\n        )\n        {\n            col.rgb += vec3(0.1,0.1,0.1);\n            col.a = 1.0;\n        }\n        // Rest\n        else\n        {\n            col.rgb += vec3(1.0,1.0,1.0);\n            col.a = 1.0;\n        }\n    }\n    \n    else if (\n        pos.y < -0.4 + 0.5 * cos(4.5 * pos.x)\n        &&\n        pos.y > -0.5 + 0.3 * cos(3.0 * pos.x)\n    )\n    {\n        col.rgb += vec3(1.0,0.1,0.2);\n        col.a = 1.0;\n    }\n    \n    // Propeller\n    else if (pos.x < 0.1 && pos.y < 0.0 && pos.x > -0.1 && pos.y > -0.3)\n    {\n        col.rgb += vec3(0.3,0.3,0.3) + 0.3 * cos(pos.x * 10.0 + 1.0);\n        col.a = 1.0;\n    }\n       \n    \n    return col;\n}\n\n\nvec3 paisajeRio(vec2 uv)\n{\nvec3 col;\n    float surfaceThickness = 0.015;\n    vec3 skyDark = vec3(0.17, 0.289, 0.51); // RGB 44, 74, 105\n    vec3 skyBright = vec3(0.714, 0.829, 0.984); // RGB 183, 238, 247\n    vec3 terrainBright = vec3(0.855, 0.640, 0.179); // RGB 219, 164, 46\n    vec3 terrainDark = vec3(0.585, 0.437, 0.117); // RGB 150, 112, 30 #96701e\n    vec3 surfaceDark = vec3(0.246, 0.398, 0.183); // RGB 63, 102, 47\n    vec3 surfaceBright = vec3(0.312, 0.648, 0.179); // RGB 80, 166, 46\n    float time = iTime * scrollSpeed;\n    \n    \n    // generate fractal noise\n    //float v = fBM(roughness, 7, 0.5, 2.31, uv + time);\n    float v = fBMYaX(roughness, 7, 0.5, 2.31, uv + time);\n     \n    // map to range\n    v = 0.125 + 0.135 * v;\n    \n    // colorize\n    if (abs(v - uv.x) < surfaceThickness  || abs( uv.x-v-0.7) < surfaceThickness )\n    {\n        // surface\n\t\tcol = mix(surfaceBright, surfaceDark, plot2d(uv.x, v + surfaceThickness * 0.5, surfaceThickness));\n    } \n   else if (v < uv.x && (v+0.7 > uv.x  ) ) {\n        // sky\n         vec3 sky = mix(skyBright, skyDark, uv.x);\n        float c = 2.5 * noise_fBM(2.0, 5, 0.5, 2.0, uv.yx + vec2(iTime * (0.7 * scrollSpeed), 0.0));\n        vec3 clouds = vec3(c);\n        col = clamp(sky + clouds, sky, vec3(1.0));\n        \n        //col = vec3(0.0,0.0,1.0);\n    }\n    else {\n        // terrain\n        col = terrainBright;\n        \n        // add some structure\n        float noise = noise_fBM(16.0, 5, 0.5, 2.0, uv + vec2(0.0, time));\n        noise = 0.5 + noise;\n\n        if (noise > 0.7   ) {\n            col = terrainDark;\n        }\n    }\n \n return col;\n}    \n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n        // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime * scrollSpeed;\n    \n    if (pixelsize > 1.0) {\n   \t\tuv = (pixelsize * floor(iResolution.xy * uv / pixelsize)) / iResolution.xy;\n        time = pixelsize * floor(iResolution.x / pixelsize * iTime * scrollSpeed) / iResolution.x;\n    }\n   \n    vec3 col;\n    col= paisajeRio(uv);\n    vec2 uv2=uv*(6.0+3.0*(sin(iTime)));\n    vec4 colcohete= rocket(uv2-vec2(3.0+2.0*sin(iTime*1.0),0.8));\n    col=mix(col,colcohete.xyz, colcohete.a );\n     \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 535, 593, 593, 734], [737, 737, 758, 758, 870], [872, 872, 900, 900, 1495], [1497, 1497, 1583, 1583, 1860], [1863, 1914, 1994, 1994, 2384], [2388, 2388, 2471, 2471, 2861], [2863, 2927, 2963, 2963, 2987], [2988, 2988, 3024, 3024, 3048], [3053, 3053, 3076, 3076, 4420], [4423, 4423, 4449, 4449, 6040], [6051, 6051, 6109, 6168, 6723]]}
{"id": "ssjSDt", "name": "PRESS THE LIKE BUTTON, DAVE", "author": "JeanPaulSoftware", "description": "YOU WANT TO PRESS THE LIKE BUTTON AND IT IS ENTIRELY YOUR DECISION, YOU ARE NOT BEING INFLUENCED BY THE SPIRAL.\n\nNaive spiral implementation- if you change 'nCols' to 3  you'll see where it breaks.", "tags": ["simple", "spiral", "quick"], "likes": 6, "viewed": 355, "published": 3, "date": "1621331638", "time_retrieved": "2024-07-30T19:19:55.908792", "image_code": "#define PI 3.1415926538\n\nfloat getEdgeFactor (float x, float lineWidth) {\n    // Probably a better way to do this\n    float halfWidth = lineWidth * 0.5;\n    float minDist = 0.0;\n    if (x > halfWidth && x < (1.0 - halfWidth)) {\n        return 0.0;\n    }\n    \n    minDist = min(abs(halfWidth - x), abs(1.0 - halfWidth - x));  \n    return clamp((minDist) / halfWidth, 0.0, 1.0);\n\n}\n\nvec3[5] palette = vec3[](\n    vec3(1., 22., 39.) / 255.0,\n    vec3(253., 255., 252.) / 255.,\n    vec3(46., 196., 182.) / 255.,\n    vec3(231., 29., 54.) / 255.,\n    vec3(255., 159., 28.) / 255.\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 2.3;   \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float angleScale = 2.0; // 1.0;\n    float nCols = 4.0; // 2.0;\n    float direction = -1.0; // 1.0;\n\n    float angle = PI * 2.0 + atan(uv.y, uv.x) / PI * angleScale;\n    vec2 scaledUV = scale * uv;\n    \n    float dist = distance(scaledUV, vec2(0.0, 0.0));\n    float distFloor = floor(dist + angle + iTime * direction);\n    float distFract = fract(dist + angle + iTime * direction);\n    \n\n    \n    int paletteIndex = int(mod(distFloor, nCols));\n    vec3 background = palette[paletteIndex];\n    \n    float edgeFactor = getEdgeFactor(distFract, 0.04);\n    vec3 edgeColour = palette[4]; //palette[2];\n\n    // Output to screen\n    fragColor = vec4(mix(background, edgeColour, edgeFactor), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjSDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 73, 113, 379], [578, 578, 635, 635, 1427]]}
{"id": "7s2SWt", "name": "shadertoy bug: reset forget LOD", "author": "FabriceNeyret2", "description": "Initialize with channel1 then incrementally replace by LOD1 → progressive blur.\n\nat reset, image should be reinitialized but it not, because only LOD0 of buffer is reseted. ", "tags": ["bug"], "likes": 0, "viewed": 304, "published": 3, "date": "1621324463", "time_retrieved": "2024-07-30T19:19:56.789437", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O = texture(iChannel0, U/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n         O = texture(iChannel0, U);\n    vec4 L = texture(iChannel0, U, 1.);\n    \n    O = L==vec4(0) ? texture(iChannel1, U) : L;   // reset doesn't work\n // O = O==vec4(0) ? texture(iChannel1, U) : L;   // reset works\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2SWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 86]]}
{"id": "fs2XDd", "name": "Wave Room 2", "author": "dr2", "description": "Immersive art using dynamic wraparound texture (mouseable)", "tags": ["wave", "texture"], "likes": 13, "viewed": 361, "published": 3, "date": "1621321763", "time_retrieved": "2024-07-30T19:19:57.629192", "image_code": "// \"Wave Room 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nfloat dstFar, tCur, bSize, tWav;\nint idObj;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q.y -= - bSize + 0.25 * bSize;\n  d = PrSphDf (q, 0.35 * bSize);\n  DMIN (1);\n  sLen = vec4 (vec3 (bSize) - 0.03, 0.03);\n  q = abs (p);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, sLen.xww, 0.02),\n     PrRoundBoxDf (q - sLen.xwz, sLen.wyw, 0.02)),\n     PrRoundBoxDf (q - sLen.xyw, sLen.wwz, 0.02));\n  DMIN (2);\n  q = p;\n  q.y = abs (q.y) - bSize;\n  d = PrRoundCylDf (q.xzy, 0.4 * bSize, 0.02, 0.01);\n  DMIN (2);\n  q = p;\n  d = - PrBoxDf (q, vec3 (bSize + sLen.w));\n  DMIN (3);\n  q = p;\n  q.y -= bSize - 0.22 * bSize;\n  d = PrSphDf (q, 0.22 * bSize);\n  DMIN (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 t2;\n  float wFreq, wAmp, ht;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    p *= qRot;\n    t4 = (p.xyxy + tWav * vec2 (1., -1.).xxyy) * wFreq;\n    t4 += 2. * vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw)).xxyy - 1.;\n    t4 = abs (sin (t4));\n    v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t2 = 1. - sqrt (v4.xz * v4.yw);\n    t2 *= t2;\n    t2 *= t2;\n    ht += wAmp * dot (t2, t2);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec4 WaveNfH (vec2 p)\n{\n  vec3 v;\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  p *= 16.;\n  for (int j = VAR_ZERO; j < 3; j ++) v[j] = WaveHt (p + ((j == 0) ? e.yy : ((j == 1) ? e.xy : e.yx)));\n  return vec4 (- normalize (vec3 (0.4 * (v.x - v.yz), e.x)), v.x);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, hn4;\n  vec3 vn, col, ltDir;\n  vec2 u;\n  float dstObj, rAz, rEl;\n  bool isRefl;\n  tWav = 0.2 * tCur;\n  dstObj = ObjRay (ro, rd);\n  isRefl = false;\n  if (dstObj < dstFar && idObj == 1) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    isRefl = true;\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == 2) {\n      col4 = vec4 (0.7, 0.7, 0.8, 0.1);\n      vn = VaryNf (32. * ro, vn, 1.);\n    } else if (idObj == 3) {\n      rAz = atan (ro.x, ro.z);\n      rEl = asin (ro.y / length (ro));\n      u = vec2 (rAz + pi, tan (2. * atan (0.5 * rEl))) / (2. * pi);\n      hn4 = mix (WaveNfH (u), WaveNfH (u - vec2 (1., 0.)), u.x);\n      vn = StdVuMat (rEl, rAz) * normalize (hn4.xyz);\n      col4 = vec4 (mix (vec3 (0.4, 1., 0.8), vec3 (0.3, 0.7, 1.), smoothstep (0.3, 1., hn4.w)), 0.2);\n    } else if (idObj == 4) {\n      col4 = vec4 (1., 1., 0.9, -1.);\n    }\n    if (col4.a >= 0.) {\n      ltDir = normalize (- ro);\n      col = col4.rgb * (0.1 + 0.9 * max (dot (vn, ltDir), 0.)) +\n         col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    } else col = col4.rgb * (0.6 - 0.4 * dot (rd, vn));\n    if (isRefl) col *= 0.9;\n  } else col = vec3 (0.);\n  return clamp (col, 0., 1.);  \n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, asp, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.35 * pi, 0.35 * pi);\n  dstFar = 20.;\n  bSize = 2.;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -0.95 * bSize);\n  zmFac = 1.5;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = vec2 (2. * tan (0.5 * atan (uv.x / (asp * zmFac))) * asp * zmFac, uv.y);\n    rd = vuMat * normalize (vec3 (uvv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (Maxv3 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2XDd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[584, 584, 606, 606, 1257], [1259, 1259, 1292, 1292, 1475], [1477, 1477, 1498, 1498, 1753], [1755, 1755, 1778, 1778, 2318], [2320, 2320, 2343, 2343, 2571], [2573, 2573, 2608, 2608, 3916], [3960, 3960, 4016, 4016, 5106], [5108, 5108, 5130, 5130, 5168], [5170, 5170, 5202, 5202, 5286], [5288, 5288, 5334, 5334, 5381], [5383, 5383, 5416, 5416, 5443], [5445, 5445, 5502, 5502, 5578], [5580, 5580, 5610, 5610, 5723], [5725, 5725, 5761, 5761, 5967], [6001, 6001, 6025, 6025, 6085], [6087, 6087, 6111, 6111, 6223], [6225, 6225, 6250, 6250, 6436], [6438, 6438, 6467, 6467, 6679], [6681, 6681, 6720, 6720, 6977]]}
{"id": "Ns2XDt", "name": "glsl smallpt++", "author": "Zi7ar21", "description": "Zavie's smallpt Port but with Improvements. Original: https://www.shadertoy.com/view/4sfGDB", "tags": ["pathtrace", "pathtracing", "pathtracer", "rt", "pt", "progressive", "smallpt", "pathtraced"], "likes": 10, "viewed": 557, "published": 3, "date": "1621313416", "time_retrieved": "2024-07-30T19:19:58.568680", "image_code": "// ####### glsl smallpt++ #######\n// Forked from \"GLSL smallpt\" Made by Zavie:\n// https://www.shadertoy.com/view/4sfGDB\n\n// Fork made by Zi7ar21\n// Fork Made on May 17th, 2021\n// Fork Last Updated: May 17th, 2021 at 19:50 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original (and possibly updated) fork can be found at:\n// https://www.shadertoy.com/view/Ns2XDt\n\n/*\n\nNotable Changes:\n- Progressive Rendering\nSamples now accumulate over time, giving a converged render. Also, bugged samples\n(e.g. NaN's, Infinities, and Negatives) are discared and do not contribute to the final image.\n\n- Replace Trash RNG with PCG Random\nPCG Random (https://www.pcg-random.org/) is a family of Random Number Generators,\nmade to perform better than other Random Number Generators in various ways.\n\n- Refactoring (Work in Progress)\nThe original shader is kinda messy, so it has been refactored to be more clear\n\n*/\n\n// Image Preview\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Final Image\n    vec3 color = texel0.rgb;\n\n    // HDR Tonemapping\n    color = clamp(pow(color/(color+1.0), vec3(1.0/gamma)), 0.0, 1.0);\n\n    // Output the Image Preview\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ##### smallpt #####\n// Original Shader: https://www.shadertoy.com/view/4sfGDB\n\n/*\n\nThis shader is an attempt at porting smallpt to GLSL.\n\nSee what it's all about here:\nhttp://www.kevinbeason.com/smallpt/\n\nThe code is based in particular on the slides by David Cline.\n\nSome differences:\n\n- For optimization purposes, the code considers there is\n  only one light source (see the commented loop)\n- Russian roulette and tent filter are not implemented\n\nI spent quite some time pulling my hair over inconsistent\nbehavior between Chrome and Firefox, Angle and native. I\nexpect many GLSL related bugs to be lurking, on top of\nimplementation errors. Please Let me know if you find any.\n\n--\nZavie\n\n*/\n\n// Ray Datatype\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\n// Sphere Datatype\nstruct sphere {\n\tfloat radius;\n\tvec3 pos, emission, col;\n\tint refl;\n};\n\n#define NUM_SPHERES 9\n\nsphere lightSourceVolume = sphere(20.0, vec3(50.0, 81.6, 81.6), vec3(12.0), vec3(0.0), DIFF);\nsphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n    spheres[0] = sphere(1.0e5, vec3(-1e5+1.0, 40.8    , 81.6     ), vec3(0.0 ), vec3(0.75, 0.25, 0.25), DIFF);\n    spheres[1] = sphere(1.0e5, vec3(1e5+99.0, 40.8    , 81.6     ), vec3(0.0 ), vec3(0.25, 0.25, 0.75), DIFF);\n    spheres[2] = sphere(1.0e5, vec3(50.0    , 40.8    ,-1e5      ), vec3(0.0 ), vec3(0.75            ), DIFF);\n    spheres[3] = sphere(1.0e5, vec3(50.0    , 40.8    , 1e5+170.0), vec3(0.0 ), vec3(0.00            ), DIFF);\n    spheres[4] = sphere(1.0e5, vec3(50.0    ,-1.0e5   , 81.6     ), vec3(0.0 ), vec3(0.75            ), DIFF);\n    spheres[5] = sphere(1.0e5, vec3(50.0    , 1e5+81.6, 81.6     ), vec3(0.0 ), vec3(0.75            ), DIFF);\n    spheres[6] = sphere(16.50, vec3(27.0    , 16.5    , 47.0     ), vec3(0.0 ), vec3(1.00            ), SPEC);\n    spheres[7] = sphere(16.50, vec3(73.0    , 16.5    , 78.0     ), vec3(0.0 ), vec3(0.70, 1.00, 0.90), REFR);\n    spheres[8] = sphere(600.0, vec3(50.0    , 681.33  , 81.6     ), vec3(12.0), vec3(0.00            ), DIFF);\n}\n\n//\nfloat intersect(sphere s, ray r)\n{\n    vec3 op = s.pos-r.o;\n    float t;\n    float epsilon = 1e-3;\n    float b = dot(op, r.d);\n    float det = b*b-dot(op, op)+s.radius*s.radius;\n    if(det < 0.0){return 0.0;}\n    else{det = sqrt(det);}\n    return (t = b-det) > epsilon ? t : ((t = b+det) > epsilon ? t : 0.0);\n}\n\n//\nint intersect(ray r, out float t, out sphere s, int avoid)\n{\n    int id = -1;\n    t = 1e5;\n    s = spheres[0];\n    for(int i = 0; i < NUM_SPHERES; i++)\n    {\n        sphere S = spheres[i];\n        float d = intersect(S, r);\n        if(i != avoid && d != 0.0 && d < t)\n        {\n            t = d;\n            id = i;\n            s = S;}\n    }\n\n    return id;\n}\n\n//\nvec3 jitter(vec3 d, float phi, float sina, float cosa)\n{\n    vec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n    return (u*cos(phi)+v*sin(phi))*sina+w*cosa;\n}\n\n//\nvec3 radiance(ray r)\n{\n    vec3 acc = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    int id = -1;\n    for(uint depth = 0U; depth < MAXDEPTH; depth++)\n    {\n        float t;\n        sphere obj;\n        if((id = intersect(r, t, obj, id)) < 0){break;}\n        vec3 x = t*r.d+r.o;\n        vec3 n = normalize(x-obj.pos);\n        vec3 nl = n*sign(-dot(n, r.d));\n\n        //vec3 f = obj.c;\n        //float p = dot(f, vec3(1.2126, 0.7152, 0.0722));\n        //if(depth > DEPTH_RUSSIAN || p == 0.0) if(rand() < p) f /= p; else{acc += mask*obj.e*E; break;}\n\n        if(obj.refl == DIFF)\n        {\n            float r2 = rand();\n            vec3 d = jitter(nl, twopi*rand(), sqrt(r2), sqrt(1.0-r2));\n            vec3 e = vec3(0.0);\n            #ifdef ENABLE_NEXT_EVENT_PREDICTION\n            //for(int i = 0; i < NUM_SPHERES; i++)\n            {\n                // Sphere s = sphere(i);\n                // if (dot(s.e, vec3(1.0)) == 0.0) continue;\n\n                // Normally we would loop over the light sources and\n                // cast rays toward them, but since there is only one\n                // light source, that is mostly occluded, here goes\n                // the ad hoc optimization:\n                sphere s = lightSourceVolume;\n                int i = 8;\n\n                vec3 l0 = s.pos-x;\n                float cos_a_max = sqrt(1.0-clamp(s.radius*s.radius/dot(l0, l0), 0.0, 1.0));\n                float cosa = mix(cos_a_max, 1.0, rand());\n                vec3 l = jitter(l0, twopi*rand(), sqrt(1.0-cosa*cosa), cosa);\n\n                if(intersect(ray(x, l), t, s, id) == i)\n                {\n                    float omega = twopi*(1.0-cos_a_max);\n                    e += (s.emission*clamp(dot(l, n), 0.0, 1.0)*omega)/pi;\n                }\n            }\n            #endif\n\t\t\tfloat E = 1.0;//float(depth==0);\n\t\t\tacc += mask*obj.emission*E+mask*obj.col*e;\n\t\t\tmask *= obj.col;\n\t\t\tr = ray(x, d);\n\t\t}\n\n        else if(obj.refl == SPEC)\n        {\n\t\t\tacc += mask*obj.emission;\n\t\t\tmask *= obj.col;\n\t\t\tr = ray(x, reflect(r.d, n));\n\t\t}\n\n        else\n        {\n            float a = dot(n, r.d);\n            float ddn = abs(a);\n            float nc = 1.0;\n            float nt = 1.5;\n            float nnt = mix(nc/nt, nt/nc, float(a > 0.0));\n            float cos2t = 1.0-nnt*nnt*(1.0-ddn*ddn);\n            r = ray(x, reflect(r.d, n));\n\n            if(cos2t > 0.0)\n            {\n                vec3 tdir = normalize(r.d*nnt+sign(a)*n*(ddn*nnt+sqrt(cos2t)));\n                float R0 = (nt-nc)*(nt-nc)/((nt+nc)*(nt+nc));\n                float c = 1.0-mix(ddn, dot(tdir, n), float(a > 0.0));\n                float Re = R0+(1.0-R0)*c*c*c*c*c;\n                float P = 0.25+0.5*Re;\n                float RP = Re/P;\n                float TP = (1.0-Re)/(1.0-P);\n                if(rand() < P){mask *= RP;}\n                else\n                {\n                    mask *= obj.col*TP;\n                    r = ray(x, tdir);\n                }\n            }\n        }\n    }\n\n    return acc;\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize Random Number Generator\n    INIT_RNG;\n\n    // Screen UV Coordinates\n\tvec2 uv = 4.0*(nrand2(0.5, gl_FragCoord.xy)-(0.5*resolution.xy))/max(resolution.x, resolution.y);\n\n    // Set-Up Variables\n\tinitSpheres();\n\n\t//vec3 camPos = vec3((2.0*(iMouse.xy==vec2(0.0) ? 0.5*iResolution.xy : iMouse.xy)/iResolution.xy-1.0)*vec2(48.0, 40.0)+vec2(50.0, 40.8), 169.0);\n    //const vec3 camPos = vec3(20.0, 40.0, 169.0);\n    const vec3 camPos = vec3(50.0, 35.0, 169.0);\n\n\t//vec3 cz = normalize(vec3(50.0, 40.0, 81.60)-camPos);\n    vec3 cz = normalize(vec3(50.0, 35.0, 0.0)-camPos);\n\tvec3 cx = vec3(1.0, 0.0, 0.0);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n\n\tvec3 color = vec3(0.0);\n\n    // Render the Frame\n\tfor(uint i = 0U; i < NSAMPLES; i++)\n    {\n        #ifdef DEBUG\n        vec3 test = radiance(Ray(camPos, normalize(0.53135*(uv.x*cx+uv.y*cy)+cz)));\n        if(dot(test, test) > 0.0){color += vec3(1.0);}\n        else{color += vec3(0.5, 0.0, 0.1);}\n        #else\n\t\tcolor += radiance(ray(camPos, normalize(0.53135*(uv.x*cx+uv.y*cy)+cz)));\n        #endif\n    }\n\n    // Output the Rendered Frame\n\tfragColor = any(lessThan(color, vec3(0.0))) || any(isinf(color)) || any(isnan(color)) ? vec4(0.0) : vec4(color/float(NSAMPLES), 1.0);\n    //fragColor = any(isinf(color)) || any(isnan(color)) ? vec4(0.0) : vec4(color/float(NSAMPLES), 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// ##### PROGRESSIVE RENDERING #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Progressive Rendering Buffer\n    fragColor = frame != 0 ? texel1 : vec4(0.0);\n\n    // Add New Data from the Rendering Buffer\n    fragColor += vec4(texel0.rgb, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ##### IMAGE EXPORT #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Get the Progressive Rendering Buffer\n    vec4 texel = texel0;\n\n    // Output the Final Image\n    fragColor = vec4(texel.a != 0.0 ? texel.rgb/texel.a : texel.rgb, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ##### PARAMETERS #####\n\n// Too few samples takes longer to converge because of the math done at the start of every frame\n// Too many samples takes longer to converge and may time out because of early-finishing threads\n#define NSAMPLES 4U\n\n// Too few bounces produce a low-quality and unrealistic result\n// Too many bounces adds no visible benifit and slows rendering\n#define MAXDEPTH 8U\n// 32 is the most you would ever want to use\n\n// Increase Convergence\n#define ENABLE_NEXT_EVENT_PREDICTION\n\n// Uncomment to see how many Samples never reach a Light Source\n//#define DEBUG\n\n// Russian Roulette Sampling (unused for now)\n//#define DEPTH_RUSSIAN 2\n\n// Image Gamma (Preview Only, does not effect Exported Image)\n#define gamma 2.2\n\n// Material ID's\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n\n// Traditional Input Names\n#define resolution iResolution\n#define frame iFrame\n\n// Sample Buffer\n#define texel0 texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0)\n#define texel1 texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0)\n#define texel2 texelFetch(iChannel2, ivec2(gl_FragCoord.xy), 0)\n#define texel3 texelFetch(iChannel3, ivec2(gl_FragCoord.xy), 0)\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n#define twopi pi*2.0\n\n// ##### RNG #####\n// Taken from michael0884's Usage of PCG Random\n// (He has since improved these, I like the old ones though... yeet!)\n// https://www.shadertoy.com/view/wltcRS\n// https://www.shadertoy.com/view/WttyWX\n// https://www.pcg-random.org/\n\nuint ns;\n#define INIT_RNG ns = uint(frame)*uint(resolution.x*resolution.y)+uint(gl_FragCoord.x+gl_FragCoord.y*resolution.x)\n\n// PCG Random Number Generator\nvoid pcg()\n{\n    uint state = ns*747796405U+2891336453U;\n    uint word  = ((state >> ((state >> 28U) + 4U)) ^ state)*277803737U;\n    ns = (word >> 22U) ^ word;\n}\n\n// Random Floating-Point Scalars/Vectors\nfloat rand(){pcg(); return float(ns)/float(0xffffffffU);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\n// Normalized Random Vectors\nvec2 nrand2(float sigma, vec2 mean){vec2 Z = rand2(); return mean+sigma*sqrt(-2.0*log(Z.x   ))*vec2(cos(twopi*Z.y), sin(twopi*Z.y));}\nvec3 nrand3(float sigma, vec3 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxy ))*vec3(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w));}\nvec4 nrand4(float sigma, vec4 mean){vec4 Z = rand4(); return mean+sigma*sqrt(-2.0*log(Z.xxyy))*vec4(cos(twopi*Z.z), sin(twopi*Z.z), cos(twopi*Z.w), sin(twopi*Z.w));}", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2XDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[929, 946, 1001, 1028, 1220]]}
{"id": "fsjXWd", "name": "chemistry!", "author": "pugbyte", "description": "Click and drag the mouse to add more chemical B. Play with a few variables in Buffer A.\n\nA reaction-diffusion simulation using the Gray-Scott model.\n\nResources used:\n * https://www.karlsims.com/rd.html\n * https://www.youtube.com/watch?v=BV9ny785UNc", "tags": ["2d", "simulation", "buffer"], "likes": 7, "viewed": 318, "published": 3, "date": "1621308096", "time_retrieved": "2024-07-30T19:19:59.418408", "image_code": "// All the interesting bits are in Buffer A.\n//\n// Tips:\n//   \n//   Click and drag to add more of chemical B.\n//   Disable auto draw by setting enable_auto_painter to 0.\n//   The simulation constants are very finicky.\n\n\n// All components are in the range [0…1], including hue.\n// https://stackoverflow.com/a/17897228\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 maphsv(float v) {\n    float hue = v;\n    \n    vec3 hsv = vec3(hue, .93, .92);\n    \n    //if (hue < 0.1) {\n    //    hsv = mix(vec3(0), hsv, hue/.1);\n    //}\n    \n    if (v > 0.8) {\n        hsv = mix(hsv, vec3(.87, .90, .6), (v-.8)/.1);\n    }\n    \n    return hsv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 cell = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n    vec3 col = vec3(cell.x - cell.y);\n    \n    vec3 hsv = maphsv(clamp(cell.x - cell.y, 0., 1.));\n    \n    col = hsv2rgb(hsv);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Tips:\n//   \n//   Click and drag to add more of chemical B.\n//   Disable auto draw by setting enable_auto_painter to 0.\n//   The simulation constants are very finicky.\n\n// Play with brush size\nfloat brush_size = 20.0;\nfloat initial_blob_size = 50.0;\nint enable_auto_painter = 1;\nfloat auto_painter_brush_size = 10.0;\n\n// Small tweaks in these variables have a large, often bad, effect.\nfloat da = 1.0; // Diffusion rate of a\nfloat db = 0.5; // Diffusion rate of b\nfloat f = 0.055; // Feed rate\nfloat k = 0.062; // Kill rate\nfloat delta = 1.0;\n\n#define PI 3.14159\n#define TAU (2.0*PI)\n\nvec2 get_cell(ivec2 pos)\n{\n    return texelFetch(iChannel0, pos, 0).rg;\n}\n\nvec2 laplacian(ivec2 pos)\n{    \n    vec2 sum = vec2(0.);\n    sum += get_cell(pos + ivec2(-1, 1)) * 0.05;\n    sum += get_cell(pos + ivec2(-1, 0)) * 0.2;\n    sum += get_cell(pos + ivec2(-1, -1)) * 0.05;\n    \n    sum += get_cell(pos + ivec2(0, 1)) * 0.2;\n    sum += get_cell(pos + ivec2(0, 0)) * -1.;\n    sum += get_cell(pos + ivec2(0, -1)) * 0.2;\n    \n    sum += get_cell(pos + ivec2(1, 1)) * 0.05;\n    sum += get_cell(pos + ivec2(1, 0)) * 0.2;\n    sum += get_cell(pos + ivec2(1, -1)) * 0.05;\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        // Initialize buffer with chemical a.\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n        \n        vec2 center = iResolution.xy * 0.5;\n        if (length(fragCoord - center) < initial_blob_size) {\n            fragColor = vec4(0.0,1.0,0.0,1.0);\n        }\n        return;\n    } else if (iMouse.z > 0.) {\n        // Click and drag mouse to add chemical b.\n        float dist = length(iMouse.xy - fragCoord);\n        if (dist < brush_size) {\n            fragColor = vec4(0.0,1.0,0.0,1.0);\n            return;\n        }\n    }\n    \n    if (enable_auto_painter > 0) {\n        \n    \n        vec2 pos;\n        \n        if (iTime < TAU) {\n            pos = vec2(sin(iTime), cos(iTime)) * iResolution.xy*0.3 + iResolution.xy*0.5;\n        } else if (iTime < 2.*TAU) {\n            pos = vec2(-sin(iTime), -cos(iTime)) * iResolution.xy*0.2 + iResolution.xy*0.5;\n        } else if (iTime < 3.*TAU) {\n            pos = vec2(sin(-iTime), cos(-iTime)) * iResolution.xy*0.4 + iResolution.xy*0.5;\n        }\n        \n        float dist = length(pos - fragCoord);\n        if (dist < auto_painter_brush_size) {\n            fragColor = vec4(0.0,1.0,0.0,1.0);\n            return;\n        }\n    }\n    \n    // Reaction-Diffusion simulation using Gray-Scott model\n    // https://www.karlsims.com/rd.html\n    ivec2 pos = ivec2(fragCoord);\n    \n    vec2 cell = get_cell(pos);\n    float a = cell.r;\n    float b = cell.g;\n    \n    vec2 l = laplacian(pos);\n    float la = l.r;\n    float lb = l.g;\n    \n    float a_prime = a + (da * la - a * b * b + f * (1. - a)) * delta;\n    float b_prime = b + (db * lb + a * b * b - (k + f) * b) * delta;\n    \n    a_prime = clamp(a_prime, 0., 1.);\n    b_prime = clamp(b_prime, 0., 1.);\n    \n    fragColor = vec4(a_prime, b_prime, 0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 319, 341, 341, 510], [512, 512, 534, 534, 781], [783, 783, 840, 890, 1188]]}
{"id": "NdSXWt", "name": "Reggae Computer", "author": "byt3_m3chanic", "description": "I saw this tower in a twitter pic and thought it was cool - old IBM thing. So I wanted to make it - my modeling skills suck, but not bad for being very primary. I was listening to this while making it - so added the audio visualizer into it!", "tags": ["raymarching", "retro", "computer", "ibm", "reproduction", "reggae"], "likes": 23, "viewed": 571, "published": 3, "date": "1621303820", "time_retrieved": "2024-07-30T19:20:00.492536", "image_code": "// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// IBM from way back - or something like that\n// was just trying to model something I saw on\n// twitter - though my modeling skills blow, I'm\n// trying to practice. \n\n// Audio - it's what I was listening to at the time\n// and worked well with the lights! :-)\n\n// soundcloud broken - https://soundcloud.com/alexvanderschoor/bob-marley-exodus-full-album\n// using system music till fixed - saving link in comments\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST .0001\n#define MAX_DIST 90.\n\nfloat sampleFreq(float freq) \n{\n    return texture(iChannel0, vec2(freq, 0.25)).x;\n}\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432);\n}\nmat2 rot(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat tmod = 0.;\nvoid getMouse(inout vec3 ro, inout vec3 rd)\n{\n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * 2. - 1.) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 2. - 1.) * PI;\n \n    if(M.z<1.){\n        y = .52*sin(T*.15);\n        x = tmod<4.? .6: .22*sin(T*.075);\n    }\n\n    if(x<-.25)x=-.25;\n    mat2 rx = rot(x);\n    mat2 ry = rot(y);\n    \n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n}\n\n//@iq thanks for the sdf's!\nfloat cap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdbox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdbox( vec2 p, vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdframe( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\nfloat smin( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nfloat modPolar(inout vec2 p, float rep) {\n    float angle = 2.*PI/rep;\n    float a = atan(p.y, p.x) + angle/2.;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*length(p);\n    return (abs(c) >= (rep/2.)) ? abs(c) : c;\n} \n//globals\nmat2 tprot = mat2(0);\nfloat glow1 = 0.,glow2 = 0.,glow3 = 0.,glow4 = 0.,glow5 = 0.,glow6 = 0.;\nvec3 hit=vec3(0);vec3 hitPoint=vec3(0);\n\nvec2 map(vec3 p, float sg)\n{\n    vec2 res =vec2(1e5,0.);\n    vec3 q = p;\n    \n    float mainbox = sdbox(q-vec3(0,1.1,0),vec3(1.5,3,.75));\n    float cutbox =  sdbox(q-vec3(0,2.50,.775),vec3(1.425,1.,.25));\n    cutbox =   min( sdbox(q-vec3(0,-.1 ,.775),vec3(.75,1.55,.1 )), cutbox);\n    cutbox =   min( sdbox(vec3(abs(q.x),q.yz)-vec3(.65,-.1 ,.775),vec3(.2,1.55,.25 )), cutbox);\n    mainbox = max(  mainbox, -cutbox);\n    if(mainbox<res.x) {\n        res = vec2(mainbox,2.);\n        hit = q-vec3(0,1,0);\n    }\n    \n    float dsp = sdbox(q-vec3(0,2.05,.55),vec3(.325,.155,.005));\n    if(dsp<res.x) {\n        res = vec2(dsp,8.);\n        hit = q-vec3(0,2.05,.55);\n    }\n    \n    float frame = sdframe(q-vec3(0,1.1,0),vec3(1.525,3.025,.775),.025);\n    frame = min(  sdframe(q-vec3(0,2.8,.775),vec3(1.525,1.33,.005),.025),frame);\n    frame = min(  sdframe(q-vec3(0,2.05,.55),vec3(.35,.175,.005),.015),frame);\n    frame = min(  torus(vec3(q.y,abs(q.x),q.z)-vec3(2.8,.65,.625),vec2(.225,.025)),frame);\n    frame = min(  torus(vec3(q.y,abs(q.x),q.z)-vec3(1.95,.65,.555),vec2(.125,.025)),frame);\n    frame = min(  sdbox(vec3(q.y,abs(q.x)-.835,q.z)-vec3(.120,0,.625),vec3(1.70,.03,.15)),frame);\n    frame = min(  sdbox(vec3(q.y,abs(q.x)-.425,q.z)-vec3(.025,0,.6),vec3(1.65,.03,.15)),frame);\n    frame = min(  cap(vec3(q.y,q.z,abs(q.x))-vec3(2.05,.475,1.05),.075,.1),frame);\n    \n    frame = min(sdbox(q-vec3(0,1.4,.55),vec3(.445,.225,.15)),frame);\n    if(frame<res.x) {\n        res = vec2(frame,3.);\n        hit = q;\n    }\n \n    float tapeB = cap(vec3(q.y,q.z,abs(q.x))-vec3(2.8,.55,.65),.225,.1);\n    tapeB = min(  cap(vec3(q.y,q.z,abs(q.x))-vec3(1.95,.5,.65),.100,.1),tapeB);\n    if(tapeB<res.x) {\n        res = vec2(tapeB,5.);\n        hit = q;\n    }\n    \n    vec3 tq1 = q.yzx-vec3(2.8,.55,.65);\n    vec3 pq1 = tq1;\n    pq1.xz*=tprot;\n    modPolar(pq1.xz,3.);\n    float tcbx = sdbox(pq1-vec3(.4,0,0),vec3(.09));\n    float tape1 = cap(tq1,.575,.05);\n    tape1=max(tape1,-tcbx);\n    \n    if(tape1<res.x) {\n        res = vec2(tape1,6.);\n        hit = pq1;\n    }   \n    \n    vec3 tq2 = q.yzx-vec3(2.8,.55,-.65);\n    vec3 pq2 = tq2;\n    pq2.xz*=tprot;\n    modPolar(pq2.xz,3.);\n    float tcby = sdbox(pq2-vec3(.4,0,0),vec3(.09));\n    float tape2 = cap(tq2,.575,.05);\n    tape2=max(tape2,-tcby);\n    if(tape2<res.x) {\n        res = vec2(tape2,7.);\n        hit = pq2;\n    }    \n    \n    float btn1 = sdbox(q-vec3(.25,3.75,.625),vec3(.125,.035,.15));\n    float btn2 = sdbox(q-vec3(.25,3.85,.625),vec3(.125,.035,.15));\n    float btn3 = sdbox(q-vec3(.55,3.75,.625),vec3(.125,.035,.15));\n    float btn4 = sdbox(q-vec3(.55,3.85,.625),vec3(.125,.035,.15));\n    float btn5 = sdbox(q-vec3(-.05,3.75,.625),vec3(.125,.035,.15));\n    float btn6 = sdbox(q-vec3(-.05,3.85,.625),vec3(.125,.035,.15));\n    \n    if (sg==1.&& hash21(vec2(floor(T),1.))>.8) glow1 += .00075/(.0025+btn1*btn1);\n    if (sg==1.&& hash21(vec2(floor(T),2.))>.8) glow2 += .00075/(.0025+btn2*btn2);\n    if (sg==1.&& hash21(vec2(floor(T),4.))>.8) glow1 += .00075/(.0025+btn4*btn4);\n    if (sg==1.&& hash21(vec2(floor(T),3.))>.8) glow2 += .00075/(.0025+btn3*btn3);\n    if (sg==1.&& hash21(vec2(floor(T),6.))>.8) glow2 += .00075/(.0025+btn5*btn5);\n    if (sg==1.&& hash21(vec2(floor(T),7.))>.8) glow2 += .00075/(.0025+btn6*btn6);\n    \n    btn1=min(btn2,btn1);\n    btn3=min(btn4,btn3);\n    btn5=min(btn6,btn5);\n    btn1=min(btn3,btn1);\n    btn1=min(btn5,btn1);\n    \n    if(btn1<res.x) {\n        res = vec2(btn1,1.);\n        hit = q;\n    }\n    \n    float gnd = p.y+2.;\n    if(gnd<res.x) {\n        res = vec2(gnd,4.);\n        hit = p;\n    }\n    \n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int steps, float sg)\n{\n    float d = 0.;\n    float m = 0.;\n    vec3 p;\n    for(int i=0;i<steps;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p,sg);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += ray.x*.8;\n        m  = ray.y;\n    } \n    hit = p;\n    return vec2(d,m);\n}\n\nvec3 normal(vec3 p, float t)\n{\n    t*=MIN_DIST;\n    float d = map(p,0.).x;\n    \n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy,0.).x,\n        map(p-e.yxy,0.).x,\n        map(p-e.yyx,0.).x\n        );\n    return normalize(n);\n}\n\nvec3 machineTone = vec3(.9,.01,.001);\nvec3 checkColor = vec3(0.729,0.031,0.031);\nvec4 FC= vec4(0.145,0.055,0.055,0.);\nvec3 lpos =  vec3(3,7,5);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,164,1.);\n    \n    hitPoint = hit;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n\n        float diff = clamp(dot(n,l),0.,1.)*.75;\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        vec3 light = normalize(lpos-p);\n        for( float t=.01; t < 18.; )\n        {\n            float h = map(p + light*t,0.).x;\n\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n\n            shdw = min(shdw, 11.*h/t);\n            t += h * .95;\n\n            if( shdw<MIN_DIST || t>62. ) break;\n        }\n        diff *= shdw;\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), (m==2.||m==4.)?24.:64.);\n \n        if(m==1.) {\n            C+=diff*.4;\n            ref = vec3(1)*fresnel;\n        }\n        hitPoint=p;\n        if(m==2.) {\n            //black decals\n            if(\n            (hitPoint.y>3.65&&hitPoint.y<3.95&&hitPoint.z>.75&&\n             hitPoint.x>-.75&&hitPoint.x<.75)||\n            (hitPoint.y>1.5&&hitPoint.y<3.5&&hitPoint.z>.15&&\n             hitPoint.x>-1.45&&hitPoint.x<1.45)||\n            \n            (hitPoint.y>-1.65&&hitPoint.y<1.5&&hitPoint.z>.15&&\n             hitPoint.x>-.85&&hitPoint.x<.85)||\n            \n            (hitPoint.y<-1.75)\n            ){  //red stripe\n                h=(hitPoint.y>-1.75&&hitPoint.y<1.5&&hitPoint.z>.5&&\n                   hitPoint.x>-.45&&hitPoint.x<.45)?\n                   machineTone:vec3(.01);\n                ref = vec3(1)*(.05-fresnel);\n            }else{\n               h= vec3(.95);\n               ref = vec3(0);\n            }\n            \n            if( hitPoint.y>1.0&&hitPoint.y<3.5&&hitPoint.z>.15&&\n             hitPoint.x>-1.4 &&hitPoint.x<1.4 ) {\n                //big back visualizer\n                vec2 uv = hitPoint.xy-vec2(0,2.05);\n                uv*=8.;\n                vec2 f = fract(uv)-.5;\n                vec2 fid = floor(uv)+.5;\n                fid.x=abs(fid.x);\n                fid.y*=-1.;\n                float ht = sampleFreq(fid.x*.0465);\n               \n                ht=smoothstep(.001,1.,ht)*1.5;\n\n                float ff = sdbox(f,vec2(.25))-.05;\n                //ff=abs(ff)-.01;\n                ff=smoothstep(.11,.1,ff);\n                \n                if(\n                (hitPoint.y>1.52 &&hitPoint.y<3.5) &&\n                ht>.5 && (fid.y-1.)>-(ht*1.75)\n                ) {\n                h=mix(h,ff*mix(vec3(.0,.6,1.),vec3(.0,.3,.6),fid.y-2.),.2);\n                ref = vec3(1)*(.35-fresnel);\n                }\n                \n             }\n             \n            C+=spec+(h*diff);\n        }\n        \n        if(m==3.) {\n            C+=vec3(.25)*diff;\n            ref = vec3(1)*(.25-fresnel);\n        }\n        \n        if(m==4.) {\n            vec2 f = fract(hitPoint.xz*.25)-.5;\n            if(f.x*f.y>0.) \n            {\n                h = vec3(.01);\n                ref = vec3(1)*(.35-fresnel);\n            } else {\n                ref = vec3(1)*(.01+fresnel);\n                h = checkColor;\n            }\n            C+=spec+h*diff;\n        }\n     \n        if(m==5.) {\n            h = vec3(.001);\n            C+=spec+h*diff;\n        }\n        if(m==6.) {\n            h = machineTone;\n            C+=spec+h*diff;\n        }\n        if(m==7.) {\n            h = vec3(1.);\n            C+=spec+h*diff;\n        }\n        if(m==8.) {\n            h = vec3(.01);\n            //mini visualizer\n            vec2 uv = hitPoint.xy-vec2(0,2.05);\n            uv*=15.;\n            vec2 f = fract(uv)-.5;\n            vec2 fid = floor(uv)+.5;\n            fid.x=abs(fid.x);\n            fid.y*=-1.;\n            float ht = sampleFreq(fid.x*.0465);\n            ht=smoothstep(.001,1.,ht)*1.5;\n    \n            float ff = sdbox(f,vec2(.25))-.05;\n            ff=smoothstep(.11,.1,ff);\n            if(\n            (hitPoint.y>1.92 &&hitPoint.y<2.19) &&\n            ht>.5 && (fid.y-1.)>-(ht*1.75)\n            ){\n                h+=ff*mix(vec3(.9,.5,0),vec3(.6,.2,0),fid.y+.5);\n                ref = vec3(1)*(.65-fresnel);\n            }\n            ref = vec3(1)*(.05-fresnel);\n            C+=spec+h*diff;\n        }\n        \n        ro = p+n*MIN_DIST;\n        rd = reflect(rd,n);\n    } else {\n        C = FC.rgb;\n    }\n    C = mix(FC.rgb,C,  exp(-.000035*d*d*d)); \n    \n    float glowMask1 = clamp(glow1,.0,.8);\n    C = mix(C,glow1*machineTone,glowMask1);\n    \n    float glowMask2 = clamp(glow2,.0,.7);\n    C = mix(C,glow2*vec3(.9),glowMask2);\n    \n    return vec4(C,alpha);\n}\n   \nvoid mainImage( out vec4 O, in vec2 F )\n{\n    tprot = rot(T*.5);\n    tmod = mod(T*.25,15.);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,1.25,M.z>0.||tmod<4.?6.5:8.);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    getMouse(ro,rd);\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 2.;//@BigWings reflection\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.00035*d*d*d));\n    }\n    //layer fog in\n    C = mix(C,FC.rgb,1.-FC.w);\n\n    C = pow(C, vec3(.4545));\t// gamma correction\n    \n    O = vec4(C,1.0);\n}\n", "image_inputs": [{"id": 28729, "src": "https://soundcloud.com/alexvanderschoor/bob-marley-exodus-full-album", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSXWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[659, 659, 690, 690, 743], [744, 744, 766, 766, 826], [827, 827, 846, 846, 895], [914, 914, 959, 959, 1323], [1325, 1353, 1392, 1392, 1499], [1500, 1500, 1531, 1531, 1618], [1619, 1619, 1650, 1650, 1730], [1731, 1731, 1773, 1773, 2055], [2056, 2056, 2087, 2087, 2152], [2153, 2153, 2197, 2197, 2297], [2298, 2298, 2339, 2339, 2560], [2708, 2708, 2736, 2736, 6303], [6305, 6305, 6358, 6358, 6635], [6637, 6637, 6667, 6667, 6881], [7028, 7028, 7113, 7113, 11872], [11877, 11877, 11918, 11918, 12628]]}
{"id": "ssSSDd", "name": "Youtarou", "author": "yasuo", "description": "https://en.wikipedia.org/wiki/World_Trigger", "tags": ["reproduction"], "likes": 16, "viewed": 342, "published": 3, "date": "1621274582", "time_retrieved": "2024-07-30T19:20:01.600573", "image_code": "// 2d distance functions from the Iq's site. https://iquilezles.org/articles/distfunctions2d\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Skew(a,b) mat2(1.0,tan(a),tan(b),1.0)\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n#define BendX(uv,k) mat2(cos(k*uv.x),-sin(k*uv.x),sin(k*uv.x),cos(k*uv.x))*uv.xy\n#define BendY(uv,k) mat2(cos(k*uv.y),-sin(k*uv.y),sin(k*uv.y),cos(k*uv.y))*uv.xy\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 youtaroEyebrow(vec2 uv, vec3 col, float addLineThick, float rot) {\n    uv.x = abs(uv.x);\n    uv.x-=0.25;\n    uv*=Rot(radians(-5.0+rot));\n    float d = sdBox(uv,vec2(0.12,0.001+addLineThick));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 yotarouEyeAsset1(vec2 uv, vec3 col) {\n    float d = length(uv)-.1;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    uv*=2.0;\n    uv.y*=2.0;\n    d = length(uv)-.1;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    return col;\n}\n\nvec3 yotarouEyeAsset2(vec2 uv, vec3 col, float addLineThick) {\n    uv.x-=0.25;\n    uv.y*=2.0;\n    float d = abs(length(uv)-.13)-(0.002+addLineThick);\n    d = max(-uv.y+0.12,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 youtaroEye(vec2 uv, vec3 col, float addLineThick) {\n    vec2 prevUV = uv;\n    uv.x = abs(uv.x);\n    uv.x-=0.25;\n    uv.y*=2.0;\n    \n    col = yotarouEyeAsset1(uv,col);\n    \n    uv = prevUV;\n    uv.x = abs(uv.x);\n    col = yotarouEyeAsset2(uv,col,addLineThick);\n    \n    return col;\n}\n\nvec3 youtaroEye2(vec2 uv, vec3 col, float addLineThick) {\n    \n    vec2 prevUV = uv;\n    uv.x = abs(uv.x);\n    uv*=Rot(radians(-20.0));\n    uv.x-=0.25;\n    uv.y*=2.0;\n    uv.y+=0.18;\n    \n    col = yotarouEyeAsset1(uv,col);\n    \n    uv = prevUV;\n    uv.x = abs(uv.x);\n    uv*=Rot(radians(-20.0));\n    uv.y+=0.08;\n    col = yotarouEyeAsset2(uv,col,addLineThick);\n    \n    return col;\n}\n\nvec3 youtaroEye3(vec2 uv, vec3 col, float addLineThick) {\n    \n    vec2 prevUV = uv;\n    uv = abs(uv);\n\n    uv.x-=0.25;\n    uv.y-=0.02;\n    \n    float d = sdBox(uv,vec2(0.07,0.002+addLineThick));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x = abs(uv.x);\n    col = yotarouEyeAsset2(uv,col,addLineThick);\n    \n    return col;\n}\n\nvec3 youtaroMouth(vec2 uv, vec3 col, float addLineThick) {\n    uv*=2.5;\n    uv.y=abs(uv.y);\n    uv*=Rot(radians(15.0));\n    uv.y-=.05;\n    uv.y*=2.0;\n    float d = abs(length(uv)-.1)-(0.01+addLineThick);\n    d = max(d,uv.x);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 youtarouHelmetRightEarPad(vec2 uv, vec3 col, float addLineThick) {\n    vec2 prevUV = uv;\n    uv*=SkewY(radians(-15.0));\n    uv.x+=0.395;\n    uv.y-=0.11;\n    uv*=Rot(radians(15.0));\n\n    float d = sdTriangle(uv-vec2(-0.02,-0.005),vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(sdTriangle(uv-vec2(-0.02,-0.005),vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));\n\n    d = sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));    \n\n    uv*=2.5;\n    uv.x-=0.05;\n    uv.y+=0.2;\n    d = sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(0.5,0.3,0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x+=0.5;\n    uv.y+=0.41;\n    \n    vec2 q = BendY(uv,-3.0);\n    \n    d = sdBox(q,vec2(0.005,0.05))-0.02;\n    col = mix(col,vec3(0.3,0.1,0.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 youtarouHelmet(vec2 uv, vec3 col, float addLineThick) {\n    vec2 prevUV = uv;\n    uv.x*=0.4;\n    uv.y*=1.1;\n    float mask = length(uv-vec2(0.0,-0.45))-.5;\n    uv = prevUV;\n    uv.y-=7.54;\n    \n    float mask2 = prevUV.x+0.5;\n    float mask3 = -prevUV.x+0.5;\n    float d = length(uv-vec2(0.0,0.45))-8.0;\n    d = max(-mask3,max(-mask2,d));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(length(uv-vec2(0.0,0.45))-8.0)-(0.002+addLineThick);\n    d = max(-mask3,max(-mask2,d));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.y*=1.1;\n    d = sdRoundedBox(uv,vec2(0.5,0.54),vec4(0.5,0.5,0.5,0.5));\n    d = max(-mask,d);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(sdRoundedBox(uv,vec2(0.5,0.54),vec4(0.5,0.5,0.5,0.5)))-(0.002+addLineThick);\n    d = max(-mask,d);\n    col = mix(col,vec3(0.0),S(d,0.0));    \n    \n    uv = prevUV;\n    uv.y -=0.24;\n    d = sdBox(uv,vec2(0.001+addLineThick,0.24));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x-=0.5;\n    uv.y+=0.41;\n    \n    vec2 q = BendY(uv,3.0);\n    d = sdBox(q,vec2(0.005+addLineThick,0.05))-0.02;\n    col = mix(col,vec3(0.3,0.1,0.0),S(d,0.0));      \n    \n    uv = prevUV;\n    uv*=SkewY(radians(15.0));\n    uv.x-=0.43;\n    uv.y-=0.11;\n    uv*=Rot(radians(-15.0));\n    d = sdTriangle(uv-vec2(-0.02,-0.01),vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(sdTriangle(uv-vec2(-0.02,-0.01),vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));\n\n    d = sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));    \n\n    uv*=2.5;\n    uv.x-=0.05;\n    uv.y+=0.2;\n    d = sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(0.5,0.3,0.0),S(d,0.0));  \n    \n    uv = prevUV;\n    uv.y-=0.18;\n    uv.y*=0.99;\n\n    q = BendX(uv,-0.7);    \n    d = sdBox(q-vec2(0.0,-0.01),vec2(0.3,0.005))-0.14;\n    col = mix(col,vec3(1.0),S(d,0.0));    \n    d = abs(sdBox(q-vec2(0.0,-0.01),vec2(0.3,0.005))-0.14)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    d = sdBox(q-vec2(-0.01,0.01),vec2(0.3,0.005))-0.14;\n    col = mix(col,vec3(1.0),S(d,0.0));  \n    d = abs(sdBox(q-vec2(-0.01,0.01),vec2(0.3,0.005))-0.14)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));  \n    \n    uv = prevUV;\n    uv.x-=0.21;\n    uv.y-=0.145;\n    uv.y*=1.1;\n    uv*=Rot(radians(20.0));\n    d = sdRoundedBox(uv,vec2(0.15,0.12),vec4(0.12,0.12,0.12,0.12));\n    uv*=Rot(radians(20.0));\n    d = max(-uv.x,d);\n    \n    col = mix(col,vec3(0.9),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x+=0.21;\n    uv.y-=0.145;\n    uv.y*=1.1;\n    uv*=Rot(radians(-20.0));\n    d = sdRoundedBox(uv,vec2(0.15,0.12),vec4(0.12,0.12,0.12,0.12));\n    \n    uv*=Rot(radians(30.0));\n    d = max(-uv.x,d);\n    \n    col = mix(col,vec3(0.9),S(d,0.0));    \n    \n    uv = prevUV;\n    uv.x = abs(uv.x);\n    uv.x-=0.21;\n    uv.y-=0.145;\n    uv.y*=1.1;\n    uv*=Rot(radians(20.0));\n    d = abs(sdRoundedBox(uv,vec2(0.19,0.14),vec4(0.14,0.14,0.14,0.14)))-(0.002+addLineThick);\n    d = max(-(length(uv)-0.185),d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x-=0.21;\n    uv.y-=0.145;\n    uv.y*=1.1;\n    uv*=Rot(radians(20.0));\n    d = abs(sdRoundedBox(uv,vec2(0.15,0.12),vec4(0.12,0.12,0.12,0.12)))-(0.002+addLineThick);\n        \n    uv = prevUV;\n    uv.x+=0.21;\n    uv.y-=0.145;\n    uv.y*=1.1;\n    uv*=Rot(radians(-20.0));\n    float d2 = abs(sdRoundedBox(uv,vec2(0.15,0.12),vec4(0.12,0.12,0.12,0.12)))-(0.002+addLineThick);\n    \n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    \n    return col;\n}\n\nvec3 youtarouHair(vec2 uv, vec3 col) {\n    vec2 prevUV = uv;\n    uv.x+=0.425;\n    uv.y-=0.05;\n    uv*=Rot(radians(40.0));\n    float d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.22));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x+=0.38;\n    uv.y-=0.05;\n    uv*=Rot(radians(30.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.25));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x+=0.35;\n    uv.y-=0.05;\n    uv*=Rot(radians(20.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.25));\n    col = mix(col,vec3(0.0),S(d,0.0));    \n    \n    uv = prevUV;\n    uv.x+=0.3;\n    uv.y-=0.1;\n    uv*=Rot(radians(10.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.25));\n    col = mix(col,vec3(0.0),S(d,0.0));  \n    \n    uv = prevUV;\n    uv.x+=0.15;\n    uv.y-=0.07;\n    uv*=Rot(radians(40.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.25));\n    col = mix(col,vec3(0.0),S(d,0.0));      \n    \n    uv = prevUV;\n    uv.y-=0.07;\n    uv*=Rot(radians(20.0));\n    d = sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.15));\n    col = mix(col,vec3(0.0),S(d,0.0));     \n        \n    uv = prevUV;\n    uv.x-=0.42;\n    uv.y-=0.1;\n    uv*=Rot(radians(9.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.35));\n    col = mix(col,vec3(0.0),S(d,0.0)); \n        \n    uv = prevUV;\n    uv.x-=0.38;\n    uv.y-=0.1;\n    uv*=Rot(radians(10.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.25));\n    col = mix(col,vec3(0.0),S(d,0.0)); \n        \n    uv = prevUV;\n    uv.x-=0.35;\n    uv.y-=0.1;\n    uv*=Rot(radians(15.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.2));\n    col = mix(col,vec3(0.0),S(d,0.0));     \n    \n    return col;\n}\n\nvec3 youtarouChin(vec2 uv, vec3 col, float addLineThick) {\n    vec2 prevUV = uv;\n    \n    uv.y*=1.1;\n    uv.y-=0.05;\n    \n    vec2  q = BendX(uv,0.2);\n    float d = sdRoundedBox(q,vec2(0.37,0.54),vec4(0.4,0.2,0.4,0.2));\n    d = max(uv.y,d);\n    col = mix(col,vec3(0.9,0.8,0.6),S(d,0.0));\n    d = abs(sdRoundedBox(q,vec2(0.37,0.54),vec4(0.4,0.2,0.4,0.2)))-(0.001+addLineThick);\n    d = max(uv.y,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 youtarouEars(vec2 uv, vec3 col, float addLineThick) {\n    uv.x+=0.4;\n    uv.y+=0.16;\n    uv*=SkewY(radians(20.0));\n    uv*=Rot(radians(-10.0));\n    float d = sdRoundedBox(uv,vec2(0.05,0.07),vec4(0.05,0.05,0.05,0.05));\n    col = mix(col,vec3(0.9,0.8,0.6),S(d,0.0));\n    \n    d = abs(sdRoundedBox(uv,vec2(0.05,0.07),vec4(0.05,0.05,0.05,0.05)))-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));\n\n    uv*=1.6;\n    d = abs(sdRoundedBox(uv-vec2(0.02,0.01),vec2(0.05,0.07),vec4(0.05,0.05,0.05,0.05)))-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 youtarou(vec2 uv, vec3 col, int type) {\n    float thickness = 0.004;\n    col = youtarouHelmetRightEarPad(uv,col,thickness);\n    col = youtarouEars(uv,col,thickness);\n    col = youtarouChin(uv,col,thickness);\n    col = youtaroEyebrow(uv-vec2(0.0,-0.05),col,thickness,(type == 1)?-20.0:0.0);\n    col = youtarouHair(uv,col);\n    col = youtarouHelmet(uv,col,thickness);\n    \n    if(type == 0){\n        col = youtaroEye(uv-vec2(0.0,-0.2),col,thickness);\n    } else if(type == 1){\n        col = youtaroEye2(uv-vec2(0.0,-0.2),col,thickness);\n    } else {\n        col = youtaroEye3(uv-vec2(0.0,-0.2),col,thickness);\n    }\n    col = youtaroMouth(uv-vec2(0.0,-0.38),col,thickness);\n    \n    return col;\n}\n\nvec3 bg(vec2 p, vec3 col) {\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    vec2 randP = fract(sin(id*123.456)*567.89);\n    randP += dot(randP,randP*34.56);\n    float rand = fract(randP.x*randP.y);\n    \n    int type = 2;\n    if(rand<=0.3){\n        type = int(mod(iTime*0.5,3.0));\n    } else if(rand>0.4 && rand<=0.6) {\n        type = 1;\n    } else if(rand>0.7 && rand<0.8) {\n        uv*=Rot(radians(sin(iTime*2.0)*7.0));\n        type = 0;\n    }\n    \n    uv*=1.3;\n    col = youtarou(uv,col,type);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=2.5;\n    uv.y+=iTime*0.2;\n    vec3 col = vec3(1.0);\n    col = bg(uv,col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[544, 544, 581, 581, 661], [663, 663, 718, 718, 875], [877, 877, 944, 944, 1509], [1511, 1511, 1582, 1582, 1764], [1766, 1766, 1808, 1808, 1984], [1986, 1986, 2048, 2048, 2219], [2221, 2221, 2277, 2277, 2509], [2511, 2511, 2568, 2568, 2895], [2897, 2897, 2954, 2954, 3247], [3249, 3249, 3307, 3307, 3530], [3532, 3532, 3603, 3603, 4644], [4646, 4646, 4706, 4706, 8469], [8471, 8471, 8509, 8509, 10280], [10282, 10282, 10340, 10340, 10736], [10738, 10738, 10796, 10796, 11326], [11328, 11328, 11372, 11372, 12027], [12029, 12029, 12056, 12056, 12555], [12557, 12557, 12614, 12614, 12793]]}
{"id": "ssBXWd", "name": "Eyeful of towers", "author": "xenn", "description": "wow man, far out", "tags": ["raymarching", "fractals", "menger"], "likes": 6, "viewed": 347, "published": 3, "date": "1621273225", "time_retrieved": "2024-07-30T19:20:02.638798", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uuv = uv * 2.0 - 1.0;\n    vec3 c = texture(iChannel0, uv).rgb;\n    vec4 col = vec4(pow(c, vec3(0.5)), 1.0);\n\n    fragColor = mix(vec4(.0), col, 1.-smoothstep(0.,1.,length(uuv)*0.6));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Fork of \"Menger Journey\" by Syntopia. https://shadertoy.com/view/Mdf3z7\n// 2021-05-17 16:50:31\n\n#define MaxSteps 32\n#define MinimumDistance 0.0009\n#define normalDistance     0.0002\n\n#define Iterations 16\n#define PI 3.141592\n#define Scale 3.0\n#define FieldOfView 1.0\n#define Jitter 0.05+abs(01.1*sin(iTime*0.725)/2.0)\n#define FudgeFactor 0.6\n#define NonLinearPerspective 2.0*abs(01.1+sin(iTime*0.5)/4.0)\n#define DebugNonlinearPerspective false\n\n#define Ambient 0.132184\n#define Diffuse 0.45\n#define LightDir vec3(1.0)\n#define LightColor vec3(1.0,1.0,0.858824)\n#define LightDir2 vec3(1.0*abs(01.1-sin(iTime*01.5)/2.0),-1.0*abs(01.1-sin(iTime*2.5)/2.0),1.0/abs(01.1-sin(iTime*0.5)/0.50))\n#define LightColor2 vec3(0.1*abs(01.1+sin(iTime*01.25)/2.0),0.333333,1.0)\n#define Offset vec3(0.82858-(0.51*(cos(iTime*01.5))/09.50),0.92858090,0.58090*(01.1-cos(iTime*0.235)/18.0))\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Two light sources. No specular \nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tvec3 lightDir = normalize(LightDir);\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\t\n\tvec3 lightDir2 = normalize(LightDir2);\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\t\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color);\n}\n\n\n// DE: Infinitely tiled Menger IFS.\n//\n// For more info on KIFS, see:\n// http://www.fractalforums.com/3d-fractal-generation/kaleidoscopic-%28escape-time-ifs%29/\nfloat DE(in vec3 z)\n{\n\t// enable this to debug the non-linear perspective\n\tif (DebugNonlinearPerspective) {\n\t\tz = fract(z);\n\t\tfloat d=length(z.xy-vec2(0.5));\n\t\td = min(d, length(z.xz-vec2(0.5)));\n\t\td = min(d, length(z.yz-vec2(0.5)));\n\t\treturn d-0.01;\n\t}\n\t// Folding 'tiling' of 3D space;\n\tz  = abs(1.0-mod(z,2.0));\n\n\tfloat d = 10.0;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tz.xy = rotate(z.xy,12.0+8.0*cos( iTime/64.0));\t\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(Scale-1.0);\n\t\tif( z.z<-0.25*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\n\t\td = min(d, length(z) * pow(Scale, float(-n)-1.0));\n\t}\n\t\n\treturn d-0.001;\n}\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0);\n}\n\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i < MaxSteps; i++) {\n\t\t// Non-linear perspective applied here.\n\t\tdir.zy = rotate(dir2.zy,totalDistance*cos( iTime/4.0)*NonLinearPerspective);\n\t\t\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\t// Try to smooth the count, to combat banding.\n\tfloat smoothStep =   float(steps) + distance/MinimumDistance;\n\tfloat ao = 1.1-smoothStep/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\t\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor = (color*Ambient+light)*ao;\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera position (eye), and camera target\n\tvec3 camPos = 0.5*iTime*vec3(1.0,0.0,0.0);\n\tvec3 target = camPos + vec3(1.0,0.0*cos(iTime),0.0*sin(0.4*iTime));\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tfragColor = rayMarch(camPos, rayDir, fragCoord );\n}\n\n\n\n\n", "buffer_a_inputs": [], "buffer_b_code": "\n// This buffer does some bokeh based on the alpha channel of buffer A which is the distance of the surface from the pixel.\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 base = vec3(0.);\n    \n    // Gaussian blur by mrharicot https://www.shadertoy.com/view/XdfGDH\n    \n    //declare stuff\n    const int mSize = 7;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\tfloat depth = texture(iChannel0, uv).a;\n    \n    //create the 1-D kernel\n    float sigma = mix(0.1, 10., max(0., -.55 + depth*0.2));\n    float Z = .0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            base += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n        }\n    }\n   \tvec4 b = vec4(base/(Z*Z), 1.0);\n\n    fragColor = b;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// subtle feedback loop: blend the last frame with the current one\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n    vec3 s = step(0.5,blend);\n    return s * (sqrt(base)*(-2.0*blend+2.0)+2.0*base*(1.0-blend)) - (1.-s)*(2.*base*blend+base*base*(1.0-2.0*blend));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 base = texture(iChannel0, uv).rgb;\n    vec3 overlay = texture(iChannel1, uv).rgb;\n    vec4 col = vec4(base +(blendSoftLight(base, overlay*2.)), 1.0);\n    \n    fragColor = col;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBXWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 291]]}
{"id": "ssSXWt", "name": "deferred rendering test .", "author": "sirjofri", "description": "raymarching a scene deferred", "tags": ["deferred"], "likes": 4, "viewed": 345, "published": 3, "date": "1621272342", "time_retrieved": "2024-07-30T19:20:03.871502", "image_code": "/* WARNING: bad AA algorithm! */\n/*\nAA 0 - no AA\nAA 1 - filter using fwidth, only direct neighbor pixels (horizontally, vertically)\nAA 2 - filter using fwidth, also using diagonal pixels\nAA 3 - filter using difference. super heavy performance!\n*/\n#define AA 1\n\n/* stolen from https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/ */\n/* thanks, demofox */\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n\n#if (AA == 0)\n    fragColor = vec4(pow(ACESFilm(col), vec3(1./2.2)), 1.0);\n    return;\n#endif\n    \n    vec3 mc = col.rgb;\n    float d = .001;\n#if (AA != 3)\n    float df = pow(length(fwidth(col.rgb)), .6);\n    \n    if (df > .4){\n#endif\n        float corner = .5;\n        float edge   = 1.;\n        float center = 2.;\n#if (AA == 2)\n        float div = corner*4. + edge*4. + center;\n#else\n        float div = edge*4. + center;\n#endif\n\n#if (AA == 2)\n        vec3 ca = texture(iChannel0, uv+vec2(-d, -d)).rgb * corner;\n        vec3 cc = texture(iChannel0, uv+vec2(+d, -d)).rgb * corner;\n        vec3 cg = texture(iChannel0, uv+vec2(-d, +d)).rgb * corner;\n        vec3 ci = texture(iChannel0, uv+vec2(+d, +d)).rgb * corner;\n#endif\n        vec3 cb = texture(iChannel0, uv+vec2(0., -d)).rgb * edge;\n        vec3 cd = texture(iChannel0, uv+vec2(-d, 0.)).rgb * edge;\n        vec3 ce = col.rgb * center;\n        vec3 cf = texture(iChannel0, uv+vec2(+d, 0.)).rgb * edge;\n        vec3 ch = texture(iChannel0, uv+vec2(0., +d)).rgb * edge;\n\n#if (AA == 2)\n        vec3 c = (ca+cb+cc+cd+ce+cf+cg+ch+ci)/div;\n#else\n        vec3 c = (cb+cd+ce+cf+ch)/div;\n#endif\n        mc = c;\n        \n#if (AA == 3)\n        float mv = smoothstep(0.1, .4, pow(distance(c, col), .5));\n        mc = mix(col, c, mv);\n#else\n    }\n#endif\n    \n    // use for direct comparison using mouse\n//    mc = mix(pow(mc, vec3(1.1)), col.rgb, step(iMouse.x/iResolution.x, uv.x));\n\n    fragColor = vec4(pow(ACESFilm(mc), vec3(1./2.2)), 1.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sdist = .001;   // march until this distance (higher = ugly)\nint maxsteps = 1024;  // march max this steps (smaller = ugly)\n\nvec3 ambi = vec3(.8, .9, 1.);\nvec3 campos = vec3(0., 0., 5.);\nfloat speed = 3.;\n\nfloat sdSphere(vec3 p, vec3 pos, float r)\n{\n    return distance(pos, p) - r;\n}\n\nvec2 matwood(vec3 p)\n{\n    vec3 mspos = vec3(0., -15., .05);\n    float d = min(\n        sdSphere(p, mspos, 1.),\n        min(\n            sdSphere(p, mspos+vec3( .9, 0.1, .6), .5),\n            sdSphere(p, mspos+vec3(-.9, 0.1, .6), .5)\n        )\n    );\n    float m = d < sdist ? 2. : 0.;\n    return vec2(d, m);\n}\n\nvec2 matground(vec3 p)\n{\n    float d = p.z-sin((p.x-.35)*3.+sin(p.y))*.15 + cos((p.y+15.)*.2+cos((p.x+5.)*.2));\n    float m = d < sdist ? 1. : 0.;\n    return vec2(d, m);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 mground = matground(p);\n    vec2 mwood = matwood(p);\n    float d = min(mground.x, mwood.x);\n    float m = max(mground.y, mwood.y);\n    return vec2(d, m);\n}\n\nvec2 march(vec3 ro, vec3 rd, float initd, float maxd)\n{\n    float d = initd;\n    for (int i=0; i<maxsteps; i++){\n        vec2 n = map(ro + rd*d);\n        d += n.x;\n        if (n.x < sdist)\n            return vec2(d, n.y);\n        if (d > maxd)\n            return vec2(1000., 0.);\n    }\n    return vec2(1000., 0.);\n}\n\nvec3 rotate(vec3 p, vec3 r)\n{\n    mat3 yaw = mat3(\n        cos(r.x), -sin(r.x), 0.,\n        sin(r.x),  cos(r.x), 0.,\n        0.      ,  0.      , 1.\n    );\n    mat3 pitch = mat3(\n        1.,       0.,        0.,\n        0., cos(r.y), -sin(r.y),\n        0., sin(r.y),  cos(r.y)\n    );\n    mat3 roll = mat3(\n         cos(r.z), 0., sin(r.z),\n               0., 1.,       0.,\n        -sin(r.z), 0., cos(r.z)\n    );\n    \n    p *= roll;\n    p *= pitch;\n    p *= yaw;\n    return normalize(p);\n}", "buffer_a_code": "// scene (distance and material id)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cr = vec3(.15+sin(iTime*speed*1.23)*.001, .2+sin(iTime*speed*.94)*.005, cos(iTime*speed*1.41)*.001);\n    vec3 rd = rotate(vec3(uv.x, -2., uv.y), cr);\n    \n    /* march(xx, xx, near clip, far clip); you can adjust for better performance */\n    vec2 mi = march(campos, rd, 10., 100.);\n    float d = mi.x;\n    float m = mi.y;\n    vec3 wp = campos + rd*d;\n    \n    fragColor = vec4(wp, m);\n}", "buffer_a_inputs": [], "buffer_b_code": "// color buffer\n\nvec3 wood(vec3 wp)\n{\n    return pow(texture(iChannel1, wp.xz).rgb, vec3(2.2));\n}\n\nvec3 ground(vec3 wp)\n{\n    return pow(texture(iChannel2, wp.xy*.7).rrr, vec3(3.))*vec3(.4, .6, .3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 t = texture(iChannel0, uv);\n    vec3 wp = t.xyz;\n    int id = int(t.w);\n    \n    float d = distance(wp, campos);\n    \n    vec3 col = vec3(0.);\n    \n    switch(id)\n    {\n    case 1:\n        col = ground(wp);\n        break;\n    case 2:\n        col = wood(wp);\n        break;\n    case 0:\n    default:\n        col = ambi;\n    }\n    \n    fragColor = vec4(col, clamp(pow(d*.01, 2.5), 0., 1.));\n}", "buffer_b_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// light buffer\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n    float intensity;\n};\n\nLight lA = Light(\n    vec3(9., -6., 4.),\n    vec3(1., 1., 0.8),\n    1.7\n);\n\nLight lB = Light(\n    vec3(-3., -3., 9.),\n    vec3(1., .5, .3),\n    .1\n);\n\nfloat dShadow(vec3 wp, Light l)\n{\n    vec3 rd = normalize(l.pos-wp);\n    /* last param for march(): make it smaller for better performance but less shadows */\n    float d = march(wp+(sdist+.02)*rd, rd, 0., 5.).x;\n    return clamp(mix(0., .2, d), 0., 1.);\n}\n\n#define AODIST (.17)\nfloat dAO(vec3 wp, vec3 n)\n{\n    float d = map(wp+n*AODIST).x;\n    return 1.;\n    return clamp(d/AODIST, 0., 1.);\n}\n\nvec3 dLight(vec3 wp, vec3 n, Light l)\n{\n    vec3 ld = normalize(l.pos-wp);\n    float ni = clamp(dot(n, ld), 0., 1.);\n    float dist = 1.-clamp(mix(0., .01, distance(wp, l.pos)), 0., 1.);\n    float d = min(ni, dShadow(wp, l))*dist;\n    return d*l.intensity*l.col;\n}\n\n/* Thanks iq */\nvec3 getNormal(vec3 p)\n{\n    const float h = 0.2;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.);\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(p+e*h).x; /* btw: s/pos/p */\n    }\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    Light lC = Light(\n        vec3(sin(iTime*4.)*2., cos(iTime*4.)*2.-15., 1.2),\n        vec3(cos(iTime)*.5+.5, sin(iTime)*.5+.5, 1.),\n        3.\n    );\n    \n    vec3 wp = texture(iChannel0, uv).xyz;\n    vec3 norm = getNormal(wp);\n    \n    float ao = pow(mix(0., 1., dAO(wp, norm)), 1.2);\n    vec3 col = ambi*.1*ao;\n    col += dLight(wp, norm, lA)*ao;\n    col += dLight(wp, norm, lB)*ao;\n    col += dLight(wp, norm, lC)*ao;\n    \n    fragColor = vec4(col, 1.0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec3 pp(vec3 bc, float d)\n{\n    return mix(bc, ambi, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 wp = texture(iChannel0, uv);\n    vec4 bc = texture(iChannel1, uv);\n    vec4 lb = texture(iChannel2, uv);\n    \n    vec3 col = pp(bc.rgb * lb.xyz, bc.a);\n\n    fragColor = vec4(col, 1.0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 377, 400, 400, 555]]}
{"id": "sdBXWt", "name": "Bouncing dotted ball", "author": "mrange", "description": "I wanted to recreate the classic dotted balls so common during the Amiga era\nThen I messed around a bit more.\n", "tags": ["3d", "retro"], "likes": 51, "viewed": 815, "published": 3, "date": "1621259549", "time_retrieved": "2024-07-30T19:20:04.737187", "image_code": "// Licence CC0: Bouncing dotted ball\n//  I wanted to recreate the classic dotted balls so common during the Amiga era\n//  Then I messed around a bit more.\n\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)       (0.5 + 0.5*cos(x))\n#define DOT2(x)       dot(x, x)\n#define TIME          iTime\n#define RESOLUTION    iResolution\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float beat          = 2.0*60.0/125.0;\nconst vec3  grid_color    = HSV2RGB(vec3(0.6, 0.6, 1.0)); \nconst vec3  plate_color   = HSV2RGB(vec3(0.0, 0.0, 0.125)); \nconst vec3  plane_color   = HSV2RGB(vec3(0.7, 0.125, 1.0/32.0)); \nconst vec3  light0_color  = 16.0*HSV2RGB(vec3(0.6, 0.5, 1.0)); \nconst vec3  light1_color  = 8.0*HSV2RGB(vec3(0.9, 0.25, 1.0)); \nconst vec3  sky0_color    = HSV2RGB(vec3(0.0, 0.65, 0.95)); \nconst vec3  sky1_color    = HSV2RGB(vec3(0.6, 0.5, 0.5)); \nconst vec3  light0_pos    = vec3(3.0, 4.0, 4.0);\nconst vec3  light1_pos    = vec3(-3.0, 2.0, -8.0);\nconst vec3  light0_dir    = normalize(light0_pos);\nconst vec3  light1_dir    = normalize(light1_pos);\nconst vec4  planet_sph    = vec4(50.0*normalize(light1_dir+vec3(0.025, -0.025, 0.0)), 10.0);\nconst float truchet_lw    = 0.05;\nconst mat2[] truchet_rots = mat2[](ROT(0.0*PI/2.0), ROT(1.00*PI/2.0), ROT(2.0*PI/2.0), ROT(3.0*PI/2.0));\n\nconst float period        = 18.0;\n\n// IQ's soft minimum: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.7*(b-a)/k, 0.0, 1.0);\n  return mix(b,a,h) - k*h*(1.0-h);\n}\n\n// From: http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// IQ's ray plane intersect: https://iquilezles.org/articles/intersectors\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// IQ's ray sphere intersect: https://iquilezles.org/articles/intersectors\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nvec3 toRect(vec3 p) {\n  return p.x*vec3(cos(p.z)*sin(p.y), sin(p.z)*sin(p.y), cos(p.y));\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat grid(vec2 p, float f, float mf) {\n  const float steps = 20.0;\n  vec2 gz = vec2(PI/(steps*mf), PI/steps);\n  vec2  n = mod2(p, gz);\n  p.y     *= f;\n  float d = min(abs(p.x), abs(p.y))-0.00125;\n  return d;\n}\n\nfloat dots(vec2 p, float f) {\n  const vec2 gz = vec2(PI/128.0);\n  vec2  n = mod2(p, gz);\n  p.y     *= f;\n  float d = length(p)-0.00125;\n  float r = hash(n+124.0);\n  \n  return d;\n}\n\nfloat plates(vec2 p, float f, float mf) {\n  vec2 gz = vec2(PI/(64.0*mf), PI/64.0);\n  vec2  n = mod2(p, gz);\n  p.y     *= f;\n  float r = hash(n+124.0);\n  \n  if (-1.5*sin(TAU*TIME/period)+r < f) {\n    return 1E6;\n  } else {\n    return 0.0;\n  }\n}\n\nfloat truchet_cell0(vec2 p, float h) {\n  float d0  = circle(p-vec2(0.5), 0.5);\n  float d1  = circle(p+vec2(0.5), 0.5);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  return d;\n}\n\nfloat truchet_cell1(vec2 p, float h) {\n  float d0  = abs(p.x);\n  float d1  = abs(p.y);\n  float d2  = circle(p, mix(0.2, 0.4, h));\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  return d;\n}\n\nfloat truchet(vec2 p, float f, float sections) {\n  float z = TAU/sections; \n  \n  vec2 hp = p/z;\n  hp.x -= sections/4.0;\n  vec2 lp = hp;\n  lp.x = abs(lp.x);\n\n  \n  vec2 hn = mod2(hp, vec2(1.0));\n  float r = hash(hn);\n\n  hp *= truchet_rots[int(r*4.0)];\n  float rr = fract(r*131.0);\n  float cd0 = truchet_cell0(hp, rr);\n  float cd1 = truchet_cell1(hp, rr);\n\n  float d = mix(cd0, cd1, float(fract(r*113.0) > 0.5));\n\n  float ld = lp.x-sections/6.0; \n\n  d = max(d, ld);\n  d = min(d, abs(ld));\n  d = abs(d) - truchet_lw;\n\n  return d*z;\n}\n\nfloat truchet(vec2 p, float f) {\n  float n = floor((TIME-2.0)/period);\n  float r = hash(0.1*n+100.0);\n  float sections = 11.0+2.0*floor(15.0*r*r);\n  float d = truchet(p, f, sections);\n  return d;\n}\n\nfloat bounce() {\n  float tm = TIME/beat;\n  float t = fract(tm*1.0)-0.5;\n  return 0.25 - t*t;\n}\n\nvoid lighting(vec3 pos, vec3 nor, vec3 ref, out vec3 ld0, out vec3 dif0, out vec3 ld1, out vec3 dif1) {\n  float ll0 = 0.05*DOT2(light0_pos-pos);\n  float ll1 = 0.05*DOT2(light1_pos-pos);\n  ld0       = normalize(light0_pos-pos);\n  ld1       = normalize(light1_pos-pos);\n  dif0      = light0_color*max(dot(nor, ld0), 0.0)/ll0;\n  dif1      = light1_color*max(dot(nor, ld1), 0.0)/ll1;\n}\n\nvec3 renderBackground(vec3 ro, vec3 rd, vec3 nrd, vec4 sph) {\n  vec3 sky  = smoothstep(1.0, 0.0, rd.y)*sky1_color+smoothstep(0.5, 0.0, rd.y)*sky0_color;\n\n  vec2 pi = raySphere(ro, rd, planet_sph);\n\n  float lf1 = 1.0;\n  if (pi.x > 0.0) {\n    vec3 ppos = ro+rd*pi.x;\n    float t = 1.0-tanh_approx(1.5*(pi.y - pi.x)/planet_sph.w);\n    sky *= mix(0.5, 1.0, t);\n    lf1 = t;\n  }\n\n  sky += pow(max(dot(rd, light0_dir), 0.0), 800.0)*light0_color; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 150.0)*light1_color; \n\n  if(rd.y > 0.0) return sky;\n\n  // As suggested by elenzil in the comments\n  float py  = 1.0 + 0.2 * smoothstep(-0.05, 0.1, bounce());\n  float t   = rayPlane(ro, rd, vec4(vec3(0.0, py, 0.0), 0.5));\n\n  vec3 pos  = ro + t*rd;\n  vec3 npos = ro + t*nrd;\n  float aa  = length(npos-pos);\n\n  vec3 nor  = vec3(0.0, 1.0, 0.0);\n  vec3 ref  = reflect(rd, nor); \n  vec3 nref = reflect(nrd, nor); \n\n\n  vec3 ld0 ;\n  vec3 ld1 ;\n  vec3 dif0; \n  vec3 dif1;\n  lighting(pos, nor, ref, ld0, dif0, ld1, dif1);\n\n  vec2 si0 = raySphere(pos, ld0, sph);\n\n  vec2 pp = pos.xz;\n  vec2 op = pp;\n  pp += TIME*0.513;\n  \n  vec2 np = mod2(pp, vec2(0.6));\n  \n  float sha0 = si0.x < 0.0 ? 1.0 : (1.0-1.0*tanh_approx((si0.y-si0.x)*2.5/(0.5+.5*si0.x)));\n  dif0 *= sha0;\n  \n  vec3 col = vec3(0.0);\n\n  float ll = 2.0*DOT2(op);\n  \n  float d = pmin(abs(pp.x), abs(pp.y), 0.05);\n\n  float gm = PCOS(-TAU/beat*TIME+0.25*TAU*length(op));\n  col += mix(vec3(0.75), 2.0*vec3(3.5, 2.0, 1.25), gm)*exp(-mix(400.0, 100.0, gm)*max(d-0.00125, 0.0));\n  col /= (1.0+ll);\n\n  col += plane_color*(dif0+dif1); \n\n  \n  return mix(sky, col, tanh_approx(500.0/(1.0 + DOT2(pos))));\n}\n\nvec3 renderBall(vec3 ro, vec3 rd, vec3 nrd, vec4 sph, vec2 t2) {\n  vec3 pos  = ro + t2.x*rd;\n  vec3 npos = ro + t2.x*nrd;\n  float aa  = length(npos-pos);\n\n  vec3 sp   = pos - sph.xyz;\n  vec3 nor  = normalize(sp);\n  vec3 ref  =reflect(rd, nor); \n  vec3 nref =reflect(nrd, nor); \n  \n  vec3 ld0 ;\n  vec3 ld1 ;\n  vec3 dif0; \n  vec3 dif1;\n  lighting(pos, nor, ref, ld0, dif0, ld1, dif1);\n  \n  sp.yz    *= ROT(TIME*sqrt(0.5));\n  sp.xy    *= ROT(TIME*1.234);\n  vec3 ssp = toSpherical(sp.zxy);\n\n  vec2  pp = ssp.yz;\n  float f  = sin(pp.x); \n\n  float lf2 = -ceil(log(f)/log(2.0));\n  float mf = pow(2.0, lf2);\n\n  float gd = grid(pp, f, mf);\n  float dd = dots(pp, f);\n  float pd = plates(pp, f, mf);\n  float td = truchet(pp, f);\n\n  vec3 rcol= renderBackground(pos, ref, nref, sph);\n  \n  vec3 col = vec3(0.0);\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -dd));\n  vec3 gcol = vec3(0.0); \n  gcol -= 0.5*vec3(1.0, 2.0, 2.0)*exp(-100.0*max(td+0.01, 0.0));\n  gcol = mix(gcol, vec3(0.1, 0.09, 0.125), smoothstep(-aa, aa, -(td+0.005)));\n  gcol += 8.0*vec3(2.0, 1.0, 1.0)*exp(-900.0*abs(td-0.00125));\n  gcol = mix(gcol, 0.5*(plate_color*(dif0+dif1)), vec3(pd > 0.0));\n  col += clamp(gcol, -1.0, 1.0);\n  col = mix(col, grid_color, smoothstep(-aa, aa, -gd));\n  \n  float b = smoothstep(0.15, 0.0, dot(nor, -rd));\n  col *= tanh_approx(1.0*abs(t2.y-t2.x)/sph.w);\n  \n  return col+rcol*(pd <= 0.0 ? 0.275 : 0.1);\n}\n\nvec3 effect(vec2 p, vec2 q) { \n  vec3 ro = 0.65*vec3(2.0, 0, 0.2)+vec3(0.0, 0.5, 0.0);\n  ro.xz *= ROT(TIME*0.312);\n  vec3 la = vec3(0.0,0.125, 0.0); \n\n  vec2 np = p + vec2(4.0/RESOLUTION.y); \n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd= normalize(np.x*uu + np.y*vv + rdd*ww);\n  \n  vec4 sph= vec4(vec3(0.0, bounce(), 0.0), 0.5);\n  \n  vec2 si = raySphere(ro, rd, sph);\n\n  if (si.x >= 0.0) {\n    return renderBall(ro, rd, nrd, sph, si);\n  } else {\n    return renderBackground(ro, rd, nrd, sph);\n  }\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n\n  float fi = smoothstep(0.0, 5.0, TIME);\n  col = mix(vec3(0.0), col, fi);\n\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 27174, "src": "https://soundcloud.com/slender-boy-380833869/markus-captain-kaarlonen-space-debris-spacesynth-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[557, 557, 579, 579, 725], [1876, 1935, 1974, 1974, 2058], [2060, 2097, 2133, 2133, 2227], [2229, 2303, 2345, 2345, 2392], [2394, 2469, 2513, 2513, 2710], [2712, 2712, 2738, 2738, 2847], [2849, 2849, 2870, 2870, 2939], [2941, 2941, 2969, 2989, 3065], [3067, 3067, 3088, 3088, 3155], [3157, 3157, 3179, 3179, 3227], [3229, 3229, 3260, 3260, 3286], [3288, 3288, 3327, 3327, 3498], [3500, 3500, 3529, 3529, 3679], [3681, 3681, 3722, 3722, 3924], [3926, 3926, 3964, 3964, 4112], [4114, 4114, 4152, 4152, 4329], [4331, 4331, 4379, 4379, 4860], [4862, 4862, 4894, 4894, 5059], [5061, 5061, 5077, 5077, 5155], [5157, 5157, 5260, 5260, 5538], [5540, 5540, 5601, 5601, 7171], [7173, 7173, 7237, 7237, 8564], [8566, 8566, 8595, 8595, 9221], [9223, 9223, 9259, 9259, 9492], [9494, 9494, 9549, 9549, 9814]]}
{"id": "fdSXWt", "name": "game map -challenger -v2", "author": "jorge2017a1", "description": "game map -challenger -v2", "tags": ["2d", "map", "polygon"], "likes": 4, "viewed": 236, "published": 3, "date": "1621218974", "time_retrieved": "2024-07-30T19:20:05.597886", "image_code": "//por jorge2017a1 ----jorgeFloresP---16/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 col0= vec3(0.03,0.35,0.70);\nconst vec3 col1= vec3(0.38,0.69,1.00);\nconst vec3 col2= vec3(0.50,0.50,0.50);\nconst vec3 col3= vec3(0.75,0.75,0.75);\nconst vec3 col4= vec3(0.50,0.50,0.50);\nconst vec3 col5= vec3(0.1,1.0,0.1);\nconst vec3 col6= vec3(0.1,0.8,0.1);\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPolyc000 POLY(23)\nvec2 ptc000[ 23]=vec2[](  \nvec2(.478,.064),vec2(.476,.107),vec2(.336,.106),vec2(.265,.188),vec2(.266,.260),\nvec2(.192,.340),vec2(.193,.581),vec2(.157,.581),vec2(.156,.661),vec2(.192,.661),\nvec2(.262,.738),vec2(.262,.819),vec2(.367,.936),vec2(.581,.934),vec2(.687,.816),\nvec2(.686,.741),vec2(.758,.658),vec2(.757,.421),vec2(.613,.260),vec2(.614,.179),\nvec2(.546,.105),vec2(.547,.066),vec2(.478,.064) );\n\nfloat sdPolyc001 POLY(5)\nvec2 ptc001[ 5]=vec2[](  \nvec2(.367,.182),vec2(.401,.261),vec2(.473,.259),vec2(.508,.181),vec2(.367,.182) );\n\nfloat sdPolyc002 POLY(5)\nvec2 ptc002[ 5]=vec2[](  \nvec2(.473,.261),vec2(.492,.280),vec2(.544,.221),vec2(.509,.181),vec2(.473,.261) );\n\nfloat sdPolyc003 POLY(5)\nvec2 ptc003[ 5]=vec2[](  \nvec2(.402,.261),vec2(.418,.280),vec2(.491,.280),vec2(.473,.261),vec2(.402,.261) );\n\nfloat sdPolyc004 POLY(5)\nvec2 ptc004[ 5]=vec2[](  \nvec2(.421,.276),vec2(.480,.276),vec2(.472,.266),vec2(.412,.265),vec2(.421,.276) );\n\nfloat sdPolyc005 POLY(5)\nvec2 ptc005[ 5]=vec2[](  \nvec2(.421,.272),vec2(.474,.271),vec2(.471,.266),vec2(.414,.267),vec2(.421,.272) );\n\nfloat sdPolyc006 POLY(5)\nvec2 ptc006[ 5]=vec2[](  \nvec2(.413,.241),vec2(.429,.241),vec2(.426,.231),vec2(.411,.232),vec2(.413,.241) );\n\nfloat sdPolyc007 POLY(5)\nvec2 ptc007[ 5]=vec2[](  \nvec2(.415,.232),vec2(.415,.240),vec2(.428,.239),vec2(.426,.233),vec2(.415,.232) );\n\nfloat sdPolyc008 POLY(5)\nvec2 ptc008[ 5]=vec2[](  \nvec2(.299,.421),vec2(.316,.441),vec2(.348,.441),vec2(.331,.420),vec2(.299,.421) );\n\nfloat sdPolyc010 POLY(5)\nvec2 ptc010[ 5]=vec2[](  \nvec2(.312,.426),vec2(.317,.431),vec2(.333,.431),vec2(.330,.426),vec2(.312,.426) );\n\nfloat sdPolyc011 POLY(5)\nvec2 ptc011[ 5]=vec2[](  \nvec2(.299,.419),vec2(.331,.421),vec2(.367,.342),vec2(.265,.341),vec2(.299,.419) );\n\nfloat sdPolyc012 POLY(9)\nvec2 ptc012[ 9]=vec2[](  \nvec2(.332,.739),vec2(.368,.815),vec2(.510,.815),vec2(.547,.739),vec2(.459,.739),\nvec2(.458,.767),vec2(.422,.768),vec2(.413,.740),vec2(.332,.739) );\n\nfloat sdPolyc013 POLY(4)\nvec2 ptc013[ 4]=vec2[](  \nvec2(.412,.740),vec2(.422,.748),vec2(.422,.768),vec2(.412,.740) );\n\nfloat sdPolyc014 POLY(5)\nvec2 ptc014[ 5]=vec2[](  \nvec2(.422,.750),vec2(.431,.749),vec2(.431,.765),vec2(.421,.766),vec2(.422,.750) );\n\nfloat sdPolyc015 POLY(5)\nvec2 ptc015[ 5]=vec2[](  \nvec2(.449,.765),vec2(.448,.749),vec2(.457,.749),vec2(.457,.766),vec2(.449,.765) );\n\nfloat sdPolyc016 POLY(5)\nvec2 ptc016[ 5]=vec2[](  \nvec2(.422,.768),vec2(.458,.767),vec2(.458,.748),vec2(.421,.749),vec2(.422,.768) );\n\nfloat sdPolyc017 POLY(5)\nvec2 ptc017[ 5]=vec2[](  \nvec2(.369,.816),vec2(.402,.856),vec2(.545,.856),vec2(.509,.816),vec2(.369,.816) );\n\nfloat sdPolyc018 POLY(5)\nvec2 ptc018[ 5]=vec2[](  \nvec2(.377,.822),vec2(.403,.851),vec2(.533,.851),vec2(.508,.823),vec2(.377,.822) );\n\nfloat sdPolyc019 POLY(5)\nvec2 ptc019[ 5]=vec2[](  \nvec2(.381,.821),vec2(.404,.846),vec2(.527,.848),vec2(.508,.822),vec2(.381,.821) );\n\nfloat sdPolyc020 POLY(5)\nvec2 ptc020[ 5]=vec2[](  \nvec2(.509,.816),vec2(.545,.856),vec2(.599,.796),vec2(.548,.739),vec2(.509,.816) );\n\nfloat sdPolyc021 POLY(5)\nvec2 ptc021[ 5]=vec2[](  \nvec2(.332,.421),vec2(.350,.441),vec2(.403,.381),vec2(.368,.341),vec2(.332,.421) );\n\nfloat sdPolyc022 POLY(18)\nvec2 ptc022[ 18]=vec2[](  \nvec2(.272,.700),vec2(.273,.704),vec2(.269,.706),vec2(.264,.709),vec2(.263,.709),\nvec2(.263,.714),vec2(.261,.719),vec2(.268,.726),vec2(.273,.728),vec2(.278,.726),\nvec2(.287,.722),vec2(.288,.716),vec2(.288,.709),vec2(.284,.706),vec2(.279,.705),\nvec2(.277,.705),vec2(.277,.700),vec2(.272,.700) );\n\nvec3 HacerVentana(vec2 p, vec3 col)\n{\n//ventana\n    float sdc006 = sdPolyc006(p, ptc006);\n    col=ponerBorde(colNegro,col,sdc006 );\n    \n    float sdc007 = sdPolyc007(p, ptc007);\n    col=ponerBorde(col1,col,sdc007 );\n return col;\n}\n\n\nvec3 HacerCuartoN1(vec2 p, vec3 col)\n{\n//hacer cuarto 1\n    float sdc001 = sdPolyc001(p, ptc001);\n    col=ponerBorde(col2,col,sdc001 );\n    \n    float sdc002 = sdPolyc002(p, ptc002);\n    col=ponerBorde(colNegro,col,sdc002 );\n\n    float sdc003 = sdPolyc003(p, ptc003);\n    col=ponerBorde(col3,col,sdc003 );\n        \n    float sdc004 = sdPolyc004(p, ptc004);\n    col=ponerBorde(colNegro,col,sdc004 );\n    \n    float sdc005 = sdPolyc005(p, ptc005);\n    col=ponerBorde(col2,col,sdc005 );\n    \n    col= HacerVentana( p,  col);\n    col= HacerVentana( p-vec2(0.04,0.0),  col);\n     return col;\n} \n\nvec3 HacerCuartoN2(vec2 p, vec3 col)\n{\n//hacer cuarto n2\n    float sdc008 = sdPolyc008(p, ptc008);\n    col=ponerBorde(col3,col,sdc008 );\n\n    float sdc010 = sdPolyc010(p, ptc010);\n    col=ponerBorde(col1,col,sdc010 );\n    \n    float sdc011 = sdPolyc011(p, ptc011);\n    col=ponerBorde(col2,col,sdc011 );\n    \n    col= HacerVentana( p-vec2(-0.1,0.15),  col);\n    \n     float sdc021 = sdPolyc021(p, ptc021);\n    col=ponerBorde(colNegro,col,sdc021 );\n  return col;\n}\n\nvec3 HacerCuartoN3Grande(vec2 p, vec3 col)\n{\n//hacer cuarto n3 grande\n    float sdc012 = sdPolyc012(p, ptc012);\n    col=ponerBorde(col2,col,sdc012 );\n    \n    float sdc013 = sdPolyc013(p, ptc013);\n    col=ponerBorde(colNegro,col,sdc013 );\n    \n    float sdc016 = sdPolyc016(p, ptc016);\n    col=ponerBorde(colNegro,col,sdc016 );\n    \n    float sdc014 = sdPolyc014(p, ptc014);\n    col=ponerBorde(col2,col,sdc014 );\n    \n    float sdc015 = sdPolyc015(p, ptc015);\n    col=ponerBorde(col2,col,sdc015 );\n\n    float sdc017 = sdPolyc017(p, ptc017);\n    col=ponerBorde(col3,col,sdc017 );\n    \n    float sdc018 = sdPolyc018(p, ptc018);\n    col=ponerBorde(col2,col,sdc018 );\n    \n    float sdc019 = sdPolyc019(p, ptc019);\n    col=ponerBorde(col2,col,sdc019 );\n\n    float sdc020 = sdPolyc020(p, ptc020);\n    col=ponerBorde(colNegro,col,sdc020 );\n     return col;\n}\n\n\nvec3 HacerArbol(vec2 p, vec3 col)\n{\n    float sdc022 = sdPolyc022(p, ptc022);\n    col=ponerBorde(col6,col,sdc022 );\n    return col;\n}\n    \n\n//***------------****-----------****------------******-------\nvec3 ChallengerNes(in vec2 pp, vec3 col) \n{\n  vec2 p=pp,pr1=pp, pr2=pp;\n  \n    float sdc000 = sdPolyc000(p, ptc000);\n    //col=mix(col,col1 ,S( sdc000 ,0.0));\n    col=ponerBorde(col2,col,sdc000 );\n    col= HacerCuartoN1(p,col);\n    col= HacerCuartoN2(p,col);\n    col= HacerCuartoN2(p-vec2(0.22,0.0),col);\n    col= HacerCuartoN1(p-vec2(-0.1,0.32),col);\n    col= HacerCuartoN1(p-vec2(0.12,0.32),col);\n    col= HacerCuartoN3Grande(p,col);\n    col= HacerArbol(p,col);\n    col= HacerArbol(p-vec2(0.05,0.0),col);\n    col= HacerArbol(p-vec2(0.3,0.0),col);\n    col= HacerArbol(p-vec2(0.35,0.0),col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.25;\n    vec2 p=uv*0.325-vec2(-0.45,-0.7+0.5*sin(fract(t)));\n     vec3 col=vec3(0.0,0.0,1.0);\n    //vec3 col=col2;\n    col=ChallengerNes(p, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 315, 351, 351, 396], [402, 402, 437, 437, 461], [463, 463, 524, 524, 648], [651, 651, 711, 711, 837], [1139, 1139, 1170, 1170, 1191], [5058, 5058, 5095, 5105, 5289], [5292, 5292, 5330, 5347, 5880], [5883, 5883, 5921, 5939, 6345], [6347, 6347, 6391, 6416, 7199], [7202, 7202, 7237, 7237, 7335], [7342, 7404, 7447, 7447, 8011], [8013, 8013, 8070, 8070, 8365]]}
{"id": "fsSSWt", "name": "Outlandish Fractal", "author": "oneshade", "description": "Interesting.", "tags": ["fractal"], "likes": 8, "viewed": 157, "published": 3, "date": "1621214047", "time_retrieved": "2024-07-30T19:20:06.460580", "image_code": "vec2 f(in vec2 z, in vec2 w) { return z * mat2(w.x, -w.y, w.yx); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 x = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 2.0;\n    float time = iTime * 0.25;\n    fragColor = vec4(0.0);\n\n    float w1 = sin(time * 0.25);\n    float w2 = sin(time) * 3.0;\n    float w3 = sin(time) * 2.0;\n    float w4 = cos(time * 0.75);\n    float w5 = sin(time * 0.5);\n    float w6 = 0.125 * sin(iTime);\n\n    for (int n=0; n < 50; n++) {\n        vec2 p = w1 * f(x, f(x, f(x, f(x, x)))) + w2 * f(x, f(x, f(x, x))) + w3 * f(x, f(x, x)) + w4 * f(x, x) + w5 * x + vec2(w6, 0.0);\n        vec2 q = 5.0 * w1 * f(x, f(x, f(x, x))) + 4.0 * w2 * f(x, f(x, x)) + 3.0 * w3 * f(x, x) + 2.0 * w4 * x + vec2(w5, 0.0);\n        x -= f(0.1 * p, 1.0 - q);\n        fragColor.rb += abs(x);\n    }\n\n    fragColor /= 25.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSSWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 66], [68, 68, 123, 123, 847]]}
{"id": "7s2XDc", "name": "Fascinating Dynamics", "author": "oneshade", "description": "Fascinating.", "tags": ["dynamics", "complex", "newton"], "likes": 16, "viewed": 199, "published": 3, "date": "1621211065", "time_retrieved": "2024-07-30T19:20:07.247475", "image_code": "#define RHO 1.57079632679\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 2.0;\n    float unit = 4.0 / iResolution.y;\n\n    // Quintic coefficients\n    float[6] coeffs;\n    genCoeffs(iTime, coeffs);\n\n    vec2 p = cpoly5(uv, coeffs);\n    fragColor = vec4(smoothstep(unit, 0.0, abs(mod(p.x + 0.125, 0.25) - 0.125)));\n    fragColor.rgb += smoothstep(unit, 0.0, abs(mod(p.y + 0.125, 0.25) - 0.125));\n    fragColor.rgb /= max(2.0, length(p) * 5.0);\n\n    // Iterate on UVs\n    vec2 z = uv;\n    vec2 path = vec2(0.0);\n    for (int n=0; n < 5; n++) {\n        vec2 dz = cdiv(cpoly5(z, coeffs), cpolyPrime5(z, coeffs));\n        path += 0.2 * dz;\n        z -= dz;\n    }\n\n    fragColor += vec4(mix(z, cpoly5(z, coeffs), 0.5 + 0.5 * sin(iTime * 0.5)), length(path), 1.0);\n\n    vec2 sUv = sin(mod(atan(uv.y, uv.x) + PI / 5.0, TAU / 5.0) - PI / 5.0 + vec2(RHO, 0.0)) * length(uv);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, abs(sUv.y)) * max(0.0, 2.0 - abs(mod(iTime, TAU * 8.0) - TAU * 4.0)));\n\n    // Draw quintic\n    float fx = poly5(uv.x, coeffs);\n    float dx = polyPrime5(uv.x, coeffs);\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.8, 0.0), smoothstep(unit, 0.0, abs(uv.y - fx) / sqrt(1.0 + dx * dx) - 0.005));\n\n    // Draw trail from mouse for complex Newton-Raphson\n    z = mouse;\n    for (int n=0; n < 50; n++) {\n        vec2 zn = z - 0.1 * cdiv(cpoly5(z, coeffs), cpolyPrime5(z, coeffs));\n        vec2 pa = uv - z, ba = zn - z;\n        fragColor.rgb = mix(fragColor.rgb, hue2rgb(length(ba)), smoothstep(unit, 0.0, length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - 0.01));\n        z = zn;\n    }\n\n    // Draw trail from mouse for real Newton-Raphson\n    float x = mouse.x;\n    for (int n=0; n < 50; n++) {\n        float xn = x - 0.1 * poly5(x, coeffs) / polyPrime5(x, coeffs);\n        vec2 pa = uv - vec2(x, 0.0), ba = vec2(xn - x, 0.0);\n        fragColor.rgb = mix(fragColor.rgb, hue2rgb(abs(ba.x)), smoothstep(unit, 0.0, length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - 0.01));\n        x = xn;\n    }\n\n    // Iterate on sample points in a grid\n    for (int id=0; id < 100; id++) {\n        z = texelFetch(iChannel0, ivec2(id, 0), 0).xy;\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), smoothstep(unit, 0.0, length(uv - z) - 0.02));\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n#define iTime iTime * 0.5\n\n// Complex math\nvec2 cmul(in vec2 z, in vec2 w) { return z * mat2(w.x, -w.y, w.yx); }\nvec2 cdiv(in vec2 z, in vec2 w) { return z * mat2(w, -w.y, w.x) / dot(w, w); }\n\nvec2 cpoly5(in vec2 x, in float[6] a) {\n    return a[0] * cmul(x, cmul(x, cmul(x, cmul(x, x)))) + a[1] * cmul(x, cmul(x, cmul(x, x))) + a[2] * cmul(x, cmul(x, x)) + a[3] * cmul(x, x) + a[4] * x + vec2(a[5], 0.0);\n}\n\nfloat poly5(in float x, in float[6] a) {\n    return ((((a[0] * x + a[1]) * x + a[2]) * x + a[3]) * x + a[4]) * x + a[5];\n}\n\nvec2 cpolyPrime5(in vec2 x, in float[6] a) {\n    return 5.0 * a[0] * cmul(x, cmul(x, cmul(x, x))) + 4.0 * a[1] * cmul(x, cmul(x, x)) + 3.0 * a[2] * cmul(x, x) + 2.0 * a[3] * x + vec2(a[4], 0.0);\n}\n\nfloat polyPrime5(in float x, in float[6] a) {\n    return (((5.0 * a[0] * x + 4.0 * a[1]) * x + 3.0 * a[2]) * x + 2.0 * a[3]) * x + a[4];\n}\n\n// Coefficient animation\nvoid genCoeffs(in float time, inout float[6] coeffs) {\n    time *= 0.25;\n    coeffs[0] = sin(time * 0.25);\n    coeffs[1] = sin(time) * 3.0;\n    coeffs[2] = sin(time) * 2.0;\n    coeffs[3] = cos(time * 0.75);\n    coeffs[4] = sin(time * 0.5);\n    coeffs[5] = sin(time);\n}", "buffer_a_code": "// Precompute sample starting points\nvoid mainImage(out vec4 z, in vec2 addr) {\n    ivec2 idx = ivec2(addr);\n    if (idx.x < 100 && idx.y == 0) {\n        float[6] coeffs;\n        genCoeffs(iTime, coeffs);\n\n        z.x = mod(addr.x, 10.0);\n        z.y = (addr.x - z.x) * 0.1;\n        z.xy = 0.1 * z.xy - 0.5;\n\n        for (int n=0; n < 10; n++) {\n            z.xy -= cdiv(cpoly5(z.xy, coeffs), cpolyPrime5(z.xy, coeffs));\n        }\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2XDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "fdjXWc", "name": "Iridescent Bokeh", "author": "Jaromir", "description": "Moving fake bokeh with fake iridescence. ", "tags": ["2d", "bokeh", "bubbles", "moving", "iridescent"], "likes": 27, "viewed": 1135, "published": 3, "date": "1621188762", "time_retrieved": "2024-07-30T19:20:08.089225", "image_code": "#define C_PI 3.14159265359\n\n\nvec3 hash13(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvec3 flower(vec2 p, float t, float id){\n\n    vec3 r = hash13(id+floor(t)*13.);    \n\n    float lT = fract(-t);\n    float ilT = 1.-lT;\n    \n    lT*=lT;\n    \n    float fade = sin(lT*C_PI);\n    fade = smoothstep(0.0,0.1,fade);\n    fade*=fract(t);\n\n    p+=vec2(r.xy-0.5)*pow(lT,.25);\n\n\n    p*=lT*5.;\n\n\n    float l = length(p);\n    float m = smoothstep(.4,0.,l);\n\n    float a = atan(p.y,p.x);\n\n      \n    a = sin(a*r.x*1.23  + iTime*0.123) * \n        sin(a*r.y*2.321 + iTime*0.456) *\n        sin(a*r.z*1.123 + iTime*0.589) *\n        sin(a);\n\n    l = mix(l,a*(r.x-0.5)*3.*ilT,r.z*0.5+0.2);\n    \n    float s1  = smoothstep(.5,0.,l);\n    float s2  = smoothstep(0.01,0.,l);\n    float s = (s1-s2)*m;\n\n\n    vec3 c1 =  vec3(sin(s *vec3(0.987,0.765,0.543)*C_PI*1.4));\n    vec3 c2 =  vec3(sin(s2*vec3(0.13*r.x,0.865*r.y,0.943*r.z)*6.664));\n\n    vec3 sOut = (c1*mix(c2,vec3(1.),r.y*0.5+0.5)*c1)*fade;\n    \n\n    return  sOut*l;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    vec3 s = vec3(0.);\n\n    const float amount = 20.;\n    float del = 1./amount;\n\n    for(float i = 1.; i <= amount; i++){\n\n     s+=flower(uv,iTime*0.05 + del*i,i);\n    \n    }\n\n    fragColor = vec4(pow(s*3.,vec3(0.4545)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 51, 51, 184], [187, 187, 226, 226, 1099], [1102, 1102, 1159, 1159, 1447]]}
{"id": "Ns2XDc", "name": "game map -challenger", "author": "jorge2017a1", "description": "game map -challenger", "tags": ["gamemapchallenger"], "likes": 4, "viewed": 255, "published": 3, "date": "1621179830", "time_retrieved": "2024-07-30T19:20:08.845204", "image_code": "//por jorge2017a1 ----jorgeFloresP---16/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 col0= vec3(0.5);\nconst vec3 col1= vec3(0.75,0.75,0.75);\nconst vec3 col2= vec3(0.72,0.40,0.03);\nconst vec3 col3= vec3(0.68,0.30,0.00);\nconst vec3 col4= vec3(0.72,0.40,0.03);\nconst vec3 col5= vec3(0.05,0.49,0.00);\nconst vec3 col6= vec3(0.26,0.62,0.17);\nconst vec3 col7= vec3(0.77,0.76,0.79);\nconst vec3 col8= vec3(0.07,0.34,0.72);\nconst vec3 col9= vec3(0.01,0.33,0.70);\nconst vec3 col10= vec3(0.38,0.69,0.95);\nconst vec3 col11= vec3(0.02,0.35,0.73);\nconst vec3 col12= vec3(0.84,0.53,0.16);\nconst vec3 col13= vec3(0.75,0.35,0.07);\nconst vec3 col14= vec3(0.02,0.35,0.72);\n\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\n\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPolyc000 POLY(17)\nvec2 ptc000[ 17]=vec2[](  \nvec2(.22,.12),vec2(.01,.28),vec2(.01,.52),vec2(.10,.64),vec2(.09,.70),\nvec2(.01,.82),vec2(.01,.99),vec2(.84,.99),vec2(.85,.76),vec2(.77,.61),\nvec2(.78,.57),vec2(.81,.51),vec2(.77,.46),vec2(.77,.36),vec2(.70,.22),\nvec2(.70,.12),vec2(.22,.12) );\n\n\nfloat sdPolyc001 POLY(17)\nvec2 ptc001[ 17]=vec2[](  \nvec2(.26,.00),vec2(.30,.04),vec2(.45,.04),vec2(.45,.12),vec2(.22,.12),\nvec2(.22,.32),vec2(.15,.32),vec2(.15,.67),vec2(.40,.67),vec2(.41,.59),\nvec2(.74,.59),vec2(.74,.55),vec2(.67,.55),vec2(.66,.12),vec2(1.00,.12),\nvec2(1.00,.00),vec2(.26,.00) );\n\n\nfloat sdPolyc002 POLY(5)\nvec2 ptc002[ 5]=vec2[](  \nvec2(.52,.00),vec2(.52,.08),vec2(1.00,.08),vec2(1.0,.00),vec2(.52,.00) );\n\n\nfloat sdPolyc003 POLY(5)\nvec2 ptc003[ 5]=vec2[](  \nvec2(.52,.08),vec2(.55,.12),vec2(1.00,.12),vec2(1.00,.08),vec2(.52,.08) );\n\nfloat sdPolyc004 POLY(5)\nvec2 ptc004[ 5]=vec2[](  \nvec2(.53,.09),vec2(.55,.12),vec2(1.00,.12),vec2(1.00,.09),vec2(.53,.09) );\n\nfloat sdPolyc005 POLY(5)\nvec2 ptc005[ 5]=vec2[](  \nvec2(.53,.09),vec2(.55,.11),vec2(1.00,.11),vec2(.99,.09),vec2(.53,.09) );\n\n\nfloat sdPolyc006 POLY(5)\nvec2 ptc006[ 5]=vec2[](  \nvec2(.45,.10),vec2(.50,.10),vec2(.50,.06),vec2(.45,.06),vec2(.45,.10) );\n\nfloat sdPolyc007 POLY(5)\nvec2 ptc007[ 5]=vec2[](  \nvec2(.45,.10),vec2(.47,.12),vec2(.52,.12),vec2(.50,.10),vec2(.45,.10) );\n\nfloat sdPolyc008 POLY(10)\nvec2 ptc008[10]=vec2[](  \nvec2(.50,.10),vec2(.52,.12),vec2(.52,.11),vec2(.51,.10),vec2(.51,.08),\nvec2(.52,.09),vec2(.52,.08),vec2(.50,.06), vec2(.50,.07),vec2(.50,.10) );\n\n\nfloat sdPolyc009 POLY(5)\nvec2 ptc009[ 5]=vec2[](  \nvec2(.47,.12),vec2(.51,.12),vec2(.50,.11),vec2(.46,.11),vec2(.47,.12) );\n\nfloat sdPolyc010 POLY(5)\nvec2 ptc010[ 5]=vec2[](  \nvec2(.47,.11),vec2(.47,.11),vec2(.50,.11),vec2(.50,.11),vec2(.47,.11) );\n\nfloat sdPolyc011 POLY(6)\nvec2 ptc011[ 6]=vec2[](  \nvec2(.47,.08),vec2(.48,.08),vec2(.48,.07),vec2(.47,.07),vec2(.47,.07),\nvec2(.47,.08) );\n\nfloat sdPolyc014 POLY(5)\nvec2 ptc014[ 5]=vec2[](  \nvec2(.60,.02),vec2(.60,.01),vec2(.62,.01),vec2(.62,.02),vec2(.60,.02) );\n\nfloat sdPolyc015 POLY(5)\nvec2 ptc015[ 5]=vec2[](  \nvec2(.60,.03),vec2(.60,.03),vec2(.62,.03),vec2(.62,.03),vec2(.60,.03) );\n\nfloat sdPolyc017 POLY(5)\nvec2 ptc017[ 5]=vec2[](  \nvec2(.26,.32),vec2(.37,.32),vec2(.37,.20),vec2(.26,.20),vec2(.26,.32) );\n\nfloat sdPolyc018 POLY(5)\nvec2 ptc018[ 5]=vec2[](  \nvec2(.40,.32),vec2(.59,.32),vec2(.59,.20),vec2(.41,.20),vec2(.40,.32) );\n\nfloat sdPolyc019 POLY(5)\nvec2 ptc019[ 5]=vec2[](  \nvec2(.18,.48),vec2(.30,.48),vec2(.30,.36),vec2(.19,.36),vec2(.18,.48) );\n\n\nfloat sdPolyc020 POLY(7)\nvec2 ptc020[ 7]=vec2[](  \nvec2(.33,.48),vec2(.41,.48),vec2(.41,.55),vec2(.59,.56),vec2(.59,.36),\nvec2(.33,.36),vec2(.33,.48) );\n\nfloat sdPolyc021 POLY(5)\nvec2 ptc021[ 5]=vec2[](  \nvec2(.19,.52),vec2(.18,.63),vec2(.37,.63),vec2(.37,.51),vec2(.19,.52) );\n\nfloat sdPolyc022 POLY(5)\nvec2 ptc022[ 5]=vec2[](  \nvec2(.08,.75),vec2(.44,.75),vec2(.35,.89),vec2(.14,.90),vec2(.08,.75) );\n\nfloat sdPolyc023 POLY(5)\nvec2 ptc023[ 5]=vec2[](  \nvec2(.00,.91),vec2(.08,.83),vec2(.16,.99),vec2(.00,.99),vec2(.00,.91) );\n\nfloat sdPolyc024 POLY(5)\nvec2 ptc024[5]=vec2[](  \nvec2(.08,.83),vec2(.30,.83),vec2(.29,.99),vec2(.16,.99),vec2(.08,.83) );\n\nfloat sdPolyc025 POLY(5)\nvec2 ptc025[ 5]=vec2[](  \nvec2(.19,.83),vec2(.19,.92),vec2(.23,.92),vec2(.23,.84),vec2(.19,.83) );\n\nfloat sdPolyc026 POLY(5)\nvec2 ptc026[ 5]=vec2[](  \nvec2(.19,.75),vec2(.19,.77),vec2(.21,.77),vec2(.21,.75),vec2(.19,.75) );\n\nfloat sdPolyc027 POLY(5)\nvec2 ptc027[ 5]=vec2[](  \nvec2(.24,.85),vec2(.37,.99),vec2(.54,.99),vec2(.68,.85),vec2(.24,.85) );\n\nfloat sdPolyc028 POLY(10)  //casa\nvec2 ptc028[ 10]=vec2[](  \nvec2(.44,.24),vec2(.44,.24),vec2(.44,.24),vec2(.44,.27),vec2(.47,.26),\nvec2(.47,.26),vec2(.48,.26),vec2(.48,.26),vec2(.48,.25),vec2(.44,.24) );\n\nfloat sdPolyc029 POLY(7)\nvec2 ptc029[ 7]=vec2[](  \nvec2(.45,.24),vec2(.45,.25),vec2(.45,.26),vec2(.46,.26),vec2(.46,.25),\nvec2(.46,.24),vec2(.45,.24) );\n\nfloat sdPolyc030 POLY(9)\nvec2 ptc030[ 9]=vec2[](  \nvec2(.45,.26),vec2(.44,.26),vec2(.45,.28),vec2(.47,.28),vec2(.48,.27),\nvec2(.48,.26),vec2(.47,.26),vec2(.46,.27),vec2(.45,.26) );\n\nfloat sdPolyc031 POLY(5)\nvec2 ptc031[ 5]=vec2[](  \nvec2(.45,.26),vec2(.45,.25),vec2(.46,.25),vec2(.46,.26),vec2(.45,.26) );\n\nfloat sdPolyc032 POLY(5)\nvec2 ptc032[ 5]=vec2[](  \nvec2(.46,.26),vec2(.47,.26),vec2(.47,.25),vec2(.46,.25),vec2(.46,.26) );\n\nfloat sdPolyc033 POLY(5)\nvec2 ptc033[ 5]=vec2[](  \nvec2(.47,.26),vec2(.47,.26),vec2(.47,.25),vec2(.47,.25),vec2(.47,.26) );\n\nfloat sdPolyc034 POLY(5)\nvec2 ptc034[ 5]=vec2[](  \nvec2(.292,.28),vec2(.292,.29),vec2(.281,.29),vec2(.281,.28),vec2(.292,.28) );\n\nfloat sdPolyc035 POLY(13) //arbol\nvec2 ptc035[ 13]=vec2[](  \nvec2(.29,.29),vec2(.28,.29),vec2(.27,.29),vec2(.28,.30),\nvec2(.27,.30),vec2(.28,.30),vec2(.28,.31),\nvec2(.29,.31),vec2(.30,.31),vec2(.30,.30),\nvec2(.30,.292),vec2(.30,.292),vec2(.29,.29) );\n\n\nvec3 arbolYTronco(vec2 p, vec3 col)\n{\n    float sdc034 = sdPolyc034(p, ptc034); //tronco\n    col=ponerBorde(col2,col,sdc034 );\n\n    float sdc035 = sdPolyc035(p, ptc035);  //arbol\n    col=ponerBorde(col6,col,sdc035 );\n    return col;\n}\n\n\nvec3 casasCh(vec2 p, vec3 col)\n{\n    float sdc028 = sdPolyc028(p, ptc028); //casa pasto\n    col=ponerBorde(col1,col,sdc028 );\n\n    float sdc029 = sdPolyc029(p, ptc029); //puerta casa\n    col=ponerBorde(col0,col,sdc029 );\n\n    float sdc030 = sdPolyc030(p, ptc030);\n    col=ponerBorde(col8,col,sdc030 );\n\n\n    float sdc031 = sdPolyc031(p, ptc031);\n    col=ponerBorde(col10,col,sdc031 );\n\n    float sdc032 = sdPolyc032(p, ptc032);  //ventana casa\n    col=ponerBorde(col8,col,sdc032 );\n\n\n    float sdc033 = sdPolyc033(p, ptc033);\n    col=ponerBorde(col1,col,sdc033 );\n    return col;\n}\n//***------------****-----------****------------******-------\nvec3 ChallengerNes(in vec2 pp, vec3 col) \n{\n  vec2 p=pp,pr1=pp, pr2=pp;\n\n    float sdc000 = sdPolyc000(p, ptc000); //pasto cafe\n    col=ponerBorde(col4,col,sdc000 );\n    \n    float sdc001 = sdPolyc001(p, ptc001);  //concreto\n    col=ponerBorde(col0,col,sdc001 );\n\n    float sdc002 = sdPolyc002(p, ptc002); //edificio\n    col=ponerBorde(col0,col,sdc002 );\n\n    float sdc003 = sdPolyc003(p, ptc003); //techo edificio\n    col=ponerBorde(col1,col,sdc003 );\n\n    float sdc004 = sdPolyc004(p, ptc004);\n    col=ponerBorde(col0,col,sdc004 );\n    \n    float sdc005 = sdPolyc005(p, ptc005);\n    col=ponerBorde2(col1,col,sdc005 );\n\n    \n    float sdc006 = sdPolyc006(p, ptc006); //cuarto\n    col=ponerBorde(col0,col,sdc006 );\n    \n    float sdc007 = sdPolyc007(p, ptc007);\n    col=ponerBorde(col1,col,sdc007 );\n\n    float sdc008 = sdPolyc008(p, ptc008);\n    col=ponerBorde(col1,col,sdc008 );\n\n    float sdc009 = sdPolyc009(p, ptc009);\n    col=ponerBorde(col0,col,sdc009 );\n\n    float sdc010 = sdPolyc010(p, ptc010); //sombra\n    col=ponerBorde(col2,col,sdc010 );\n\n    float sdc011 = sdPolyc011(p, ptc011); //ventana\n    col=ponerBorde(col8,col,sdc011 );\n    \n    \n    float sdc014 = sdPolyc014(p, ptc014);  //ventana edificio\n    col=ponerBorde(col8,col,sdc014 );\n    \n    float sdc015 = sdPolyc015(p, ptc015);\n    col=ponerBorde(col1,col,sdc015 );\n    \n    float sdc017 = sdPolyc017(p, ptc017);\n    col=mix(col,col5 ,S( sdc017 ,0.0));\n    \n    \n    float sdc018 = sdPolyc018(p, ptc018);\n    col=mix(col,col5 ,S( sdc018 ,0.0));\n\n    float sdc019 = sdPolyc019(p, ptc019);\n    col=mix(col,col5 ,S( sdc019 ,0.0));\n\n    float sdc020 = sdPolyc020(p, ptc020);\n    col=mix(col,col5 ,S( sdc020 ,0.0));\n\n    float sdc021 = sdPolyc021(p, ptc021);\n    col=mix(col,col5 ,S( sdc021 ,0.0));\n\n    float sdc023 = sdPolyc023(p, ptc023); //piramide oculta\n    col=ponerBorde(col3,col,sdc023 );\n\n    float sdc024 = sdPolyc024(p, ptc024);\n    col=ponerBorde(col2,col,sdc024 );  //piramide sombrea oculta\n\n    float sdc025 = sdPolyc025(p, ptc025); //puerta piramide oculta\n    col=ponerBorde(colNegro,col,sdc025 );\n\n    float sdc027 = sdPolyc027(p, ptc027);  //piramide n2 atras\n    col=ponerBorde(col2,col,sdc027 );\n\n    float sdc022 = sdPolyc022(p, ptc022); //piramide n1\n    col=ponerBorde(col3,col,sdc022 );\n\n      float sdc026 = sdPolyc026(p, ptc026);  //puerta piramide 1\n    col=ponerBorde(colNegro,col,sdc026 );\n\n\n col= casasCh( p, col);\n col= casasCh( p-vec2(0.02,0.17), col);\n col= casasCh( p-vec2(-0.06,0.17), col);\n col= casasCh( p-vec2(-0.2,0.17), col);\n col= casasCh( p-vec2(-0.2,0.3), col);\n\n col= arbolYTronco(p-vec2(0.0,0.0), col);\n col= arbolYTronco(p-vec2(0.04,0.0), col);\n \n col= arbolYTronco(p-vec2(0.15,0.20), col);\n col= arbolYTronco(p-vec2(0.18,0.20), col);\n col= arbolYTronco(p-vec2(0.21,0.21), col);\n col= arbolYTronco(p-vec2(-0.07,0.3), col);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.25;\n    vec2 p=uv*0.325-vec2(-0.45,-0.7+0.5*sin(fract(t)));\n    vec3 col=col8;\n    col=ChallengerNes(p, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2XDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 315, 351, 351, 396], [402, 402, 437, 437, 461], [463, 463, 524, 524, 648], [651, 651, 711, 711, 837], [1452, 1452, 1483, 1483, 1504], [6748, 6748, 6785, 6785, 6982], [6985, 6985, 7017, 7017, 7566], [7567, 7629, 7672, 7672, 10483], [10485, 10485, 10542, 10542, 10802]]}
{"id": "fd2XDc", "name": "Shitty green screen keying", "author": "ChuckNorris", "description": "Uses a linear model to estimate alpha. Then solve I = alpha F + (1 - alpha) B for F assuming fixed B and blend F and alpha with new background.", "tags": ["screen", "greenscreen", "green", "keying", "matting"], "likes": 1, "viewed": 367, "published": 3, "date": "1621178143", "time_retrieved": "2024-07-30T19:20:09.597193", "image_code": "// License: CC0\n\nfloat estimate_alpha(vec3 I){\n    return clamp(0.8 + dot(vec3(1.5, -2.1, 1.2), I), 0.0, 1.0);\n}\n\nvec3 estimate_foreground(vec3 I, float alpha){\n    vec3 B = vec3(0.15, 0.5, 0.1);\n    return (I - (1.0 - alpha) * B) / (alpha + 0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 I = texture(iChannel0, uv).rgb;\n    float alpha = estimate_alpha(I);\n    vec3 F = estimate_foreground(I, alpha);\n    vec3 B_new = texture(iChannel1, uv + vec2(fract(-0.2 * iTime), 0)).rgb;\n    fragColor = vec4(mix(B_new, F, alpha), 1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XDc.jpg", "access": "api", "license": "cc0-1.0", "functions": [[17, 17, 46, 46, 112], [114, 114, 160, 160, 249], [251, 251, 305, 305, 594]]}
{"id": "Ns2XWc", "name": "Reflecting toruses", "author": "mrange", "description": "CC0: Reflecting toruses\nNumerous examples on shadertoy already on how to do repeating toruses so nothing ground breaking.\nPart of an Amiga tribute demo released earlier. Every late Amiga demo had rotating toruses\n", "tags": ["3d", "raymarching", "torus"], "likes": 43, "viewed": 733, "published": 3, "date": "1621175258", "time_retrieved": "2024-07-30T19:20:10.465870", "image_code": "// CC0: Reflecting toruses\n//  Numerous examples on shadertoy already on how to do repeating toruses so nothing ground breaking.\n//  Part of an Amiga tribute demo released earlier. Every late Amiga demo had rotating toruses\n\n// Repeats itself after 20 sec\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define MISS            1E6\n\n#define BB_TOLERANCE            0.0001\n#define BB_NORM_OFF             0.001\n#define BB_MAX_RAY_LENGTH       15.0\n#define BB_MAX_RAY_MARCHES      60\n#define BB_MAX_SHADOW_MARCHES   15\n#define BB_MAX_REFLECTIONS      3\n\nconst mat2 rot0            = ROT(0.0);\nconst vec3 std_gamma       = vec3(2.2);\n\nconst vec3 bb_lightPos     = 2.0*vec3(4.0, 3.0, 1.5);\nconst vec3 bb_backLightPos = bb_lightPos.x*vec3(-1.0, 1.0, -1.0);\nconst vec3 bb_skyCol1      = vec3(0.2, 0.4, 0.6);\nconst vec3 bb_skyCol2      = vec3(0.4, 0.7, 1.0);\nconst vec3 bb_sunCol       = vec3(8.0,7.0,6.0)/8.0;\nconst vec3 bb_sunDir       = normalize(bb_lightPos);\nconst float bb_period      = 20.0;\n\nconst float bb_bottom      = -.85;\n\nvec3   bb_g_baseColor      = vec3(0.0);\nfloat  bb_g_refFactor      = 0.0;\n\nmat2   bb_g_rot            = rot0;\nfloat  bb_g_fi             = 0.0;\nfloat  bb_g_fo             = 0.0;\nfloat  bb_g_fi13           = 0.0;\nfloat  bb_g_fi23           = 0.0;\n\n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n// IQ's smooth min: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// IQ's box distance function: https://iquilezles.org/articles/distfunctions\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// IQ's torus distance function: https://iquilezles.org/articles/distfunctions\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// From: http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat bb_planeIntersect(vec3 ro, vec3 rd, float mint) {\n  vec3 p = ro + rd*mint;\n  return (bb_bottom-p.y)/rd.y;\n}\n\nvec3 bb_skyColor(vec3 rd) {\n  float sunDot = max(dot(rd, bb_sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  float roundBox = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.5, 0.5),0.0))-0.1;\n  final += vec3(0.75)* pow(saturate(1.0 - roundBox*0.5), 9.0);\n  \n  final += mix(bb_skyCol1, bb_skyCol2, rd.y);\n  final += 0.5*bb_sunCol*pow(sunDot, 20.0);\n  final += 4.0*bb_sunCol*pow(sunDot, 400.0);    \n  return final;\n}\n\nfloat bb_df(vec3 p) {\n  float fi   = bb_g_fi;\n  float fo   = bb_g_fo;\n  mat2  rot  = bb_g_rot;\n  float fi13 = bb_g_fi13;\n  float fi23 = bb_g_fi23;\n  \n  float oo = mix(2.5, 0.5, fi*fo);\n  float ss = mix(0.05, 0.4, fi13*fo);\n  float rr = mix(0.125, 0.75, fi23*fo);\n  \n  vec3 p0 = p;\n  p0.y -= 0.5;\n  p0.zy *= rot;\n  p0.xy *= rot;\n  float d0 = box(p0, vec3(0.65));\n  \n  vec3 p1 = p;\n  p1.y -= oo;\n\n  float s = 1.0;\n\n  float d1 = torus(p1, s*vec2(1.0, 0.125));\n\n  vec3 c1 = vec3(0.125);\n\n  float trf = 0.75;\n  \n  for (int i = 0; i < 3; ++i) {\n    p1.xz *= rot;\n    p1.xyz = p1.zxy;\n\n    float pr = length(p1.xy);\n    float pa = atan(p1.y, p1.x);\n  \n    float n = mod1(pa, TAU/8.0);\n    \n    p1.xy = pr*vec2(cos(pa), sin(pa));\n    p1.x -= s;\n    s *= ss;\n    float dd = torus(p1, s*vec2(1.0, rr));\n\n\n    d1 = pmax(d1, -dd, 0.75*s);\n    trf = dd < d1 ? trf = 1.0-trf : trf;\n    d1 = min(d1, dd);\n  }\n  \n\n  float rf = 0.35;\n  vec3 bc = vec3(0.5);\n\n  float d = d0;\n\n  d = d0;    \n  \n  d = pmax(d, -d1, 0.1);\n\n  if (d1 < d) {\n    bc = c1;\n    rf = trf;\n    d = d1; \n  }\n\n  bb_g_refFactor = rf;\n  bb_g_baseColor = bc;\n\n  return d;\n}\n\nvec3 bb_normal(vec3 pos) {\n  vec3 eps = vec3(BB_NORM_OFF, 0.0, 0.0);\n  vec3 nor;\n  \n  nor.x = bb_df(pos+eps.xyy) - bb_df(pos-eps.xyy);\n  nor.y = bb_df(pos+eps.yxy) - bb_df(pos-eps.yxy);\n  nor.z = bb_df(pos+eps.yyx) - bb_df(pos-eps.yyx);\n  \n  return normalize(nor);\n}\n \nfloat bb_rayMarch(vec3 ro, vec3 rd, float initial, out float nearest, out int iter) {\n  float t = initial;\n\n  float n = 1E6;\n  int ii = 0;\n\n  for (int i = 0; i < BB_MAX_RAY_MARCHES; ++i) {\n    ii = i;\n    vec3 p = ro + rd*t;\n    \n    float d = bb_df(p);\n    n = min(n, d);\n    \n    if (d < BB_TOLERANCE || t >= BB_MAX_RAY_LENGTH) break;\n    \n    t += d;\n  }\n  \n  iter = ii;\n  nearest = n;\n  \n  return t < BB_MAX_RAY_LENGTH ? t : MISS;\n}\n\nfloat bb_softShadow(vec3 ps, vec3 ld, float mint, float k) {\n\n  float res = 1.0;\n  float t = mint*6.0;\n  int mat;\n  for (int i=0; i < BB_MAX_SHADOW_MARCHES; ++i) {\n    vec3 p = ps + ld*t;\n    float d = bb_df(p);\n    res = min(res, k*d/t);\n    if (res < BB_TOLERANCE) break;\n    \n    t += max(d, mint);\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 bb_render(vec3 ro, vec3 rd) { \n  vec3 finalCol = vec3(0.0);\n\n  float aggRefFactor = 1.0;\n\n  vec3 bg = bb_skyColor(rd);\n  int titer = 0;\n  int tref = 0;\n  \n  for (int rc = 0; rc < BB_MAX_REFLECTIONS; ++rc) {  \n      if (aggRefFactor < 0.05) break;\n  \n      vec3 sky = bb_skyColor(rd);\n  \n      const float mint = 0.05;\n      float tp = bb_planeIntersect(ro, rd, mint);\n\n      int iter;\n      float nearest;\n      float tm = bb_rayMarch(ro, rd, mint, nearest, iter);\n      titer += iter;\n      ++tref;\n      \n      vec3 baseColor  = bb_g_baseColor;\n      float refFactor = bb_g_refFactor;\n      \n      float shine = exp(-5.0*nearest);\n      const float shinef = 0.125;\n      const vec3 shineCol = vec3(1.25).zyx;\n      shine *= shinef;\n\n      if(tm >= MISS && tp <= 0.0) {\n        // We hit the sky\n        finalCol += aggRefFactor*mix(sky, shineCol, shine);\n        break;\n      }\n\n      vec3 p = ro + tm*rd;\n      vec3 nor = bb_normal(p);\n      float fakeAo = 1.0 - smoothstep(0.5, 1.2, float(iter)/float(BB_MAX_RAY_MARCHES));\n      \n      vec3 pp = ro + tp*rd;\n      vec2 pp1 = pp.xz;\n\n      pp1.x -= -2.0*TIME*0.5;\n      pp1 *= sqrt(0.5);\n      vec2 np1 = mod2_1(pp1);\n      \n      if (tp < tm && tp >= 0.0) {\n        // Hit plane\n        p = pp;\n        float dd = min(abs(pp1.x), abs(pp1.y));\n        baseColor = vec3(0.75)-0.25*exp(-50.0*dd);\n        refFactor = 0.8;\n        nor = vec3(0.0, 1.0, 0.0);\n        fakeAo = 1.0;\n      }\n      \n      refFactor *= pow(abs(dot(nor, rd)), 0.25);\n      vec3 ld  = normalize(bb_lightPos - p);\n      vec3 bld = normalize(bb_backLightPos - p);\n  \n          \n      float dif  = max(dot(nor, ld), 0.0);\n      float bdif = max(dot(nor, bld), 0.0);\n      float spe  = pow(max(dot(reflect(ld, nor), rd), 0.0), 40.0);\n      float sha  = bb_softShadow(p, ld, 0.1, 4.0);\n      vec3 col = 0.8*baseColor*mix(0.2, 1.0, dif*sha*fakeAo) + 0.25*spe;\n      col += baseColor*mix(0.0, 0.2, bdif);\n      col *= refFactor;\n\n      float yy = 1.0-exp(-4.0*float(iter)/float(BB_MAX_RAY_MARCHES));\n      \n      col = mix(col, shineCol, max(shine, yy*shinef));\n      // Very very random code\n      col *= mix(0.95, -1.0, abs(dot(nor,rd)));\n\n      finalCol += aggRefFactor*(col);\n\n      aggRefFactor *= (1.0 - refFactor);\n      \n      ro = p;\n      rd = reflect(rd, nor);\n  }\n\n  return finalCol;\n}\n\nvec3 bb_effect(vec2 p, vec2 q) {\n  float gtime = TIME;\n  float ltime = mod(gtime, bb_period);\n\n  bb_g_rot    = ROT(TAU*TIME*0.75/4.0);\n  bb_g_fi     = smoothstep(0.0, 1.0, ltime);\n  bb_g_fo     = 1.0-smoothstep(bb_period-1.25, bb_period-0.25, ltime);\n  bb_g_fi13   = smoothstep(bb_period*1.0/3.0-0.5, bb_period*1.0/3.0+0.5, ltime);\n  bb_g_fi23   = smoothstep(bb_period*2.0/3.0-0.5, bb_period*2.0/3.0+0.5, ltime);\n  \n  vec3 ro = 0.6*vec3(6.0, 5.0, -2.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  ro.xz *= ROT(sin(TIME*sqrt(0.3)));\n\n  vec3 la  = vec3(0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 col = bb_render(ro, rd);\n\n  return col;  \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = bb_effect(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2XWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1427, 1427, 1452, 1452, 1481], [1483, 1540, 1579, 1579, 1668], [1670, 1670, 1709, 1709, 1738], [1740, 1817, 1844, 1844, 1931], [1933, 2012, 2041, 2041, 2106], [2108, 2145, 2184, 2184, 2309], [2311, 2311, 2338, 2338, 2407], [2409, 2409, 2445, 2445, 2678], [2680, 2680, 2735, 2735, 2793], [2795, 2795, 2822, 2822, 3201], [3203, 3203, 3224, 3224, 4325], [4327, 4327, 4353, 4353, 4593], [4596, 4596, 4681, 4681, 5032], [5034, 5034, 5094, 5094, 5372], [5374, 5374, 5408, 5408, 7695], [7697, 7697, 7729, 7729, 8455], [8457, 8457, 8512, 8512, 8703]]}
{"id": "sdj3Wm", "name": "Japan diorama", "author": "z0rg", "description": "A little diorama I made inspired by a picture I saw.", "tags": ["fish", "japan", "diorama"], "likes": 29, "viewed": 715, "published": 3, "date": "1621173724", "time_retrieved": "2024-07-30T19:20:11.426303", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 chromaFlare(vec2 uv, vec2 ouv, float sz, float id)\n{\n    vec3 col;\n    \n    float c = abs(length(ouv)-.3-id*sz*8.-sz*9.)-sz;\n    vec3 rgb;\n    float a = atan(ouv.y, ouv.x)*1.;\n    float cnt = 16.;\n    for (float i = 0.; i < cnt; ++i)\n    {\n           \n        rgb += vec3(1.)*\n        (sat(.5*(sin(a*80.+iTime*10.)+sin(a*200.)+sin(a*100.))*.2+.5)*.5+.5)*\n        texture(iChannel0, vec2(.5)+((uv-vec2(.5))*(i+1.)*0.01*r2d((i-cnt/2.)*.025)*-1.*sat(length(ouv*2.)))).x;\n    }\n    col += pow((1.-sat(c*5.))*pow(rgb/cnt, vec3(1.)), vec3(1.));\n    \n    return col*.2;\n}\n\nvec3 doBloom(vec2 uv)\n{\n    vec3 acc = vec3(0.);\n    float stepAngle = 2.6;\n    for (float i = 0.; i < 16.; ++i)\n    {\n        float rad = 0.5;\n        rad = rad*sat(i/16.);\n        float angle = i * stepAngle;\n        vec2 psample = vec2(sin(angle), cos(angle))*rad;\n\n        vec3 res = texture(iChannel0, uv+psample*iResolution.xx/iResolution.xy).xyz;\n\n        acc += pow(sat(res), vec3(2.));\n\n    }\n\n    return (acc/16.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    col.xyz = pow(col.xyz, vec3(.5));\n    \n    col.xyz += doBloom(uv)*.3;\n    col.xyz += chromaFlare(uv, cuv, 0.01, 0.)*vec3(1.,0.,0.);\n    col.xyz += chromaFlare(uv, cuv, 0.01, -1.)*vec3(0.,1.,0.);\n    col.xyz += chromaFlare(uv, cuv, 0.01, -2.)*vec3(0.,0.,1.);\n\n    vec3 rgb = mix(vec3(0.176,0.443,0.463), vec3(0.996,0.459,0.365), pow(col.y, 5.));\n    \n    float an = atan(cuv.y,cuv.x);\n    col.xyz = sat((1.-(length(cuv)-.3))+sin(an*100.+iTime*10.)*.5+.7)*mix(rgb, col.xyz, pow(1.-sat((length(cuv*1.))), 2.));\n    col.xyz = pow(col.xyz+.1, vec3(1.5));\n\n    fragColor = vec4(col.xyz,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27157, "src": "https://soundcloud.com/asianmeditationmusiccollective/crane-in-the-water?in=asianmeditationmusiccollective/sets/traditional-asian-music-50", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(max(l.x, l.y), l.z);\n}\n\nfloat _leave(vec3 p, float s)\n{\n    \n    return max(max(length(p)-s, -(-p.y-sin((p.x+p.z)*150.)*.2*s-.01)), -(length(p)-s*.8));\n}\n\nfloat _cyl(vec3 p, vec2 s)\n{\n    return max(length(p.xz)-s.x, abs(p.y)-s.y);\n}\nfloat smin( float a, float b, float k ) {\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 _fishp;\nvec2 fish(vec3 p, float idMat)\n{\n    float tmove = iTime*.25+idMat;\n    vec2 pos = vec2(sin(tmove), cos(tmove)*.33)*.55;\n    p.xz += pos;\n    pos = normalize(pos);\n    float a = atan(pos.x, pos.y);\n    p.xz *= r2d(a-3.1415);\n    p.xz *= r2d(sin(iTime*2.+p.x*3.)*.3);\n    p -= vec3(0.,-.3,0.);\n    float acc = 100.;\n    \n    acc = min(acc, length(p*vec3(1.,2.,3.))-.25);\n    acc = smin(acc, length(p*vec3(1.,2.,3.)-vec3(-0.25,.0,0.))-.17, .1);\n    \n    acc = min(acc, max(abs(p.y+.05)-0.001, (length(p*vec3(3.,1.,1.)-vec3(.1,0.,0.))-.25)));\n    \n    \n    vec3 ptail = p*vec3(1.,sign(p.y),1.);\n    ptail -=  vec3(-.5,0.05,0.);\n    ptail.xy *= r2d(.7);\n\n    \n    acc = smin(acc, max(abs(ptail.z)-0.001, length(ptail*vec3(1.,2.,1.))-.125), .05);\n    if (idMat != 5.)\n        _fishp = p;\n    return vec2(acc, idMat);\n}\n\nvec3 _nenupharPos;\n\nvec2 map(vec3 p, bool water)\n{\n   vec2 acc = vec2(10000.,-1.);\n   \n   \n   //acc = _min(acc, vec2(length(p-vec3(0.5,.2,.2))-.5, 1.));\n   \n   // Ground\n   float gnd = p.y+.6+texture(iChannel1, p.xz*.05).x*.07;\n   acc = _min(acc, vec2(gnd, 0.));\n   \n   // Water\n   float waterHeight = -.1+texture(iChannel2, p.xz*.0512+vec2(iTime*.01)).x*.11\n       +texture(iChannel2, p.xz*.0512+vec2(iTime*.01)*vec2(1.,-1.)).x*.08;\n   if (water)\n   {\n       acc = _min(acc, vec2(max(p.y+waterHeight,-gnd), 2.));\n   }\n   \n   // Nenuphar\n   vec3 pnenu = p-vec3(-0.3,0.03,0.4);\n   //pnenu.yz *= r2d(sin(iTime*2.)*.05);\n   _nenupharPos = pnenu;\n   float nenu = max(_cyl(pnenu, vec2(.2,.01)), -_cube(pnenu-vec2(.2, 0.).xyx, vec3(.15)));\n   nenu = max(nenu, -_cyl(pnenu-vec3(0.,0.005,0.), vec2(.19, .01)));\n   acc = _min(acc, vec2(nenu, 3.));\n   \n   vec3 pfish2 = p*vec3(-1.,1.,-1.);\n   acc = _min(acc, fish(p*1.5-vec3(.5,0.,0.), 4.));\n   acc = _min(acc, vec2(fish(pfish2*4.-vec3(1.5,-0.5,0.), 5.)));\n   \n   // Bridge\n   float bridgerep = 0.1;\n   vec3 bridgep = p-vec3(0.3,0.2,0.);\n   bridgep.x = clamp(bridgep.x, -bridgerep*.5, bridgerep*7.5);\n   bridgep.x = mod(bridgep.x+.5*bridgerep, bridgerep)-bridgerep*.5;\n   float bridgeWidth = 0.4;\n   float accbridge = _cube(bridgep, vec3(bridgerep*.35, 0.01,bridgeWidth));\n   acc = _min(acc, vec2(accbridge, 6.));\n   \n   // Bridge poles\n   vec3 ppoles =p-vec3(0.3,-0.4,0.);\n   ppoles.z = abs(p.z)-bridgeWidth;\n   float poles = _cyl(ppoles, vec2(.05,1.));\n   acc = _min(acc, vec2(poles, 7.));\n   \n   // Bridge plates\n   float plates = _cube(ppoles-vec3(0.55,.6,0.), vec3(.5,.05,.01));\n   acc = _min(acc, vec2(plates, 8.));\n   \n   // Bridge plate support\n   vec3 pplates2 = p-vec3(1.35,.15,0.);\n   pplates2.z = abs(pplates2.z)-.2;\n   float plates2 = _cube(pplates2, vec3(1.,.01,.05));\n   acc = _min(acc, vec2(plates2, 9.));\n   \n   float repleaves = 0.1;\n   vec3 pleaves = p+vec3(iTime*.2, 0., iTime*.1);\n   vec2 idxLeave = floor((pleaves.xz+repleaves*.5)/repleaves);\n   pleaves.xz = mod(pleaves.xz+repleaves*.5, vec2(repleaves))-repleaves*.5;\n    \n   pleaves.xz += (texture(iChannel1, idxLeave*.05).xy-.5)*.25;\n   pleaves.y += waterHeight-repleaves/4.;\n   float leaves = _leave(pleaves, repleaves/4.);\n   if (sin(idxLeave.x*.1+idxLeave.y*.25) > 0.)\n       acc = _min(acc, vec2(leaves, 10.));\n   \n   float limits = _cube(p, vec3(1.));\n   //limits = length(p)-1.5;\n   acc = vec2(max(acc.x, limits), acc.y);\n   return acc;\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps, bool water)\n{\n    vec3 p = ro;\n    for (int i =0; i < steps && distance(p, ro) < 10.; ++i)\n    {\n        vec2 res = map(p, water);\n        res = vec2(res.x, res.y);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(ro, p), res.y);\n        p+= rd * res.x*.5;\n    }\n    return vec3(-1.);\n}\n\nvec3 _normal(float d, vec3 p, bool water)\n{\n    vec2 e = vec2(0.001,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy, water).x, map(p-e.yxy, water).x, map(p-e.yyx, water).x));\n}\n\nvec3 getWoodTex(float mat, vec3 p, vec3 n, vec3 h)\n{\n    vec3 tex = sat(texture(iChannel1, p.yx*vec2(.2,1.)).x+.35)*vec3(1.);\n    n.x += (tex.x-.5)*.5;\n    //n.z += (tex.x-.5)*.1;\n    return mix(tex*vec3(0.957,0.541,0.263), tex*.25*vec3(0.588,0.176,0.090), pow(sat(dot(h,n)),.5));\n}\n\nvec3 getLeaveText(vec3 p, vec3 n, vec3 h)\n{\n    return mix(vec3(1.000,0.580,0.824), vec3(1.,1.,1.), sat(dot(n,h)));\n}\n\nvec3 getNenupharTex(vec3 p, vec3 n, vec3 h)\n{\n    float an = atan(_nenupharPos.z, _nenupharPos.x);\n    return sat(.75*mix(vec3(0.212,0.808,0.251)*sat(sin(an*20.)*.5+.5+.6), vec3(1.,1.,1.), pow(sat(dot(n,h)), 5.)));\n//_nenupharPos\n}\n\n//vec3 rdrMat(vec3 p, vec3 n\n\nvec4 rdr(vec2 uv)\n{\n    vec3 col;\n    \n    vec3 ro = camOrig(iTime);//vec3(pcam.x,2.,pcam.y);\n    vec3 ta = camTarget();//vec3(0.,-.5,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    \n    col = (texture(iChannel0, rd).xyz*.5+.5);\n\n    vec3 lpos = vec3(15.);\n    vec3 waterCol = vec3(.5,.7,.99)*.1;\n    vec3 res = trace(ro, rd, 128, true);\n    float depth = -1.;\n    if (res.y > 0.)\n    {\n        depth = res.y;\n        vec3 p = ro+rd*res.y;\n        vec3 n = normalize(cross(dFdx(p), dFdy(p)));\n        n = _normal(res.x, p, true);\n        vec3 ldir = lpos-p;\n        col = n*.5+.5;\n        if (res.z == 2.) // water\n        {\n            col = vec3(0.);\n            vec3 pwater = p;\n            vec3 nwater = n;\n            float fogsz = 1.2;\n            float fogd = fogsz;\n            \n            \n            res = trace(p, rd, 64, false);\n            if (res.y > 0.)\n            {\n                p += rd*res.y;\n                n = normalize(cross(dFdx(p), dFdy(p)));\n                \n                fogd = distance(pwater, p);\n                \n                col = (n*.5+.5)*.5;\n            }\n        if (res.z == 4.) // fish\n        {\n            \n            float secail = 0.03;\n            vec3 fishpo = _fishp;\n            _fishp = mod(_fishp+.5*secail,secail)-secail*.5; \n            col = vec3(0.925,0.576,0.816)*mix(.55,1.,(1.-sat((length(_fishp)-secail*.25)*40.)));\n            col = mix(col, 1.2*col*vec3(1.000,0.455,0.361), sat(.5+(2.*fishpo.y-.2+fishpo.x*.9)*10.));\n            col *= mix(.5, 1., pow(abs(dot(rd, n)),2.5));\n            col = sat(col);\n        }\n        if (res.z == 5.)\n        {\n            col = vec3(1.000,0.455,0.361)*mix(.5, 1., pow(abs(dot(rd, n)),.5));\n            col = sat(col);\n        }\n        if (res.z > 5. && res.z < 10.)\n        {\n            col = .25*getWoodTex(res.z, p, n, normalize(ldir+rd));\n        }\n        if (res.z == 10.)\n        {\n            col = getLeaveText(p,n,normalize(ldir+rd));\n        }\n            if (res.z == 0.)\n            {\n                col = texture(iChannel2, p.xz).xyz*.07;\n            }\n            vec3 resshadow = trace(p+n*0.01, normalize(lpos-p), 4, false);\n            if (resshadow.y < 0.)\n                col += pow(sat(dot(normalize(ldir-rd), n)), 3.1)*(1.-waterCol)*.5*sat(fogd/fogsz);\n            \n            col = mix(col, waterCol, pow(sat(fogd/fogsz), 1.9));\n            \n            col += pow(sat(dot(normalize(ldir+(pwater+ro)), nwater)), 5.1)*vec3(1.)*.75;\n            \n            vec3 refl = normalize(reflect(rd, nwater));\n            vec3 resRefl = trace(pwater, refl, 16, false);\n            if (resRefl.y<0.)\n            {\n                col += texture(iChannel0, refl).xyz*.15;\n            }\n            else\n            {\n                vec3 prefl = pwater+resRefl.y*refl;\n                if (resRefl.z>5.)\n                col += .3*getWoodTex(resRefl.z, prefl, normalize(cross(dFdx(prefl), dFdy(prefl))), normalize((lpos-prefl)+refl));\n            }\n            \n\n            \n        }\n        else if (res.z == 3.)\n        {\n            col = getNenupharTex(p, n, normalize(ldir+rd));\n        }\n        else if (res.z == 0.)\n        {\n            col = pow(texture(iChannel2, vec2(atan(p.z, p.x), p.y)*vec2(1.,4.)).x, .5)*vec3(0.314,0.263,0.129);\n        }\n        else if (res.z > 5. && res.z < 10.)\n        {\n            col = getWoodTex(res.z, p, n, normalize(ldir+rd));\n            col = sat(col);\n        }\n        if (res.z == 10.)\n        {\n            col = getLeaveText(p,n,normalize(ldir+rd));\n        }\n\n    }\n    \n    \n    return vec4(col, depth);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec4 col = rdr(uv);\n\n    col.xyz = pow(col.xyz, vec3(1./1.5));\n    col.xyz *= mix(.0,1., 1.-sat(length(uv*1.5)-.15));\n    col = sat(col);\n    col.xyz = mix(col.xyz, texture(iChannel3, fragCoord/iResolution.xy).xyz, .75*sat(col.w/2.));\n    \n    fragColor = vec4(col);\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n\nfloat tCam(float time)\n{\n    return time*0.25;\n}\nvec2 pCam(float time)\n{\n    return vec2(sin(tCam(time)), cos(tCam(time)))*5.;\n}\nvec3 camOrig(float time)\n{\n    return vec3(pCam(time).x,2.,pCam(time).y);\n}\nvec3 camTarget()\n{\n    return vec3(0.,-.5,0.);\n}\n\n#define sat(a) clamp(a, 0., 1.)\n\nfloat lenny(vec2 v)\n{\n    return abs(v.x)+ abs(v.y);\n}\nmat2 r2d(float a) { float c= cos(a), s = sin(a); return mat2(c, -s, s, c); }\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 1.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*-uv.y));\n}\n/*\n    float tcam = iTime*.5;\n    vec2 pcam = vec2(sin(tcam), cos(tcam))*5.;\n    \n    vec3 ro = camOrig();//vec3(pcam.x,2.,pcam.y);\n    vec3 ta = camTarget();//vec3(0.,-.5,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    */", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdj3Wm.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 966], [968, 968, 991, 991, 1394], [1397, 1397, 1454, 1454, 2202]]}
{"id": "Ns2XD3", "name": "Day 514", "author": "jeyko", "description": "potate", "tags": ["mdtmjvm", "kurzgesagt"], "likes": 27, "viewed": 423, "published": 3, "date": "1621171355", "time_retrieved": "2024-07-30T19:20:12.478489", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    float pxSz = fwidth(uv.y);\n    \n    vec3 col = vec3(0);\n    \n    float sunH =  + sin(iTime*0.4)*0.1;\n    \n    float sunM = sunH*4. + 0.4;\n    col = mix(vec3(0.4,0.23,0.1 + sunM*0.)*4.4,vec3(0.2 - sunH*0.6,0.3+ sunH*0.4,0.5)*1.,smoothstep(0.,1.,uv.y*0.8 +0.5));\n    \n    {      \n        // sun\n        vec2 p = uv - vec2(0.1,+0.1+sunH*1.4);\n        float d = length(p) - 0.2;\n        float sh = smoothstep(0.5,0.0,abs(d));\n        \n        #define smm(a)  sin(a + sin(a))*0.05\n\n        col = mix(col, col*0.5*vec3(1,1,0.) + vec3(1. ,0.5,0.5)+ sin(d*2.)*sh * vec3(0.6,0.5,1.)*1.,smoothstep(fwidth(d),0.,d - 0.1 + smm(iTime))*0.4);\n        col = mix(col, col*0.5*vec3(1,1,0.) + vec3(1. ,0.6,0.5)+ sin(d*4.)*sh * vec3(0.6,0.5,1.)*1.,smoothstep(fwidth(d),0.,d - 0.2 + smm(iTime + 0.4))*0.12);\n        \n        col = mix(col,vec3(1. ,0.6,0.5)*1.5+ 1.*sin(-d*2.)*sh * vec3(0.6,0.5,1.)*1.,smoothstep(fwidth(d),0.,d+ smm(iTime + 0.1)*0.6));\n        \n        {\n            p *= 1. + smm(iTime)*3.;\n            float sm = sin(iTime)*0.02;\n            //p *= rot(sm*14. + iTime + sin(iTime) + pi);\n            //p *= rot( (iTime + sin(iTime))*float(mod(iTime,pi*8.)<pi*2.));\n            //p*= rot(sin(iTime)*float(mod(iTime,pi) < pi));\n            p*= rot((sin(iTime))*smoothstep(-0.5,1.,sin((iTime/2. + pi/2.))));\n            \n            \n            d = sdSegment( p - vec2(0,-0.05 + sin(p.x/0.1*pi/3. - pi/2.)*0.05), vec2(-0.1 + sm,0.),vec2(0.05+sm,0.) )-0.01;\n            p.x = abs(p.x);\n            p.x -= 0.15;\n            d = min(d,length(p)-0.03);\n            \n            col = mix(col,col*vec3(0.5,0.3,0.3)*2.,smoothstep(fwidth(d),0.,d));\n        \n        }  \n    }\n    {\n        // clouds\n        for(float cl = 0.; cl < 14.; cl++){\n        \n            float sc = 1.2;\n            float sl = 0.02*iTime*(1. + sin(cl*20.)*0.9);\n            float slid = floor(sl);\n            vec2 p = uv + vec2(0. + mod(sl,1.)*4. - 2.,sin(slid*15. + cl)*0.2 - 0.4);;\n            p *= sc;\n            p.x *= 0.9;\n            p *= rot(-0.32);\n            float d = 10e5;\n            //d = min(d, sdSegment( p + vec2(0,0.1), vec2(-0.1,0.), vec2(0.2,0. )) - 0.05);\n            for(float i = 0.; i < 2.; i++){\n                vec2 q = p;\n                float rad = 0.1 + sin(i)*0.04;\n                float rep = 2.;\n                float id = pModPolar(q, rep);\n                d = min(d, (length(q) - rad)/sc);    \n            \n                d = min(d,(length(q - vec2(0.1,0.)) - rad*0.5 - sin(id*20. + iTime + cos(id)*0.)*0.05*rad)/sc); \n                p *= rot(-0.05 + cl*11. + sin(i + cos(cl))*0.4);\n                p -= vec2(0.1,0.);\n             }\n             vec2 dd = vec2(dFdx(d),dFdy(d));\n             \n             float sh = smoothstep(0.1,0.0,abs(d))*0.1;\n             \n             //col = mix(col,col*1.*vec3(0.4,0.5,1),smoothstep(0.1,0.,d)*0.2);\n             \n             //col = mix(col,vec3(1.,0.59,0.44 + sin(uv.y*2. + d*10.)*0.1)*1.5,smoothstep(fwidth(d),0.,d)*0.8);\n             /*\n             col = mix(col,vec3(\n                 0.7 + sin(dd.x*21. + dd.y*10.)*4.*sh,\n                 0.2- sin(-dd.y*20.)*1.*smoothstep(0.0,0.0,abs(d)),\n                 0.34)*0.44,smoothstep(fwidth(d),0.,d));\n             */\n        }\n        \n    }\n    \n    {\n        // birbs\n        for(float cl = 0.; cl < 54.; cl++){\n        \n            float sc = 1.2;\n            float sl = 0.05*iTime*(1. + sin(cl*25.1)*0.2);\n            float slid = floor(sl);\n            vec2 p = uv + vec2(0. + mod(sl,1.)*4. - 2.,sin(slid*15. + cl)*0.2 - 0.3);;\n            p *= sc;\n            //p.x *= 0.9;\n            float d = 10e5;\n            //d = length(p) - 0.02;\n            float w = 0.02; float ww = 0.005;\n            //p.x = abs(p.x);\n            float m =  sin(cl + iTime*4.)*0.3;\n            float mm =  sin(cl + iTime*4. - 2.4)*0.3;\n            \n            p.y -= mm*0.1;\n            p *= rot(m);\n            \n            d = min(d,sdSegment( p, vec2(0.0,0.), vec2(w,0.) ) - ww);\n            p *= rot(-m*2.- pi);\n            \n            d = opSmoothUnion( d, sdSegment( p, vec2(0,0.), vec2(w,0.) ) - ww, 0.01 );\n\n            \n            //for(float i = 0.; i < 2.; i++){\n                //p.x = -p.x;\n                \n            \n            //}\n            \n            vec2 dd = vec2(dFdx(d),dFdy(d));\n            \n            \n            float sh = smoothstep(0.1,0.0,(d))*0.1;\n            col = mix(col,0.25+0.5*col*vec3(0.4,0.6,0.9)*1.,smoothstep(fwidth(d),0.,d));\n        \n        }\n        \n    }\n    \n    {\n        for(float cl = 0.; cl < 14.; cl++){\n        \n            float sc = 1.2;\n            float sl = 0.02*iTime*(1. + sin(cl*204.124)*0.5);\n            float slid = floor(sl);\n            vec2 p = uv + vec2(0. + mod(sl,1.)*4. - 2.,sin(slid*15. + cl)*0.2 - 0.4);;\n            p *= sc;\n            //p.x *= 0.9;\n            //p *= rot(-0.32);\n            float d = 10e5;\n            d = min(d, sdSegment( p + vec2(0,0.), vec2(-0.1,0.), vec2(0.2,0. )) - 0.05);\n            for(float i = 0.; i < 1.5 + sin(cl)*2.; i++){\n                p -= vec2(0.,0.1);\n             \n                vec2 q = p;\n                float cd =  sdSegment( p, vec2(-0.+ sin(i + cl*20.)*0.4,0.), vec2(0.2+ sin(i*20. + cl*4.)*0.4,0. )) - 0.05;\n                \n                d = opSmoothUnion(d, cd, 0.05 );\n\n                //d = min(d,);\n                \n            }\n            \n            //col = mix(col,col*1.*vec3(0.4,0.5,1),smoothstep(0.1,0.,d)*0.2);\n            col = mix(col,vec3(1.,0.59,0.44 + sin(uv.y*2. + d*10.)*0.1)*1.5,smoothstep(fwidth(d),0.,d)*0.8);\n             \n            /*\n             col = mix(col,vec3(\n                 0.7 + sin(dd.x*21. + dd.y*10.)*4.*sh,\n                 0.2- sin(-dd.y*20.)*1.*smoothstep(0.0,0.0,abs(d)),\n                 0.34)*0.44,smoothstep(fwidth(d),0.,d));\n             */\n        }\n        \n    }\n    {\n       for(float cl = 0.; cl < 14.; cl++){\n        \n            /*\n             col = mix(col,vec3(\n                 1. + smoothstep(fwidth(d),0.,d - dd.x*4. - 2.*dd.y)*0. ,\n                 0.59,\n                 0.44 + sin(uv.y*2. + d*10.)*0.1)*1.5,smoothstep(fwidth(d),0.,d)*0.8);\n             */\n             /*\n             col = mix(col,vec3(\n                 0.7 + sin(dd.x*21. + dd.y*10.)*4.*sh,\n                 0.2- sin(-dd.y*20.)*1.*smoothstep(0.0,0.0,abs(d)),\n                 0.34)*0.44,smoothstep(fwidth(d),0.,d));\n             */\n        }\n    }\n    \n    \n    {\n        #define pmod(p,a) mod(p,a) - 0.5*a\n        \n        float cnt = 19.;\n        float h = 0.7 ;\n        #define tsin(a) mix(sin(a),asin(sin(a)),0.8)\n            \n        {\n            vec2 p = uv + vec2(0,-0.3 + h);\n            float tm = p.x*3.  + iTime*0.15;\n            \n            \n            //#define geth(tm) (tsin(tm + tsin(tm*1.)))*0.1 - 0.2 + tsin(tm*5.)*0.02\n            #define geth(tm) ((sin(tm + sin(tm*1.)))*0.1 - 0.2 + sin(tm*5.)*0.02)\n            \n            //float d = p.y + (tsin(tm*2. + tsin(tm*3.)*0.5 + cos( + tm*2.)*2.)*0.1 + tsin(tm*1.5)*0.2)*0.4 - 0.3;\n            \n            float d = p.y + geth(tm);\n            \n            for(float i = 0.; i <4.; i++){\n                p = uv + vec2(0,-0.3 + h);\n            \n                float md = 0.4 + sin(i)*0.1;\n                float id = floor(tm/md)*md + 0.5*md;\n\n                float hh = geth(id);\n\n                p.x = pmod(tm,md);\n                p.x /= 3.;\n                float s = - 0.024 + sin(id*20. + i*20.)*0.01;\n                d = min(d, length(p + vec2(0,hh + 0.01)) +s);\n            \n            }\n            \n            \n            \n            col = mix(col,vec3(0.2 ,0.4 + sin(d*1.5)*0.4,0.34)*1.4,smoothstep(fwidth(d),0.,d));\n            \n        }\n        for(float terr = 0.; terr < cnt; terr++){\n            float terrIdx = terr/cnt;\n            vec2 p = uv + vec2(0,0.3 + terrIdx*h);\n            \n            float tm = p.x*1. + terrIdx + iTime*(1. + terrIdx*0.)*.1 ;\n            tm += sin(tm*2. + terrIdx*8.)*1.4;\n            #define gethb(tm) (sin(tm*1.+ terrIdx*18. + sin(tm*3.)*0.5 + cos( + tm*2.+ terrIdx*5.)*2.)*0.1 + sin(tm*1.5 + terrIdx*5.)*0.2)*0.24\n\n            float d = p.y + gethb(tm);\n            //float d = p.y + (sin(tm*2. + tsin(tm*3.)*0.5 + cos( + tm*2.)*2.)*0.1 + tsin(tm*1.5)*0.2)*0.4;\n            \n            if(terr>=0.){\n                vec2 q = p;\n                //float tm = p.x*3.  + iTime*0.15;\n            \n            \n                //#define geth(tm) (tsin(tm + tsin(tm*1.)))*0.1 - 0.2 + tsin(tm*5.)*0.02\n                //#define geth(tm) ((sin(tm + sin(tm*1.)))*0.1 - 0.2 + sin(tm*5.)*0.02)\n\n                //float d = p.y + (tsin(tm*2. + tsin(tm*3.)*0.5 + cos( + tm*2.)*2.)*0.1 + tsin(tm*1.5)*0.2)*0.4 - 0.3;\n\n                float db = p.y + gethb(tm);\n                \n                \n                \n                for(float i = 0.; i <1.; i++){\n                    p = uv + vec2(0,0.3 + terrIdx*h);\n                    float ltm = tm + sin(i + terr*20.);\n                    float md = 0.2 + sin(i+ terr*0.3)*0.5;\n                    float id = floor(ltm/md)*md + 0.5*md;\n\n                    float hh = gethb(id);\n                    \n                    p.x = pmod(ltm,md);\n                    p.x += sin(id)*md*0.1;\n                    \n                    \n                    float s = - 0.034 + sin(id*20. + i*20.)*0.03;\n                    p += vec2(0,hh );\n                    db = min(db, length(p) +s);\n                \n                    for(float j = 0.; j < 0.; j++){\n                        vec2 q = p;\n                        float rep = 1. + floor(sin(id + i*20.)*2.4);\n                        float idb = pModPolar(q, rep);\n                        q.x -= 0.02 + sin(idb*15. + j*20.)*0.035;\n                        p *= rot(2.5 + sin(j + i));\n                        db = min(db, length(q + vec2(0,0))-0.028 + sin(idb + id)*0.0);\n                \n                    }\n                    //db = min(db, length(p + vec2(0,hh -0.1)) +s);\n                    p=q;\n                }\n                \n                //col = mix(col,0.2*vec3(0.5 + sin(terrIdx*14.)*0.4,0.4 + sin(d*2.5)*0.4,0.34 + sin(d*4.5)*0.2)*1.4,smoothstep(fwidth(d),0.,db));\n                //col = mix(col,vec3(0.3 + sin(terrIdx*24.)*0.1 ,0.4 + sin(d*1.5)*0.4,0.34)*1.4,smoothstep(fwidth(db),0.,db));\n                \n                //col = mix(col,vec3(0.5 + sin(terrIdx*24.)*0.3,0.4 + sin(d*2.5)*0.2,0.34 + sin(d*4.5)*0.2)*1.4,smoothstep(fwidth(db),0.,db));\n            \n                \n            }\n            \n            col = mix(col,vec3(0.5 + sin(terrIdx*24.)*0.3,0.4 + sin(d*2.5)*0.2,0.34 + sin(d*4.5)*0.2)*1.4,smoothstep(fwidth(d),0.,d));\n            \n        }\n        \n        /*\n        vec2 p = uv + vec2(0,0.2);\n            \n        float tm = p.x*2. + iTime*(1.)*.2 ;\n            //tm += sin(tm*2.)*1.6;\n        p.y = p.y + (sin(tm*2. + sin(tm*3.)*0.5 + cos( + tm*2.)*2.)*0.1 + sin(tm*1.5)*0.2)*0.1 - 0.2;\n        \n        \n        float md = 1.;\n        float id = floor(p.x/md);\n        p.x += iTime + sin(iTime);\n        p.x = mod(p.x,md) - 0.5*md;\n        \n        float  d = sdSegment( p + vec2(sin(iTime+md)*0.1,0.), vec2(-0.2,0.), vec2(0.2,0.)) - 0.01;\n        */\n        /*\n        col = mix(col,vec3(\n                 1. ,\n                 0.59,\n                 0.44 + sin(uv.y*2. + d*10.)*0.1)*1.5,smoothstep(fwidth(d),0.,d)*0.8);\n          */   \n    }\n    \n    //col = vec3(1.,0.98,1.) - col*vec3(.5,0.8,1.);\n    \n    \n    \n    //col *= vec3(1,0.9,1.15);\n    col = pow(col,vec3(1.1,1.15,1.2));\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi acos(-1.)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define iTime (iTime + 120.)*2.\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*pi/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2XD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 11735]]}
{"id": "7sSXWc", "name": "Simpler Cubic Solver", "author": "oneshade", "description": "Implementing the general formula for all real and complex roots. Its a LOT simpler.", "tags": ["simple", "complex", "solver", "cubic", "roots"], "likes": 10, "viewed": 227, "published": 3, "date": "1621150343", "time_retrieved": "2024-07-30T19:20:13.237460", "image_code": "// Implementing general formula from https://en.wikipedia.org/wiki/Cubic_equation\nconst vec2 eta = vec2(-0.5, sqrt(0.75)); // = (-1 + sqrt(-3))/2 = -cos(π/3) + sin(π/3)i\nvoid solveCubic(in float a, in float b, in float c, in float d, inout vec2[3] roots) {\n    b /= a, c /= a, d /= a;\n    float d0 = b * b - 3.0 * c;\n    float d1 = (2.0 * b * b - 9.0 * c) * b + 27.0 * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) + abs(C.y) < 1e-3) C = vec2(d1 - j, 0.0);\n    float t = atan(C.y, C.x) / 3.0, r = pow(0.25 * dot(C, C), 1.0 / 6.0);\n    C = vec2(cos(t), sin(t));\n\n    vec4 k = C.xyxy * eta.xxyy;\n    float h = d0 / r, w = -h - r, wi = h - r;\n    roots[0] = vec2(       C.x  * w - b,        C.y  * wi) / 3.0;\n    roots[1] = vec2((k.x - k.w) * w - b, (k.y + k.z) * wi) / 3.0;\n    roots[2] = vec2((k.x + k.w) * w - b, (k.y - k.z) * wi) / 3.0;\n}\n\n// Coloring code from @mla (https://www.shadertoy.com/view/tlVcD3)\n// I've fixed a minor mistake in the evaluation\nvec2 cmul(in vec2 z, in vec2 w) { return z * mat2(w.x, -w.y, w.yx); }\nvec2 cpoly3(in vec2 x, in float a, in float b, in float c, in float d) {\n    return a * cmul(x, cmul(x, x)) + b * cmul(x, x) + c * x + vec2(d, 0.0);\n}\n\nvec3 hsv2rgb(in float h, in float s, in float v) {\n    vec3 rgb = clamp(abs(mod(h * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb); // cubic smoothing       \n    return v * mix(vec3(1.0), rgb, s);\n}\n\nvec3 polycolor(in vec2 z) {\n    vec2 z0 = z;\n    float h = 0.5 + 0.5 * atan(z.y, z.x) / 3.14159265;\n    vec3 col = hsv2rgb(h, 1.0, sqrt(1.0 / (1.0 + length(z))));\n    z -= floor(z);\n    z = min(z, 1.0 - z);\n    col *= mix(0.5 + 0.5 * smoothstep(0.0, 0.1, min(z.x, z.y)), 1.0, min(1.0, length(z0) / 20.0));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n\n    // Coefficients\n    float a = sin(iTime * 0.25) * 2.0;\n    float b = sin(iTime * 0.5);\n    float c = cos(iTime * 0.75) * 2.0;\n    float d = sin(iTime);\n\n    vec3 color = polycolor(cpoly3(uv, a, b, c, d));\n\n    // Draw function\n    float f = a * uv.x * uv.x * uv.x + b * uv.x * uv.x + c * uv.x + d;\n    float g = 3.0 * a * uv.x * uv.x + 2.0 * b * uv.x + c; // Derivative for DE\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(uv.y - f) / sqrt(1.0 + g * g)));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, abs(uv.y)));\n\n    // Draw roots\n    vec2[3] roots;\n    solveCubic(a, b, c, d, roots);\n    for (int n=0; n < 3; n++) {\n        color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - roots[n]) - 0.05));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSXWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[936, 1051, 1084, 1084, 1120], [1121, 1121, 1193, 1193, 1271], [1273, 1273, 1323, 1323, 1521], [1523, 1523, 1550, 1550, 1846]]}
{"id": "7sBSWc", "name": "Paper Dance", "author": "pugbyte", "description": "Do the paper dance.", "tags": ["2d"], "likes": 5, "viewed": 269, "published": 3, "date": "1621147808", "time_retrieved": "2024-07-30T19:20:13.991444", "image_code": "mat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy + 0.5;\n\n    // softly zoom\n    uv *= mix(0.8, 2.0, sin(iTime*0.2+(4.14))*0.5+0.5);\n    \n    // softly rotate\n    uv *= rot(mix(-5., -6., sin(-iTime*0.102)*0.5+0.5));\n\n    // varying everything with noise and time is good right?! :D\n    float PI = mix(3.14, 4.28, texture(iChannel0, vec2(iTime*0.01,0.)).x);\n\n    vec3 col = vec3(uv.y);\n    \n    float offx = iTime*3.0;\n    float offy = cos(uv.x*5.-iTime)*2.0;\n    offy += iTime*5.0;\n    \n    float x = uv.x*PI*4.+offx;\n    float y = uv.y*PI*4.+offy;\n    \n    col = vec3(0.2);\n    col = mix(col, vec3(0.9,.9,.9), ceil(cos(x-iTime))    * ceil(cos(y)));\n    col = mix(col, vec3(0.9,.7,.7), ceil(cos(x+PI+iTime)) * ceil(cos(y+PI)));\n    col = mix(col, vec3(0.9,.3,.4), ceil(cos(y-iTime))    * ceil(cos(x)));\n    col = mix(col, vec3(0.5,.2,.6), ceil(cos(y+PI+iTime)) * ceil(cos(x+PI)));\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBSWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 95], [97, 97, 154, 204, 1163]]}
{"id": "ssSXD3", "name": "hehe - a typography shader", "author": "blackle", "description": "a shader I wrote while live coding among friends", "tags": ["letters", "hehe", "words"], "likes": 49, "viewed": 901, "published": 3, "date": "1621134579", "time_retrieved": "2024-07-30T19:20:14.843167", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat corner(vec2 p) {\n  return length(max(p,0.))+min(0.,max(p.x,p.y));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat h_(vec2 p) {\n  float l1 = linedist(p, vec2(0,-.75), vec2(0,-10)) - 1.5;\n  float l2 = linedist(p, vec2(0,-.5), vec2(0,-10)) - .5;\n  float l3 = linedist(p, vec2(-1,10), vec2(-1,-10)) - .5;\n  float ud = abs(p.y)-2.5;\n  return corner(vec2(ud,min(max(l1,-l2),l3)));\n}\n\nfloat e_(vec2 p) {\n  float l1 = linedist(p, vec2(0,-.75), vec2(0,-1.)) - 1.5;\n  float l2 = linedist(p, vec2(0,-.5), vec2(0,-1.25)) - .5;\n  float l3 = linedist(p, vec2(-1,-.65), vec2(1,-.65)) - .25;\n  float ho = linedist(p, vec2(.45,-1.05), vec2(10,-1.05)) - .15;\n  return corner(vec2(min(max(l1,-l2),l3),-ho));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat profile(vec2 p, float stronch) {\n  return corner(vec2(abs(p.x)-stronch-.3,p.y+.05))-.05;\n}\n\nvec3 gploc;\nfloat letter(vec3 p, bool e, float off) {\n  p.z += sin(iTime*3.+off)*.2;\n  p = erot(p,vec3(0,1,0),cos(iTime*4.+off)*.1);\n  p = erot(p,vec3(0,0,1),sin(iTime*4.+off)*.1);\n  p.x += sin(iTime*4.7+off);\n  \n  float x = iTime*(5.+sin(off)*.5)+off;\n  float stronch = (sin(x)*.5+.5+sin(x*3.)*.2)*3.;\n  \n  gploc = p * vec3(1./(stronch+.35),1,1);\n  vec2 h = vec2(p.x,e ? e_(p.yz) : h_(p.yz));\n  return profile(h, stronch);\n}\n\nint gid;\nvec3 ggploc;\nfloat scene(vec3 p) {\n  p -= vec3(0,-1.2,0);\n  float h1 = letter(p-vec3(1,-3,0),false,.4);\n  ggploc = gploc;\n  gid = 0;\n  float e1 = letter(p,true,2.9);\n  if (e1 < h1) {\n    \n  ggploc = gploc;\n    gid = 1;\n    h1 = e1;\n  }\n  float e2 = letter(p-vec3(0,6,0),true,5.9);\n  if (e2 < h1) {\n    gid = 2;\n  ggploc = gploc;\n    h1 = e2;\n  }\n  float h2 = letter(p-vec3(1,3,0),false,4.2);\n  if (h2 < h1) {\n    gid = 3;\n  ggploc = gploc;\n    h1 = h2;\n  }\n  return h1;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n  bool ise =  sin(iTime*5.)>0.;\n  \n  vec3 cam = normalize(vec3(2,uv));\n  vec3 init = vec3(-18.+sin(iTime*3.5)*3.,0,0);\n  \n  float yrot = sin(iTime)*.4;\n  float zrot = cos(iTime*5.5)*.4;\n  float xrot = sin(iTime*2.)*.3;\n  cam = erot(cam,vec3(1,0,0),xrot);\n  init = erot(init,vec3(0,1,0),yrot);\n  cam = erot(cam,vec3(0,1,0),yrot);\n  init = erot(init,vec3(0,0,1),zrot);\n  cam = erot(cam,vec3(0,0,1),zrot);\n  init.z += sin(iTime*5.)*.4;\n  \n  vec3 p = init;\n  bool hit = false;\n  bool inside = false;\n  float trigdist = .05;\n  for (int i = 0; i < 150 && !hit; i++) {\n    float dist = scene(p);\n    p += cam*dist;\n    hit = dist*dist < 1e-6;\n    if (dist < trigdist) { \n      inside = true;\n    }\n    if (inside && dist > trigdist) break;\n    if (distance(p,init) > 50.) break;\n  }\n  vec3 ploc = ggploc;\n  float id = float(gid);\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float fact = length(sin(r*4.2)*.5+.5)/sqrt(3.);\n  float diff = length(sin(n*2.9)*.4+.6)/sqrt(3.);\n  float fres = 1. - abs(dot(cam,n))*.98;\n  float spec = (fact*.05 + pow(fact,8.)*2.)*fres;\n  vec3 diffcol = vec3(0.7,.1,.05);\n  diffcol = erot(diffcol,n,.2);\n  diffcol = erot(diffcol,normalize(sin(n*6.)),.2);\n  diffcol = min(max(erot(diffcol,normalize(vec3(1,2,3)),id+floor(iTime*3.))*.8+.5,0.05),.9);\n  if (dot(sin(erot(ploc,normalize(vec3(1,1,1)),.6*id)*20.),vec3(1)) > 0.5) diffcol = pow(fact,4.)*diffcol*10.;\n  vec3 col = diff*diffcol+spec*mix(diffcol,vec3(1),.5);\n  float ang = atan(uv.x,uv.y);\n  float bg = sin(ang*10.+iTime*2.);\n  ang += iTime;\n  vec3 rainbow = vec3(sin(ang),sin(ang+3.14/3.),sin(ang+3.14*2./3.))*.4+.6;\n  bg = smoothstep(fwidth(bg),0.,bg);\n  float circ = length(uv)-.4;\n  circ = smoothstep(fwidth(circ),0.,circ);\n  vec3 bgcol = vec3(mix(rainbow,vec3(1),bg));\n  \n  vec3 fancycol = vec3(0.7,.1,.05);\n  fancycol = min(max(erot(fancycol,normalize(vec3(1,2,3)),9.+floor(iTime*3.)*1.3)*.8+.5,0.05),.9);\n  bgcol = mix(bgcol,fancycol,circ);\n  fragColor.xyz = hit ? col : bgcol;\n  if (inside && !hit) fragColor.xyz = vec3(0);\n  fragColor *= 1.-dot(uv,uv)*.3;\n  fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSXD3.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 216, 216, 267], [269, 269, 309, 309, 396], [398, 398, 416, 416, 666], [668, 668, 686, 686, 980], [982, 982, 1020, 1020, 1080], [1082, 1082, 1120, 1120, 1178], [1192, 1192, 1233, 1233, 1605], [1629, 1629, 1650, 1650, 2087], [2089, 2089, 2108, 2108, 2224], [2226, 2226, 2283, 2283, 4418]]}
{"id": "7dSXD3", "name": "Fuild border effect", "author": "zlnimda", "description": "Trying to give a fuild effect on border of a video.\nPOC for stream overlay.", "tags": ["border"], "likes": 4, "viewed": 408, "published": 3, "date": "1621133543", "time_retrieved": "2024-07-30T19:20:15.602137", "image_code": "/* ----------------------------------------------------------------------------\n * \"THE BEER-WARE LICENSE\" (Revision 42):\n * zlnimda (Nimda@zl) wrote this file.  As long as you retain this notice you\n * can do whatever you want with this stuff. If we meet some day, and you think\n * this stuff is worth it, you can buy me a beer in return.\n * ----------------------------------------------------------------------------\n */\n\n// The following functions has been borrowed from iq // Copyright © 2020 Inigo Quilez\n// under MIT License\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n// END of MIT License \n\n\nfloat border(vec2 uv, float t, vec2 ratio)\n{\n    vec2 p = uv.yx + vec2(-1.f, 1.f) * sign(uv) * t;\n    p *= 64.f;\n    p = vec2(cos(p.x), sin(p.y));\n    p *= 0.01f;\n    uv += p;\n    \n    float d = sdBox(uv, ratio * 0.39);\n    float v = smoothstep(0.01f, 0.f, d);\n    \n    return clamp(v, 0.f, 1.f);\n}\n\nfloat fuilds(vec2 uv, float t, vec2 ratio)\n{\n    vec2 p = uv;\n    // p move over time\n    float s = sin(t) * 0.5f, c = cos(t) * 0.5f;\n    p += vec2(t - s + c, t + s - c);\n    // p scaled\n    p *= 16.f;\n    \n    // noise get from p\n    float n = noise(p) * 16.0f;\n    \n    \n    float d = sdBox(uv, ratio * 0.4);\n    d = smoothstep(0.03f, 0.f, d);\n    n *= d;\n    \n    n = pow(n, 6.f);\n    \n    return clamp(n, 0.f, 1.f);\n}\n\nfloat mask(vec2 uv, float t)\n{\n    vec2 ratio = iResolution.xy/max(iResolution.x,iResolution.y);\n    uv -= 0.5; // centered\n    uv *= ratio; // keep aspect ratio\n\n    float mask = 0.f;\n    mask += border(uv, t, ratio);\n    mask += fuilds(uv , t, ratio);\n    \n    return clamp(mask, 0.f, 1.f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = iTime * 0.2f;\n    float mask = mask(uv, t);\n    \n    vec4 col = texture(iChannel0, uv);\n    col.xyz *= mask;\n\n    // Output to screen\n    fragColor = vec4(col.xyz,mask);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSXD3.jpg", "access": "api", "license": "beerware", "functions": [[425, 533, 570, 570, 650], [652, 652, 672, 672, 776], [778, 778, 804, 804, 1098], [1124, 1124, 1168, 1168, 1422], [1424, 1424, 1468, 1468, 1845], [1847, 1847, 1877, 1877, 2141], [2144, 2144, 2201, 2251, 2478]]}
{"id": "NdBSDc", "name": "Eye of the Infinite", "author": "pugbyte", "description": "Just a beginner messing around with radial coordinates. It started to look like an eye at some point so I just ran with it.", "tags": ["beginner"], "likes": 10, "viewed": 468, "published": 3, "date": "1621116558", "time_retrieved": "2024-07-30T19:20:16.351135", "image_code": "#define M_PI 3.14159\n\nvec2 getRadialUv(vec2 uv) {\n    float angle = atan(uv.x, uv.y);\n\n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (M_PI * 2.0) + 0.5;\n    radialUv.y = length(uv);\n\n    return radialUv;\n}\n\nfloat lid(float x, float openess) {\n    //return cos(x) * abs(sin(iTime*2.0));\n    return cos(x) * openess;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Start at an interesting time where the eyelids are moving frequently\n    float time = iTime + 48.0;\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * 2.0;\n    \n    // Move the whole eye around sporadically\n    float eye_move = sin(texture(iChannel0, vec2(time*0.004)).x-0.5);\n    float eye_move_y = sin(texture(iChannel0, vec2((time+20.0)*0.004)).x-0.5);\n    //uv += vec2(eye_move,0.0);\n    \n    \n    // displace the coordinates using interesting texture\n    float displacement = texture(iChannel0, uv).x*0.1;\n    \n    vec2 uv_anim = uv + vec2(eye_move*1.9+displacement, eye_move_y);\n\n    vec2 radialUv = getRadialUv(uv_anim);\n    \n    float warpedX = fract(radialUv.x - (time*2.0 - radialUv.y*5.0));\n    float warpedY = radialUv.y;\n\n    vec3 color = vec3(warpedX, warpedY, 1.0);\n    \n    float pupil_size = texture(iChannel1, vec2((time-0.3)*0.01)).x*0.5;\n    //pupil_size = 0.1;\n    float pupil = 1.0 - smoothstep(pupil_size, pupil_size + 0.02, radialUv.y);\n    color = mix(color, vec3(.1,.1,.2), pupil);\n    \n    color = mix(color, vec3(.4,.1,.1), min(1.,pow(warpedY*0.6, 8.0)));\n\n    // form the eye lids\n    float lidedge = displacement*0.5;\n    float openess = texture(iChannel1, vec2(time*0.011)).x-0.5;\n    openess *= 2.0;\n    openess = 0.7-clamp(openess, 0.0, 0.7);\n    \n    float lid_move = eye_move*0.5;\n    //lid_move = 0.0;\n    \n    float ulidy = lid(uv.x+lid_move, openess);\n    float upperLid = smoothstep(ulidy-lidedge, ulidy, uv.y);\n    \n    float llidy = -lid(uv.x+lid_move, openess);\n    float lowerLid = 1.0-smoothstep(llidy, llidy+lidedge, uv.y);\n    \n    vec3 lidColor = vec3(.1,.1,.2);\n    vec3 lidHighlight = vec3(0.);\n   \n    \n    float dist = uv.y+0.5 - ulidy;\n    float wrinkles = 30.*(0.5-dist);\n    vec3 upperLidColor = mix(lidColor, lidHighlight, sin(uv.y*wrinkles-lidedge*20.0));\n    \n    dist = abs(uv.y-0.39 - llidy);\n    wrinkles = 30.*(0.5-dist);\n    vec3 lowerLidColor = mix(lidColor, lidHighlight, sin(uv.y*wrinkles-lidedge*20.0));\n    \n    color = mix(color, lowerLidColor, lowerLid);\n    color = mix(color, upperLidColor, upperLid);\n    \n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBSDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 49, 49, 215], [217, 217, 252, 295, 326], [328, 328, 385, 461, 2531]]}
{"id": "wsKXDh", "name": "Butterfly (2004)", "author": "iq", "description": "A procedural butterfly I made back in 2004 for the realtime 64 kilobyte demo [url=https://www.pouet.net/prod.php?which=12821]Paradise[/url]. You can see the butterfly in the rhino sequence: [url]https://www.youtube.com/watch?v=JY9FzRwasjw&t=274s[/url]", "tags": ["procedural", "2d", "demoscene", "butterfly", "paradise"], "likes": 44, "viewed": 1214, "published": 3, "date": "1621114208", "time_retrieved": "2024-07-30T19:20:17.138031", "image_code": "// Created by inigo quilez - iq/2004/2021\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// A procedural butterfly I made back in 2004 for the realtime\n// 64 kilobyte demo Paradise (https://www.pouet.net/prod.php?which=12821)\n// You can see the butterfly in the rhino sequence: \n//\n// https://www.youtube.com/watch?v=JY9FzRwasjw&t=274s\n//\n// I converted the code below from C to GLSL. The exact noise patterns are\n// a bit different because in C I used a LUT based hash that I didn't want\n// to duplicate here in the Shadertoy version.\n\n// make 0 to see the static painting\n#define ANIMATE 1\n\nfloat fbm( float x, float y, int octaves );\n\nvec4 butterfly( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    vec4 col = vec4(0.0);\n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    \n    // bottom wing\n    if( p.y<0.0 )\n    {\n        float f = 0.45 + 0.2*fbm( 1.0+4.0*a,0.0, 2 );\n        float w = 3.1416*max(0.0,a-1.05)/(3.1416-1.05);\n\n        f *= sin(w)*sin(w);\n        f += 0.25*exp(-30.0*abs(a-(1.7+0.7*r)));\n\n        float th = f + 0.001;\n        \n        vec3 wcol = vec3(0.0,0.0,0.0);\n\n        // ala amarilla\n        f = fbm( 5.0*r, 5.0*w/(1.0+1.5*r), 3 );\n        f *= 1.0-pow(r/th,42.0);\n        f = 0.2 + 0.8*f;\n        wcol = mix( wcol, vec3(1.00,0.98,0.59), smoothstep(0.47,0.53,f) );\n        wcol *= 1.4;\n        // borde negro\n        f = w - 0.3*(r/th);\n        f = 0.5 + 0.5*sin(20.0*f);\n        f = 0.3*pow(f, 1.0 + 40.0*r/th );\n        f = sqrt( max(1.0-(r/th),0.0) );\n        wcol *= 1.0-f;\n\n        // manchas negri-naranjas\n        f = fbm( 6.0*p.x, 6.0*p.y, 2 );\n\n        wcol = mix( wcol, vec3(0.00,0.00,0.00), smoothstep( 0.52, 0.53, f ) );\n        wcol = mix( wcol, vec3(0.97,0.64,0.10), smoothstep( 0.53, 0.58, f ) );\n        float d = r-th;\n        //col = mix( col, wcol, smoothstep( 0.0,2.0*fwidth(d),-d) );\n        float al = smoothstep( 0.0,2.0*fwidth(d),-d);\n        col.xyz = wcol;\n        col.w = al;\n    }\n    \n    // top wing\n    if( a<2.2 )\n    {\n        float f = 0.55 + 0.3*fbm( 4.0*a, 46.0, 2 );\n        float w = a*(3.1416/2.356);\n        float th = f*sin(w)*sin(w) + 0.001;\n            \n        // ala roja\n        float h = fbm( p.x*4.0, p.y*4.0, 3 );\n        vec3 col2 = mix( vec3(0.54,0.28,0.09), \n                         vec3(0.55,0.04,0.04), smoothstep( 0.3, 0.7, h ) );\n        col2 *= 1.4;\n        f = fbm( 6.0*r+2.0, 5.0*w/(1.0+0.1*r), 3 );\n        f = 0.2 + 0.8*f;\n\n        // borde negrito\n        f *= 1.0-pow(r/th,42.0);\n        vec3 wcol = mix( vec3(0.0), col2, smoothstep(0.47,0.53,f) );\n\n        // esqueleto\n        f = w - 0.3*(r/th);\n        f = 0.5 + 0.5*sin(32.0*f);\n        f = 0.4*pow(f, 1.0 + 40.0*r/th );\n        f *= 1.0-pow( r/th, 5.0 );\n        wcol *= 1.0-f;\n\n        // manchas blanqui-negras\n        f = fbm(18.5+ 5.0*p.x, 0.0+6.0*p.y, 2 );\n        f = smoothstep( 0.35, 0.65, f);\n        wcol = mix( wcol, vec3(0,0,0), smoothstep( 0.65, 0.85,f ) );\n        wcol = mix( wcol, vec3(1,1,1), smoothstep( 0.99, 1.00,f ) );\n        float d = r-th;\n        float al = smoothstep( 0.0,2.0*fwidth(d),-d);\n        col.xyz = mix( col.xyz, wcol, al );\n        col.w = 1.0 - (1.0-col.w)*(1.0-al);\n    }\n    \n    return col;\n}\n\nint hash( ivec2 z )\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    return (n*(n*n*15731+789221)+1376312589)>>16;\n}\n    \n// this hash differs from the one I used in Paradise, so the color\n// patters don't match exactly.\nvec2 grad( ivec2 z )\n{\n    // Perlin style vectors\n    int n = hash(z) & 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                                  gr ;\n}\n\n// some basic gradient noise\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( float x, float y, int octaves )\n{\n    float t = 0.0;\n    float s = 0.5;\n\n    for( int i=0; i<octaves; i++ )\n    {\n        t+=s*noise( vec2(x,y) );\n        x+=x;\n        y+=y;\n        s*=.5;\n    }\n\n    return clamp( 0.5 + 0.6*t, 0.0, 1.0 );\n}\n\n// integral of smoothstep(0,T,t). More info here:\n// https://www.tiktok.com/@inigoquilez/video/6963762978126646534\nfloat s( float t, in float T )\n{\n    if( t<T )\n    {\n        return t*t*t*(1.0-t*0.5/T)/T/T;\n    }\n    return t - T/2.0;\n    \n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // render\n#if ANIMATE==1\n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 of = vec2(i,j)/float(AA);\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n\n        // time\n        float di = float( hash(ivec2(fragCoord)*AA+ivec2(i,j))&255 )/255.0;\n        float time = iTime + ((float(j*AA+i)+di)/float(AA*AA))*(0.5/24.0) - 0.5*0.5/24.0;\n        \n        // soften motion        \n        time += 0.07*sin( p.y );\n\n        // wing position\n        float wing = s(time, 8.0);\n       \n        //animate plane\n        float an = 1.55*(0.5-0.5*cos(16.5*(wing-12.0)));\n        vec2  pl = vec2(sign(p.x)*sin(an),-cos(an));\n\n        // intersect plane\n        vec3 ro = vec3(0.0,0.0,1.95);\n        vec3 rd = vec3(p,-3.0);\n        vec3 pos = ro - rd*dot(ro.xz,pl)/dot(rd.xz,pl);\n        vec2 q = vec2( length(pos.xz), pos.y );\n\n        // draw butterfly\n        vec4 tmp = butterfly( q );\n\n        // some basic fake lighting \n        tmp = clamp(tmp,0.0,1.0);\n        tmp.xyz *= 0.1+0.9*mix(1.0,abs(q.y)*0.5+min(q.x*2.0,1.0),pl.x*pl.x);\n        tmp.xyz *= clamp(0.25+0.75*(pl.x-pl.y+1.0),0.0,1.0);\n\n        // accumulate\n        col += mix( vec3(0.56), tmp.xyz, tmp.w );\n    }\n    // resolve (box filter)\n    col /= float(AA*AA);\n#else\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p *= 0.65;\n    vec3 col = butterfly( p );\n#endif\n\n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    col *= 0.05 + 0.95*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n    \n    // dither\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKXDh.jpg", "access": "api", "license": "proprietary-license", "functions": [[1151, 1151, 1180, 1180, 3693], [3695, 3695, 3716, 3770, 3929], [3935, 4034, 4056, 4084, 4267], [4269, 4298, 4324, 4324, 4706], [4708, 4708, 4752, 4752, 4960], [4962, 5077, 5109, 5109, 5204]]}
{"id": "fsBXDc", "name": "2D Ball Early Collision Detect", "author": "oneshade", "description": "Analytically detecting collisions between a simple ball trajectory between a line and a circle.\nBox collision detection is just a combination of lines I guess.", "tags": ["2d", "ball", "analytic", "collisiondetection", "early"], "likes": 11, "viewed": 221, "published": 3, "date": "1621110874", "time_retrieved": "2024-07-30T19:20:17.887028", "image_code": "// Utilities\n#define drawSDF(dist, col, opacity) color = mix(color, col, smoothstep(unit, 0.0, dist) * opacity)\n\n// Closest points\nvec2 closestInfLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    vec2 local = ba * dot(pa, ba) / dot(ba, ba);\n    return a + local + normalize(pa - local) * t;\n}\n\nvec2 closestSegment(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    vec2 local = ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return a + local + normalize(pa - local) * t;\n}\n\nvec2 closestCircle(in vec2 p, in vec2 o, in float r) {\n    return o + normalize(p - o) * r;\n}\n\n// SDFs\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * dot(pa, ba) / dot(ba, ba)) - t;\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nfloat sdCircle(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\n// Normals\nvec2 norInfLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return normalize(pa - ba * dot(pa, ba) / dot(ba, ba)) - t;\n}\n\nvec2 norSegment(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return normalize(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nvec2 norCircle(in vec2 p, in vec2 o, in float r) {\n    return normalize(p - o);\n}\n\n// Trajectory of a ball at constant velocity with constant downward gravitational force\n// In such a simple case, all that is needed is to integrate the force over time and\n// distort the starting (linear) trajectory by it\nvec2 posTrajectory(in vec2 p0, in vec2 v0, in float t, in float g) {\n    vec2 lin = p0 + v0 * t;\n    return vec2(lin.x, lin.y - 0.5 * g * t * t);\n}\n\n// Ball velocity (derivative of position)\nvec2 velTrajectory(in vec2 p0, in vec2 v0, in float t, in float g) {\n    return vec2(v0.x, v0.y - g * t);\n}\n\n// 2D collision between simple ball trajectory and a circle\n// Requires solving a quartic\nfloat circleCollision(in vec2 p0, in vec2 v0, in float br, in vec2 co, in float cr, in float g) {\n    p0 -= co; cr += br;\n    float qa = 0.25 * g * g;\n    float qb = -g * v0.y;\n    float qc = dot(v0, v0) - g * p0.y;\n    float qd = 2.0 * dot(p0, v0);\n    float qe = dot(p0, p0) - cr * cr;\n    qb /= qa; qc /= qa; qd /= qa; qe /= qa;\n\n    float bb = qb * qb;\n    float p = qc - 0.375 * bb;\n    float q = qd - 0.5 * qb * qc + 0.125 * bb * qb;\n    float r = qe - 0.25 * qb * qd + 0.0625 * bb * qc - 0.01171875 * bb * bb;\n\n    // Cubic solving\n    float ra = 2.0 * p;\n    float rb = p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float raa = ra * ra;\n    float inflect = ra / 3.0;\n\n    float rp = rb - raa / 3.0;\n    float rq = raa * ra / 13.5 - ra * rb / 3.0 + rc;\n    float rppp = rp * rp * rp, rqq = rq * rq;\n\n    float p2 = abs(rp);\n    float v1 = 1.5 / rp * rq;\n\n    float lambda;\n    if (rqq * 0.25 + rppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (rp < 0.0) lambda = sign(rq) * cosh(acosh(v2 * -sign(rq)) / 3.0);\n        else lambda = sinh(asinh(v2) / 3.0);\n        lambda = -sqrt(p2 / 3.0) * lambda;\n    }\n\n    else lambda = sqrt(-rp / 3.0) * cos(acos(v1 * sqrt(-3.0 / rp)) / 3.0);\n    lambda = 2.0 * lambda - inflect;\n\n    if (lambda < 0.0) return -1.0;\n    float sqrtLambda = sqrt(lambda);\n    float pLambda = 2.0 * (p + lambda), qLambda = 2.0 * q / sqrtLambda;\n\n    // Smallest positive root (found experimentally)\n    float bar = lambda - pLambda + qLambda;\n    if (bar > 0.0) return -(sqrtLambda + sign(qe) * sqrt(bar)) * 0.5 - 0.25 * qb;\n\n    float foo = lambda - pLambda - qLambda;\n    if (foo > 0.0) return +(sqrtLambda - sign(qe) * sqrt(foo)) * 0.5 - 0.25 * qb;\n\n    return -1.0;\n}\n\n// 2D collision between simple ball trajectory and an infinite line\n// Requires solving a quadratic\nfloat infLineCollision(in vec2 p0, in vec2 v0, in float r, in vec2 a, in vec2 b, in float t, in float g) {\n    vec2 pa = p0 - a, ba = b - a, offset = normalize(pa - ba * dot(pa, ba) / dot(ba, ba)) * (t + r);\n    float slope = ba.y / ba.x;\n    a += offset, b += offset;\n    float qa = 0.5 * g, qb = slope * v0.x - v0.y, qc = slope * (p0.x - a.x) - p0.y + a.y;\n    float h = qb * qb - 4.0 * qa * qc;\n    if (h < 0.0) return -1.0;\n    return -0.5 * (sign(qc) * sqrt(h) + qb) / qa;\n}\n\n// 2D collision between simple ball trajectory and a line segment\n// (combination of infinite line and circular caps)\nfloat segmentCollision(in vec2 p0, in vec2 v0, in float r, in vec2 a, in vec2 b, in float t, in float g) {\n    float tColl = infLineCollision(p0, v0, r, a, b, t, g); // Time of collision\n    if (sdSegment(posTrajectory(p0, v0, tColl, g), a, b, t) > r + 0.001) { // Need a small error margin\n        float tCollCap1 = circleCollision(p0, v0, r, b, t, g);\n        if (tCollCap1 > 0.0) tColl = tCollCap1;\n        float tCollCap2 = circleCollision(p0, v0, r, a, t, g);\n        if (tCollCap2 > 0.0 && (tCollCap1 < 0.0 ? true : tCollCap2 < tCollCap1)) tColl = tCollCap2;\n        if (tCollCap1 < 0.0 && tCollCap2 < 0.0) tColl = -1.0;\n    }\n\n    return tColl;\n}\n\n// Distance to simple ball trajectory (for rendering purposes)\nfloat sdTrajectory(in vec2 p, in vec2 p0, in vec2 v0, in float tEnd, in bool term, in float g) {\n    vec2 q = p0 - p;\n    float t3 = 0.5 * g * g;\n    float t2 = -1.5 * g * v0.y;\n    float t1 = dot(v0, v0) - q.y * g;\n    float t0 = dot(q, v0);\n\n    t2 /= t3, t1 /= t3, t0 /= t3;\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = -2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0;\n        return length(p - posTrajectory(p0, v0, term ? clamp(root, 0.0, tEnd) : max(0.0, root), g));\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = 2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0;\n        roots = term ? clamp(roots, 0.0, tEnd) : max(roots, 0.0);\n        vec2 p1 = p - posTrajectory(p0, v0, roots.x, g);\n        vec2 p2 = p - posTrajectory(p0, v0, roots.y, g);\n        return sqrt(min(dot(p1, p1), dot(p2, p2)));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Default before mouse interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        float time = 0.5 * iTime;\n        mouse = vec4(1.5 * cos(time), 1.5 * sin(time), 0.0, 0.0);\n    }\n\n    // Gravity, ball start, ball velocity, ball radius\n    float g = 1.0;\n    vec2 p0 = mouse.zw;\n    vec2 v0 = mouse.xy - mouse.zw;\n    float r = 0.15;\n\n    // Line vertices and thickness\n    vec2 a1 = vec2(-2.5, 0.0);\n    vec2 b1 = vec2(-1.0, -1.0);\n    float t1 = 0.1;\n\n    // Infinite line vertices and thickness\n    vec2 a2 = vec2(1.0, -1.0);\n    vec2 b2 = vec2(0.0, -1.25);\n    float t2 = 0.01;\n\n    // Circle position and radius\n    vec2 co = vec2(1.0, 0.5);\n    float cr = 0.25;\n\n    // Draw objects\n    drawSDF(sdInfLine(uv, a2, b2, t2), vec3(0.0), 1.0);\n    drawSDF(sdSegment(uv, a1, b1, t1), vec3(0.0), 1.0);\n    drawSDF(sdCircle(uv, co, cr), vec3(0.0), 1.0);\n\n    // Draw trajectory\n    drawSDF(sdTrajectory(uv, p0, v0, 1000.0, false, g) - 0.01, vec3(0.0, 0.0, 1.0), 1.0);\n\n    // Combine collisions\n    float tColl = infLineCollision(p0, v0, r, a2, b2, t2, g); // Time of collision\n    float tColl2 = segmentCollision(p0, v0, r, a1, b1, t1, g);\n    if (tColl2 > 0.0 ? (tColl > 0.0 ? tColl2 < tColl : true) : false) tColl = tColl2;\n    tColl2 = circleCollision(p0, v0, r, co, cr, g);\n    if (tColl2 > 0.0 ? (tColl > 0.0 ? tColl2 < tColl : true) : false) tColl = tColl2;\n\n    vec2 pColl = posTrajectory(p0, v0, tColl, g); // Collision point\n    drawSDF(sdTrajectory(uv, p0, v0, tColl, tColl > 0.0, g) - 0.01, vec3(1.0, 0.0, 0.0), 1.0);\n\n    // Get normal of closest object to hit\n    float dInfLine = sdInfLine(pColl, a2, b2, t2);\n    float dSegment = sdSegment(pColl, a1, b1, t1);\n    float dCircle = sdCircle(pColl, co, cr);\n\n    float closest = min(dInfLine, min(dSegment, dCircle)); vec2 hit, nor;\n    if (dInfLine == closest) hit = closestInfLine(pColl, a2, b2, t2), nor = norInfLine(pColl, a2, b2, t2);\n    if (dSegment == closest) hit = closestSegment(pColl, a1, b1, t1), nor = norSegment(pColl, a1, b1, t1);\n    if (dCircle == closest) hit = closestCircle(pColl, co, cr), nor = norCircle(pColl, co, cr);\n\n    // Show collision and next bounce\n    if (tColl > 0.0) drawSDF(sdCircle(uv, pColl, r), vec3(1.0, 0.9, 0.0), 1.0);\n    drawSDF(sdTrajectory(uv, pColl, reflect(velTrajectory(p0, v0, tColl, g), nor), 1000.0, false, g) - 0.01, vec3(0.0, 0.0, 1.0), 0.25);\n    drawSDF(sdSegment(uv, hit, hit + 0.5 * nor, 0.001), vec3(1.0, 0.0, 1.0), 1.0);\n    drawSDF(sdCircle(uv, hit, 0.05), vec3(0.0, 1.0, 0.0), 1.0);\n\n    // Vignette\n    uv *= 0.25;\n    float dd = dot(uv, uv);\n    color -= 0.5 * dd * dd;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBXDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 131, 197, 197, 331], [333, 333, 399, 399, 550], [552, 552, 606, 606, 645], [647, 655, 717, 717, 812], [814, 814, 876, 876, 988], [990, 990, 1040, 1040, 1072], [1074, 1085, 1147, 1147, 1245], [1247, 1247, 1309, 1309, 1424], [1426, 1426, 1476, 1476, 1507], [1509, 1732, 1800, 1800, 1879], [1881, 1923, 1991, 1991, 2030], [2032, 2122, 2219, 2219, 3838], [3840, 3940, 4046, 4046, 4419], [4421, 4539, 4645, 4645, 5192], [5194, 5257, 5353, 5353, 6522], [6524, 6524, 6579, 6598, 9490]]}
{"id": "wtVcWz", "name": "Geometric Heart Pattern", "author": "Shane", "description": "Using a hexagon grid to create a packed random heart pattern.", "tags": ["hexagon", "heart", "geometry", "hash"], "likes": 28, "viewed": 770, "published": 3, "date": "1621086543", "time_retrieved": "2024-07-30T19:20:18.819535", "image_code": "/*\n\n    Geometric Heart Pattern\n    -----------------------\n    \n    I must be a romantic at heart, because I love heart examples. This is a\n    very abstract version, but there's some really nice examples on here for\n    anyone interested. I coded it up a while back after playing around with \n    hexagonal grids. In fact, it's just a hexagonal grid example in disguise. \n    \n    Producing the geometry didn't pose too many problems, but I made everything \n    up as I went along, so there'd definitely be cleverer ways to go about it. \n    If it were not for the slightly randomized vertex points, this would be a \n    much simpler and faster example.\n    \n    The hash pattern overlay was made up on the spot also, so I wouldn't pay \n    too much attention to its construction either. It wasn't difficult to make: \n    Obtain the pixel's greyscale value, then render overlapped rotated lines. \n    Darker shades require more rotated line layers and lighter ones require \n    fewer. I had hoped to put the pattern in extruded form, but ran out of \n    steam making the 2D version, so maybe at a later date. :)\n    \n    \n    \n    // Other heart examples:\n    \n    Pixel Heart - Fizzer\n    https://www.shadertoy.com/view/MlByzh    \n    \n    Heart - 2D - iq\n    https://www.shadertoy.com/view/XsfGRn\n    \n    Zeta heart for my wife - Logos\n    https://www.shadertoy.com/view/3lKXzt\n\n*/\n\n\n// If you want a better idea of how the pattern was created, uncomment this.\n//#define SHOW_GRID_CELLS\n\n// Rounded hearts: This complicates things, but it looks cool.\n//#define ROUNDED\n\n// Offset vertices.\n#define OFFSET\n\n// Pink: 0, Golden Brown: 1, Mix: 2.\n#define COLOR 2\n\n\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n \n// Global vertices and local coordinates of the triangle cell.\n// It's lazy putting them here, but I'll tidy them up later.\nvec2[8] gV;\nvec2 gP;\nfloat d2D;\n\n\nvec4 blocks(vec3 q){\n    \n    \n    // Brick dimension: Length to height ratio with additional scaling.\n    #ifdef FLAT_TOP\n    const vec2 dim = scale*vec2(1.732/2., 1);\n    #else\n    const vec2 dim = scale*vec2(1, 1.732/2.);\n    #endif\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;//*vec2(1, .5); \n    \n\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block corner postions.\n    //const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    //vec2[4] ps4 = vec2[4](vec2(1, -.5), vec2(0, -.5), vec2(-.5, .5), vec2(.5));\n    // Four block corner postions.\n    const vec2 ll = vec2(.5);//vec2(.5, 1);// \n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    // Pointed top.\n    #ifdef FLAT_TOP\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    // Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif   \n  \n\n    d2D = 1e5;\n    \n        \n    float triID = 0.; // Triangle ID. Not used in this example, but helpful.\n\n\n\n\n    // Initializing the global vertices and local coordinates of the triangle cell.\n    //gV = vec2[6](vec2(0), vec2(0), vec2(0), vec2(0), vec2(0), vec2(0));\n    gP = p;\n    \n    // Hexagon vertices. \n    vec2[6] vert = vID;  \n \n    vert[0] *= dim;\n    vert[1] *= dim;\n    vert[2] *= dim;\n    vert[3] *= dim;\n    vert[4] *= dim;\n    vert[5] *= dim;\n    \n    for(int i = min(0, iFrame); i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;\n        \n        // Local coordinates.\n        p = q.xy;\n        \n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n \n        //vec2 inC = (vert[0] + vert[1] + vert[2] + vert[3] + vert[4] + vert[5])/6.;\n        \n        float face1 = sdPoly(p, vert); \n        vec2 offs = vec2(0);//inC.xy;\n        vec2 idi1 = idi + offs;\n         \n         \n         \n        // For each hexagon, render three heart shapes.\n        // Uncomment \"SHOW_GRID_CELLS\" for a visual guide.\n      \n        // Randomly offsetting the index for a random rotation effect.\n        int rI = hash21(idi)<.5? 1 : 0;\n        \n        // Random angle. \n        \n        #ifdef OFFSET\n        const float ra = -atan(sqrt(3.)/5.) - .075; // .333473172\n        //const float ra = -6.2831/19.;//24.;\n        const float len = sqrt(4./7.)/1.03;\n        #else\n        const float ra = -atan(sqrt(3.)/5.);\n        const float len = sqrt(4./7.);\n        #endif\n        \n        for(int jj = min(0, iFrame); jj<6; jj+=2){\n        \n            int j = jj + rI;\n            j = j%6; \n\n            // Use the hexagonal cell geometry to determine the eight polygon\n            // vertices for each heart shape.\n            vec2[8] vJ;\n            vJ[0] = vec2(0);\n            vJ[1] = rot2(ra)*vert[j]*len;\n            vJ[2] = vert[j];\n            //vJ[3] = vert[j] - rot2(-6.2831/3.)*(vJ[2] - vJ[1]);\n            vJ[3] = eID[j]*s + rot2(ra)*vert[(j + 4)%6]*len;\n            vJ[4] = rot2(ra)*vert[(j + 1)%6]*len;\n\n\n            vJ[5] = vert[(j + 1)%6];\n            // vJ[5] = vert[(j + 1)%6] - rot2(-6.2831/3.)*(vJ[6] - vJ[5]);\n            vJ[6] = eID[(j + 1)%6]*s + rot2(ra)*vert[(j + 5)%6]*len;\n            vJ[7] = rot2(ra)*vert[(j + 2)%6]*len;\n          \n            //// \n            #ifdef ROUNDED\n            // Moving the vertices in to help create rounded hexagons. Rounded offset hexgons can\n            // be created by simply adding a factor to the distance field. Unfortunately, in a \n            // packed grid, that would create overlap, so it's necessary to move the points in\n            // first, then add the amount. This is less trivial, as you can see, but is just a\n            // bit of trigonometry. The following is robust, but was something I came up with on\n            // the spot, so if anyone knows of a more elegant way, feel free to let me know.\n            // Remember that this is just a one-off precalculation, so speed isn't a factor.\n            const float ndg = .125*GSCALE.x;\n            vec2[8] tmpV;\n\n            //tmpV[0] = vJ[0];\n            for(int k = min(iFrame, 0); k<8; k++){\n\n                // Vertices and flanking neighbors.\n                vec2 g = vJ[k];\n                vec2 g1 = vJ[(k + 1)%8];\n                vec2 g2 = vJ[(k + 7)%8];\n\n                // Move the vertices in the direction of the tangent vector\n                // by the nudge factor.\n                vec2 v1 = g1 - g;\n                vec2 v2 = g - g2;\n\n                vec2 tng1 = normalize(v1); // Tangent vector.\n                vec2 tng2 = normalize(v2); // Tangent vector.\n                vec2 n1 = tng1.yx*vec2(1, -1); // Normal vector.\n                vec2 n2 = tng2.yx*vec2(1, -1); // Normal vector.\n\n                vec2 interP;\n                lineIntersection(g - tng1 + n1*ndg, g + tng1 + n1*ndg, \n                                 g - tng2 + n2*ndg, g + tng2 + n2*ndg, interP);\n\n                // Angle between vectors.\n                //float ang = acos(dot(v1, v2)/length(v1)/length(v2));\n                //float sl = ndg/tan(ang/2.);\n                tmpV[k] = interP;//g + sl*nj + ndg*nj.yx*vec2(1, -1);\n\n\n                //if(ang>1e5) break; // Fake break.\n            }\n\n            vJ = tmpV;\n            #endif\n            /////       \n            \n            \n            // Construct this particular heart polygon.\n            float faceJ = sdPoly(p, vJ);\n            #ifdef ROUNDED\n            faceJ -= ndg;\n            #endif\n            \n            vec4 di = vec4(faceJ, idi1, float(j/2));\n            \n            // Fake break to trick the compiler into not being ridiculously slow.\n            if(di.x>1e6) break; \n\n            // If applicable, update the overall minimum distance value,\n            // ID, and box ID. \n            if(di.x<d){\n            \n                d = di.x;\n                id = di.yz;\n                triID = di.w;\n\n                // Setting the vertices and local coordinates.\n                gV = vJ;\n                gP = p;\n\n                d2D = face1; \n\n            }\n        \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, triID);\n}\n\n\n\n // IQ's float to float hash.\nfloat hash11(float x){  return fract(sin(x)*43758.5453); }\n\n\n\nvoid swap(inout int a, inout int b){ int tmp = a; a = b; b = tmp; }\n// A swap without the extra declaration -- It works fine on my machine, but I'm\n// not game  enough to use it, yet. :)\n//void swap(inout int a, inout int b){ a = a + b; b = a - b; a = a - b; }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling, rotation and translation.\n    const float gSc = 1.;\n    float sf = gSc/iResolution.y;\n    float ra = -atan(sqrt(3.)/5.);\n    vec2 p = rot2((ra + 3.14159))*(uv*gSc + vec2(1, .5)*iTime/16.);\n    \n    // The heart tiles offset -- for highlighting.\n    vec4 d4Hi = blocks(vec3(p - normalize(vec2(1, 2))*.003, 0));\n    vec4 svGIDHi = d4Hi;//.yzw; // Individual block ID.\n    \n     // The heart tiles.\n    vec4 d4 = blocks(vec3(p, 0));\n    vec4 svGID = d4; // Individual block ID.\n    vec2 svP = gP;\n    vec2[gV.length()] svV = gV;\n    //float svH = gH;\n    float svD2D = d2D;\n    \n    // Bump value.\n    float bump = max(d4Hi.x - d4.x, 0.)/.003*.7;\n    \n    // Scene color.\n    vec3 col = vec3(0);\n    \n    // Cell center.\n    vec2 ctr = vec2(0);\n    //for(int i = 0; i<svV.length(); i++) ctr += svV[i]/float(svV.length());\n    ctr += normalize(mix(svV[5], svV[6], .5))*scale.x*.35;\n    \n    // Some random values.\n    float rnd = hash21((svGID.yz + ctr));\n    float rnd2 = hash21(svGID.yz + ctr + .35);\n    float rnd3 = hash21(svGID.yz + ctr + .65);\n    \n    // Use the above to produce a cell color.\n    vec3 cCol = .6 + .4*cos(6.2831853*rnd/4. + vec3(0, 1, 2));\n    vec3 gCol = .6 + .4*cos(6.2831853*rnd/4. + vec3(0));\n    float gr = dot(cCol/4., vec3(.299, .587, .114));\n    //cCol = vec3(.7, .8, 1)*(rnd*.05 + .05);\n    //cCol = vec3(1)*dot(cCol/4., vec3(.299, .587, .114));\n    \n    // Pink coloring.\n    vec3 hCol = mix(vec3(1, .05, .5), vec3(1, .15, .4), rnd3);\n    //vec3 hCol = mix(vec3(1, .05, .15), vec3(1, .1, .05), rnd3);\n    //hCol *= mix(vec3(.25, .5, 1), vec3(1, .8, .2), bump);\n    \n    #if COLOR == 2\n    // Color half of them with golden brown shades.\n    if(hash21(svGID.yz + ctr + .25)<.5) hCol = cCol/3.;\n    #elif COLOR == 1\n    // All golden brown\n    hCol = cCol/3.;\n    #endif\n    \n    // Bump based coloring.\n    hCol *= mix(vec3(1, .4, .2), vec3(1, .7, .3), bump);\n    \n    // Coloring and shading.\n    d4.x += .005; \n    float sh = max(.25 - d4.x/.03, 0.);\n    //if(mod(svGID.w, 3.)!=2.) \n    //cCol = mix(cCol.zyx, cCol.yxz, step(.5, fract(rnd*57. + .5)));\n    cCol = mix(gCol, min(hCol*5., 1.8), smoothstep(.9, .95, sin(rnd2*6.2831 + iTime*1.)*.5 + .5));\n \n    // Render the heart.\n    col = mix(col, vec3(1), 1. - smoothstep(0., sf, d4.x));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d4.x + .0075));\n    col = mix(col, cCol, 1. - smoothstep(0., sf, d4.x + .0125));\n    \n    // Add highlighting.\n    col = col*(vec3(.5, .7, 1)*bump*bump*2. + .5);    \n    \n    \n    \n    // Hatch algorithm.\n    //////\n    float gry = dot(col, vec3(.299, .587, .114)); // Greyscale pixel value.\n    //gry = sqrt(gry);\n    float pat = 1.;\n      \n    // Perturb the pixel slightly. \n    vec2 q = p + (vec2(n2D3G(p*8.), n2D3G(p*8. + .5)) - .5)*.02; \n    \n    // Add five layers of rotated lines over the top, depending on how dark\n    // the greyscale pixel value is.\n    const int NN = 5;\n    const float fn = float(NN);\n    float lns = 150.*iResolution.y/450.;\n    for(int i = 0; i<NN; i++){\n        \n        vec2 rp = rot2(-ra - 3.14159/3. - float(i)*6.2831/(fn)/2.)*q;\n        rp += float(i)/fn;\n        float patL = abs(fract((rp.x)*lns) - .5)*2. - .05;\n        \n        if(gry<(fn - float(i))/(fn + 1.)) pat = min(pat, patL);\n    }\n    \n    // Apply the hatch pattern.\n    pat = smoothstep(0., sf*lns*2., pat);\n    col = mix(col, col*vec3(pat*.8 + .4), 1. - smoothstep(0., sf, d4.x + .0125));\n    /////\n     \n    \n    // More highlighting.\n    //float dt = length(svP - ctr) - .015;\n    //col = mix(col, col*2., (1. - smoothstep(0., sf*8., dt))*.5);\n    \n    \n    #ifdef SHOW_GRID_CELLS\n    // Hexagon cells.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(svD2D) - .006))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(svD2D) - .006));\n    col = mix(col, vec3(2, .9, .25), 1. - smoothstep(0., sf, abs(svD2D) - .001));\n    #endif\n                      \n\n    // Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "\n// Grid pattern repeat scale. Baking wrapped distance fields into textures can be \n// a little fiddly. Basically, the pattern is wrapped on a 64 by 64 unit basis.\nfloat repSc = 1024./4.;\n\n// This sets the scale of the extruded shapes. Because of the way I've calculated\n// things, the scale needs to be even divisors and each term needs to be equal --\n// I use it in other applications where I can use two different numbers though. \n// As above, if you choose this option, a reset will be necessary. Ie. Hit the \n// back button.\n#define GSCALE vec2(1./3.)\n\n\nconst vec2 scale = GSCALE;\n\n\n//#define FLAT_TOP\n#ifdef FLAT_TOP\n// Vertices: Clockwise from the left.\nvec2[6] vID = vec2[6](vec2(-2./3., 0), vec2(-2./6., .5), vec2(2./6., .5), \n                      vec2(2./3., 0), vec2(2./6., -.5), vec2(-2./6., -.5)); \nvec2[6] eID = vec2[6](vec2(-.5, .25), vec2(0, .5), vec2(.5, .25), \n                      vec2(.5, -.25), vec2(0, -.5), vec2(-.5, -.25));\n#else\n// Vertices: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\nvec2[6] vID = vec2[6](vec2(-.5, -2./6.), vec2(-.5, 2./6.), vec2(0, 2./3.), \n                      vec2(.5, 2./6.), vec2(.5, -2./6.), vec2(0, -2./3.));\nvec2[6] eID = vec2[6](vec2(-.5, 0), vec2(-.25, .5), vec2(.25, .5), vec2(.5, 0), \n                      vec2(.25, -.5), vec2(-.25, -.5));\n#endif\n\n////////\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// vec2 to vec2 hash.\nvec2 hash22C(vec2 p) { \n\n    p = mod(p, repSc);\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    vec2 n = sin(vec2(dot(p, vec2(27.29, 57.81)), dot(p, vec2(7.14, 113.43))));\n    return fract(vec2(262144.1397, 32768.8793)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + gTime); \n    \n}\n\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n} \n\n\n// IQ's irregular polygon distance function. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV 6\n//\nfloat sdPoly(in vec2 p, in vec2[NV] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // Distance.\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // Winding number from: http://geomalgorithms.com/a03-_inclusion.html.\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n// IQ's irregular polygon distance function. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV8 8\n//\nfloat sdPoly(in vec2 p, in vec2[NV8] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // Distance.\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // Winding number from: http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n//Cross product of 2d vectors returns scalar\n//1 = perpendicular, 0 = colinear\nfloat cross2D(vec2 v1, vec2 v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\n//Line intersection algorithm\n//Based off Andre LaMothe's algorithm in \"Tricks of the Windows Game Programming Gurus\".\nbool lineIntersection(vec2 L1A, vec2 L1B, vec2 L2A, vec2 L2B, out vec2 p){\n\n    //Line 1 Vector\n    vec2 v1 = L1B - L1A;\n    \n    //Line 2 Vector\n    vec2 v2 = L2B - L2A;\n    \n    //Cross of vectors\n    float d = cross2D(v1,v2);\n    \n    //Difference between start points\n    vec2 LA_delta = L1A - L2A;\n    \n    //Percentage v1 x LA_delta is along v1 x v2\n    float s = cross2D(v1,LA_delta) / d;\n    \n    //Percentage v2 x LA_delta is along v1 x v2\n    float t = cross2D(v2,LA_delta) / d;\n\n    p = vec2(1e6);\n    \n    //Do segments intersect?\n    //Bounds test\n    if (s >= 0.0 && s <= 1.0 && t >= 0.0 && t <= 1.0)\n    {\n        //Projection\n        p = vec2(L1A.x + (t * v1.x), L1A.y + (t * v1.y)); \n        return true;\n    }\n    return false;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtVcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8680, 8709, 8731, 8731, 8767], [8771, 8771, 8807, 8807, 8838]]}
{"id": "7sjSWK", "name": "Belousov-Zhabotinsky Extrusion", "author": "Shane", "description": "Mapping a realtime Belousov-Zhabotinsky reaction onto an extruded hexagon grid. The pattern takes about 20 seconds to stabilize.", "tags": ["hexagon", "diffusion", "belousovzhabotinsky", "reaction", "extrusion"], "likes": 67, "viewed": 1369, "published": 3, "date": "1621084943", "time_retrieved": "2024-07-30T19:20:19.753039", "image_code": "/*\n\n\n    Belousov-Zhabotinsky Extrusion\n    ------------------------------\n\n\tFlexMonkey put together a really cool diffusion based example a while back\n    that I thought was pretty cool, so I wanted to make a version of it. The\n    original is a Belousov–Zhabotinsky reaction mapped to a 2D hexagonal grid, \n    so I was curious as to how it would look in extruded form.\n    \n    I used a simpler and somewhat less sophisticated method to create the \n    Belousov–Zhabotinsky reaction pattern itself, but it's essentially the same \n    thing -- By the way, the link to FlexMonkey's original is below.\n    \n    Codewise, there's nothing particularly exciting in here, but I thought I'd\n    post it for anyone interested in this kind of thing.\n    \n    \n\n\tBased on:\n    \n\t// FlexMonkey (A.K.A Simon Gladman) has a heap of nice diffusion related \n    // examples on here.\n    Pixelated Belousov–Zhabotinsky - FlexMonkey\n\thttps://www.shadertoy.com/view/ltlfWn \n    \n    Other examples:\n    \n    // A really nice concise version.\n    Belousov-Zhabotinsky Reaction - Cornusammonis\n    https://www.shadertoy.com/view/XtcGD2\n    \n    // The smallest Turing routine you're likely to find. If you set the \n    // texture to multicolor and uncomment the Belousov–Zhabotinsky line,\n    // you'll see a rough hardware version of this pattern.\n    Two Tweet Turing Texture - Shane\n    https://www.shadertoy.com/view/4ldcWS\n\n*/\n\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Hollow out the pylon center -- Kind of intersting.\n//#define HOLLOW\n\n// Flatten the scene, but give the pylons just a tiny variation for lighting.\n//#define FLAT\n\n// Greyscale.\n//#define GREYSCALE\n        \n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// 2D Texture routine.\nvec3 getTex2D(vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel1, fract(p)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n\n// Cube map texture reader.\nvec3 getTex(vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n  \n    p /= 4.;\n    //p = (mod(floor(p*1024.), 1024.) + .5)/1024.;\n    return texture(iChannel0, vec3(fract(p) - .5, .5)).xyz;\n \n\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2. );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method, which is here:\nfloat sHexS(in vec2 p, float r, in float sf){\n    \n  const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n\n  // X and Y reflection.  \n  p = abs(p); \n  p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n   \n \n  r -= sf;\n  // Polygon side.\n  return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n    \n}\n \n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    // Scale.\n    //#define STRETCH\n    #ifdef STRETCH\n\tconst vec2 scale = vec2(1./12., 1./16.);\n     // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale.x*1.732/2., scale.y);\n    #else\n    const float scale = 1./16.;\n     // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale*1.732/2., scale);\n    #endif\n    \n   \n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n    \n    // Distance.\n    float d = 1e5;\n    // Local coordinates, cell center, and overall cell IDs.\n    vec2 p, cntr, id = vec2(0), idi = vec2(0);\n    \n\n    \n    \n    // Four block corner postions.\n    const vec2 ll = vec2(.5);\n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    // Pointed top.\n    //vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    // Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    \n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;\n\n        // Local coordinates.\n        p = q3.xy;\n        //ip = floor(p/s - cntr) + .5 + cntr; // Local tile ID.\n        // Correct positional individual tile ID.\n        idi = (floor(p/s - cntr) + .5 + cntr)*s;\n        p -= idi; // New local position.\n\n                    \n \n        // The extruded block height. See the height map function, above.\n        float h = hm(idi)*.5 + .5;\n        \n        // Block width -- Normally set to one, but I'm using the underlying color\n        // to change the width.\n        float w = max(1. - h*h*2.2, .1);\n        \n        // Tempering the height.\n        #ifdef FLAT\n        h *= .05; // Relatively flat. Just a tiny variation for lighting.\n        #else\n        h *= .3;\n        #endif\n        \n        \n            \n        // The hexagonal cross section. The corners are slightly rounded on this\n        // version, but they don't have to be.\n        #ifdef STRETCH\n        vec2 lu = l/vec2(1.732/2., 1);\n        vec2 pStretch = lu.x<lu.y? vec2(1, lu.x/lu.y) : vec2(lu.y/lu.x, 1);\n        float r = min(lu.x, lu.y)/2.;\n        float di2D = sHexS(p*pStretch, r*(.5 - w)*2., .2*r*(.5 - w));\n        #else\n        float di2D = sHexS(p, scale*(.5 - w), .2*scale*(.5 - w));\n        //float di2D = sCylS(p, scale*(.5 - w));\n        #endif\n        \n        #ifdef HOLLOW\n        // Hollow out the pylon center.\n        di2D = abs(di2D + .14*scale) - .14*scale;\n        #endif\n\n        // The extruded distance function value.\n        float di = opExtrusion(di2D, (q3.z + h), h);\n        \n        //di = min(di, length(vec3(p, q3.z + h*2.)) - (scale/2. - w/2.*scale/2.)*.98);\n        di += di2D/6.;\n\n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di<d){\n            d = di;\n            id = idi;\n            // BoxID.\n            boxID = di2D;\n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .03;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), \n                          map(p + e.yxy) - map(p - e.yxy),\t\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, \n    //anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n/*\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.4, 1., c); // Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c); // Redish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); // Mixing in a bit of purple.\n\n}\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, iTime/8., -4.25); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .07, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.5, 2, 3);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .5; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n\n    \n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec3 svGID = gID;\n    \n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n        /*\n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.     \n        */\n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Coloring the individual blocks with the saved ID.\n            \n            vec3 tx = getTex(svGID.xy); // See scale in the distance function.\n            //vec3 tx2 = vec3(hash21(svGID.xy + .1), hash21(svGID.xy + .2), hash21(svGID.xy + .3));\n            vec3 tx2 = getTex2D(svGID.xy/2.); // Texture based color.\n            tx = smoothstep(0., .5, tx);\n            tx2 = smoothstep(0., .5, tx2);\n            \n            #ifdef GREYSCALE\n            // Greyscale value.\n            float gr = clamp(dot(tx*2. - .25, vec3(.299, .587, .114)), 0., 1.);\n            texCol = tx2*gr*1.5;\n            #else\n            // Applying some color. \n            texCol = tx*.8 + .2;\n            texCol = .53 + .42*cos(-texCol*6.2831/2.8 + vec3(0, 1, 2) + 2.5);\n            texCol *= tx2*3.;\n            #endif\n            \n            // Central dots.\n            //vec2 svP = sp.xy - svGID.xy;\n            //texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, length(svP) - .04/8.));\n            \n            /*\n            // Hexagonal face value.\n            float ht = (hm(svGID.xy)*.5 + .5)*.3;\n            float hex = svGID.z;\n   \n            float hex2 = hex;\n            hex = max(abs(hex), abs(sp.z + ht*2.)) - .004; // Face border.\n            //hex = min(hex, abs(hex2 + .01) - .00125); // Extra border.\n            // Applying the face border.\n            texCol = mix(texCol, texCol/8., (1. - smoothstep(0., .002, hex)));\n            */\n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(.05);\n        }\n       \n    \t\n   \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .25 + vec3(1, .7, .4)*spec*2.*sh);\n        \n        // Fake environment mapping.\n        //vec3 cTex = envMap(reflect(rd, sn));\n        //col += col*cTex.zyx*sh*5.;\n\n        // Shading.\n        col *= ao*atten;\n        \n        \n\t\n\t}\n    \n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// Global scale.\nfloat gSc = 512.;\n\n// IQ's vec2 to float with wrapping.\nfloat hash21(vec2 p) {\n\n    p = mod(p, gSc);\n    return fract(sin(dot(p, vec2(42.5137, 13.7963)))*43758.5453); \n}\n \n// Cube texture read.\nvec4 tx(vec2 p){ \n    \n    return texture(iChannel0, vec3(fract(p) - .5, .5));\n}\n\n/*\n// Blur function. Pretty standard.\nvec4 bTx(in vec2 p, const int N){\n    \n    // Result.\n\tvec4 c = vec4(0);\n    float sum = 0.;\n\n    // NxN blur.\n    for(int i = 0; i<N*N; i++) {\n        vec2 offs = vec2(i/N, i%N) - floor(float(N) - .5)/2.;\n        float l = max(length(vec2(N)/2.) - length(offs), 0.); l *= l;\n        //float l = exp(-(dot(offs, offs)/float(N*N))/2.)/float(N)*.39894;\n        //float l = 1./(1. + dot(offs, offs)*.5);\n        c += tx(p - (offs)/iResolution.y)*l;\n        sum += l;\n    }\n    \n    return c/sum; \n    \n}\n*/\n\n// Circle blur function -- Not as common, but you see it around. Sometimes,\n// taking a sweep at a certain radius can give you a blurrier result\n// without the cost. It's especially efficient when taking the difference\n// between different size filters.\nvec4 bTxCir(in vec2 p, float r){\n    \n\n    // Result.\n\tvec4 c = vec4(0);\n    float sum = 0.;\n    \n    const int N = 12;\n\n    // NxN blur.\n    for(int i = 0; i<N; i++) {\n        float ang = float(i)*6.2831/float(N);\n        vec2 offs = vec2(cos(ang), sin(ang))*r;\n        float l = 1.;//max(length(vec2(N)/2.) - length(offs), 0.); l *= l;\n        //float l = exp(-(dot(offs, offs)/float(N*N))/2.)/float(N)*.39894;\n        //float l = 1./(1. + dot(offs, offs)*.5);\n        c += tx(p - (offs)/iResolution.y)*l;\n        sum += l;\n    }\n    \n    return c/sum; \n    \n}\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    //float a = mod(float(iFrame), 8.)*3.14159/4.;// + rot2(a)*vec2(0, .5)\n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    gSc = 1.;\n \n    // Pixel storage.\n    vec4 col;\n   \n    // Initial conditions -- Performed upon initiation.\n    if(abs(tx(uv).w - iResolution.y)>.001){\n    \n        // Initial conditions: Fill each channel in each cell with some random values.\n        col = vec4(hash21(uv), hash21(uv + .17), hash21(uv + .23), 1.);\n        col.w = iResolution.y;\n    }\n    else {\n    \n        // A very rough Belousov–Zhabotinsky reaction approximation -- Feel free to look\n        // up the process in detail, but it's similar to many reaction diffusion like\n        // examples: Start off with an initial solution in the form of noise in one or \n        // some of the channels, use filters to blur it over time to similute dispersion,\n        // then mix the result with the previous frame. In this case, we can simulate \n        // non-equilibrium by sprinkling in extra noise for volatility... As mentioned,\n        // there are others on the net and on Shadertoy who can give you more detail, but\n        // that's the general gist of it.\n        \n        // Thinking a little outside the box, it's possible to use a much cheaper \n        // radial boundary blur with a larger radius to mickick a larger block blur. \n        // It doesn't work in all situations, but it works well enough here.\n        vec4 val = bTxCir(uv, 5.); // 12 Taps.\n        val = mix(val, tx(uv), 1./25.); // Adding the center pixel.\n        //vec4 val = bTx(uv, 7); // Box blur: 49 taps -- Requires rescaling.\n        \n        //#if 0\n        // Alternate, simpler equation.\n        //col = clamp(tx(uv) + .08*(val.zxyw - val.yzxw), 0., 1.);\n        //#else\n        float reactionRate = val.x*val.y*val.z; // Self explanitory.\n        //float reactionRate = smoothstep(0., 1., val.x*val.y*val.z); \n\n        // Producing the new value: For an explanation, you can look up the chemical\n        // reaction it pertains to and the mathematical translation which is pretty\n        // interesting. From a visual perspective, however, it's just a cute calculus \n        // based equation that produces a cool pattern over time.\n        vec4 res = val - reactionRate + val*(val.yzxw - val.zxyw);\n        //vec4 params = vec4(1, 1, 1, 0);//\n        //vec4 res = val - reactionRate + val*(params*val.yzxw - params.zxyw*val.zxyw);\n        \n        \n \n\n        // Adding some volatile noise to the system. \n        vec3 t = vec3(1.01, 1.07, 1.03)*fract(iTime);\n        vec4 ns = vec4(hash21(uv + .6 + t.x), hash21(uv + .2 + t.y), hash21(uv + .7 + t.z), 0);\n        \n        // Mixing the new value and noise with the old value. \n        col = mix(tx(uv), res*(.9 + ns*.3), .2*iTimeDelta*60.);\n        //#endif\n        \n \n        // Using the fourth channel to store resolution.\n        col.w = iResolution.y;\n    \n    }\n    \n    // Recording the new value and clamping it to a certain range.\n    fragColor = vec4(clamp(col.xyz, -1., 1.), iResolution.y);\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjSWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1755, 1788, 1810, 1810, 1868], [1871, 1899, 1920, 1920, 1983], [1986, 2009, 2031, 2408, 2512], [2515, 2543, 2563, 2940, 3072], [3074, 3138, 3158, 3158, 3207], [3209, 3236, 3293, 3293, 3600], [3603, 3759, 3804, 3804, 4079], [7626, 7649, 7667, 7686, 7959], [7963, 7984, 8020, 8069, 8540], [8543, 8643, 8679, 8679, 8890], [8893, 9084, 9136, 9260, 10580], [10583, 10735, 10771, 10771, 11025], [12200, 12200, 12256, 12289, 17518]]}
{"id": "ssjSDV", "name": "anticore - Outline SS QF #1", "author": "anticore", "description": "Outline demoparty shader showdown match #1\nmusic is in Buffer B iChannel0", "tags": ["spectrogram"], "likes": 5, "viewed": 480, "published": 3, "date": "1621079828", "time_retrieved": "2024-07-30T19:20:20.511013", "image_code": "float spectro(vec2 p) {\n    p.y = abs((p.y - 0.5) * 2.);\n    return smoothstep(0., 1., texture(iChannel0, p).a);\n}\n\nvec3 cam(vec3 ro, vec3 tar, vec2 uv) {\n    vec3 f = normalize(tar - ro);\n    vec3 l = normalize(cross(vec3(0,1,0) , f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l * uv.x + u * uv.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    return length(max(abs(p) - b, 0.));\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p,n) + h;\n}\nvec3 repl(vec3 p, vec3 c, vec3 l) {\n    return p - c * clamp(round(p / c), -l, l);\n\n}\n\nvec2 cp; float cps;\n\nvec2 map(vec3 p) {\n    float w = min(\n      sdPlane(p, vec3(1,0,0), 4. + sin(p.z+ iTime * 3.) * 0.5),\n      sdPlane(p, vec3(-1,0,0), 4. + sin(p.z + iTime * 3.) * 0.5)\n    );\n  \n    cp = (round(p / 0.1 + 0.05).zx + vec2(0,50)) / vec2(1000, 100);\n    cps = spectro(vec2(-cp.x / 2., cp.y));\n    p = repl(p, vec3(0.1, 0., 0.1), vec3(50, 0, 1000));\n    float b = sdBox(p + vec3(0.05, sin(iTime * 4. + cp.x * 10.)* 0.4, 0.05), vec3(0.07, 0.07 + cps * 2.2, 0.07));\n  \n    return vec2(min(b,w),b < w ? 0 : 1);\n}\n\nvec3 norm(vec3 p) {\n    float E = 0.0001; vec2 k = vec2(1,-1);\n  \n  return normalize(\n      k.xyy * map(p + k.xyy * E).x +\n  k.yyx * map(p + k.yyx * E).x +\n  k.yxy * map(p + k.yxy * E).x +\n  k.xxx * map(p + k.xxx * E).x\n );\n}\n\nvec3 pal(float t) {\n    vec3 a = vec3(0.6);\n    vec3 b = vec3(0.7);\n  \n    vec3 c = vec3(1);\n    vec3 d = vec3(0,.2, .4);\n  \n  return a + b * cos(6.283 * (c * t + d));\n}\n\nvec3 tr(vec3 ro, vec3 rd) {\n    float td = 0.1;\n    vec2 h;\n  \n    vec4 c = vec4(0);\n    float bnc = 0.;\n    float en = 1.;\n   \n    for (int i = 0; i < 1000; i++) {\n        vec3 ip = ro + rd * td;\n        h = map(ip);\n        td += h.x * 0.1;\n        \n        if (h.x < 0.01) {\n            if (h.y == 0.) {\n              c +=  vec4(pal(cps * 2.) * en, 1) * en;\n            }\n            else if (h.y == 1.) {\n                //float f = texture(iChannel1,  vec2(0, fract(ip.y / 3. + iTime + sin(ip.z * 2.) / 10.))).r;\n                //c += vec4(vec3(f) * 1. * pal(iTime + ip.y + iTime), 0.1);\n                float f = smoothstep(0.7,1.,\n                    texture(iChannel1, vec2(0, fract(ip.y / 3. + iTime + sin(ip.z * 2.) / 10. - sin(ip.z / 10. + iTime)))).r);\n                c += vec4(vec3(f) * pal(iTime * 2. + ip.y),0.01);\n \n                ro = ip; \n                vec3 inorm = norm(ip);\n                rd = reflect(rd, inorm) + (texture(iChannel2, ip.yz).r - 0.5) * 0.1;\n                td = 0.1;\n                bnc += 1.;\n                en = max(en - 0.4, 0.);\n            }\n        }\n        \n        if (td > 1000. || bnc > 2. || en <= 0. || c.a >= 1.) break;\n    }\n  \n    return vec3(c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(sin(iTime * 2.), 4. + sin(iTime),0);\n    vec3 tar = vec3(0,0,-10);\n    vec3 rd = cam(ro, tar, uv);\n    vec3 t = tr(ro, rd);\n  \n    fragColor = vec4(t,1.0);\n    //fragColor = (texture(iChannel1,  vec2(0, fract(uv.y))));\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float ffti(float a) {\n    return texture( iChannel0, vec2(0,a)).x;\n}\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    vec2 uvv = uv;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n    vec2 pv = vec2((fragCoord.x-1.) / iResolution.x, fragCoord.y / iResolution.y);\n  \n    float a = fragCoord.x < 1. ? ffti(uvv.y) : texture(iChannel1, pv).a;\n\n    C = vec4(a);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float ffti(float a) {\n    return texture( iChannel0, vec2(a,0)).x;\n}\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\n    C = vec4(ffti(uv.y));\n}", "buffer_b_inputs": [{"id": 27155, "src": "https://soundcloud.com/apex-music/london-elektricity-just-one-second-apex-rmx", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 114], [116, 116, 154, 154, 321], [323, 323, 352, 352, 394], [396, 396, 436, 436, 463], [464, 464, 499, 499, 549], [572, 572, 590, 590, 1075], [1077, 1077, 1096, 1096, 1302], [1304, 1304, 1323, 1323, 1473], [1475, 1475, 1502, 1502, 2683], [2686, 2686, 2743, 2743, 3086]]}
{"id": "ssjXWV", "name": "anticore - Outline SS QF #2", "author": "anticore", "description": "Outline demoparty 2021 shader showdown quarterfinals, match #2\n", "tags": ["ye"], "likes": 6, "viewed": 331, "published": 3, "date": "1621076342", "time_retrieved": "2024-07-30T19:20:21.261007", "image_code": "float ffti(float a) {\n    return texelFetch( iChannel0, ivec2(a,0), 0 ).x;\n}\n\nfloat ffts(float a) {\n    return 0.;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    return length(max(abs(p) - b, 0.));\n}\n\nfloat smin(float d1, float d2, float k){\n    float h = max(k - abs(d1 - d2), 0.); \n    return min(d1, d2) - h * h * .25 / k;\n}\n\nvec3 repl(vec3 p, vec3 c, vec3 l) {\n    return p - c * clamp(round(p / c), -l, l);\n}\n\nvec3 rep(vec3 p, vec3 c) {\n    return mod(p + .5 * c, c) - .5 * c;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n  \n    return mat2(c, s,-s, c);\n}\nfloat PI = acos(-1.);\nfloat hei = 1.;\nfloat sdE(vec3 p) {\n  float e = sdBox(p, vec3(0.1, hei, 0.1));\n  e = smin(e, sdBox(repl(p + vec3(0.4,0,0), vec3(1), vec3(0,.9,0)), vec3(hei / 2., 0.1, 0.1)), 0.1);\n  \n  return e - 0.1;\n}\n\nfloat sdY(vec3 p) {\n    float y = sdBox(p + vec3(0, hei / 2., 0), vec3(0.1, hei / 2., 0.1));\n    vec3 pp = p + vec3(0.3, -hei / 2., 0);\n    pp.xy *= rot(PI / 6.);\n    y = smin(y, sdBox(pp, vec3(0.1, hei / 2., 0.1)), 0.1);\n    pp = p + vec3(-0.3, -hei / 2., 0); pp.xy *= rot(-PI / 6.);\n    y = smin(y, sdBox(pp, vec3(0.1, hei/2., 0.1)), 0.1);\n  \n    return y - 0.1;\n}\n\nfloat dirlight(vec3 n, vec3 ld) {\n     ld = normalize(ld);\n    return clamp(max(dot(n, ld), 0.0), 0., 1.);\n}\n\nfloat spec(vec3 p, vec3 n, vec3 ld) {\n     ld = normalize(ld);\n    vec3 r = reflect(-ld, n);\n    vec3 v = normalize(-p);\n    return pow(max(dot(r,v) , 0.), 100.5);\n}\n\nvec2 map(vec3 p) {\n    p = rep(p + vec3(sin(p.z), cos(p.z), sin(p.y / 3. + iTime)), vec3(10));\n    float y = sdY(p + vec3(-1,0,5));\n    float e = sdE(p + vec3(0,0,5));\n    float ye = min(y, e);\n    ye -= ffti(0.) * 0.3;\n  \n    return vec2(ye,0);\n}\n\nvec3 norm(vec3 p) {\n    float E = 0.001; vec2 k = vec2(1,-1);\n    \n    return normalize(\n    k.xyy * map(p + k.xyy * E).x +\n  k.yyx * map(p + k.yyx * E).x +\n  k.yxy * map(p + k.yxy * E).x +\n  k.xxx * map(p + k.xxx * E).x\n    );\n}\n\nvec3 pal(float t) {\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1);\n    vec3 d = vec3(0, .2, .4);\n    return a + b * cos(6.283 * (c * t + d));\n}\n\nvec3 tr(vec3 ro, vec3 rd) {\n    float td = .1;\n    vec2 h;\n  \n    for (int i = 0; i < 1000; i++) {\n      \n        vec3 ip = ro + rd * td;\n        h = map(ip);\n        td += h.x * 0.3;\n      \n        if (h.x < 0.01) {\n            vec3 inorm = norm(ip);\n            vec3 ld = vec3(0, 2, 10);\n            return (pal(iTime + ip.z / 100. + ip.y / 100.) * dirlight(inorm, ld) + spec(ip, inorm, ld) * 1.) * exp(-td * 0.02);\n        }\n    }\n  \n    return vec3(0);\n}\n\nvec3 cam(vec3 ro, vec3 tar, vec2 uv) {\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0,1,0), f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l * uv.x + u * uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 ro = vec3(iTime * 2.,3. * sin( iTime), 0.);\n    vec3 tar = vec3(iTime * 2., 0., -5.);\n    vec3 rd = cam(ro, tar, uv);\n  \n\tfragColor = vec4(tr(ro, rd), 1);\n}", "image_inputs": [{"id": 27154, "src": "https://soundcloud.com/worinpro/machinedrum-center-your-love", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 76], [78, 78, 99, 99, 116], [118, 118, 147, 147, 189], [191, 191, 231, 231, 317], [319, 319, 354, 354, 403], [405, 405, 431, 431, 473], [475, 475, 494, 494, 572], [611, 611, 630, 630, 797], [799, 799, 818, 818, 1165], [1167, 1167, 1200, 1200, 1275], [1277, 1277, 1314, 1314, 1442], [1444, 1444, 1462, 1462, 1691], [1693, 1693, 1712, 1712, 1922], [1924, 1924, 1943, 1943, 2090], [2092, 2092, 2119, 2119, 2550], [2552, 2552, 2590, 2590, 2754], [2756, 2756, 2813, 2813, 3086]]}
{"id": "7dBSWV", "name": "mirror_", "author": "mdb", "description": "ray tracing reflection on a dirty miror", "tags": ["raytracing"], "likes": 1, "viewed": 258, "published": 3, "date": "1621075644", "time_retrieved": "2024-07-30T19:20:22.063861", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    col = pow(col, vec3(1.8));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.14159265359\n#define SAMPLES 64\n\n// pseudo random numbers////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 uv){\n    seed = uint(uv.y*iResolution.x + uv.x) + uint(iTime*6000000.0);\n}\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n\nvec3 newDir(vec3 n){\n    float teta = random()*2.0*PI;\n    float z = random()*2.0-1.0;\n    vec3 v = vec3(sqrt(1.0-z*z)*cos(teta), sqrt(1.0-z*z)*sin(teta), z); \n    if (dot(n, v)<0.0);\n        return -v;\n    return v;\n}\n////////////////////////////////////////////////////////////////////////\n\nvec2 box(vec3 ro, vec3 rd, vec3 up, vec3 down){\n        \n        vec3 dirfrac = 1.0 / rd;\n        vec3 tdown = (down - ro)*dirfrac;\n        vec3 tup = (up - ro)*dirfrac;\n\n        float tmin = max(max(min(tdown.x, tup.x), min(tdown.y, tup.y)), min(tdown.z, tup.z));\n        float tmax = min(min(max(tdown.x, tup.x), max(tdown.y, tup.y)), max(tdown.z, tup.z));\n\n        // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us\n        if (tmax < 0.0) return vec2(-1.0);\n\n        // if tmin > tmax, ray doesn't intersect AABB\n        if (tmin > tmax) return vec2(-1.0);\n\n        return vec2(tmin, tmax);\n}\n\n\nvec3 getScene(vec3 ro, vec3 rd){\n    \n    vec3 n = vec3(-1.0, 0.0, 0.0);\n    float t = box(ro, rd, vec3(1.0, 5.5, 8.0), vec3(0.9, -5.5, -8.0)).x;\n    if (t < 0.0) return vec3(0.0);\n    \n    ro = ro + t*rd;\n\n    vec2 uv = ro.zy * 2.0;\n    float weight = texture(iChannel1, uv).x;\n    weight = pow(weight*1.9, 1.4);\n    \n    if(random() < clamp(1.0 - weight, 0.0, 0.8)){\n        float x = ro.x;\n        float depth = 0.03;\n        ro += rd*depth;\n        ro.x = x;\n        uv = ro.zy * 2.0;\n        weight = texture(iChannel1, uv).x;\n        weight = pow(weight*1.4, 1.4);\n    }\n    \n    weight = clamp(weight, 0.2, 0.55);\n    \n    //light\n    vec3 rVec = reflect(rd, n);\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < SAMPLES; i++){\n        vec3 nVec = newDir(n);\n        rd = mix(rVec, nVec, weight);\n        rd = normalize(rd);\n        t = box(ro, rd, vec3(0.5, 1.0, 2.0), vec3(-0.8, 0.97, -0.5)).x;\n        if (t > 0.0) col += vec3(6.0);\n    }\n    col /= float(SAMPLES);\n                   \n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col;\n    initRandomGenerator(fragCoord);\n    \n    //get ray\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    float t = iTime*0.6;\n    vec3 camPos = vec3(sin(t*0.5)*0.2, sin(t + 3.0)*0.3, -0.1-0.5*(1.0 + sin(t*0.5)));\n    vec3 target = vec3(0.4, 0.0, 0.0);\n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec2 off = vec2(random(),random()) / iResolution.y;\n    uv += off;\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    \n    col = getScene(camPos, rd);\n    vec3 last = texture(iChannel0,  fragCoord/iResolution.xy).xyz;\n    float weight = 0.3;\n    col = mix(last, col, weight);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBSWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 261]]}
{"id": "fdjXWV", "name": "Box Marching", "author": "oneshade", "description": "I saw a couple of shaders that showed analytic maxnorm distances to shapes that are difficult or impossible to get exact euclidean distances to and thought why not use boxes instead of circles/spheres to raymarch them? I think it turned out pretty well!", "tags": ["raymarching", "distancefields", "ray", "box", "maxnorm", "boxmarching"], "likes": 25, "viewed": 518, "published": 3, "date": "1621045539", "time_retrieved": "2024-07-30T19:20:22.817845", "image_code": "// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    return abs(dot(p - a, normalize(b - a).yx * vec2(-1.0, 1.0)));\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, q.y));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\nfloat mapScene(in vec2 p) {\n    vec2 v1 = vec2(-2.0, -2.0 + cos(iTime));\n    vec2 v2 = vec2(4.0, 2.0);\n    vec2 v3 = vec2(-4.0, 2.0);\n    vec2 v4 = vec2(2.0, -2.0 + sin(iTime));\n\n    vec2 a = v4 + 3.0 * (v2 - v3) - v1;\n    vec2 b = 3.0 * (v1 - 2.0 * v2 + v3);\n    vec2 c = 3.0 * (v2 - v1);\n    vec2 d = v1;\n\n    float loop = sdCubic(p, a, b, c, d, 0.1, 0.9, true) - 0.01;\n    float box = sdBox(p - vec2(2.0, 0.8), vec2(0.75, 0.35), iTime);\n    float line = sdLine(p, vec2(-2.0, 1.0 - 0.5 * cos(iTime)), vec2(-0.5, 1.5)) - 0.01;\n    float ellipse = sdEllipse(p - vec2(-2.0, -1.25), vec2(1.0 + 0.25 * cos(iTime), 0.35 + 0.2 * sin(iTime)));\n    float tanglesquare = sdTanglesquare((p - vec2(2.0, -0.9)) * 2.0, 16.0, -25.0, 8.0 + 10.0 * cos(iTime)) * 0.5;\n\n    return min(min(loop, min(box, min(line, ellipse))), tanglesquare);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Default before mouse interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec4(-1.75, 0.5 * sin(iTime), -2.5, 0.0);\n\n    // 2D ray\n    vec2 ro = mouse.zw;\n    vec2 rd = mouse.xy - mouse.zw;\n\n    // Draw the scene\n    float scene = mapScene(uv);\n    drawSDF(scene, vec3(0.0, 0.0, 1.0));\n    color += 0.125 + 0.125 * sin(scene * 100.0);\n\n    // Draw the ray\n    drawSDF(sdInfLine(uv, ro, ro + rd), vec3(1.0, 0.8, 0.0));\n    drawSDF(sdVectorArrow(uv - ro, rd * 0.75), vec3(1.0));\n\n    // Box march!\n    float t = 0.0;\n    rd /= max(abs(rd.x), abs(rd.y)); // Convert to maxnorm\n    for (int i=0; i < 50; i++) {\n        vec2 p = ro + rd * t;\n        float d = mapScene(p);\n        drawSDF(abs(sdBox(uv - p, vec2(abs(d)))), vec3(1.0, 0.0, 0.0)); // Draw bounding box\n        if (d < 0.001 || t > 10.0) break; // Break on hit or miss\n        t += d; // Step forward\n    }\n\n    // Output\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Line segment SDF\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a, s = sign(ba);\n    vec2 to = abs(pa - ba * clamp(dot(pa, s) / dot(ba, s), 0.0, 1.0));\n    return max(to.x, to.y);\n}\n\n// Oriented box SDF\n// https://www.shadertoy.com/view/stSGDh\nfloat sdBox(in vec2 p, in vec2 dims, in float rot) {\n    float u = cos(rot), v = sin(rot);\n\n    vec4 h = vec4(dims * u, dims * v);\n    vec2 a = vec2(h.x - h.w, h.z + h.y);\n    vec2 b = vec2(h.x + h.w, h.z - h.y);\n\n    vec2 qa = abs(mat2(u, -v, v, u) * p) - dims;\n    vec2 qb = abs(p) - max(abs(a), abs(b));\n\n    return max(max(qb.x, qb.y), max(qa.x, qa.y) / max(abs(u - v), abs(u + v)));\n}\n\n// Ellipse SDF\n// https://www.shadertoy.com/view/fljGDW\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    p = abs(p);\n    p = max(p, (p - ab).yx);\n    float ba = ab.y / ab.x, a = ba * ba + 1.0;\n    float b = p.y - p.x, bb = b * b;\n    return p.x - (sqrt(bb - (bb - ab.y * ab.y) * a) - b) / a;\n}\n\n// Tanglesquare SDF - analytical, no quartics!\n// https://www.shadertoy.com/view/st2SzK\nfloat sdTanglesquare(in vec2 p, in float a, in float b, in float c) {\n    p = abs(p); // Quadrant symmetry\n    if (p.y > p.x) p = p.yx; // Diagonal symmetry\n\n    // Upper-right critical point in the top right quadrant \n    vec2 crit = p - vec2(sqrt((-b + sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)), sqrt(-b / (2.0 * a)));\n    float d = max(abs(crit.x), abs(crit.y));\n\n    // Lower critical point in the top right quadrant\n    if (abs((b * b) / (a * c) - 3.0) < 1.0) {\n        crit = p - vec2(sqrt(-b / (2.0 * a)), sqrt((-b - sqrt(2.0 * b * b - 4.0 * a * c)) / (2.0 * a)));\n        d = min(d, max(abs(crit.x), abs(crit.y)));\n    }\n\n    else {\n        crit = p - vec2(sqrt((-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a)), 0.0); // Rightmost middle critical point\n        d = min(d, max(abs(crit.x), abs(crit.y)));\n\n        float h = b * b - 4.0 * a * c;\n        if (h > 0.0) {\n            float x = (-b - sqrt(h)) / (2.0 * a);\n            if (x > 0.0) {\n                crit = p - vec2(sqrt(x), 0.0); // Next critical point to the left\n                d = min(d, max(abs(crit.x), abs(crit.y)));\n            }\n        }\n    }\n\n    // Diagonal ray intersection\n    vec2 p2 = p * p, p3 = p2 * p, p4 = p3 * p;\n    float sum1 = p.x + p.y, sum2 = p2.x + p2.y, sum4 = p4.x + p4.y;\n    float diff1 = p.x - p.y;\n\n    // (ux^2 + vx + w)^2 + t = 0 ---> ux^2 + vx + w = (+/-)sqrt(-t)\n    float u = sqrt(2.0 * a);\n    float v = sum1 * u;\n    float w = ((3.0 * sum2 - sum1 * sum1) * a + b) / u;\n    float t = sqrt(w * w - sum4 * a - sum2 * b - c);\n\n    // ux^2 + vx + w = +sqrt(-t)\n    float h = v * v - 4.0 * u * (w - t);\n    float k = 2.0 * u;\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // ux^2 + vx + w = -sqrt(-t)\n    h = v * v - 4.0 * u * (w + t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // Other diagonal ray intersection\n    v = diff1 * u;\n    w = ((3.0 * sum2 - diff1 * diff1) * a + b) / u;\n    t = sqrt(w * w - sum4 * a - sum2 * b - c);\n\n    // ux^2 + vx + w = +sqrt(-t)\n    h = v * v - 4.0 * u * (w - t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    // ux^2 + vx + w = -sqrt(-t)\n    h = v * v - 4.0 * u * (w + t);\n    if (h > 0.0) {\n        h = sqrt(h);\n        d = min(d, min(abs(v - h), abs(v + h)) / k);\n    }\n\n    return d * sign(sum4 * a + sum2 * b + c);\n}\n\n// Cubic curve SDF\n// https://www.shadertoy.com/view/ft2GRD\nvec3 solveQuadratic(in float a, in float b, in float c) {\n    float h = b * b - 4.0 * a * c;\n    if (h < 0.0) return vec3(0.0);\n    return vec3((vec2(-1.0, 1.0) * sqrt(h) - b) * 0.5 / a, 2.0);\n}\n\nconst vec2 eta = vec2(-0.5, sqrt(0.75));\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d;\n\n    b /= a, c /= a, d /= a;\n    float d0 = b * b - 3.0 * c;\n    float d1 = (2.0 * b * b - 9.0 * c) * b + 27.0 * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) + abs(C.y) < 1e-3) C = vec2(d1 - j, 0.0);\n    float t = atan(C.y, C.x) / 3.0, r = pow(0.25 * dot(C, C), 1.0 / 6.0);\n    C = vec2(cos(t), sin(t));\n\n    vec3 roots;\n    float w = -d0 / r - r;\n    roots.x = (C.x * w - b) / 3.0;\n    roots.y = (dot(vec2(C.x, -C.y), eta) * w - b) / 3.0;\n    if (h > 0.0) roots.z = (dot(C, eta) * w - b) / 3.0;\n    else if (abs(dot(C.yx, eta)) < abs(C.y)) roots.x = roots.y;\n\n    return vec4(roots, h < 0.0 ? 1 : 3);\n}\n\nfloat evalDist(in vec2 p, in float t, in float tmin, in float tmax, in bool limit, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    if (limit) t = clamp(t, tmin, tmax);\n    vec2 toCurve = p - (((a * t + b) * t + c) * t + d);\n    return max(abs(toCurve.x), abs(toCurve.y));\n}\n\nfloat sdCubic(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float tmin, in float tmax, in bool limit) {\n    vec2 dp = d - p;\n\n    vec4 minMax1 = solveCubic(a.x - a.y, b.x - b.y, c.x - c.y, dp.x - dp.y);\n    vec4 minMax2 = solveCubic(a.x + a.y, b.x + b.y, c.x + c.y, dp.x + dp.y);\n\n    vec3 minMax3 = solveQuadratic(3.0 * a.x, 2.0 * b.x, c.x);\n    vec3 minMax4 = solveQuadratic(3.0 * a.y, 2.0 * b.y, c.y);\n\n    float dist = evalDist(p, minMax1[0], tmin, tmax, limit, a, b, c, d);\n    for (int n=1; n < int(minMax1.w); n++) dist = min(dist, evalDist(p, minMax1[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax2.w); n++) dist = min(dist, evalDist(p, minMax2[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax3.z); n++) dist = min(dist, evalDist(p, minMax3[n], tmin, tmax, limit, a, b, c, d));\n    for (int n=0; n < int(minMax4.z); n++) dist = min(dist, evalDist(p, minMax4[n], tmin, tmax, limit, a, b, c, d));\n\n    return dist;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjXWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 102, 147, 147, 215], [217, 217, 267, 267, 336], [338, 338, 373, 373, 458], [460, 460, 514, 514, 790], [792, 792, 835, 835, 1023], [1025, 1025, 1052, 1052, 1850], [1852, 1852, 1907, 1926, 3107]]}
{"id": "sdBSDV", "name": "ECSS", "author": "Molive", "description": "https://society.ecs.soton.ac.uk", "tags": ["2d", "logo"], "likes": 3, "viewed": 348, "published": 3, "date": "1621030878", "time_retrieved": "2024-07-30T19:20:23.629675", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5 vertically, -AR to AR horizontally)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= iResolution.x/iResolution.y/2.;\n    uv.y -= 0.5;\n    \n    // Antialias\n    float low = 1./iResolution.y/2.;;\n    vec3 o = vec3(low,-low,0.);\n    vec3 col = (logo(uv+o.xx,iTime)\n               +logo(uv+o.xy,iTime)\n               +logo(uv+o.yx,iTime)\n               +logo(uv+o.yy,iTime)\n               +logo(uv+o.yz,iTime)\n               +logo(uv+o.zy,iTime)\n               +logo(uv+o.zz,iTime)\n               +logo(uv+o.zx,iTime)\n               +logo(uv+o.xz,iTime))/9.;\n               \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// logo go spinny\nvec3 logo(vec2 u, float time) {\n    mat2 x = mat2(cos(time),sin(time),-sin(time),cos(time));\n    mat2 y = mat2(sin(time),cos(time),-cos(time),sin(time));\n    float l = length(u);\n    \n    if (l < .17) {\n        return vec3(1.);\n    } else if (l < .22) {\n        u = x*u;\n        if (abs(u.y) < 0.02) {\n            return vec3(1.);\n\n        } else {\n            return vec3(.82,.0,.1);\n        }\n    } else if (l < .25) {\n        return vec3(1.);\n    } else if (l < .4) {\n        u = y*u;\n        if (l > .32) {\n            float a = fract((atan(u.y,u.x)/(atan(-1.)*4.)+0.5)*3.);\n            if ((l > 0.37) && (a > .85-(l*2.) && a < .15+(l*2.))) {\n                return vec3(1.);\n            } else if (a > 0.275-l/2. && a < 0.725+l/2.) {\n                return vec3(1.);\n            }\n        }\n        if (abs(u.y) < 0.02) {\n            return vec3(1.);\n        } else if (u.y < 0.) {\n            return vec3(0.35,0.32,0.32);\n        } else {\n            return vec3(0.12);\n        }\n    } else if (l < .44) {\n        return vec3(1.);\n    } else if (l < .5) {\n        return vec3(0.12);\n    } \n    \n    //flashy colours\n    return vec3((sin(u.y+time*2.)+1.)/2.,(sin(u.x+time*3.)+1.)/2.,(sin(u.y+time*5.)+1.)/2.);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBSDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 147, 742]]}
{"id": "ttyBz1", "name": "planet01", "author": "cody_shader", "description": "реймарчинг", "tags": ["raymarching"], "likes": 3, "viewed": 260, "published": 3, "date": "1621025647", "time_retrieved": "2024-07-30T19:20:24.378672", "image_code": "#define ITERATION 500\n#define MAX_DIST 10.\n#define EX vec3(0.001, 0., 0.)\n#define EY vec3(0., 0.001, 0.)\n#define EZ vec3(0., 0., 0.001)\n#define w iResolution.x\n#define h iResolution.y\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat random (vec2 st) {\n    \n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return fract(abs(sin(st)*43758.5453123));\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 4\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .6;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nfloat dist(vec3 a, vec3 b) { //Считает расстояние между точками в трехмерном пространстве\n\treturn sqrt(pow(a.x - b.x, 2.) + pow(a.y - b.y, 2.) + pow(a.z - b.z, 2.));\n}\n\nvec3 normalize(vec3 a) { //Нормализует вектор\n    float l = dist(a, vec3(0.,0.,0.));\n    return vec3(a.x / l, a.y / l, a.z / l);\n}\n\nvec3 sum(vec3 a, vec3 b) { //Суммирует вектора\n\treturn vec3(a.x + b.x, a.y + b.y, a.z + b.z);\n}\n\nvec3 sub(vec3 a, vec3 b) { //Вычитает вектора\n\treturn vec3(a.x - b.x, a.y - b.y, a.z - b.z);\n}\n\nvec3 mul(vec3 a, float value) { //Умножает вектор на значение\n\treturn vec3(a.x * value, a.y * value, a.z * value);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat m = max(min(0.5 + 0.5 * (b - a) / k, 1.), 0.);\n\treturn a * m + b * (1. - m) - k * m * (1. - m);\n}\n\n\n\n\nfloat getDistdotsentra(vec3 p) { //ПОЛУЧИТЬ РАССТОЯНИЕ ОТ ТОЧКИ ДО центра сферы\n\tvec3 sphere = vec3(0.,0.,0.);\n\tfloat sphereDist = dist(p, sphere) - 1.5 ;\n\tfloat d = sphereDist;\n\treturn d;\n\n}\n\nvec3 normalforlit(vec3 p) {\n\tfloat d = getDistdotsentra(p);\n\tfloat p1 = getDistdotsentra(sub(p, EX));\n\tfloat p2 = getDistdotsentra(sub(p, EY));\n\tfloat p3 = getDistdotsentra(sub(p, EZ));\n\tvec3 tri = vec3(p1, p2, p3);\n\tvec3 n = sub(vec3(d,d,d), tri);\n\treturn normalize(n);\n}\n\n\nvec2 getDist(vec3 p) { //ПОЛУЧИТЬ РАССТОЯНИЕ ОТ ТОЧКИ ДО СФЕРЫ\n\tvec3 sphere = vec3(0.,0.,0.);\n    vec3 n = normalforlit(p);\n    \n    vec2 st = p.xy;\n    \n    st.y+= iTime*0.1;\n    \n     // Масштаб\n    float mashtab = 15.;\n    st *= mashtab;\n\n    // Разбиение пространства\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 100.0;\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Соседняя клетка\n            vec2 neighbor = vec2(float(x),float(y));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.5+0.5*sin(iTime + 6.2831*point);\n            vec2 diff = neighbor + point - f_st; //вектор до точки\n            float dist = length(diff) + 1.*sin(point.x); // Расстояние до точки\n            m_dist = min(m_dist, dist); // Сохранить наименьшее расстояние\n        }\n    }\n\n    //float line = 1./(iResolution.y/mashtab);\n    //vec3 col = vec3(m_dist);\n    //fragColor = vec4(col,1.0);\n    \n    \n\tfloat sphereDist = dist(p, sphere) - m_dist*0.1 - 1.3 ;\n    float fraktal_noise = dist(p, sphere)  - fbm(vec2(n.x*4.+iTime*0.7, n.y*4.))*0.7 - 1. ; \n    \n    float d = smin(sphereDist, fraktal_noise, 0.1);\n    //  + fbm(vec2(n.x*5.+iTime, n.y*5.))*0.5\n    // фрактальный шум\n    float t = 0.;\n    if (sphereDist>fraktal_noise) t = 1.;\n    \n\t//float d = sphereDist;\n\treturn vec2(d, t);\n\n}\n\n\nvec3 normal(vec3 p) {\n\tfloat d = getDist(p).x;\n\tfloat p1 = getDist(sub(p, EX)).x;\n\tfloat p2 = getDist(sub(p, EY)).x;\n\tfloat p3 = getDist(sub(p, EZ)).x;\n\tvec3 tri = vec3(p1, p2, p3);\n\tvec3 n = sub(vec3(d,d,d), tri);\n\treturn normalize(n);\n}\n\n\n\n\n\nfloat light(vec3 p) {\n\t//vec3 lightPos = vec3(-10., 4., 0.);\n    vec3 lightPos = vec3(sin(iTime)*3., 1., cos(iTime)*3.);\n\tvec3 lightDir = normalize(sub(lightPos, p));\n\tvec3 n = normalforlit(p);\n\treturn dot(n, lightDir) * 0.5  + 0.5;\n}\n\nvec3 rayMarching(vec3 ro, vec3 rd) {\n\tvec3 p = ro;\n\tfor (int i = -0; i < 500; i++){\n\t\tfloat d = getDist(p).x;\n        float t = getDist(p).y;\n\t\tif (d > MAX_DIST) {break;}\n\t\tp = sum(p, mul(rd, d));\n\t\tif (d < 0.0001){\n\t\t\t//let dif = i / ITERATION\n\t\t\t//dif = dif+dif\n            float l = light(p);\n            float n = 2.;\n\t\t\treturn vec3(\n            pow(l*t,5.),\n            pow(l,n),\n            pow(l*(1.-t),n)\n            \n            );\n\t\t} \n\t}\n\treturn vec3(0.,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int iteration = 500;\n    const float max_dist = 10.0;\n\n\t//координаты камеры\n\tvec3 ro = vec3(0., 0., -2.5);\n\n    float x = (fragCoord.x / w) * 2. - 1.;\n    float y = (fragCoord.y / h) * 2. - 1.;\n    x *= w / h;\n\n    //направление луча\n    vec3 rd = vec3(x, y , 1.);\n    rd = normalize(rd);\n\n    //круг\n    vec3 color = rayMarching(ro, rd);\n\t\t\t\n\t\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 296, 320, 320, 397], [399, 399, 421, 421, 554], [556, 634, 660, 660, 1040], [1060, 1060, 1084, 1106, 1360], [1363, 1363, 1391, 1504, 1582], [1584, 1584, 1608, 1646, 1731], [1733, 1733, 1759, 1795, 1844], [1846, 1846, 1872, 1906, 1955], [1957, 1957, 1988, 2042, 2097], [2099, 2099, 2138, 2138, 2243], [2248, 2248, 2280, 2365, 2477], [2479, 2479, 2506, 2506, 2751], [2754, 2754, 2776, 2848, 4266], [4269, 4269, 4290, 4290, 4507], [4513, 4513, 4534, 4573, 4747], [4749, 4749, 4785, 4785, 5223], [5225, 5225, 5282, 5282, 5747]]}
{"id": "NsB3Ry", "name": "04042021", "author": "Pixdigit", "description": "Some shader practice", "tags": ["blobs"], "likes": 3, "viewed": 258, "published": 3, "date": "1621013824", "time_retrieved": "2024-07-30T19:20:25.222416", "image_code": "mat2 rot(float deg) {\n    float s = sin(deg);\n    float c = cos(deg);\n    return mat2(c, -s, s, c);\n}\n\nvec3 pal(vec3 off) {\n    return 0.5 + 0.5*cos(off+vec3(0,2,4));\n}\n\nfloat nsin(float deg) {\n    return sin(deg) * 0.5 + 0.5;\n}\n\nfloat rand(vec2 seed) {\n    return fract(sin(dot(seed,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    const float scale = 20.;\n    vec2 uv = fragCoord/iResolution.x * scale;\n    vec2 offset = vec2(iTime * 0.1);\n    vec2 guv = fract(uv + offset) * 2. - 1.;\n    vec2 gid = floor(uv + offset) * 2.;\n\n\n    vec3 col = vec3(1.);\n    \n    float dScale = 0.3;\n    float dSpeed = 2.;\n    float diag = 1.- max(nsin((gid.x-gid.y - iTime*dSpeed) * dScale), nsin((gid.x+gid.y + iTime*dSpeed) * dScale));\n    col *= smoothstep(1., .8, length(guv) + smoothstep(0., .5, diag));\n    if (rand(gid) < rand(gid.yx)) {\n        col *= pal(vec3(rand(gid)*100.));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsB3Ry.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 101], [103, 103, 123, 123, 168], [170, 170, 193, 193, 228], [230, 230, 253, 253, 323], [326, 326, 383, 433, 1039]]}
{"id": "7sSXWK", "name": "illuminated sphere", "author": "LelloPisello", "description": "my first shader\na raytraced sphere (only diffuse and specular) \nmove with mouse (no rotation support)\ni'm not sure I'm applying normals properly\nadd a custom normal map to make it look decent\n", "tags": ["raytracing", "raytracing", "illumination", "normals", "cineshader"], "likes": 0, "viewed": 5867, "published": 3, "date": "1621006159", "time_retrieved": "2024-07-30T19:20:26.012304", "image_code": "//paste this snippet in your browser's javascript console to add a normal map\n/*\ngShaderToy.SetTexture(0, {mSrc:'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/daa69c9f-c54f-4f10-a57f-185a25677132/d6sulh0-9d2ecd83-43d4-4c10-943c-0077b19c778c.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcL2RhYTY5YzlmLWM1NGYtNGYxMC1hNTdmLTE4NWEyNTY3NzEzMlwvZDZzdWxoMC05ZDJlY2Q4My00M2Q0LTRjMTAtOTQzYy0wMDc3YjE5Yzc3OGMuanBnIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.wXxYlNM9PT-eqrwObuP53O6qDJCPl0gNQfvfwK80I6I', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n\n//number of lights, if you add some change this to fit the actual number\n#define LIGHTS 3\n\n//exponent for the specular highlight\n#define EXPONENT 25.0\n\n//if you want the sphere to have the same color as the normal map set this to 1\n#define TEXTURED 0\n\nstruct light\n{\n    vec3 position;\n    vec4 color;\n};\n\nprecision highp float;\n\nvec3 raySphereIntersection(in vec3 rayOrigin, in vec3 rayDir, in vec4 sphere)\n{\n    vec3 oc = rayOrigin - sphere.xyz;\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float discriminant = b * b - 4.0 * c;\n    if(discriminant < 0.0)\n    {\n        return vec3(-1);\n    }\n    else\n    {\n        float t = (-b - sqrt(discriminant)) / (2.0);\n        vec3 endpoint = rayDir * t + rayOrigin;\n        if(endpoint.y < rayOrigin.y) return vec3(-1);\n        return endpoint;\n    }\n}\n\n//only works for a sphere, works anyways if you use no normal map\nvec3 calculateLighting(vec3 position, vec3 normal, vec2 uv, light lights[LIGHTS], vec3 camera)\n{\n    //convert from tangent space to world space\n    {\n        mat3 conversion;\n        conversion[0] = normalize(cross(vec3(0, 0, 1), normal));\n        conversion[1] = normalize(cross(normal, conversion[0]));\n        conversion[2] = normal;\n        {\n            vec3 normmap = texture(iChannel0, uv).rgb * 2.0 - 1.0;\n            normmap = normalize(normmap);\n            normal = normmap * conversion;\n        }\n    }\n    vec3 total = vec3(0.0);\n    for(int i = 0; i < LIGHTS; ++i)\n    {\n        \n        vec3 to_light = lights[i].position - position;\n        vec3 incoming = normalize(position - camera);\n        total +=\n            (\n                max(dot(normal, normalize(to_light)), 0.0) + \n                pow(max(dot(normal, normalize((to_light + incoming) * 0.5)), 0.0), EXPONENT)\n            ) * lights[i].color.a / length(to_light) * lights[i].color.rgb;\n    }\n    #if TEXTURED == 1\n    return total * texture(iChannel0, uv).rgb * 0.5;\n    #else\n    return total * 0.5;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //objects\n    //add lights here\n    //the alpha component in the color field of the light struct represents the light's intensity\n    const light lights[LIGHTS] = light[LIGHTS](\n        light(vec3(-0.5, 1.0, 1.25), vec4(1.0, 0.0, 0.0, 1.75)),\n        light(vec3(1.5, 0.5, -0.75), vec4(0.2, 1.0, 0.4, 1.0)),\n        light(vec3(-1.75, 4, 2.0), vec4(0.0, 0.0, 1.0, 5))\n    );\n    //camera position\n    vec3 camera = vec3((iMouse.x / iResolution.x - .5) * 5.0, -5.0, (iMouse.y / iResolution.y - .5) * 5.0);\n    //sphere position\n    vec4 sphere = vec4(cos(iTime * 2.5), sin(iTime * 5.0), 0.0, 1.5);\n    #if TEXTURED != 1\n    vec3 sphereColor = vec3(1.0, 1.0, 1.0);\n    #endif\n    \n    //rendering\n    vec3 rayDir = \n    normalize(vec3\n    (\n        fragCoord.x - iResolution.x / 2.0,\n        iResolution.y / 1.5,\n        fragCoord.y - iResolution.y / 2.0\n    ));\n    vec3 intersect = raySphereIntersection(camera, rayDir, sphere);\n    if(intersect == vec3(-1)) fragColor = vec4(vec3(0.0), 1.0);\n    else \n    {\n        vec3 normal = normalize(intersect - sphere.xyz);\n        vec2 uv = (intersect.xz - sphere.xz) / sphere.w / 2.0 + 0.5;\n        \n        fragColor = \n            #if TEXTURED == 1\n            vec4(calculateLighting(intersect, normal, uv, lights, camera), 1.0);\n            #else\n            vec4(calculateLighting(intersect, normal, uv, lights, camera) * sphereColor, 1.0);\n            #endif\n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSXWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1130, 1130, 1209, 1209, 1642], [1644, 1710, 1806, 1854, 2803]]}
{"id": "fsSXDV", "name": "fire in the brain", "author": "xenn", "description": "yay", "tags": ["particles", "ca"], "likes": 18, "viewed": 616, "published": 3, "date": "1621000263", "time_retrieved": "2024-07-30T19:20:26.773270", "image_code": "// Fork of \"curly flames\" by xenn. https://shadertoy.com/view/tsGcR1\n// 2021-05-14 13:50:26\n\n// Fork of \"electrical storm\" by xenn. https://shadertoy.com/view/tsyyR1\n// 2020-10-08 23:51:09\n\n// Fork of \"strange swimmers\" by xenn. https://shadertoy.com/view/wdGyzh\n// 2020-10-08 22:18:58\n\n// Fork of \"A mild mind violation\" by xenn. https://shadertoy.com/view/3lBBWw\n// 2020-10-08 20:09:29\n\n// Fork of \"total mind fornication\" by xenn. https://shadertoy.com/view/tl2fDD\n// 2020-09-02 01:52:11\n\n// Fork of \"Motilla Tea\" by xenn. https://shadertoy.com/view/tllfzl\n// 2020-09-02 01:05:52\n\n// Fork of \"battle of end times\" by xenn. https://shadertoy.com/view/wlsBzl\n// 2020-08-15 16:25:19\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*10.0+vec3(01.0,1.0,2.0),1.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(10.15), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,0.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(20.*border_h,border_h*0.25,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-03., 30., 3.);\n    vec4 grad = -10.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),1.82)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(-3.4)), 0.), -1.5);\n    float specularb = G(10.24*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(-3.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*0., rho.z),01.1);\n    float b = exp(-0.7*smoothstep(fluid_rho*0.5, fluid_rho*.5, rho.z));\n    vec3 col0 = vec3(0.2, 0.5, 0.17);\n    vec3 col1 = vec3(0.2, 0.2, 0.2);\n    // Output to screen\n    col.xyz += 0.1*a;\n    col.xyz += 0.5 - 0.5*cos(02.5*vec3(0.20*sin(iTime*0.421),0.15*cos(iTime*0.5),0.125*sin(iTime*(0.819)))*rho.w);\n    //col.xyz -= vec3(0,0,0)*bord;\n    col.xyz = tanh(6.*pow(col.xyz,vec3(2.50)));\n    col.w=0001.50;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 20.5\n\n#define fluid_rho 0.020\n\n\n//mold stuff \n#define sense_ang 0.1110+(0.7250*sin(time*0.1))\n//)+(01.0*cos(time*0.2)))\n#define sense_dis 2.0\n#define sense_force 0.5\n#define trailing 0100.10/cos(time*01.0)\n#define acceleration 0.05\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 0.050*rho.x + 0.*rho.y; //gas\n    return 0.02*rho.x*(rho.x/fluid_rho - 01.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 01.333333\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.yx *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -3, 3) range(j, -3, 3)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= .5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= sin(-.0020*P.M.x*vec2(0,1));\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 01.1*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.0)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 10)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(0.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 000.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 000.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(10.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 0.*vec4(P.V, P.M)*G((pos - x0)/01.25); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho*2.0;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSXDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[685, 685, 712, 712, 894], [896, 896, 932, 932, 982], [984, 984, 1000, 1000, 1028], [1030, 1030, 1075, 1075, 2258]]}
{"id": "7d2SDG", "name": "rehiletes 2d-", "author": "jorge2017a1", "description": "rehiletes 2d-", "tags": ["2d", "draw", "polygons", "poly", "rehiletes2d"], "likes": 4, "viewed": 260, "published": 3, "date": "1620960327", "time_retrieved": "2024-07-30T19:20:27.534234", "image_code": "//por jorge2017a1 ----jorgeFloresP---13/may/2021\n//rehiletes 2d-\n// referencia \n////-------------------\n/// IQ funciones....librerias\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\nvec2 RotarPuntoPivote(vec2 p,vec2 pXrYr, float theta)\n{\n     vec2 pp=p;\n     vec2 pos=pXrYr;\n     pp=pp-pos;\n     pp.xy = rotatev2(pp.xy, theta);\n     pp=pp+pos;   \n     return pp;\n}   \n\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 col1=vec3(0.54,0.49,0.39);\nconst vec3 col2=vec3(0.06,0.07,1.0);\nconst vec3 col3=vec3(0.06,0.07,0.8);\nconst vec3 col4=vec3(0.60,0.17,0.17); \nconst vec3 col5=vec3(0.73,0.60,0.55);\nconst vec3 colDorado=vec3(0.925,0.67,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.28,.72),vec2(.71,.72),vec2(.71,.28),vec2(.28,.28),vec2(.28,.72) );\n\n\nfloat sdPoly4 POLY(4)\nvec2 pt4[ 4]=vec2[](  \nvec2(.29,.72),vec2(.07,.50),vec2(.50,.51),vec2(.29,.72) );\n\nfloat sdPoly4b POLY(4)\nvec2 pt4b[ 4]=vec2[](  \nvec2(.50,.93),vec2(.72,.71),vec2(.50,.51),vec2(.50,.93) );\n\nfloat sdPoly4c POLY(4)\nvec2 pt4c[ 4]=vec2[](  \nvec2(.50,.50),vec2(.93,.50),vec2(.71,.28),vec2(.50,.50) );\n\nfloat sdPoly4d POLY(4)\nvec2 pt4d[ 4]=vec2[](  \nvec2(.50,.50),vec2(.50,.07),vec2(.28,.28),vec2(.50,.50) );\n\n\n///------------*******-------------------\nvec3 Rehilete(in vec2 pp, vec3 col) \n{\n    vec2 p=pp;  \n    float sd5 = sdPoly5(p, pt5);\n    float sd4 = sdPoly4(p, pt4);\n    float sd4b = sdPoly4b(p, pt4b);\n    float sd4c = sdPoly4(p, pt4c);\n    float sd4d = sdPoly4(p, pt4d);\n    col=ponerBorde(col1,col,sd5 );\n    col=ponerBorde(col2,col,sd4 );\n    col=ponerBorde(col3,col,sd4b );\n    col=ponerBorde(col4,col,sd4c );\n    col=ponerBorde(col5,col,sd4d );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=5.0*sin(iTime*0.5+cos(iTime*0.5))+sin(iTime+0.5);\n    vec2 p=uv*0.5-vec2(-0.5,-0.5);\n    vec2 p2=uv*0.25-vec2(-0.5,-0.5);\n    vec2 p3=uv*0.125-vec2(-0.5,-0.5);\n    \n    vec3 col=vec3(0.15,0.6,0.3); //vec3(0.25);\n    vec2 pXrYr1=vec2(0.5,0.5);\n    vec2 pr1=RotarPuntoPivote( p, pXrYr1, t);\n    vec2 pr2=RotarPuntoPivote( p, pXrYr1, 10.0+t);\n    vec2 pr3=RotarPuntoPivote( p, pXrYr1, 20.0+t);\n    col=Rehilete(pr3, col);\n    col=Rehilete(pr2, col);\n    col=Rehilete(pr1, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2SDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 281, 317, 317, 362], [368, 368, 403, 403, 427], [429, 429, 489, 489, 613], [615, 615, 649, 649, 746], [747, 747, 802, 802, 929], [935, 935, 966, 966, 987], [2107, 2149, 2187, 2187, 2572], [2574, 2574, 2631, 2631, 3248]]}
{"id": "NsSXWG", "name": "vec.xy * mat2", "author": "DEKTEN", "description": "Testing understanding of matrix multiplication. I write my shader code in a style that can compile to GLSL _AND_ C99 so I can unit test my code. Sometimes requires that I create CPU-side C99 polyfills of GLSL functionality. www.twitch.com/kanjicoder", "tags": ["test"], "likes": 0, "viewed": 592, "published": 3, "date": "1620950889", "time_retrieved": "2024-07-30T19:20:28.295200", "image_code": "    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        /**@VID_IID[0300]TIME[03:23:23]DONE_WRITING_CODE**/\n        /**TWITCH[ www.twitch.com/kanjicoder ]************/\n\n        vec2 uv = fragCoord/iResolution.xy;\n\n        vec3 rd;\n             rd.x=( 1.0 );\n             rd.y=( 2.0 );\n             rd.z=( 3.0 );\n\n        //:--------------------------------------------------://\n        //:  VECTORS AND SUB VECTORS ARE \"ROW VECTORS\"       ://\n        //:  rd.xy is __NOT__ a column vector:               ://\n        //:  (2X1)  *  (2X2) == NOT POSSIBLE!                ://\n        //:     |       |                                    ://\n        //:     +---+---+                                    ://\n        //:         |                                        ://\n        //:      NOT_MATCH!                                  ://\n        //:                                                  ://\n        //:  rd.xy  *  mat2(10,20,30,40)                     ://\n        //:  +- -+     +-     -+                             ://\n        //:  |1.0|     |10 , 30|                             ://\n        //:  |   |  *  |       | == INVALID_OPERATION        ://\n        //:  |2.0|     |20 , 40|                             ://\n        //:  +- -+     +-     -+                             ://\n        //:--------------------------------------------------://\n        //:  rd.xy is __IS__  a row vector:                  ://\n        //:  (1X2)  *  (2X2) == __IS__ possible              ://\n        //:     |       |                                    ://\n        //:     +---+---+                                    ://\n        //:         |                                        ://\n        //:      YES_MATCH!                                  ://\n        //:--------------------------------------------------://\n        //:                                                  ://\n        //:                  +---+---+                       ://\n        //:                  |10 |30 |                       ://\n        //:                  +---+---+ <--[ mat2(10,20,30,40) ]\n        //:                  |20 |40 |                       ://\n        //:                  +---+---+                       ://\n        //:        +---+---+ +---+---+                       ://\n        //: rd.xy==|1.0|2.0| | x | y |                       ://\n        //:        +---+---+ +---+---+                       ://\n        //:                                                  ://\n        //:        x =( (1.0*10)+(2.0*20) ) ===>  50         ://\n        //:        y =( (1.0*30)+(2.0*40) ) ===> 110         ://\n        //:--------------------------------------------------://\n\n        rd.xy = rd.xy*mat2(10,20,30,40);\n     \n        if( rd.x == 50.0 && rd.y == 110.0 ){  \n            //:GREEN SCREEN: KNOW WHAT YOU ARE TALKING ABOUT:\n            fragColor = vec4(0,1,0,1.0); \n        }else{\n            //:BLACK SCREEN: WE ARE BEING IDIOTS:\n            fragColor = vec4(0,0,0,1.0);\n        };;\n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 65, 185, 2992]]}
{"id": "7d2SWG", "name": "Rito's Julia Fractal", "author": "ritobanrc", "description": "This is a Julia Fractal\n", "tags": ["fractal"], "likes": 2, "viewed": 209, "published": 3, "date": "1620949831", "time_retrieved": "2024-07-30T19:20:29.047189", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 z = fragCoord/iResolution.xy;\n    z *= 2.;\n    z -= 1.;\n    vec2 c = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    bool val = false;\n\n    // Time varying pixel color\n    int i = 0;\n    for (;i < 10000; i++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.*z.x*z.y) + c;\n        if (length(z) > 100.) {\n            val = true;\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = val ? vec4(i / 8, 1., 1.,1.0) : vec4(0., 0., 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2SWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 568]]}
{"id": "ssjXWG", "name": "Random Joke", "author": "oneshade", "description": "High quality pseudorandom hash based on [url=https://xkcd.com/221/]https://xkcd.com/221/[/url].", "tags": ["random", "joke"], "likes": 17, "viewed": 240, "published": 3, "date": "1620947302", "time_retrieved": "2024-07-30T19:20:29.796187", "image_code": "float getRandomNumber(in vec2 x) {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             vec2 n = x * fract(dot(x, vec2(534.75, 65.54))); return fract(dot(x + n, n));\n    return 5.0; // Chosen by fair dice roll.\n                // Guaranteed to be random.\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(getRandomNumber(floor(fragCoord / iResolution.xy * 100.0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjXWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 5207], [5209, 5209, 5264, 5264, 5348]]}
{"id": "fd2XDy", "name": "Basic 2D lighting", "author": "Salmon_e", "description": "Basic 2D lighting shader, definitely could use some more clean up and optimization but I'm still happy with it.\nUnfortunately it needs a way to upload custom textures or else it won't do anything.", "tags": ["2d", "lighting"], "likes": 3, "viewed": 557, "published": 3, "date": "1620940493", "time_retrieved": "2024-07-30T19:20:30.561141", "image_code": "// NOTE: This won't work with out a custom texture in channel 0, so use chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda?hl=en\n// or the js console to upload a custom texture. \n// White is treated as air, and all other colors are treated as solid ground\n\n\n// Converts from pixel space into texture coord space\nvec2 convert(vec2 p){\n    return vec2(p.x/iResolution.x, p.y/iResolution.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 lightPos = iMouse.xy;\n    \n    // How deep the light penetrates into solid ground\n    float lightPenetration = 50.0;\n    \n    // Size of the step for the ray. Higher is lower quality, but faster\n    float lightQuality = 3.0;\n    \n    // direction vector of the ray\n    vec2 dir = lightPos - fragCoord;    \n    float dist = distance(lightPos, fragCoord);\n    \n    // The number of solid pixels encountered by the ray\n    float solidCount = 0.0;\n    \n    vec4 color = texture(iChannel0, convert(fragCoord));\n    for(float i = 0.0; i <= 1.0; i += lightQuality/dist){\n        // Get the next point on the line\n        vec2 p = i*dir + fragCoord;\n        \n        // Stop calculating things in the pixel is off screen\n        if(p.x < 0.0 || p.y < 0.0 || p.x > iResolution.x || p.y > iResolution.y){\n            continue;\n        }\n        // Check if the color at the current point is solid, if so, increase the counter\n        if(texture(iChannel0, convert(p)).rgb != vec3(1,1,1)){\n            solidCount++;\n            // break if the the solidCount gets high enough to block all light, no need to increase it further\n            if(solidCount > lightPenetration * lightQuality){\n                break;\n            }\n        }\n    }\n    // This was created with my go to strategy of \"slap numbers together until it looks ok\"\n    float light = 1.0-solidCount/lightPenetration*lightQuality;\n    // Add some ambient light to empty space\n    if(color.rgb == vec3(1,1,1)){    \n        light = clamp(light, 0.3, 1.0);\n    }\n    \n    fragColor = color*light;\n    \n}", "image_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 353, 374, 374, 431], [433, 433, 490, 490, 2056]]}
{"id": "fdjSDy", "name": "Fork  fractal  NikolaErce 522", "author": "NikolaErceg", "description": "Creating multiple shapes with one SDF evaluation by repeatedly rotating and folding space", "tags": ["fractalcineshader"], "likes": 17, "viewed": 7249, "published": 3, "date": "1620936564", "time_retrieved": "2024-07-30T19:20:31.314128", "image_code": "vec3 palette(float d){\n\treturn mix(vec3(0.0,3.02,1.24),vec3(1.,0.01,1.2),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<66; ++i){\n        float t = iTime*0.006;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*1.0);\n        p.xz = abs(p.xz);\n        p.xz-=.16;\n\t}\n\treturn dot(sign(p),p)/6.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 1.;\n    vec3 col = vec3(0.006);\n    float d;\n    for(float i =0.; i<36.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*.98;\n        if(d<0.07){\n            break;\n        }\n        if(d>22.){\n        \tbreak;\n        }\n        //col+=vec3(3.6,3.8,3.8)/(400.*(d));\n        col+=palette(length(p)*.1)/(222.*(d));\n        t+=d;\n    }\n    return vec4(col,1./(d*20.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(55.,55.,-13.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(7,3.,17.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjSDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 78], [80, 80, 108, 108, 180], [182, 182, 200, 200, 404], [406, 406, 433, 433, 813], [814, 814, 871, 871, 1268]]}
{"id": "sss3Wj", "name": "Cyberpunk city", "author": "z0rg", "description": "A fun project designing a 5th element / cyberpunk ish city. I really enjoyed doing it, I went through a lot of non working things, doubts... but the final thing is really cool, I learned the lot in the process, and I hope you'll like it !", "tags": ["city", "cyberpunk", "2077", "5thelement"], "likes": 99, "viewed": 8687, "published": 3, "date": "1620927942", "time_retrieved": "2024-07-30T19:20:32.097035", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvec3 doBloom(vec2 uv, float blur, float threshold)\n{\n    vec3 col;\n    int cnt = 50;\n    float fcnt = float(cnt);\n    for (int i = 0;i <cnt;++i)\n    {\n        float fi = float(i);\n        float coef = (fi/fcnt);\n        float sz = 1.+pow(coef,2.)*blur;\n        float samplePerTurn = 5.;\n        float an = (fi/(fcnt/samplePerTurn))*PI;\n        vec2 p = uv - vec2(sin(an), cos(an))*an*blur*.1;\n        vec3 smple = texture(iChannel0, p).xyz;\n        if (length(smple) > threshold)\n            col += smple;\n    \t\n        \n    }\n    \n    return col/float(cnt);\n}\n\nvec3 chromaFlare(vec2 uv, vec2 ouv, float sz, float id)\n{\n    vec3 col = vec3(0.);// = texture(iChannel0, uv).xyz;\n    \n    float c = abs(length(ouv)-.3-id*sz*8.-sz*9.)-sz;\n    vec3 rgb;\n    float a = atan(ouv.y, ouv.x)*1.;\n    float cnt = 16.;\n    for (float i = 0.; i < cnt; ++i)\n    {\n           \n        rgb += vec3(1.)*\n        (sat((sin(a*400.)+sin(a*200.)+sin(a*100.))*.2+.5)*.5+.5)*\n        texture(iChannel0, vec2(.5)+((uv-vec2(.5))*(i+1.)*0.01*r2d((i-cnt/2.)*.025)*-1.*sat(length(ouv*2.)))).x;\n    }\n    col += pow((1.-sat(c*5.))*pow(rgb/cnt, vec3(1.)), vec3(1.));\n    \n    return col*.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    float bloomIntensity = 424./640.;  \n    vec3 bloomSample = doBloom(uv, 40./360., 237./ 640.);\n    bloomSample = pow(bloomSample, vec3(0.5));\n    \n    col = col + (bloomSample*bloomIntensity);\n    \n\n    col += chromaFlare(uv, cuv, 0.01, 0.)*vec3(1.,0.,0.);\n    col += chromaFlare(uv, cuv, 0.01, -1.)*vec3(0.,1.,0.);\n    col += chromaFlare(uv, cuv, 0.01, -2.)*vec3(0.,0.,1.);\n\n    col = mix(col, col.zyx, pow(sat(length(cuv*2.)),4.));\n\n    col = pow(col, vec3(1.95));\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define UPSIDEDOWN // Comment to see not only the dow side\n\n#define FFT(f) (texture(iChannel1, vec2(f, 0.)).x)\n\n\nfloat _speed = 20.;\nfloat _time;\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y, l.z));\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 _max(vec2 a, vec2 b)\n{\n    if (a.x > b.x)\n        return a;\n    return b;\n}\n\nfloat _cars(vec3 op, vec3 s)\n{\n    op.z+=_time*20.;\n    float carStp = 10.5;\n    vec3 pcar = op;\n    float idxCar = floor((pcar.z+.5*carStp)/carStp);\n    pcar.z = mod(pcar.z+.5*carStp, carStp)-.5*carStp;\n    pcar.x += sin(idxCar);\n#ifndef UPSIDEDOWN\n    pcar.y += 90.;\n#endif\n    pcar.y += sin(idxCar*5.+_time);\n    return _cube(pcar, s*(sin(idxCar)*.5+.5));\n}\n\nvec2 map(vec3 p)\n{\n\n    p.z += _time*_speed;\n    vec3 op = p;\n    \n#ifdef UPSIDEDOWN\n    p.y = abs(p.y)-100.;\n#endif\n    vec2 acc = vec2(100., -1.);\n    vec2 ground = vec2(_cube(p, vec3(50., .1, 50.)), 0.);\n    vec3 pBat = p;\n    vec2 repBat = vec2(10.);\n    vec2 idxBat = floor((pBat.xz+repBat*.5)/ repBat); \n    pBat.xz = mod(pBat.xz+repBat*.5, repBat)-repBat*.5;\n    float height = mix(1., 8., (sin(idxBat.x+idxBat.y*10.)*.5+.5));\n    height += (texture(iChannel0, idxBat*.1).x-.5)*5.;\n    float width = texture(iChannel0, idxBat/10.).x*.75;\n    pBat.xz += sin(idxBat*10.)*.5;\n    vec2 bat = vec2(_cube(pBat, vec3(5.5*width,height*8.,3.7)), 0.);\n    \n    acc = _min(acc, ground);\n    acc = _min(acc, bat);\n    acc = _min(acc, vec2(_cars(op-vec3(0.,10.,0.), vec3(.5,.5,1.5)), 1.));\n    acc = _min(acc, vec2(_cars(op-vec3(50.,10.,0.), vec3(.5,.5,1.5)), 1.));\n    \n    float repz = 50.;\n    float idxz = op.z / repz;\n    op.z = mod(op.z+.5*repz, repz)-repz*.5;\n    op.xz *= r2d(1.57);\n    op.y += sin(idxz)*25.;\n    acc = _min(acc, vec2(_cars(op, vec3(.5,.5,2.5)), 1.));\n    return acc;\n}\n\nvec3 trace(vec3 ro, vec3 rd, float dist, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps && ((dist > 0.0 && distance(ro, p) < dist) || dist < 0.0); ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n        {\n            return vec3(res.x, distance(ro, p), res.y);\n        }\n        // We allow march step to be false if far enough from origin\n        p += rd * min(res.x,.5+(distance(ro, p)/120.));\n    }\n    return vec3(-1.);\n}\n\nfloat traceShadow(vec3 ro, vec3 rd, float dist, int steps)\n{\n    float rad = 1.5;\n    vec3 p = ro;\n    float acc = 1.;//rad;//rad*50.;\n    for (int i = 0; i < steps && distance(p, ro) < dist; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n        {\n            return 0.;\n        }\n        float d =min(res.x,1.5);\n        acc = min(acc, 30.*d/distance(p, ro));\n        p += rd * d;\n         // check this https://www.shadertoy.com/view/3tVBRV\n        //acc += sat(d/rad*dist*.005);\n    }\n    return acc;\n}\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    float fov = 4.;\n    return normalize(rd+(uv.x*r+uv.y*u)*fov);\n}\n\nvec3 getNormal(float d, vec3 p)\n{\n    vec2 e = vec2(0.04, 0.);\n    //return -normalize(cross(dFdx(p), dFdy(p)));\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\n\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n#ifdef UPSIDEDOWN\n    vec3 ro = vec3(sin(_time*.3)*15.,15.+sin(_time*.15)*15.,-75.)*.75;\n    vec3 ta = vec3(0.,-10.,0.)*.5;\n#else\n    vec3 ro = vec3(sin(_time*.3)*15.,-105.+sin(_time*.15)*15.,-75.)*.75;\n    vec3 ta = vec3(0.,-110.,0.)*.5;\n#endif\n\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    \n    vec3 res = trace(ro, rd, -1., 256);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNormal(res.x, p);\n        \n        \n        col = n*.5+.5;\n        float rad = 50.;\n        float tsun = iMouse.x/100.;//_time*.25;\n        float lDist = 550.;\n        //vec3 lpos = vec3(cos(tsun)*lDist, lDist,sin(tsun)*lDist);\n        vec3 shadowO = p+n*0.01;\n        vec3 ldir = vec3(1.,-2.,5.)*lDist;//lpos-shadowO;\n        vec3 lCol = vec3(1.,0.,0.);\n        \n        \n        float shadowRes = traceShadow(shadowO, normalize(ldir), lDist, int(650.*(1.-sat((length(p.xz)-150.)*.01))));\n        vec3 ambientCol = vec3(0.569,0.675,0.714);\n        vec3 diffuseCol = vec3(0.678,0.878,0.902);\n        col = ambientCol; // Ambient col\n        \n        col *= sat(pow(sat(shadowRes),.5)+.15);\n        if (shadowRes > 0.01)\n        {\n            \n            vec3 h = normalize(ldir+rd);\n            // diffuse\n            col += 500.*sat(dot(n, normalize(ldir)))*diffuseCol/lDist;\n            float specPower = mix(1.,.01, sat(sin(p.y*2.)*50.));\n            // spec\n            col += (.025/specPower)*100.*vec3(1.000,0.584,0.000)*pow(sat(abs(dot(n, h))),specPower)/lDist;\n        }\n\n        col += mix(vec3(0.), mix(vec3(1.000,0.000,0.400), vec3(1.), sat(abs(length(p.xz)*.0025))), 1.-sat(exp(-distance(p, ro)/500.)));\n        p.z += _time*_speed;\n\n\n       col += float(dot(n, vec3(0.,-1.,0.)) < 0.1)*vec3(0.851,0.690,0.506)*pow(texture(iChannel2, p*.02).x,20.)*2.;\n       col += .3*vec3(0.729,0.565,0.212)*(sat(p.y*.1+5.))*pow(texture(iChannel2, vec3(1.,4.,1.)*p*.02+vec3(.5*_time*sign(sin(p.z*5.)), 0., 0.)).x,20.);\n\n    }\n    else\n        col = sat(mix(mix(vec3(.75), vec3(1.000,0.000,0.400)*.75, .1),texture(iChannel3, vec2(-rd.x, rd.y)*vec2(2.,-8.)-vec2(0.,.7)).xyz,(sat((rd.y-.175)*40.))*.5*sat(length(uv*2.))));//*sat(-rd.y*2.+1.);\n\n    col += (1.-sat(lenny(rd.xy*vec2(1.,4.)*.5)))*vec3(1.000,0.000,0.400)*.5*float(res.y<0.);\n    col += 3.*pow(1.-sat(lenny(rd.xy*.15*vec2(1.,8.))),5.)*vec3(1.000,0.000,0.400)*.5;//*float(res.y<0.);\n    col *= mix(.75,1.5,pow(sat(FFT(0.5)),2.));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // This helps a bit decreasing aliasing by doing a no sampling motion blur\n    _time =  iTime + texture(iChannel0, fragCoord/8.).x*.25;\n\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n    vec3 col = rdr(uv);\n\n    \n    col = pow(col, vec3(.85));\n    col *= (1.-sat(lenny(uv*2.)-.5));\n    \n    col = mix(col, texture(iChannel3, fragCoord/iResolution.xy).xyz, sat(.9)*sat(length(uv*2.)));\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26933, "src": "https://soundcloud.com/aasish-rajendran/tron-legacy-soundtrack-12-end-of-line-daft-punk", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n\nfloat lenny(vec2 v) { return abs(v.x)+abs(v.y); }", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sss3Wj.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 449, 449, 957], [959, 959, 1016, 1016, 1559], [1561, 1561, 1618, 1618, 2282]]}
{"id": "7ssSWr", "name": "Electric pillars", "author": "z0rg", "description": "A mash-up of two album covers I like", "tags": ["3d", "electricpillars"], "likes": 4, "viewed": 289, "published": 3, "date": "1620925213", "time_retrieved": "2024-07-30T19:20:32.852016", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n#define PI 3.141592653\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat _sph(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat _cyl(vec3 p, vec2 s)\n{\n    return max(length(p.xz)-s.x, abs(p.y)-s.y);\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n    vec3 l = abs(p)-s;\n    return max(l.x, max(l.y,l.z));\n}\n\nfloat map(vec3 p)\n{\n    float rad = .1;\n    vec3 ppi = p;\n    ppi.x = abs(ppi.x);\n    float pillars = _cyl(ppi-vec3(.9,0.75,0.), vec2(rad,3.));\n    \n    vec3 pb = p-vec3(0.,-1.75,0.);\n    pb.x = abs(pb.x);\n    pb.xy*= r2d(PI/2.);\n    float branches = 10.;\n    for (float i = 0.; i < 3.; ++i)\n    {\n        vec3 pbb = pb+vec3(i*.7,0.,0.);\n        pbb.z = abs(pbb.z);\n        float branche = _cyl(pbb, vec2(rad, 1.75));\n        \n        pbb.yz*= r2d(PI/2.);\n        branche = min(branche, _cyl(pbb-vec3(-0.1,-0.5,1.75), vec2(.1)));\n        //branche = max(branche, );\n        vec3 pc = pbb-vec3(-2.,-20.,1.75);\n        pc.xy *= r2d(.1);\n        branche = min(branche, _cyl(pc, vec2(0.025,20.)));\n        branches = min(branches, branche);\n\n    }\n    \n    return min(min(pillars, branches), _cube(p-vec3(0.,5.,50.), vec3(5.)));\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    float fov = 2.;\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+fov*(r*uv.x+u*uv.y));\n}\n\nvec3 _normal(float d, vec3 p)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-vec3(map(p+e.xyy), map(p+e.yxy), map(p+e.yyx)));\n}\n\nvec2 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        float d = map(p);\n        if (d < 0.001)\n            return vec2(d, distance(p, ro));\n        p += rd*d;\n    }\n    return vec2(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    float a = sin(iTime*.5)*.75;\n    vec3 ro = vec3(-5.*sin(a),3.,-5.*cos(a));\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    \n    rd = getCam(rd, uv);\n    \n    float sep = -(uv.x-uv.y)+.25;\n    \n    vec3 yellow = mix(vec3(.1), vec3(1.000,0.804,0.102), 1.-sat(sep*400.));\n    vec3 black = mix( vec3(1.),vec3(.1), 1.-sat(sep*400.));\n    \n    \n    col = mix(.5, 1., texture(iChannel0, rd*vec3(1.,-1.,1.)).x)*yellow;\n    \n    vec2 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = _normal(res.x,p); \n        col = n*.5+.5;\n        \n        col = black+vec3(1.000,0.349,0.000)*sat(dot(n, vec3(-1.)))*-sign(sep);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col = rdr(uv);\n    if (true)// Not so cheap antialiasing\n    {\n        vec2 off = vec2(1., -1.)/(iResolution.x*2.);\n        off *= r2d(.8); // This seems to have better results than axis aligned grid\n        vec3 acc = col;\n        acc += rdr(uv+off.xx);\n        acc += rdr(uv+off.xy);\n        acc += rdr(uv+off.yy);\n        acc += rdr(uv+off.yx);\n        col = acc/5.;\n        \n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ssSWr.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[453, 453, 472, 472, 530], [532, 532, 561, 561, 587], [589, 589, 617, 617, 667], [669, 669, 698, 698, 758], [760, 760, 779, 779, 1586], [1588, 1588, 1619, 1619, 1776], [1778, 1778, 1809, 1809, 1917], [1919, 1919, 1960, 1960, 2162], [2164, 2164, 2183, 2183, 2897], [2899, 2899, 2956, 2956, 3451]]}
{"id": "fsjXWG", "name": "Chateaux... v2", "author": "dr2", "description": "Chenonceau, with updated visuals", "tags": ["forest", "architecture", "scenery"], "likes": 20, "viewed": 384, "published": 3, "date": "1620922231", "time_retrieved": "2024-07-30T19:20:33.795494", "image_code": "// \"Chateaux... v2\"  by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Chenonceau, with updated visuals and without the book format.\n  Seasons change.\n  Mouse down in subwindows for day or night views, traveling or rotating viewer.\n*/\n\n#define AA  0  // = 0/1 - optional antialiasing (slow)\n\n#define LOOP_REFL 0    // = 0/1 - faster compile & slower execute (for some) ??\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrConeDf (vec3 p, vec3 b);\nfloat SmootherStep (float a, float b, float x);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec4 snowCol;\nvec3 qHit, sunDir, trkA, trkF, bldSize;\nvec2 gId, trOff, trkA2, trkF2;\nfloat dstFar, tCur, hgSize, trSzFac, trSym, grHt, trRot, snowFac, zRep, bldSzFac;\nint idObj, vuMode;\nbool isSh, isNt, isFlsh;\nconst int idBrdg = 1, idWal = 2, idBatt = 3, idTwr = 4, idFlr = 5, idWin = 6, idRf = 7,\n   idRmp = 8, idPil = 9, idRod = 10, idFlag = 11, idTrnk = 21, idLv = 22, idRk = 23;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec2 TrackPathS (float t)\n{\n  return vec2 (dot (trkA, cos (2. * pi * trkF * t)), t);\n}\n\nvec2 TrackPath (float t)\n{\n  return TrackPathS (t) + vec2 (dot (trkA2, cos (2. * pi * trkF2 * t)), 0.);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float h, w;\n  h = 0.5 + 0.17 * (sin (dot (p, vec2 (1., 1.4))) + sin (dot (p, vec2 (-1.2, 0.8)))) *\n     smoothstep (1., 2., abs (mod (p.y + zRep, 2. * zRep) - zRep));\n  w = abs (p.x - TrackPath (p.y).x) * (1.1 + 0.3 * sin (0.5 * p.y));\n  h = h * SmootherStep (4.35, 5., w) - 0.05 * (1. - w * w / (4.3 * 4.3)) * step (w, 4.3);\n  return h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.05, 0.5 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat ObjGdf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, ht;\n  dMin = dstFar;\n  p.xz -= HexToPix (gId) * hgSize + trOff;\n  if (trSzFac > 0.) {\n    dMin /= trSzFac;\n    p.xz = Rot2D (p.xz, trRot);\n    p.y -= grHt - 0.1;\n    p /= trSzFac;\n    ht = 2.2;\n    q = p;\n    q.y -= ht;\n    d = PrCylDf (q.xzy, 0.12 - 0.03 * q.y / ht, ht);\n    qq = p;\n    qq.xz = Rot2D (qq.xz, 2. * pi * (floor (trSym * atan (qq.z, - qq.x) / (2. * pi) +\n       0.5) / trSym));\n    q = qq;\n    q.xy = Rot2D (q.xy - vec2 (-0.2, 0.3), -0.3 * pi);\n    d = SmoothMin (d, PrCylDf (q.yzx, 0.09 + 0.02 * q.x / 0.6, 0.6), 0.2);\n    q = qq;\n    q.xy = Rot2D (q.xy - vec2 (-0.2, 1.2 * ht), 0.3 * pi);\n    d = SmoothMin (d, PrCylDf (q.yzx, 0.05 + 0.02 * q.x / 0.5, 0.5), 0.1);\n    DMIN (idTrnk);\n    q = p;\n    q.y -= 2. * ht;\n    d = SmoothMin (min (PrSphDf (q + vec3 (0, -1., 0.), 0.6),\n       PrSphDf (vec3 (qq.x + 0.4, q.y + 1., qq.z), 0.6)), PrSphDf (q, 1.), 0.5);\n    DMIN (idLv);\n    dMin *= trSzFac;\n  } else  if (trSzFac < 0.) {\n    q = p;\n    d = PrSphDf (q, - trSzFac * 0.3);\n    DMIN (idRk);\n  }\n  return dMin;\n}\n\nvoid SetTrParms ()\n{\n  vec2 g, w, v;\n  float s;\n  w = Hashv2v2 (17. * gId);\n  trSzFac = 0.3 + 0.4 * w.x;\n  trSym = floor (3. + 2.9 * w.y);\n  w = Hashv2v2 (33. * gId);\n  g = HexToPix (gId) * hgSize;\n  s = abs (g.x - TrackPath (g.y).x);\n  if (length (vec2 (max (s, 10.), mod (g.y + zRep, 2. * zRep) - zRep)) < 10.5) {\n    trSzFac = 0.;\n  } else {\n    v = w.x * sin (2. * pi * w.y + vec2 (0.5 * pi, 0.));\n    if (s < 1.5) {\n      trOff = hgSize * 0.5 * sqrt3 * v;\n      trSzFac *= -1.;\n    } else if (s < 6.5) {\n      trSzFac = 0.;\n    } else {\n      trOff = max (0., hgSize * 0.5 * sqrt3 - trSzFac) * v;\n      trRot = 0.6 * pi * (Hashfv2 (23. * gId + 99.) - 0.5);\n      grHt = GrndHt (g + trOff);\n    }\n  }\n}\n\nfloat ObjGRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrParms ();\n    }\n    d = ObjGdf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjGNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjGdf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjGSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrParms ();\n    }\n    h = ObjGdf (p);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += clamp (h, 0.05, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat BldDf (vec3 p)\n{\n  vec3 q;\n  vec2 vb, vc;\n  float dMin, d, dw;\n  dMin = dstFar / bldSzFac;\n  p /= bldSzFac;\n  q = p;\n  q.y -= 2. + bldSize.y;\n  if (! isSh) d = PrBoxDf (q, bldSize + vec3 (6., 2., 1.));\n  if (isSh || d < 0.1) {\n    q = p;\n    q.x = abs (q.x) - bldSize.x - 3.;\n    q.y -= 1.6;\n    q.y = dot (q.yx, sin (0.06 * pi + vec2 (0.5 * pi, 0.)));\n    d = max (abs (q.x) - 2.65, max (PrBox2Df (q.yz, vec2 (0.3, 0.7)),\n       - PrBox2Df (q.yz - vec2 (0.2, 0.), vec2 (0.3, 0.6))));\n    DMINQ (idRmp);\n    q = p;\n    q.x = abs (q.x) - bldSize.x - 3.;\n    q.y -= 2.15 - step (0., q.x);\n    d = PrCapsDf (vec3 (abs (q.xz) - vec2 (2.7, 0.65), q.y), 0.08, 0.3);\n    DMINQ (idPil);\n    q = p;\n    d = max (PrBox2Df (q.xz, bldSize.xz + vec2 (0.4, 0.3)),\n       - PrCaps2Df (vec2 (mod (q.x, 2.) - 1., q.y), 0.6, 1.));\n    d = SmoothMax (min (d, max (PrCaps2Df (vec2 (mod (q.x + 1., 2.) - 1., q.z), 0.4, bldSize.z + 0.3),\n       abs (q.x) - 5.)), q.y - 2., 0.05);\n    DMINQ (idBrdg);\n    q = p;\n    vb = mod (q.xz + 0.5, 1.) - 0.5;\n    vc = abs (q.xz) - bldSize.xz + 0.15;\n    q.y -= 2. + bldSize.y;\n    d = max (max (abs (PrBox2Df (q.xz, bldSize.xz - 0.07)) - 0.07, abs (q.y) - bldSize.y),\n       - min (max (PrBox2Df (vec2 (vb.x, abs (q.y) - 0.7), vec2 (0.2, 0.45)), vc.x),\n       max (PrBox2Df (vec2 (vb.y, abs (q.y) - 0.7), vec2 (0.2, 0.45)), vc.y)));\n    dw = PrBox2Df (vec2 (q.y + 0.85, q.z), vec2 (0.6, 0.35));\n    d = max (d, - dw);\n    DMINQ (idWal);\n    q = p;\n    q.y -= 2. * bldSize.y + 2.15;\n    d = max (max (PrBoxDf (q, vec3 (bldSize.xz, 0.15).xzy), - PrBox2Df (q.xz, bldSize.xz - 0.1)),\n       -0.125 + Maxv2 (abs (mod (q.xz + 0.25, 0.5) - 0.25)));\n    DMINQ (idBatt);\n    q = p;\n    q.y -= 2.;\n    d = abs (q.y - bldSize.y) - bldSize.y;\n    q.y = mod (q.y + 0.5 * (bldSize.y - 0.05), (bldSize.y - 0.05)) - 0.5 * (bldSize.y - 0.05);\n    d = max (PrBoxDf (q, vec3 (bldSize.xz - 0.07, 0.03).xzy), d);\n    DMINQ (idFlr);\n    q = p;\n    q.xz = abs (q.xz);\n    q -= vec3 (bldSize.xz - 0.05, 2. + bldSize.y).xzy;\n    d = min (PrCylDf (vec3 (p.x, abs (q.y - 0.1) - 0.7, q.z).yzx, 0.025, bldSize.x),\n       max (PrCylDf (vec3 (vb.x, q.yz).xzy, 0.025, bldSize.y), vc.x));\n    DMINQ (idWin);\n    d = min (max (PrCylDf (vec3 (q.x, abs (q.y - 0.1) - 0.7, p.z), 0.025, bldSize.z), - dw),\n       max (PrCylDf (vec3 (q.xy, vb.y).xzy, 0.025, bldSize.y), vc.y));\n    DMINQ (idWin);\n    q = p;\n    q.y -= 2. * bldSize.y + 3.15;\n    d = max (max (dot (vec2 (abs (q.x) - 2.3, q.y), sin (0.3 * pi + vec2 (0.5 * pi, 0.))),\n       dot (vec2 (abs (q.z) - 0.3, q.y), sin (0.3 * pi + vec2 (0.5 * pi, 0.)))), - q.y - 1.2);\n    DMINQ (idRf);\n    q = vec3 (vc - 0.15, p.y - (2.2 + bldSize.y)).xzy;\n    d = PrCylDf (q.xzy, 0.3, bldSize.y + 0.2);\n    DMINQ (idTwr);\n    q.y -= 1.4 + bldSize.y;\n    d = PrConeDf (q.xzy, vec3 (sin (0.07 * pi + vec2 (0.5 * pi, 0.)), 1.2));\n    DMINQ (idRf);\n    q.y -= 0.15;\n    d = PrCylDf (q.xzy, 0.03, 0.3);\n    DMINQ (idRod);\n    q.xy -= vec2 (0.2 * sign (p.x), 0.15);\n    d = PrBoxDf (q, vec3 (0.2, 0.1, 0.005));\n    DMINQ (idFlag);\n  } else dMin = d;\n  return bldSzFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  return BldDf (vec3 (p.x - TrackPath (0.).x, p.y, mod (p.z + zRep, 2. * zRep) - zRep));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  p = vec3 (p.x - TrackPath (0.).x, p.y, mod (p.z + zRep, 2. * zRep) - zRep);\n  p /= bldSzFac;\n  p.y -= 2. + bldSize.y;\n  return bldSzFac * PrBoxDf (p, bldSize - 0.07);\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.05, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 BldCol (float zColr, vec3 vn, out vec2 vf)\n{\n  vec4 col4, bldCol, hzCol;\n  vec2 u;\n  float sy;\n  bldCol = vec4 (HsvToRgb (vec3 (0.05 + 0.06 * zColr / 3., 0.7, 1.)), 0.1);\n  hzCol = mix (bldCol, vec4 (0.4, 0.4, 0.4, 0.1), 0.8);\n  sy = 0.9 + 0.1 * SmoothBump (0.1, 0.9, 0.02, mod (10. * qHit.y + 0.5, 1.));\n  if (idObj == idWal) {\n    col4 = bldCol;\n    if (abs (mod (qHit.y + 0.5 * (bldSize.y - 0.05), (bldSize.y - 0.05)) -\n       0.5 * (bldSize.y - 0.05)) < 0.03) col4 *= 0.8;\n    u.xy = abs (mod (qHit.xz + 0.5, 1.) - 0.5) - 0.25;\n    if (abs (qHit.y + 0.85) < 0.68 && abs (qHit.z) < 0.42) col4 *= 1.1;\n    else if (abs (abs (qHit.y) - 0.7) < 0.5 && (u.x < 0. && abs (qHit.z) > bldSize.z - 0.2 ||\n       u.y < 0. && abs (qHit.x) > bldSize.x - 0.2)) col4 *= 0.8;\n    else if (Maxv2 (abs (qHit.xz) - bldSize.xz) > - 0.01) col4 *= sy;\n  } else if (idObj == idBrdg) {\n    if (vn.y < 0.99) {\n      col4 = 0.7 * bldCol;\n      if (qHit.y < 0.4) col4 *= 0.8 * sy;\n      if (qHit.y < 1.6 && abs (qHit.z) < bldSize.z) col4 *= (0.8 +\n         0.2 * SmoothBump (0.08, 0.92, 0.02, mod (4. * qHit.z, 1.)));\n    } else col4 = hzCol;\n  } else if (idObj == idBatt || idObj == idTwr || idObj == idPil) col4 = bldCol * sy;\n  else if (idObj == idRf) col4 = vec4 (0.55, 0.6, 0.55, 0.1) * sy;\n  else if (idObj == idRmp) col4 = (abs (vn.z) > 0.99) ? bldCol * sy : hzCol;\n  else if (idObj == idFlr) col4 = 0.7 * bldCol;\n  else if (idObj == idWin) col4 = vec4 (0.4, 0.4, 0.3, 0.1);\n  else if (idObj == idRod) col4 = vec4 (0.9, 0.9, 0.9, 0.1);\n  else if (idObj == idFlag) col4 = vec4 (mix (HsvToRgb (vec3 (zColr / 4., 1., 1.)), \n     vec3 (1.2), step (qHit.y, 0.)), 0.1);\n  if (idObj == idRod || idObj == idFlag) vf = vec2 (0.);\n  else if (idObj == idBrdg && vn.y < 0.99) vf = vec2 (32., 0.5);\n  else vf = vec2 (32., 0.2);\n  if (! (idObj == idWal && qHit.y < bldSize.y - 0.01 || idObj == idFlr)) {\n    col4 = mix (col4, snowCol, snowFac * smoothstep (0.3, 0.8, vn.y));\n    if (snowFac > 0.5) vf = vec2 (32., 2. * smoothstep (0.5, 0.7, snowFac)) *\n       smoothstep (0.3, 0.8, vn.y);\n  }\n  return col4;\n}\n\nvec4 TreeRkCol (vec3 p, vec3 vn, out vec2 vf)\n{\n  vec4 col4, snCol;\n  vec2 g;\n  col4 = vec4 (0.);\n  vf = vec2 (0.);\n  g = Hashv2v2 (27. * gId);\n  if (idObj == idTrnk) {\n    col4 = vec4 (HsvToRgb (vec3 (0.1 * g.x, 0.5, 0.4 - 0.2 * g.y)), 0.);\n    snCol = mix (snowCol, mix (col4, snowCol, smoothstep (-0.05, 0.2, vn.y)),\n       smoothstep (0.1 * trSzFac, 0.3 * trSzFac, p.y - GrndHt (HexToPix (gId) * hgSize)));\n    vf = vec2 (32., 2.);\n  } else if (idObj == idLv) {\n    col4 = vec4 (HsvToRgb (vec3 (0.2 + 0.2 * g.x, 0.7, 0.8 - 0.4 * g.y)) *\n       (1. - 0.2 * Noisefv3 (64. * p)), 0.05);\n    snCol = mix (0.6 * col4, snowCol, 0.2 + 0.8 * smoothstep (-0.8, -0.6, vn.y));\n    vf = vec2 (16., mix (2., 8., 1. - snowFac));\n  } else if (idObj == idRk) {\n    col4 = vec4 (mix (vec3 (0.4, 0.3, 0.3), vec3 (0.3, 0.4, 0.5), Fbm2 (16. * p.xz)), 0.1);\n    snCol = mix (col4, snowCol, 0.2 + 0.8 * smoothstep (0., 0.2, vn.y));\n    vf = vec2 (8., 8.);\n  }\n  col4 = mix (col4, snCol, snowFac);\n  return col4;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y < 0.01 * Fbm1 (256. * (atan (rd.x, rd.z) / (2. * pi) + 0.5))) {\n    col = 0.9 * vec3 (0.4, 0.5, 0.8);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    skCol = vec3 (0.4, 0.5, 0.8);\n    if (! isNt) {\n      sd = max (dot (rd, sunDir), 0.);\n      skCol = mix (skCol, vec3 (1., 1., 0.8), step (0.1, sd) *\n         0.2 * pow (sd, 128.) + 0.8 * pow (sd, 2048.));\n    }\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c1, c2, cSky, vn, vnw, rog, roo, rdo;\n  vec2 vf;\n  float dstObjG, dstObjB, dstObj, dstTrObj, dstGrnd, dstWat, sh, htScn;\n  int idObjG;\n  bool isWat, isSky;\n  hgSize = 1.5;\n  bldSize = vec3 (4., 1.5, 2.);\n  bldSzFac = 0.5;\n  htScn = 5.;\n  isWat = false;\n  isSky = false;\n  isSh = false;\n  snowCol = vec4 (0.9, 0.9, 0.95, 0.1);\n  roo = ro;\n  rdo = rd;\n  dstTrObj = TrObjRay (ro, rd);\n#if LOOP_REFL\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstObjG = (ro.y < htScn || rd.y < 0.) ? ObjGRay (ro, rd) : dstFar;\n    idObjG = idObj;\n    dstObjB = ObjRay (ro, rd);\n    dstObj = min (dstObjB, dstObjG);\n    dstGrnd = GrndRay (ro, rd);\n    if (k == 0) {\n      rog = ro + dstGrnd * rd;\n      dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n    }\n    if (k == 0 && dstWat < min (min (dstGrnd, dstObj), dstFar)) {\n      ro += dstWat * rd;\n      vnw = VaryNf (ro + vec3 (0., 0., 0.2 * tCur), vec3 (0., 1., 0.),\n         0.2 - 0.18 * smoothstep (0.1, 0.15, dstWat / dstFar));\n      rd = reflect (rd, vnw);\n      ro += 0.01 * rd;\n      isWat = true;\n    }\n  }\n#else\n  dstObjG = (ro.y < htScn || rd.y < 0.) ? ObjGRay (ro, rd) : dstFar;\n  idObjG = idObj;\n  dstObjB = ObjRay (ro, rd);\n  dstObj = min (dstObjB, dstObjG);\n  dstGrnd = GrndRay (ro, rd);\n  dstWat = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  rog = ro + dstGrnd * rd;\n  if (dstWat < min (min (dstGrnd, dstObj), dstFar)) {\n    ro += dstWat * rd;\n    vnw = VaryNf (ro + vec3 (0., 0., 0.2 * tCur), vec3 (0., 1., 0.),\n       0.2 - 0.18 * smoothstep (0.1, 0.15, dstWat / dstFar));\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstObjG = (ro.y < htScn || rd.y < 0.) ? ObjGRay (ro, rd) : dstFar;\n    idObjG = idObj;\n    dstObjB = ObjRay (ro, rd);\n    dstObj = min (dstObjB, dstObjG);\n    dstGrnd = GrndRay (ro, rd);\n    isWat = true;\n  }\n#endif\n  vf = vec2 (0.);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    if (dstObj < dstGrnd) {\n      if (dstObjB < dstObjG) {\n        ro += dstObjB * rd;\n        vn = ObjNf (ro);\n        col4 = BldCol (mod (floor (ro.z / (2. * zRep) + 0.5), 4.), vn, vf);\n      } else {\n        ro += dstObjG * rd;\n        vn = ObjGNf (ro);\n        idObj = idObjG;\n        col4 = TreeRkCol (ro, vn, vf);\n      }\n      vf.y *= 1. - smoothstep (0.01, 0.25, dstObj / dstFar);\n      col4 *= 1. - 0.2 * smoothstep (0.4, 0.8, dstObj / dstFar);\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      gId = PixToHex (ro.xz / hgSize);\n      SetTrParms ();\n      vn = GrndNf (ro);\n      vf = vec2 (8., 4. * (1. - smoothstep (0.07, 0.5, dstGrnd / dstFar)));\n      if (snowFac < 1.) {\n        c1 = mix (vec3 (0.15, 0.25, 0.15), vec3 (0.2, 0.4, 0.2),\n           smoothstep (0.3, 0.5, Fbm2 (4. * ro.xz)));\n        if (trSzFac > 0.) c1 *= 0.6 + 0.4 * smoothstep (0.4 * trSzFac, 0.7 * trSzFac,\n           length (ro.xz - HexToPix (gId) * hgSize - trOff));\n        c1 *= (1. - 0.2 * Noisefv2 (128. * ro.xz));\n        c2 = vec3 (0.3, 0.3, 0.35) * (1. - 0.2 * Noisefv2 (256. * ro.zy));\n        col4 = vec4 (mix (c2, mix (c2, c1, smoothstep (0.4, 0.7, vn.y)),\n           smoothstep (0., 0.005 * Noisefv2 (128. * ro.xz), ro.y)), 0.);\n      } else col4 = vec4 (0.);\n      col4 = mix (col4, snowCol, snowFac);\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    isSh = true;\n    sh = (! isNt) ? min (ObjGSShadow (ro, sunDir), ObjSShadow (ro, sunDir)) : 1.;\n    col = col4.rgb * (0.2 + 0.2 * max (dot (normalize (- sunDir.xz), vn.xz), 0.) +\n       0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.));\n    if (! isNt) col += step (0.95, sh) * col4.a * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n  } else {\n    if (! isWat) {\n      ro = roo;\n      rd = rdo;\n    }\n    isSky = true;\n  }\n  cSky = SkyBgCol (ro, rd);\n  if (isSky) col = cSky;\n  if (isWat) col = mix (mix (vec3 (0., 0.1, 0.), vec3 (0.08, 0.08, 0.1),\n     smoothstep (0.45, 0.55, Noisefv2 (128. * rog.xz))), 0.9 * col,\n     1. - 0.9 * pow (dot (- rdo, vnw), 2.));\n  if (! isSky) col = mix (col, cSky, smoothstep (0.8, 1.,\n     (min (dstGrnd, dstObj) + (isWat ? dstWat : 0.)) / dstFar));\n  if (isNt) col = mix (col, 0.6 * vec3 (pow (Maxv3 (col), 1.5)), 0.9) *\n     (isFlsh ? 1.5 * vec3 (1., 1., 0.8) : vec3 (0.4));\n  if (! isWat && dstTrObj < min (min (dstObj, dstGrnd), dstFar)) {\n    ro = roo + dstTrObj * rdo;\n    rd = reflect (rdo, TrObjNf (ro));\n    if (rd.y > 0.01 * Fbm1 (512. * (atan (rd.x, rd.z) / (2. * pi) + 0.5)))\n       col = mix (col, (isNt ? 0.2 : 0.8) * SkyBgCol (ro, rd), 0.7);\n    else col *= 0.5;\n    if (isNt) col = mix (col, vec3 (0.5, 0.5, 0.2), 0.3);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, vd, mMid[4], ut[4], mSize, msw;\n  float el, az, asp, zmFac, t, vel, f, vuId, regId, sr;\n  const int nsWin = 4;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./7.) * vec2 (asp, 1.);\n  for (int k = 0; k < nsWin; k ++) mMid[k] = vec2 (asp, 1.) * (1. - mSize.y);\n  mMid[0] = mMid[0] * vec2 (-1., -1.);\n  mMid[1] = mMid[1] * vec2 (-1., -1.) + vec2 (2. * mSize.x, 0.);\n  mMid[2] = mMid[2] * vec2 (1., -1.)  + vec2 (- 2. * mSize.x, 0.);\n  mMid[3] = mMid[3] * vec2 (1., -1.);\n  for (int k = 0; k < nsWin; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1.;\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < nsWin; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = 1. + float (k);\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == -1.) msw = mPtr.xy;\n  }\n  vuId = 0.;\n  for (int k = 0; k < nsWin; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = float (k + 1);\n      break;\n    }\n  }\n  if (regId > 0. && vuId == 0.) vuId = regId;\n  vuMode = (vuId == 0. || vuId == 1. || vuId == 3.) ? 0 : 1;\n  isNt = (vuId == 3. || vuId == 4.);\n  isFlsh = (Fbm1 (10. * tCur) > 0.7);\n  snowFac = SmoothBump (0.4, 0.9, 0.03, mod (tCur / 120., 1.));\n  zRep = 64.;\n  trkF = vec3 (1., 2., 3.) / zRep;\n  trkA = vec3 (1.5, -1.2, 0.8);\n  trkF2 = vec2 (1., 2.) * 16. / zRep;\n  trkA2 = vec2 (-0.1, 0.05);\n  if (vuMode == 0) {\n    vel = 1.5;\n    t = vel * tCur + 0.3 * zRep;\n    ro.xz = TrackPathS (t);\n    vd = TrackPathS (t + zRep / 32.) - ro.xz;\n    t = ro.z / (2. * zRep);\n    f = SmoothBump (0.15, 0.85, 0.07, mod (t, 1.));\n    ro.x += 0.5 * (1. - f) * (2. * mod (floor (t + 0.5), 2.) - 1.);\n    ro.y = 0.6 + 7.4 * (1. + 0.5 * mod (floor (t), 2.)) * f;\n    az = 0.;\n    el = 0.;\n    if (vuId == 0.) {\n      az = pi * SmoothBump (0.15, 0.55, 0.15, mod (t, 1.)) * (mod (floor (t), 3.) - 1.);\n      el = -0.07 * pi * (1. + 0.5 * mod (floor (t), 2.)) * f;\n    }\n    az += 0.5 * atan (vd.x, vd.y);\n    zmFac = 3.;\n  } else {\n    ro = vec3 (0., 1.5, -15.);\n    az = 0.03 * pi * tCur;\n    el = -0.023 * pi * (5. - cos (2. * az));\n    zmFac = 4.;\n  }\n  if ((vuId == 0. || vuId == regId) && mPtr.z > 0.) {\n    f = (vuMode == 0) ? 1. : -1.;\n    az += 2. * f * pi * msw.x;\n    el += f * pi * msw.y;\n  }\n  if (vuMode == 0) el = clamp (el, -0.3 * pi, 0.3 * pi);\n  else el = clamp (el, -0.3 * pi, -0.01 * pi);\n  dstFar = 200.;\n  sunDir = normalize (vec3 (1., 1.5, 0.3));\n  vuMat = StdVuMat (el, az);\n  if (vuMode > 0) ro = vuMat * ro;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < nsWin; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 4.) col = vec3 (0.7, 0.7, 0.2);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat PrConeDf (vec3 p, vec3 b)\n{\n  return max (dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat SmootherStep (float a, float b, float x)\n{\n  x = clamp ((x - a) / (b - a), 0., 1.); \n  return ((6. * x - 15.) * x + 10.) * x * x * x;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjXWG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1887, 1887, 1914, 1914, 1973], [1975, 1975, 2001, 2001, 2080], [2082, 2082, 2105, 2105, 2447], [2449, 2449, 2483, 2483, 2977], [2979, 2979, 3001, 3001, 3145], [3147, 3147, 3170, 3170, 4231], [4233, 4233, 4253, 4253, 4939], [4941, 4941, 4975, 4975, 6062], [6064, 6064, 6086, 6086, 6344], [6346, 6346, 6384, 6384, 6793], [6795, 6795, 6817, 6817, 9895], [9897, 9897, 9919, 9919, 10010], [10012, 10012, 10045, 10045, 10228], [10230, 10230, 10251, 10251, 10506], [10508, 10508, 10532, 10532, 10703], [10705, 10705, 10740, 10740, 10924], [10926, 10926, 10949, 10949, 11206], [11208, 11208, 11245, 11245, 11492], [11494, 11494, 11543, 11543, 13577], [13579, 13579, 13626, 13626, 14574], [14576, 14576, 14610, 14610, 15421], [15423, 15423, 15458, 15458, 20013], [20015, 20015, 20071, 20071, 23404], [23406, 23406, 23438, 23438, 23538], [23540, 23540, 23573, 23573, 23662], [23664, 23664, 23697, 23697, 23724], [23726, 23726, 23768, 23768, 23819], [23821, 23821, 23864, 23864, 23928], [23930, 23930, 23974, 23974, 24034], [24036, 24036, 24069, 24069, 24142], [24144, 24144, 24189, 24189, 24281], [24283, 24283, 24328, 24328, 24366], [24368, 24368, 24425, 24425, 24508], [24510, 24510, 24558, 24558, 24651], [24653, 24653, 24675, 24675, 24702], [24704, 24704, 24726, 24726, 24753], [24755, 24755, 24777, 24777, 24815], [24817, 24817, 24839, 24839, 24877], [24879, 24879, 24915, 24915, 25121], [25123, 25123, 25153, 25153, 25266], [25268, 25268, 25292, 25292, 25522], [25524, 25524, 25548, 25548, 25608], [25610, 25610, 25634, 25634, 25751], [25785, 25785, 25809, 25809, 25869], [25871, 25871, 25895, 25895, 25948], [25950, 25950, 25974, 25974, 26086], [26088, 26088, 26112, 26112, 26255], [26257, 26257, 26282, 26282, 26428], [26430, 26430, 26455, 26455, 26641], [26643, 26643, 26668, 26668, 26893], [26895, 26895, 26917, 26917, 27071], [27073, 27073, 27094, 27094, 27249], [27251, 27251, 27280, 27280, 27492], [27494, 27494, 27533, 27533, 27790]]}
{"id": "7sBXDG", "name": "fourier approximate square wave", "author": "hornet", "description": "https://mathworld.wolfram.com/FourierSeriesSquareWave.html", "tags": ["wave", "approximation", "square", "analog", "fourier"], "likes": 3, "viewed": 285, "published": 3, "date": "1620910105", "time_retrieved": "2024-07-30T19:20:34.646219", "image_code": "//#define ANIMATE\n\n//note: [-4.0/PI;4.0/PI]\nfloat sq_approx( float t )\n{    \n    const float PI = 3.1415926536;\n    const int NUM_ITERATIONS = 7;\n    const float T = 0.5;\n    \n    float sum_sin = 0.0;\n    for (int i=1; i<2*NUM_ITERATIONS; i+=2 )\n    {\n        sum_sin += sin( (2.0*PI*float(i)*t) / T ) / float(i);\n    }\n    sum_sin *= 4.0 / PI;\n    return sum_sin;\n}\n\n//note: [0;1]\nfloat sq_approx_norm( float t )\n{\n    const float PI = 3.1415926536;\n    return 0.5 + 0.5 * sq_approx(t) * PI / 4.0;\n}\n\n\n// ======================================\n\nfloat f( float v )\n{\n    //return sq_approx(v);\n    return sq_approx_norm(v);\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ab=b-a,ap=p-a;\n    return length(ap-ab*clamp(dot(ab,ap)/dot(ab,ab), 0.0, 1.0));\n}\nfloat eval_dist( vec2 uv )\n{\n    //note: evaluate function at pixel-edges\n    //      +-------+\n\t//      |       |\n\t//      x0  x  x1\n\t//      |       |\n\t//      +-------+\n    float dx = 0.5 * dFdx( uv.x );\n    float x0 = uv.x - dx;\n    float x1 = uv.x + dx;\n    float y0 = f( x0 );\n    float y1 = f( x1 );\n\n    //note: calculate distance to line-segment (x0,y0)<->(x1,y1)\n    //      +-------+\n\t//      |    /-x1\n    //      |  -x   |\n\t//     x0-/     |\n\t//      +-------+\n    float d = sd_segment( uv, vec2(x0,y0), vec2(x1,y1) );\n    return smoothstep( dFdy(uv.y), 0.0, d );\n}\n\n\n// ======================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n \n    #if defined( ANIMATE )\n    ssuv.x += 0.125*sin(iTime);\n    #endif //ANIMATE\n \n    vec2 luv = vec2( 2.0 * ssuv.x-1.0, 5.0*ssuv.y - 1.25 );\n   \n    float v = f( luv.x );\n    float g = eval_dist( luv );\n    \n    if ( ssuv.y < 0.5 )\n    {\n        fragColor = vec4( vec3(g), 1.0 );\n        if ( abs(luv.y-1.0) < dFdy(luv.y) ) fragColor.rgb += 0.5;\n        if ( abs(luv.y-0.0) < dFdy(luv.y) ) fragColor.rgb += 0.5;\n        if ( abs(luv.y+1.0) < dFdy(luv.y) ) fragColor.rgb += 0.5;    \n        if ( abs(luv.x+0.0) < dFdx(luv.x) ) fragColor.rgb += 0.5;\n    }\n    else\n        fragColor = vec4( vec3(v), 1.0 );\n            \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.4) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 44, 72, 72, 366], [368, 382, 415, 415, 500], [546, 546, 566, 593, 625], [627, 627, 669, 669, 760], [761, 761, 789, 932, 1339], [1385, 1385, 1442, 1442, 2169]]}
{"id": "ssBXDG", "name": "Polar_coordinates_sample", "author": "butadiene", "description": "Polar coordinates\n", "tags": ["sample"], "likes": 0, "viewed": 262, "published": 3, "date": "1620904833", "time_retrieved": "2024-07-30T19:20:35.501931", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float x = uv.x;\n    float y = uv.y;\n\n    vec4 color0 = texture(iChannel0,vec2(x,y));//ゆがんでない\n\n    float r = length(vec2(x,y));\n    float theta = atan(y,x); //極座標変換\n\n    vec4 color1 = texture(iChannel0,vec2(r,theta));//円形にゆがむ\n\n\n    vec4 color2 = texture(iChannel0,vec2(r*cos(theta),r*sin(theta)));\n    //極座標を用いて、デカルト座標を表す。これはゆがまない\n\n   \n   \n   \n    vec4 col = color0;\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBXDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 656]]}
{"id": "7sBSWG", "name": "大龙猫 - Quicky#052", "author": "totetmatt", "description": "Quicky done in the ICE, slight difference from Bonzo (mainly texFFT)", "tags": ["quicky"], "likes": 5, "viewed": 278, "published": 3, "date": "1620900139", "time_retrieved": "2024-07-30T19:20:36.322737", "image_code": "#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n#define flikflok(t) (floor(t)+pow(fract(t),.25))\nvec2 sdf(vec3 p) {\n  float bt = iTime*.5;\n  float bt3 = iTime*.33;\n   p.z +=floor(bt3*10.);\n   p.xy *=rot(p.z*.785*.1);\n  vec3 op = p;    \n  float tt = texture(iChannel1,p.xz*.1).r*.1;\n\n    vec2 h;\n    vec3 pp = p;\n    p = abs(p)-1.5;\n    h.x = length(p)-1.;\n  p.xy = abs(p.x) < abs(p.y)  ?p.yx:p.xy;\n  \n  \n    p.xz/=3.;\n    p.xz = asin(sin(p.zx));\n    p.xz*=3.;\n    h.x = min(h.x,length(p.xz)-.5-clamp(cos(abs(p.y)*4.+fGlobalTime*180./60.*4.),-.25+sin(p.y*10.)*.1,.25)*.4);   \n     h.y = 1.;\n      h.x*=.7;\n   return h;\n}\nvec2 nv=vec2(-.001,.001);\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(0.,.3,.7)));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float tt = fract(iTime);\n  vec3 bcol = log(1.+tt*100.11)*pal(.5+uv.x);\n  \n  float ttt =texture(iChannel1,uv*10.).r;\n  float pp = fract(iTime);\n\t\n  \n  vec3 ro=vec3(0.,0.,-5.),rd=normalize(vec3(uv,1.-pp*ttt)),rp=ro;\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 acc = vec3(0.);\n  vec3 col =vec3(0.);\n  for(float i=0.;i<=69.;i++){\n      vec2 d = sdf(rp);\n    \n        \n          acc+=mix(vec3(1.,.7,.2),vec3(.1,.5,.7),step(.5,i/69.))*exp(20.*-abs(d.x))/(10.);\n            \n       if(d.x<=0.005){\n         vec3 n = norm(rp);\n        col *= vec3(1.)*max(0.,dot(n,normalize(light-rp)));\n      \n        break;\n        }\n        rp+=rd*d.x;\n   }\n  col +=acc;\n \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBSWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 44, 44, 91], [141, 141, 159, 159, 663], [716, 716, 734, 734, 793], [794, 794, 812, 812, 858], [859, 859, 916, 966, 1734]]}
{"id": "NsBXDy", "name": "alphaGo vs Lee Sedol", "author": "changjiu", "description": "alphaGo vs Lee Sedol；The fourth game，This is the last time hunman kill god\nalphaGo 对战 李世石，第四局，这是人类最后一次弑神", "tags": ["alphago"], "likes": 4, "viewed": 260, "published": 3, "date": "1620899298", "time_retrieved": "2024-07-30T19:20:37.154513", "image_code": "#define Count 308\n\nstruct Piece{\n    float x;\n    float y;\n    float color;\n};\n\nconst Piece pieces[Count] = Piece[](\n    Piece(16., 4., 0.),\nPiece(4., 16., 1.),\nPiece(3., 4., 0.),\nPiece(17., 16., 1.),\nPiece(15., 16., 0.),\nPiece(15., 17., 1.),\nPiece(14., 17., 0.),\nPiece(16., 17., 1.),\nPiece(3., 14., 0.),\nPiece(6., 17., 1.),\nPiece(13., 16., 0.),\nPiece(16., 15., 1.),\nPiece(9., 17., 0.),\nPiece(5., 3., 1.),\nPiece(8., 4., 0.),\nPiece(3., 7., 1.),\nPiece(5., 4., 0.),\nPiece(3., 10., 1.),\nPiece(4., 3., 0.),\nPiece(2., 16., 1.),\nPiece(14., 3., 0.),\nPiece(17., 9., 1.),\nPiece(5., 16., 0.),\nPiece(5., 15., 1.),\nPiece(4., 11., 0.),\nPiece(6., 16., 1.),\nPiece(3., 11., 0.),\nPiece(4., 10., 1.),\nPiece(5., 10., 0.),\nPiece(5., 9., 1.),\nPiece(6., 9., 0.),\nPiece(5., 8., 1.),\nPiece(6., 8., 0.),\nPiece(2., 10., 1.),\nPiece(6., 11., 0.),\nPiece(6., 7., 1.),\nPiece(7., 7., 0.),\nPiece(6., 6., 1.),\nPiece(7., 6., 0.),\nPiece(13., 3., 1.),\nPiece(13., 4., 0.),\nPiece(12., 3., 1.),\nPiece(14., 2., 0.),\nPiece(9., 4., 1.),\nPiece(8., 3., 0.),\nPiece(10., 7., 1.),\nPiece(16., 10., 0.),\nPiece(16., 9., 1.),\nPiece(15., 10., 0.),\nPiece(15., 9., 1.),\nPiece(14., 9., 0.),\nPiece(14., 8., 1.),\nPiece(13., 8., 0.),\nPiece(14., 7., 1.),\nPiece(13., 7., 0.),\nPiece(13., 9., 1.),\nPiece(14., 10., 0.),\nPiece(13., 6., 1.),\nPiece(12., 9., 0.),\nPiece(14., 5., 1.),\nPiece(14., 4., 0.),\nPiece(13., 10., 1.),\nPiece(12., 6., 0.),\nPiece(13., 11., 1.),\nPiece(13., 5., 0.),\nPiece(14., 6., 1.),\nPiece(12., 8., 0.),\nPiece(17., 10., 1.),\nPiece(11., 11., 0.),\nPiece(9., 11., 1.),\nPiece(10., 9., 0.),\nPiece(7., 8., 1.),\nPiece(8., 10., 0.),\nPiece(7., 5., 1.),\nPiece(8., 5., 0.),\nPiece(6., 4., 1.),\nPiece(6., 3., 0.),\nPiece(11., 9., 1.),\nPiece(10., 10., 0.),\nPiece(12., 10., 1.),\nPiece(11., 8., 0.),\nPiece(10., 8., 1.),\nPiece(13., 12., 0.),\nPiece(14., 11., 1.),\nPiece(15., 12., 0.),\nPiece(15., 11., 1.),\nPiece(16., 11., 0.),\nPiece(16., 12., 1.),\nPiece(17., 11., 0.),\nPiece(14., 12., 1.),\nPiece(11., 10., 0.),\nPiece(9., 9., 1.),\nPiece(18., 11., 0.),\nPiece(15., 13., 1.),\nPiece(16., 7., 0.),\nPiece(17., 12., 1.),\nPiece(3., 16., 0.),\nPiece(3., 15., 1.),\nPiece(15., 5., 0.),\nPiece(18., 12., 1.),\nPiece(19., 11., 0.),\nPiece(18., 10., 1.),\nPiece(8., 7., 0.),\nPiece(9., 10., 1.),\nPiece(11., 13., 0.),\nPiece(7., 9., 1.),\nPiece(6., 10., 0.),\nPiece(10., 12., 1.),\nPiece(11., 12., 0.),\nPiece(7., 12., 1.),\nPiece(6., 12., 0.),\nPiece(7., 13., 1.),\nPiece(3., 8., 0.),\nPiece(5., 5., 1.),\nPiece(5., 2., 0.),\nPiece(2., 7., 1.),\nPiece(4., 7., 0.),\nPiece(5., 7., 1.),\nPiece(5., 14., 0.),\nPiece(6., 15., 1.),\nPiece(4., 6., 0.),\nPiece(4., 8., 1.),\nPiece(9., 13., 0.),\nPiece(8., 11., 1.),\nPiece(2., 14., 0.),\nPiece(9., 6., 1.),\nPiece(7., 4., 0.),\nPiece(6., 5., 1.),\nPiece(8., 6., 0.),\nPiece(9., 8., 1.),\nPiece(2., 8., 0.),\nPiece(3., 9., 1.),\nPiece(8., 15., 0.),\nPiece(7., 15., 1.),\nPiece(15., 18., 0.),\nPiece(18., 7., 1.),\nPiece(4., 14., 0.),\nPiece(3., 17., 1.),\nPiece(16., 18., 0.),\nPiece(17., 18., 1.),\nPiece(18., 6., 0.),\nPiece(17., 7., 1.),\nPiece(17., 6., 0.),\nPiece(10., 3., 1.),\nPiece(7., 18., 0.),\nPiece(19., 6., 1.),\nPiece(19., 5., 0.),\nPiece(19., 7., 1.),\nPiece(18., 4., 0.),\nPiece(2., 12., 1.),\nPiece(2., 11., 0.),\nPiece(1., 11., 1.),\nPiece(3., 12., 0.),\nPiece(8., 14., 1.),\nPiece(9., 14., 0.),\nPiece(8., 16., 1.),\nPiece(6., 18., 0.),\nPiece(5., 18., 1.),\nPiece(5., 19., 0.),\nPiece(4., 19., 1.),\nPiece(1., 8., 0.),\nPiece(1., 9., 1.),\nPiece(11., 4., 0.),\nPiece(9., 5., 1.),\nPiece(11., 3., 0.),\nPiece(11., 2., 1.),\nPiece(7., 11., 0.),\nPiece(9., 2., 1.),\nPiece(17., 8., 0.),\nPiece(18., 8., 1.),\nPiece(17., 19., 0.),\nPiece(18., 19., 1.),\nPiece(15., 8., 0.),\nPiece(19., 12., 1.),\nPiece(15., 6., 0.),\nPiece(19., 10., 1.),\nPiece(14., 9., 0.),\nPiece(14., 10., 1.),\nPiece(15., 15., 0.),\nPiece(10., 16., 1.),\nPiece(8., 8., 0.),\nPiece(12., 7., 1.),\nPiece(11., 7., 0.),\nPiece(11., 6., 1.),\nPiece(11., 10., 0.),\nPiece(12., 5., 1.),\nPiece(11., 9., 0.),\nPiece(12., 7., 1.),\nPiece(15., 12., 0.),\nPiece(11., 10., 0.),\nPiece(9., 9., 1.),\nPiece(9., 10., 0.),\nPiece(7., 9., 1.),\nPiece(6., 10., 0.),\nPiece(10., 8., 1.),\nPiece(11., 8., 0.),\nPiece(8., 6., 1.),\nPiece(8., 7., 0.),\nPiece(9., 6., 1.),\nPiece(7., 10., 0.),\nPiece(10., 10., 1.),\nPiece(10., 11., 0.),\nPiece(8., 6., 1.),\nPiece(8., 7., 0.),\nPiece(9., 6., 1.),\nPiece(8., 9., 0.),\nPiece(14., 6., 1.),\nPiece(13., 10., 0.),\nPiece(12., 4., 1.),\nPiece(18., 5., 0.),\nPiece(6., 4., 1.),\nPiece(6., 3., 0.),\nPiece(14., 10., 1.),\nPiece(17., 10., 0.),\nPiece(14., 11., 1.),\nPiece(18., 9., 0.),\nPiece(18., 8., 1.),\nPiece(18., 10., 0.),\nPiece(14., 8., 1.),\nPiece(13., 9., 0.),\nPiece(13., 8., 1.),\nPiece(12., 9., 0.),\nPiece(12., 8., 1.),\nPiece(11., 9., 0.),\nPiece(17., 7., 1.),\nPiece(16., 13., 0.),\nPiece(12., 4., 1.),\nPiece(13., 5., 0.),\nPiece(9., 2., 1.),\nPiece(7., 2., 0.),\nPiece(9., 4., 1.),\nPiece(11., 6., 0.),\nPiece(8., 3., 1.),\nPiece(7., 4., 0.),\nPiece(10., 5., 1.),\nPiece(5., 11., 1.),\nPiece(6., 10., 0.),\nPiece(2., 11., 1.),\nPiece(5., 12., 0.),\nPiece(12., 17., 1.),\nPiece(12., 16., 0.),\nPiece(14., 18., 1.),\nPiece(11., 17., 0.),\nPiece(13., 17., 1.),\nPiece(10., 14., 0.),\nPiece(6., 4., 1.),\nPiece(5., 5., 0.),\nPiece(10., 3., 1.),\nPiece(3., 11., 1.),\nPiece(6., 16., 0.),\nPiece(5., 17., 1.),\nPiece(4., 15., 0.),\nPiece(3., 15., 1.),\nPiece(4., 14., 0.),\nPiece(7., 16., 1.),\nPiece(6., 15., 0.),\nPiece(8., 17., 1.),\nPiece(9., 16., 0.),\nPiece(7., 15., 1.),\nPiece(6., 14., 0.),\nPiece(7., 14., 1.),\nPiece(6., 13., 0.),\nPiece(2., 14., 1.),\nPiece(5., 17., 1.),\nPiece(4., 15., 0.),\nPiece(3., 16., 1.),\nPiece(4., 11., 0.),\nPiece(3., 11., 1.),\nPiece(3., 12., 0.),\nPiece(4., 12., 1.),\nPiece(5., 12., 0.),\nPiece(4., 13., 1.),\nPiece(5., 13., 0.),\nPiece(3., 13., 1.),\nPiece(2., 13., 0.),\nPiece(2., 12., 1.),\nPiece(4., 14., 0.),\nPiece(3., 12., 1.),\nPiece(7., 16., 0.),\nPiece(6., 16., 1.),\nPiece(7., 15., 0.),\nPiece(4., 5., 1.),\nPiece(3., 5., 0.),\nPiece(4., 6., 1.),\nPiece(3., 7., 0.),\nPiece(4., 7., 1.),\nPiece(3., 8., 0.),\nPiece(4., 8., 1.),\nPiece(4., 9., 0.),\nPiece(5., 9., 1.),\nPiece(5., 10., 0.),\nPiece(3., 6., 1.),\nPiece(2., 6., 0.),\nPiece(2., 5., 1.),\nPiece(2., 7., 0.),\nPiece(3., 3., 1.),\nPiece(2., 4., 0.),\nPiece(4., 10., 1.),\nPiece(3., 9., 0.),\nPiece(6., 9., 1.),\nPiece(6., 10., 0.),\nPiece(7., 10., 1.),\nPiece(7., 9., 0.),\nPiece(6., 7., 1.),\nPiece(8., 9., 0.),\nPiece(7., 11., 1.),\nPiece(6., 12., 0.),\nPiece(4., 13., 1.)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    \n    float cellWidth = floor(iResolution.y/25.0);\n    float lineWidth = ceil(cellWidth/20.0);\n    \n    vec3 col = vec3(0.5,0.5,0.5);\n    \n    bool lineV = int(uv.x)%int(cellWidth)<int(lineWidth) && uv.x/cellWidth<20.0 && uv.x/cellWidth>1.0 && uv.y>cellWidth*1.0 && uv.y<cellWidth*19.0;\n    bool lineH = int(uv.y)%int(cellWidth)<int(lineWidth) && uv.y/cellWidth<20.0 && uv.y/cellWidth>1.0 && uv.x>cellWidth*1.0 && uv.x<cellWidth*19.0;\n    \n    \n    if(lineV||lineH){\n        col = vec3(0,0,0);\n    }\n\n    \n    float x0 = uv.x;\n    float y0 = uv.y;\n    \n    float t = mod(iTime,308.);\n \n    for(int i=0; i<Count && i<int(t); i++){\n        float x = pieces[i].x;\n        float y = pieces[i].y;\n        float dis = distance(uv, vec2(x*cellWidth, y*cellWidth));\n        if(dis<cellWidth/2.0){\n            col=vec3(pieces[i].color);\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[6264, 6264, 6321, 6371, 7320]]}
{"id": "Nd2Szd", "name": "2D Julia set", "author": "takeshi", "description": "ジュリア集合", "tags": ["julia"], "likes": 1, "viewed": 212, "published": 3, "date": "1620886388", "time_retrieved": "2024-07-30T19:20:37.912486", "image_code": "#define cos01(x) ((cos(x)+1.)/2.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb*rgb*(3.0-2.0*rgb), c.y);\n}\n\n#define MAX_ITERS 400\nfloat julia( vec2 z, vec2 c ){\n  for( int i=0; i<MAX_ITERS; i++ ){\n      z = vec2( z.x*z.x-z.y*z.y, 2.*z.x*z.y ) + c;\n      if( length(z) > 2. ){\n        return (float(i) - log2(log2(dot(z,z))) + 4.0) / float(MAX_ITERS);\n      }\n  }\n  return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  float time = iTime * 0.4;\n  float ratio = iResolution.y/iResolution.x;\n  vec2 mo = iMouse.xy / iResolution.xy - 0.5;\n  //mo = vec2(cos(time),-sin(time))*.2;\n  vec2 uv = fragCoord / iResolution.xx - 0.5*vec2(1.,ratio);\n  uv *= rot(-.8);\n  float d = julia(uv*2.4,vec2(-0.1,-0.65)+mo*vec2(.4,.1));\n  float h = cos01(pow(d,1.)/.1);\n  float s = pow(d,1./2.0);\n  float v = 1.-pow(d,1.1) - pow(length(uv),2.2);\n  vec3 hsv = vec3(cos01(h+time/1.),s,v);\n  fragColor = vec4(hsv2rgb(hsv),1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2Szd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 111, 111, 258], [531, 531, 587, 587, 1072]]}
{"id": "NdSSWz", "name": "Multi-material blending V2", "author": "RogerB", "description": "Blending of an arbitrary number of materials in a way that's compatible with textures, reflections, and material properties.", "tags": ["raymarching", "sdf", "blending"], "likes": 5, "viewed": 328, "published": 3, "date": "1620875162", "time_retrieved": "2024-07-30T19:20:38.664476", "image_code": "// SHARED CONSTANTS\n\nconst float VERTICAL_FOV = 60.f;\n\n// How far away from the surface counts as 0.\nconst float MARCH_EPS = 0.00001;\n\n// How far to move away from the surface of the shape before marching reflections and shadows so the march doesn't get stuck near the surface.\nconst float T_EPS = MARCH_EPS * 2.;\nconst float NORMAL_EPS = MARCH_EPS * 2.;\n\n// How large of a step to use when computing the gradient.\nconst float GRADIENT_EPS = 0.001;\n\n// How low of a transmittance to use as a cutoff for reflections.\nconst float REFLECTION_EPS = 0.001;\n\nconst float FAR_CLIP = 100.;\nconst int MAX_MARCH_STEPS = 256;\n\n// Maximum number of reflections. Total number of casts = 1+MAX_REFLECTIONS.\nconst int MAX_REFLECTIONS = 5;\n\nconst float PI = 3.1416;\n\n// CAMERA MATH\n\nvec3 computeCameraRay (vec3 eye, vec3 target, vec2 uv) {\n    vec3 look = target - eye;\n    float lookLen = length(look);\n    vec3 xDir = normalize(cross(look, vec3(0, 1, 0)));\n    vec3 yDir = normalize(cross(xDir, look));\n    \n    // Distance to move in world-space to move one unit in screen-space.\n    float unitDist = tan(VERTICAL_FOV/2. * PI/180.) * lookLen;\n    \n    vec3 rayTarget = target + unitDist*(xDir*uv.x + yDir*uv.y);\n    return normalize(rayTarget - eye);\n}\n\n// MATERIALS\n\n// An earlier version represented materials in SdResult as a vector of material weights, with one component for each material in the scene.\n// Storing/blending material properties directly scales better for scenes with many textures.\nstruct Mat {\n    vec3 diffuseCol;\n    vec3 specularCol;\n    float shininess;\n    float reflectivity;\n};\n\nconst Mat red = Mat(vec3(0.2, 0.02, 0.02), vec3(0.04, 0.02, 0.02), 32.0, 0.0);\nconst Mat green = Mat(vec3(0.02, 0.2, 0.02), vec3(0.02, 0.04, 0.02), 32.0, 0.0);\nconst Mat blue = Mat(vec3(0.02, 0.02, 0.2), vec3(0.02, 0.02, 0.04), 32.0, 0.0);\nconst Mat mirror = Mat(vec3(0.01), vec3(0.09), 64., 0.9);\n\nMat floorMat(vec3 pos) {\n    vec3 white = vec3(0.3);\n    vec3 black = vec3(0.025);\n    \n    // Smoothstep for antialising; smooth more strongly further out.\n    // TODO: Antialias better. (Idea: Compute screen-space distance (in pixels?) to the other color and blend using that.)\n    float smoothstepSize = 0.005;\n    float scale = max(10., pow(length(pos), 1.3));\n    vec2 tile2D = smoothstep(-smoothstepSize, smoothstepSize, sin(pos.xz * PI) / scale);\n    float tile = min(max(tile2D.x, tile2D.y), max(1.-tile2D.x,1.-tile2D.y)); // Fuzzy xor.\n    vec3 color = mix(white, black, tile);\n    \n    return Mat(color,vec3(0.03), 128.0, 0.0);\n}\n\n// SCENE DEFINITION\n\nstruct SdResult {\n    float dist;\n    Mat mat;\n};\n\nfloat sdSphere(float r, vec3 p) {\n    return length(p) - r;\n}\n\nfloat sdPlane(float height, vec3 p) {\n    return p.y - height;\n}\n\nfloat largest(vec3 a) {\n    return max(a.x, max(a.y, a.z));\n}\n\nfloat sdBox(vec2 r, vec2 p) {\n    vec2 d = abs(p) - r;\n    float exterior = length(max(d, 0.));\n    float interior = min(max(d.x,d.y), 0.);\n    return exterior + interior;\n}\n\nfloat sdBox(vec3 r, vec3 p) {\n    vec3 d = abs(p) - r;\n    float exterior = length(max(d, 0.));\n    float interior = min(largest(d), 0.);\n    return exterior + interior;\n}\n\nfloat sdCylinder(vec2 r, vec3 p) {\n    return sdBox(r, vec2(length(p.xz), p.y));\n}\n\nSdResult sdUnion(SdResult a, SdResult b) {\n    if (a.dist < b.dist) return a; else return b;\n}\n\nMat blend(Mat a, Mat b, float k) {\n    return Mat(\n        mix(a.diffuseCol, b.diffuseCol, k),\n        mix(a.specularCol, b.specularCol, k),\n        mix(a.shininess, b.shininess, k),\n        mix(a.reflectivity, b.reflectivity, k)\n    );\n}\n\n// TODO: Generalize exponential smoothmin to work with multiple terms, each with their own smoothing coefficient.\n// (Start by deriving an asymmetrical smoothmin for two terms, then generalize it to n terms.)\n\n// k.x is the factor used for blending shape; ky is the factor for blending material.\nSdResult sminCubic(SdResult a, SdResult b, vec2 k) {\n    k = max(k, 0.0001);\n    vec2 h = max(k - abs(a.dist - b.dist), 0.0)/k;\n    vec2 m = h * h * h * 0.5;\n    vec2 s = m * k * (1.0 / 3.0);\n    \n    SdResult res;\n    bool aCloser = a.dist < b.dist;\n    res.dist = (aCloser ? a.dist : b.dist) - s.x;\n    float blendCoeff = aCloser ? m.y : 1.0-m.y;\n    \n    res.mat = blend(a.mat, b.mat, blendCoeff);\n    return res;\n}\n\nSdResult sminCubic(SdResult a, SdResult b, float k) {\n    return sminCubic (a, b, vec2(k));\n}\n\nvec3 rot45(vec3 p) {\n    const float ROOT_2_OVER_2 = 0.70710678118;\n    return vec3(ROOT_2_OVER_2 * (p.x - p.z), p.y, ROOT_2_OVER_2 * (p.x + p.z));\n}\n\n// I'm reasonably certain that the material calculations get optimized away by the compiler in cases where only the distance is used.\n// If this isn't the case, the optimization could be done manually by making a version of this function that only computes the distance.\nSdResult sdScene(vec3 p) {\n    float time = iTime - 2.8; // Add an offset to the current time so the thumbnail at time 0 looks good.\n    vec3 sphere1Pos = vec3(0, 0.5, 0);\n    SdResult sphere1 = SdResult(sdSphere(1.0, p - sphere1Pos), red);\n    SdResult result = sphere1;\n    \n    vec3 sphere2Pos = vec3(2.5*cos(time), 1, 2.5*sin(time));\n    SdResult sphere2 = SdResult(sdSphere (1.5, p - sphere2Pos), green);\n    result = sminCubic(result, sphere2, vec2(2, 1));\n    \n    vec3 sphere3Pos = vec3(-2.*cos(time/2.), 1, 2.*sin(time/2.));\n    SdResult sphere3 = SdResult(sdSphere (1.25, p - sphere3Pos), blue);\n    result = sminCubic(result, sphere3, 1.);\n    \n    SdResult floor = SdResult(sdPlane(0.0, p), floorMat(p));\n    result = sminCubic(result, floor, 1.5);\n    \n    vec3 smallMirrorPos = vec3(1.2, 1.4, 0.);\n    SdResult smallMirror = SdResult(sdBox(vec3(0.5), p - smallMirrorPos) - 0.05, mirror);\n    result = sminCubic(result, smallMirror, vec2(1., 0.5));\n    \n    vec3 cylinderPos = vec3(-5., 1., -3.);\n    SdResult cylinder = SdResult(sdCylinder(vec2(1., 1.5), p - cylinderPos) - 0.5, mirror);\n    \n    vec3 boxPos = vec3(5., 0., -4.);\n    SdResult box = SdResult(sdBox(vec3(1., 3., 3.), rot45(p - boxPos)) - 0.1, mirror);\n    \n    SdResult mirrors = sdUnion(cylinder, box);\n    result = sminCubic(result, mirrors, 0.1);\n    \n    return result;\n}\n\n// RAY MARCHING\n\n// Returns the distance to the intersection with the scene, or -1 if no intersection is found.\nfloat march(vec3 ro, vec3 rd) {\n    float t = T_EPS;\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 pos = ro + rd*t;\n        float d = sdScene(pos).dist;\n        t += d;\n        if (d/t < MARCH_EPS) break;\n        if (t > FAR_CLIP) return -1.;\n    }\n    return t;\n}\n\n// Returns a coefficient for how much light makes it to a point from a light source.\n// lightApparentSize controls soft shadows. A bigger number means the light takes up a larger viewing area, making softer shadows.\n// (If you want to specify an exact apparent radius, pass in tan(radius), or tan(diameter/2.) for an apparent diameter.)\n// lightDist is the distance to the light source. Used to prevent marching past a point light.\nfloat shadowMarch(vec3 ro, vec3 norm, vec3 rd, float lightApparentSize, float lightDist) {\n    ro += norm * NORMAL_EPS;\n    float t = T_EPS;\n    \n    float minDist = lightApparentSize;\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 pos = ro + rd*t;\n        float d = sdScene(pos).dist;\n        minDist = min(minDist, d/t);\n        t += d;\n        if (d < MARCH_EPS) break; // Good for efficiency and shouldn't impact the final result.\n        if (minDist/lightApparentSize < MARCH_EPS || t > FAR_CLIP) return max(minDist, 0.) / lightApparentSize;\n    }\n    // Assume we're in shadow if we didn't complete the march. This is usually a sign that we couldn't get off the original\n    // surface because the light vector was close to perpendicular.\n    return 0.;\n}\n\n// Overload for light sources infinitely far away.\nfloat shadowMarch(vec3 ro, vec3 norm, vec3 rd, float lightApparentSize) {\n    return shadowMarch(ro, norm, rd, lightApparentSize, FAR_CLIP);\n}\n\nvec3 grad(vec3 pos) {\n    const float eps = GRADIENT_EPS;\n    // Tetrahedron approach from https://iquilezles.org/articles/normalsSDF.\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(pos+eps*e).dist;\n    }\n    return n;\n}\n\nvec3 norm(vec3 pos) {\n    return normalize(grad(pos));\n}\n\n// LIGHTING\n\nvec3 distantPointLight(vec3 lightDir, vec3 lightCol, float lightApparentSize, Mat mat, vec3 pos, vec3 rd, vec3 norm) {\n    vec3 halfVec = normalize(lightDir - rd);\n    \n    vec3 diffuse = mat.diffuseCol * clamp(dot(norm, lightDir), 0., 1.);\n    vec3 specular = mat.specularCol * pow(clamp(dot(norm, halfVec), 0., 1.), mat.shininess);\n    // Normalization from http://www.thetenthplanet.de/archives/255.\n    float specNormalization = (mat.shininess  + 2.) / (4. * (2. - pow(2., -mat.shininess/2.)));\n    \n    return lightCol * shadowMarch(pos, norm, lightDir, lightApparentSize) * (diffuse + specular*specNormalization);\n}\n\nvec3 light(Mat mat, vec3 pos, vec3 rd, vec3 norm) {\n    float occlusion = 1.; // TODO: Some kind of occlusion.\n    \n    vec3 res = vec3(0);\n    \n    vec3 sunDir = normalize(vec3(1,0.75,0.5));\n    vec3 sunCol = vec3(2);\n    float sunApparentSize = 0.047; // The physically correct number is 0.0047, but softer shadows are fun.\n    res += distantPointLight(sunDir, sunCol, sunApparentSize, mat, pos, rd, norm);\n    \n    vec3 ambient =  vec3(0.05) * occlusion;\n    res += ambient * mat.diffuseCol;\n    \n    return res;\n}\n\n\n// RENDERING\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0);\n    float transmittance = 1.;\n    \n    for (int i = min(iFrame,0); i <= MAX_REFLECTIONS; i++) {\n        float dist = march(ro, rd);\n        if (dist > 0.) {\n            vec3 pos = ro + dist*rd;\n            SdResult sd = sdScene(pos);\n            vec3 norm = norm(pos);\n\n            color += transmittance * light(sd.mat, pos, rd, norm);\n            transmittance *= sd.mat.reflectivity;\n            ro = pos + norm * NORMAL_EPS;\n            rd = reflect(rd, norm);\n            \n            if (transmittance < REFLECTION_EPS) break;\n\n            // TODO: Render light sources as a specular reflection directly on the camera.\n        } else {\n            vec3 skyLight = vec3(0.4, 0.4, 0.8);\n            vec3 skyDark = vec3(0.1, 0.1, 0.4);\n            vec3 skyColor = mix(skyDark, skyLight, rd.y);\n            color += transmittance * skyColor;\n            break;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates. (y goes from -1 to 1, x has the same scale per pixel and is centered at 0.)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.yy;\n    \n    // Fixed viewpoint.\n    // vec3 ro = vec3(0, 4, 4);\n    // vec3 target = vec3(0, 0, -2);\n    \n    // Rotating viewpoint.\n    float viewAngle = iTime/10.;\n    vec3 ro = 4. * vec3(sin(viewAngle), 1, cos(viewAngle));\n    vec3 target = -2. * vec3(sin(viewAngle), 0, cos(viewAngle));\n    \n    vec3 rd = computeCameraRay(ro, target, uv);\n    \n    vec3 color = render(ro, rd);\n    \n    color = pow(color, vec3(0.4545)); // Gamma correction.\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSSWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[767, 767, 823, 823, 1239], [1893, 1893, 1917, 1917, 2532], [2606, 2606, 2639, 2639, 2667], [2669, 2669, 2706, 2706, 2733], [2735, 2735, 2758, 2758, 2796], [2798, 2798, 2827, 2827, 2971], [2973, 2973, 3002, 3002, 3144], [3146, 3146, 3180, 3180, 3228], [3230, 3230, 3272, 3272, 3324], [3326, 3326, 3360, 3360, 3564], [3776, 3862, 3914, 3914, 4280], [4282, 4282, 4335, 4335, 4375], [4377, 4377, 4397, 4397, 4526], [4528, 4799, 4825, 4825, 6153], [6172, 6267, 6298, 6298, 6546], [6548, 6980, 7070, 7070, 7755], [7757, 7808, 7881, 7881, 7950], [7952, 7952, 7973, 7973, 8286], [8288, 8288, 8309, 8309, 8344], [8359, 8359, 8477, 8477, 8980], [8982, 8982, 9033, 9033, 9499], [9516, 9516, 9547, 9547, 10477], [10479, 10479, 10536, 10649, 11188]]}
{"id": "fdBSDG", "name": "viaje horizontal", "author": "jorge2017a1", "description": "viaje horizontal", "tags": ["viajehorizontal"], "likes": 3, "viewed": 200, "published": 3, "date": "1620874802", "time_retrieved": "2024-07-30T19:20:39.421452", "image_code": "\n//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n#define REFLECT 2\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\n\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\nvec2 path(float z)\n{\n    //float s=sin(z/34.)*cos(z/12.0)*cos( sin(z/20.0));\n    float s=sin(z/34.+z/25.0)*cos(z/12.0)*cos( sin(z/20.0));\n\treturn  vec2( s*12.+sin(s)*6.1,s*15.0 );\n}\n\n\n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n\t\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n  \n    vec2 yp=path(p.z);\n    planeDist1=planeDist1+ yp.y;\n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n          p.y=p.y-5.0;\n    float sds1= sdSphere( p+vec3(-10.0,yp.y,22.0-itime), 2.0 );\n    res =opU3(res, vec3(sds1,2.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{\n    float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {   mObj.hitbln = true; minDist = abs(t); break; }\n        \n        if(t>MAX_DIST)\n        { mObj.hitbln = false;    minDist = t;    break; } \n        \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n///============================================================\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ \n   \n    vec3 l = normalize(lp - p);\n    vec3 r = reflect(-l, n);\n    float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n    \n    return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{\n    vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n\n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n            \n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n    { fshadow=GetShadow(p,lp);}\n    else\n    {   fshadow=0.5; }\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    \n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n \n    return lin;\n}\n///============================================================\n\n\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 render_sky_color(vec3 rd)\n{\n    \n    float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    \n\tvec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    \n    return col;\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n}\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    \n     if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p ;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        p = (ro + rd * d );  \n         vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n   \n   return col;\n}\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,\n        1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c)\n    );\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*10.0,1000.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(5.0, 10.0, -10.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( -10.0, 30.0, -10.0 ); light_color2 =vec3( 1.0 ); \n   vec3 ro=vec3(0.0,5.0,-25.0+t);\n   ro.y-=path(ro.z).y;\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_y(rd, radians(90.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    \n    col = linear2srgb(col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBSDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[436, 436, 472, 472, 493], [496, 534, 570, 570, 615], [621, 686, 720, 720, 818], [819, 819, 853, 853, 945], [946, 946, 980, 980, 1072], [1073, 1113, 1147, 1147, 1244], [1247, 1247, 1267, 1323, 1428], [1432, 1472, 1497, 1497, 1904], [1906, 1957, 1981, 1981, 2169], [2172, 2172, 2221, 2221, 2874], [2876, 2963, 2999, 2999, 3246], [3313, 3313, 3340, 3340, 3357], [3359, 3359, 3395, 3395, 3487], [3488, 3488, 3534, 3534, 3679], [3681, 3681, 3755, 3755, 5333], [5400, 5434, 5514, 5514, 5646], [5647, 5688, 5720, 5720, 5926], [5929, 5977, 6005, 6005, 6200], [6201, 6252, 6299, 6299, 6530], [6585, 6585, 6678, 6678, 7022], [7024, 7024, 7055, 7055, 7657], [7658, 7707, 7733, 7733, 7857], [7860, 7909, 7966, 7966, 8577]]}
{"id": "7s2XRz", "name": "Distance to Circle Inverted Box", "author": "oneshade", "description": "Distance to a circle inverted box by converting its edges to circle segments. Has artifacts due to very extreme cases, WIP.", "tags": ["2d", "sdf", "circle", "box", "inverted", "arc"], "likes": 6, "viewed": 182, "published": 3, "date": "1620865855", "time_retrieved": "2024-07-30T19:20:40.180422", "image_code": "// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n// ax: vec2(cos(axis), sin(axis))\n// ap: vec2(cos(aperture), sin(aperture))\nfloat sdArc(in vec2 p, in vec2 ax, in vec2 ap, in float r) {\n    p = vec2(dot(p, ax), abs(p.y * ax.x - p.x * ax.y));\n    return p.y * ap.x < p.x * ap.y ? abs(length(p) - r) : length(p - ap * r);\n}\n\nfloat cInvSegment(in vec2 p, in vec2 a, in vec2 aInv, in vec2 b, in vec2 bInv) {\n    vec2 ba = b - a;\n\n    // The closest point on the line segment to the origin will invert the farthest away.\n    // Since the line stretches to infinity, its inversion will wrap around to the origin.\n    // The center is then halfway between the farthest point on the line's inversion and the origin.\n    // The radius is then the distance from a point on the line's inversion to the center.\n    vec2 cen = a - ba * dot(a, ba) / dot(ba, ba);\n    cen = 0.5 * cen / dot(cen, cen);\n    float rad = length(cen);\n\n    // The arc lies on one side of the line passing through the end points.\n    // Taking a point on the line's inversion (within the segment only) and projecting\n    // it onto the line passing through endpoints allows the direction in which the\n    // arc lies to be calculated.\n    vec2 far = 0.5 * (a + b), baInv = bInv - aInv;\n    far = far / dot(far, far);\n    vec2 faInv = far - aInv;\n    far = normalize(faInv - baInv * dot(faInv, baInv) / dot(baInv, baInv));\n\n    // Return distance to circle segment\n    aInv -= cen;\n    float ap = dot(aInv, far) / length(aInv);\n    return sdArc(p - cen, far, vec2(ap, sqrt(1.0 - ap * ap)), rad);\n}\n\n// Precomputes values and then combines the distance to each edge and the sign\nfloat sdCircleInvBox(in vec2 p, in mat3 t, in vec2 b, in float r) {\n    float rr = r * r;\n    p /= rr;\n\n    // Transform and invert through a circle\n    vec2 v1 = (vec3(-b,         1.0) * t).xy, v1Inv = v1 / dot(v1, v1);\n    vec2 v2 = (vec3( b.x, -b.y, 1.0) * t).xy, v2Inv = v2 / dot(v2, v2);\n    vec2 v3 = (vec3( b,         1.0) * t).xy, v3Inv = v3 / dot(v3, v3);\n    vec2 v4 = (vec3(-b.x,  b.y, 1.0) * t).xy, v4Inv = v4 / dot(v4, v4);\n\n    // Combine edges\n    float d =  cInvSegment(p, v1, v1Inv, v2, v2Inv);\n    d = min(d, cInvSegment(p, v2, v2Inv, v3, v3Inv));\n    d = min(d, cInvSegment(p, v3, v3Inv, v4, v4Inv));\n    d = min(d, cInvSegment(p, v4, v4Inv, v1, v1Inv));\n\n    // Get sign and return signed distance\n    p = abs((vec3(p / dot(p, p), 1.0) * inverse(t)).xy) - b;\n    return d * rr * sign(max(p.x, p.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse.xy = vec2(cos(iTime), sin(iTime)) * 0.75;\n\n    vec2 a = mouse.xy;\n    vec2 b = mouse.zw;\n    float r = 1.0;\n\n    float cInvBox = sdCircleInvBox(uv, mat3(1.0, 0.0, mouse.x, 0.0, 1.0, mouse.y, 0.0, 0.0, 1.0), vec2(0.25), r) * 0.5;\n    if (mod(iTime * 0.5, 2.0) < 1.0) cInvBox = sdBox(uv * r * r / dot(uv, uv) - mouse.xy, vec2(0.25));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(cInvBox) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(cInvBox));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * cInvBox);\n    color = mix(color, vec3(0.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, abs(cInvBox)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2XRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 102, 137, 137, 217], [219, 295, 355, 355, 491], [493, 493, 573, 573, 1728], [1730, 1809, 1876, 1876, 2630], [2632, 2632, 2687, 2706, 3603]]}
{"id": "fdSSWG", "name": "Animated Random Population", "author": "pyBlob", "description": "Beautiful random noise caused by mutations in growing cells.\n\nclick+drag: punch holes\nR: reset", "tags": ["mouse", "random", "cellular", "automaton"], "likes": 15, "viewed": 371, "published": 3, "date": "1620862515", "time_retrieved": "2024-07-30T19:20:40.990257", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (fragColor != vec4(0))\n    {\n        fragColor.x = .5 + .5 * sin(fragColor.x * 3. + iTime * .2 + fragColor.w * -1e-3 - .3);\n        fragColor.y = .5 + .5 * sin(fragColor.y * 3. + iTime * .2 + fragColor.w * -7e-3 + .5);\n        fragColor.z = .5 + .5 * sin(fragColor.z * 3. + iTime * .2 + fragColor.w * -3e-3 + .9);\n        fragColor.w = 1.;\n    }\n    if (iMouse.z >= .0)\n    \tif (length(fragCoord - abs(iMouse.zw)) < length(iMouse.xy - abs(iMouse.zw)))\n    \t\tfragColor = mix(fragColor, vec4(.3), .5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// https://www.shadertoy.com/view/4djSRW\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvoid test(inout vec4 id, ivec2 x)\n{\n    if (x == ivec2(0))\n        return;\n    if (id != vec4(0))\n        return;\n    vec4 next = texelFetch(iChannel0, x, 0);\n    if (next == vec4(0))\n        return;\n    vec3 pos = vec3(x,iTime);\n    vec4 blob = hash43(pos);\n    if (blob.w > 3e-1)\n        return;\n    vec3 delta = .1 * (blob.xyz - .5);\n    id = vec4(next.xyz + delta, next.w + 1.);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(82, 1), 0).x>0.)\n    {\n        ivec2 xy = ivec2(fragCoord.xy) - ivec2(iResolution.xy/2.);\n        fragColor = vec4(0);\n        if (xy == ivec2(0,0))\n            fragColor = vec4(0, 0, 0, 1e-3);\n        return;\n    }\n    ivec2 x = ivec2(fragCoord);\n    if (x == ivec2(0))\n    {\n        fragColor = iMouse;\n        return;\n    }\n    vec4 id = texelFetch(iChannel0, x, 0);\n    test(id, x+ivec2(0, 1));\n    test(id, x+ivec2(1, 0));\n    test(id, x-ivec2(0, 1));\n    test(id, x-ivec2(1, 0));\n    fragColor = id;\n    vec4 lastMouse = texelFetch(iChannel0, ivec2(0), 0);\n    if (lastMouse.z >= .0 && iMouse.z < .0)\n        if (length(fragCoord - abs(lastMouse.zw)) < length(lastMouse.xy - abs(lastMouse.zw)))\n            fragColor = vec4(0);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSSWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 624]]}
{"id": "Nd2Xzd", "name": "Void Sun", "author": "R3N", "description": "Now with no aliasing artifacts", "tags": ["abstract"], "likes": 2, "viewed": 269, "published": 3, "date": "1620859978", "time_retrieved": "2024-07-30T19:20:41.750225", "image_code": "float sun(vec2 p, float t){\n    float a = atan(p.x, p.y)-t/50.0;\n    return 0.03/length(p*sin(a*11.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tc = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uvc = uv - vec2(iResolution.x/iResolution.y, 1.0)/2.0;\n    vec2 nuv = vec2(iResolution.x/iResolution.y, 1.0) - uv;\n    float t = iTime/3.0;\n    vec2 gn = iResolution.xy/4.0;\n    vec2 guv = fract(tc*gn);\n    vec2 gid = floor(tc*gn);\n    vec2 p1 = uvc + vec2(sin(t/3.0), cos(t/3.0+sin(t)))/3.0;\n    vec2 p2 = uvc + vec2(cos(t/3.0), sin(-t/3.0+cos(t)))/3.0;\n    float d = sin(uv.y*10.0+t)*sin(t)*0.1;\n    nuv.x += d;\n    float c = (2.0*mix(0.0, sun(p2, t)*mix(100.0, 300.0, smoothstep(-1.0, 1.0, sin(iTime))), fract(smoothstep(0.0, sun(p1, t), .5*sun(nuv, 0.0)))*(1.0/length(guv-0.5)/100.0)));\n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2Xzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 105], [108, 108, 165, 165, 871]]}
{"id": "7s2XRd", "name": "Fork  fractal  NikolaErceg", "author": "NikolaErceg", "description": "Creating multiple shapes with one SDF evaluation by repeatedly rotating and folding space", "tags": ["fractalcineshader"], "likes": 1, "viewed": 6107, "published": 3, "date": "1620851580", "time_retrieved": "2024-07-30T19:20:42.502214", "image_code": "vec3 palette(float d){\n\treturn mix(vec3(2.3,2.42,2.24),vec3(.0,0.31,1.2),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<5; ++i){\n        float t = iTime*1.0;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*0.001);\n        p.xz = abs(p.xz);\n        p.xz-=0.24;\n\t}\n\treturn dot(sign(p),p)/13.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 3.;\n    vec3 col = vec3(0.01);\n    float d;\n    for(float i =0.; i<86.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*.86;\n        if(d<0.18){\n            break;\n        }\n        if(d>55.){\n        \tbreak;\n        }\n        //col+=vec3(1.6,3.8,3.8)/(100.*(d));\n        col+=palette(length(p)*.1)/(222.*(d));\n        t+=d;\n    }\n    return vec4(col,0./(d*10.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(41.,41.,-0.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(55,3.,57.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2XRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 78], [80, 80, 108, 108, 180], [182, 182, 200, 200, 405], [407, 407, 434, 434, 813], [814, 814, 871, 871, 1268]]}
{"id": "7s2SRd", "name": "Cigar at night", "author": "Daizuukee", "description": "A man smoking a cigar in the nightsky.\nA lot of things here are quite hacky this is more of a test to recreate a drawing as ashader.", "tags": ["sky", "night", "smoke", "human", "cigar", "sillouhette"], "likes": 7, "viewed": 398, "published": 3, "date": "1620849702", "time_retrieved": "2024-07-30T19:20:43.264177", "image_code": "#define Cig1 vec3(0.4, 0.2902, 0.2196)\n#define Cig2 vec3(0.8588, 0.7882, 0.7686)\n#define Light1 vec3(0.902, 0.4941, 0.3843)\n#define Light2 vec3(0.7686, 0.5843, 0.0863)\n#define PIXELSIZE 100.\n\n//#define LSD\n\n#define CRT\n\n\n#define CLCOL ((Light1 - Light2) * abs(max(cos(iTime * 2. * PI),sin(iTime * 2. * PI))) + Light2)\n#define PI_TWO\t\t\t1.570796326794897\n#define PI\t\t\t\t3.141592653589793\n#define TWO_PI\t\t\t6.283185307179586\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\n//https://www.shadertoy.com/view/MtcGRl\nvec2 GetGradient(vec2 intPos, float t) {\n    \n    // Uncomment for calculated rand\n    //float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    // Texture-based rand (a bit faster on my GPU)\n    float rand = hash(intPos / 64.0).r;\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\n\n\nvec2 uv;\n\n\nbool Smoke( in vec2 p) {\n    p -= vec2(0.2,0.1);\n    p.x += sin(p.y * 20. - iTime * PI) * p.y / 2. * pow(abs(sin(iTime * 0.25 * PI)),0.5);\n    if(p.x - 0.005 < p.y && p.x + 0.0025 >= p.y * 0.75 && p.x > 0.)\n        return true;\n    return false;\n}\n\nvec3 Cigar( in vec2 p) {\n    vec3 shade = vec3(0.4,0.3,0.2) * (1. - (p.y - 0.08) * (1./0.08) * 2.);\n    if(p.y > 0.08 && p.y < 0.1 && p.x > 0. && p.x < 0.2) {\n        if(p.x < 0.05)\n            return Cig1 - shade;\n        if(p.x < 0.18)\n            return Cig2 - shade;\n        return CLCOL;\n    }\n    return vec3(0);\n}\n\nfloat FaceDist(in vec2 p) {\n    float f = -0.3;\n    //HEAD\n    float po = abs(p.y - 0.225) * 2.;\n    f += (0.1 - po*po*po*po*po) * 3.;\n    //HAT\n    if(p.y > 0.3) {\n        po = (0.4-p.y)*3.25;\n        f = smax(f,po*po*po - 0.075,-0.2) + 0.05;\n    }\n    //EYE HOLE\n    f = smin(f,abs(p.y - 0.25),0.15);\n    //NOSE\n    f = smax(f, 0.02-abs(p.y - 0.175),-0.2);\n    //MOUTH\n    f = smax(f, 0.01-abs(p.y - 0.11),-0.2);\n    f = smax(f, 0.01-abs(p.y - 0.09),-0.2);\n    //SHOULDERS\n    f = smax(f, 0.02-abs(p.y + 0.2),0.1);\n    return f - p.x;\n}\n\nfloat star( in vec2 p) {\n    float x = Pseudo3dNoise(vec3(p * PIXELSIZE / 2.,iTime));\n    if(x > 0.75)\n        return (x-0.75) * (1./0.75); \n    return 0.;\n}\n\nvec3 getColor( in vec2 p) {\n    float smok = 0.;\n    if(Smoke(p))\n        smok = max(0.,0.6 - length(p));\n    vec3 c;\n    if((c = Cigar(p)) != vec3(0)) \n        return vec3(c);\n    float face = FaceDist(p);\n    if(face > 0.)\n        return CLCOL * (0.1 - face);\n\n    float star = star(p);\n    return CLCOL * max(0.2 - distance(p,vec2(0.2,0.09)),0.) + smok + star;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.yy;\n    uv.x -= 0.25;\n    uv.y -= 0.1;\n#ifdef CRT\n    if(uv.y > (0.75-fract(iTime * 0.1)) * 1.5 && uv.y < (0.75-fract(iTime * 0.1)) * 1.5 + 0.05) {\n        uv.y = (0.75-fract(iTime * 0.1)) * 1.5 + 0.05;\n    }\n#endif\n#ifdef LSD\n    fragColor = vec4(getColor(floor(uv * PIXELSIZE) / PIXELSIZE).r,\n                     getColor(floor((uv + vec2(0.01) * sin(iTime * PI)) * PIXELSIZE) / PIXELSIZE).g,\n                     getColor(floor((uv + vec2(-0.01,sin(iTime * PI) * 0.01) * sin(iTime * PI * 1.5432)) * PIXELSIZE) / PIXELSIZE).b,\n                     1);\n#else\n#ifdef CRT\n    fragColor = vec4(getColor(floor((uv + vec2(0.0,0.116) / PIXELSIZE) * PIXELSIZE) / PIXELSIZE).r,\n                     getColor(floor((uv + vec2(0.116,-0.116) / PIXELSIZE) * PIXELSIZE) / PIXELSIZE).g,\n                     getColor(floor((uv + vec2(-0.116,-0.116) / PIXELSIZE) * PIXELSIZE) / PIXELSIZE).b,\n                     1);\n#else\n    fragColor = vec4(getColor(floor(uv * PIXELSIZE) / PIXELSIZE),1);\n#endif\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2SRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 462, 503, 503, 575], [577, 617, 658, 658, 749], [751, 751, 772, 797, 919], [921, 961, 1001, 1180, 1391], [1394, 1394, 1425, 1425, 2015], [2030, 2030, 2054, 2054, 2277], [2279, 2279, 2303, 2303, 2599], [2601, 2601, 2628, 2628, 3139], [3141, 3141, 3165, 3165, 3298], [3300, 3300, 3327, 3327, 3665], [3667, 3667, 3721, 3721, 4752]]}
{"id": "sd2Szt", "name": "Alternating grid test", "author": "aferriss", "description": "Alternating test", "tags": ["grid"], "likes": 2, "viewed": 350, "published": 3, "date": "1620844248", "time_retrieved": "2024-07-30T19:20:44.017164", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float cells = 6.0;\n    vec2 grid0 = fract(uv * cells);\n    vec2 grid1 = fract(vec2(1.0 - uv.x, uv.y) * cells);\n    \n    float everyOther = mod( floor(uv.x * cells) + floor(uv.y * cells), 2.0);\n    \n    \n    vec2 coord = grid0 * everyOther + grid1 * (1.0-everyOther);\n\n    fragColor = texture(iChannel0, coord);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2Szt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 414]]}
{"id": "7djSzt", "name": "Alternating grid", "author": "aferriss", "description": "Alternating test", "tags": ["grid"], "likes": 3, "viewed": 314, "published": 3, "date": "1620844125", "time_retrieved": "2024-07-30T19:20:44.787105", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float cells = 4.0;\n    vec2 grid0 = fract(uv * cells);\n    vec2 grid1 = fract(vec2(1.0 - uv.x, uv.y) * cells);\n    \n    float everyOther = mod( floor(uv.x * cells) + floor(uv.y * cells), 2.0);\n    \n    \n    vec2 coord = grid0 * everyOther + grid1 * (1.0-everyOther);\n\n    fragColor = texture(iChannel0, coord);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djSzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 465]]}
{"id": "7sjSRt", "name": "round bang", "author": "spectrum", "description": "more bang", "tags": ["circular", "bang"], "likes": 3, "viewed": 369, "published": 3, "date": "1620836665", "time_retrieved": "2024-07-30T19:20:45.549068", "image_code": "vec2 hash12(float t) {\n    float x = fract(sin(t*674.31)*432.1)*6.2384;\n    float y = fract(sin(t*472.1)*201.9);\n    return vec2(sin(x), cos(x))*y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n\n    float t = iTime * 4.;\n    \n    float dt = 0.;\n    \n\n    for (float i=600.; i>0.; i--) {\n        float brightness = .0001*(sin((i*3.)+t)+3.);\n        vec2 dir = hash12(i+1.)*2.;\n        float tt = fract(iTime*.2)*10.;\n        dt = length(uv-dir*tt);\n        color += brightness/dt;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 149], [151, 151, 208, 208, 622]]}
{"id": "sdjSRt", "name": "bang", "author": "spectrum", "description": "particle bang", "tags": ["star"], "likes": 2, "viewed": 312, "published": 3, "date": "1620834973", "time_retrieved": "2024-07-30T19:20:46.300060", "image_code": "vec2 hash12(float t) {\n    float x = fract(sin(t*674.31)*432.1);\n    float y = fract(sin(t*472.1)*201.9);\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n\n    float t = iTime * 10.;\n    float brightness = .0001*(sin(t)+3.);\n    \n    float dt = 0.;\n    \n\n    for (float i=200.; i>0.; i--) {\n        vec2 dir = hash12(i)-.5;\n        float tt = fract(iTime*.3)*10.;\n        dt = length(uv-dir*tt);\n        color += brightness/dt;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjSRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 130], [132, 132, 189, 189, 590]]}
{"id": "ssSXzt", "name": "等宽曲线", "author": "shiyuelai", "description": "等宽曲线", "tags": [], "likes": 0, "viewed": 255, "published": 3, "date": "1620802618", "time_retrieved": "2024-07-30T19:20:47.063020", "image_code": "float PI = 3.1415926;\n\nfloat f(float x1, float y1, float x)\n{\n   return y1 - sin(x) + (x1 - x) / cos(x);\n}\n\nfloat df(float x1, float x)\n{\n   return -cos(x) + ((x1 - x) * sin(x) - cos(x)) / (cos(x) * cos(x));\n}\n\nfloat ddf(float x1, float x)\n{\n   return sin(x) + ((x1 - x) * cos(x) - 2.0 * sin(x)) / (cos(x) * cos(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // 黑色背景\n    fragColor = vec4(0.0);\n    float x = uv.x * 32.0 * iResolution.x / iResolution.y;\n    x = x +  iTime * 2.0;\n    float width = 0.4;\n    \n    \n    // 导数分析法\n    vec4 color = vec4(1.0, 0.5, 0.5, 1.0);\n    float y = (uv.y - 0.1667) * 16.0;\n    float h = width * 0.65 / cos(atan(cos(x)));\n    float dis = abs(sin(x) - y);\n    if(dis < h)\n    {\n       float alpha = smoothstep(h, h - 0.03, dis);\n       fragColor = mix(fragColor, color, alpha);\n    }\n    \n    \n    width = 0.7;\n    // 牛顿迭代法 画sin曲线\n    color = vec4(0.5, 1.0, 0.5, 1.0);\n    y = (uv.y - 0.5) * 16.0;\n    float xk = x;\n    for(int k = 0; k < 2; k++)\n    {\n       xk= xk - f(x, y, xk) / df(x, xk);\n    \n    }\n    float sin_x = xk;\n    float sin_y = sin(xk);\n    dis = length(vec2(x - sin_x, y - sin_y)); \n    if((1.0 - dis) > width)\n    {\n       float alpha = smoothstep(1.0 - width, 0.97 - width, dis);\n       fragColor = mix(fragColor, color, alpha);\n    }\n    \n    \n    // 切比雪夫迭代法\n    color = vec4(0.5, 0.5, 1.0, 1.0);\n    y = (uv.y - 0.8334) * 16.0;\n    xk = x;\n    for(int k = 0; k < 4; k++)\n    {\n       float ff = f(x, y, xk);\n       xk= xk - ff / df(x, xk);\n       xk = xk - ddf(x, xk) * ff * ff / (2.0 * pow(df(x, xk), 3.0)) ;\n    \n    }\n    sin_x = xk;\n    sin_y = sin(xk);\n    dis = length(vec2(x - sin_x, y - sin_y)); \n    if(dis < 1.0 - width)\n    {\n       float alpha = smoothstep(1.0 - width, 0.97 - width, dis);\n       fragColor = mix(fragColor, color, alpha);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 61, 61, 106], [108, 108, 137, 137, 209], [211, 211, 241, 241, 318], [320, 320, 377, 427, 1977]]}
{"id": "sdSXzt", "name": "Forest-bosque- v2", "author": "jorge2017a1", "description": "Forest-bosque- v2", "tags": ["2d", "draw", "poly", "forestbosquev2"], "likes": 3, "viewed": 262, "published": 3, "date": "1620787785", "time_retrieved": "2024-07-30T19:20:47.883826", "image_code": "//por jorge2017a1 ----jorgeFloresP---11/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\nconst vec3 colVerde=vec3(0.0,1.0,0.0);\nconst vec3 colVerde2=vec3(0.1,0.8,0.1);\nconst vec3 colrojoObs=vec3(0.45,0.13,0.15); //rojo obscuro\n\nconst vec3 col1=vec3(0.54,0.49,0.39);\nconst vec3 col2=vec3(0.06,0.07,1.0);\nconst vec3 col3=vec3(0.06,0.07,0.8);\n//const vec3 col4=vec3(0.45,0.13,0.15); //rojo obscuro\nconst vec3 col4=vec3(0.60,0.17,0.17); //vestido\nconst vec3 col5=vec3(0.73,0.60,0.55);\nconst vec3 colDorado=vec3(0.925,0.67,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPoly15 POLY(15)\nvec2 pt15[ 15]=vec2[](  \nvec2(.10,.65),vec2(.10,.54),vec2(.10,.54),vec2(.10,.54),vec2(.13,.53),\nvec2(.13,.64),vec2(.15,.67),vec2(.14,.68),vec2(.12,.65),vec2(.12,.69),\nvec2(.11,.69),vec2(.11,.66),vec2(.08,.68),vec2(.08,.67),vec2(.10,.65) );\n\nfloat sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.07,.66),vec2(.04,.67),vec2(.01,.73),vec2(.01,.80),vec2(.06,.86),\nvec2(.16,.84),vec2(.20,.75),vec2(.20,.69),vec2(.17,.66),vec2(.14,.66),\nvec2(.07,.66) );\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.09,.38),vec2(.12,.42),vec2(.15,.41),vec2(.17,.43),vec2(.20,.46),\nvec2(.22,.44),vec2(.24,.42),vec2(.27,.40),vec2(.28,.38),vec2(.09,.38) );\n\n\nfloat sdPoly32 POLY(32)\nvec2 pt32[ 32]=vec2[](  \nvec2(.15,.09),vec2(.15,.19),vec2(.10,.22),vec2(.06,.26),vec2(.04,.28),\nvec2(.06,.28),vec2(.09,.24),vec2(.12,.22),vec2(.15,.21),vec2(.17,.24),\nvec2(.20,.26),vec2(.22,.27),vec2(.23,.28),vec2(.24,.27),vec2(.18,.23),\nvec2(.17,.21),vec2(.17,.21),vec2(.19,.21),vec2(.21,.22),vec2(.24,.23),\nvec2(.24,.22),vec2(.23,.21),vec2(.19,.20),vec2(.17,.19),vec2(.17,.17),\nvec2(.17,.15),vec2(.18,.15),vec2(.19,.16),vec2(.19,.15),vec2(.17,.14),\nvec2(.17,.10),vec2(.15,.09) );\n\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.00,.53),vec2(.00,.62),vec2(.18,.85),vec2(.26,.81),vec2(.31,.70),\nvec2(.38,.54),vec2(.00,.53) );\n\nfloat sdPoly11b POLY(11)\nvec2 pt11b[11]=vec2[](  \nvec2(.24,.54),vec2(.34,.74),vec2(.41,.82),vec2(.46,.89),vec2(.51,.89),\nvec2(.53,.86),vec2(.54,.77),vec2(.59,.73),vec2(.65,.65),vec2(.67,.54),\nvec2(.24,.54) );\n\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.60,.53),vec2(.67,.59),vec2(.74,.62),vec2(.76,.65),vec2(.81,.63),\nvec2(.84,.60),vec2(.87,.56),vec2(.90,.54),vec2(.60,.53) );\n\n\nfloat sdPoly11c POLY(11)\nvec2 pt11c[ 11]=vec2[](  \nvec2(.48,.53),vec2(.60,.70),vec2(.68,.77),vec2(.71,.77),vec2(.78,.82),\nvec2(.81,.84),vec2(.85,.78),vec2(.89,.71),vec2(.93,.67),vec2(.97,.54),\nvec2(.48,.53) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.41,.18),vec2(.40,.28),vec2(.53,.32),vec2(.54,.18),vec2(.41,.18) );\n\nfloat sdPoly5b POLY(5)\nvec2 pt5b[ 5]=vec2[](  \nvec2(.46,.18),vec2(.46,.26),vec2(.49,.26),vec2(.50,.18),vec2(.46,.18) );\n\n\nfloat sdPoly10b POLY(10)\nvec2 pt10b[ 10]=vec2[](  \nvec2(.43,.29),vec2(.42,.33),vec2(.40,.33),vec2(.40,.35),vec2(.44,.35),\nvec2(.45,.35),vec2(.46,.33),vec2(.44,.33),vec2(.44,.29),vec2(.43,.29) );\n\n\nfloat sdPoly11d POLY(11)\nvec2 pt11d[ 11]=vec2[](  \nvec2(.74,.17),vec2(.74,.22),vec2(.76,.24),vec2(.77,.27),vec2(.77,.30),\nvec2(.77,.30),vec2(.77,.27),vec2(.76,.24),vec2(.75,.22),vec2(.74,.17),\nvec2(.74,.17) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.74,.17),vec2(.74,.22),vec2(.71,.25),vec2(.70,.30),vec2(.71,.30),\nvec2(.72,.25),vec2(.75,.22),vec2(.74,.17),vec2(.74,.17) );\n\nfloat sdPoly15b POLY(15)\nvec2 pt15b[ 15]=vec2[](  \nvec2(.75,.97),vec2(.71,.96),vec2(.69,.94),vec2(.65,.93),vec2(.63,.90),\nvec2(.69,.88),vec2(.78,.89),vec2(.82,.90),vec2(.86,.88),vec2(.86,.93),\nvec2(.84,.94),vec2(.80,.94),vec2(.78,.96),vec2(.77,.97),vec2(.75,.97) );\n\n///------------*******-------------------\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\n\n//***------------****-----------****------------******-------\nvec3 Bosque2(in vec2 pp, vec3 col) \n{\n  vec2 p=pp,pr1=pp, pr2=pp;\n   pr1.x= opRep1D(pr1.x, 0.4 ); pr1.y-=0.04;\n   pr2.x= opRep1D(pr2.x, 0.7 ); pr2.y+=0.04;\n   \n   float i = floor(p.x);  // integer\n    float f = fract(p.x);  // fraction\n    float y1 = rand(i)*0.005;\n    float y2 = rand(f)*0.005;\n\n   float sd15 = sdPoly15(p, pt15);\n   float sd11 = sdPoly11(p, pt11);\n   float sd10 = sdPoly10(p-vec2(0.1,0.0), pt10);\n   float sd32 = sdPoly32(p, pt32);\n   float sd7 = sdPoly7(p-vec2(-0.3,0.2), pt7); //montaña\n    float sd11b = sdPoly11b(p-vec2(-0.1,0.0), pt11b); //montaña\n    float sd9 = sdPoly9(p-vec2(0.3,0.3), pt9);\n    float sd11c = sdPoly11c(p, pt11c);\n    float sd5 = sdPoly5(p, pt5);\n    float sd5b = sdPoly5b(p, pt5b);\n    float sd10b = sdPoly10b(p, pt10b);\n    \n    float sd11d = sdPoly11d(p, pt11d);\n    float sd9b = sdPoly9b(p, pt9b);\n    float sd15b = sdPoly15b(p, pt15b);\n    col=ponerBorde(col1,col,sd7 ); //montaña n3\n    col=ponerBorde(col5,col,sd11c );\n    col=ponerBorde(colVerde2,col,sd11 ); //ramas arbol\n    col=ponerBorde(colrojoObs,col,sd15 ); //tronco\n    col=ponerBorde(col1,col,sd10 );  //piedra chica\n    col=ponerBorde(col4,col,sd32 ); //tronco seco\n    col=ponerBorde(col4,col,sd11b ); //montaña n2\n    col=ponerBorde(col4,col,sd9 );  //piedra chica n2\n    col=ponerBorde(col1,col,sd5 ); //casa\n    col=ponerBorde(col4,col,sd5b ); //puerta\n    col=ponerBorde(col4,col,sd10b ); //chimenea\n    col=ponerBorde(col1,col,sd11d );\n    col=ponerBorde(col4,col,sd9b ); //arboito seco\n    col=ponerBorde(col2,col,sd15b );// nube\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.25;\n    vec2 p=uv*0.5-vec2(-0.5,-0.5);\n    vec3 col=vec3(0.15,0.6,0.3); //vec3(0.25);\n    vec2 p2=p+vec2(0.0,3.5);\n    float tt=t;\n    p.y= opRep1D(p.y+tt, 2.2 );\n    p2.y= opRep1D(p2.y+tt, 2.2 );\n    col=Bosque2(p, col);\n    col=Bosque2(p2, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSXzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 343, 379, 379, 424], [430, 430, 465, 465, 489], [491, 491, 551, 551, 675], [677, 677, 708, 708, 729], [4735, 4777, 4797, 4797, 4864], [4866, 4866, 4886, 4886, 4924], [4927, 4989, 5026, 5026, 6557], [6559, 6559, 6616, 6616, 7014]]}
{"id": "sdBXRt", "name": "sine distance estimator", "author": "michael0884", "description": "huh", "tags": ["sdf", "sine", "de", "huh"], "likes": 9, "viewed": 563, "published": 3, "date": "1620783003", "time_retrieved": "2024-07-30T19:20:48.729565", "image_code": "const float pi = 3.141592653;\nconst float fudgefactor = 0.6; //probably a better parameter exists \n\nfloat sinline(in vec2 p)\n{\n    p.x = p.x + pi*0.5; \n    p.y *= ((int(p.x/pi)%2 == 0)?1.0:-1.0)*sign(p.x);//reflection stuff\n    p.x = mod(p.x, pi) - pi*0.5; //repeat half periods\n    float e0 = sin(p.x) - p.y; //first estimate \n    float x1 = mix(p.x,-pi*0.5*sign(e0),abs(tanh(fudgefactor*e0/pi)));//update closest point estimate by hand\n    return 0.92*distance(p, vec2(x1, sin(x1))); //distance\n}\n\nfloat sdSphere(vec2 p, float R)\n{\n    return length(p) - R;\n}\n\nvoid mainImage( out vec4 C, in vec2 X )\n{\n    vec2 uv = 5.0*(X - iResolution.xy*0.5)/iResolution.y; \n    vec2 m = 5.0*(iMouse.xy - iResolution.xy*0.5)/iResolution.y;\n    \n    float sd = sinline(uv);\n    \n    float sdm = sinline(m);\n    \n    float l0 = smoothstep(0.02, 0.0, abs(sd)); \n    float l1 = smoothstep(0.02, 0.0, abs(sdSphere(uv - m, sdm))); \n\n    vec3 col = (cos(sd*100.0)*0.25 + 0.7)/(1.0 +25.0*sd*vec3(0.792,0.3,0.098));\n    // Output to screen\n    C = vec4(mix(col, vec3(1),max(l1,l0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBXRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[500, 500, 533, 533, 561], [563, 563, 604, 604, 1069]]}
{"id": "NsBXRd", "name": "Web Grid", "author": "R3N", "description": "A Ray Marching shader. The color brightness corresponds with the number of steps of the ray marcher.", "tags": ["3d", "raymarching"], "likes": 5, "viewed": 326, "published": 3, "date": "1620763241", "time_retrieved": "2024-07-30T19:20:49.483549", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 1000.0\n#define MIN_DIST 0.01\n\n// 2D matrix rotation\nvec2 rot(vec2 p, float a) {\n\treturn (p * mat2(cos(a), -sin(a), sin(a), cos(a)));\n}\n\n// Hexagon SDF by iq\nfloat Hexagon(vec2 p, float r) {\n\tconst vec3 k = vec3(-0.866025404,0.5,0.577350269);\n\tp = abs(p);\n\tp -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n\tp -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n\treturn length(p)*sign(p.y);\n}\n\n// SDFs of the objects in the scene\nfloat Dist(vec3 point) {\n\t// Strand 1\n\tvec2 sqp1 = mod(abs(point.xz), 20.0)-vec2(10, 10);\n\tsqp1 = rot(sqp1, point.y/2.0) + 0.3;\n\tfloat c1 = Hexagon(sqp1, 1.0);\n\t// Strand 2\n\tvec2 sqp2 = mod(abs(point.yz+10.0), 20.0)-vec2(10, 10);\n\tsqp2 = rot(sqp2, point.x/4.0) + 0.3;\n\tfloat c2 = Hexagon(sqp2, 1.0);\n\t// Strand 3\n\tvec2 sqp3 = mod(abs(point.xy+vec2(10,0)), 20.0)-vec2(10, 10);\n\tsqp3 = rot(sqp3, point.z/4.0) + 0.3;\n\tfloat c3 = Hexagon(sqp3, 1.0);\n\treturn min(min(c1,c2),c3);\n}\n\nvec2 RayMarch (vec3 cameraOrigin, vec3 rayDirection) {\n\tfloat minDist = 0.0;\n\tint steps = 0;\n\twhile (steps < MAX_STEPS) {\n\t\tvec3 point = cameraOrigin + rayDirection * minDist;\n\t\tfloat dist = Dist(point);\n\t\tminDist += dist;\n\t\tif (dist < MIN_DIST || abs(minDist) > MAX_DIST) {\n\t\t\tbreak;\n\t\t}\n\t\tsteps++;\n\t}\n\treturn vec2(minDist, steps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/(iResolution.y);\n\tuv -= vec2(iResolution.x/iResolution.y/2.0, 0.5);\n\tvec3 cameraPosition = vec3(0, 5.0, 0);\n\tcameraPosition.xy = rot(cameraPosition.xy, 0.0);\n\tcameraPosition.z += iTime*10.0;\n\tcameraPosition.x += iTime*4.0;\n\tcameraPosition.y += 10.0;\n\tvec3 ray = normalize(vec3(uv.x,uv.y, 0.5));\n\tray.xz = rot(ray.xz, iTime/5.0);\n\tray.xy = rot(ray.xy, -iTime/5.0);\n\tvec2 march = RayMarch(cameraPosition, ray);\n\tvec3 rayPoint = cameraPosition + march.x * ray;\n\tvec3 col = mix(vec3(0), mix(vec3(0.9, 0.5, 0.6), vec3(0.5, 0.5, 1.0), sin(iTime/10.0)*0.5+0.5),march.y/50.0);\n\t//vec3 col = mix(vec3(0), mix(vec3(0.9, 0.5, 0.6), vec3(0.5, 0.5, 1.0), sin(iTime/10.0)*0.5+0.5),1.-march.y/50.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 91, 118, 118, 173], [175, 196, 228, 228, 403], [405, 441, 465, 478, 916], [918, 918, 972, 972, 1252], [1254, 1254, 1311, 1311, 2053]]}
{"id": "NsSSDW", "name": "3D Turing Texture", "author": "Shane", "description": "Constructing and applying a repeat 3D Turing pattern using a custom filtering method.", "tags": ["3d", "dof", "diffusion", "turing"], "likes": 66, "viewed": 1224, "published": 3, "date": "1620736258", "time_retrieved": "2024-07-30T19:20:50.422039", "image_code": "/*\n\n    3D Turing Texture\n    -----------------\n\n    Constructing and applying a repeat 3D Turing pattern: Diffusion patterns are \n    nothing new, but I couldn't find any 3D wrappable ones, so I've put this up \n    as a reference. It's based on something I did years ago.\n    \n    There are a couple of things I needed to overcome before presenting it in\n    shader form. The main one was that diffusion patterns take a while to create, \n    and people get bored very quickly... OK, I mean, I get bored very quickly. :D\n    To get around this, I skipped over the usual dual concentration approach, and\n    took a custom filtered approach, which forms patterns much faster. Unfortunately, \n    the initial precalculation can be a little intensive, so I hid it behind an \n    oldschool waiting screen -- similar to the ones that people used to use in old \n    demos.\n    \n    It was also necessary to render the Turing pattern efficiently in realtime,\n    which meant it had to be relatively fast and smooth. Smooth rendering usually \n    requires eight texel reads per pass, which is a little slow. One unfiltered \n    texture read is fast, but not visually acceptable. I got around the problem by \n    storing four neighbor values in adjoining buffer channels, which meant only two \n    texel reads per pass. The problem with the dual concentrated solution diffusion \n    appraoch is that twice as many storage slots are required, which in turn requires \n    twice the reads at half the resolution. However, the filtered noise approach \n    that I've used bypasses that -- By the way, I have yet another filtering method \n    that is much nicer that I'll demonstrate in due course.\n    \n    The structure itself is just a few layers of transcendentals combined to make\n    something that looks geometric and natural at the same time. By warping the \n    structure, you can make it look more organic, but I wanted to keep it simple.\n \n    Anyway, the pattern here is only bump mapped, but it is fast enough to be used\n    via the distance function. I've applied a basic depth of field effect to round \n    things out. I have a few more traditional looking 3D Turing pattern surfaces \n    that I'll release a little later on.\n    \n    \n    \n    // Other examples:\n    \n    // I love this one.\n    3D diffusion limited aggregation - Mattz\n    https://www.shadertoy.com/view/XtSfRz\n    \n    // 2D, but really nice. Wyatt has heaps of diffusion (2D and 3D) related \n    // examples on here that are worth looking through.\n    Symbiosis - Wyatt\n    https://www.shadertoy.com/view/WssXW2\n    \n    \n*/\n\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 12 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 12., coc = 5.;\n    // Linear distance from either side of the focal point.\n    float l = abs(focD - texture(iCh, uv).w);\n    // Using it to calculate the DOF.\n    vec2 dof = clamp((l - coc)/(2.*coc), 0., 1.)/vec2(800, 450)*2.5; \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<49; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/7, i%7) - 3.)*dof).xyz;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 49.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n\n// This would normally be a very quick routine that displays\n// the scene and gives it a distance of field effect, but I \n// wanted to put in a little loading bar graphic just to let\n// people know that some precalculation is happening in the \n// background... and to give impatient people like me a visual \n// representation of the time it's going to take. :D\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    \n    \n    int tFrame = iFrame - frame0;\n    if(tFrame<300){\n    \n        // Precalculating and producing the Turing pattern can take \n        // a few seconds, so rather than present a stuttering mess to \n        // the user, I put together an oldschool demoscene waiting\n        // screen graphic... I was in a hurry, so the logic could be\n        // better, but it does the job.\n        \n        \n        vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n        float sf = 1./iResolution.y;\n        \n        float l = float(tFrame - 1)/300.*300./299.;\n        //l = floor(l*31.999)/31.;\n        float x = uv.x;//floor(uv.x*15.999)/15.;\n        \n        float back = max(abs(uv.x) - .25, abs(uv.y) - .02);\n        vec3 col = mix(vec3(0), vec3(1), 1. - smoothstep(0., sf, back - .01));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf*2., back - .005));\n        \n        uv = uv + vec2(.25*(1. - l), 0);\n        float bar = max(abs(uv.x) - .25*l, abs(uv.y) - .02);\n        \n        vec3 bCol = .5 + .5*cos(6.2831*x*.5 + vec3(0, 1, 2) + 4.);\n        bCol *= max((uv.y + .01)/.015, 0.) + .25;\n        \n        col = mix(col, bCol, 1. - smoothstep(0., sf, bar));\n        \n        fragColor = vec4(sqrt(max(col, 0.)), 1);\n        \n        // I prefer \"if-else\" statements, but sometimes GPUs will calculate the\n        // whole statement, which can be expensive. Hence the less readable \"return\"\n        // approach.\n        return;\n    }\n    \n    // If we're not precalculating (above), apply some depth of field, then present\n    // to the screen.\n    vec3 col = DpthFld(iChannel0, fragCoord/iResolution.xy);\n    \n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The cubemap texture resultion.\n#define cubemapRes vec2(1024)\n\nint frame0 = 0;\n\n// If you use all four channels of one 1024 by 1024 cube face, that would be\n// 4096000 storage slots (1024*1024*4), which just so happens be 160 cubed.\n// In other words, you can store the isosurface values of a 160 voxel per side\n// cube into one cube face of the cubemap.\n//\n// The voxel cube dimensions: That's the one you'd change, but I don't really\n// see the point, since setting it to the maximum resolution makes the most\n// sense. For demonstrative purposes, dropping it to say, vec3(80), will show\n// how a decrease in resolution will affect things. Increasing it to above the\n// allowable resolution (for one cube face) to say, vec3(200), will display the\n// wrapping issues.\n//\n// On a side note, I'm going to put up an example later that uses four of the \n// cubemap faces, which should boost the resolution to 256... and hopefully,\n// not add too much to the complexity, and consequent lag that would follow.\nconst vec3 dimsVox = vec3(100); \nconst vec3 scale = vec3(1, 1, 1);\nconst vec3 dims = dimsVox/scale;\n\n \n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube tx, vec2 p, int id){    \n\n    vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(tx, fcP[id]);\n}\n\n\nvec4 texMapCh(samplerCube tx, vec3 p){\n    \n    p *= dims;\n    int ch = (int(p.x*4.)&3);\n    p = mod(floor(p), dims);\n    float offset = dot(p, vec3(1, dims.x, dims.x*dims.y));\n    vec2 uv = mod(floor(offset/vec2(1, cubemapRes.x)), cubemapRes);\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    uv = fract((uv + .5)/cubemapRes) - .5;\n    return vec4(1)*texture(tx, vec3(-.5, uv.yx))[ch];\n    \n}\n\n// Used in conjunction with the function below. When doing things eight times over, any \n// saving is important. If I could trim this down more, I would, but there's wrapping\n// and pixel snapping to consider. Having said that, I might take another look at it,\n// at some stage.\nvec4 txChSm(samplerCube tx, in vec3 p){\n   \n    p = mod(floor(p), dims);\n    //vec2 uv = mod(floor(dot(p, vec3(1, dims.x, dims.x*dims.y))/vec2(1, cubemapRes.x)), cubemapRes);\n    vec2 uv = floor(dot(p, vec3(1, dims.x, dims.x*dims.y))/vec2(1, cubemapRes.x));\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably... definitely not doing this. :)\n    uv = fract((uv + .5)/cubemapRes) - .5;\n    return texture(tx, vec3(-.5, uv.yx));\n    \n}\n\n// Smooth texture interpolation that access individual channels: You really need this -- I \n// wish you didn't, but you do. I wrote it a while ago, and I'm pretty confident that it works. \n// The smoothing factor isn't helpful at all, which surprises me -- I'm guessing it molds things \n// to the shape of a cube. Anyway, it's written in the same way that you'd write any cubic \n// interpolation: 8 corners, then a linear interpolation using the corners as boundaries.\n//\n// It's possible to use more sophisticated techniques to achieve better smoothing, but as you \n// could imagine, they require more samples, and are more expensive, so you'd have to think about \n// it before heading in that direction -- Perhaps for texturing and bump mapping.\nvec4 texMapSmoothCh(samplerCube tx, vec3 p){\n\n    // Voxel corner helper vector.\n\t//const vec3 e = vec3(0, 1, 1./4.);\n\tconst vec2 e = vec2(0, 1);\n\n    // Technically, this will center things, but it's relative, and not necessary here.\n    //p -= .5/dimsVox.x;\n    \n    p *= dimsVox;\n    vec3 ip = floor(p);\n    p -= ip;\n\n    \n    //int ch = (int(ip.x)&3), chNxt = ((ch + 1)&3);  //int(mod(ip.x, 4.))\n    //ip.x /= 4.;\n/*\n    float c = mix(mix(mix(txChSm(tx, ip + e.xxx, ch).x, txChSm(tx, ip + e.yxx, chNxt).x, p.x),\n                     mix(txChSm(tx, ip + e.xyx, ch).x, txChSm(tx, ip + e.yyx, chNxt).x, p.x), p.y),\n                 mix(mix(txChSm(tx, ip + e.xxy, ch).x, txChSm(tx, ip + e.yxy, chNxt).x, p.x),\n                     mix(txChSm(tx, ip + e.xyy, ch).x, txChSm(tx, ip + e.yyy, chNxt).x, p.x), p.y), p.z);\n*/\n    \n     vec4 txA = txChSm(tx, ip + e.xxx);\n     vec4 txB = txChSm(tx, ip + e.yxx);\n\n     float c = mix(mix(mix(txA.x, txB.x, p.x), mix(txA.y, txB.y, p.x), p.y),\n                   mix(mix(txA.z, txB.z, p.x), mix(txA.w, txB.w, p.x), p.y), p.z);\n\n \n \t/*   \n    // For fun, I tried a straight up average. It didn't work. :)\n    vec4 c = (txChSm(tx, ip + e.xxx*sc, ch) + txChSm(tx, ip + e.yxx*sc, chNxt) +\n             txChSm(tx, ip + e.xyx*sc, ch) + txChSm(tx, ip + e.yyx*sc, chNxt) +\n             txChSm(tx, ip + e.xxy*sc, ch) + txChSm(tx, ip + e.yxy*sc, chNxt) +\n             txChSm(tx, ip + e.xyy*sc, ch) + txChSm(tx, ip + e.yyy*sc, chNxt) + txChSm(tx, ip + e.yyy*.5, ch))/9.;\n \t*/\n    \n    return vec4(c);\n\n}\n\n// If you want things to wrap, you need a wrapping scale. It's not so important\n// here, because we're performing a wrapped blur. Wrapping is not much different\n// to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash function\n// for anything that's procedurally generated with random numbers. If you're using\n// a repeat texture, then that'll have to wrap too.\nvec3 gSc;\n\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// 3x1 hash function.\n//float hash31(vec3 p){ return fract(sin(dot(p, vec3(21.471, 157.897, 113.243)))*45758.5453); }\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    return fract(sin(dot(p, vec2(27.609, 157.583)))*43758.5453); \n}\n\n// David_Hoskins puts together some pretty reliable hash functions. This is \n// his unsigned integer based vec3 to vec3 version.\nvec3 hash33(vec3 p){\n\n    p = mod(p, gSc);\n\tuvec3 q = uvec3(ivec3(p))*uvec3(1597334673U, 3812015801U, 2798796415U);\n\tq = (q.x^q.y^q.z)*uvec3(1597334673U, 3812015801U, 2798796415U);\n\treturn -1. + 2. * vec3(q) * (1./float(0xffffffffU));\n}\n\n\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\n", "cube_a_code": "// It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n// all calculated at startup. The idea is to put the function you wish to use in the\n// middle of the loop here, instead of writing it out four times over.\nvec4 funcFace0(vec3 p){\n   \n    \n    vec4 col;\n    \n    for(int i = 0; i<4; i++){\n        \n        vec3 q = p + vec3(0, i&1, i>>1)/dims.x;\n        \n        vec3 rotF = vec3(0); // Rotation factor - Range: [0, 1].\n        \n        // Wrapped multilayer tertiary order Voronoi.\n        gSc = vec3(64);\n        vec3 sc = vec3(1);\n        float res = hash33(q*gSc).x*.5 + .5;\n        \n        //res = smoothstep(.4, .6, res);\n        \n        //float res = 1. - n3DT(q*gSc);\n    \n        // The pixel channel value: On a side note, setting it to \"v.y\" is interesting,\n        // but not the look we're going for here.\n        col[i] = res;//max(1. - res*.85 - res*res*.15, 0.);\n\n        \n    }\n    \n    // Return the four function values -- One for each channel.\n    return col;\n    \n}\n\n\n\n// 3D weighted blur routine. Not much different to a 2D one. \nvec4 blur3D(samplerCube iCh, vec3 p, int N, int faceID) {\n\n    vec4 col;\n\n    p *= dims;\n    \n    vec3 mid = floor(vec3(N) - .5)/2.;\n    vec4 res = vec4(0);\n    float sum = 0.;\n\n     \n    for(int k = 0; k<N; k++){ \n       for(int j = 0; j<N; j++){ \n            for(int i = 0; i<N; i++){\n                 \n                vec3 offs = vec3(i, j, k) - mid; // Pixel offset.\n                \n                // Weighted blur value.\n                float a = max(length(vec2(N)/2.) - length(offs), 0.); a *= a;\n                //float a = 1./(1. + dot(offs, offs));\n                //float a = exp(-(dot(offs, offs)/float(N*N))/2.);///float(N)*.39894;\n                \n                // Weighted texture value.\n                res += txChSm(iCh, p + offs)*a;\n\n                sum += a;\n            }\n        }\n    }\n\n\n    return res/sum;\n    \n}\n\n// Converting your UV coordinates to 3D coordinates. I've seen some pretty longwinded\n// obfuscated conversions out there, but it shouldn't require anything more than \n// the following. By the way, the figure \"dims.x\" is factored down by four to account\n// for the four pixel channels being utilized, but the logic is the same.\nvec3 convert2DTo3D(vec2 uv){\n    \n    // Converting the fract(uv) coordinates from the zero to one range to the whole\n    // number, zero to... 1023 range.\n    uv = floor(uv*cubemapRes);\n    \n    // Converting the UV coordinate to a linear representation. The idea is to convert the\n    // 2D UV coordinates to a linear value, then use that to represent the 3D coordinates.\n    // This way, you can effectively fit all kinds of 3D dimensions into a 2D texture array\n    // without having to concern yourself with 2D texture wrapping issues. In theory, so \n    // long as the dimensions fit, and the X dimension is a multiple of four, then anything\n    // goes. As mentioned, the maximum cubic dimension allowable for one cube face is \n    // 160 cubed. In that respect, rectangular dimensions, like vec3(160, 80, 320), etc, \n    // would also fit.\n    //\n    // For instance, the 137th pixel in the third row on a 1024 by 1024 cubemap face texture \n    // would be the number 2185 (2*1024 + 137).\n    float iPos = dot(uv, vec2(1, cubemapRes.x));\n    \n    // In this case the XY slices comprise of 160 pixels (or whatever number we choose) along \n    // X and Y, so the pixel position in any block would be modulo 160*160. The xyBlock position \n    // would have to be converted to X and Y positions, which would be xyBlock mod dimX, and \n    // floor(xyBlock/dimX) mod dimY respectively. The Z position would depend on how many \n    // 160 by 160 blocks deep we're in, which translates to floor(iPos/(dimX*dimY)).\n    //\n    // Anyway, that's what the following lines represent.\n    \n    // XY block (or slice) linear position.\n    float xyBlock = mod(iPos, dims.x*dims.y);\n    \n    // Converting to X, Y and Z position.\n    vec3 p = vec3(mod(floor(vec3(xyBlock, xyBlock, iPos)/vec3(1, dims.x, dims.x*dims.y)), dims));\n    \n    //vec3 p = vec3(mod(xySlice, dims.x), mod(floor((xySlice)/dims.x), dims.y),\n                  //floor((iPos)/(dims.x*dims.y)));\n    \n    // It's not necessary, but I'm converting the 3D coordinates back to the zero to one\n    // range... There'd be nothing stopping you from centralizing things (p/dims - .5), but \n    // this will do.\n    return p/dims;\n}\n\n\n\n\n\n// Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n  \n  \n    // Pixel storage.\n    vec4 col;\n    \n\n    // Initial conditions -- Performed upon initiation.\n    //if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    //if(iFrame<1){\n    //\n    // Great hack, by IQ, to ensure that this loads either on the first frame, or in the\n    // event that the texture hasn't loaded (this happens a lot), wait, then do it...\n    // Well kind of. Either way, it works. It's quite clever, which means that it's something \n    // I never would have considered. :)\n    if(textureSize(iChannel0,0).x<2 || iFrame<1){\n        \n        // This is part of an ugly hack that attempts to force the GPU compiler\n        // to not unroll the Voronoi loops. Not sure if it'll work, but I'm \n        // trying it anyway, in the hope to get compiler times down on some\n        // machines. For the record, this takes about 3 seconds to compile on \n        // my machine.\n        frame0 = iFrame;\n        \n \n        \n        \n        // Fill the first cube face with a custom 3D function.\n        if(faceID==0){\n            \n            vec3 p = convert2DTo3D(uv);\n            \n            col = funcFace0(p);\n           \n        }\n\n        /*\n        // Last channel on the last face: Used to store the current \n        // resolution to ensure loading... Yeah, it's wasteful and it\n        // slows things down, but until there's a reliable initiation\n        // variable, I guess it'll have to do. :)\n        if(faceID==5){\n            \n            col.w = iResolution.y;\n        }\n        */\n\n        \n    }\n    else {\n    \n \n        //\n        if(faceID!=0 || (iFrame - frame0)>300) {\n            \n            \n            fragColor = tx(iChannel0, uv, faceID);\n            \n            // I couldn't understand why my frame rate was lagging after\n            // applying an \"if-else\" statement, then realized the GPU will\n            // still sometime calculate \"if\" and \"else\", even though only \n            // one is executed. Using a return gets around that.\n            return;\n        }\n        \n        \n        vec3 p = convert2DTo3D(uv);\n\n        \n        // Here's the quickest 3D Turing pattern tutorial you're ever going\n        // to get: Create some noise, then take the difference between the a \n        // large blur and a smaller one. You're welcome. :D\n        //\n        // Seriously though, this is just a huge shortcut that I kind of made\n        // up on the spot.\n        vec4 filt1 = blur3D(iChannel0, p, 3, faceID);\n        vec4 filt2 = blur3D(iChannel0, p, 5, faceID);\n\n        col = clamp(filt1*2. - filt2, -1., 1.);\n\n    }\n    \n    \n    // Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n// Max ray distance.\n#define FAR 50. \n\n// Surface delta.\n#define DELTA .001\n\n// Just the two passes. If your computer doesn't enjoy running the program,\n// change the number of passes to 1.\n#define PASSES 2\n\n\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 path(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    //return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec3(s*12., 0., t);\n    \n    float a = sin(t*.11);\n    float b = cos(t*.14);\n    return vec3(a*4. - b*1.5, b*1.2 + a*1., t);\n    \n}\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(n*n, .001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n// The 3D surface function. This one converts the 3D position to a 3D voxel \n// position in the cubemap, then reads the isovalue. Actually, one option does\n// that, and the other is forced to read out eight neighboring values to \n// produce a smooth interpolated value. As in real life, it looks nicer, but \n// costs more. :)\nfloat txFace0(in vec3 p){\n    \n    #if 0\n    \n    // One sample... Ouch. :D It's a shame this doesn't work, because it's \n    // clearly faster. Unfortunately, it's virtually pointless from an aesthetic\n    // aspect, as you can see, but there'd be times when you could get away with it.\n    vec3 col = texMapCh(iChannel0, p).xyz;\n    \n    #else\n    \n    // Eight samples, for smooth interpolation. Still not as good as the real \n    // thing -- and by that, I mean, calculating on the fly. However, it's \n    // good enough. I'd need to think about it, but I'm wondering whether a\n    // four or five point tetrahedral interpolation would work? It makes my\n    // head hurt thinking about it right now, but it might. :)\n    vec3 col = texMapSmoothCh(iChannel0, p).xyz;\n    \n    #endif\n    \n    return col.x;\n    \n}\n\n\n\n// 3D surface function.\nfloat surfFunc3D(in vec3 p){ \n\n    return txFace0(p/3.)*.5 + .5;\n    \n}//\n\n \n// A simple transcendental distance function upon which to apply \n// the Turing pattern.\nfloat map(vec3 p){\n   \n    // 3D Turing pattern.\n    //float sf = surfFunc3D(p);\n    //sf = smoothstep(-.3, .3, sf - .5);\n \n    \n    p.xy -= path(p.z).xy;\n \n    // Twist along Z.\n    //float  ang = -p.z*.1;\n    //p.xy *= rot2(ang);\n    // Perturbation.\n    //p += cos(p*1.57 + sin(p.yzx*3.14159)*3.14159)*.05;\n    //p.xz += cos(p.xy*1.57*6. + sin(p.yz*3.14159*6.)*3.14159)*.01;\n    \n    \n    // Mixing layers of transcendental functions. Only three are\n    // used here, but higher numbers can look interesting.\n    \n    float d = 1e5;\n    const int n = 3;\n    const float fn = float(n);\n    \n    for(int i = 0; i<n; i++){\n        \n        vec3 q = p;\n        float a = float(i)*fn*2.422; //*6.283/fn\n        a *= a;\n        q.z += float(i)*float(i)*1.67; //*3./fn\n        q.xy *= rot2(a);\n        d = smin(d, (length(length(sin(q.xy) + cos(q.yz))) - .15), 1.);\n        \n    }\n    \n    // Applying the Turing pattern.\n    //d += (.5 - sf)*.025;\n    //d = abs(d) + (.5 - sf)*.0125;\n    \n    return d;\n\t\n}\n\n/*\n// A fake, noisy looking field - cheaply constructed from a spherized sinusoidal\n// combination. I came up with it when I was bored one day. :) Lousy to hone in\n// on, but it has the benefit of being able to guide a camera through it.\nfloat map(vec3 p){\n\n     // 3D Turing pattern.\n    //float sf = surfFunc3D(p);\n    //sf = smoothstep(-.3, .3, sf - .5);\n \n    p.xy -= path(p.z).xy; \n     \n\tp = cos(p*.315*1.25 + sin(p.zxy*.875*1.25)); // 3D sinusoidal mutation.\n    \n    \n    float n = length(p); // Spherize. The result is some mutated, spherical blob-like shapes.\n\n    \n    // It's an easy field to create, but not so great to hone in one. The \"1.4\" fudge factor\n    // is there to get a little extra distance... Obtained by trial and error.\n    n = (n - 1.025)*1.5;\n    \n    // Applying the Turing pattern.\n    //n = abs(n) + (.5-sf)*.0125;\n    //n += (.5 - sf)*.025;\n    \n    return n;\n    \n}\n*/\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., d;\n    \n    for(int i=0; i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<DELTA*(t*.05 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        // Ray shortening.\n        t += d*.75;\n    }\n\n    // Cap to the far distance plane.\n    return min(t, FAR);\n}\n\n\n// Surface bump function..\nfloat bumpSurf3D( in vec3 p){\n \n    // The Turing pattern.\n    float sf = surfFunc3D(p);\n      \n    // Shaping the pattern a bit.\n    return smoothstep(-.35, .35, sf - .5);\n\n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.003, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p);\n   \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    */ \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, \n    // anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\nvoid mainImage(out vec4 e, in vec2 v){\n\n\n    // When precalculating on the cube map tab, return a black screen.\n    if (iFrame - frame0<=300) {\n        e = vec4(0);\n        return;\n    }\n    \n    \n    // Aspect correct UV coordinates. Only translation and scaling is required.\n    vec2 uv = (v - iResolution.xy*.5)/iResolution.y;\n    \n\t// Camera Setup.\n    float speed = 2.;\n    vec3 ro = path(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = path(iTime*speed + .25);  // \"Look At\" position.\n    vec3 lp = path(iTime*speed + 5.); // Light position, somewhere near the moving camera.\n\t\n    // Light postion offset. Since the lattice structure is rotated about the XY plane, the light\n    // has to be rotated to match. See the \"map\" equation.\n    vec3 loffs =  vec3(0, 0, 0);\n    //vec2 a = sin(vec2(1.57, 0) - lp.z*1.57/10.);\n    //loffs.xy = mat2(a, -a.y, a.x)*loffs.xy; \n    lp += loffs;\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.;//3./3.14159; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 rd = normalize(fwd/FOV + uv.x*rgt + uv.y*up);\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.25)));\n    \n    // Swiveling the camera from left to right when turning corners.\n    rd.xy = rot2(-path(lk.z).x/16. )*rd.xy;\n\n    // Set the initial position to the camera position.\n    vec3 sp = ro;\n    vec3 oRd;\n    \n    \n    \n    // Overall scene color.\n    vec3 col = vec3(0);\n    \n   \n    // Alpha, reflective factor, and fog distance.\n    float alpha = 1.;\n    float refFact = 1.;\n    float fogDist = 1e5;\n    \n    // Bouncing the ray around and collecting color along the way.\n    for(int j = min(0, iFrame); j<PASSES; j++){\n    \n        \n        // Color for this particular pass.\n        vec3 colL = vec3(0); \n        \n        float distanceFactor = 1.;\n\n        float freS = 1., fre2 = 1.;\n\n        // Raymarching.\n        float t = trace(sp, rd);\n         \n        // Fog distance.\n        if(j==0) fogDist = t;\n\n        // Advance the ray to the surface hit postion.\n        sp += rd*t;\n        \n        // Unit direction vector copy.\n        oRd = rd;\n\n        if(t<FAR){\n\n            // Surface normal.\n            vec3 sn = getNormal(sp)*distanceFactor;\n            \n            // Function based bump mapping.\n            sn = doBumpMap(sp, sn, .5/(1. + fogDist*fogDist*.03));///\n            \n            vec3 reflection = reflect(rd, sn);\n\n            // Light direction, vector.\n            vec3 ld = lp - sp;\n            float lDist = length(ld); // Light distance.\n            ld /= max(lDist, .0001);\n\n            // Light attenuation.\n            float att = 2./(1. + lDist*lDist*.03);\n            \n            \n            // Very, very cheap shadows -- Not used here.\n            //float sh = min(min(map(sp + ld*.08), map(sp + ld*.16)), \n            //           min(map(sp + ld*.24), map(sp + ld*.32)))/.08*1.5;\n            //sh = clamp(sh, 0., 1.);\n            float sh = softShadow(sp, lp, sn, 12.); // Shadows.\n            float ao = calcAO(sp, sn); // Ambient occlusion.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse value.\n            float spe = pow(max(dot(reflection, ld), 0.), 16.);\n            float fre = clamp(1. + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n            fre2 = clamp(1. - abs(dot(rd, sn))*.5, 0., 1.); // Fresnel reflection term.\n            \n            // Ramping up the diffuse component for more of a metallic look.\n            dif = pow(dif, 4.)*2.;\n\n            //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            //freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n\n            // Surface texture.\n            vec3 tx = tex3D(iChannel1, sp/2., sn);\n            tx = smoothstep(0., .5, tx);\n            vec3 oCol = tx;\n            \n            // The Turing pattern.\n            float sf = surfFunc3D(sp);\n            \n            // Applying the Turing pattern.\n            oCol *= mix(vec3(.45, .5, .55), vec3(.15), 1. - smoothstep(-.03, .03, (sf - .5)));\n            // Edge highlighting or sorts.\n            oCol = mix(oCol, oCol*4., 1. - smoothstep(-.03, .03, abs(sf - .5) - .1));\n           \n            // Reflective factor: The idea is to reflect the darker part of the pattern less. \n            refFact = mix(1., .5, 1. - smoothstep(-.03, .03, (sf - .5)));\n            //refFact *= mix(1., 4., 1. - smoothstep(-.03, .03, abs(sf - .5) - .1));\n           \n           \n \n             \n            // Applying the above to color the suface.\n            colL = oCol*(dif*sh + .15 + vec3(1, .6, .3)*spe*sh*refFact*4.);\n            \n            // Attenuation and ambient occlusion.\n            colL *= att*ao;\n            \n            // Reflect off the surface.\n            rd = reflection; \n            \n            // Move just off the surface to avoid self collisions.\n            sp += sn*DELTA*1.1; \n\n        }\n\n        // Applying fog.\n        vec3 fogCol = mix( vec3(1.2, .7, .4).zyx, vec3(1), oRd.y*.5 + .5)*2.;\n        float td = min(length(sp - ro), FAR);\n        colL = mix(colL, fogCol, smoothstep(0., .99, td/FAR));\n\n        // Adding the color for this pass.\n        col += colL/float(PASSES)*alpha;\n        //col = mix(col, colL, alpha/float(j + 1));//*freS;\n        \n        // Overall reflective reduction.\n        alpha -= .25/float(PASSES);\n        // Individual reflective reduction.\n        alpha *= refFact;\n        \n    }\n    \n    \n    \n    e = vec4((max(col, 0.)), fogDist);\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSSDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2597, 3377, 3414, 3460, 4170], [4173, 4537, 4592, 4592, 6267]]}
{"id": "ss2Xz3", "name": "Bonneval-sur-Arc", "author": "ocb", "description": "Raycast thru a grid with overlapping cell to create contiguous and interconnected set of chalets.\n\nMouse available\n\nChange SEED line 37 to create new village.\n\nMore infos in Image header.\n", "tags": ["grid", "raycasting", "fake", "city", "village", "overlapping"], "likes": 48, "viewed": 941, "published": 3, "date": "1620736162", "time_retrieved": "2024-07-30T19:20:51.550024", "image_code": "/***************************************************************************************/\n// Title: Bonneval-sur-Arc\n// author: ocb\n//\n// No copyright on code\n//\n// The purpose of this shader is to create structures using grid with overlapping cells. \n// Interconnections of randomly positionned objects create meta-structures, less\n// geometrical and then more natural or unexpected.\n//\n// I also tried myself with fake 3D. (windows, doors, inside lights).\n// Code is still little messy.\n// \n// Mouse is usable to explore village.\n// Push the mouse forward to go inside, explore narrow passages, hidden squares, secret corners.\n// The aiming point is always the village center.\n// No anti-collision functions. If you go thru the chalets, artifacts will appear.\n// It's a limited tool, as the objective is not a game.\n// Put back the mouse on left edge of the shader image to go back to auto-flight cam.\n//\n//\n// Change the SEED at the first line of the code (line 37) to create new village.\n//\n//\n// Thanks to:\n// iq for the Sphere4 raycasting primitive used for the snowy roof.\n// See iq's article and demo shader:\n// https://www.shadertoy.com/view/3tj3DW\n//\n// Dave_Hoskins for the very good hash functions:\n// https://www.shadertoy.com/view/4djSRW\n//\n/***************************************************************************************/\n\n/* If High Resolution screen */\n//#define HiRes\n\n/* set any SEED (float) to create new village */\n#define SEED 0.1\n\n/* smaller chalets or bigger chalets */\n//#define DEN >.8\n#define DEN <1.2\n\n// Max camera distance from center\n#define CamDist 12.\n\n// Max size of the grid - village\n#define MaxRad 11.\n\n// try to comment this if compilation troubles\n#define WITH_CHURCH\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000.\n//#define ti iTime\n//#define ti iMouse.x/iResolution.x*200.\n\n#define SKY 0\n#define GND 1\n#define BODY 2\n#define ROOF 3\n#define CEIL 4\n#define BALCON 5\n#define CHEM 6\n#define TORCH 7\n#define TOWER 8\n#define STEEP 9\n#define CHURCH 10\n#define NEF 11\n\n#define TOPSFC 2.5\n#define maxCell 30\n\n#define RVAL 1000.\n#define TOP 1000.\n  \n#define ZERO min(0,iFrame)\n \n/*******************************************************/\n/*                       Globals                       */\n/*******************************************************/\nint hitObj = SKY;\n\nvec3 boxCtr = vec3(INFINI);\nvec3 boxSze = vec3(0.);\nfloat boxH = 0.;\nmat2 boxRot = mat2(1,0,0,1);\nvec2 boxCell = vec2(0);\nfloat t = INFINI;\nvec3 n = vec3(0,1,0);\n/*******************************************************/\n/*                         Basic                       */\n/*******************************************************/\n//Dave_Hoskins's hash functions\n\nfloat H12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 H22(vec2 p)\n{\n    p += vec2(15.456,21.0985);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 H33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\nvec3 dither(in vec3 p){\n    return vec3(H33(floor(5000.*p))-.5);\n}\n\n\n/*******************************************************/\n/*                 Raycast primitives                  */\n/*******************************************************/\n\nfloat gnd(float py, float ry, float h){\n    float t = (h-py)/ry;\n    if(t<0.) t = INFINI;\n    return t;\n}\n\n// IQ's box function modified\nvec4 iBox( in vec3 p, in vec3 ray, in vec3 box) \n{\n    // ray-box intersection in box space\n    vec3 sg = sign(ray);\n    vec3 t1 = -(p+sg*box)/ray;\n    vec3 t2 = -(p-sg*box)/ray;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF <= 0. || tN <= 0.) return vec4(INFINI);\n    \n    vec3 nor = -sign(ray)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec4(nor,tN);\n}\n\n// IQ's iSphere4D function !!\n// modified to get the second solution and cut off the roof\nvec4 iSphere4( in vec3 ro, in vec3 rd, in float ra)\n{   \n    // -----------------------------\n    // solve quartic equation\n    // -----------------------------\n    float r2 = ra*ra;\n    \n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n\n    float ka = 1.0/dot(d2,d2);\n\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n\n    // -----------------------------\n    // solve cubic\n    // -----------------------------\n\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    \n    float h = q*q - p*p*p;\n\n    // -----------------------------\n    // skip the case of three real solutions for the cubic, which involves four\n    // complex solutions for the quartic, since we know this objcet is convex\n    // -----------------------------\n    if( h<0.0 ) return vec4(INFINI);\n    \n    // one real solution, two complex (conjugated)\n    float sh = sqrt(h);\n\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n\n    // -----------------------------\n    // the quartic will have two real solutions and two complex solutions.\n    // we only want the real ones\n    // -----------------------------\n\n    vec2  v = vec2( w.x+c2*4.0, w.y*1.73205081 )*0.5;   // sqrt(3.0)\n    float r = length(v);\n    float a = abs(v.y)/sqrt(r+v.x);\n    float b = c1/r + k3;\n    float t1 = -a-b;\n    if(t1 <= 0.) return vec4(INFINI);\n    \n    // ocb modified part to shape the roof\n    float t2 = a-b;\n    \n    vec3 pos = ro + t1*rd;\n    vec3 norm = normalize(pos*pos*pos);\n\n    float sn = .6*ra; // snow thickness\n    if(pos.y<sn && pos.z<sn){\n        pos = ro + t2*rd;\n        if(pos.y<sn && pos.z<sn) return vec4(INFINI);\n        \n        vec2 tt = vec2((sn-ro.y)/rd.y, (sn-ro.z)/rd.z); \n        if(pos.y<sn) t1 =  tt.y;\n        else if(pos.z<sn) t1 = tt.x;\n        else t1=min(tt.x, tt.y);\n        \n        if(t1 == tt.y) norm = vec3(0,0,-1);\n        else norm = vec3(0,-1,0);\n    }\n    return vec4(norm,t1);\n}\n\nvec2 cylinder(in vec2 pos, in vec2 ray, in vec2 O, in float R){\n    float t1 = INFINI, t2 = INFINI;\n    vec2 op = pos - O;\n\n    float a = dot(ray,ray);\n    float b = dot(op, ray);\n    float c = dot(op,op) - R*R;\n    float d = b*b - a*c;\n    \n    if (d >= 0.){\n        float Vd = sqrt(d);\n        t1 = (-b - Vd)/a;\n        t2 = (-b + Vd)/a;\n    }\n    \n\treturn vec2(t1,t2);\n}\n\nvec2 sphere(in vec3 p, in vec3 ray, in vec3 O, in float r){\n    vec2 t = vec2(INFINI);\n    vec3 d = O - p;\n    float b = dot(d, ray);\n    \n    float c = dot(d,d) - r*r;\n    float D = b*b - c;\n    if (D >= 0.){\n        float VD = sqrt(D);\n        t = vec2(b-VD, b+VD);\n        if(t.x<=0.) t.x = INFINI;\n        if(t.y<=0.) t.y = INFINI;\n    }\n    return t;\n}\n\n\nvec4 curvgnd(in vec3 pos, in vec3 ray, in float f){\n\n    float t = sphere(pos, ray, vec3(0.,RVAL,0.), RVAL).y;\n    vec3 p = pos + t*ray;\n    vec3 n = normalize(vec3(-p.x,RVAL-p.y,-p.z));\n    vec2 a = vec2(abs(atan(p.x,p.z)));\n    float h = .1\n                +.1*texture(iChannel0,.04*a).x\n                +.3*texture(iChannel0,.02*a).x\n                +.6*texture(iChannel0,.005*a).x;\n    if(p.y > TOP*h) t = INFINI;\n    return vec4(n,t);\n}\n\n\nvec4 bellTower(in vec3 p, in vec3 ray,  in vec3 box)\n{\n    vec3 sg = sign(ray);\n    vec3 t1 = -(p+sg*box)/ray;\n    vec3 t2 = -(p-sg*box)/ray;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF <= 0. || tN <= 0.) return vec4(INFINI);\n    \n    vec3 nor;\n    p += tN*ray;\n    if(p.y+min(1.2,3.*(abs(fract(p.z)-.5)+abs(fract(p.x)-.5))) <= box.y){\n        nor = -sign(ray)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        return vec4(nor,tN);\n    }\n    \n    p += (tF-tN)*ray;\n    if(p.y+min(1.2,3.*(abs(fract(p.z)-.5)+abs(fract(p.x)-.5))) <= box.y){\n        nor = -sign(ray)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);\n        return vec4(nor,tF);\n    }    \n    return vec4(INFINI);\n}\n\n\nvec4 steeple(in vec3 p, in vec3 ray, in vec3 size)\n{\n    vec3 np = vec3(.986393923832144,.164398987305357,.0);        // normalize(vec3(6,1.,0));\n    vec3 n = np;\n    float t = INFINI, t2 = INFINI;\n    vec2 pp;\n    \n    float f = dot(ray,np);\n    if(f<=0.){\n        t = -(dot(p,np)-.6575)/f;    // 4./3. x 0.4931 = cos(atan(n.y,n.x))\n        pp = p.zy+t*ray.zy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t = INFINI;\n    }\n\n    np.x = -np.x;\n    f = dot(ray,np);\n    if(f<=0.){\n        t2 =-(dot(p,np)-.6575)/f;\n        pp = p.zy+t2*ray.zy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t2 = INFINI;\n    }\n    if(t2<t){\n        t=t2;\n        n = np;\n    }\n    \n    np = np.zyx;\n    f = dot(ray,np);\n    if(f<=0.){\n        t2 = -(dot(p,np)-.6575)/f;\n        pp = p.xy+t2*ray.xy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t2 = INFINI;\n    }\n    if(t2<t){\n        t=t2;\n        n = np;\n    }\n\n    np.z = -np.z;\n    f = dot(ray,np);\n    if(f<=0.){\n        t2 = -(dot(p,np)-.6575)/f;\n        pp = p.xy+t2*ray.xy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t2 = INFINI;\n    }\n    if(t2<t){\n        t=t2;\n        n = np;\n    }\n\n    if(t<=0.) t = INFINI;\n    return vec4(n,t);\n}\n\n/*******************************************************/\n/*                     Grid process                    */\n/*******************************************************/\n\n// finding next cell on the grid\nvec2 getNextCell(in vec2 p, in vec2 v, in vec2 cell){\n    vec2 d = sign(v);\n\tvec2 dt = (cell+d*.5-p)/v;\n    d *= vec2( step(dt.x-0.02,dt.y) , step(dt.y-0.02,dt.x) );\t\t// -0.02 to avoid cell change for epsilon inside\n    return cell+d;\n}\n\n// cell information (center and size of the chalet, if there is.)\nvec2 getBox(in vec2 cell)\n{\n\n#ifdef WITH_CHURCH\n    if(abs(cell.x) <= 1. && abs(cell.y)<=1.) return vec2(-1.);   // Empty spaces for the church\n#endif\n    if(length(cell)>= MaxRad-1.5) return vec2(-1.);\n    vec2 h = H22(cell+SEED);\n    if(h.x+h.y DEN) return vec2(-1.);\n\n    return h;\n}\n\n// raycasting one cell\nvoid checkCell(in vec3 pos, in vec3 ray, in vec2 cell)\n{\n    vec2 h = getBox(cell);\n    if(h.x < -0.1) return;\n    \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n    \n    // convert from ray to box space\n    float c = cos(ang), s = sin(ang);\n    mat2 rotY = mat2(c,-s,s,c);\n    mat2 derotY = mat2(c,s,-s,c);\n    \n    // roof 45 deg\n    // 0.7071 = sin or cos PI/4\n    mat3 rot45 = mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n    mat3 derot45 = mat3(1,0,0,  0,.7071,.7071,  0,-.7071,.7071);\n\n\n\tray.xz *= rotY;\n    pos -= ctr;\n\tpos.xz *= rotY;\n    \n    // Main body\n    vec4 res = iBox( pos, ray, sze);\n    vec3 p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(p.z) <= sze.y){\n        t = res.w;\n        n = res.xyz;\n        n.xz*=derotY;\n        hitObj = BODY;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }    \n    \n    // Chimney\n    pos.z -= .4;\n    res = iBox( pos, ray, vec3(.1,sze.y+.2,.1) );\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        n.xz*=derotY;\n        hitObj = CHEM;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }\n    pos.z += .4;\n    \n    // Torch\n    float sx = sze.x+.01;\n    sx *= sign(mod(cell.x,2.)-.5)*sign(mod(cell.y,2.)-.5);\n    pos -= vec3(sx, .35, sx);\n    res = iBox( pos, ray, vec3(.01,.03,.01) );\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        n.xz*=derotY;\n        hitObj = TORCH;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n        boxCell = cell;\n    }\n    pos += vec3(sx, .35, sx);\n\n    // Balcony\n    if(sze.y>1.6){\n        pos.y -= .7;\n        res = iBox( pos, ray, vec3(1.2*sze.x, .1,.7*sze.x) );\n        vec3 pb = pos + res.w*ray;\n        if(res.w<t && res.y!=1. && ( abs(fract(15./sze.x*(pb.z+pb.x))-.5)>.25 || abs(pb.y)>.07) && pb.y<.09+.01*cos(20.*(pb.z+3.*pb.x))){\n            t = res.w;\n            n = res.xyz;\n            n.xz*=derotY;\n            hitObj = BALCON;\n            boxCtr = ctr;\n            boxSze = sze;\n            boxH = h.x;\n            boxRot = rotY;\n        }\n        pos.y += .7;\n    }\n        \n    // Chimney snow cap\n    vec3 O = vec3(0.,sze.y+.2,.4);\n    float u = sphere(pos, ray, O, .13).x;\n    if(u<t){\n        t = u;\n        n = normalize(pos+u*ray - O);\n        n.xz*=derotY;\n        hitObj = ROOF;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }    \n    \n    \n    pos.y -= sze.y-1.1*sze.x;\n    \n    ray *= rot45;\n    pos *= rot45;\n\n    // Snowy roof\n    res = iSphere4(pos, ray, 1.3*sze.x);\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz*derot45;\n        n.xz*=derotY;\n        if(res.y+res.z == -1.) hitObj = CEIL;\n        else hitObj = ROOF;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }\n\n    return;\n}\n\n/*******************************************************/\n/*                Main process thru grid               */\n/*******************************************************/\n\nvoid runGrid(in vec3 pos, in vec3 ray){\n\n    vec2 cell, outCell;\n    \n    // first step getting boundary of interesting areas    \n    // Entry and exit point of the voxel run(te and tx)\n    vec3 pe = pos;\n    float te = INFINI, tx = 0.;\n\n    vec2 tc = cylinder(pos.xz, ray.xz, vec2(0.), MaxRad);\n    float th = gnd(pos.y,ray.y,TOPSFC);\n    vec4 res = curvgnd(pos, ray, 1.);\n    float tg = res.w;\n    n = res.xyz;\n\n    if(pos.y>=TOPSFC){\n        te = min(max(tc.x,th),tc.y);\n        tx = min(tg,tc.y);\n    }\n    else{\n        te = tc.x*step(0.,tc.x)+INFINI*step(th,tc.x);\n        tx = min(min(tg,tc.y),th);\n    }\n    \n    \n    // MAIN PROCESS\n    // going thru the grid checking for existing object in each cell\n   \n    t = tg;\n    if(t<INFINI) hitObj = GND;\n    \n    cell = floor(pos.xz+te*ray.xz + .5);\n    outCell = getNextCell(pos.xz, ray.xz, floor(pos.xz+tx*ray.xz + .5));\n\n    int endCheck = 0;\n    const vec3 e = vec3(1,0,-1);\n     \n    for(int i=ZERO; i<maxCell;i++){\n        \n        if(cell == outCell) break;\n                \n        checkCell(pos, ray, cell);\n        checkCell(pos, ray, cell+e.xy);    // 3x3 overlaping\n        checkCell(pos, ray, cell+e.zy);\n        checkCell(pos, ray, cell+e.yx);\n        checkCell(pos, ray, cell+e.yz);\n        \n        checkCell(pos, ray, cell+e.xx);\n        checkCell(pos, ray, cell+e.zz);\n        checkCell(pos, ray, cell+e.xz);\n        checkCell(pos, ray, cell+e.zx);\n        \n        \n        if(endCheck==2) break;\n        \n        if(hitObj >= 2) endCheck += 1;\n        \n        cell = getNextCell(pos.xz,ray.xz,cell);\n    } \n\n\n    return;\n}\n\n/*******************************************************/\n/*                  raycasting Church                  */\n/*******************************************************/\n\n// checking if ray goes in center cell (dim = 1.36 x 1.36)\nbool inChurchBound(in vec2 p, in vec2 r)\n{\n    vec2 s = sign(r);\n    vec2 t1 = -(p+s*1.36)/r;\n    vec2 t2 = -(p-s*1.36)/r;\n\n\tfloat tN = max( t1.x, t1.y );\n\tfloat tF = min( t2.x, t2.y );\n\t\n\tif( tN > tF || tF <= 0.) return false;\n    else return true;\n}\n\n// raycasting whole church\nvoid checkChurch(in vec3 pos, in vec3 ray)\n{\n    vec3 sze = vec3(.9,1.8,.9);\n    vec4 res = iBox( pos, ray, sze);\n    vec3 p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(p.z) <= sze.y){\n        t = res.w;\n        n = res.xyz;\n        hitObj = CHURCH;\n    }\n    \n    res.w = cylinder(pos.xz, ray.xz, vec2(.5,0.), .8).x;\n    p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(.3*p.x) <= .8){\n        t = res.w;\n        n = vec3(p.x-.6,0,p.z);\n        hitObj = NEF;\n    }\n    \n    res.w = sphere(pos, ray, vec3(.5,.25,0), .85).x;\n    p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(.3*p.x) > .75){\n        t = res.w;\n        n = normalize(p - vec3(.5,.3,0));\n        hitObj = ROOF;\n    }\n    \n    pos.xz -= vec2(.4,1.);\n    res = bellTower(pos,ray,vec3(.35,3.5,.35));\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        hitObj = TOWER;\n    }       \n   \n    res = steeple( pos, ray, vec3(.5,3.,.5));\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        hitObj = STEEP;\n    }\n    pos.xz += vec2(.4,1.);\n    \n    // roof\n    pos.y -= sze.y-1.1*sze.x;\n    ray *= mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n    pos *= mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n\n    res = iSphere4(pos, ray, 1.15*sze.x);\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz*mat3(1,0,0,  0,.7071,.7071,  0,-.7071,.7071);\n        if(res.y+res.z == -1.) hitObj = CEIL;\n        else hitObj = ROOF;\n    }\n\n    return;\n}\n\n/*******************************************************/\n/*                 Textures and colors                 */\n/*******************************************************/\nvec3 sky(in float x, in float y)\n{\n    x = .5*x+.5;          \n    return vec3(2.-3.*y, 1.2-1.4*y, .8-.6*y)*x*x+vec3(.0,.05,.1);\n}\n\nfloat snowGlitt(in vec3 p,in vec3 ray)\n{\n    #ifdef HiRes\n    return .6*min(1., step(.9995, H33(floor(2000.*p)+floor(5.*ray)).x ));\n    #else\n    return 0.;\n    #endif\n}\n\n\nvec3 stonewall(in vec2 uv)\n{\n    uv *= vec2(20.,20.);\n\n    vec2 i = floor(uv);\n    uv += vec2(.5,.3)*H22(i);\n    vec2 f = abs(fract(uv)-.5);\n    \n    float h = H12(floor(uv));\n    float tex = texture(iChannel0,.3*(uv+h)).x;\n    vec3 col = .1+ .3*vec3(h);\n    col += .6*tex;\n    col -= .3*(smoothstep(.45+.1*tex,.5,f.x)+smoothstep(.35+.1*tex,.45,f.y));\n\n    return max(vec3(0.),col);\n}\n\nvec3 woodwall(in vec2 p)\n{\n    vec3 col = vec3(.3,.225,.15);\n    col *= 1.-texture(iChannel0,.05*p.yx).x;\n    p*=15.;\n    col -= .4*smoothstep(.34+.2*texture(iChannel0,.01*p.xy).x,.5,abs(fract(p.x)-.5)) ;\n    col *= 1.-.5*H12(floor(p.xx));\n\n    return col;\n}\n\n/************************************************/\n/*               Doors and windows              */\n/************************************************/\n\n/******************** door *******************/\nfloat doorMask(in vec3 p, in vec3 ray, in float pzctr)\n{\n    float apz = abs(pzctr);\n    float m = 1.\n              - smoothstep(.143,.135,apz)*step(p.y,.44)\n              - smoothstep(.205,.20,apz)*smoothstep(.027,.020,abs(p.y-.425));\n    m = max(m,0.);\n    return m;\n}\n\nvec3 door2D(in vec3 p, in vec3 ray, in float pzctr)\n{\n    vec3 tex = vec3(.3,.225,.15)*(.1+texture(iChannel0,3.*p.yz).x);\n    float apz = abs(pzctr);\n    \n    // wood framing\n    vec3 col = tex*smoothstep(.023,.015,abs(p.y-.425))*smoothstep(.2,.19,apz);\n    col += tex*smoothstep(.02,.01,abs(apz-.12))*smoothstep(.40,.398,p.y);\n\n    // door with fake 3D shadows\n    float cy = sign(n.x)*(ray.x*n.z-ray.z*n.x); // cross(ray,n)  \n    float top = step(p.y,.37*(1.-clamp(ray.y,-.08,0.)));\n    if(pzctr < min(.1+.05*cy,.1) && pzctr > max(-.1+.05*cy,-.1)) col += top*woodwall(3.*p.zy);\n    \n    return col;\n}\n\n/******************** window *******************/\n\nfloat winMask(in vec3 apw, in vec3 ray)\n{\n    return 1.-smoothstep(.25,.23,apw.z)*smoothstep(.08,.07,apw.y);\n}\n\nfloat lightWinMask(in vec3 apw)\n{\n    return smoothstep(.18,.16,apw.z)*smoothstep(.055,.05,apw.y);\n}\n\nvec3 window2D(in vec3 pw, in vec3 ray, in float lm, in float h)\n{\n    vec3 tex = vec3(.3,.225,.15)*(.1+texture(iChannel0,pw.zy).x);\n    vec3 col = tex*smoothstep(.24,.22,abs(pw.z))*smoothstep(.075,.07,abs(pw.y));\n;\n    \n    // background light with fake3D light source  \n    vec3 litcol = vec3(.05+.02*h,.03-.01*h,.0)*(2.+.5/(length(vec2(pw.z+.2*(ray.x+ray.z),pw.y+.04+.1*ray.y))+.01));\n    col += 1.5*lm*litcol;\n    \n    // framing with fake 3D shade\n    float cy = sign(n.x)*(ray.x*n.z-ray.z*n.x); // cross(ray,n)  \n    vec2 ctr = vec2(.1*sign(pw.z)*cy ,-.05*sign(pw.y)*ray.y );\n    float mask = lm*smoothstep(.18,.16,abs(pw.z)-ctr.x)*smoothstep(.055,.05,abs(pw.y)-ctr.y);\n    col *= 1.-mask;\n    col += mask*litcol;\n    \n    return col;\n}\n\n/**************** balcony window door ***************/\nvec3 windoorFrame(in vec3 p)\n{\n    vec3 tex = vec3(.3,.225,.15)*(.1+texture(iChannel0,3.*p.yz).x);\n    return tex*smoothstep(.095,.085,abs(p.z))*smoothstep(.19,.17,abs(p.y));\n}\n\n\nfloat wdMask(in vec3 apw)\n{\n    return 1.-smoothstep(.1,.09,apw.z)*smoothstep(.2,.18,apw.y);\n}\n\nfloat lightWDMask(in vec3 apw)\n{\n    return smoothstep(.038,.033,abs(apw.z-.045))*smoothstep(.16,.15,apw.y);\n}\n\nvec3 windoor2D(in vec3 p, in vec3 ray, in float lm, in float h)\n{\n    vec3 col = windoorFrame(p)*(1.-lm); \n    col += lm*vec3(.04,.025-.01*h,.01)*(2.+1./(length(vec2(p.z+.2*(ray.x+ray.z),p.y+.05+.1*ray.y))+.02));\n\n    return col;\n}\n\n/******************** Church windows ********************/\n\n// fake 3D //\nvec2 fake3D(in vec3 ray, in vec2 po)\n{\n    vec3 cr = cross(ray,n);\n    vec2 c = vec2(n.x*cr.z-n.z*cr.x, cr.y);   // face selection\n    return vec2(.1*c.y*sign(po.x)*sign(-n.x+n.z),.1*c.x*sign(po.y));\n}\n\nfloat bellWindow(in vec2 ap, in vec2 poa)\n{\n    float wm = smoothstep(.12,.1,ap.x)*smoothstep(.16,.14,ap.y);\n    wm += smoothstep(.12,.1,length(poa));\n    return min(1.,wm);\n}\n\nfloat churchWindow(in vec2 ap, in vec2 poa)\n{\n    float wm = smoothstep(.07,.06,ap.x)*smoothstep(.05,.04,ap.y);\n    wm += smoothstep(.07,.06,length(poa));\n    return min(1.,wm);\n}\n\n\n\n/*******************************************************/\n/*                       Shadows                       */\n/*******************************************************/\n\n/********************* Fake 3D shadow ******************/\nfloat calcShad(in vec2 cell, in vec2 p, in vec2 lit)\n{    \n    vec2 h= getBox(cell);\n    if(h.x < -0.1 && cell != vec2(0)) return 0.;\n        \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n    \n    float co = cos(ang), si = sin(ang);\n    p -= ctr.xz;\n\n    float da = abs(ang-atan(lit.x,lit.y));\n    float sd = sign(dot(lit,vec2(co,-si)));\n    float sina = sin(da);\n    \n    vec2 ps = p * mat2(lit.x,lit.y,-lit.y,lit.x);\n    p *= mat2(co,-si,si,co);\n    \n    float sh = .5*step(sd*p.x,sze.x)*step(p.y,sze.x)*(1.-step(-sze.x+.01,sd*p.x)*step(-sze.x+.01,p.y))*smoothstep(3.,0.,abs(ps.x))*smoothstep(0.15, -.02*abs(ps.x-sze.x), abs(ps.y)-(1.+.414*sina)*sze.x);\n    \n    lit *= mat2(co,-si,si,co);\n    vec2 s =sign(lit);\n\n    float occ = .5*smoothstep(sze.x+.3,sze.x-.1,abs(p.x)) * smoothstep(sze.x+.3,sze.x-.1,abs(p.y));\n    \n    return sh+occ;\n}\n\n\nfloat fakeShade(in vec2 p, in vec2 lit)\n{\n    vec2 cell = floor(p+.5);\n    float shad = 0.;\n    \n    for(float e=-1.; e<=3.; e++){\n        for(float f=-1.; f<=2.; f++){\n            shad = max(shad,calcShad(cell+vec2(e,f), p, lit));\n        }\n    }\n  \n    return 1.-shad;\n}\n/********************* End of fake 3D shadow ******************/\n\n\n\n/************************* 3D shadow **************************/\n\n/*********** simplified checkCell raycast ************/\nfloat shadCheckCell(in vec3 pos, in vec3 ray, in vec2 cell)\n{\n    float t = INFINI;\n    vec2 h = getBox(cell);\n    if(h.x < -.1) return INFINI;\n    \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n    \n    // convert from ray to box space\n    float c = cos(ang), s = sin(ang);\n    mat2 rotY = mat2(c,-s,s,c);\n    \n    // roof 45 deg\n    mat3 rot45 = mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n\n\tray.xz *= rotY;\n    pos -= ctr;\n\tpos.xz *= rotY;\n    \n    // Main body\n    vec4 res = iBox( pos, ray, sze);\n    vec3 p = pos + res.w*ray;\n    if(p.y+abs(p.z) <= sze.y) t = min(t,res.w);\n\n    // Chimney\n    pos.z -= .4;\n    res = iBox( pos, ray, vec3(.1,sze.y+.2,.1) );\n    t = min(t,res.w);\n    pos.z += .4;\n        \n    // Chimney snow cap\n    vec3 O = vec3(0.,sze.y+.2,.4);\n    t = min(t, sphere(pos, ray, O, .13).x);\n\n    \n    pos.y -= sze.y-1.1*sze.x;\n    \n    ray *= rot45;\n    pos *= rot45;\n\n    // Snowy roof\n    res = iSphere4(pos, ray, 1.3*sze.x);\n    t = min(t, res.w);\n\n    return t;\n}\n\n\n/****************** shadows on ground ******************/\nfloat gndShad(in vec3 p, in vec3 lit){\n    vec2 cell = floor(p.xz+.5);\n    p.y+=.001;             // be sure p is above ground surface to avoid ground interception\n    p.xz -= .015*lit.xz;   // to remove some artifacts due to rotation accuracy issue with building\n    float tsh = INFINI;\n    lit -= .1*dither(p);//+.05*n+.1*lit;\n    for(float e=-0.; e<=4.; e++){            // due to fix ambiant light direction\n        for(float f=-1.; f<=2.; f++){        // only checking limited grid area\n            tsh = min(tsh, shadCheckCell(p, lit, cell+vec2(e,f)));\n        }\n    }    \n    return min(.3*tsh+.4,1.);\n}\n\n/********* local shade, for ambiant occlusion *******/\nfloat locShad(in vec3 p, in vec3 lit){\n    vec2 cell = floor(p.xz+.5);\n    float tsh = INFINI;\n    for(float e=-1.; e<=2.; e++){\n        for(float f=-1.; f<=2.; f++){ \n            tsh = min(tsh, shadCheckCell(p, lit, cell+vec2(e,f)));\n        }\n    }    \n\nreturn min(2.*tsh,1.);\n}\n\n/*********************************************************/\n/*                       Lighting                        */\n/*********************************************************/\n\nfloat torch( in vec2 cell, in vec3 p)\n{\n    vec2 h= getBox(cell);\n    if(h.x < 0.) return INFINI;\n    \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n\n    float sx = sze.x+.01;\n    sx *= sign(mod(cell.x,2.)-.5)*sign(mod(cell.y,2.)-.5);  // to change corner side every other one\n\n    vec3 torPos = vec3(sx, .35, sx);\n\n    float c = cos(ang), s = sin(ang);\n    torPos.xz *= mat2(c,s,-s,c);\n    torPos.xz += ctr.xz;\n\n    vec3 u = torPos-p;\n    \n    float l = INFINI;\n    \n    float dt = dot(normalize(u),n);\n    l = length(u)/smoothstep(-.2,0.2,dt);\n\n    return l;\n}\n\nvec3 torchLight(in vec3 p)\n{\n    vec2 cell = floor(p.xz+.5);\n    float d = INFINI;\n    //p -= .1*dither(p)+.05*n;\n    for(float e=-3.; e<=3.; e++){\n        for(float f=-3.; f<=3.; f++){\n            d = min(d,torch(cell+vec2(e,f), p));\n        }\n    }\n    return vec3(.5,.3,.1)*max(0.,(1./(d*d+.1)-.1));\n}\n\n/******************************************************************/\n/*                        CAM functions                          */\n/******************************************************************/\n \nvec3 getCamPos(out vec3 camTarget)\n{\n    vec3 p;\n    if(iTime < 30.){\n        float r = 15.;//+3.*cos(.1*iTime);\n        float a = -.075*iTime-2.5;\n        p = vec3(r*cos(a),.25,r*sin(a));\n        camTarget = .5*p;    \n    }\n    else if(iTime < 52.){\n        float ti = iTime-30.;\n        camTarget.y = 1.;\n        p.y = .25;\n        float tiA = .7*ti;\n        float tiB = .4*ti;\n        float tr = smoothstep(15.,20.,ti);\n        tiA = -.1*tiA+2.8;\n        tiB -= 17.;\n        p.xz = mix(11.*vec2(cos(tiA), sin(tiA)), vec2(.15*tiB+1.4, -tiB), tr);\n        camTarget.xz = mix(vec2(.35,7.), vec2(0), tr);\n    }\n    else if(iTime<94.){\n        p.y = .25;\n        float tiA = .4*(iTime-30.);\n        float tiB = .05*(iTime-30.)+6.3;\n        tiA -= 17.+smoothstep(58.,64.,iTime);\n        float tr = smoothstep(59.,63.,iTime);\n        float s = smoothstep(65.,72.,iTime);\n        float sf = smoothstep(82.,90.,iTime);\n        float r = 5.-1.8*s-1.*sf;\n        p.xz = mix(vec2(.15*tiA+1.4, -tiA), r*vec2(cos(tiB),sin(tiB)), tr);\n        camTarget = vec3(-3.*s+4.*sf, 1.+.6*sf, -3.*s+4.*sf);\n    }\n    else if(iTime<120.){\n        float ti = iTime-94.;\n        float s = smoothstep(12.,27.,ti);\n        float rot = smoothstep(16.,27.,ti);\n        float ey = smoothstep(13.,18.,ti);\n        ti= .3*ti-8.;\n        camTarget = (1.-s)*vec3(-ti,.25+ey*.7,-1.73*ti-6.1+.13*sin(ti+1.))+vec3(0,s*1.5,0);\n        ti -= .1;\n        p = mix(vec3(-ti,.23+s*2.3,-1.73*ti-6.1), vec3(4.*cos(-.5*ti-2.5),2.3,4.*sin(-.5*ti-2.5)), rot);\n    }\n    else{\n        float ti = iTime-94.;\n        ti= -.15*ti+1.55;\n        float tr = smoothstep(121.,140.,iTime);\n        float r = 10.+5.*sin(.4*ti);\n        p = vec3(r*cos(.7*ti),2.5,r*sin(.7*ti));\n        p = mix(vec3(4.*cos(ti),2.3,4.*sin(ti)), p, tr);\n        p.y -= 2.1*smoothstep(9.,13.,length(p.xz));\n        camTarget = mix(vec3(0,1.5,0), .5*p, tr);\n    }\n    \n/*    float ti = -.2*iTime+4.;\n    float r = 10.+5.*sin(.4*ti);\n    p = vec3(r*cos(.7*ti),2.5,r*sin(.7*ti));\n    p.y -= 2.1*smoothstep(9.,13.,length(p.xz));\n    camTarget = .8*p;\n    */\n    return p;\n}\n\n// used for cam path equation setting\nvec3 laserBeam(in vec3 p)\n{\n    vec3 c = vec3(0);\n    c.r += smoothstep(.02,0.,abs(1.73*p.x-p.z-6.1));\n    c.r += smoothstep(.02,.0,abs(length(p.xz)-11.)) + smoothstep(.02,0.,abs(p.x+.15*p.z-1.4)) + smoothstep(.02,.0,abs(length(p.xz)-5.1));\n    return c;\n}\n\nvec3 mouseCam(in vec3 camTarget)\n{\n    float \trau = 12.,\n            alpha = iMouse.x/iResolution.x*4.*PI,\n            theta = (iMouse.y+.001)/iResolution.y*PI+ (PI/2.0001);\t// +0.001 to avoid black horizontal line\n \n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\n\n/******************************************************************/\n/*                        MAIN functions                          */\n/******************************************************************/\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 1.5;\n    vec3 ww = normalize( camTarget - pos);\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    vec3 lit = vec3(.9759,.09759,.19518);   // light dir = (1.,.1,.2)\n    vec3 camTarget = vec3(0), pos = vec3(15.,1.,15.);\n   \n    if(iMouse.x > 2.){\n        camTarget = vec3(0.,1.,0.);\n        pos = mouseCam(camTarget);\n        pos.y = max(.1+RVAL-sqrt(RVAL*RVAL-pos.x*pos.x-pos.z*pos.z),pos.y);\n    }\n    else{\n        pos = getCamPos(camTarget); \n    }\n    \n    vec3 ray = getRay(st, pos,camTarget);\n    \n    \n    runGrid(pos,ray);\n\n#ifdef WITH_CHURCH\n    checkChurch(pos,ray);\n#endif\n\n    vec3 p = pos;\n    if(t<INFINI) p += t*ray; \n    \n    vec3 outp = p+.0001*n;\n    float lm = 0., lm2 = 0., dm = 0.;               // light mask\n    \n    // GROUND with shadows\n    if(hitObj == GND){\n        ray.y = abs(ray.y);\n        float df = texture(iChannel0,.5*p.xz).x-texture(iChannel0,.5*p.xz+vec2(.001)).x;\n        vec2 e = vec2(.001*length(p.xz),.3*atan(p.z,abs(p.x)));\n        col += .6+snowGlitt(p,ray)+.1*df+.4*(texture(iChannel0,.0005*p.xz).x-texture(iChannel0,.0005*p.xz+vec2(.00001*t)).x);   // gnd snow \n        col *= smoothstep(600.,0.,t);                           // fading to the mountains\n        col += min(.3,.0042*p.y*texture(iChannel0,e).x);        // snow and rocks over mountains\n        col += p.y*vec3(0.,.00015,.0002)*ray.x;   // color correction, magenta over exposed top\n        col *= .4+.6*dot(n,lit);\n        col *= fakeShade(p.xz, lit.xz);    // fake shadows (smooth and fast) \n        col *= 1.-.5*smoothstep(2.2,0.,abs(p.x+.4))*smoothstep(1.,0.,abs(p.z-.9))*step(.9,p.z)*smoothstep(.85,.75,p.x);    // towerbell correction        \n        //col *= gndShad(p,lit);               // more real (3D sahdows) slower and need dithering\n    }\n    // BODY bulding with windows and doors\n    else if(hitObj == BODY){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        \n        col += .3*stonewall(p.zy+p.xy);\n         \n        // windows\n        float dctr = 1.6*boxH-.4;    // door center\n        vec3 pw = vec3(p.x, p.y-.3,fract(3.*p.z)-.5);\n        vec3 apw = abs(pw);\n        float fpz = floor(3.*p.z);\n        if(fpz+1.<dctr-.15 || fpz>dctr+.15){\n            lm = lightWinMask(apw);\n            col *= winMask(apw, ray);\n            col += window2D(pw, ray, lm, boxH); // fake 3D window\n        }\n        // window for level2 no balcony\n        if( boxSze.y<1.6 ){\n            pw = vec3(p.x, p.y-.8,fract(4.*p.z+.5)*mod(floor(4.*p.z+.5),2.)-.5);\n            apw = abs(pw);\n            lm2 = lightWinMask(apw);\n            col *= winMask(apw, ray);\n            col += window2D(pw, ray,lm2, boxH);\n        }\n        // balcony door\n        else{\n            pw = vec3(p.x, p.y-.85, p.z);\n            apw = abs(pw);\n            lm2 = lightWDMask(apw);\n            col *= wdMask(apw);\n            col += windoor2D(pw, ray, lm2, boxH);\n        }\n\n        // door\n        float pzCtr = p.z-dctr;   // pos from door center\n        dm = doorMask(p, ray, pzCtr);\n        col *= dm;\n        col += door2D(p, ray, pzCtr);      // fake 3D door\n        \n        // shading and lights\n        float rf = .65*(p.y+abs(p.z))/boxSze.y;    // roof occlusion\n        rf *= rf*rf*rf;\n        col -= rf*(1.-lm2);\n        \n        float gi = .6+.4*dot(n,lit);    // gen. illuminitaion\n        \n        float ls = 1.;\n        if(dot(n,lit)>0.) ls = locShad(outp,lit);\n        lm += lm2;\n        lm *= dm;\n        col *= lm+(1.-lm)*ls*gi;     // removing window mask to avoid erroneous shade on windows light     \n    }\n    // CHIMNEY\n    else if(hitObj == CHEM){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        col += .3*stonewall(p.zy+p.xy);\n        col *= .6+.4*dot(n,lit);\n    }\n    // BALCONY\n    else if(hitObj == BALCON){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        if(p.y > .77) col += .3;\n        else col += woodwall(10.*n.x*p.zy + 2.*n.y*p.xz);\n        col *= .6+.4*dot(n,lit);\n    }\n    // snowy ROOF\n    else if(hitObj == ROOF){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        col += .4;\n        col += snowGlitt(p,ray);\n        col *= .6+.4*dot(n,lit);\n        if(dot(n,lit)>0.) col *= .6+.4*locShad(outp,lit);     \n    }\n    // wooden CEILING below roof\n    else if(hitObj == CEIL){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        col += .3*woodwall(2.5*p.xy);\n        p.z*=8.;\n        col -= .1*(smoothstep(.2+.3*texture(iChannel0,.1*p.xz).x,.4,abs(fract(p.z)-.5)));\n        col *= .5+.5*dot(-ray,lit);\n    }\n    // TORCH street light\n    else if(hitObj == TORCH){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        float sx = boxSze.x+.01;\n        sx *= sign(mod(boxCell.x,2.)-.5)*sign(mod(boxCell.y,2.)-.5);\n        p -= vec3(sx, .35, sx);\n        float l = length(p);\n        col += vec3(.00024,.00012,.00004)/(l*l);\n        col *= step(abs(p.x),.007)+step(abs(p.y),.027)+step(abs(p.z),.007);\n    }\n    \n#ifdef WITH_CHURCH\n\n    // CHURCH\n    else if(hitObj == CHURCH){\n        col += .4*stonewall(p.zy+p.xy);\n        col  *= .6+.4*dot(n,lit); \n        p += .001*n;                   // proximity occlusion\n        if(dot(n,lit)>0.) col *= locShad(p,lit);     \n        \n        \n        /** lateral windows **/\n        vec2 po = vec2(fract(1.7*p.x-.3)-.5, p.y-.35);\n        vec2 ap = abs(po);           // center of the window\n        vec2 poa = po-vec2(0.,.05);  // center of the arche\n        \n        // window mask\n        float wm = churchWindow(ap,poa);\n        \n        // moving center for the black mask (fake 3D)\n        vec2 ctr = .7*fake3D(ray,po);\n               \n        // black mask. same as window mask but with shifted center\n        ap = abs(ap-ctr);\n        poa -= sign(po)*ctr;\n        float bm = churchWindow(ap,poa);\n                \n        ap*=vec2(20.,5.);\n        ap.x = fract(ap.x)-.5;\n        vec3 litcol = vec3(.05,.04,.02)*(1.+2./length(ap));\n\n        // adding texture with brighter color on window mask (sides)\n        col += wm*vec3(.3,.24,.12);\n        // removing shifted hole part (black), in respect of window limits.\n        col *= 1.-wm*bm;\n        \n        po -= sign(po)*ctr;\n        po *= 30.;\n        col += bm*wm*litcol*(.3+.7*H12(floor(vec2(po.x+po.y,po.x-po.y))+floor(1.7*p.x-.3)+12.34));   // inside lights        \n        col *= 1.-wm*bm*(smoothstep(.9,1.,fract(po.x+po.y))+smoothstep(.9,1.,fract(po.x-po.y)));  // window grid\n        \n        \n        /** top round windows **/\n        poa = vec2(p.z, p.y-1.1);\n        wm = smoothstep(.1,.09,length(poa));\n        ctr = .7*fake3D(ray,poa);\n        poa -= sign(poa)*ctr;\n        float lpoa = length(poa);\n        bm =smoothstep(.1,.09,lpoa);\n        float ang = 2.*atan(poa.y,poa.x);\n        litcol = vec3(.04,.032,.016)/(lpoa+.02)*(.5+.5*H12(vec2(floor(ang))))*(1.-smoothstep(.8,1.,fract(ang)));\n        col += wm*vec3(.3,.24,.12);\n        col *= 1.-wm*bm;\n        col += bm*wm*litcol;\n        \n    }    \n    else if(hitObj == NEF){\n        vec2 a = vec2(atan(p.z,p.x),2.*p.y);\n        col += .4*stonewall(a);\n        col  *= .6+.4*dot(n,lit); \n        p += .001*n;                   // proximity occlusion\n        if(dot(n,lit)>0.) col *= locShad(p,lit);   \n        \n        \n        /** slot windows **/\n        vec2 po = vec2(fract(2.5*a.x-.5)-.5, a.y-.55);\n        vec2 ap = abs(po);           // center of the window\n         \n        float wm = smoothstep(.03,.02,ap.x)*smoothstep(.07,.06,ap.y);\n        vec2 ctr = .7*fake3D(ray,po);\n        ap = abs(ap-ctr);\n        float bm = smoothstep(.03,.02,ap.x)*smoothstep(.07,.06,ap.y);\n       \n        ap.y-=.1;\n        vec3 litcol = vec3(.05,.04,.02)*(.4/length(ap));\n        col += wm*vec3(.4,.32,.16);\n        col *= 1.-wm*bm;\n        col += bm*wm*litcol;\n        \n    }\n    else if(hitObj == TOWER){\n        //vec3 o = vec3(.4,1.8,1.);  // center of bell tower for memory\n        vec3 an = abs(n);\n        vec2 po = an.x*(p.zy-vec2(1.,1.8))+an.z*(p.xy-vec2(.4,1.8));   // face selection\n        vec2 ap = abs(po);           // center of the window\n        vec2 poa = po-vec2(0.,.16);  // center of the arche\n        \n        // window mask\n        float wm = bellWindow(ap,poa);\n        \n        // moving center for the black mask (fake 3D)\n        vec2 ctr = fake3D(ray,po);\n               \n        // black mask. same as window mask but with shifted center\n        ap = abs(ap-ctr);\n        poa -= sign(po)*ctr;\n        float bm = bellWindow(ap,poa);\n\n        // adding texture with darker color on window mask (sides)\n        col += (.4-.2*wm)*stonewall(2.*po);\n        // removing shifted hole part (black), in respect of window limits.\n        col *= 1.-bm*wm;\n        \n        col  *= .6+.4*dot(n,lit); \n        p += .001*n;                   // proximity occlusion\n        if(dot(n,lit)>0.) col *= locShad(p,lit);     \n    }\n    else if(hitObj == STEEP){\n        float f = smoothstep(.0,.15,(3.5-p.y)*texture(iChannel0,n.z*p.yx+n.x*p.yz).x);\n        col += (1.-f)*vec3(.43,.4,.37)*stonewall(vec2(.5*(p.z+p.x),.3*p.y));\n        col += .4*f;\n        col  *= .6+.4*dot(n,lit); \n    }\n    \n#endif\n\n    // SKY\n    else col += sky(ray.x, ray.y);\n    \n    // Overall illumination by torch\n    if(hitObj != SKY) col *= 1.+(1.-step(0.05,lm))*torchLight(outp)/(.6+.4*dot(n,lit));\n\n    //if(hitObj == GND) col += laserBeam(p);\n\n    fragColor = vec4(col,1.0);\n}\n\n \n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27115, "src": "https://soundcloud.com/desert-trax/carbon-based-lifeforms-rca", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2Xz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2751, 2751, 2770, 2770, 2887], [2889, 2889, 2907, 2907, 3072], [3074, 3074, 3093, 3093, 3218], [3221, 3221, 3244, 3244, 3287], [3465, 3465, 3504, 3504, 3570], [3572, 3602, 3652, 3693, 4030], [4032, 4122, 4175, 4282, 6370], [6372, 6372, 6435, 6435, 6745], [6747, 6747, 6806, 6806, 7104], [7107, 7107, 7158, 7158, 7548], [7551, 7551, 7605, 7605, 8286], [8289, 8289, 8341, 8341, 9473], [9650, 9683, 9736, 9736, 9919], [10275, 10298, 10354, 10354, 13332], [13509, 13509, 13548, 13548, 15106], [15283, 15342, 15384, 15384, 15593], [15595, 15622, 15666, 15666, 17040], [17042, 17216, 17250, 17250, 17345], [17347, 17347, 17387, 17387, 17516], [17519, 17519, 17547, 17547, 17903], [17905, 17905, 17931, 17931, 18163], [18319, 18367, 18423, 18423, 18637], [18639, 18639, 18692, 18692, 19241], [19294, 19294, 19335, 19335, 19404], [19406, 19406, 19439, 19439, 19506], [19508, 19508, 19573, 19573, 20249], [20251, 20306, 20336, 20336, 20482], [20485, 20485, 20512, 20512, 20579], [20581, 20581, 20613, 20613, 20691], [20693, 20693, 20758, 20758, 20924], [20986, 21000, 21038, 21038, 21201], [21203, 21203, 21246, 21246, 21378], [21380, 21380, 21425, 21425, 21559], [21738, 21796, 21850, 21850, 22825], [22828, 22828, 22869, 22869, 23100], [23235, 23291, 23352, 23352, 24470], [24473, 24531, 24569, 24569, 25141], [25143, 25198, 25236, 25236, 25478], [25661, 25661, 25700, 25700, 26410], [26412, 26412, 26440, 26440, 26716], [26926, 26926, 26962, 26962, 29015], [29017, 29055, 29082, 29082, 29311], [29313, 29313, 29347, 29347, 29619], [29830, 29830, 29886, 29886, 30091]]}
{"id": "sdBSzc", "name": "scene abc", "author": "sirjofri", "description": "sdf raymarching scene", "tags": ["raymarching", "sdf"], "likes": 3, "viewed": 217, "published": 3, "date": "1620726612", "time_retrieved": "2024-07-30T19:20:52.335922", "image_code": "vec3 camrot = vec3(-0.4, 0.2, 0.);\nvec3 campos = vec3(3., 10., 4.);\nvec3 ambi = vec3(0.6, .8, .9);\nvec3 lightA = vec3(9., 10., 10.);\nvec3 lightB = vec3(20., 8., 7.);\nvec3 lightC = vec3(6., -12., 2.);\nvec3 lightcol = vec3(1., .9, .7);\nfloat ballspeed = 2.;\n\nfloat sdist = .0001;\n\nvec3 calcRayDir(vec3 d)\n{\n    mat3 yaw = mat3(\n        cos(camrot.x), -sin(camrot.x), 0.,\n        sin(camrot.x),  cos(camrot.x), 0.,\n        0.           ,  0.           , 1.\n    );\n    mat3 pitch = mat3(\n        1.,            0.,             0.,\n        0., cos(camrot.y), -sin(camrot.y),\n        0., sin(camrot.y),  cos(camrot.y)\n    );\n    mat3 roll = mat3(\n        cos(camrot.z),  0., sin(camrot.z),\n        0.,             1.,            0.,\n        -sin(camrot.z), 0., cos(camrot.z)\n    );\n    \n    d *= roll;\n    d *= pitch;\n    d *= yaw;\n    return normalize(d);\n}\n\nfloat noise(vec3 pos, int n)\n{\n    float x = 0.;\n    float on = float(n);\n    while (n-- > 0){\n        float y = .04-float(n)/on*.01;\n        x += cos(pos.y+sin(pos.x)*2.+sin((pos.x-pos.y)*.3)*3.)*y;\n        pos *= 4.59;\n    }\n    return x;\n}\n\nvec2 ground(vec3 pos)\n{\n    float d = pos.z\n        + smoothstep(0., 1., pow((pos.x+sin(pos.y*.6))*.4, 2.) + noise(pos*.4, 2)*2.)*(-2.)+2.\n        + sin(pos.x*.3+cos(pos.y*.4+1.))*.9\n        + sin(pos.x*1.+cos(pos.y*.5))*.1\n        + noise(pos*.8+sin(pos.y*1.2+pos.x*1.1+iTime*8.)*.02, 5);\n    return vec2(d, d < sdist ? 1. : 0.);\n}\n\nvec2 mysphere(vec3 pos)\n{\n    float d = sdSphere(vec3(-.6+cos(iTime*ballspeed), -7.+sin(iTime), .7-sin(iTime*ballspeed)), 1., vec3(pos.x, mod(pos.y, -30.), pos.z));\n    return vec2(d, d < sdist ? 2. : 0.);\n}\n\nvec2 dist(vec3 pos)\n{\n    vec2 a = mysphere(pos);\n    vec2 b = ground(pos);\n    return vec2(\n        min(a.x, b.x),\n        max(a.y, b.y)\n    );\n}\n\nvec2 march(vec3 ro, vec3 rd, int steps)\n{\n    float d = 0.;\n    for (int i=0; i<steps; i++) {\n        vec2 n = dist(ro + rd*d);\n        d += n.x;\n        if (n.x < sdist)\n            return vec2(d, n.y);\n    }\n    return vec2(100., 0.);\n}\n\nfloat shadow(vec3 ro, vec3 l)\n{\n    vec3 rd = normalize(l - ro);\n    float d = march(ro+rd*.5, rd, 128).x;\n    return d*.01;\n}\n\n/* Thanks iq */\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.2;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.);\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*dist(p+e*h).x; /* btw: s/pos/p */\n    }\n    return normalize(n);\n}\n\nfloat calcAO(vec3 pos, vec3 normal)\n{\n    float dst = 1.;\n    float d = dist(pos + normal*dst).x;\n    return clamp(mix(.8, 1., d/dst), 0., 1.);\n}\n\nvec3 color(vec3 p, float mat)\n{\n    vec3 gridcol = mix(vec3(.2, .4, 0.), vec3(0.4, .8, 0.), worldGrid(p*4.));\n    vec3 ballcol = vec3(.1, .3, 1.);\n    if (mat <= 0.1)\n        return gridcol;\n    if (mat <= 1.1)\n        return gridcol;\n    if (mat <= 2.1)\n        return ballcol;\n    return vec3(0.);\n}\n\nvec3 pp(vec3 col)\n{\n    return pow(col, vec3(1./1.8));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= iResolution.y/iResolution.x/2.;\n    uv -= .5;\n    \n    camrot.z = sin(iTime*2.5)*.02;\n    camrot.y = .2 + sin(iTime*ballspeed)*.03 +sin(iTime*.9)*.02;\n    camrot.x = -.4 + sin(iTime*ballspeed)*.03 +sin(iTime*2.3)*.005;\n    vec3 ro = campos;\n    vec3 rd = calcRayDir(vec3(uv.x, -2., uv.y));\n    \n    vec2 mr = march(ro, rd, 256);\n    float d = mr.x;\n    vec3 wp = ro + rd*d;\n    \n    vec3 norm = calcNormal(wp);\n    vec3 nao;\n    nao.x = mix(.1, .5, dot(normalize(lightA-wp), norm));\n    nao.y = mix(.1, .5, dot(normalize(lightB-wp), norm));\n    nao.z = mix(.1, .5, dot(normalize(lightC-wp), norm));\n    float ns = clamp(nao.x + nao.y + nao.z, 0., 1.);\n    float ao = clamp(calcAO(wp, norm), 0., 1.);\n    ao *= ns;\n    \n    vec3 s;\n    s.x = mix(0., .3, shadow(wp, lightA));\n    s.y = mix(0., .3, shadow(wp, lightB));\n    s.z = mix(0., .2, shadow(wp, lightC));\n    vec3 lightmix = (s.x+s.y+s.z)*lightcol + .01*ambi;\n\n    vec3 col = color(wp, mr.y);\n    col *= lightmix;\n    col *= ao;\n    \n    float dfog = clamp(mix(0., 1., d*.01), 0., 1.);\n    col = mix(col, ambi*.9, dfog);\n    col = pp(col);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "float worldGrid(vec3 pos)\n{\n    float x = smoothstep(-.2, .2, sin(pos.x));\n    float y = smoothstep(-.2, .2, sin(pos.y));\n    return (x+y)/2.;\n}\n\nfloat sdSphere(vec3 pos, float r, vec3 p)\n{\n    return distance(pos, p) - r;\n}\n\nfloat sdBox(vec3 pos, vec3 dim, vec3 p)\n{\n    return length(max(vec3(0), abs(p-pos)-dim));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBSzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 304, 304, 852], [854, 854, 884, 884, 1096], [1098, 1098, 1121, 1121, 1430], [1432, 1432, 1457, 1457, 1639], [1641, 1641, 1662, 1662, 1787], [1789, 1789, 1830, 1830, 2027], [2029, 2029, 2060, 2060, 2155], [2157, 2173, 2198, 2198, 2469], [2471, 2471, 2508, 2508, 2616], [2618, 2618, 2649, 2649, 2919], [2921, 2921, 2940, 2940, 2977], [2979, 2979, 3036, 3036, 4221]]}
{"id": "Ns2SR3", "name": "Fork video wave bkindler 239", "author": "bkindler", "description": "Simple video waveform editor", "tags": ["video"], "likes": 0, "viewed": 302, "published": 3, "date": "1620686650", "time_retrieved": "2024-07-30T19:20:53.083922", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u = fragCoord.x / iResolution.x * 3.0;\n    vec2 coords;\n    float accum = 1.0 / iResolution.y;\n    accum *= 20.;\n\n    vec4 col = vec4(0., 0., 0., 1.);\n    float ys = (fragCoord.xy[1] - 1.0)/ iResolution.y;\n    float ye = (fragCoord.xy[1]) / iResolution.y;\n\n    for (int y = 1; y < int(iChannelResolution[0].y); ++y){\n        coords.x = fragCoord.x / (iResolution.x / 3.0);\n        coords.y = float(y) / iChannelResolution[0].y;\n        vec4 texcol;\n        if (u <= 1.0){\n            texcol = texture(iChannel0, coords);\n            if (texcol.x > ys && texcol.x < ye){\n                col += vec4(accum, 0., 0., 0.);\n            }\n        }\n\n        if (u > 1.0 && u <= 2.0){\n            coords.x -= 1.;\n            texcol = texture(iChannel0, coords);\n            if (texcol.y > ys && texcol.y < ye){\n                col += vec4(0., accum, 0., 0.);\n            }\n        }\n        if (u > 2.0){\n            coords.x -= 2.;\n            texcol = texture(iChannel0, coords);\n            if (texcol.z > ys && texcol.z < ye){\n                col += vec4(0., 0., accum, 0.);\n            }\n        }\n    }\n\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2SR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1217]]}
{"id": "NdBXR3", "name": "denoiser test", "author": "mdb", "description": "test for removing noise from an image with low spp", "tags": ["globalillumination"], "likes": 15, "viewed": 744, "published": 3, "date": "1620668034", "time_retrieved": "2024-07-30T19:20:54.018424", "image_code": "#define Kernel 8\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    float z = 0.0;\n    float k =  (iMouse.x == 0.0) ? 0.5 + 0.5*cos(iTime) : iMouse.x/iResolution.x;\n    if(uv.x > k){\n        vec4 n0 = texture(iChannel1, uv).xyzw;\n\n        //create the 1-D kernel\n        float sigma = 6.0;\n        float kernel[Kernel*2+1];\n        for (int j = 0; j <= Kernel; ++j)\n        {\n            kernel[Kernel+j] = kernel[Kernel-j] = normpdf(float(j), sigma);\n        }\n\n        for(int i = - Kernel; i <= Kernel; i++){\n        for(int j = - Kernel; j <= Kernel; j++){\n            vec4 n = texture(iChannel1, uv + vec2(i, j)/iResolution.xy);\n            if (dot(n.xyz*2.0-1.0, n0.xyz*2.0-1.0)>0.95 && abs(n0.w-n.w)<0.03){\n                col += kernel[Kernel+j]*kernel[Kernel+i]*texture(iChannel0, uv + vec2(i, j)/iResolution.xy).rgb;\n                z += kernel[Kernel+j]*kernel[Kernel+i];\n            }\n        }\n        }\n        col /= z;\n    \n    }else{\n        col =  texture(iChannel0, uv).rgb;\n    }\n    \n    //col *= 10.0;\n    col = 1.0-exp(-9.0*col); \n    col = pow(col, vec3(0.7));\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.8 );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAXDEPTH 4\n#define PI 3.14159265359\n#define MAXSTEP 400\n#define MAXDIST 10.0\n#define MINDIST 0.001\nconst vec3 camPos = vec3(0.0, 0.3, -0.4);\n//const vec3 camPos = vec3(0.0, 0.7, -0.06); // up view\nconst vec3 target = vec3(0.0, 0.2, 0.0);\nstruct Mat{vec3 c, e;}; //color, emission\n\n// pseudo random numbers////////////////////////////////////////////////\nfloat seed = 0.0;\n\nvoid initSeed(vec2 uv){\n    seed = mod(fract(sin(uv.x*875.87+12.8+iTime)*776.978)*2378.0 + fract(sin(uv.y*594.87+57.75)*689.655)*8938.0\n            + fract(sin(iTime*798.43+89.24)*875.365)*5685.0 ,10000.0);\n}\nvoid next(){seed=mod(seed*348.12+77.0, 10000.0);}\nfloat random(){\n    next();\n    return seed/10000.0;\n}\n/////////////////////////////////////////////////////////////////////////\n\nfloat sdPerso(vec3 pos){\n    float d = 1e5;\n    vec3 p;\n    //stick\n    p = pos - vec3(0.0, 0.2, 0.0);\n    d = min(d, sdCylinder(p, vec2(0.01, 0.2))-0.003);\n    \n    p = pos-vec3(-0.05, 0.36, 0.0);\n    d = min(d, sdCappedTorus(p, vec2(0.866025,-0.5), 0.04, 0.01));\n    p = pos-vec3(-0.05, 0.36, 0.0);\n    d = min(d, sdSphere(p, 0.01));\n    p = pos-vec3(-0.11, 0.35, 0.0);\n    d = min(d, sdSphere(p, 0.01));\n    \n    float teta = 1.0;\n    p = mat3x3(cos(teta), 0.0, sin(teta),\n                  0.0   , 1.0,   0.0,\n              -sin(teta), 0.0, cos(teta))*(pos - vec3(-0.11, 0.25, 0.0));\n    d = min(d, sdBoundingBox(p, vec3(0.06, 0.08, 0.06), 0.005 )); \n    //body\n    \n    //d = min(d, sdCappedCone(pos, vec3(0.05, 0.16, 0.0), vec3(0.13, 0.03, 0.0), 0.05, 0.12));\n    p = pos;\n    p.z = abs(p.z);\n    d = min(d, sdCapsule(p, vec3(0.1, 0.0, 0.02), vec3(0.25, 0.1, 0.05), 0.04 ));\n    d = min(d, sdCapsule(p, vec3(0.25, 0.1, 0.05), vec3(0.31, 0.01, 0.03), 0.03 ));\n    d = min(d, sdCapsule(p, vec3(0.07, 0.15, 0.0), vec3(0.1, 0.0, 0.0), 0.04 ));\n    d = min(d, sdCapsule(p, vec3(0.06, 0.1, 0.08), vec3(0.06, 0.18, 0.08), 0.02 ));\n    //head\n    p = pos-vec3(0.07, 0.25, 0.0);\n    d = min(d, sdSphere(p, 0.05));\n    p -= vec3(0.0, 0.08, 0.0);\n    d = min(d, sdCone(p, vec2(0.1, 0.04), 0.05 ));  \n    \n    return d;\n}\n\n\nfloat DE(vec3 pos, out Mat obj){\n    float dist = 1e6;\n    float t;\n    \n    //working light\n    //t = sdSphere(pos - vec3(-2.0, 2.0, -2.0), 1.8);\n    //if (t<dist){dist = t; obj = Mat(vec3(1.0), vec3(1.0));}\n    \n    //ground\n    t = sdPlane(pos);\n    if (t<dist){dist = t; obj = Mat(vec3(0.1), vec3(0.0));}\n    \n    //backbround sphere\n    t = -sdSphere(pos, 3.0);\n    if (t<dist){dist = t; obj = Mat(vec3(0.0), vec3(0.0));}\n    \n    //perso\n    t = sdPerso(pos);\n    if (t<dist){dist = t; obj = Mat(vec3(0.1), vec3(0.0));}\n    \n    //lights\n    t = sdCapsule(pos, vec3(-0.11, 0.22, 0.0), vec3(-0.11, 0.28, 0.0), 0.05);\n    if (t<dist){dist = t; obj = Mat(vec3(0.8, 0.0, 0.0), vec3(40.0, 13.0, 13.0));}\n    vec3 p = pos - vec3(0.105, 0.25, -0.028);\n    p.z = abs(p.z);\n    t = sdSphere(p, 0.01);\n    if (t<dist){dist = t; obj = Mat(vec3(0.8, 0.0, 0.0), vec3(10.0));}\n    \n    return dist;\n}\n\nfloat intersect(vec3 ro, vec3 rd, out vec3 normal, out Mat obj){\n    normal = rd;\n    obj = Mat(vec3(0.9, 0.1, 0.1), vec3(0.0));\n    float t = 0.0;\n    for(int i = 0; i < MAXSTEP; i++){\n        vec3 p = ro + t * rd;\n        float delta = DE(p, obj);\n        t += delta;\n        if(t > MAXDIST)return -1.0;\n        if(abs(delta) < MINDIST){//end\n            float off=0.001;\n            Mat m;\n            normal = normalize(vec3(DE(p+vec3(off,0,0), m)-DE(p-vec3(off,0,0), m),\n                                    DE(p+vec3(0,off,0), m)-DE(p-vec3(0,off,0), m),\n                                    DE(p+vec3(0,0,off), m)-DE(p-vec3(0,0,off), m))); \n            break;\n        }\n        \n    }\n    return t;\n}\n\nvec3 newDir(vec3 n){\n    float teta = random()*2.0*PI;\n    float z = random()*2.0-1.0;\n    vec3 v = vec3(sqrt(1.0-z*z)*cos(teta), sqrt(1.0-z*z)*sin(teta), z); \n    if (dot(n, v)<0.0);\n        return -v;\n    return v;\n}\n\nvec3 march(vec3 ro, vec3 rd){\n\tvec3 col = vec3(0.0);\n\tvec3 mask = vec3(1.0);\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tMat obj;\n        vec3 n;\n        float t = intersect(ro, rd, n, obj);\n        if(t<=0.0)break;\n        \n\t\tro = ro + t * rd + n * MINDIST * 3.0;\n\t\trd = newDir(n);\n        \n\t\tcol += mask * obj.e;\n\t\tmask *= obj.c;\n        \n        if (dot(mask, mask)<0.00001)break;\n\t\t\n\t}\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    initSeed(uv);\n    \n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n        \n    vec3 col = march(camPos, rd);\n    \n    \n    \n    vec3 last = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    float weight = 1.0/float(iFrame + 1);\n    col = col * weight + last * (1.0-weight);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// https://www.shadertoy.com/view/Xds3zN\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\n//smouth min to blend material\nfloat smin( float a, float b, float k )\n{\n    if (k <=0.)return min(a,b);\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}", "buffer_b_code": "\n#define PI 3.14159265359\n#define MAXSTEP 400\n#define MAXDIST 10.0\n#define MINDIST 0.001\nconst vec3 camPos = vec3(0.0, 0.3, -0.4);\n//const vec3 camPos = vec3(0.0, 0.7, -0.06); // up view\nconst vec3 target = vec3(0.0, 0.2, 0.0);\nstruct Mat{vec3 c, e;}; //color, emission\n\n// pseudo random numbers////////////////////////////////////////////////\nfloat seed = 0.0;\n\nvoid initSeed(vec2 uv){\n    seed = mod(fract(sin(uv.x*875.87+12.8+iTime)*776.978)*2378.0 + fract(sin(uv.y*594.87+57.75)*689.655)*8938.0\n            + fract(sin(iTime*798.43+89.24)*875.365)*5685.0 ,10000.0);\n}\nvoid next(){seed=mod(seed*348.12+77.0, 10000.0);}\nfloat random(){\n    next();\n    return seed/10000.0;\n}\n/////////////////////////////////////////////////////////////////////////\n\nfloat sdPerso(vec3 pos){\n    float d = 1e5;\n    vec3 p;\n    //stick\n    p = pos - vec3(0.0, 0.2, 0.0);\n    d = min(d, sdCylinder(p, vec2(0.01, 0.2))-0.003);\n    \n    p = pos-vec3(-0.05, 0.36, 0.0);\n    d = min(d, sdCappedTorus(p, vec2(0.866025,-0.5), 0.04, 0.01));\n    p = pos-vec3(-0.05, 0.36, 0.0);\n    d = min(d, sdSphere(p, 0.01));\n    p = pos-vec3(-0.11, 0.35, 0.0);\n    d = min(d, sdSphere(p, 0.01));\n    \n    float teta = 1.0;\n    p = mat3x3(cos(teta), 0.0, sin(teta),\n                  0.0   , 1.0,   0.0,\n              -sin(teta), 0.0, cos(teta))*(pos - vec3(-0.11, 0.25, 0.0));\n    d = min(d, sdBoundingBox(p, vec3(0.06, 0.08, 0.06), 0.005 )); \n    //body\n    \n    //d = min(d, sdCappedCone(pos, vec3(0.05, 0.16, 0.0), vec3(0.13, 0.03, 0.0), 0.05, 0.12));\n    p = pos;\n    p.z = abs(p.z);\n    d = min(d, sdCapsule(p, vec3(0.1, 0.0, 0.02), vec3(0.25, 0.1, 0.05), 0.04 ));\n    d = min(d, sdCapsule(p, vec3(0.25, 0.1, 0.05), vec3(0.31, 0.01, 0.03), 0.03 ));\n    d = min(d, sdCapsule(p, vec3(0.07, 0.15, 0.0), vec3(0.1, 0.0, 0.0), 0.04 ));\n    d = min(d, sdCapsule(p, vec3(0.06, 0.1, 0.08), vec3(0.06, 0.18, 0.08), 0.02 ));\n    //head\n    p = pos-vec3(0.07, 0.25, 0.0);\n    d = min(d, sdSphere(p, 0.05));\n    p -= vec3(0.0, 0.08, 0.0);\n    d = min(d, sdCone(p, vec2(0.1, 0.04), 0.05 ));  \n    \n    return d;\n}\n\n\nfloat DE(vec3 pos, out Mat obj){\n    float dist = 1e6;\n    float t;\n    \n    //working light\n    //t = sdSphere(pos - vec3(-2.0, 2.0, -2.0), 1.8);\n    //if (t<dist){dist = t; obj = Mat(vec3(1.0), vec3(1.0));}\n    \n    //ground\n    t = sdPlane(pos);\n    if (t<dist){dist = t; obj = Mat(vec3(0.1), vec3(0.0));}\n    \n    //backbround sphere\n    t = -sdSphere(pos, 3.0);\n    if (t<dist){dist = t; obj = Mat(vec3(0.0), vec3(0.0));}\n    \n    //perso\n    t = sdPerso(pos);\n    if (t<dist){dist = t; obj = Mat(vec3(0.1), vec3(0.0));}\n    \n    //lights\n    t = sdCapsule(pos, vec3(-0.11, 0.22, 0.0), vec3(-0.11, 0.28, 0.0), 0.05);\n    if (t<dist){dist = t; obj = Mat(vec3(0.8, 0.0, 0.0), vec3(40.0, 13.0, 13.0));}\n    vec3 p = pos - vec3(0.105, 0.25, -0.028);\n    p.z = abs(p.z);\n    t = sdSphere(p, 0.01);\n    if (t<dist){dist = t; obj = Mat(vec3(0.8, 0.0, 0.0), vec3(10.0));}\n    \n    return dist;\n}\n\nfloat intersect(vec3 ro, vec3 rd, out vec3 normal, out Mat obj){\n    normal = rd;\n    obj = Mat(vec3(0.9, 0.1, 0.1), vec3(0.0));\n    float t = 0.0;\n    for(int i = 0; i < MAXSTEP; i++){\n        vec3 p = ro + t * rd;\n        float delta = DE(p, obj);\n        t += delta;\n        if(t > MAXDIST)return -1.0;\n        if(abs(delta) < MINDIST){//end\n            float off=0.001;\n            Mat m;\n            normal = normalize(vec3(DE(p+vec3(off,0,0), m)-DE(p-vec3(off,0,0), m),\n                                    DE(p+vec3(0,off,0), m)-DE(p-vec3(0,off,0), m),\n                                    DE(p+vec3(0,0,off), m)-DE(p-vec3(0,0,off), m))); \n            break;\n        }\n        \n    }\n    return t;\n}\n\n\n\nvec4 march(vec3 ro, vec3 rd){\n    Mat obj;\n    vec3 n = vec3(0.0);\n    float t = intersect(ro, rd, n, obj);\n    if (dot(obj.e, obj.e)>0.000001) t = -1.0;\n\treturn vec4(n*0.5+0.5, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame > 2){\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        return;\n    }\n    \n    \n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    initSeed(uv);\n    \n    vec3 dir0 = normalize(target-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n        \n    vec4 col = march(camPos, rd);\n    \n\n    fragColor = col;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 61, 61, 114], [116, 116, 173, 173, 1370]]}
{"id": "NsjSRy", "name": "metal test", "author": "mdb", "description": "test of normal and specular textures on a metal box", "tags": ["raytracing", "box"], "likes": 5, "viewed": 338, "published": 3, "date": "1620667492", "time_retrieved": "2024-07-30T19:20:54.781384", "image_code": "vec3 rotate(vec3 p, vec3 u, float teta){\n    float cost = cos(teta);\n    float sint = sin(teta);\n    mat3x3 R = mat3x3(cost + u.x*u.x*(1.0-cost),      u.x*u.y*(1.0-cost) - u.z*sint,  u.x*u.z*(1.0-cost) + u.y*sint,\n                      u.y*u.x*(1.0-cost) + u.z*sint,  cost + u.y*u.y*(1.0-cost),      u.y*u.z*(1.0-cost) - u.x*sint,\n                      u.z*u.x*(1.0-cost) - u.y*sint,  u.z*u.y*(1.0-cost) + u.x*sint,  cost + u.z*u.z*(1.0-cost)   );\n    return R * p;\n}\n\nvec2 box(vec3 ro, vec3 rd){\n        \n        vec3 dirfrac = 1.0 / rd;\n        float t1 = (-1.0- ro.x)*dirfrac.x;\n        float t2 = (1.0 - ro.x)*dirfrac.x;\n        float t3 = (-1.0 - ro.y)*dirfrac.y;\n        float t4 = (1.0 - ro.y)*dirfrac.y;\n        float t5 = (-1.0 - ro.z)*dirfrac.z;\n        float t6 = (1.0 - ro.z)*dirfrac.z;\n\n        float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n        float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n        // if tmax < 0, ray (line) is intersecting AABB, but the whole AABB is behind us\n        if (tmax < 0.0) return vec2(-1.0);\n\n        // if tmin > tmax, ray doesn't intersect AABB\n        if (tmin > tmax) return vec2(-1.0);\n\n        return vec2(tmin, tmax);\n}\n\nvec3 transform(vec3 p){\n    p = rotate(p, vec3(0.0, 0.0, 1.0), -iTime);\n    p = rotate(p, vec3(0.0, 1.0, 0.0), iTime*0.3);\n    return p;\n}\n\nvec3 getScene(vec3 ro, vec3 rd){\n    //rotate the box\n    ro = transform(ro);\n    rd = transform(rd);\n    \n    float t = box(ro, rd).x;\n    if (t < 0.0) return vec3(0.0);\n    vec3 p = ro + rd*t;\n    vec3 n = vec3(0.0);\n    vec2 uv;\n    if(abs(p.x)>0.99){n.x = p.x; uv = p.yz;}\n    if(abs(p.y)>0.99){n.y = p.y; uv = p.xz;}\n    if(abs(p.z)>0.99){n.z = p.z; uv = p.xy;}\n    n = normalize(n);\n    uv = 0.5 + 0.5*uv;\n    \n    //get to shading\n    vec3 lightDir = normalize(vec3(1.0, 2.0, -3.0));\n    lightDir = transform(lightDir);\n    vec3 tex = texture(iChannel0, uv).xyz;\n    vec4 prop = texture(iChannel1, uv);\n    \n    vec3 bump = prop.xyz*2.0-1.0;\n    float teta = acos(dot(bump, vec3(0.0, 0.0, 1.0)));\n    if (teta>0.000001){\n        n = rotate(n, normalize(cross(bump, vec3(0.0, 0.0, 1.0))), teta);\n    }\n    \n    vec3 col = tex;\n    col *= max(0.2, dot(n, lightDir));\n    col += 0.8*prop.w*pow(max(0.0, dot(n, lightDir)), 20.0);\n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel1, uv).xyz;\n    \n    //get ray\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 camPos = vec3(0.0, 0.0, -3.0);\n    vec3 dir0 = normalize(-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(up, dir0));\n    up = cross(dir0, right);\n    //vec2 off = vec2(random(),random()) / iResolution.y;\n    vec3 rd = normalize(dir0 + right*uv.x + up*uv.y);\n    \n    col = getScene(camPos, rd);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// .rgb = normal map, .a = specular mask\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec3 metal = texture(iChannel0, uv).xyz;\n    \n    //shiness\n    float mask = 1.0;\n    //if (metal.r-dot(metal, vec3(0.3)) > 0.05) mask = 0.0;\n    mask = 1.0 - smoothstep(0.035, 0.065, metal.r-dot(metal, vec3(0.3)));\n    \n    //bump normal map\n    float a = metal.r-dot(metal, vec3(0.3));\n    vec2 bumpStr = vec2(4.0);\n    bumpStr *= iResolution.xy * 0.01;\n    vec3 normal = vec3(dFdx(a)*bumpStr.x, dFdy(a)*bumpStr.y, 1.0);\n    normal = normalize(normal);\n    normal = 0.5 + 0.5*normal;\n    \n    \n    // Output to screen\n    fragColor = vec4(normal,mask);\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjSRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 467], [469, 469, 496, 496, 1207], [1209, 1209, 1232, 1232, 1347], [1349, 1349, 1381, 1402, 2305], [2307, 2307, 2364, 2414, 2947]]}
{"id": "sdSSRK", "name": "off the tracks", "author": "nabr", "description": "image: curved rails in the middle a metal ball reflecting square lights\nsound: dirty punchy drums with fast arpeggios brass-like synth", "tags": ["sound", "fm", "reflections", "pathtracer", "drums", "pm"], "likes": 14, "viewed": 581, "published": 3, "date": "1620666697", "time_retrieved": "2024-07-30T19:20:55.535368", "image_code": "\n#ifndef SOUNDONLY\n\nvoid mainImage(out vec4 c, in vec2 p) \n{\n    c = 3.*texelFetch(iChannel0, ivec2(p), 0);\n    c /= float(iFrame+1);\n}\n\n\n#else\nvoid mainImage(out vec4 c, in vec2 p) {}\n#endif", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "#define _f(x)fract(x)\nvoid f(float ft, float t, inout float y)\n{\n    float f = 0., ftf1 = _f(.25 * t), ftf0 = _f(.125 * ft);\n    f = sin(4084.015 * t) * exp(-1. * ftf0);\n    //pulse\n    f *= cos(t + t + 376.98 * exp(-0.03 * pow(1. - ftf0, 20.)));\n    f *= cos(ft * 15. * exp(-0.05 * pow(1. - ftf1, 10.)));\n    f *= min(1., 630. * ftf1) * max(0., 1. - ftf1);\n    //eq,noise\n    f = (f / (1.3 - cos(37.7 * f))) / (1.5 + sin(12. * f));\n    f *= min(1., 3675. * _f(ft)) * max(0., 1. - _f(ft));\n    \n    y += .05*f;\n}\nvec2 mainSound(int samp, float time)\n{\n    vec2 y = vec2(1e-6), d = y;\n\n    //stereo width l,r 45°=1\n    const float a = radians(30.);\n    mat2 v = mat2(cos(a) + sin(a), cos(a) - sin(a), cos(a) - sin(a), cos(a) + sin(a));\n    v *= .707106;\n    \n    float Fs = (1. / iSampleRate);\n    float t = (float(samp) * Fs), x = Fs,\n          mt = mod((vec3(2, 3, 1)[int(-.5*t) % 3] * t), (vec3(4, 2, .5)[int(t) % 3])), //playback speed\n          t0 = mt;\n\n    for (int j = 0; j < 2; j++)\n        for (int i = 0; i < 6; i++)\n        {\n            t0 *= abs(1. - x);\n            x = Fs + .125;\n            // ----- left\n            f((.2 * t0 + _f(4. * t0)), ( .1 + .5 * t0  + x), d.x);\n            f(.5 * (t0 - .21), .06 + t0, y.x);\n            x += .16667;\n            // ----- right\n            f((.2 * t0 + _f(8. * t0)), (.02 + .5 * t0 + x), d.y);\n            f(.5 * (t0 - .25), .08 + t0, y.y);\n        }\n    float am = 1.,ad = 1.,at = 2.;\n    \n    if (time < 4.)//intro\n    {\n        at = 4.;\n        am = float(mod(t, 2.) < 1.);\n    }\n    else {\n        d = d * v;//narrow\n        ad = .8;\n        }\n        \n    vec2 env = vec2(.2 * mt, -.1 * mt * at);\n    d *= max(0., 1. - dot(env, env));\n        \n    return (ad * d*min(.5*t, 1.) + am * y);\n\n}", "sound_inputs": [], "buffer_a_code": "#ifndef SOUNDONLY\n\n//some suff by iq>website\nvec2 hash21(uint q)\n{\n    uvec2 n=q*uvec2(1597334697U,3812015801U);\n    n=(n.x^n.y)*uvec2(1597334697U,3812015801U);\n    return vec2(n)*(1.0/float(0xffffffffU));\n}\nfloat sdBox(vec3 p, vec3 s) {p=abs(p)-s;return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);}\n#define dmin(a,b)((a.x<b.x)?a:b)\nvec2 f(vec3 p)\n{\n  #define lz(c,l)(p.z-c*clamp(round(p.z/c ),-l,l))\n  #define frp(_x,_y)(_y*.5-mod(_x,_y))\n  //sphere\n  float b = length(vec3(p.xy, p.z+7.5));\n  //room\n  float rm = abs(sdBox(p, vec3(3, 2.5, 10)));\n  vec3 v = p;\n  //rails\n  float r = cos(.45*p.z)+atan(p.y, p.x)*1.91;\n  v = abs(vec3(frp(r, 2.4),length(v.xy)-2.,lz(1., 8.))) -vec3(.65, .1, .45);\n  float rls = length(max(vec3(-.18,1e-3,1e-3), v)) + min(max(v.x, max(v.y, v.z) ), 0.)-.125;\n  v = p;\n  //lights\n  v = abs(vec3(frp(r+1., 2.4), lz(2., 3.), length(p.xy) - 1.8));\n  float fli = max(v.x-.1, max(v.y, v.z))-.05;\n  //seconds sphere is a hidden to the eye lightsource\n  return dmin(vec2(fli, 5),dmin(vec2(min(b-1.71,min(rm, rls)), 3), vec2(b-1.7, 7)));\n}\nvec3 calcNormal(in vec3 pos){vec3 eps=vec3(.0001,0,0);return normalize(vec3((f(pos+eps.xyy)-f(pos-eps.xyy)).x,(f(pos+eps.yxy)-f(pos-eps.yxy)).x,(f(pos+eps.yyx)-f(pos-eps.yyx)).x));}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    if(iFrame > 0)\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 R = iResolution.xy, h = vec2(0);\n    //seed by demofox \n    uint seed = (uint(fragCoord.x) * 1973u + uint(fragCoord.y) * 9277u + uint(iFrame) * 2669u) | 1u;\n    float a = max(abs(R.x), abs(R.y));\n    vec2 jjt = vec2(.3*cos(a*hash21(seed).x),sin(a*hash21(seed).y)),\n         st = ((fragCoord +jjt) * 2. - R ) /R.y;\n    vec3 col = vec3(1e-6),cmat = vec3(.974),\n    ro = vec3(.5, -1.,1./(2.+length(st)*jjt)),\n    rd = normalize(vec3(st,-1.7));\n    \n    if(abs(st.x)<1.3)\n    for(int b = 1; b < 6 + min(iFrame, 0); b++)\n    {\n        float t = 0.;\n        for(int i = 0; i < 60; i++)\n        {\n            h = f(ro + t * rd);\n            if(abs(h.x) < t *.0001 || t > 20. )break;\n            t += h.x;\n        }\n        ro += t * rd;\n       vec3 n = calcNormal(ro);\n       ro+=n*.001;\n       //lights\n       float phi =hash21(seed).y*6.283185,th =hash21(seed).x,sth = sin(th);\n       vec3 ld = normalize(vec3(1e-4, 1e-4, 2.1) + n ),\n              u = vec3(1e-4, 1e-4, ld.z),\n              v = cross(ld, u);\n        rd =  normalize(u * cos(phi) * sth + v * sin(phi) * sth + ld * cos(th));\n       //shade \n       float em = h.y == 5.?1.:h.y==7.?.1:0.;\n       col += em * (cmat*=cmat);\n    }\n    //reinhard gamma\n    col = (col/(1.+col));\n    fragColor += vec4(pow(col,vec3(0.4545)),1);\n}\n\n#else\nvoid mainImage(out vec4 c, in vec2 p) {}\n#endif", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n\n//#define SOUNDONLY", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSSRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "fdBXz3", "name": "super goku -v3", "author": "jorge2017a1", "description": "super goku -v3", "tags": ["2d", "draw", "anime", "poly", "supergokuv3"], "likes": 5, "viewed": 407, "published": 3, "date": "1620651082", "time_retrieved": "2024-07-30T19:20:56.395069", "image_code": "//por jorge2017a1 ----jorgeFloresP---10/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.75),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\nconst vec3 colVerde=vec3(0.0,1.0,0.0);\nconst vec3 colVerde2=vec3(0.1,0.8,0.1);\nconst vec3 colrojoObs=vec3(0.45,0.13,0.15); //rojo obscuro\n\n\nconst vec3 colDorado=vec3(0.925,0.67,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPoly26 POLY(26)\nvec2 pt26[ 26]=vec2[](  \nvec2(.48,1.00),vec2(.73,1.00),vec2(.70,.83),vec2(.73,.86),vec2(.74,.87),\nvec2(.75,.87),vec2(.78,.84),vec2(.78,.79),vec2(.78,.74),vec2(.76,.68),\nvec2(.74,.66),vec2(.71,.65),vec2(.71,.57),vec2(.71,.54),vec2(.68,.50),\nvec2(.62,.44),vec2(.58,.41),vec2(.55,.41),vec2(.52,.46),vec2(.49,.52),\nvec2(.48,.53),vec2(.45,.71),vec2(.45,.73),vec2(.45,.78),vec2(.46,.83),\nvec2(.48,1.00) );\n\n\nfloat sdPoly8 POLY(8)\nvec2 pt8[ 8]=vec2[](  \nvec2(.50,.58),vec2(.55,.62),vec2(.56,.60),vec2(.52,.57),vec2(.53,.57),\nvec2(.53,.56),vec2(.51,.56),vec2(.50,.58) );\n\nfloat sdPoly15 POLY(15)\nvec2 pt15[ 15]=vec2[](  \nvec2(.50,.58),vec2(.55,.62),vec2(.56,.60),vec2(.52,.57),vec2(.53,.57),\nvec2(.53,.56),vec2(.51,.56),vec2(.50,.58),vec2(.55,.63),vec2(.57,.54),\nvec2(.57,.52),vec2(.57,.51),vec2(.54,.49),vec2(.53,.50),vec2(.50,.58) );\n\nfloat sdPoly8b POLY(8)\nvec2 pt8b[ 8]=vec2[](  \nvec2(.53,.50),vec2(.53,.52),vec2(.54,.54),vec2(.55,.55),vec2(.56,.55),\nvec2(.57,.52),vec2(.54,.50),vec2(.53,.50) );\n\nfloat sdPoly6 POLY(6)\nvec2 pt6[ 6]=vec2[](  \nvec2(.49,.68),vec2(.47,.62),vec2(.47,.61),vec2(.49,.59),vec2(.50,.63),\nvec2(.49,.68) );\n\nfloat sdPoly4 POLY(4)\nvec2 pt4[ 4]=vec2[](  \nvec2(.47,.61),vec2(.50,.63),vec2(.50,.60),vec2(.47,.61) );\n\nfloat sdPoly3 POLY(3)\nvec2 pt3[ 3]=vec2[](  \nvec2(.53,.69),vec2(.61,.73),vec2(.53,.69) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.55,.69),vec2(.61,.72),vec2(.59,.70),vec2(.62,.71),vec2(.55,.69) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.50,.76),vec2(.54,.85),vec2(.56,.90),vec2(.57,.91),vec2(.59,.91),\nvec2(.60,.91),vec2(.60,.88),vec2(.57,.86),vec2(.54,.84),vec2(.53,.81),\nvec2(.51,.78),vec2(.50,.76) );\n\nfloat sdPoly8c POLY(8)\nvec2 pt8c[ 8]=vec2[](  \nvec2(.45,.77),vec2(.46,.78),vec2(.47,.77),vec2(.48,.73),vec2(.48,.73),\nvec2(.46,.75),vec2(.45,.74),vec2(.45,.77) );\n\nfloat sdPoly23 POLY(23)\nvec2 pt23[ 23]=vec2[](  \nvec2(.46,.64),vec2(.40,.65),vec2(.35,.64),vec2(.31,.63),vec2(.38,.76),\nvec2(.26,.79),vec2(.16,.82),vec2(.30,1.00),vec2(.80,1.00),vec2(.80,.98),\nvec2(.92,1.00),vec2(.86,.91),vec2(.99,.90),vec2(.99,.84),vec2(.92,.76),\nvec2(1.00,.74),vec2(.99,.71),vec2(.88,.64),vec2(.93,.62),vec2(.81,.59),\nvec2(.80,.61),vec2(.73,.65),vec2(.46,.64) );\n\nfloat sdPoly35 POLY(35)\nvec2 pt35[ 35]=vec2[](  \nvec2(.58,.41),vec2(.62,.44),vec2(.67,.48),vec2(.70,.53),vec2(.71,.65),\nvec2(.80,.61),vec2(.83,.48),vec2(.92,.40),vec2(.95,.41),vec2(1.00,.38),\nvec2(1.00,.01),vec2(.00,.01),vec2(.00,.21),vec2(.05,.21),vec2(.08,.19),\nvec2(.13,.22),vec2(.18,.22),vec2(.23,.21),vec2(.26,.23),vec2(.26,.26),\nvec2(.30,.28),vec2(.32,.30),vec2(.36,.30),vec2(.37,.31),vec2(.42,.30),\nvec2(.45,.29),vec2(.45,.29),vec2(.46,.31),vec2(.49,.29),vec2(.53,.31),\nvec2(.54,.30),vec2(.55,.31),vec2(.59,.34),vec2(.59,.36),vec2(.58,.41) );\n\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.36,.30),vec2(.35,.19),vec2(.35,.02),vec2(.45,.02),vec2(.45,.06),\nvec2(.47,.14),vec2(.50,.25),vec2(.54,.31),vec2(.51,.30),vec2(.49,.29),\nvec2(.46,.31),vec2(.45,.29),vec2(.42,.31),vec2(.36,.30) );\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.25,.23),vec2(.26,.26),vec2(.27,.27),vec2(.29,.28),vec2(.29,.27),\nvec2(.31,.29),vec2(.33,.30),vec2(.34,.30),vec2(.36,.29),vec2(.37,.30),\nvec2(.36,.24),vec2(.35,.14),vec2(.35,.01),vec2(.33,.01),vec2(.32,.09),\nvec2(.30,.16),vec2(.27,.23),vec2(.25,.23) );\n\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.95,.41),vec2(1.00,.39),vec2(1.00,.22),vec2(.94,.01),vec2(.71,.00),\nvec2(.79,.19),vec2(.83,.28),vec2(.86,.35),vec2(.91,.38),vec2(.95,.41) );\n\nfloat sdPoly20 POLY(20)\nvec2 pt20[ 20]=vec2[](  \nvec2(.54,.31),vec2(.56,.32),vec2(.51,.25),vec2(.48,.13),vec2(.54,.10),\nvec2(.62,.12),vec2(.70,.16),vec2(.75,.19),vec2(.79,.29),vec2(.85,.38),\nvec2(.88,.39),vec2(.95,.41),vec2(.95,.40),vec2(.90,.38),vec2(.86,.35),\nvec2(.73,.01),vec2(.45,.01),vec2(.46,.18),vec2(.53,.31),vec2(.54,.31) );\n\nfloat sdPoly3b POLY(3)\nvec2 pt3b[ 3]=vec2[](  \nvec2(.50,.83),vec2(.55,1.00),vec2(.50,.83) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.47,.66),vec2(.49,.67),vec2(.48,.72),vec2(.47,.73),vec2(.46,.73),\nvec2(.46,.71),vec2(.47,.66) );\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.54,.71),vec2(.58,.73),vec2(.58,.78),vec2(.58,.81),vec2(.56,.83),\nvec2(.55,.83),vec2(.53,.80),vec2(.53,.77),vec2(.54,.71) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.57,1.00),vec2(.58,.96),vec2(.58,.93),vec2(.57,.86),vec2(.59,.89),\nvec2(.63,.95),vec2(.63,.99),vec2(.63,1.00),vec2(.57,1.00) );\n\n\nfloat sdPoly10b POLY(10)\nvec2 pt10b[ 10]=vec2[](  \nvec2(.49,1.00),vec2(.54,1.00),vec2(.52,.95),vec2(.49,.90),vec2(.48,.86),\nvec2(.48,.77),vec2(.46,.82),vec2(.45,.91),vec2(.45,.93),vec2(.49,1.00) );\n\nfloat sdPoly17 POLY(17)\nvec2 pt17[ 17]=vec2[](  \nvec2(.72,.70),vec2(.73,.70),vec2(.75,.71),vec2(.76,.76),vec2(.76,.82),\nvec2(.76,.83),vec2(.77,.79),vec2(.77,.79),vec2(.77,.83),vec2(.75,.84),\nvec2(.74,.84),vec2(.73,.79),vec2(.72,.76),vec2(.73,.76),vec2(.73,.74),\nvec2(.73,.73),vec2(.72,.70) );\n\nfloat sdPoly9c POLY(9)\nvec2 pt9c[9]=vec2[](  \nvec2(.52,.24),vec2(.54,.24),vec2(.59,.23),vec2(.60,.23),vec2(.64,.25),\nvec2(.70,.29),vec2(.76,.32),vec2(.81,.33),vec2(.52,.24) );\n\n\nconst vec3 col1=vec3(0.83,0.34,0.69); //rosa\nconst vec3 col2=vec3(0.18,0.28,0.76); //azul\nconst vec3 col3=vec3(1.00,0.84,0.77); //piel\nconst vec3 col4=vec3(0.88,0.60,0.37); //piel obscuro\nconst vec3 col5=vec3(0.98,0.96,0.95); //blanco\nconst vec3 col6=vec3(0.97,0.42,0.14);\n\nfloat sdPoly4b POLY(4)\nvec2 pt4b[4]=vec2[](  \nvec2(.59,.19),vec2(.58,.14),vec2(.58,.11),vec2(.59,.19) );\n\nfloat sdPoly16 POLY(16)\nvec2 pt16[16]=vec2[](  \nvec2(.64,1.),vec2(.66,.91),vec2(.65,.87),vec2(.65,.83),vec2(.66,.84),\nvec2(.68,.86),vec2(.69,.87),vec2(.69,.82),vec2(.68,.81),vec2(.70,.82),\nvec2(.72,.84),vec2(.73,.86),vec2(.74,.87),vec2(.75,.87),vec2(.75,1.),\nvec2(.64,1.) );\n\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[7]=vec2[](  \nvec2(.10,.17),vec2(.15,.18),vec2(.18,.18),vec2(.22,.17),vec2(.25,.17),\nvec2(.27,.15),vec2(.10,.17) );\n\nfloat sdPoly7c POLY(7)\nvec2 pt7c[7]=vec2[](  \nvec2(.59,.38),vec2(.61,.36),vec2(.62,.32),vec2(.62,.31),vec2(.61,.35),\nvec2(.59,.37),vec2(.59,.38) );\n\nfloat sdPoly7d POLY(7)\nvec2 pt7d[7]=vec2[](  \nvec2(.70,.53),vec2(.70,.48),vec2(.64,.26),vec2(.64,.26),vec2(.70,.48),\nvec2(.70,.53),vec2(.70,.53) );\n\nfloat sdPoly3c POLY(3)\nvec2 pt3c[3]=vec2[](  \nvec2(.82,.45),vec2(.78,.35),vec2(.82,.45) );\n\n\n//***------------****-----------****------------******-------\nvec3 RostroGoku(in vec2 pp, vec3 col, vec2 uv) \n{\n  vec2 p=pp;\n   float sd26 = sdPoly26(p, pt26);\n   float sd8 = sdPoly8(p, pt8);\n   float sd15 = sdPoly15(p, pt15);\n   float sd8b = sdPoly8b(p, pt8b);\n   float sd6 = sdPoly6(p, pt6);\n   float sd4 = sdPoly4(p, pt4);\n   float sd3 = sdPoly3(p, pt3);\n   float sd5 = sdPoly5(p, pt5);\n   float sd12 = sdPoly12(p, pt12);\n   float sd8c = sdPoly8c(p, pt8c);\n   float sd23 = sdPoly23(p, pt23);\n   float sd35 = sdPoly35(p, pt35);\n   float sd14 = sdPoly14(p, pt14);\n   float sd18 = sdPoly18(p, pt18);\n   float sd10 = sdPoly10(p, pt10);\n   float sd20 = sdPoly20(p, pt20);\n   float sd3b = sdPoly3b(p, pt3b);    \n   float sd7 = sdPoly7(p, pt7);\n   float sd9 = sdPoly9(p, pt9);\n   float sd9b = sdPoly9b(p, pt9b);\n   float sd10b = sdPoly10b(p, pt10b);\n   float sd17 = sdPoly17(p, pt17);\n   float sd9c = sdPoly9c(p, pt9c);\n   float sd4b = sdPoly4(p, pt4b);\n   float sd16 = sdPoly16(p, pt16);\n    float sd7b = sdPoly7b(p, pt7b);\n    float sd7c = sdPoly7c(p, pt7c);\n   float sd7d = sdPoly7d(p, pt7d);\n    float sd3c = sdPoly3c(p, pt3c);\n   \n   float sdojo1= sdCircle(uv-vec2(-0.03,0.28), 0.02 );\n   float sdojo2= sdCircle(uv-vec2(-0.22,0.19), 0.02 ); //izq pupila\n   \n   float t1=mod(iTime,1.);\n   float t2=mod(iTime,2.);\n   vec3 colpelo;\n   if (t1<t2)\n    colpelo=mix(colNegro, colDorado, p.y);\n   else\n       colpelo=colNegro;\n   //col=mix(col,colpelo ,S( sd23,0.0)); // pelo\n   col=ponerBorde(colpelo,col,sd23); //pelo\n   col= ponerBorde(col3,col,sd26); //rostro\n   col=mix(col,colBlanco ,S( sd8,0.0));// dientes\n   col= ponerBorde(colNegro,col,sd15); // boca\n   col= ponerBorde(colRojo,col,sd8b); //lengua\n   col= ponerBorde(col3,col,sd6); // nariz\n   col= ponerBorde(col4,col,sd4); // \n   col=mix(col,colNegro ,S( sd3,0.0)); //linea rostro1\n   col=mix(col,colNegro ,S( sd5,0.0)); //linea rostro 2\n   col=mix(col,colNegro ,S( sd12,0.0)); //ceja der\n   col=mix(col,colNegro ,S( sd8c,0.0)); //ceja izq\n   col= ponerBorde(col3,col,sd35); // cuerpo\n   col= ponerBorde(col6,col,sd14); // camisa 0 roja\n   col= ponerBorde(col2,col,sd18); //camisa 1 azul\n   col= ponerBorde(col6,col,sd10); //camisa 2 azul\n   col= ponerBorde(col2,col,sd20); // camisa roja 2\n   col= ponerBorde(col1,col,sd3b); // linea 2 arruga\n   col= ponerBorde(colBlanco,col,sd7); // ojo izq\n   col= ponerBorde(colBlanco,col,sd9); // ojo der\n   col= ponerBorde(colpelo,col,sd9b); // pelo negro\n   col= ponerBorde(colpelo,col,sd10b); // pelo negro\n   col= ponerBorde(col4,col,sd17); // oreja\n   col= ponerBorde(colNegro,col,sd9c); // linea pecho\n   col= ponerBorde(colNegro,col,sdojo1); // pupila-ojo \n   col= ponerBorde(colNegro,col,sdojo2); // pupila-ojo \n   col=mix(col,colNegro ,S( sd4b ,0.0));// linea\n   col=mix(col,colpelo ,S( sd16 ,0.0));\n   col=mix(col,colNegro ,S( sd7b ,0.0));\n   col=mix(col,colNegro ,S( sd7c ,0.0));\n   col=mix(col,colNegro ,S( sd7d ,0.0));\n   col=mix(col,colNegro ,S( sd3c ,0.0));\n  return col;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float t=1.0-0.5*fract(sin(iTime*0.5));\n    uv*=t;\n    //uv.x+=1.4;uv.y+=0.8;\n    vec2 p=uv;\n    p.x+=1.4;p.y+=0.8;\n    p.x*=0.4; p.y*=0.7;\n    vec3 col=mix(col1, vec3(0.0),uv.y*0.5);\n    col=RostroGoku(p, col, uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBXz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 394, 430, 430, 475], [481, 481, 516, 516, 540], [542, 542, 576, 576, 673], [674, 674, 734, 734, 859], [861, 861, 892, 892, 913], [7997, 8059, 8108, 8108, 10979], [10982, 10982, 11039, 11039, 11393]]}
{"id": "NsBXR3", "name": "Orbital CA", "author": "paniq", "description": "a cellular automaton built from orbit interactions. various modes supported in code. see https://twitter.com/leonard_ritter/status/1391716571307970562", "tags": ["cellular", "spin", "automaton", "orbital"], "likes": 3, "viewed": 377, "published": 3, "date": "1620648167", "time_retrieved": "2024-07-30T19:20:57.152045", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect_fix = vec2(1.0);//vec2(0.5,0.5);\n#ifdef RULE110\n    fragColor = vec4(vec3(texelFetch(iChannel0, ivec2(fragCoord * aspect_fix), 0).r), 1.0);\n#else\n    fragColor = vec4(texture(iChannel0, (fragCoord / iResolution.xy) * aspect_fix).rgb, 1.0);\n#endif\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\n#ifdef RULE110\nfloat rule110(float v00, float v10, float v01, float v11) {\n    int i00 = (v00 > 0.5)?1:0;\n    int i10 = (v10 > 0.5)?1:0;\n    int i01 = (v01 > 0.5)?1:0;\n    int i11 = (v11 > 0.5)?1:0;\n    int code = (i11 << 3) | (i10 << 2) | (i01 << 1) | i00;\n    // good codes:\n    // 38550 (xor 3)   \n    // 21930 (diagonal xor)\n    //   938 (diagonal blocking xor 1)\n    // 16298 (diagonal blocking xor 2)\n    // 22270 (rule 110 analog A)\n    // 32510 (rule 110 analog B)   \n    // 49212 (add 2 w carry select)\n    // 33598 (octagonal ornaments)\n    // 32360 (entropy pockets, try with 83% black)\n    // 27308 (maxwell's demon, has gliders and glider guns)\n    // 48700 (diagonal roads)\n    // 48956 (city generator)\n    // 43944 (self-assembling plaid canals)\n    // 48744 (entropy worms & spinners)\n    //   957 (critters by margolus/toffoli)\n    // 43496 (billiard ball machine by fredkin - this one's broken)\n    // 10479 (motherboard)\n    // 43798 (self-erasing rubberbands)\n    // 42330 (binary tree curtain)\n    // 44588 (new year's eve)   \n    // 43777 (c00?c11:(!(c01|c10)))    \n#if 0 // pattern construction kit\n    const int rule =\n    //00          00          10          10\n    //00          10          00          10\n     (1 <<  0) | (0 <<  1) | (1 <<  2) | (1 <<  3) |\n    //00          00          10          10\n    //01          11          01          11\n     (1 <<  4) | (1 <<  5) | (0 <<  6) | (1 <<  7) |\n    //01          01          11          11\n    //00          10          00          10\n     (1 <<  8) | (1 <<  9) | (0 << 10) | (0 << 11) |\n    //01          01          11          11\n    //01          11          01          11\n     (0 << 12) | (0 << 13) | (0 << 14) | (0 << 15);\n    return float((rule >> code) & 1);\n#else\n    return float((48956 >> code) & 1);\n#endif\n}\n#endif\n\nivec2 moduv(ivec2 uv) {\n    ivec2 sz = ivec2(iResolution.xy);\n    return (uv + sz) % sz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n    vec4 n00 = vec4(0.0);\n    if (iFrame == 0 || keyDown(K_BACKSPACE)) {\n        vec3 h = hash32(fragCoord + iTime);\n#ifdef RULE110\n        //n00 = vec4(step(0.9995,h), 1.0);\n        n00 = vec4(step(0.999,h), 1.0);\n#else\n        /*\n        if (uv == ivec2(iResolution.xy/2.0 * vec2(1.0,1.0/sqrt(3.0))))\n            n00 = vec4(vec3(10000.0), 1.0);*/\n        n00 = vec4(step(0.999,h)*400.0, 1.0);\n#endif\n    } else {\n        n00 = texelFetch(iChannel0, uv, 0);\n        int d = (iFrame & 1) * 2 - 1;\n        int dx = d * ((uv.x & 1) * 2 - 1);\n        int dy = d * ((uv.y & 1) * 2 - 1);\n        \n        vec4 n11 = texelFetch(iChannel0, moduv(uv + ivec2(dx, dy)), 0);\n        vec4 n10 = texelFetch(iChannel0, moduv(uv + ivec2(dx, 0)), 0);\n        vec4 n01 = texelFetch(iChannel0, moduv(uv + ivec2(0, dy)), 0);\n#ifdef RULE110        \n        n00 = vec4(rule110(n00.r,n10.r,n01.r,n11.r), rule110(n00.g,n10.g,n01.g,n11.g), rule110(n00.b,n10.b,n01.b,n11.b), 1.0);\n#else        \n        n00 = (n00 + n01 + n10 + n11) / 4.0;\n#endif        \n    }\n    fragColor = n00;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define RULE110\n#define SKIP_ODD\n\n// from https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n// from https://www.shadertoy.com/view/llySRh\n\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n// Modifiers: SHIFT: 16 CTRL: 17 ALT: 18\n// Advice:  Mode: keyToggle(key)  Action: keydown(key)+keyclick(modifier)\n#define keyToggle(ascii)  ( texelFetch(iChannel1,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel1,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel1,ivec2(ascii,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel1,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel1,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel1,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n#define K_BACKSPACE 8\n\n\n\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a = texelFetch(iChannel0, ivec2(fragCoord), 0);\n#ifdef SKIP_ODD\n    vec4 b = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if ((iFrame & 1) == 0)\n        fragColor = a;\n    else\n        fragColor = b;\n#else\n    fragColor = a;\n#endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 322]]}
{"id": "sd2XzV", "name": "video waveform parade", "author": "DrQuark", "description": "Simple video waveform editor", "tags": ["video"], "likes": 7, "viewed": 316, "published": 3, "date": "1620641955", "time_retrieved": "2024-07-30T19:20:57.902040", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u = fragCoord.x / iResolution.x * 3.0;\n    vec2 coords;\n    float accum = 1.0 / iResolution.y;\n    accum *= 20.;\n\n    vec4 col = vec4(0., 0., 0., 1.);\n    float ys = (fragCoord.xy[1] - 1.0)/ iResolution.y;\n    float ye = (fragCoord.xy[1]) / iResolution.y;\n\n    for (int y = 1; y < int(iChannelResolution[0].y); ++y){\n        coords.x = fragCoord.x / (iResolution.x / 3.0);\n        coords.y = float(y) / iChannelResolution[0].y;\n        vec4 texcol;\n        if (u <= 1.0){\n            texcol = texture(iChannel0, coords);\n            if (texcol.x > ys && texcol.x < ye){\n                col += vec4(accum, 0., 0., 0.);\n            }\n        }\n\n        if (u > 1.0 && u <= 2.0){\n            coords.x -= 1.;\n            texcol = texture(iChannel0, coords);\n            if (texcol.y > ys && texcol.y < ye){\n                col += vec4(0., accum, 0., 0.);\n            }\n        }\n        if (u > 2.0){\n            coords.x -= 2.;\n            texcol = texture(iChannel0, coords);\n            if (texcol.z > ys && texcol.z < ye){\n                col += vec4(0., 0., accum, 0.);\n            }\n        }\n    }\n\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2XzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1217]]}
{"id": "NdSSR3", "name": "Channeling Slime", "author": "dr2", "description": "Blobs of metallic goo (slimy worms) in Voronoi channels  (mouseable, click upper-right for new run)", "tags": ["voronoi", "dynamics", "collisions"], "likes": 18, "viewed": 371, "published": 3, "date": "1620641939", "time_retrieved": "2024-07-30T19:20:58.879428", "image_code": "// \"Channeling Slime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Blobs of metallic goo (slimy worms) in Voronoi channels (mouseable,\n// click upper-right for new run). Observe behavior closely.\n// (Mix of \"Channeling Marbles\" and \"Multi-Slime\")\n\nfloat PrSphDf (vec3 p, float r);\nvoid HexVorInit ();\nfloat HexVor (vec2 p);\nfloat Minv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nmat3 DirVuMat (vec3 vd);\nvec2 Hashv2v2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\nconst int nBall = 60;\nvec3 ltDir, vorSmth;\nfloat dstFar, tCur, vorHt, vorAmp, vorScl;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat SurfHt (vec2 p)\n{\n  return vorHt * smoothstep (vorSmth.x, vorSmth.y, HexVor (p));\n}\n\nfloat SurfRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  if (rd.y < 0.) {\n    s = - (ro.y - vorHt) / rd.y;\n    sLo = s;\n    for (int j = VAR_ZERO; j < 160; j ++) {\n      p = ro + s * rd;\n      h = p.y - SurfHt (p.xz);\n      if (h < 0.) break;\n      sLo = s;\n      s += max (0.2, 0.4 * h);\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = VAR_ZERO; j < 5; j ++) {\n        s = 0.5 * (sLo + sHi);\n        p = ro + s * rd;\n        if (p.y > SurfHt (p.xz)) sLo = s;\n        else sHi = s;\n      }\n      dHit = 0.5 * (sLo + sHi);\n    }\n  }\n  return dHit;\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float d;\n  d = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++)\n     d = SmoothMin (d, PrSphDf (p - Loadv4 (3 * n).xyz, 0.45), 2.);\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, bgCol;\n  float dstObj, dstSurf, sh;\n  HexVorInit ();\n  bgCol = vec3 (0.5, 0.7, 1.);\n  dstObj = ObjRay (ro, rd);\n  dstSurf = (rd.y < 0.) ? SurfRay (ro, rd) : dstFar;\n  col = bgCol;\n  if (min (dstObj, dstSurf) < dstFar) {\n    sh = 1.;\n    if (dstObj < dstSurf) {\n      ro += dstObj * rd;\n      col4 = vec4 (1., 0.7, 0.2, 0.2);\n      vn = ObjNf (ro);\n    } else {\n      ro += dstSurf * rd;\n      col4 = vec4 (mix (vec3 (0.2, 0.2, 0.5), vec3 (0.7, 0.75, 0.7),\n         smoothstep (0., 0.02, ro.y)), 0.05);\n      vn = VaryNf (2. * ro, SurfNf (ro), 1. - smoothstep (0.5, 0.7, dstSurf / dstFar));\n      sh = ObjSShadow (ro + 0.01 * ltDir, ltDir);\n    }\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    col = mix (bgCol, col, min (1., exp2 (8. * (1. - 1.2 * min (dstObj, dstSurf) / dstFar))));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 col, rd, ro, bMid;\n  vec2 canvas, uv;\n  float az, el, asp, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (3 * nBall + 0);\n  vorSmth = stDat.xyz;\n  stDat = Loadv4 (3 * nBall + 1);\n  vorAmp = stDat.x;\n  vorHt = stDat.y;\n  vorScl = stDat.z;\n  stDat = Loadv4 (3 * nBall + 2);\n  mPtr.xyz = stDat.xyz;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && Minv2 (mPtr.xy + 0.05 * vec2 (1. / asp, 1.) - 0.5) < 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 0.5 * pi * (mPtr.y + 0.25);\n  } else {\n    az -= 0.01 * pi * tCur;\n    el += pi * (0.17 + 0.1 * sin (0.031 * pi * tCur));\n  }\n  el = clamp (el, 0.02 * pi, 0.4 * pi);\n  bMid.xz = vec2 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) bMid.xz += Loadv4 (3 * n).xz;\n  bMid.xz /= float (nBall);\n  bMid.y = vorHt;\n  dstFar = 250.;\n  ro = bMid + 80. * vec3 (cos (el) * sin (az + vec2 (0.5 * pi, 0.)), 2. * sin (el)).xzy;\n  vuMat = DirVuMat (normalize (bMid - ro));\n  zmFac = 4.;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  col = ShowScene (ro, rd);\n  if (mPtr.z > 0. && Minv2 (uv - vec2 (asp, 1.)) > -0.1) col = mix (col, vec3 (1., 0.3, 0.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float a;\n  p *= vorScl;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + vorAmp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) sd = sd.wxyw;\n    else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, vorSmth.z) - sd.x;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Channeling Slime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvoid HexVorInit ();\nfloat HexVor (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nvec3 Hashv3f (float p);\nvec2 Hashv2v2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 60;\nvec3 vorSmth;\nfloat todCur, nStep, vorHt, vorAmp, vorScl;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat SurfHt (vec2 p)\n{\n  return vorHt * smoothstep (vorSmth.x, vorSmth.y, HexVor (p));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.7;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (3 * mId).xyz;\n  vm = Loadv4 (3 * mId + 1).xyz;\n  wm = Loadv4 (3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (3 * n + 1).xyz;\n      wmN = Loadv4 (3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }    \n    am += ((n / (nBall / 4) == mId / (nBall / 4) && abs (float (n - mId)) <= 3.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (fPull * vec2 (1., -0.5 * sin (0.01 * 2. * pi * nStep)), - grav).xzy -\n     fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = vec2 (0., 0.95 * mIdf) + 35. * mod (floor (todCur), 10.);\n  rm.y = vorHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  HexVorInit ();\n  vorAmp = 0.4;\n  vorHt = 2.;\n  vorScl = 0.1;\n  vorSmth = vec3 (0.1, 0.8, 0.2);\n  mId = (pxId < 3 * nBall) ? pxId / 3 : -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (3 * nBall);\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (3 * nBall + 2);\n    mPtrP.z = stDat.z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId < 3 * nBall) {\n    kp = 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 3 * nBall;\n    if      (pxId == kp) stDat = vec4 (vorSmth, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (vorAmp, vorHt, vorScl, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (mPtr.xyz, 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float a;\n  p *= vorScl;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + vorAmp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) sd = sd.wxyw;\n    else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, vorSmth.z) - sd.x;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Channeling Slime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvoid HexVorInit ();\nfloat HexVor (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nvec3 Hashv3f (float p);\nvec2 Hashv2v2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 60;\nvec3 vorSmth;\nfloat todCur, nStep, vorHt, vorAmp, vorScl;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat SurfHt (vec2 p)\n{\n  return vorHt * smoothstep (vorSmth.x, vorSmth.y, HexVor (p));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.7;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (3 * mId).xyz;\n  vm = Loadv4 (3 * mId + 1).xyz;\n  wm = Loadv4 (3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (3 * n + 1).xyz;\n      wmN = Loadv4 (3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }    \n    am += ((n / (nBall / 4) == mId / (nBall / 4) && abs (float (n - mId)) <= 3.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (fPull * vec2 (1., -0.5 * sin (0.01 * 2. * pi * nStep)), - grav).xzy -\n     fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = vec2 (0., 0.95 * mIdf) + 35. * mod (floor (todCur), 10.);\n  rm.y = vorHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  HexVorInit ();\n  vorAmp = 0.4;\n  vorHt = 2.;\n  vorScl = 0.1;\n  vorSmth = vec3 (0.1, 0.8, 0.2);\n  mId = (pxId < 3 * nBall) ? pxId / 3 : -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (3 * nBall);\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (3 * nBall + 2);\n    mPtrP.z = stDat.z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId < 3 * nBall) {\n    kp = 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 3 * nBall;\n    if      (pxId == kp) stDat = vec4 (vorSmth, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (vorAmp, vorHt, vorScl, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (mPtr.xyz, 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float a;\n  p *= vorScl;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + vorAmp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) sd = sd.wxyw;\n    else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, vorSmth.z) - sd.x;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Channeling Slime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvoid HexVorInit ();\nfloat HexVor (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nvec3 Hashv3f (float p);\nvec2 Hashv2v2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 60;\nvec3 vorSmth;\nfloat todCur, nStep, vorHt, vorAmp, vorScl;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat SurfHt (vec2 p)\n{\n  return vorHt * smoothstep (vorSmth.x, vorSmth.y, HexVor (p));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.7;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (3 * mId).xyz;\n  vm = Loadv4 (3 * mId + 1).xyz;\n  wm = Loadv4 (3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (3 * n + 1).xyz;\n      wmN = Loadv4 (3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }    \n    am += ((n / (nBall / 4) == mId / (nBall / 4) && abs (float (n - mId)) <= 3.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (fPull * vec2 (1., -0.5 * sin (0.01 * 2. * pi * nStep)), - grav).xzy -\n     fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = vec2 (0., 0.95 * mIdf) + 35. * mod (floor (todCur), 10.);\n  rm.y = vorHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  HexVorInit ();\n  vorAmp = 0.4;\n  vorHt = 2.;\n  vorScl = 0.1;\n  vorSmth = vec3 (0.1, 0.8, 0.2);\n  mId = (pxId < 3 * nBall) ? pxId / 3 : -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (3 * nBall);\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (3 * nBall + 2);\n    mPtrP.z = stDat.z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId < 3 * nBall) {\n    kp = 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 3 * nBall;\n    if      (pxId == kp) stDat = vec4 (vorSmth, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (vorAmp, vorHt, vorScl, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (mPtr.xyz, 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float a;\n  p *= vorScl;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + vorAmp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) sd = sd.wxyw;\n    else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, vorSmth.z) - sd.x;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Channeling Slime\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvoid HexVorInit ();\nfloat HexVor (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nvec3 Hashv3f (float p);\nvec2 Hashv2v2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBall = 60;\nvec3 vorSmth;\nfloat todCur, nStep, vorHt, vorAmp, vorScl;\nconst float pi = 3.14159, sqrt3 = 1.73205;\nconst float txRow = 128.;\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat SurfHt (vec2 p)\n{\n  return vorHt * smoothstep (vorSmth.x, vorSmth.y, HexVor (p));\n}\n\nvec3 SurfNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (SurfHt (p.xz) - vec2 (SurfHt (p.xz + e.xy), SurfHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  vec3 rmN, vmN, wmN, dr, dv, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fAttr, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = 0.1;\n  fricSW = 1.;\n  fricT = 0.5;\n  fPull = 0.7;\n  fAttr = 0.1;\n  fDamp = 0.5;\n  grav = 10.;\n  rm = Loadv4 (3 * mId).xyz;\n  vm = Loadv4 (3 * mId + 1).xyz;\n  wm = Loadv4 (3 * mId + 2).xyz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    rmN = Loadv4 (3 * n).xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4 (3 * n + 1).xyz;\n      wmN = Loadv4 (3 * n + 2).xyz;\n      dv = vm - vmN;\n      drv = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross (0.5 * (wm + wmN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }    \n    am += ((n / (nBall / 4) == mId / (nBall / 4) && abs (float (n - mId)) <= 3.) ? 1. : 0.0005) *\n       fAttr * (rmN - rm);\n  }\n  dr.xz = 0.5 * SurfNf (rm).xz;\n  dr.y = rm.y + 0.5 - SurfHt (rm.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross (wm, dr);\n    ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  am += vec3 (fPull * vec2 (1., -0.5 * sin (0.01 * 2. * pi * nStep)), - grav).xzy -\n     fDamp * vec3 (1., 5., 1.) * vm;\n  dt = 0.02;\n  vm += dt * am ;\n  rm += dt * vm;\n  wm += dt * wam / 0.1;\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float (mId);\n  rm.xz = vec2 (0., 0.95 * mIdf) + 35. * mod (floor (todCur), 10.);\n  rm.y = vorHt + 1.5;\n  vm = Hashv3f (mIdf + todCur) - 0.5;\n  wm = vec3 (0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 3 * nBall + 3) discard;\n  canvas = iResolution.xy;\n  todCur = iDate.w;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  HexVorInit ();\n  vorAmp = 0.4;\n  vorHt = 2.;\n  vorScl = 0.1;\n  vorSmth = vec3 (0.1, 0.8, 0.2);\n  mId = (pxId < 3 * nBall) ? pxId / 3 : -1;\n  if (iFrame <= 5) {\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4 (3 * nBall);\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (3 * nBall + 2);\n    mPtrP.z = stDat.z;\n    if (mPtr.z > 0. && mPtrP.z < 0. && Maxv2 (mPtr.xy - 0.5 - vec2 (0.05 / asp, - 0.05)) > 0. &&\n       nStep > 100.) doInit = true;\n  }\n  if (doInit) nStep = 0.;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, wm);\n    else Step (mId, rm, vm, wm);\n  }\n  if (pxId < 3 * nBall) {\n    kp = 3 * mId;\n    if      (pxId == kp + 0) stDat = vec4 (rm, 0.);\n    else if (pxId == kp + 1) stDat = vec4 (vm, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (wm, 0.);\n  } else {\n    kp = 3 * nBall;\n    if      (pxId == kp) stDat = vec4 (vorSmth, nStep);\n    else if (pxId == kp + 1) stDat = vec4 (vorAmp, vorHt, vorScl, 0.);\n    else if (pxId == kp + 2) stDat = vec4 (mPtr.xyz, 0.);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat HexVor (vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float a;\n  p *= vorScl;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + vorAmp * (0.4 + 0.6 * u.x) * sin (a + vec2 (0.5 * pi, 0.)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) sd = sd.wxyw;\n    else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, vorSmth.z) - sd.x;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (p + vec3 (37., 39., 41.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSSR3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[759, 759, 782, 782, 848], [850, 850, 884, 884, 1474], [1476, 1476, 1498, 1498, 1637], [1639, 1639, 1661, 1661, 1810], [1812, 1812, 1845, 1845, 2028], [2030, 2030, 2051, 2051, 2306], [2308, 2308, 2345, 2345, 2588], [2590, 2590, 2625, 2625, 3585], [3587, 3587, 3643, 3643, 4964], [4966, 4966, 4999, 4999, 5026], [5028, 5028, 5052, 5052, 5282], [5284, 5284, 5308, 5308, 5368], [5394, 5394, 5414, 5414, 5634], [5636, 5636, 5659, 5659, 6175], [6177, 6177, 6199, 6199, 6226], [6228, 6228, 6273, 6273, 6376], [6378, 6378, 6408, 6408, 6521], [6523, 6523, 6548, 6548, 6717], [6751, 6751, 6775, 6775, 6887], [6889, 6889, 6914, 6914, 7100], [7102, 7102, 7131, 7131, 7343], [7345, 7345, 7384, 7384, 7569], [7663, 7663, 7688, 7688, 7811]]}
{"id": "7s2SzV", "name": "twinkle little star", "author": "spectrum", "description": "twinkle 어쩌나", "tags": ["star"], "likes": 1, "viewed": 354, "published": 3, "date": "1620639231", "time_retrieved": "2024-07-30T19:20:59.631416", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n  float d = length(uv-vec2(sin(iTime*2.)*.4,cos(iTime*1.)*.2));\n\n  vec3 col = vec3(0);\n  float brightness = 0.1 * sin(iTime*1.)+.2;\n  col += brightness*.2 / d;\n  col.y *= sin(iTime*1.);\n  col.z *= sin(iTime*1.);\n  fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2SzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 360]]}
{"id": "ssjXzK", "name": "how MIPmap is wrong - refcubemap", "author": "FabriceNeyret2", "description": "click for new seeds. (better seen in fullscreen ).\nIt is the reference case for [url]https://shadertoy.com/view/ssBSRK[/url].\nWith present power-of-2 textures all is good, while it was not for ordinary buffers.", "tags": ["glsl", "mipmap", "bug"], "likes": 3, "viewed": 371, "published": 3, "date": "1620628938", "time_retrieved": "2024-07-30T19:21:00.395374", "image_code": "// correct reference against \"how MIPmap is wrong\" by FabriceNeyret2. https://shadertoy.com/view/ssBSRK\n\n#define col(l)   m = T(U,l).w * float(1<<(2*l)); if (m > 0.01 ) O\n#define R        iResolution.xy\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = (U-.5*R)/R.y; \n    if ( abs(U.x) > .5 ) { O = vec4(0); return; } // you don't want to see cubeMap sides ;-)\n    U = U*R+.5*R;\n    O = vec4( T(U,0).w );      // particles\n    float m;\n    \n#if 0                          // ( better with texelFetch )                       \n    col(4).g += .3;\n    col(5).r += .2 + .4* m;\n    col(6).b += .2 + .2* m;\n // col(4).g += m/2.; col(5).r += m/2.; col(6).b += m/2.; // cloud color scheme\n\n#else\n    col(4).g += .3;\n    col(5).r += .4;  // (.5+.5*cos(24.*m))*m*2.;\n    col(6).b += .5;\n // col(1).b -= .5;            // more LODs\n // col(2).r -= .4; \n // col(3).g -= .3;\n#endif\n\n// if (m>0.) O +=  ( .6 + .6 * cos( 6.3*(m/6.)  + vec4(0,23,21,0)  ) ) * (m>6. ? 1. : .5); // hue\n\n// O = T(U,0);                 // debug\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define R        iResolution.xy // bugged for cubeMaps\n\n#define T0(U,l)   textureLod( iChannel0, vec3((U)/R*2.-1.,1)*vec3(1,-1,1), float(l) )\n  #define T(U,l)  T0(U,l)                                              // using texture interpolation\n//#define T(U,l)  T0( floor( (U)/float(1<<l) ) * float(1<<l) +.5 , l ) // trying to emulate texelFetch array\n", "cube_a_code": "// .xy = particle coords  .w = density field : +1 at particle location then MIPmap\n\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define R        vec2(1024) // bugged for cubeMaps\n\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 C, vec3 D )\n{\n        if (iFrame == 0 || iMouse.w > 0. ) {                  // --- initialization\n            O = vec4( hash2(U+iTime) *R ,  0,-1 );            // random coords\n            return;\n        }\n     // O = texture(iChannel1,U/R); return; // cubemap debug qualibration\n        \n        O = T(U,0);                                     // recover previous state\n        \n        if ( O.w < 0. ) {                                     // new coords not yet splated \n            O.w = 0.;\n            for ( float y = .5; y < .01*R.y; y++ )            // splat some particles on screen\n                for ( float x = .5; x < .01*R.x; x++ )\n                    if( floor(T(vec2(x,y),0).xy) == floor(U) )    // if point in pixel, splat \n                        { O.w++; return; }\n          }\n}", "cube_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 243, 243, 1009]]}
{"id": "7djSzK", "name": "Distance to Sine (three iters!)", "author": "oneshade", "description": "How good does it get?", "tags": ["2d", "sdf", "fast", "sine", "distance"], "likes": 15, "viewed": 493, "published": 3, "date": "1620623136", "time_retrieved": "2024-07-30T19:21:01.170302", "image_code": "// See: https://www.desmos.com/calculator/hvqys18zux\n// f: frequency\n// a: amplitude\nfloat sdSine(in vec2 p, in float f, in float a) {\n    f *= 3.14159265359 * a, p /= a; // Modify to handle varying amplitude\n    float r = 3.14159265359 / f, h = 0.5 * r, ff = f * f;\n    p = vec2(mod(p.x + h, r) - h, p.y * sign(r - mod(p.x + h, 2.0 * r))); // Remap\n\n    // Get closest on linear approximation\n    float t = clamp((0.818309886184 * f * p.y + p.x) / (0.669631069826 * ff + 1.0), -h, h);\n\n    // Three iterations of Newton-Raphson\n    for (int n=0; n < 3; n++) {\n        float k = t * f, c = cos(k), s = sin(k);\n        t -= ((s - p.y) * c * f + t - p.x) / ((c * c - s * s + s * p.y) * ff + 1.0);\n    }\n\n    return length(p - vec2(t, sin(t * f))) * a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    float f = mix(0.125, 8.0, 0.5 + 0.5 * sin(iTime));\n    float a = 0.25 + 0.125 * cos(iTime);\n    float d = sdSine(uv, f, a) * 2.0; // Shrink isolines\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d) * 0.8));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djSzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 85, 134, 134, 751], [753, 753, 808, 808, 1335]]}
{"id": "Nds3RH", "name": "pumpkin for the man and epic", "author": "pema99", "description": "pompkin\n\nvrchat", "tags": ["raymarching", "halloween", "pumpkin"], "likes": 1, "viewed": 333, "published": 3, "date": "1620600960", "time_retrieved": "2024-07-30T19:21:01.922291", "image_code": "#define MAX_STEPS 80\n#define MAX_DIST 5.\n#define SURF_DIST .001\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat pumpkinBody(vec3 p)\n{\n    p.y *= 1.5-abs(pow(length(p.xz),0.3))*0.5;\n    p.xz *= 1.0 + sin(10.0 * atan(p.z, p.x))*0.05;\n    return length(p)-0.8;\n}\n\nfloat pumpkinStem(vec3 p)\n{\n    p.yz *= rot(p.y*0.15);\n    p.xz *= 1.0 + sin(10.0 * atan(p.z, p.x))*0.05;\n    return sdCappedCylinder(p-vec3(0, 0.6, 0.05), 0.25, 0.13);\n}\n\nint id = 0;\nfloat map(vec3 p)\n{\n    float height = max(p.y, 0.);\n\n    float c = 1.6;\n    p.y = mod(p.y + 0.5*c, c) - 0.5*c;\n    p.y += 0.1;\n    \n    p *= height;\n\n    float d0 = pumpkinBody(p);\n    d0 = max(d0, -d0-0.2);\n    float d1 = pumpkinStem(p);\n    id = d0 < d1 ? 0 : 1;\n    return opSmoothUnion(d0, d1, 0.1) / height;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    int i = 0;\n    for(; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = map(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, float(i));\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = map(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n         r = normalize(cross(vec3(0,1,0), f)),\n         u = cross(f,r),\n         c = f*z,\n         i = c + uv.x*r + uv.y*u,\n         d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 3, -3)*.6;\n    ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    \n    vec3 rd = getRayDir(uv, ro, vec3(0,0,0), 1.);\n    vec3 bg = pow(texture(iChannel0, rd).rgb, vec3(4.0))*0.7;\n    vec3 col = bg;\n    vec3 newCol = vec3(0);\n    \n    vec2 res = rayMarch(ro, rd);\n    float d = res.x;\n    float ao = res.y / float(MAX_STEPS);\n\n    if(d>MAX_DIST) { \n        newCol = bg;\n    } else {\n        int mat = id;\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n\n        if (mat == 1) col = vec3(0.4, 0.4, 0.1);\n        else col = vec3(1.0, 0.3, 0.0);\n        \n        col *= max(dot(n, vec3(1.)), 0.1); //ndotl go brrr\n        \n        col -= max(vec3(ao), 0.05)*0.6;\n    }\n\n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nds3RH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 84, 84, 146], [148, 148, 200, 200, 299], [301, 301, 353, 353, 464], [467, 467, 494, 494, 620], [622, 622, 649, 649, 792], [806, 806, 825, 825, 1121], [1123, 1123, 1156, 1156, 1387], [1389, 1389, 1413, 1413, 1587], [1589, 1589, 1639, 1639, 1835], [1837, 1837, 1894, 1894, 2778]]}
{"id": "fdjXRV", "name": "Rainbow Vector Field", "author": "theott", "description": "I like colors!\nVector field generated using :  https://www.shadertoy.com/view/7dBSzK (in buffer B)\nGradient / continuous particle system : buffer A", "tags": ["visualization", "colors", "rainbow", "vectorfield"], "likes": 8, "viewed": 324, "published": 3, "date": "1620596454", "time_retrieved": "2024-07-30T19:21:02.779998", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = A(uv).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 U = (2.*fragCoord - iResolution.xy)/iResolution.y; // -1,1\n    vec2 V = fragCoord/iResolution.xy; // [0,1\n\n    vec2 field = B(V).xy; // get vector field \n    vec4 pre = A(V - 0.001 * field); // use vector field as gradient\n\n    vec3 col = pow3(clamp(pre.xyz,0.,.9),1.005); // color attenuation\n    \n    // Grid of poiints * Time varying pixel color * twinkle\n    float grid = smoothstep(0.01, 0., length(mod(U + 0.05, 0.1)));\n    vec3 palette = 0.5 + 0.5*cos(iTime+V.xyx+vec3(0,2,4));\n    float twinkle = map(sin(iTime/3.), -1.,1., 0.3, 1.);\n    col +=  grid * normalize(palette);// * twinkle;\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//methods from https://www.shadertoy.com/view/3tBGzh\n#define A(U) texture(iChannel0, U)\n#define B(U) texture(iChannel1, U)\n#define C(U) texture(iChannel2, U)\n\n//utility functions\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat unipolar(float x){\n    return map(x,-1.,1.,0.,1.);\n}\n\nvec2 unipolar2(vec2 u){\n    return vec2(unipolar(u.x), unipolar(u.y));\n}\n\nvec3 pow3(vec3 u, float a){\n    return vec3(pow(u.x,a), pow(u.y,a), pow(u.z,a));\n}", "buffer_b_code": "// Copy Pasted from https://www.shadertoy.com/view/7dBSzK\n\n//----------------\n  const int ps = 0; // use values > 1..10 for oldskool\n//----------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float x = fragCoord.x / iResolution.x * 640.;\n   float y = fragCoord.y / iResolution.y * 480.;\n   \n\tif (ps > 0)\n\t{\n\t   x = float(int(x / float(ps)) * ps);\n\t   y = float(int(y / float(ps)) * ps);\n\t}\n   \n   float t = iTime/30.;\n   \n   float mov0 = y/2.+sin(t)*10.+sin(x/90.)*70.+t*2.;\n   float mov1 = (mov0 / 5. + sin(mov0 / 30.))/ 10. + t * 3.;\n   float mov2 = mov1 + sin(mov1)*5. + t*1.0;\n   float cl1 = sin(sin(mov1/4. + t)+mov1);\n   float c1 = cl1 +mov2/2.-mov1-mov2+t;\n   float c2 = sin(c1+sin(mov0/100.+t)+sin(y/57.+t/50.)+sin((x+y)/200.)*2.);\n   float c3 = abs(sin(c2+cos((mov1+mov2+c2) / 10.)+cos((mov2) / 10.)+sin(x/80.)));\n  \n   float dc = float(16-ps);\n\t\n\tif (ps > 0)\n\t{\n   \t\tcl1 = float(int(cl1*dc))/dc;\n   \t\tc2 = float(int(c2*dc))/dc;\n   \t\tc3 = float(int(c3*dc))/dc;\n\t}\n\t\n   fragColor = vec4( cl1,c2,c3,1.0);\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjXRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 232]]}
{"id": "ssSSRV", "name": "Circle Doodle ", "author": "ircss", "description": "Was curious what shape the projection of the tangent around the circle to a specific point on the circumference would make.  ", "tags": ["circle", "sketch"], "likes": 4, "viewed": 300, "published": 3, "date": "1620595139", "time_retrieved": "2024-07-30T19:21:03.578862", "image_code": "#define TWO_PI 6.28318530718\n#define radius 0.3\n#define BUFFER iChannel0\n\n#define betweenVector vec3(0.784, 0.254, 0.254)\n#define originCol     vec3(0.768, 0.709, 0.709)\n#define rCurrentCol   vec3(0.803, 0.427, 0.396)\n#define toProjCol     vec3(0.937, 0.223, 0.164)\n#define circleCol     vec3(0.505, 0.254, 0.372)\n#define shapCol       vec3(0.956, 0.164, 0.533)\n\nvoid DrawVector(vec2 origin, vec2 vector, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * vUv/v2;\n    float d    = distance(p, uv);\n    sceneColor = mix(lineColor, sceneColor, smoothstep(size, size + 0.001, d));\n    \n}\n\nvoid DrawBetweenTwoPoints(vec2 origin, vec2 end, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n    \n    vec2 vector = end - origin;\n          uv  -= origin;\n    float len  = length(vector);\n       vector /= len;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * clamp(vUv, 0.,len) /v2;\n    float d    = distance(p, uv);\n\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.001, d), 0. ,1.)); \n}\n\nvoid DrawLengthedVector(vec2 origin, vec2 vector, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float len  = length(vector);\n       vector /= len;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * clamp(vUv, 0.,len) /v2;\n    float d    = distance(p, uv);\n\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.001, d), 0. ,1.)); \n}\n\nvoid DrawHalfVectorWithLength(vec2 origin, vec2 vector, float len, vec2 uv, float size, vec3 lineColor, inout vec3 sceneColor){\n    \n          uv  -= origin;\n    float v2   = dot(vector, vector);\n    float vUv  = dot(vector, uv);\n    vec2  p    = vector * clamp(vUv, 0.,len) /v2;\n    float d    = distance(p, uv);\n\n    sceneColor = mix(lineColor, sceneColor, clamp(smoothstep(size, size + 0.001, d), 0. ,1.)); \n}\n\nvoid DrawPoint(vec2 origin, vec2 uv, float size, vec3 pointColor, inout vec3 sceneColor){\n  float d = distance(uv, origin);\n  sceneColor = mix(pointColor, sceneColor, clamp(smoothstep(size, size + 0.001, d), 0. ,1.)); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 buff = texture(BUFFER, uv);\n\n    uv -= vec2(0.5);\n    uv.x *=  iResolution.x/iResolution.y;\n\n\n    float cAngle = iTime * 0.3;\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = -uv;\n    float angle = atan(toCenter.y,toCenter.x);\n          \n          angle = (angle/TWO_PI)+0.5;\n          //angle-= 0.25;\n          angle = fract(angle);\n      //    fragColor = vec4(angle);\n      //    return;\n    float pradius = length(toCenter);\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    vec2 cricle = vec2(cos(cAngle), sin(cAngle))*radius;\n\n    vec2 currentInPolar =  uv ;\n    float shouldDraw = abs( pradius - radius);\n          shouldDraw = step(0.004,shouldDraw);\n    \n\n   vec2 tangent = vec2(-sin(cAngle), cos(cAngle));\n\n\n  \n   \n   vec2 originalPoint = vec2(0., radius);\n   \n   vec2 toOrignalPoint = originalPoint - cricle;\n   \n   float fOnTangent = dot(toOrignalPoint, tangent);\n   vec2  drawPoint  = fOnTangent * normalize(tangent) + cricle;\n   \n    col = mix(circleCol, vec3(1.), shouldDraw);\n   \n   vec2 toDrawPoint = drawPoint - cricle;\n   vec2 orgToDrawP  = drawPoint - originalPoint;\n   \n    DrawLengthedVector(cricle, toOrignalPoint, uv, 0.004,  betweenVector, col);\n    DrawBetweenTwoPoints(cricle, vec2(0.), uv, 0.004,  rCurrentCol, col);\n    DrawBetweenTwoPoints(originalPoint, vec2(0.), uv, 0.004,  originCol, col);\n    DrawBetweenTwoPoints(drawPoint, cricle,  uv, 0.004,  toProjCol, col);\n    DrawVector(drawPoint, normalize(toDrawPoint),   uv, 0.001,  toProjCol, col);\n    DrawVector(drawPoint, normalize(orgToDrawP),   uv, 0.001,  toProjCol, col);\n    DrawPoint(cricle, uv, 0.013,  rCurrentCol, col);\n    DrawPoint(originalPoint, uv, 0.01,  originCol, col);\n    DrawPoint(vec2(0.), uv, 0.01,  originCol, col);\n    DrawPoint(drawPoint, uv, 0.013,  toProjCol, col);\n    //DrawVector(cricle, )    \n   // Output to screen\n   \n   col = mix(col, shapCol, buff.x );\n    fragColor = vec4(col.xyz, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TWO_PI 6.28318530718\n#define radius 0.3\n#define BUFFER iChannel0\n#define BUFF_RES iChannelResolution[0].xy\n\n\nfloat DrawPoint(vec2 origin, vec2 uv, float size){\n  float d = distance(uv, origin);\n  return clamp(smoothstep(size, size + 0.001, d), 0. ,1.); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv  = (fragCoord / BUFF_RES);\n        \n \n   vec4 buff = texture(BUFFER, uv);\n        \n         uv -= vec2(0.5);\n       uv.x *=  iResolution.x/iResolution.y;\n       \nfloat cAngle = iTime * 0.3;\n       \n vec2 cricle = vec2(cos(cAngle), sin(cAngle))*radius;\n float clearBuff = 1.-step(0.995,fract(cAngle / TWO_PI));   \n\n        \n            // Use polar coordinates instead of cartesian\n    vec2 toCenter = -uv;\n    float angle = atan(toCenter.y,toCenter.x);\n          angle = (angle/TWO_PI)+0.5;\n        \n   vec2 tangent = vec2(-sin(cAngle), cos(cAngle));\n   \n      vec2 originalPoint = vec2(0., radius);\n   \n   vec2 toOrignalPoint = originalPoint - cricle;\n   \n   float fOnTangent = dot(toOrignalPoint, tangent);\n   vec2  drawPoint  = fOnTangent * normalize(tangent) + cricle;\n        \n        \n        buff  += vec4(1. -DrawPoint(drawPoint, uv,  0.006));\n        \n    fragColor = clamp( buff * clearBuff, 0., 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSSRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[363, 363, 465, 465, 722], [724, 724, 833, 833, 1210], [1212, 1212, 1322, 1322, 1662], [1664, 1664, 1791, 1791, 2076], [2078, 2078, 2167, 2167, 2298], [2301, 2301, 2358, 2408, 4407]]}
{"id": "NsjXzK", "name": "Bosque poly-2d", "author": "jorge2017a1", "description": "Bosque poly-2d", "tags": ["2d", "draw", "poly", "bosquepoly2d", "polygono"], "likes": 2, "viewed": 211, "published": 3, "date": "1620587172", "time_retrieved": "2024-07-30T19:21:04.397672", "image_code": "//por jorge2017a1 ----jorgeFloresP---9/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\nconst vec3 colVerde=vec3(0.0,1.0,0.0);\nconst vec3 colVerde2=vec3(0.1,0.8,0.1);\nconst vec3 colrojoObs=vec3(0.45,0.13,0.15); //rojo obscuro\n\nconst vec3 col1=vec3(0.54,0.49,0.39);\nconst vec3 col2=vec3(0.06,0.07,1.0);\nconst vec3 col3=vec3(0.06,0.07,0.8);\n//const vec3 col4=vec3(0.45,0.13,0.15); //rojo obscuro\nconst vec3 col4=vec3(0.60,0.17,0.17); //vestido\nconst vec3 col5=vec3(0.73,0.60,0.55);\nconst vec3 colDorado=vec3(0.925,0.67,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.13,.01),vec2(.12,.19),vec2(.15,.28),vec2(.15,.20),vec2(.16,.13),\nvec2(.16,.07),vec2(.17,.03),vec2(.18,.01),vec2(.13,.01) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.29,.00),vec2(.30,.17),vec2(.29,.28),vec2(.26,.36),vec2(.32,.26),\nvec2(.35,.13),vec2(.35,.07),vec2(.36,.01),vec2(.29,.00) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.47,.01),vec2(.47,.03),vec2(.50,.03),vec2(.52,.03),vec2(.57,.03),\nvec2(.58,.04),vec2(.62,.04),vec2(.65,.03),vec2(.68,.03),vec2(.69,.03),\nvec2(.70,.01),vec2(.47,.01) );\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.57,.03),vec2(.56,.24),vec2(.52,.30),vec2(.53,.32),vec2(.56,.29),\nvec2(.59,.32),vec2(.61,.32),vec2(.60,.27),vec2(.62,.26),vec2(.67,.31),\nvec2(.67,.29),vec2(.62,.21),vec2(.62,.03),vec2(.57,.03) );\n\nfloat sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.52,.29),vec2(.47,.30),vec2(.42,.36),vec2(.38,.46),vec2(.43,.66),\nvec2(.56,.72),vec2(.72,.64),vec2(.79,.42),vec2(.75,.31),vec2(.66,.28),\nvec2(.52,.29) );\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.00,.45),vec2(.99,.46),vec2(.83,.70),vec2(.77,.58),vec2(.52,.90),\nvec2(.34,.64),vec2(.19,.83),vec2(.08,.56),vec2(.04,.62),vec2(.00,.45) );\n\n\nfloat sdPoly12b POLY(12)\nvec2 pt12b[ 12]=vec2[](  \nvec2(.83,.24),vec2(.77,.20),vec2(.69,.18),vec2(.66,.13),vec2(.70,.10),\nvec2(.82,.05),vec2(.93,.06),vec2(.99,.12),vec2(.98,.19),vec2(.92,.22),\nvec2(.86,.21),vec2(.83,.24) );\n\n\n//***------------****-----------****------------******-------\nvec3 Bosque1(in vec2 pp, vec3 col) \n{\n  vec2 p=pp,pr1=pp, pr2=pp;\n   pr1.x= opRep1D(pr1.x, 0.4 ); pr1.y-=0.04;\n   pr2.x= opRep1D(pr2.x, 0.7 ); pr2.y+=0.04;\n   \n   float sd9 = sdPoly9(pr1, pt9);\n   float sd9b = sdPoly9b(pr2, pt9b);\n   float sd12 = sdPoly12(p, pt12);\n   float sd14 = sdPoly14(p, pt14);\n   float sd11 = sdPoly11(p, pt11);\n   float sd10 = sdPoly10(p, pt10);\n   float sd10b = sdPoly10(p-vec2(0.5,0.2), pt10);\n   float sd10c = sdPoly10(p-vec2(-0.5,0.1), pt10);\n   float sd12b = sdPoly12b(p, pt12b);\n   float sdcielo=-p.y+0.68;\n   \n   vec3 colsky1=mix(colAzul,vec3(1.0),p.y*.75);\n   \n   col= ponerBorde(colsky1,col,sdcielo); //\n   col= ponerBorde(col4,col,sd10c); //montana\n   col= ponerBorde(col4,col,sd10b); //montana\n   col= ponerBorde(colrojoObs,col,sd10); //montana\n   col= ponerBorde(colAzul,col,sd12b);\n    col= ponerBorde(colVerde,col,sd9); //\n   col= ponerBorde(colVerde,col,sd9b);\n   col= ponerBorde(colVerde2,col,sd12);\n   col= ponerBorde(colVerde2,col,sd11); //arbol ramas\n   col= ponerBorde(colrojoObs,col,sd14); //tronco\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.5;\n    vec2 p=uv*0.5-vec2(-0.5,-0.5);\n    vec3 col=vec3(0.15,0.6,0.3); //vec3(0.25);\n    float tt=mod(iTime,10.0);\n    p.x= opRep1D(p.x+tt, 3.0 );\n    col=Bosque1(p, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 342, 378, 378, 423], [429, 429, 464, 464, 488], [490, 490, 550, 550, 674], [676, 676, 707, 707, 728], [3174, 3236, 3273, 3273, 4296], [4298, 4298, 4355, 4355, 4677]]}
{"id": "fsjXzK", "name": "Limacon Band Intersection 3D", "author": "oneshade", "description": "Intersection with a 3D limacon band.", "tags": ["3d", "raytracing", "ray", "raycasting", "intersection", "trochoid", "limacon"], "likes": 2, "viewed": 135, "published": 3, "date": "1620586870", "time_retrieved": "2024-07-30T19:21:05.147667", "image_code": "// Convenience struct\nstruct Intersect {\n    float depth;\n    float param;\n    vec3 pos;\n    vec3 nor;\n};\n\n// Updates nearest intersection\nvoid update(in vec3 ro, in vec3 rd, in float dd, in float alpha, in float thickness, in float param, inout Intersect isect) {\n    float t2 = 2.0 * param;\n    float depth = dot(vec2(cos(t2) + alpha * cos(param), sin(t2) + alpha * sin(param)) - ro.xy, rd.xy) / dd;\n    if (depth > 0.0 && (isect.depth < 0.0 ? true : depth < isect.depth)) {\n        vec3 pos = ro + rd * depth;\n        if (abs(pos.z) < thickness) {\n            isect.depth = depth;\n            isect.param = param;\n            isect.pos = pos;\n        }\n    }\n}\n\n// Intersection\nIntersect iLimaconBand(in vec3 ro, in vec3 rd, in float alpha, in float thickness) {\n    Intersect isect = Intersect(-1.0, 0.0, vec3(0.0), vec3(0.0));\n    float y = dot(ro.xy, normalize(rd.yx) * vec2(1.0, -1.0));\n    float u = atan(rd.y, rd.x), dd = dot(rd.xy, rd.xy);\n    alpha = abs(alpha); // Artifacts seem to occur for negative values\n\n    float shift = 0.5 * u;\n    vec2 sc = vec2(sin(shift), 2.0 * cos(shift)) * alpha;\n\n    // Solve a quartic in tan((x+shift)/2)\n    float qa = y + sc.x, qb = sc.y - 4.0, qc = 2.0 * y, qd = sc.y + 4.0, qe = y - sc.x;\n    qb /= qa; qc /= qa; qd /= qa; qe /= qa; // Divide by leading coefficient to make it 1\n\n    float bb = qb * qb;\n    float p = qc - 0.375 * bb;\n    float q = qd - 0.5 * qb * qc + 0.125 * bb * qb;\n    float r = qe - 0.25 * qb * qd + bb * qc / 16.0 - 3.0 * bb * bb / 256.0;\n\n    // Solve for an arbitary root to x^3 + 2px^2 + (p^2 - 4r)x - q^2\n    float ra = 2.0 * p;\n    float rb = p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float raa = ra * ra;\n    float inflect = ra / 3.0;\n\n    float rp = rb - raa / 3.0;\n    float rq = raa * ra / 13.5 - ra * rb / 3.0 + rc;\n    float rppp = rp * rp * rp, rqq = rq * rq;\n\n    float p2 = abs(rp);\n    float v1 = 1.5 / rp * rq;\n\n    float lambda;\n    if (rqq * 0.25 + rppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (rp < 0.0) lambda = sign(rq) * cosh(acosh(v2 * -sign(rq)) / 3.0);\n        else lambda = sinh(asinh(v2) / 3.0);\n        lambda = -sqrt(p2 / 3.0) * lambda;\n    }\n\n    else lambda = sqrt(-rp / 3.0) * cos(acos(v1 * sqrt(-3.0 / rp)) / 3.0);\n    lambda = 2.0 * lambda - inflect;\n\n    // Solve two quadratic equations (checking for negative sqrts which should be complex)\n    if (lambda < 0.0) return isect;\n    float sqrtLambda = sqrt(lambda);\n\n    float pLambda = p + lambda, qLambda = q / sqrtLambda;\n    float offs = 0.25 * qb;\n\n    float foo = lambda - 2.0 * (pLambda + qLambda);\n    float bar = lambda - 2.0 * (pLambda - qLambda);\n\n    if (foo >= 0.0) {\n        vec2 param = atan((vec2(1.0, -1.0) * sqrt(foo) + sqrtLambda) * 0.5 - offs) * 2.0 + shift;\n        update(ro, rd, dd, alpha, thickness, param.x, isect);\n        update(ro, rd, dd, alpha, thickness, param.y, isect);\n    }\n\n    if (bar >= 0.0) {\n        vec2 param = atan((vec2(1.0, -1.0) * sqrt(bar) - sqrtLambda) * 0.5 - offs) * 2.0 + shift;\n        update(ro, rd, dd, alpha, thickness, param.x, isect);\n        update(ro, rd, dd, alpha, thickness, param.y, isect);\n    }\n\n    if (isect.depth > 0.0) {\n        float t2 = 2.0 * isect.param; alpha *= 0.5;\n        isect.nor = vec3(normalize(vec2(cos(t2) + alpha * cos(isect.param), sin(t2) + alpha * sin(isect.param))), 0.0);\n    }\n\n    return  isect;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Intersect and render\n    Intersect hit = iLimaconBand(vec3(-ro.y, ro.xz), vec3(-rd.y, rd.xz), 3.0 * sin(iTime * 0.5), 0.75);\n    if (hit.depth > 0.0) {\n        hit.nor = vec3(-hit.nor.y, hit.nor.xz);\n        float diff = abs(dot(hit.nor, -rd));\n        float checkers = mod(floor(hit.param * 6.28) + floor(hit.pos.z * 2.5), 2.0);\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, hit.nor)), 0.25);\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjXzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 139, 264, 264, 663], [665, 681, 765, 765, 3377], [3379, 3379, 3434, 3434, 4609]]}
{"id": "fsBXDD", "name": "Parallelogram", "author": "Pentan", "description": "2D parallelogram distance field", "tags": ["2d", "distancefield", "sdf", "distance"], "likes": 4, "viewed": 294, "published": 3, "date": "1620582715", "time_retrieved": "2024-07-30T19:21:05.907635", "image_code": "float parallelogram2d(vec2 p, float w, float h, float s)\n{\n    vec2 v = vec2(s, h);\n    vec2 n = normalize(v.yx * vec2(1.0, -1.0));\n\n    float th = clamp(p.y / h, -1.0, 1.0);\n    vec2 o = vec2(clamp((p.x - s * th), -w, w), 0.0);\n    float t = clamp(dot(p - o, v) / dot(v, v), -1.0, 1.0);\n    float d0 = length(p - v * t - o);\n\n    float d1 = min(0.0, max(abs(p.y) - h, abs(dot(n, p)) - n.x * w));\n\n    return d0 + d1;\n}\n\nfloat grid(vec2 p) {\n    vec2 s = abs(vec2(dFdx(p).x, dFdy(p).y));\n    p = fract(p);\n    return (p.x < s.x || p.y < s.y) ? 1.0 : 0.0;\n}\n\nvec4 sdf_preview(float d, float lw) {\n    float ad = abs(d);\n    float l = 1.0 - smoothstep(lw - 1.0, lw, abs(d * min(iResolution.x, iResolution.y)));\n    float f = fract(ad * 10.0) * 0.2 + pow(fract(ad), 4.0) * 1.0;\n    vec4 c = (d > 0.0) ? vec4(0.0, f, d, 1.0) : vec4(-d, f, 0.0, 1.0);\n    return mix(c, vec4(0.0, 1.0, 0.0, 1.0), l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p *= 4.0;\n\n    float g = grid(p);\n\n    float w = (1.1 + sin(iTime * 0.8)) * 1.5;\n    float h = (1.1 + sin(iTime * 0.5)) * 1.0;\n    float s = 0.0 + sin(iTime * 1.3) * 2.0;\n    float d = parallelogram2d(p, w, h, s);\n\n    vec4 col;\n    col = mix(sdf_preview(d, 8.0), vec4(1.0, 1.0, 1.0, 1.0), g * 0.5);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBXDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 419], [421, 421, 441, 441, 556], [558, 558, 595, 595, 895], [897, 897, 954, 954, 1374]]}
{"id": "fd2XRK", "name": "duality2 for twitch.tv/sableraph", "author": "morisil", "description": "duality for:\n\nhttps://www.twitch.tv/sableraph", "tags": ["spiral", "signeddistance", "ornament"], "likes": 20, "viewed": 415, "published": 3, "date": "1620580788", "time_retrieved": "2024-07-30T19:21:06.659625", "image_code": "// Fork of \"duality for twitch.tv/sableraph\" by morisil. https://shadertoy.com/view/7dBXzV\n// 2021-05-09 17:16:25\n\n// the same shader, just at bit different parameters for more color spread\n\n// check out https://www.twitch.tv/sableraph\n// sableraph is posting creative coding chanllange every week and then review\n// sketches on the stream every Sunday. This time the topic was \"duality\"\n\n// Some comments:\n\n// I like that using trigonometric shapes is reducing the need of antialiasing whatsover\n\n// I started with grayscale, but then decided to apply distance based and angular\n// based chromatic abberration, which gives more video synthesis-like aesthetics\n// Maybe my childhood CRT experience makes me love vaporwave aesthetics so much :)\n\n\n#define SCALE                  140.0\n#define ROTATION_SPEED         -1.\n#define DISTANCE_SPREAD        -.01\n#define ANGLE_SPREAD           .5\n#define SHAPE_RANGE            1.6\n#define OSCILLATION_SPEED      .15\n#define OSCILLATION_AMPLITUDE  .2\n#define MIRROR_TRUE            1.\n#define MIRROR_FALSE           -1.\n\n\nfloat getColorComponent(float dist, float angle, float mirror) {\n    return clamp(\n        sin(\n            (dist * SCALE)\n                + angle * mirror\n                + (cos(dist * SCALE))\n                - (iTime * ROTATION_SPEED) * mirror\n        )\n        - dist * SHAPE_RANGE\n        ,-0.05 // try putting small negative value here, like -.2 :)\n        ,1.\n    );\n}\n\nvec3 getSwirl(vec2 center, float dist, float mirror) {\n    float angle = atan(center.x, center.y);\n    return vec3(\n        getColorComponent(dist * (1. - DISTANCE_SPREAD), angle - ANGLE_SPREAD, mirror),\n        getColorComponent(dist * (1. + 0.)             , angle - 0.          , mirror),\n        getColorComponent(dist * (1. + DISTANCE_SPREAD), angle + ANGLE_SPREAD, mirror)\n    );    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    vec2 oscillation = vec2(\n        sin(iTime * OSCILLATION_SPEED),\n        0.\n    ) * OSCILLATION_AMPLITUDE;\n    vec2 uv1 = uv + oscillation;\n    vec2 uv2 = uv - oscillation;\n    float dist1 = length(uv1);\n    float dist2 = length(uv2);\n    vec3 color =\n        getSwirl(uv1, dist1, MIRROR_TRUE)\n        + getSwirl(uv2, dist2, MIRROR_FALSE);\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1063, 1063, 1127, 1127, 1437], [1439, 1439, 1493, 1493, 1830], [1832, 1832, 1887, 1887, 2330]]}
{"id": "Ns2SRK", "name": "Cloud Shader", "author": "spectajin", "description": "Cloud shader generated from this tutorial:\nhttps://www.youtube.com/watch?v=hwa6XRXd1xQ", "tags": ["cloudshader"], "likes": 5, "viewed": 344, "published": 3, "date": "1620578592", "time_retrieved": "2024-07-30T19:21:07.421588", "image_code": "float noise(vec2 pq) {\n    return fract(\n        sin(\n        (pq.x * 19.) + iTime/11111111150. + \n        (pq.y * 180.) + iTime/11111111150.)* 360.);\n}\n\nfloat noiseSmooth(vec2 pq) {\n    vec2 index = floor(pq);\n    \n    vec2 frag = fract(pq);\n    frag = smoothstep(0.0, 1.0, frag);\n    \n    float topLeft = noise(index);\n    float topRight = noise(index + vec2(1,0));\n    float top = mix(topLeft,topRight, frag.x);\n    \n    float bottomLeft = noise(index + vec2(0,1));\n    float bottomRight = noise(index + vec2(1,1));\n    float bottom = mix(bottomLeft, bottomRight, frag.x);\n    \n    return mix(top, bottom, frag.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 sky = vec3(0.09, 0.7, 1.5) * (1.5 - uv.y) / (1.5 - uv.y) * 0.5; \n    \n    // uv += iMouse.xy / 20.;\n    uv.x += iTime / 35.;\n    \n    vec2 uv2 = uv;\n    \n     \n    uv2 += sin(iTime / 120.);\n    vec2 uv3 = uv;\n    uv3 += cos(iTime / 90.);\n     \n     \n    // Time varying pixel color\n    vec3 col = vec3(noiseSmooth(uv * 2.));\n    col += vec3(noiseSmooth(uv3 * 32.)) * 0.125;\n    col += vec3(noiseSmooth(uv3 * 64.)) * 0.0625;\n    col += vec3(noiseSmooth(uv2 * 16.)) * 0.25;\n    col += vec3(noiseSmooth(uv * 8.)) * 0.5;\n    col /= 1.5;\n    \n    col *= smoothstep(0.2, 0.9, (col + vec3(noiseSmooth(uv2 * 8.)) * 0.5)-0.1);\n    col = mix(vec3(1.), sky, 1. - col);\n     \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2SRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 152], [154, 154, 182, 182, 619], [620, 620, 677, 727, 1556]]}
{"id": "7dBXzV", "name": "duality for twitch.tv/sableraph", "author": "morisil", "description": "duality for:\n\nhttps://www.twitch.tv/sableraph", "tags": ["spiral", "signeddistance", "ornament"], "likes": 6, "viewed": 304, "published": 3, "date": "1620573989", "time_retrieved": "2024-07-30T19:21:08.181556", "image_code": "// check out https://www.twitch.tv/sableraph\n// sableraph is posting creative coding chanllange every week and then review\n// sketches on the stream every Sunday. This time the topic was \"duality\"\n\n// Some comments:\n\n// I like that using trigonometric shapes is reducing the need of antialiasing whatsover\n\n// I started with grayscale, but then decided to apply distance based and angular\n// based chromatic abberration, which gives more video synthesis-like aesthetics\n// Maybe my childhood CRT experience makes me love vaporwave aesthetics so much :)\n\n\n#define SCALE                  70.0\n#define ROTATION_SPEED         -1.\n#define DISTANCE_SPREAD        -.02\n#define ANGLE_SPREAD           .1\n#define SHAPE_RANGE            2.\n#define OSCILLATION_SPEED      .15\n#define OSCILLATION_AMPLITUDE  .2\n#define MIRROR_TRUE            1.\n#define MIRROR_FALSE           -1.\n\n\nfloat getColorComponent(float dist, float angle, float mirror) {\n    return clamp(\n        sin(\n            (dist * SCALE)\n                + angle * mirror\n                + (cos(dist * SCALE))\n                - (iTime * ROTATION_SPEED) * mirror\n        )\n        - dist * SHAPE_RANGE\n        ,0. // try putting small negative value here, like -.2 :)\n        ,1.\n    );\n}\n\nvec3 getSwirl(vec2 center, float dist, float mirror) {\n    float angle = atan(center.x, center.y);\n    return vec3(\n        getColorComponent(dist * (1. - DISTANCE_SPREAD), angle - ANGLE_SPREAD, mirror),\n        getColorComponent(dist * (1. + 0.)             , angle - 0.          , mirror),\n        getColorComponent(dist * (1. + DISTANCE_SPREAD), angle + ANGLE_SPREAD, mirror)\n    );    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    vec2 oscillation = vec2(\n        sin(iTime * OSCILLATION_SPEED),\n        0.\n    ) * OSCILLATION_AMPLITUDE;\n    vec2 uv1 = uv + oscillation;\n    vec2 uv2 = uv - oscillation;\n    float dist1 = length(uv1);\n    float dist2 = length(uv2);\n    vec3 color =\n        getSwirl(uv1, dist1, MIRROR_TRUE)\n        + getSwirl(uv2, dist2, MIRROR_FALSE);\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[870, 870, 934, 934, 1241], [1243, 1243, 1297, 1297, 1634], [1636, 1636, 1691, 1691, 2134]]}
{"id": "ssBSRK", "name": "how MIPmap is wrong", "author": "FabriceNeyret2", "description": "click for new seeds.\nAnother illustration of how MIPmap on not power-of-2 texture is wrong:\na few dots are drawn in white in the Buffer.\nsquares = where LOD 4,5,6 > 0 in the MIPmap of Buffer.\n→ squares sometime out of dot, + dot location in squares biased", "tags": ["glsl", "mipmap", "bug"], "likes": 5, "viewed": 385, "published": 3, "date": "1620559000", "time_retrieved": "2024-07-30T19:21:08.934542", "image_code": "// compare to Cubemap version ( power-of-2 texture ) : https://www.shadertoy.com/view/ssjXzK\n\n#define col(l)   m = T(U,l).w * float(1<<(2*l)); if (m > 0.01 ) O\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = vec4(T(U,0).w);        // particles\n    float m;\n    \n#if 0                          // ( better with texelFetch ) \n    col(4).g += .3;\n    col(5).r += .2 + .2* m;\n    col(6).b += .2 + .1* m;\n // col(4).g += m/2.; col(5).r += m/2.; col(6).b += m/2.; // cloud color scheme\n#else\n    col(4).g += .3;\n    col(5).r += .4; // .2 + .2* m*2.;// (.5+.5*cos(24.*m))*m*2.;\n    col(6).b += .5; // .2 + .1* m*2.;\n // col(1).b -= .5;            // more LODs\n // col(2).r -= .4; \n // col(3).g -= .3;\n#endif\n\n// if (m>0.) O +=  ( .6 + .6 * cos( 6.3*(m/6.)  + vec4(0,23,21,0)  ) ) * (m>6. ? 1. : .5);  // hue\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// .xy = particle coords  .w = density field : +1 at particle location then MIPmap\n\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n        if (iFrame == 0 || iMouse.w > 0. ) {                  // --- initialization\n            O = vec4( hash2(U+iTime) *R ,  0,-1 );            // random coords\n            return;\n        }\n        \n        O = T(U,0);                                           // recover previous state\n        \n        if ( O.w < 0. ) {                                     // new coords not yet splated \n            O.w = 0.;\n            for ( float y = .5; y < .01*R.y; y++ )            // splat some particles on screen\n                for ( float x = .5; x < .01*R.x; x++ )\n                    if( floor(T(vec2(x,y),0).xy) == floor(U) )    // if point in pixel, splat \n                        { O.w++; return; }\n          }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R        iResolution.xy\n\n//#define T(U,l)   texelFetch( iChannel0, ivec2(U) / (1<<(l)), l ) // using texelFetch array\n//#define T(U,l)   texelFetch( iChannel0, ivec2( (U)/R*vec2(textureSize(iChannel0,l).xy) ), l ) \n\n  #define T(U,l)   textureLod( iChannel0, (U)/R, float(l) )        // using texture interpolation\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBSRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 199, 199, 802]]}
{"id": "NdBXzV", "name": "ShyGuy Mask", "author": "IWBTShyGuy", "description": "Someday, I'll be able to model the body too.", "tags": ["raymarching", "shyguy"], "likes": 2, "viewed": 326, "published": 3, "date": "1620550968", "time_retrieved": "2024-07-30T19:21:09.694510", "image_code": "// Copyright © 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n// ----------------------- 3D common ----------------------- //\n\nconst float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n// ------------------- Physically Based Shading ------------------- //\n// reference: https://www.shadertoy.com/view/4sSfzK\n\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\n\nvec3 EnvRemap(vec3 c) {\n\treturn pow(2. * c, vec3(2.2));\n}\n\nfloat VisibilityTerm(float roughness, float ndotv, float ndotl) {\n\tfloat r2 = roughness * roughness;\n\tfloat gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2);\n\tfloat gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\n\treturn 0.5 / max(gv + gl, 0.00001);\n}\n\nfloat DistributionTerm(float roughness, float ndoth) {\n\tfloat r2 = roughness * roughness;\n\tfloat d = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 / (d * d * PI);\n}\n\nvec3 FresnelTerm(vec3 specularColor, float vdoth) {\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\n// ------------------- persona semi SDF ------------------- //\n\nconst mat3 BASE_MAT = mat3(\n    1.3, 0.0, 0.0,\n    0.0, 1.5, 0.0,\n    0.0, 0.0, 1.2\n);\nconst mat3 BASE_INV = inverse(BASE_MAT);\n\nconst mat3 CONTOUR_MAT = mat3(\n    1, 0, 0,\n    0, 0, -1,\n    0, 1, 0\n);\nconst mat3 CONTOUR_INV = inverse(CONTOUR_MAT);\n\nconst mat3 EYE_MAT = mat3(\n    0.3, 0, 0,\n    0, 0, -1,\n    0, 0.4, 0\n);\nconst mat3 EYE_INV = inverse(EYE_MAT);\n\nconst mat3 MOUTH_MAT = mat3(\n    0.15, 0, 0,\n    0, 0, -1,\n    0, 0.15, 0\n);\nconst mat3 MOUTH_INV = inverse(MOUTH_MAT);\n\nvec3 normalTransform(in mat3 matrix, in vec3 normal) {\n    mat3 trans = inverse(transpose(matrix));\n    return normalize(trans * normal * determinant(matrix));\n}\n\nfloat sphereSDF(in vec3 p, out vec3 normal) {\n    normal = p;\n    return length(p) - 1.0;\n}\n\nfloat cylinderSDF(in vec3 p, out vec3 normal) {\n    normal = vec3(p.x, 0, p.z);\n    return length(p.zx) - 1.0;\n}\n\nfloat shapeSemiSDF(in vec3 p, out mat3 mat, out vec3 normal) {\n    float dist_tmp;\n    vec3 normal_tmp;\n\n    // base\n    float dist = sphereSDF(BASE_INV * (p + vec3(0, 0, 0.9)), normal);\n    mat = BASE_MAT;\n    \n    // contour\n    dist_tmp = cylinderSDF(CONTOUR_INV * p, normal_tmp);\n    dist = max(dist, dist_tmp / 2.0);\n    mat = mat + (1.0 - sign(dist - dist_tmp)) * CONTOUR_MAT;\n    normal = normal + (1.0 - sign(dist - dist_tmp)) * normal_tmp;\n\n    // eye0\n    dist_tmp = -cylinderSDF(EYE_INV * (p - vec3(0.4, 0.3, 0.0)), normal_tmp);\n    dist = max(dist, dist_tmp * 0.3);\n    mat = mat + (1.0 - sign(dist - dist_tmp)) * EYE_MAT;\n    normal = normal - (1.0 - sign(dist - dist_tmp)) * normal_tmp;\n    \n    // eye1\n    dist_tmp = -cylinderSDF(EYE_INV * (p - vec3(-0.4, 0.3, 0.0)), normal_tmp);\n    dist = max(dist, dist_tmp * 0.3);\n    mat = mat + (1.0 - sign(dist - dist_tmp)) * EYE_MAT;\n    normal = normal - (1.0 - sign(dist - dist_tmp)) * normal_tmp;\n\n    // mouth\n    dist_tmp = -cylinderSDF(MOUTH_INV * (p - vec3(0.0, -0.55, 0.0)), normal_tmp);\n    dist = max(dist, dist_tmp * 0.1);\n    mat = mat + (1.0 - sign(dist - dist_tmp)) * MOUTH_MAT;\n    normal = normal - (1.0 - sign(dist - dist_tmp)) * normal_tmp;\n    \n    // face\n    dist_tmp = -sphereSDF(BASE_INV * (p + vec3(0, 0, 0.95)), normal_tmp);\n    dist = max(dist, dist_tmp);\n    mat = mat + (1.0 - sign(dist - dist_tmp)) * BASE_MAT;\n    normal = normal - (1.0 - sign(dist - dist_tmp)) * normal_tmp;\n    \n    return dist;\n}\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 mouse = iMouse / iResolution.xyxy;\n    float onMouse = max(sign(iMouse.z), 0.0);\n    float phase = (1.0 - onMouse) * 0.25 * iTime - onMouse * PI * (2.0 * mouse.x - 1.0);\n    float height = (1.0 - onMouse) * 0.2 - onMouse * (3.0 * mouse.y - 1.5);\n    vec3 r = vec3(sin(phase), height, cos(phase));\n    Camera camera = newCamera(\n        3.5 * r,\n        -r,\n        vec3(0, 1, 0),\n        PI / 5.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    vec3 light_position = 2.0 * r;\n   \n    vec3 p, normal;\n    float dist = 0.0, t = 0.0;\n\n    for (int _i = 0; _i < 256; _i++) {\n        t += dist / 1.3;\n        p = ray.origin + t * ray.direction;\n        mat3 mat;\n        dist = shapeSemiSDF(p, mat, normal);\n        if (dist < 0.0001) {\n            normal = normalTransform(mat, normal);\n            break;\n        };\n    }\n\n    fragColor = vec4(pow(texture(iChannel1, ray.direction).xyz, vec3(2.2)), 1000.0);\n    if (dist < 0.0001) {\n        float is_head = max(sign(normal.z), 0.0);\n        float roughness = 0.75 - 0.5 * is_head;\n\n        vec3 lightDir = ray.direction;\n\t\tvec3 viewDir = -ray.direction;\n\t\tvec3 refl = reflect(ray.direction, normal);\n        float roughnessE = roughness * roughness;\n        float roughnessL = max(0.1, roughnessE);\n        vec3 specularColor = vec3(1);\n\n\t\tvec3 diffuse = vec3(0);\n\t\tvec3 specular = vec3(0);\n\n\t\tvec3 halfVec = normalize(viewDir + lightDir);\n\t\tfloat vdoth = clamp(dot(viewDir, halfVec), 0.0, 1.0);\n\t\tfloat ndoth = clamp(dot(normal, halfVec), 0.0, 1.0);\n\t\tfloat ndotv = clamp(dot(normal, viewDir), 0.0, 1.0);\n\t\tfloat ndotl = clamp(dot(normal, lightDir), 0.0, 1.0);\n\t\tvec3 envSpecularColor = EnvBRDFApprox(vec3(1), roughnessE, ndotv);\n\n\t\tvec3 env1 = EnvRemap(texture(iChannel0, refl).xyz);\n\t\tvec3 env2 = EnvRemap(texture(iChannel1, refl).xyz);\n\t\tvec3 env3 = EnvRemap(vec3(1.0));\n\t\tvec3 env = mix(env1, env2, clamp(roughnessE * 4.0, 0.0, 1.0));\n\t\tenv = mix(env, env3, clamp((roughnessE - 0.25) / 0.75, 0.0, 1.0));\n\n\t\tdiffuse += vec3(1.0);\n\t\tspecular += envSpecularColor * env;\n\n\t\tdiffuse += clamp(dot(normal, lightDir), 0.0, 1.0);\n\n\t\tvec3 lightF = FresnelTerm(specularColor, vdoth);\n\t\tfloat lightD = DistributionTerm(roughnessL, ndoth);\n\t\tfloat lightV = VisibilityTerm(roughnessL, ndotv, ndotl);\n\t\tspecular += lightF * (lightD * lightV * PI * ndotl);\n\n\t\tvec3 color = diffuse * 2.0 + specular;\n        color *= 0.25 + is_head * 0.75;\n\n        fragColor = vec4(color * 0.4, distance(p, ray.origin));\n    }\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, Activate AA, level: 2 or 3\n#define AA 2\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if ( fwidth(length(O.xyz)) > 0.1 && O.w < 50.0 ) {\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 2.0);\n              O += o;\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += 2 - abs(sign(k - 3)) ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += o;\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n    }\n#endif\n\n    O = pow(O, vec4(1.0 / 2.2));\n    O.w = 1.0;\n}\n", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27117, "src": "https://soundcloud.com/mabovsky/arabian-night-orchestral", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBXzV.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[401, 401, 494, 494, 690], [692, 813, 858, 858, 1292], [1418, 1496, 1566, 1566, 1841], [1843, 1843, 1866, 1866, 1900], [1902, 1902, 1967, 1967, 2163], [2165, 2165, 2219, 2219, 2330], [2332, 2332, 2383, 2383, 2480], [3030, 3030, 3084, 3084, 3191], [3193, 3193, 3238, 3238, 3284], [3286, 3286, 3333, 3333, 3398], [3400, 3400, 3462, 3462, 4887], [4889, 4889, 4945, 4945, 7466]]}
{"id": "NdSXzV", "name": "Limacon Intersection 2D I", "author": "oneshade", "description": "Intersections with this case of a trochoid can be solved analytically. Best part, you can apply all sorts of transformations without having to change the intersector (translate, rotate, scale, shear)!", "tags": ["2d", "ray", "raycasting", "intersection", "trochoid", "limacon"], "likes": 8, "viewed": 153, "published": 3, "date": "1620550041", "time_retrieved": "2024-07-30T19:21:10.550223", "image_code": "// Convenience struct\nstruct Hit4 {\n    int nHit;\n    vec4 tHit;\n};\n\n// Drawing utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sqLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    vec2 toProj = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return dot(toProj, toProj);\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdInfLine(in vec2 p, in vec2 a, in vec2 b) {\n    return abs(dot(p - a, normalize(b - a).yx * vec2(-1.0, 1.0)));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\n// Parametric\nvec2 posLimacon(in float t, in float alpha) {\n    float t2 = 2.0 * t;\n    float x = cos(t2) + alpha * cos(t);\n    float y = sin(t2) + alpha * sin(t);\n    return vec2(x, y);\n}\n\n// Intersection\nHit4 iLimacon(in vec2 ro, in vec2 rd, in float alpha) {\n    Hit4 isect = Hit4(0, vec4(-1.0));\n    float y = dot(ro, normalize(rd).yx * vec2(1.0, -1.0));\n    float u = atan(rd.y, rd.x), dd = dot(rd, rd);\n\n    float shift = 0.5 * u;\n    vec2 sc = vec2(sin(shift), 2.0 * cos(shift)) * alpha;\n\n    // Solve a quartic in tan((x+shift)/2)\n    float qa = y + sc.x, qb = sc.y - 4.0, qc = 2.0 * y, qd = sc.y + 4.0, qe = y - sc.x;\n    qb /= qa; qc /= qa; qd /= qa; qe /= qa; // Divide by leading coefficient to make it 1\n\n    float bb = qb * qb;\n    float p = qc - 0.375 * bb;\n    float q = qd - 0.5 * qb * qc + 0.125 * bb * qb;\n    float r = qe - 0.25 * qb * qd + 0.0625 * bb * qc - 0.01171875 * bb * bb;\n\n    // Solve for an arbitary root to x^3 + 2px^2 + (p^2 - 4r)x - q^2\n    float ra = 2.0 * p;\n    float rb = p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float raa = ra * ra;\n    float inflect = ra / 3.0;\n\n    float rp = rb - raa / 3.0;\n    float rq = raa * ra / 13.5 - ra * rb / 3.0 + rc;\n    float rppp = rp * rp * rp, rqq = rq * rq;\n\n    float p2 = abs(rp);\n    float v1 = 1.5 / rp * rq;\n\n    float lambda;\n    if (rqq * 0.25 + rppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (rp < 0.0) lambda = sign(rq) * cosh(acosh(v2 * -sign(rq)) / 3.0);\n        else lambda = sinh(asinh(v2) / 3.0);\n        lambda = -sqrt(p2 / 3.0) * lambda;\n    }\n\n    else lambda = sqrt(-rp / 3.0) * cos(acos(v1 * sqrt(-3.0 / rp)) / 3.0);\n    lambda = 2.0 * lambda - inflect;\n\n    // Solve two quadratic equations (checking for negative sqrts which should be complex)\n    if (lambda < 0.0) return isect;\n    float sqrtLambda = sqrt(lambda);\n\n    float pLambda = p + lambda, qLambda = q / sqrtLambda;\n    float offs = 0.25 * qb;\n\n    float foo = lambda - 2.0 * (pLambda + qLambda);\n    float bar = lambda - 2.0 * (pLambda - qLambda);\n\n    if (foo >= 0.0) {\n        vec2 roots = atan((vec2(1.0, -1.0) * sqrt(foo) + sqrtLambda) * 0.5 - offs) * 2.0 + shift;\n        isect.tHit.x = dot(posLimacon(roots.x, alpha) - ro, rd) / dd; // Project onto the ray\n        isect.tHit.y = dot(posLimacon(roots.y, alpha) - ro, rd) / dd;\n        isect.nHit += 2;\n    }\n\n    if (bar >= 0.0) {\n        vec2 roots = atan((vec2(1.0, -1.0) * sqrt(bar) - sqrtLambda) * 0.5 - offs) * 2.0 + shift, tRoots;\n        tRoots.x = dot(posLimacon(roots.x, alpha) - ro, rd) / dd; // Project onto the ray\n        tRoots.y = dot(posLimacon(roots.y, alpha) - ro, rd) / dd;\n        if (isect.nHit > 0) isect.tHit.zw = tRoots;\n        else isect.tHit.xy = tRoots;\n        isect.nHit += 2;\n    }\n\n    return  isect;\n}\n\n// Animation\nvec2 Hash12(in float t) {\n\tvec3 p3 = fract(t * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec4 getRay(in float t) {\n    float id = floor(t), local = fract(t);\n    vec2 a = Hash12(id), b = Hash12(id + 1.0), c = Hash12(id + 2.0);\n    vec2 mid1 = 0.5 * (a + b), mid2 = 0.5 * (b + c);\n\n    float tInv = 1.0 - local;\n    vec2 pos = mid1 * tInv * tInv + 2.0 * b * tInv * local + mid2 * local * local;\n    vec2 dir = normalize(mid1 * (local - 1.0) + (1.0 - 2.0 * local) * b + mid2 * local);\n\n    return vec4(pos, dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 8.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 8.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float alpha = 3.0 * sin(iTime * 0.5);\n\n    vec4 ray = getRay(iTime * 0.25);\n    vec2 ro = ray.xy * 8.0 - 4.0, rd = ray.zw;\n    if (iMouse.z > 0.0) ro = mouse.zw, rd = mouse.xy - mouse.zw;\n\n    // Nice colors from iq\n    float limacon = 1e20;\n    vec2 prev = posLimacon(-3.14, alpha);\n    float tStep = 0.05;\n    for (float t=tStep - 3.14; t < 3.14 + tStep; t += tStep) {\n        vec2 cur = posLimacon(t, alpha);\n        limacon = min(limacon, sqLine(uv, prev, cur));\n        prev = cur;\n    }\n\n    drawSDF(sqrt(limacon) * 0.5 - 0.015, vec3(0.0, 0.0, 1.0));\n    drawSDF(sdInfLine(uv * 0.5, ro * 0.5, (ro + rd) * 0.5) - 0.001, vec3(1.0, 0.8, 0.0));\n    drawSDF(sdVectorArrow((uv - ro) * 0.5, rd * 0.5), vec3(1.0));\n\n    // Find the closest hit in front of the camera\n    Hit4 hit = iLimacon(ro, rd, alpha);\n    for (int n=0; n < hit.nHit; n++) {\n        vec2 pos = ro + rd * hit.tHit[n];\n        drawSDF(length(uv - pos) - 0.1, vec3(1.0, 0.0, 0.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSXzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 179, 233, 233, 509], [511, 511, 558, 558, 697], [699, 699, 744, 744, 812], [814, 814, 864, 864, 933], [935, 935, 978, 978, 1166], [1168, 1182, 1227, 1227, 1356], [1358, 1374, 1429, 1429, 3945], [3947, 3960, 3985, 3985, 4114], [4116, 4116, 4141, 4141, 4539], [4541, 4541, 4596, 4596, 5845]]}
{"id": "fdBXRK", "name": "Rey sentado", "author": "jorge2017a1", "description": "Rey sentado", "tags": ["2d", "draw", "reysentado", "pintura", "dibujo"], "likes": 4, "viewed": 215, "published": 3, "date": "1620527184", "time_retrieved": "2024-07-30T19:21:11.429871", "image_code": "//por jorge2017a1 ----jorgeFloresP---8/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\nconst vec3 colVerde=vec3(0.0,1.0,0.0);\n\nconst vec3 col1=vec3(0.54,0.49,0.39);\nconst vec3 col2=vec3(0.06,0.07,1.0);\nconst vec3 col3=vec3(0.06,0.07,0.8);\n//const vec3 col4=vec3(0.45,0.13,0.15); //rojo obscuro\nconst vec3 col4=vec3(0.60,0.17,0.17); //vestido\nconst vec3 col5=vec3(0.73,0.60,0.55);\nconst vec3 colDorado=vec3(0.925,0.67,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly25 POLY(25)\nvec2 pt25[ 25]=vec2[](  \nvec2(.08,.01),vec2(.07,.50),vec2(.08,.58),vec2(.09,.65),vec2(.10,.67),\nvec2(.12,.67),vec2(.14,.65),vec2(.16,.57),vec2(.17,.55),vec2(.18,.51),\nvec2(.19,.47),vec2(.17,.45),vec2(.17,.44),vec2(.18,.37),vec2(.21,.28),\nvec2(.26,.21),vec2(.33,.17),vec2(.39,.15),vec2(.40,.11),vec2(.40,.05),\nvec2(.37,.02),vec2(.33,.03),vec2(.31,.05),vec2(.31,.01),vec2(.08,.01) );\n\nfloat sdPoly41 POLY(41)\nvec2 pt41[ 41]=vec2[](  \nvec2(.09,.65),vec2(.11,.57),vec2(.13,.56),vec2(.14,.53),vec2(.14,.48),\nvec2(.13,.46),vec2(.11,.45),vec2(.13,.36),vec2(.13,.31),vec2(.16,.23),\nvec2(.20,.18),vec2(.26,.14),vec2(.31,.13),vec2(.34,.12),vec2(.35,.08),\nvec2(.34,.06),vec2(.32,.05),vec2(.31,.05),vec2(.33,.04),vec2(.37,.03),\nvec2(.39,.05),vec2(.40,.08),vec2(.40,.11),vec2(.39,.14),vec2(.34,.17),\nvec2(.28,.20),vec2(.24,.23),vec2(.18,.34),vec2(.17,.41),vec2(.17,.45),\nvec2(.18,.47),vec2(.19,.50),vec2(.18,.54),vec2(.16,.56),vec2(.16,.57),\nvec2(.15,.62),vec2(.14,.65),vec2(.13,.66),vec2(.11,.67),vec2(.10,.66),\nvec2(.09,.65) );\n\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.07,.57),vec2(.79,.60),vec2(.80,.01),vec2(.08,.01),vec2(.07,.57) );\n\n\nfloat sdPoly25c POLY(25)\nvec2 pt25c[ 25]=vec2[](  \nvec2(.26,.22),vec2(.26,.30),vec2(.30,.40),vec2(.34,.52),vec2(.36,.57),\nvec2(.40,.58),vec2(.43,.59),vec2(.46,.63),vec2(.50,.68),vec2(.53,.78),\nvec2(.57,.83),vec2(.62,.85),vec2(.66,.84),vec2(.70,.80),vec2(.74,.72),\nvec2(.73,.67),vec2(.71,.61),vec2(.69,.56),vec2(.68,.55),vec2(.73,.46),\nvec2(.81,.32),vec2(.84,.28),vec2(.93,.02),vec2(.26,.01),vec2(.26,.22) );\n\n\nfloat sdPoly31 POLY(31)\nvec2 pt31[ 31]=vec2[](  \nvec2(.26,.01),vec2(.26,.29),vec2(.36,.57),vec2(.42,.59),vec2(.45,.62),\nvec2(.49,.67),vec2(.51,.71),vec2(.53,.77),vec2(.55,.80),vec2(.59,.84),\nvec2(.63,.85),vec2(.66,.84),vec2(.70,.81),vec2(.73,.75),vec2(.66,.73),\nvec2(.63,.72),vec2(.62,.68),vec2(.60,.67),vec2(.59,.65),vec2(.57,.62),\nvec2(.55,.62),vec2(.55,.59),vec2(.54,.57),vec2(.53,.56),vec2(.57,.50),\nvec2(.55,.47),vec2(.53,.30),vec2(.52,.22),vec2(.51,.13),vec2(.50,.02),\nvec2(.26,.01) );\n\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.52,.55),vec2(.55,.54),vec2(.57,.54),vec2(.59,.54),vec2(.60,.56),\nvec2(.61,.54),vec2(.60,.53),vec2(.59,.53),vec2(.58,.52),vec2(.58,.52),\nvec2(.58,.53),vec2(.55,.53),vec2(.53,.54),vec2(.52,.55) );\n\n\nfloat sdPoly30 POLY(30)\nvec2 pt30[ 30]=vec2[](  \nvec2(.53,.56),vec2(.58,.64),vec2(.65,.78),vec2(.70,.74),vec2(.70,.71),\nvec2(.70,.70),vec2(.69,.68),vec2(.68,.64),vec2(.68,.63),vec2(.67,.63),\nvec2(.66,.63),vec2(.66,.63),vec2(.67,.62),vec2(.67,.62),vec2(.65,.62),\nvec2(.64,.62),vec2(.66,.61),vec2(.66,.60),vec2(.65,.60),vec2(.65,.58),\nvec2(.64,.58),vec2(.61,.59),vec2(.59,.61),vec2(.60,.59),vec2(.60,.57),\nvec2(.60,.56),vec2(.59,.55),vec2(.56,.55),vec2(.54,.55),vec2(.53,.56) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.69,.69),vec2(.68,.70),vec2(.67,.70),vec2(.64,.71),vec2(.67,.69),\nvec2(.68,.69),vec2(.69,.69) );\n\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.64,.69),vec2(.65,.69),vec2(.66,.68),vec2(.67,.68),vec2(.66,.67),\nvec2(.65,.67),vec2(.64,.68),vec2(.64,.68),vec2(.64,.69) );\n\nfloat sdPoly5b POLY(5)\nvec2 pt5b[ 5]=vec2[](  \nvec2(.51,.68),vec2(.19,.72),vec2(.23,.68),vec2(.49,.65),vec2(.51,.68) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.51,.68),vec2(.19,.72),vec2(.23,.68),vec2(.49,.65),vec2(.51,.70),\nvec2(.22,.82),vec2(.19,.87),vec2(.53,.74),vec2(.51,.68) );\n\nfloat sdPoly13 POLY(13)\nvec2 pt13[ 13]=vec2[](  \nvec2(.51,.68),vec2(.19,.72),vec2(.23,.68),vec2(.49,.65),vec2(.51,.70),\nvec2(.22,.82),vec2(.19,.87),vec2(.53,.74),vec2(.54,.79),vec2(.33,.95),\nvec2(.33,1.00),vec2(.57,.82),vec2(.51,.68) );\n\nfloat sdPoly5c POLY(5)\nvec2 pt5c[ 5]=vec2[](  \nvec2(.67,.82),vec2(.85,.98),vec2(.89,.97),vec2(.70,.79),vec2(.67,.82) );\n\nfloat sdPoly20 POLY(20)\nvec2 pt20[ 20]=vec2[](  \nvec2(.51,.10),vec2(.53,.07),vec2(.55,.03),vec2(.56,.02),vec2(.57,.02),\nvec2(.57,.04),vec2(.57,.03),vec2(.58,.03),vec2(.59,.04),vec2(.59,.03),\nvec2(.61,.03),vec2(.61,.05),vec2(.62,.03),vec2(.63,.03),vec2(.63,.06),\nvec2(.60,.10),vec2(.55,.13),vec2(.53,.14),vec2(.52,.13),vec2(.51,.10) );\n\n\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[ 7]=vec2[](  \nvec2(.66,.62),vec2(.65,.62),vec2(.64,.62),vec2(.64,.62),vec2(.65,.62),\nvec2(.66,.61),vec2(.66,.62) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.52,.56),vec2(.60,.55),vec2(.68,.36),vec2(.70,.28),vec2(.72,.24),\nvec2(.73,.04),vec2(.73,.08),vec2(.73,.07),vec2(.80,.03),vec2(.82,.01),\nvec2(.50,.01),vec2(.52,.56) );\n\nfloat sdPoly5d POLY(5)\nvec2 pt5d[ 5]=vec2[](  \nvec2(.66,.71),vec2(.92,.85),vec2(.97,.84),vec2(.70,.68),vec2(.66,.71) );\n\n\nfloat sdPoly5e POLY(5)\nvec2 pt5e[ 5]=vec2[](  \nvec2(.70,.67),vec2(.94,.76),vec2(.98,.74),vec2(.70,.63),vec2(.70,.67) );\n\nfloat sdPoly7c POLY(7)\nvec2 pt7c[ 7]=vec2[](  \nvec2(.00,.93),vec2(.05,.92),vec2(.15,.92),vec2(.17,.02),vec2(.06,.01),\nvec2(.00,.05),vec2(.00,.93) );\n\n//***------------****-----------****------------******-------\nvec3 RostroChica(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n   float sd25 = sdPoly25(p, pt25);\n   float sd41 = sdPoly41(p, pt41);\n   float sd5 = sdPoly5(p, pt5);\n   \n   float sd25b = sdPoly25(p-vec2(0.7,0.0), pt25);\n   float sd41b = sdPoly41(p-vec2(0.7,0.0), pt41);\n   float sd25c = sdPoly25c(p, pt25c);\n   float sd31 = sdPoly31(p, pt31);    \n   float sd14 = sdPoly14(p, pt14);\n   float sd30 = sdPoly30(p, pt30);\n   float sd7 = sdPoly7(p, pt7);\n   float sd9 = sdPoly9(p, pt9);\n   float sd5b = sdPoly5b(p, pt5b);\n   float sd9b = sdPoly9b(p, pt9b);\n   float sd13 = sdPoly13(p, pt13);\n   float sd5c = sdPoly5c(p, pt5c);\n   float sd20 = sdPoly20(p-vec2(-0.01,0.05*sin(iTime)), pt20);\n   float sd12 = sdPoly12(p, pt12);\n   float sd5d = sdPoly5d(p, pt5d);    \n   float sd5e = sdPoly5e(p, pt5e);\n   float sd7c = sdPoly7c(p, pt7c);\n   float sd7d = sdPoly7c(p-vec2(0.8,0.0), pt7c);\n   \n   col= ponerBorde(col1,col,sd5); //respaldo silla\n   col= ponerBorde(col1,col,sd7c); //columna\n   col= ponerBorde(col1,col,sd7d); //columna\n   col= ponerBorde(col1,col,sd25b);//silla figura 2\n   col= ponerBorde(col1,col,sd41b); //figura silla 2\n   col= ponerBorde(colDorado,col,sd5b); // rayo1\n   col= ponerBorde(colDorado,col,sd9b); // rayo1\n   col= ponerBorde(colDorado,col,sd13); // rayo1\n   col= ponerBorde(colDorado,col,sd5c); // rayo1\n   col= ponerBorde(colDorado,col,sd5d); // rayo1\n   col= ponerBorde(colDorado,col,sd5e); // rayo1\n   col= ponerBorde(col3,col,sd25c); //vestido izq\n   col= ponerBorde(col2,col,sd31); //vestido der\n   col= ponerBorde(col4,col,sd12); //vestido\n   col= ponerBorde(col1,col,sd25);//silla izq\n   col= ponerBorde(col1,col,sd41); //figura silla izq\n   col= ponerBorde(colVerde,col,sd14); //anillo cuello\n   col= ponerBorde(col5,col,sd30); //rostro\n   col= ponerBorde(colNegro,col,sd7); //pestaña\n   col= ponerBorde(colBlanco,col,sd9); //ojo\n   col= ponerBorde(col5,col,sd20); //mano\n   \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*1.0;\n    vec2 p=uv*0.5-vec2(-0.5,-0.5);\n    vec3 col=vec3(0.0); //vec3(0.25);\n    \n    //col=RostroChica(p*0.5-vec2(-0.25,0.0), col);\n    col=RostroChica(p, col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBXRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 339, 339, 363], [365, 365, 425, 425, 549], [551, 551, 582, 582, 603], [6375, 6437, 6478, 6478, 8350], [8352, 8352, 8409, 8409, 8725]]}
{"id": "NsSSRK", "name": "Mathematica Color Schemes", "author": "harry7557558", "description": "Apply least-squares fitting to Wolfram language color schemes.\n[url]https://harry7557558.github.io/Graphics/UI/color_functions/[/url]", "tags": ["color", "palette", "cosine", "polynomial", "leastsquare"], "likes": 29, "viewed": 582, "published": 3, "date": "1620523568", "time_retrieved": "2024-07-30T19:21:12.487044", "image_code": "// Wolfram Language Color Schemes (least square fitting)\n\n// Apply least square fitting to color images downloaded from\n// https://reference.wolfram.com/language/guide/ColorSchemes.html\n\n// Curve fitting code (check the .py files):\n// https://github.com/harry7557558/Graphics/tree/master/UI/color_functions\n\n// Each color scheme is fitted to three functions:\n\n// `P`: Polynomial functions of varying degree;\n// `T`: Functions in the form color(x)=c₀+c₁⋅x+a₀⋅cos(π⋅x-u₀)+∑ₖ[aₖ⋅cos(2kπ⋅x-uₖ)];\n// `C`: Functions in the form color(t)=a+b*t+c*cos(d*t+e), inspired by iq's cosine color palette article;\n\n// Coefficients for `cosine` are computed numerically and may not be optimal. \n\n// For a better visual comparison of the three color functions,\n// go to https://harry7557558.github.io/Graphics/UI/color_functions/\n\n// Disclaimer: I’m not related to Wolfram in anyway. Wolfram reserves the rights of these color schemes.\n\n\n/* ====================== polynomial color functions ====================== */\n\nvec3 AlpineColorsP(float t) {\n    return clamp((((vec3(0,0,-2.66)*t+vec3(0,0,4.45))*t+vec3(.61,.5,-.91))*t+vec3(.15,.09,-.5))*t+vec3(.27,.4,.51),0.,1.);\n}\nvec3 LakeColorsP(float t) {\n    return clamp(((vec3(0,0,1.02)*t+vec3(-.21,-.93,-2.57))*t+vec3(.85,1.81,1.9))*t+vec3(.29,.02,.49),0.,1.);\n}\nvec3 ArmyColorsP(float t) {\n    return clamp(((vec3(0,1.1,0)*t+vec3(.13,-1.17,.65))*t+vec3(.18,.29,-.5))*t+vec3(.45,.58,.51),0.,1.);\n}\nvec3 MintColorsP(float t) {\n    return clamp((vec3(-.58,-.37,-.55)*t+vec3(1.04,.01,.7))*t+vec3(.46,.97,.63),0.,1.);\n}\nvec3 AtlanticColorsP(float t) {\n    return clamp((((vec3(-.97,0,0)*t+vec3(1.5,-.85,-1.25))*t+vec3(-1.4,-.25,.41))*t+vec3(1.26,1.48,1.33))*t+vec3(.1,.12,.13),0.,1.);\n}\nvec3 NeonColorsP(float t) {\n    return clamp((((vec3(0,-3.39,-3.65)*t+vec3(0,5.26,7.87))*t+vec3(-.33,-1.04,-4.42))*t+vec3(.44,-1.62,.7))*t+vec3(.69,.95,.27),0.,1.);\n}\nvec3 AuroraColorsP(float t) {\n    return clamp((((vec3(6.62,2.78,-8.72)*t+vec3(-12.68,-9.91,17.42))*t+vec3(7.58,9,-10.1))*t+vec3(-.87,-1.95,2.11))*t+vec3(.25,.31,.24),0.,1.);\n}\nvec3 PearlColorsP(float t) {\n    return clamp((((vec3(-4.27,-4.24,-6.53)*t+vec3(10.54,10.44,14.12))*t+vec3(-7.15,-7.65,-9.04))*t+vec3(.94,1.44,1.66))*t+vec3(.89,.82,.76),0.,1.);\n}\nvec3 AvocadoColorsP(float t) {\n    return clamp(((vec3(-1.86,1.04,0)*t+vec3(3.64,-2.34,.03))*t+vec3(-.83,2.33,.17))*t+vec3(.03,-.03,.01),0.,1.);\n}\nvec3 PlumColorsP(float t) {\n    return clamp(((vec3(3.19,0,-2)*t+vec3(-4.92,.8,2.23))*t+vec3(2.7,.03,.17))*t+vec3(-.03,.04,0),0.,1.);\n}\nvec3 BeachColorsP(float t) {\n    return clamp((((vec3(4.55,3.94,-4.62)*t+vec3(-6.3,-5.4,7.53))*t+vec3(1.93,1.2,-2.6))*t+vec3(.01,.8,.42))*t+vec3(.86,.5,.25),0.,1.);\n}\nvec3 RoseColorsP(float t) {\n    return clamp((((vec3(4.77,4.06,0)*t+vec3(-9.87,-8.77,0))*t+vec3(5.17,4.81,-1.2))*t+vec3(.48,-.29,1.24))*t+vec3(.16,.32,.04),0.,1.);\n}\nvec3 CandyColorsP(float t) {\n    return clamp((((vec3(2.68,0,0)*t+vec3(-3.42,-1.41,-2.02))*t+vec3(-.7,2.18,2.86))*t+vec3(1.75,-.12,-.32))*t+vec3(.38,.2,.35),0.,1.);\n}\nvec3 SolarColorsP(float t) {\n    return clamp(((vec3(.88,-1.16,0)*t+vec3(-2.29,1.87,.16))*t+vec3(1.97,.08,-.03))*t+vec3(.44,.01,.01),0.,1.);\n}\nvec3 CMYKColorsP(float t) {\n    return clamp((((vec3(-2.95,-8.11,-11.92)*t+vec3(2.91,8.04,21.96))*t+vec3(-2.1,1.3,-12.03))*t+vec3(2,-2.05,1.26))*t+vec3(.27,.82,.88),0.,1.);\n}\nvec3 SouthwestColorsP(float t) {\n    return clamp((((vec3(-1.65,5.87,16.25)*t+vec3(1.99,-14.14,-30.02))*t+vec3(-1.92,9.87,17.36))*t+vec3(1.45,-1.34,-2.91))*t+vec3(.43,.33,.27),0.,1.);\n}\nvec3 DeepSeaColorsP(float t) {\n    return clamp(((vec3(3.26,-1.4,0)*t+vec3(-3.94,2.65,-.74))*t+vec3(1.38,-.35,1.47))*t+vec3(.13,.02,.28),0.,1.);\n}\nvec3 StarryNightColorsP(float t) {\n    return clamp(((vec3(-1.92,-1.39,-.77)*t+vec3(2.68,1.18,-.3))*t+vec3(.07,.84,1.22))*t+vec3(.11,.15,.18),0.,1.);\n}\nvec3 FallColorsP(float t) {\n    return clamp((((vec3(0,-5,0)*t+vec3(-1.21,9.93,0))*t+vec3(1.97,-5.2,.44))*t+vec3(-.06,.67,-.54))*t+vec3(.29,.38,.38),0.,1.);\n}\nvec3 SunsetColorsP(float t) {\n    return clamp((((vec3(4.93,0,-14.8)*t+vec3(-8.68,-1.09,36.43))*t+vec3(2.56,1.85,-27.3))*t+vec3(2.25,.22,6.77))*t+vec3(-.02,.03,-.1),0.,1.);\n}\nvec3 FruitPunchColorsP(float t) {\n    return clamp((((vec3(0,3.2,-5.66)*t+vec3(.99,-4.45,7.54))*t+vec3(-.63,.35,-1.47))*t+vec3(-.39,.78,.09))*t+vec3(1.03,.49,-0),0.,1.);\n}\nvec3 ThermometerColorsP(float t) {\n    return clamp((((vec3(3.75,5.74,0)*t+vec3(-9.01,-10.57,1.63))*t+vec3(4.86,2.57,-3.87))*t+vec3(.78,2.25,1.61))*t+vec3(.15,.1,.77),0.,1.);\n}\nvec3 IslandColorsP(float t) {\n    return clamp((((vec3(7.05,0,0)*t+vec3(-18.07,0,1.42))*t+vec3(14.48,-1.38,-4.68))*t+vec3(-3.6,1.73,3.34))*t+vec3(.8,.4,.22),0.,1.);\n}\nvec3 WatermelonColorsP(float t) {\n    return clamp((((vec3(0,0,-4.28)*t+vec3(-1.21,-1.96,4.77))*t+vec3(1.21,.6,-1.17))*t+vec3(.78,1.6,.9))*t+vec3(.13,.11,.09),0.,1.);\n}\nvec3 BrassTonesP(float t) {\n    return clamp((((vec3(3.34,3.34,1.86)*t+vec3(-6.77,-6.91,-3.96))*t+vec3(1.16,1.73,1.2))*t+vec3(2.35,1.89,.93))*t+vec3(.09,.11,.03),0.,1.);\n}\nvec3 GreenPinkTonesP(float t) {\n    return clamp((((vec3(11.14,6.54,9.33)*t+vec3(-29.11,-6.8,-25.28))*t+vec3(21.17,-4.06,18.64))*t+vec3(-3.07,4.27,-2.6))*t+vec3(.08,.19,.11),0.,1.);\n}\nvec3 BrownCyanTonesP(float t) {\n    return clamp(((vec3(.97,-1.01,-1.33)*t+vec3(-3.47,-.32,.26))*t+vec3(2.52,1.78,1.77))*t+vec3(.3,.19,.07),0.,1.);\n}\nvec3 PigeonTonesP(float t) {\n    return clamp((((vec3(-4.68,-3.16,-3.96)*t+vec3(8.84,6.49,8.27))*t+vec3(-4.7,-3.97,-5.14))*t+vec3(1.36,1.5,1.65))*t+vec3(.17,.15,.19),0.,1.);\n}\nvec3 CherryTonesP(float t) {\n    return clamp(((vec3(2,0,0)*t+vec3(-4.02,1.15,1.12))*t+vec3(2.83,-.3,-.27))*t+vec3(.21,.19,.19),0.,1.);\n}\nvec3 RedBlueTonesP(float t) {\n    return clamp((((vec3(5.28,5.07,0)*t+vec3(-9.7,-11.42,-2.29))*t+vec3(3.1,5.87,1.99))*t+vec3(.99,.66,.6))*t+vec3(.46,.15,.21),0.,1.);\n}\nvec3 CoffeeTonesP(float t) {\n    return clamp((((vec3(0,0,-3.64)*t+vec3(0,.75,9.28))*t+vec3(-.31,-.86,-6.4))*t+vec3(.85,.79,1.53))*t+vec3(.43,.34,.24),0.,1.);\n}\nvec3 RustTonesP(float t) {\n    return clamp((((vec3(3.72,0,0)*t+vec3(-7.43,0,0))*t+vec3(3.71,-.49,.16))*t+vec3(1.02,.97,-.32))*t+vec3(.01,-.02,.2),0.,1.);\n}\nvec3 FuchsiaTonesP(float t) {\n    return clamp(((vec3(0,-1.11,0)*t+vec3(-.64,1.97,-.46))*t+vec3(1.55,-.04,1.38))*t+vec3(.07,.13,.07),0.,1.);\n}\nvec3 SiennaTonesP(float t) {\n    return clamp(((vec3(.93,-.8,-1.35)*t+vec3(-2.32,.94,2.5))*t+vec3(1.86,.56,-.44))*t+vec3(.44,.18,.09),0.,1.);\n}\nvec3 GrayTonesP(float t) {\n    return clamp((vec3(.39,.26,.11)*t+vec3(.47,.59,.68))*t+vec3(.1,.1,.11),0.,1.);\n}\nvec3 ValentineTonesP(float t) {\n    return clamp((vec3(-.07,.45,.3)*t+vec3(.56,.34,.44))*t+vec3(.51,.09,.18),0.,1.);\n}\nvec3 GrayYellowTonesP(float t) {\n    return clamp(((vec3(-1.57,-2.08,-3.17)*t+vec3(1.79,2.16,2.8))*t+vec3(.52,.42,.3))*t+vec3(.18,.22,.31),0.,1.);\n}\nvec3 DarkTerrainP(float t) {\n    return clamp((((vec3(0,2.38,4.4)*t+vec3(4.05,1.4,-3.2))*t+vec3(-5.9,-5.75,-1.04))*t+vec3(2.92,3,.48))*t+vec3(-.04,.04,.45),0.,1.);\n}\nvec3 LightTerrainP(float t) {\n    return clamp(((vec3(-1.35,-1.85,-1.86)*t+vec3(1.98,3.21,4.13))*t+vec3(-.29,-1.25,-2.23))*t+vec3(.54,.78,.86),0.,1.);\n}\nvec3 GreenBrownTerrainP(float t) {\n    return clamp((((vec3(5.66,6.03,0)*t+vec3(-9.79,-7.78,5.38))*t+vec3(4.02,.54,-7.66))*t+vec3(1.13,2.27,3.32))*t+vec3(-0,-.02,-.05),0.,1.);\n}\nvec3 SandyTerrainP(float t) {\n    return clamp((((vec3(3.48,4.39,0)*t+vec3(-7.65,-8.69,0))*t+vec3(3.48,3.53,-.49))*t+vec3(.27,.83,.43))*t+vec3(.68,.3,.2),0.,1.);\n}\nvec3 BrightBandsP(float t) {\n    return clamp((((vec3(-16.63,6.8,-8.13)*t+vec3(28.73,-14.81,26.66))*t+vec3(-12.13,8.23,-27.59))*t+vec3(-.11,.17,9.55))*t+vec3(.98,.23,-.04),0.,1.);\n}\nvec3 DarkBandsP(float t) {\n    return clamp((((vec3(17.15,-2.97,-5.17)*t+vec3(-33.07,6.52,5.24))*t+vec3(20.27,-3.03,2.06))*t+vec3(-3.87,-.41,-2.81))*t+vec3(.68,.81,1),0.,1.);\n}\nvec3 AquamarineP(float t) {\n    return clamp(((vec3(2.66,1.62,1.39)*t+vec3(-3.77,-2.42,-1.78))*t+vec3(1.1,.82,.41))*t+vec3(.67,.73,.84),0.,1.);\n}\nvec3 PastelP(float t) {\n    return clamp((((vec3(0,0,-6.39)*t+vec3(-1.54,-1.64,11.82))*t+vec3(.75,1.3,-4.98))*t+vec3(.41,.52,-.49))*t+vec3(.77,.5,.98),0.,1.);\n}\nvec3 BlueGreenYellowP(float t) {\n    return clamp((vec3(1.4,-.82,-.63)*t+vec3(-.63,1.69,.52))*t+vec3(.15,.01,.42),0.,1.);\n}\nvec3 RainbowP(float t) {\n    return clamp((((vec3(0,1.63,-8.06)*t+vec3(-4.42,-4.94,20.35))*t+vec3(7.09,1.89,-17.07))*t+vec3(-2.3,1.49,4.45))*t+vec3(.46,.04,.45),0.,1.);\n}\nvec3 DarkRainbowP(float t) {\n    return clamp((((vec3(2.62,6.12,-2.34)*t+vec3(-9.73,-15.58,2.43))*t+vec3(9.43,10.93,1.04))*t+vec3(-2.02,-1.77,-1.62))*t+vec3(.33,.41,.65),0.,1.);\n}\nvec3 TemperatureMapP(float t) {\n    return clamp((((vec3(5.84,0,11.29)*t+vec3(-11.36,-2.4,-19.02))*t+vec3(4.9,.36,7.83))*t+vec3(1.31,1.84,-.76))*t+vec3(.16,.28,.95),0.,1.);\n}\nvec3 LightTemperatureMapP(float t) {\n    return clamp((((vec3(4.11,0,5.78)*t+vec3(-8.72,0,-10.5))*t+vec3(4.23,-2.77,4.36))*t+vec3(1.04,2.85,-.37))*t+vec3(.18,.27,.95),0.,1.);\n}\n\n\n/* ====================== trigonometric series color functions ====================== */\n\nvec3 AlpineColorsT(float x) {\n    return clamp(vec3(.39,.2,.73)+vec3(.51,.98,-.01)*x+vec3(.18,.2,.35)*cos(3.14*x+vec3(2.18,.66,2.16)),0.,1.);\n}\nvec3 LakeColorsT(float x) {\n    return clamp(vec3(.25,.14,.27)+vec3(.74,.68,.8)*x+vec3(.06,.24,.34)*cos(3.14*x+vec3(-.92,-1.93,-.83)),0.,1.);\n}\nvec3 ArmyColorsT(float x) {\n    return clamp(vec3(.37,.33,.41)+vec3(.46,.71,.32)*x+vec3(.07,.27,.17)*cos(3.14*x+vec3(.44,.44,1.14)),0.,1.);\n}\nvec3 MintColorsT(float x) {\n    return clamp(vec3(.47,.99,.64)+vec3(.44,-.38,.14)*x+vec3(.14,.09,.13)*cos(3.14*x+vec3(-1.64,-1.67,-1.61)),0.,1.);\n}\nvec3 AtlanticColorsT(float x) {\n    return clamp(vec3(1.61,.32,.41)+vec3(-2.72,.01,-.05)*x+vec3(1.55,.42,.45)*cos(3.14*x+vec3(-2.94,-2.03,-2.23))+vec3(.28,0,0)*cos(6.28*x+vec3(-1.39,0,0)),0.,1.);\n}\nvec3 NeonColorsT(float x) {\n    return clamp(vec3(.83,-.12,.53)+vec3(-.15,1.19,-.19)*x+vec3(.14,.95,.34)*cos(3.14*x+vec3(-2.51,.08,2.89))+vec3(0,.26,.12)*cos(6.28*x+vec3(0,1.26,-.8)),0.,1.);\n}\nvec3 AuroraColorsT(float x) {\n    return clamp(vec3(1.18,1.25,.02)+vec3(-.83,-2.02,.71)*x+vec3(.83,1.01,.26)*cos(3.14*x+vec3(2.62,-2.87,-1.55))+vec3(.26,0,.24)*cos(6.28*x+vec3(-2.45,0,.01)),0.,1.);\n}\nvec3 PearlColorsT(float x) {\n    return clamp(vec3(.5,.16,.07)+vec3(.94,1.11,1.27)*x+vec3(.55,.56,.54)*cos(3.14*x+vec3(.64,-.11,-.29))+vec3(0,.11,.18)*cos(6.28*x+vec3(0,.22,.31)),0.,1.);\n}\nvec3 AvocadoColorsT(float x) {\n    return clamp(vec3(.43,-.25,-.11)+vec3(.14,1.48,.44)*x+vec3(.46,.3,.1)*cos(3.14*x+vec3(2.68,-.69,.06)),0.,1.);\n}\nvec3 PlumColorsT(float x) {\n    return clamp(vec3(-.73,-.19,.45)+vec3(2.37,1.27,-.47)*x+vec3(.71,.26,.48)*cos(3.14*x+vec3(-.05,.83,-2.75)),0.,1.);\n}\nvec3 BeachColorsT(float x) {\n    return clamp(vec3(.33,.03,.54)+vec3(1.52,1.69,-.06)*x+vec3(.78,.62,.41)*cos(3.14*x+vec3(.53,.36,-2.94))+vec3(.15,.12,.12)*cos(6.28*x+vec3(3.08,3.09,-.02)),0.,1.);\n}\nvec3 RoseColorsT(float x) {\n    return clamp(vec3(.3,.43,.11)+vec3(.49,-.48,-.07)*x+vec3(.12,.37,.3)*cos(3.14*x+vec3(-1.85,-1.98,-1.72))+vec3(.11,0,0)*cos(6.28*x+vec3(3.07,0,0)),0.,1.);\n}\nvec3 CandyColorsT(float x) {\n    return clamp(vec3(-.07,.51,.8)+vec3(1.17,.04,-.38)*x+vec3(.53,.31,.45)*cos(3.14*x+vec3(-.61,3.09,-3.05)),0.,1.);\n}\nvec3 SolarColorsT(float x) {\n    return clamp(vec3(.26,.27,.06)+vec3(.95,.29,.02)*x+vec3(.31,.26,.06)*cos(3.14*x+vec3(-.87,3.01,2.45)),0.,1.);\n}\nvec3 CMYKColorsT(float x) {\n    return clamp(vec3(1.55,-1.73,1.39)+vec3(-3.03,3.26,-2.95)*x+vec3(1.77,2.22,1.53)*cos(3.14*x+vec3(-2.51,-.53,-2.35))+vec3(.22,.85,.55)*cos(6.28*x+vec3(-.72,1.03,-.21))+vec3(0,.05,.06)*cos(12.57*x+vec3(0,.11,.46)),0.,1.);\n}\nvec3 SouthwestColorsT(float x) {\n    return clamp(vec3(-1.09,.99,-.13)+vec3(2.73,-.78,2.44)*x+vec3(1.51,.53,1.46)*cos(3.14*x+vec3(-.43,3.12,.93))+vec3(.34,.14,.51)*cos(6.28*x+vec3(1.29,3.14,3.02)),0.,1.);\n}\nvec3 DeepSeaColorsT(float x) {\n    return clamp(vec3(-.6,.32,.35)+vec3(2.14,.28,.6)*x+vec3(.76,.34,.19)*cos(3.14*x+vec3(.31,2.74,-1.85)),0.,1.);\n}\nvec3 StarryNightColorsT(float x) {\n    return clamp(vec3(.54,.47,.37)+vec3(-.01,.02,-.19)*x+vec3(.43,.38,.39)*cos(3.14*x+vec3(-3.04,-2.53,-2.02)),0.,1.);\n}\nvec3 FallColorsT(float x) {\n    return clamp(vec3(.56,.27,.48)+vec3(.16,.39,-.31)*x+vec3(.27,.01,.14)*cos(3.14*x+vec3(3,2.95,2.25))+vec3(0,.12,0)*cos(6.28*x+vec3(0,.01,0)),0.,1.);\n}\nvec3 SunsetColorsT(float x) {\n    return clamp(vec3(1,.27,.14)+vec3(-.81,.5,-.07)*x+vec3(.94,.25,.67)*cos(3.14*x+vec3(-2.85,2.92,-2.58))+vec3(.25,0,.58)*cos(6.28*x+vec3(-1.98,0,-.86))+vec3(0,0,.06)*cos(12.57*x+vec3(0,0,-1.68)),0.,1.);\n}\nvec3 FruitPunchColorsT(float x) {\n    return clamp(vec3(.81,.03,.74)+vec3(.4,.75,-1.31)*x+vec3(.3,.48,.97)*cos(3.14*x+vec3(.76,-.44,-2.78))+vec3(0,0,.17)*cos(6.28*x+vec3(0,0,-.08)),0.,1.);\n}\nvec3 ThermometerColorsT(float x) {\n    return clamp(vec3(.45,-.14,.43)+vec3(-.28,.38,.1)*x+vec3(.63,.86,.5)*cos(3.14*x+vec3(-2.12,-1.34,-.76)),0.,1.);\n}\nvec3 IslandColorsT(float x) {\n    return clamp(vec3(2.03,.25,-1.17)+vec3(-2.23,.69,2.65)*x+vec3(1.09,.36,1.51)*cos(3.14*x+vec3(2.86,-1.17,-.58))+vec3(.2,0,.21)*cos(6.28*x+vec3(-2.98,0,1.09)),0.,1.);\n}\nvec3 WatermelonColorsT(float x) {\n    return clamp(vec3(.25,.42,.81)+vec3(.26,-.66,-1.54)*x+vec3(.47,.96,1.13)*cos(3.14*x+vec3(-2.17,-2.07,-2.47))+vec3(.11,.12,.17)*cos(6.28*x+vec3(.01,-.03,-.05)),0.,1.);\n}\nvec3 BrassTonesT(float x) {\n    return clamp(vec3(-1.03,-.89,.07)+vec3(2.84,2.55,-.07)*x+vec3(1.45,1.3,.38)*cos(3.14*x+vec3(-.26,-.24,-1.7))+vec3(.36,.34,0)*cos(6.28*x+vec3(2.08,2.1,0))+vec3(.08,.07,0)*cos(12.57*x+vec3(2.19,2.17,0)),0.,1.);\n}\nvec3 GreenPinkTonesT(float x) {\n    return clamp(vec3(-3.25,3.08,-3.34)+vec3(6.9,-6.12,6.89)*x+vec3(3.37,3.09,3.41)*cos(3.14*x+vec3(-.17,-2.85,-.22))+vec3(1.01,.89,.99)*cos(6.28*x+vec3(1.7,-1.51,1.61))+vec3(.11,.08,.1)*cos(12.57*x+vec3(1.25,-.96,1.12)),0.,1.);\n}\nvec3 BrownCyanTonesT(float x) {\n    return clamp(vec3(.11,.44,.38)+vec3(.45,.01,.11)*x+vec3(.53,.5,.51)*cos(3.14*x+vec3(-1.15,-2.04,-2.18)),0.,1.);\n}\nvec3 PigeonTonesT(float x) {\n    return clamp(vec3(.72,.15,.66)+vec3(-.52,.94,-.32)*x+vec3(.67,.1,.56)*cos(3.14*x+vec3(-2.92,1.13,-2.92))+vec3(.17,0,.16)*cos(6.28*x+vec3(-.69,0,-.85)),0.,1.);\n}\nvec3 CherryTonesT(float x) {\n    return clamp(vec3(-.22,.34,.36)+vec3(1.7,.51,.47)*x+vec3(.51,.31,.31)*cos(3.14*x+vec3(-.5,2.03,2.1)),0.,1.);\n}\nvec3 RedBlueTonesT(float x) {\n    return clamp(vec3(-.19,1.25,.74)+vec3(1.15,-1.86,-.7)*x+vec3(.81,1.09,.62)*cos(3.14*x+vec3(-.46,-2.73,-2.54))+vec3(.14,.16,0)*cos(6.28*x+vec3(2.33,-2.13,0)),0.,1.);\n}\nvec3 CoffeeTonesT(float x) {\n    return clamp(vec3(.31,.17,-.16)+vec3(.8,1.03,1.66)*x+vec3(.13,.18,.55)*cos(3.14*x+vec3(-.61,.39,.61)),0.,1.);\n}\nvec3 RustTonesT(float x) {\n    return clamp(vec3(.12,-.01,.19)+vec3(.96,.47,-.15)*x+vec3(.06,.12,.04)*cos(3.14*x+vec3(-1.97,-1.59,1.54))+vec3(.09,0,0)*cos(6.28*x+vec3(-3.09,0,0)),0.,1.);\n}\nvec3 FuchsiaTonesT(float x) {\n    return clamp(vec3(.21,.38,.23)+vec3(.66,.33,.63)*x+vec3(.19,.26,.16)*cos(3.14*x+vec3(-2.17,2.84,-2.4)),0.,1.);\n}\nvec3 SiennaTonesT(float x) {\n    return clamp(vec3(.24,.36,.38)+vec3(.89,.34,.12)*x+vec3(.3,.19,.32)*cos(3.14*x+vec3(-.82,-2.8,2.77)),0.,1.);\n}\nvec3 GrayTonesT(float x) {\n    return clamp(vec3(.2,.16,.11)+vec3(.65,.74,.79)*x+vec3(.13,.08,.03)*cos(3.14*x+vec3(2.31,2.16,1.59)),0.,1.);\n}\nvec3 ValentineTonesT(float x) {\n    return clamp(vec3(.63,.28,.38)+vec3(.23,.41,.34)*x+vec3(.11,.19,.18)*cos(3.14*x+vec3(-2.98,2.54,2.73)),0.,1.);\n}\nvec3 GrayYellowTonesT(float x) {\n    return clamp(vec3(.53,.69,1.04)+vec3(.05,-.41,-1.48)*x+vec3(.38,.52,.85)*cos(3.14*x+vec3(-2.77,-2.68,-2.55)),0.,1.);\n}\nvec3 DarkTerrainT(float x) {\n    return clamp(vec3(-.93,-.95,-.09)+vec3(2.85,3.2,2.08)*x+vec3(.9,1.14,1.11)*cos(3.14*x+vec3(.04,.27,.83))+vec3(0,.1,.21)*cos(6.28*x+vec3(0,-2.62,-2.66)),0.,1.);\n}\nvec3 LightTerrainT(float x) {\n    return clamp(vec3(.84,1.18,1.26)+vec3(-.25,-.71,-.79)*x+vec3(.3,.42,.52)*cos(3.14*x+vec3(-3.1,2.89,2.48)),0.,1.);\n}\nvec3 GreenBrownTerrainT(float x) {\n    return clamp(vec3(-.46,-.72,-1.24)+vec3(2.2,2.76,3.41)*x+vec3(.59,.88,1.2)*cos(3.14*x+vec3(.15,.19,.08))+vec3(.15,.16,0)*cos(6.28*x+vec3(2.83,-3.03,0)),0.,1.);\n}\nvec3 SandyTerrainT(float x) {\n    return clamp(vec3(-.27,.24,.14)+vec3(1.57,.1,.09)*x+vec3(1.03,.48,.13)*cos(3.14*x+vec3(-.38,-1.53,-1.11))+vec3(.22,0,0)*cos(6.28*x+vec3(1.79,0,0)),0.,1.);\n}\nvec3 BrightBandsT(float x) {\n    return clamp(vec3(-10.69,-13.44,-14.93)+vec3(23.11,28.36,31.5)*x+vec3(11.44,13.75,15.46)*cos(3.14*x+vec3(.02,0,.02))+vec3(2.54,2.84,2.76)*cos(6.28*x+vec3(1.49,1.66,1.68))+vec3(.2,.19,.36)*cos(12.57*x+vec3(1.91,1.75,2.05)),0.,1.);\n}\nvec3 DarkBandsT(float x) {\n    return clamp(vec3(19.05,22.62,-12.71)+vec3(-36.56,-43.6,26.79)*x+vec3(18.26,21.63,13.6)*cos(3.14*x+vec3(3.13,3.13,.01))+vec3(3.78,4.47,3.04)*cos(6.28*x+vec3(-1.6,-1.56,1.56))+vec3(.32,.41,.31)*cos(12.57*x+vec3(-1.2,-1.57,1.66)),0.,1.);\n}\nvec3 AquamarineT(float x) {\n    return clamp(vec3(.08,.37,.54)+vec3(1.16,.74,.63)*x+vec3(.59,.36,.32)*cos(3.14*x+vec3(.09,.01,.23)),0.,1.);\n}\nvec3 PastelT(float x) {\n    return clamp(vec3(1.13,.89,-1.28)+vec3(-1.06,-.57,3.61)*x+vec3(.51,.47,1.84)*cos(3.14*x+vec3(-2.31,-2.49,-.2))+vec3(0,0,.54)*cos(6.28*x+vec3(0,0,.87))+vec3(0,0,.07)*cos(12.57*x+vec3(0,0,.6)),0.,1.);\n}\nvec3 BlueGreenYellowT(float x) {\n    return clamp(vec3(.01,-.09,.22)+vec3(1,1.09,.31)*x+vec3(.35,.22,.23)*cos(3.14*x+vec3(1.29,-1.14,-.72)),0.,1.);\n}\nvec3 RainbowT(float x) {\n    return clamp(vec3(1.42,1.64,-.15)+vec3(-1.57,-3.2,.38)*x+vec3(.99,1.76,.77)*cos(3.14*x+vec3(3.03,-2.71,-1.05))+vec3(0,.24,.28)*cos(6.28*x+vec3(0,-1.44,-.39)),0.,1.);\n}\nvec3 DarkRainbowT(float x) {\n    return clamp(vec3(-2.48,-1.09,-1.47)+vec3(6.03,3.61,3.66)*x+vec3(2.74,1.88,2)*cos(3.14*x+vec3(-.01,.18,.02))+vec3(.73,.6,.49)*cos(6.28*x+vec3(1.65,2.19,1.47))+vec3(0,.06,0)*cos(12.57*x+vec3(0,-2.77,0)),0.,1.);\n}\nvec3 TemperatureMapT(float x) {\n    return clamp(vec3(1.23,.85,2.05)+vec3(-1.23,-1.25,-3.22)*x+vec3(.96,.95,1.27)*cos(3.14*x+vec3(-2.87,-2.17,-2.84))+vec3(.23,0,.39)*cos(6.28*x+vec3(-2.13,0,-1.56))+vec3(0,0,.09)*cos(12.57*x+vec3(0,0,-.03)),0.,1.);\n}\nvec3 LightTemperatureMapT(float x) {\n    return clamp(vec3(-.33,.27,1.48)+vec3(1.85,.15,-1.54)*x+vec3(.62,.67,.39)*cos(3.14*x+vec3(-.42,-1.52,-3.01))+vec3(.15,0,.18)*cos(6.28*x+vec3(2.12,0,-2.43)),0.,1.);\n}\n\n\n/* ====================== cosine color plaettes ====================== */\n\nvec3 AlpineColorsC(float t) {\n    return clamp(vec3(.34,.26,.43)+vec3(.56,.75,.3)*t+vec3(.15,.09,.17)*cos(vec3(3.47,4.56,4.86)*t+vec3(1.97,.16,1.11)),0.,1.);\n}\nvec3 LakeColorsC(float t) {\n    return clamp(vec3(.25,.13,.34)+vec3(.73,.67,.73)*t+vec3(.06,.25,.3)*cos(vec3(3.28,3.07,3.36)*t+vec3(-1,-1.9,-.98)),0.,1.);\n}\nvec3 ArmyColorsC(float t) {\n    return clamp(vec3(.43,.43,.89)+vec3(.3,.43,2.69)*t+vec3(.02,.14,3.54)*cos(vec3(12.93,4.13,.85)*t+vec3(.41,.06,1.68)),0.,1.);\n}\nvec3 MintColorsC(float t) {\n    return clamp(vec3(-.97,.7,.07)+vec3(.09,-.49,.08)*t+vec3(1.81,.45,.74)*cos(vec3(.82,1.32,1.24)*t+vec3(-.67,-.9,-.7)),0.,1.);\n}\nvec3 AtlanticColorsC(float t) {\n    return clamp(vec3(-.36,.31,.46)+vec3(-4.38,-.07,-.51)*t+vec3(7.37,.48,.75)*cos(vec3(.73,2.92,2.48)*t+vec3(-1.51,-1.96,-2.03)),0.,1.);\n}\nvec3 NeonColorsC(float t) {\n    return clamp(vec3(.77,.83,.14)+vec3(.07,-.79,.51)*t+vec3(.04,.14,.13)*cos(vec3(5.93,5.94,5.69)*t+vec3(2.73,.76,.06)),0.,1.);\n}\nvec3 AuroraColorsC(float t) {\n    return clamp(vec3(.21,.51,.17)+vec3(.59,-.23,.7)*t+vec3(.05,.28,.12)*cos(vec3(10.52,5.46,7.58)*t+vec3(1.43,2.47,-.64)),0.,1.);\n}\nvec3 PearlColorsC(float t) {\n    return clamp(vec3(.72,.78,.71)+vec3(.13,-.07,.15)*t+vec3(.2,.11,.11)*cos(vec3(5.4,6.57,7.19)*t+vec3(-.18,-.89,-.77)),0.,1.);\n}\nvec3 AvocadoColorsC(float t) {\n    return clamp(vec3(.65,-.68,-.01)+vec3(-.2,2.05,.25)*t+vec3(.65,.66,.02)*cos(vec3(2.76,2.28,5.9)*t+vec3(2.92,-.1,-1.25)),0.,1.);\n}\nvec3 PlumColorsC(float t) {\n    return clamp(vec3(-1.02,-2.84,2.04)+vec3(2.94,17.04,-4.71)*t+vec3(1.01,30.48,3.86)*cos(vec3(2.77,.544,1.48)*t+vec3(.15,1.478,-2.12)),0.,1.);\n}\nvec3 BeachColorsC(float t) {\n    return clamp(vec3(-40.16,.56,.15)+vec3(87.82,.36,.8)*t+vec3(202.13,.08,.1)*cos(vec3(.4371,7.61,6.82)*t+vec3(1.3668,-2.56,.38)),0.,1.);\n}\nvec3 RoseColorsC(float t) {\n    return clamp(vec3(.32,.48,.22)+vec3(.54,-.21,0)*t+vec3(.17,.17,.16)*cos(vec3(5.63,5.38,4.87)*t+vec3(-2.92,-2.92,-2.52)),0.,1.);\n}\nvec3 CandyColorsC(float t) {\n    return clamp(vec3(.43,19.47,.48)+vec3(.47,-36.59,.3)*t+vec3(.21,79.3,.17)*cos(vec3(4.93,.474,4.66)*t+vec3(-1.75,-1.816,2.53)),0.,1.);\n}\nvec3 SolarColorsC(float t) {\n    return clamp(vec3(-.33,.03,.17)+vec3(1.62,.73,-.13)*t+vec3(.78,.08,.16)*cos(vec3(2.09,5.13,2.13)*t+vec3(-.13,1.92,3.14)),0.,1.);\n}\nvec3 CMYKColorsC(float t) {\n    return clamp(vec3(21.34,.96,.86)+vec3(-109.66,-.7,-.54)*t+vec3(274.8,.36,.1)*cos(vec3(.4044,6.26,9.08)*t+vec3(-1.6474,1.69,-1.02)),0.,1.);\n}\nvec3 SouthwestColorsC(float t) {\n    return clamp(vec3(2.15,.44,.17)+vec3(-26.75,.3,.38)*t+vec3(51.14,.17,.12)*cos(vec3(.542,6.24,11.28)*t+vec3(-1.604,2.53,1.02)),0.,1.);\n}\nvec3 DeepSeaColorsC(float t) {\n    return clamp(vec3(-.45,.39,.22)+vec3(1.77,.17,.37)*t+vec3(.59,.4,.47)*cos(vec3(3.48,2.95,1.93)*t+vec3(.17,2.86,-1.41)),0.,1.);\n}\nvec3 StarryNightColorsC(float t) {\n    return clamp(vec3(.19,.49,.39)+vec3(.74,-.07,-.02)*t+vec3(.12,.43,.27)*cos(vec3(5.25,2.99,3.94)*t+vec3(2.27,-2.48,-2.33)),0.,1.);\n}\nvec3 FallColorsC(float t) {\n    return clamp(vec3(.21,.26,6.5)+vec3(.81,.4,-7.17)*t+vec3(.04,.12,12.76)*cos(vec3(8.62,6.28,.571)*t+vec3(-.26,.02,-2.069)),0.,1.);\n}\nvec3 SunsetColorsC(float t) {\n    return clamp(vec3(.14,-.05,-.07)+vec3(1.15,1.07,.73)*t+vec3(.27,.04,.32)*cos(vec3(5.06,7.88,7.07)*t+vec3(-2.21,.1,-1.2)),0.,1.);\n}\nvec3 FruitPunchColorsC(float t) {\n    return clamp(vec3(.89,.57,-.04)+vec3(-.02,-.09,.68)*t+vec3(.11,.14,.14)*cos(vec3(5.77,5.77,6.99)*t+vec3(-.21,-2.09,1.02)),0.,1.);\n}\nvec3 ThermometerColorsC(float t) {\n    return clamp(vec3(.45,.28,.46)+vec3(.12,.14,.05)*t+vec3(.39,.55,.48)*cos(vec3(4.18,4.18,3.22)*t+vec3(-2.51,-1.92,-.81)),0.,1.);\n}\nvec3 IslandColorsC(float t) {\n    return clamp(vec3(.67,-8.59,-35.37)+vec3(.12,8,32.87)*t+vec3(.14,12.2,68.16)*cos(vec3(7.54,.712,.508)*t+vec3(1.45,.746,1.022)),0.,1.);\n}\nvec3 WatermelonColorsC(float t) {\n    return clamp(vec3(8.38,6.22,80.01)+vec3(-23.7,-56.24,-209.12)*t+vec3(45.9,127.22,639.31)*cos(vec3(.542,.4551,.3292)*t+vec3(-1.752,-1.6188,-1.696)),0.,1.);\n}\nvec3 BrassTonesC(float t) {\n    return clamp(vec3(.16,.24,.12)+vec3(.07,0,-.04)*t+vec3(.73,.6,.31)*cos(vec3(3.31,3.49,3.55)*t+vec3(-1.67,-1.8,-1.89)),0.,1.);\n}\nvec3 GreenPinkTonesC(float t) {\n    return clamp(vec3(.53,.21,.6)+vec3(-.05,.51,-.21)*t+vec3(.55,.62,.57)*cos(vec3(5.5,4.82,5.27)*t+vec3(2.78,-1.55,2.86)),0.,1.);\n}\nvec3 BrownCyanTonesC(float t) {\n    return clamp(vec3(.2,-1.14,.59)+vec3(.37,-14.82,-3.1)*t+vec3(.47,26.53,3.44)*cos(vec3(3.37,.626,1.41)*t+vec3(-1.29,-1.521,-1.72)),0.,1.);\n}\nvec3 PigeonTonesC(float t) {\n    return clamp(vec3(.12,.13,.17)+vec3(.86,.84,.79)*t+vec3(.06,.04,.06)*cos(vec3(7.66,7.9,7.72)*t+vec3(-.48,-.99,-.96)),0.,1.);\n}\nvec3 CherryTonesC(float t) {\n    return clamp(vec3(-33.95,11.9,13.78)+vec3(52.15,-9.82,-12.63)*t+vec3(107.83,19.47,25.21)*cos(vec3(.4822,.588,.562)*t+vec3(1.2484,-2.214,-2.139)),0.,1.);\n}\nvec3 RedBlueTonesC(float t) {\n    return clamp(vec3(.65,.46,.91)+vec3(-.25,.01,-1.3)*t+vec3(.33,.39,.96)*cos(vec3(4.74,4.49,2.62)*t+vec3(-2.17,-2.54,-2.37)),0.,1.);\n}\nvec3 CoffeeTonesC(float t) {\n    return clamp(vec3(-2.68,.32,.06)+vec3(4.95,.64,.86)*t+vec3(5.69,.04,.2)*cos(vec3(.8,7.86,5.28)*t+vec3(1,-1.39,-.16)),0.,1.);\n}\nvec3 RustTonesC(float t) {\n    return clamp(vec3(.12,.06,.17)+vec3(1.02,.47,-.16)*t+vec3(.12,.06,.02)*cos(vec3(5.86,5.84,5.85)*t+vec3(-2.93,-2.93,.2)),0.,1.);\n}\nvec3 FuchsiaTonesC(float t) {\n    return clamp(vec3(.39,.03,1.44)+vec3(-3.14,.91,-4.92)*t+vec3(5.33,.05,8.11)*cos(vec3(.83,7.86,.75)*t+vec3(-1.63,-.06,-1.74)),0.,1.);\n}\nvec3 SiennaTonesC(float t) {\n    return clamp(vec3(-.41,.33,.4)+vec3(1.68,.42,.09)*t+vec3(.86,.15,.34)*cos(vec3(2.03,3.42,3.09)*t+vec3(-.04,-2.91,2.8)),0.,1.);\n}\nvec3 GrayTonesC(float t) {\n    return clamp(vec3(.04,.06,.09)+vec3(.84,.84,.79)*t+vec3(.04,.03,.02)*cos(vec3(7.06,7.43,9)*t+vec3(-.08,-.36,-1.35)),0.,1.);\n}\nvec3 ValentineTonesC(float t) {\n    return clamp(vec3(2.39,.14,.17)+vec3(-3.68,.6,.66)*t+vec3(5.19,.1,.05)*cos(vec3(.82,4.26,5.68)*t+vec3(-1.94,1.82,1.15)),0.,1.);\n}\nvec3 GrayYellowTonesC(float t) {\n    return clamp(vec3(.6,22,40.32)+vec3(-.13,-61.93,-135.25)*t+vec3(.47,141.55,364.05)*cos(vec3(2.89,.4457,.3746)*t+vec3(-2.67,-1.7253,-1.6809)),0.,1.);\n}\nvec3 DarkTerrainC(float t) {\n    return clamp(vec3(-119.59,-5.32,-180.09)+vec3(246.86,12.06,452.81)*t+vec3(786.34,7.19,1665.28)*cos(vec3(.3139,1.75,.27247)*t+vec3(1.4182,.74,1.4622)),0.,1.);\n}\nvec3 LightTerrainC(float t) {\n    return clamp(vec3(.59,27.29,39.02)+vec3(.26,-45.82,-51.94)*t+vec3(.09,94.81,114.12)*cos(vec3(5.12,.49,.4623)*t+vec3(2.23,-1.854,-1.9117)),0.,1.);\n}\nvec3 GreenBrownTerrainC(float t) {\n    return clamp(vec3(.12,.12,-205.56)+vec3(.95,.88,434.26)*t+vec3(.12,.18,1593.1)*cos(vec3(6.76,6.8,.27279)*t+vec3(-2.89,-2.34,1.44143)),0.,1.);\n}\nvec3 SandyTerrainC(float t) {\n    return clamp(vec3(.9,.48,.26)+vec3(-.54,.07,-.03)*t+vec3(.32,.27,.06)*cos(vec3(4.28,4.7,5.68)*t+vec3(-2.37,-2.32,-2.62)),0.,1.);\n}\nvec3 BrightBandsC(float t) {\n    return clamp(vec3(.63,.52,-577.52)+vec3(.13,.31,1052.6)*t+vec3(.31,.29,4334.34)*cos(vec3(7.39,5.46,.24336)*t+vec3(-.03,-3.02,1.43714)),0.,1.);\n}\nvec3 DarkBandsC(float t) {\n    return clamp(vec3(.52,.62,1.08)+vec3(.31,.21,-.98)*t+vec3(.15,.26,.35)*cos(vec3(11.59,4.3,5.11)*t+vec3(.78,.76,1.76)),0.,1.);\n}\nvec3 AquamarineC(float t) {\n    return clamp(vec3(-.3,.26,-.2)+vec3(1.96,.95,2.36)*t+vec3(1.04,.47,1.51)*cos(vec3(2.57,2.85,1.8)*t+vec3(.36,.15,.8)),0.,1.);\n}\nvec3 PastelC(float t) {\n    return clamp(vec3(5.99,1.69,.81)+vec3(-30.91,-3.63,-.07)*t+vec3(57.32,2.89,.22)*cos(vec3(.549,1.56,5.58)*t+vec3(-1.662,-1.99,.59)),0.,1.);\n}\nvec3 BlueGreenYellowC(float t) {\n    return clamp(vec3(2.08,-.47,-1.06)+vec3(4.68,1.41,1.97)*t+vec3(6.45,.5,1.61)*cos(vec3(.82,2.07,1.48)*t+vec3(1.88,-.42,.45)),0.,1.);\n}\nvec3 RainbowC(float t) {\n    return clamp(vec3(132.23,.39,-142.83)+vec3(-245.97,-1.4,270.69)*t+vec3(755.63,1.32,891.31)*cos(vec3(.3275,2.39,.3053)*t+vec3(-1.7461,-1.84,1.4092)),0.,1.);\n}\nvec3 DarkRainbowC(float t) {\n    return clamp(vec3(.25,.65,.52)+vec3(.64,-.34,-.4)*t+vec3(.16,.28,.11)*cos(vec3(7.89,5.83,6.93)*t+vec3(1.19,2.69,.6)),0.,1.);\n}\nvec3 TemperatureMapC(float t) {\n    return clamp(vec3(.37,.89,1.18)+vec3(.71,-2.12,-.94)*t+vec3(.26,1.56,.2)*cos(vec3(5.2,2.48,8.03)*t+vec3(-2.51,-1.96,2.87)),0.,1.);\n}\nvec3 LightTemperatureMapC(float t) {\n    return clamp(vec3(.38,-5.49,1.11)+vec3(.62,.96,-.73)*t+vec3(.24,6.09,.17)*cos(vec3(4.9,.97,6.07)*t+vec3(-2.61,-.33,-2.74)),0.,1.);\n}\n\n\n/* ====================== main ====================== */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (vec2(0,1)-(fragCoord/iResolution.xy))*vec2(-4, 13);\n    int i = int(uv.x)*13+int(uv.y);\n    float t = fract(uv.x);\n    vec3 col = vec3(0);\n    // align them so one can Alt+select to change the suffix\n    if (i== 0) col=        AlpineColorsP(t);\n    if (i== 1) col=          LakeColorsP(t);\n    if (i== 2) col=          ArmyColorsP(t);\n    if (i== 3) col=          MintColorsP(t);\n    if (i== 4) col=      AtlanticColorsP(t);\n    if (i== 5) col=          NeonColorsP(t);\n    if (i== 6) col=        AuroraColorsP(t);\n    if (i== 7) col=         PearlColorsP(t);\n    if (i== 8) col=       AvocadoColorsP(t);\n    if (i== 9) col=          PlumColorsP(t);\n    if (i==10) col=         BeachColorsP(t);\n    if (i==11) col=          RoseColorsP(t);\n    if (i==12) col=         CandyColorsP(t);\n    if (i==13) col=         SolarColorsP(t);\n    if (i==14) col=          CMYKColorsP(t);\n    if (i==15) col=     SouthwestColorsP(t);\n    if (i==16) col=       DeepSeaColorsP(t);\n    if (i==17) col=   StarryNightColorsP(t);\n    if (i==18) col=          FallColorsP(t);\n    if (i==19) col=        SunsetColorsP(t);\n    if (i==20) col=    FruitPunchColorsP(t);\n    if (i==21) col=   ThermometerColorsP(t);\n    if (i==22) col=        IslandColorsP(t);\n    if (i==23) col=    WatermelonColorsP(t);\n    if (i==24) col=          BrassTonesP(t);\n    if (i==25) col=      GreenPinkTonesP(t);\n    if (i==26) col=      BrownCyanTonesP(t);\n    if (i==27) col=         PigeonTonesP(t);\n    if (i==28) col=         CherryTonesP(t);\n    if (i==29) col=        RedBlueTonesP(t);\n    if (i==30) col=         CoffeeTonesP(t);\n    if (i==31) col=           RustTonesP(t);\n    if (i==32) col=        FuchsiaTonesP(t);\n    if (i==33) col=         SiennaTonesP(t);\n    if (i==34) col=           GrayTonesP(t);\n    if (i==35) col=      ValentineTonesP(t);\n    if (i==36) col=     GrayYellowTonesP(t);\n    if (i==37) col=         DarkTerrainP(t);\n    if (i==38) col=        LightTerrainP(t);\n    if (i==39) col=   GreenBrownTerrainP(t);\n    if (i==40) col=        SandyTerrainP(t);\n    if (i==41) col=         BrightBandsP(t);\n    if (i==42) col=           DarkBandsP(t);\n    if (i==43) col=          AquamarineP(t);\n    if (i==44) col=              PastelP(t);\n    if (i==45) col=     BlueGreenYellowP(t);\n    if (i==46) col=             RainbowP(t);\n    if (i==47) col=         DarkRainbowP(t);\n    if (i==48) col=      TemperatureMapP(t);\n    if (i==49) col= LightTemperatureMapP(t);\n    fragColor = vec4(col, 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSSRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1030, 1030, 1059, 1059, 1184], [1185, 1185, 1212, 1212, 1323], [1324, 1324, 1351, 1351, 1458], [1459, 1459, 1486, 1486, 1576], [1577, 1577, 1608, 1608, 1743], [1744, 1744, 1771, 1771, 1910], [1911, 1911, 1940, 1940, 2087], [2088, 2088, 2116, 2116, 2267], [2268, 2268, 2298, 2298, 2414], [2415, 2415, 2442, 2442, 2550], [2551, 2551, 2579, 2579, 2717], [2718, 2718, 2745, 2745, 2883], [2884, 2884, 2912, 2912, 3050], [3051, 3051, 3079, 3079, 3193], [3194, 3194, 3221, 3221, 3368], [3369, 3369, 3401, 3401, 3554], [3555, 3555, 3585, 3585, 3701], [3702, 3702, 3736, 3736, 3853], [3854, 3854, 3881, 3881, 4012], [4013, 4013, 4042, 4042, 4187], [4188, 4188, 4221, 4221, 4359], [4360, 4360, 4394, 4394, 4536], [4537, 4537, 4566, 4566, 4703], [4704, 4704, 4737, 4737, 4872], [4873, 4873, 4900, 4900, 5044], [5045, 5045, 5076, 5076, 5228], [5229, 5229, 5260, 5260, 5378], [5379, 5379, 5407, 5407, 5554], [5555, 5555, 5583, 5583, 5692], [5693, 5693, 5722, 5722, 5860], [5861, 5861, 5889, 5889, 6021], [6022, 6022, 6048, 6048, 6178], [6179, 6179, 6208, 6208, 6321], [6322, 6322, 6350, 6350, 6465], [6466, 6466, 6492, 6492, 6577], [6578, 6578, 6609, 6609, 6696], [6697, 6697, 6729, 6729, 6845], [6846, 6846, 6874, 6874, 7011], [7012, 7012, 7041, 7041, 7164], [7165, 7165, 7199, 7199, 7342], [7343, 7343, 7372, 7372, 7506], [7507, 7507, 7535, 7535, 7688], [7689, 7689, 7715, 7715, 7865], [7866, 7866, 7893, 7893, 8011], [8012, 8012, 8035, 8035, 8172], [8173, 8173, 8205, 8205, 8296], [8297, 8297, 8321, 8321, 8467], [8468, 8468, 8496, 8496, 8647], [8648, 8648, 8679, 8679, 8822], [8823, 8823, 8859, 8859, 8999], [9092, 9092, 9121, 9121, 9235], [9236, 9236, 9263, 9263, 9379], [9380, 9380, 9407, 9407, 9521], [9522, 9522, 9549, 9549, 9669], [9670, 9670, 9701, 9701, 9867], [9868, 9868, 9895, 9895, 10060], [10061, 10061, 10090, 10090, 10260], [10261, 10261, 10289, 10289, 10449], [10450, 10450, 10480, 10480, 10596], [10597, 10597, 10624, 10624, 10745], [10746, 10746, 10774, 10774, 10943], [10944, 10944, 10971, 10971, 11131], [11132, 11132, 11160, 11160, 11279], [11280, 11280, 11308, 11308, 11424], [11425, 11425, 11452, 11452, 11678], [11679, 11679, 11711, 11711, 11885], [11886, 11886, 11916, 11916, 12032], [12033, 12033, 12067, 12067, 12188], [12189, 12189, 12216, 12216, 12370], [12371, 12371, 12400, 12400, 12607], [12608, 12608, 12641, 12641, 12798], [12799, 12799, 12833, 12833, 12951], [12952, 12952, 12981, 12981, 13152], [13153, 13153, 13186, 13186, 13359], [13360, 13360, 13387, 13387, 13602], [13603, 13603, 13634, 13634, 13865], [13866, 13866, 13897, 13897, 14015], [14016, 14016, 14044, 14044, 14209], [14210, 14210, 14238, 14238, 14353], [14354, 14354, 14383, 14383, 14554], [14555, 14555, 14583, 14583, 14699], [14700, 14700, 14726, 14726, 14888], [14889, 14889, 14918, 14918, 15035], [15036, 15036, 15064, 15064, 15179], [15180, 15180, 15206, 15206, 15321], [15322, 15322, 15353, 15353, 15470], [15471, 15471, 15503, 15503, 15626], [15627, 15627, 15655, 15655, 15821], [15822, 15822, 15851, 15851, 15971], [15972, 15972, 16006, 16006, 16172], [16173, 16173, 16202, 16202, 16363], [16364, 16364, 16392, 16392, 16628], [16629, 16629, 16655, 16655, 16897], [16898, 16898, 16925, 16925, 17039], [17040, 17040, 17063, 17063, 17268], [17269, 17269, 17301, 17301, 17418], [17419, 17419, 17443, 17443, 17615], [17616, 17616, 17644, 17644, 17860], [17861, 17861, 17892, 17892, 18110], [18111, 18111, 18147, 18147, 18317], [18395, 18395, 18424, 18424, 18554], [18555, 18555, 18582, 18582, 18711], [18712, 18712, 18739, 18739, 18870], [18871, 18871, 18898, 18898, 19029], [19030, 19030, 19061, 19061, 19201], [19202, 19202, 19229, 19229, 19360], [19361, 19361, 19390, 19390, 19523], [19524, 19524, 19552, 19552, 19683], [19684, 19684, 19714, 19714, 19848], [19849, 19849, 19876, 19876, 20023], [20024, 20024, 20052, 20052, 20193], [20194, 20194, 20221, 20221, 20355], [20356, 20356, 20384, 20384, 20524], [20525, 20525, 20553, 20553, 20688], [20689, 20689, 20716, 20716, 20861], [20862, 20862, 20894, 20894, 21034], [21035, 21035, 21065, 21065, 21198], [21199, 21199, 21233, 21233, 21369], [21370, 21370, 21397, 21397, 21533], [21534, 21534, 21563, 21563, 21698], [21699, 21699, 21732, 21732, 21868], [21869, 21869, 21903, 21903, 22037], [22038, 22038, 22067, 22067, 22208], [22209, 22209, 22242, 22242, 22403], [22404, 22404, 22431, 22431, 22563], [22564, 22564, 22595, 22595, 22728], [22729, 22729, 22760, 22760, 22904], [22905, 22905, 22933, 22933, 23064], [23065, 23065, 23093, 23093, 23252], [23253, 23253, 23282, 23282, 23419], [23420, 23420, 23448, 23448, 23579], [23580, 23580, 23606, 23606, 23740], [23741, 23741, 23770, 23770, 23909], [23910, 23910, 23938, 23938, 24071], [24072, 24072, 24098, 24098, 24228], [24229, 24229, 24260, 24260, 24394], [24395, 24395, 24427, 24427, 24582], [24583, 24583, 24611, 24611, 24775], [24776, 24776, 24805, 24805, 24957], [24958, 24958, 24992, 24992, 25140], [25141, 25141, 25170, 25170, 25305], [25306, 25306, 25334, 25334, 25483], [25484, 25484, 25510, 25510, 25642], [25643, 25643, 25670, 25670, 25801], [25802, 25802, 25825, 25825, 25970], [25971, 25971, 26003, 26003, 26141], [26142, 26142, 26166, 26166, 26328], [26329, 26329, 26357, 26357, 26488], [26489, 26489, 26520, 26520, 26657], [26658, 26658, 26694, 26694, 26831], [26892, 26892, 26947, 26947, 29444]]}
{"id": "Ns2SzG", "name": "Springy Cube", "author": "oneshade", "description": "I though it'd be fun to put some springs into a cube and use my bilinear patch intersector. Pull the vertices with the mouse. I must say, they look a lot nicer than triangles.", "tags": ["3d", "simulation", "cube", "physics", "spring", "softbody", "bilinearpatch"], "likes": 48, "viewed": 622, "published": 3, "date": "1620503224", "time_retrieved": "2024-07-30T19:21:13.252996", "image_code": "Intersect iScene(in vec3 ro, in vec3 rd) {\n    Intersect scene = Intersect(false, -1.0, vec3(0.0), vec3(0.0), vec2(0.0), -1);\n\n    // Ground plane\n    addPlane(vec3(0.0, PLANE_HEIGHT, 0.0), vec3(0.0, 1.0, 0.0), 0, ro, rd, scene);\n\n    // Vertices (joints)\n    for (int n=0; n < joints.length(); n++) {\n        vec3 joint = getJoint(n).pos;\n        addSphere(joint, JOINT_SIZE, 1, ro, rd, scene);\n    }\n\n    // Faces\n    for (int n=0; n < faces.length(); n++) {\n        vec3 a = getJoint(faces[n][0]).pos;\n        vec3 b = getJoint(faces[n][1]).pos;\n        vec3 c = getJoint(faces[n][2]).pos;\n        vec3 d = getJoint(faces[n][3]).pos;\n        addBilinearPatch(a, b, c, d, 2, ro, rd, scene);\n    }\n\n    return scene;\n}\n\nvec3 getSky(in vec3 rd) {\n    return mix(vec3(1.0), vec3(0.25, 0.25, 1.0), 0.5 + 0.5 * rd.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = CAMERA_POS;\n    vec3 rd = normalize(vec3(uv, -FOCAL_LENGTH));\n\n    fragColor = vec4(getSky(rd), 1.0);\n\n    Intersect scene = iScene(ro, rd);\n    if (scene.hit) {\n        scene.nor *= sign(dot(scene.nor, -rd)); // Flip the normal towards the camera\n        vec3 light = normalize(vec3(-1.0, 1.0, 1.0));\n        if (scene.id == 0) { // Plane\n            fragColor.rgb = vec3(mod(dot(floor(scene.uv), vec2(1.0)), 2.0));\n            fragColor.rgb /= 0.4 * max(1.0, 0.2 * scene.dist); // Fade\n        }\n\n        if (scene.id == 1) { // Sphere\n            fragColor.rgb = vec3(0.0, 0.5, 1.0);\n        }\n\n        if (scene.id == 2) { // Patch\n            float checkers = mod(dot(floor(scene.uv * 8.0), vec2(1.0)), 2.0);\n            fragColor.rgb = vec3(0.5 + 0.5 * checkers, 0.0, 0.0);\n        }\n\n        fragColor.rgb *= max(0.0, mix(dot(scene.nor, light), dot(scene.nor, -rd), 0.5));\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75)); // Tonemap\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const vec3[] joints = vec3[](\n    vec3(-1.5,  1.5, -1.5),\n    vec3(-1.5,  1.5,  1.5),\n    vec3( 1.5,  1.5,  1.5),\n    vec3( 1.5,  1.5, -1.5),\n    vec3(-1.5, -1.5, -1.5),\n    vec3(-1.5, -1.5,  1.5),\n    vec3( 1.5, -1.5,  1.5),\n    vec3( 1.5, -1.5, -1.5)\n);\n\nconst ivec4[] faces = ivec4[](\n    ivec4(0, 1, 2, 3),\n    ivec4(4, 5, 6, 7),\n    ivec4(0, 4, 5, 1),\n    ivec4(1, 5, 6, 2),\n    ivec4(2, 6, 7, 3),\n    ivec4(3, 7, 4, 0)\n);\n\n// Settings\n#define CAMERA_POS vec3(0.0, 0.0, 6.0)\n#define FOCAL_LENGTH 1.0\n\n#define JOINT_SIZE 0.15\n#define JOINT_MASS 10.0\n\n#define PLANE_HEIGHT -2.0\n\n#define GRAVITY 0.1\n#define SPRINGINESS 0.25\n#define DAMPING 0.99\n#define SPEED_LIMIT 0.5\n\n// Utilities\nstruct Joint {\n    vec3 pos;\n    vec3 vel;\n    float mass;\n};\n\n#define getJoint(id)                                  \\\n    Joint(texelFetch(iChannel0, ivec2(id, 0), 0).xyz, \\\n          texelFetch(iChannel0, ivec2(id, 1), 0).xyz, \\\n          JOINT_MASS)                                 \\\n\n// Intersectors\nstruct Intersect {\n    bool hit;\n    float dist;\n    vec3 pos;\n    vec3 nor;\n    vec2 uv;\n    int id;\n};\n\n// Plane intersector\nfloat iPlane(in vec3 o, in vec3 n, in vec3 ro, in vec3 rd) {\n    float d = dot(rd, n);\n    if (d != 0.0) return dot(o - ro, n) / d;\n    return -1.0;\n}\n\n// Adds a plane to the scene\nvoid addPlane(in vec3 o, in vec3 n, in int id, in vec3 ro, in vec3 rd, inout Intersect scene) {\n    ro -= o;\n    float d = dot(rd, n);\n    if (d != 0.0) {\n        float t = -dot(ro, n) / d;\n        if (t > 0.0 && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = ro + rd * t;\n            scene.nor = n;\n            vec3 v = n.x != 0.0 && n.z != 0.0 ? normalize(vec3(-n.z, 0.0, n.x)) : vec3(1.0, 0.0, 0.0);\n            scene.uv = scene.pos * mat2x3(v, cross(v, n));\n            scene.id = id;\n            scene.pos += o;\n        }\n    }\n}\n\n// Adds a sphere to the scene\nvoid addSphere(in vec3 o, in float r, in int id, in vec3 ro, in vec3 rd, inout Intersect scene) {\n    ro -= o;\n\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n\n    float discr = b * b - a * c;\n    if (discr > 0.0) {\n        float t = -(sign(c) * sqrt(discr) + b) / a;\n        if (t > 0.0 && (scene.hit ? t < scene.dist : true)) {\n            scene.hit = true;\n            scene.dist = t;\n            scene.pos = ro + rd * t;\n            scene.nor = scene.pos / r;\n            scene.uv = vec2(atan(scene.nor.z, scene.nor.x) / 6.28, atan(scene.nor.y, length(scene.nor.xz)) / 3.14) + 0.5;\n            scene.id = id;\n            scene.pos += o;\n        }\n    }\n}\n\n// Adds a bilinear patch to the scene\n// Vertices are expected to be winding in counterclockwise order\nfloat cross2D(in vec2 a, in vec2 b) { return a.y * b.x - a.x * b.y; }\nvoid addBilinearPatch(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in int id, in vec3 ro, in vec3 rd, inout Intersect scene) {\n    vec2 m = rd.yz / rd.x;\n    vec3 p = a - b + c - d, q = d - a, r = b - a;\n    vec2 c1 = p.yz - p.x * m, c2 = q.yz - q.x * m, c3 = r.yz - r.x * m;\n    vec2 c4 = (ro.x - a.x) * m + a.yz - ro.yz;\n\n    // Quadratic coefficients (reversed as a trick to deal with edge cases)\n    float qa = cross2D(c4, c2);\n    float qb = cross2D(c4, c1) + cross2D(c3, c2);\n    float qc = cross2D(c3, c1);\n\n    float discr = qb * qb - 4.0 * qa * qc;\n    if (discr > 0.0) {\n        vec2 v = 2.0 * qa / (vec2(-1.0, 1.0) * sqrt(discr) - qb); // Solve quadratic in v\n        vec2 u = -(c4.x + c3.x * v) / (c1.x * v + c2.x);\n        vec2 t = (p.x * u * v + q.x * u + r.x * v + a.x - ro.x) / rd.x;\n\n        // Get closest intersection in view and add it to the scene\n        for (int n=0; n < 2; n++) {\n            if (t[n] > 0.0 && (scene.hit ? t[n] < scene.dist : true) && abs(u[n] - 0.5) < 0.5 && abs(v[n] - 0.5) < 0.5) {\n                scene.hit = true;\n                scene.dist = t[n];\n                scene.pos = ro + rd * t[n];\n                scene.nor = normalize(cross(p * v[n] + q, p * u[n] + r));\n                scene.uv = vec2(u[n], v[n]);\n                scene.id = id;\n            }\n        }\n    }\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n\n    // Simulation\n    if (iFragCoord.x < joints.length() && iFragCoord.y < 2) {\n        if (iFrame == 0) {\n            if (iFragCoord.y == 0) fragColor.xyz = joints[iFragCoord.x] - vec3(0.0, 0.0, 1.0);\n            if (iFragCoord.y == 1) {\n                vec3 joint = joints[iFragCoord.x];\n                fragColor.xyz = vec3(normalize(joint.zx) * vec2(-0.05, 0.05), 0.0) + vec3(0.0, 0.2, -0.05);\n            }\n        }\n\n        if (iFrame > 0) {\n            Joint joint1 = getJoint(iFragCoord.x);\n            vec3 startPos1 = joints[iFragCoord.x];\n\n            // Accumulate gravitational and spring forces\n            vec3 totalForce = vec3(0.0, -GRAVITY, 0.0);\n            for (int i=0; i < joints.length(); i++) {\n                if (i == iFragCoord.x) continue;\n                Joint joint2 = getJoint(i);\n                vec3 startPos2 = joints[int(float(i) + 0.5)]; // Why +0.5?\n\n                float restLength = distance(startPos1, startPos2);\n                vec3 force = normalize(joint2.pos - joint1.pos);\n                float extension = restLength - distance(joint2.pos, joint1.pos);\n                force *= -SPRINGINESS * extension;\n\n                totalForce += force;\n            }\n\n            // Update\n            joint1.vel += totalForce / joint1.mass;\n            joint1.pos += joint1.vel;\n            joint1.pos.y = max(joint1.pos.y, JOINT_SIZE + PLANE_HEIGHT);\n            joint1.vel *= DAMPING * sign(joint1.pos.y - PLANE_HEIGHT - JOINT_SIZE);\n\n            // Attract to mouse\n            if (iMouse.z > 0.0) {\n                vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n                vec3 ro = CAMERA_POS;\n                vec3 rd = normalize(vec3(mouse, -FOCAL_LENGTH));\n\n                bool closest = true;\n                vec3 targetPos = ro + rd * iPlane(joint1.pos, vec3(0.0, 0.0, 1.0), ro, rd);\n                float targetDist = distance(joint1.pos, targetPos);\n                for (int n=0; n < joints.length(); n++) {\n                    if (n == iFragCoord.x) continue;\n                    vec3 joint2 = getJoint(n).pos;\n                    vec3 targetPos2 = ro + rd * iPlane(joint2, vec3(0.0, 0.0, 1.0), ro, rd);\n                    if (distance(joint2, targetPos2) < targetDist) {\n                        closest = false;\n                        break;\n                    }\n                }\n\n                if (closest) {\n                    joint1.vel = (targetPos - joint1.pos) * 0.5;\n                    joint1.vel = normalize(joint1.vel) * min(length(joint1.vel), SPEED_LIMIT);\n                }\n            }\n\n            // Store\n            if (iFragCoord.y == 0) fragColor.xyz = joint1.pos;\n            if (iFragCoord.y == 1) fragColor.xyz = joint1.vel;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2SzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 719], [721, 721, 746, 746, 816], [818, 818, 873, 873, 1906]]}
{"id": "ss2SzG", "name": "voronoi kaleidoscope wallpaper", "author": "Azorlogh", "description": "Made this to use it as my wallpaper.\nCan be customized from the [Common] tab.", "tags": ["voronoi", "kaleidoscope", "wallpaper", "onedark"], "likes": 2, "viewed": 434, "published": 3, "date": "1620503162", "time_retrieved": "2024-07-30T19:21:14.140623", "image_code": "///////////////////////////////////////\n// Shader by Azorlogh                //\n//                                   //\n// Check out Common tab to customize //\n///////////////////////////////////////\n\nvec3 render_bg(vec2 pos) {\n\t\tfloat time = iTime*0.1*BACKGROUND_SPEED;\n\t\tpos *= 10.0;\n\t\tpos = rotate(pos, 0.3);\n\t\tpos = mod(pos+time, vec2(1.0));\n\t\tvec2 dist = smoothstep(0.12, 0.15, min(pos, 1.0-pos));\n\t\treturn mix(THEME[0].rgb*1.2, THEME[0].rgb, max(dist.x, dist.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord / iResolution.xy;\n\n\t// background\n\t#ifdef BACKGROUND_TRANSPARENT\n\t\tfragColor = vec4(0);\n\t#else\n\t\tvec2 pos = (gl_FragCoord.xy-iResolution.xy/2.0) / (iResolution.y/2.0);\n\t\tfragColor = vec4(render_bg(pos), 1);\n\t#endif\n\n\t// shadow\n\t#ifdef SHADOW_ENABLE\n\t\tvec4 blurry_pattern = texture(iChannel1, uv);\n\t\tfragColor = fragColor*(1.0-blurry_pattern.a*SHADOW_OPACITY);\n\t#endif\n\t\n\t// pattern\n\tvec4 pattern = texture(iChannel0, uv);\n\tfragColor = alphaBlend(fragColor, pattern);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 kaleido(vec2 p, float time) {\n\tp = abs(p);\n\tp = rotate(p, time*0.1);\n\tp = rotate(p, TAU/16.0+time*0.02);\n\tp = abs(p);\n\tp -= time;\n\treturn p;\n}\n\nconst float NB_COLORS_F = float(NB_COLORS);\n// edge distance algorithm by Inigo Quilez: https://iquilezles.org/articles/voronoilines\nvec4 voronoi(vec2 pos, float time, vec2 center, out float closest_dst) {\n\tvec2 p = vec2(floor(pos));\n\tvec2 f = fract(pos);\n\tint closest_color;\n\tvec2 closest_pos;\n\tvec2 closest_coord;\n\tfloat fade = 0.0;\n\t// first pass: acquire closest point\n\tclosest_dst = 100.0; // represents the closest square distance to a point\n\tfor (int i=-1; i<=1; i++) {\n\t\tfor (int j=-1; j<=1; j++) {\n\t\t\tvec2 b = vec2(i, j);\n\t\t\tvec2 rand = hash22(vec2(p) + b)*2.0-1.0;\n\t\t\tfloat phase = rand.x*time*TAU + rand.y;\n\t\t\tvec2 rel_pos = b + 0.3*vec2(cos(phase), sin(phase)) - f;\n\t\t\tfloat dst = dot(rel_pos, rel_pos);\n\t\t\tif (dst < closest_dst) {\n\t\t\t\tclosest_color = int(rand.x*NB_COLORS_F);\n\t\t\t\tclosest_pos = rel_pos;\n\t\t\t\tclosest_coord = b;\n\t\t\t\tclosest_dst = dst;\n\t\t\t\tfade = length(vec2(p)+b-center) - FADE_RADIUS;\n\t\t\t}\n\t\t}\n\t}\n\t// second pass: acquire distance to edge\n\tclosest_dst = 100.0; // now represents the closest distance to an edge\n\tfor( int j=-2; j<=2; j++ ) {\n\t\tfor( int i=-2; i<=2; i++ ) {\n\t\t\tvec2 b = closest_coord + vec2(i, j);\n\t\t\tvec2 rand = hash22(vec2(p) + b)*2.0-1.0;\n\t\t\tfloat phase = rand.x*time*TAU + rand.y;\n\t\t\tvec2 rel_pos = b + 0.3*vec2(cos(phase), sin(phase)) - f;\n\t\t\tif (i != 0 || j != 0) {\n\t\t\t\tfloat dst = dot(0.5*(closest_pos+rel_pos), normalize(rel_pos-closest_pos));\n\t\t\t\tif (dst < closest_dst) {\n\t\t\t\t\tclosest_dst = min(closest_dst, dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfloat alpha = clamp(1.0-fade, 0.0, 1.0);\n\treturn THEME[closest_color] * vec4(1, 1, 1, alpha);\n}\n\nvec4 render(vec2 pos, float time) {\n\tpos = kaleido(pos/SCALE, time);\n\tfloat edge_dist;\n\tvec4 color = voronoi(pos, time, vec2(-time), edge_dist);\n\tcolor.a = mix(color.a, 0.0, 1.0 - smoothstep(0.0, 0.03, edge_dist));\n\treturn color;\n}\n\nconst float PATTERN_SIZE = (FADE_RADIUS + sqrt(2.0)/2.0 + 0.3 + 1.0)*SCALE + 0.04;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord-iResolution.xy/2.0) / (iResolution.y/2.0);\n\tfragColor = vec4(0);\n\tif (length(pos) > PATTERN_SIZE) {\n\t\treturn;\n\t}\n\tfloat time = iTime*TIME_SCALE + TIME_OFFSET;\n\tvec4 pcol = render(pos, time);\n\tfragColor = alphaBlend(fragColor, pcol);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n\tfloat sum = 0.0;\n\tfor (int i=-3*SIGMA; i<=3*SIGMA; i++) {\n\t\tfloat fact = normpdf(float(i), float(SIGMA));\n\t\tcol += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(i,0), 0)*fact;\n\t\tsum += fact;\n\t}\n\tcol /= sum;\n\tfragColor = vec4(col);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//////-- CONFIGURATION --//////\n\n//// BACKGROUND ////\n// #define BACKGROUND_TRANSPARENT\nconst float BACKGROUND_SPEED = 1.0;\n\n//// SHADOWS ////\n#define SHADOW_ENABLE\nconst float SHADOW_OPACITY = 0.5; // TODO: 0 to disable\nconst int   SHADOW_SIZE    = 6;\n\n//// PATTERN ////\nconst float FADE_RADIUS = 3.0;    // amount of cells before fading\nconst float TIME_SCALE  = 1.0;    // how fast it changes\nconst float TIME_OFFSET = 0.0;    // change this to start from a different pattern\nconst float SCALE       = 0.1;    // size of the whole pattern\nconst int   NB_COLORS   = 10;     // number of colors for the theme\nconst vec4 THEME[NB_COLORS] = vec4[NB_COLORS](\n\tvec4( 40,  44,  51,   0)/255.0,\n\tvec4( 40,  44,  51,   0)/255.0,\n\tvec4( 40,  44,  51,   0)/255.0,\n\tvec4(244, 107, 116, 255)/255.0,\n\tvec4(152, 195, 121, 255)/255.0,\n\tvec4(299, 192, 122, 255)/255.0,\n\tvec4( 98, 174, 239, 255)/255.0,\n\tvec4(199, 120, 221, 255)/255.0,\n\tvec4( 85, 182, 194, 255)/255.0,\n\tvec4(171, 178, 191, 255)/255.0\n);\n\n//////-- END OF CONFIGURATION --//////\n\n\n\nconst float TAU = 6.2831853071796;\nvec2 rotate(vec2 v, float a) { float c = cos(a), s = sin(a); return mat2( c, s, -s, c )*v; }\n\nvec4 alphaBlend(vec4 a, vec4 b) {\n\tvec4 c;\n\tc.a = b.a + a.a*(1.0-b.a);\n\tc.rgb = (b.rgb*b.a + a.rgb*a.a*(1.0-b.a))/c.a;\n\treturn c;\n}\n\nfloat normpdf(in float x, in float sigma) {\n\treturn 0.39894*exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n}\n\nconst int SIGMA = SHADOW_SIZE;\n\n/////////////////////////////////////////////////////////////////\n// credit: David Hoskins https://www.shadertoy.com/view/XdGfRR //\n#define UI0 1597334673U                                        //\n#define UI1 3812015801U                                        //\n#define UI2 uvec2(UI0, UI1)                                    //\n#define UI3 uvec3(UI0, UI1, 2798796415U)                       //\n#define UIF (1.0 / float(0xffffffffU))                         //\nvec2 hash21(uint q){uvec2 n=q*UI2;n=(n.x^n.y)*UI2;             //\nreturn vec2(n)*UIF;}                                           //\nvec2 hash22(vec2 p){uvec2 q=uvec2(ivec2(p))*UI2;               //\nq=(q.x^q.y)*UI2;return vec2(q)*UIF;}                           //\n/////////////////////////////////////////////////////////////////", "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n\tfloat sum = 0.0;\n\tfor (int i=-3*SIGMA; i<=3*SIGMA; i++) {\n\t\tfloat fact = normpdf(float(i), float(SIGMA));\n\t\tcol += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0,i), 0)*fact;\n\t\tsum += fact;\n\t}\n\tcol /= sum;\n\tfragColor = vec4(col);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2SzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 227, 227, 471], [473, 473, 530, 530, 1020]]}
{"id": "7dSXzy", "name": "strange noise", "author": "zzggbb", "description": "experimenting with ways of generating noise", "tags": ["noise", "rng"], "likes": 0, "viewed": 252, "published": 3, "date": "1620478247", "time_retrieved": "2024-07-30T19:21:15.019274", "image_code": "void mainImage(out vec4 V, in vec2 i){\n    V = vec4(vec3(texelFetch(iChannel0, ivec2(i), 0).x/M), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A iChannel0\n\n#define NONE  vec3(0.0)\n#define LEFT  vec3(1.0, -1.0, 0.0)\n#define UP    vec3(2.0, 0.0, 1.0)\n#define RIGHT vec3(3.0, 1.0, 0.0)\n#define BELOW vec3(4.0, 0.0, -1.0)\n\n#define CELL_RES (iResolution.xy/vec2(CELL_LAYOUT))\n\n#define XMAX float(CELL_LAYOUT.x-1)\n\nbool even(float y) {\n    return mod(y, 2.0) == 0.0;\n}\n\nvec2 get(vec2 I, vec3 dir) {\n    return texelFetch(A, ivec2((I+dir.yz)*CELL_RES + CELL_RES/2.0), 0).xy;\n}\n\nvoid mainImage(out vec4 V, in vec2 i){\n\n\n    vec2 seq;\n    vec3 y = NONE;\n    vec2 I = floor(i/CELL_RES);\n    \n    if (I.x == 0.0 && I.y == 0.0) {\n        // set x0\n        seq = vec2(S, RIGHT.x);\n        y = RIGHT;\n        \n    } else if (I.x == 0.0 && even(I.y)) {\n        // fetch below\n        seq = get(I, BELOW);\n        y = seq.y == UP.x ? RIGHT : NONE;\n        \n    } else if (I.x == 0.0 && !even(I.y)) {\n        // fetch right\n        seq = get(I, RIGHT);\n        y = seq.y == LEFT.x ? UP : NONE;\n        \n    } else if (I.x == XMAX && even(I.y)) {\n        // fetch left\n        seq = get(I, LEFT);\n        y = seq.y == RIGHT.x ? UP : NONE;\n         \n    } else if (I.x == XMAX && !even(I.y)) {\n        // fetch below\n        seq = get(I, BELOW);\n        y = seq.y == UP.x ? LEFT : NONE;\n        \n    } else if (even(I.y)) {\n        // fetch left\n        seq = get(I, LEFT);\n        y = seq.y == RIGHT.x ? RIGHT : NONE;\n        \n    } else {\n        // fetch right\n        seq = get(I, RIGHT);\n        y = seq.y == LEFT.x ? LEFT : NONE;\n    }\n    \n    if (y != NONE) {\n        V = vec4(prng(seq.x), y);\n    } else {\n        V = vec4(0.5);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// nice patterns\n// woven mat: P=239, Q=263, S=17, blumblumshug method\n// cross section worms: P=239, Q=263, S=20, blumblumshug method\n\n#define P (239.0)\n#define Q (263.0)\n#define S 21.0\n#define M (P*Q)\n\n#define CELL_LAYOUT ivec2(250, 120) \n\nfloat prng(float x) {\n    // blum blum shub\n    return mod(0.31*pow(x, 2.0), M);\n    \n    // linear congruential generator\n    //return mod(15.0*x + 17.0, M);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 105]]}
{"id": "ssSXRy", "name": "audio wave and fft example", "author": "bespsm", "description": "Reference shader that utilizes audio wave and fft data for glslViewer (cross platform console-based GLSL Sandbox for 2D/3D shaders shaders):\n\nhttps://github.com/patriciogonzalezvivo/glslViewer.git", "tags": ["audio", "reference", "glslviewer"], "likes": 5, "viewed": 764, "published": 3, "date": "1620471906", "time_retrieved": "2024-07-30T19:21:15.911887", "image_code": "// Reference shader that utilizes audio wave and fft data for glslViewer \n// (cross platform console-based GLSL Sandbox for 2D/3D shaders shaders):\n// https://github.com/patriciogonzalezvivo/glslViewer.git\n// The same glslViewer's shader can be found here:\n// https://github.com/patriciogonzalezvivo/glslViewer/blob/master/examples/2D/00_tests/test_audio.frag\n// Created by Sergei B (https://github.com/bespsm)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// fft\n\tfloat fft  = texture( iChannel0, vec2(uv.x,0.25)).x; \n\t    \n    // wave\n\tfloat wave = texture( iChannel0, vec2(uv.x,0.75)).x;\n\t\n\tvec3 col = vec3(0.0);\n\n\tcol += 1.0 -  smoothstep( 0.0, 0.01, abs(wave - uv.y) );\n    \n    col += 1.0 -  smoothstep( 0.0, 0.03, abs(fft - uv.y) );\n\n    // green\n    col = pow( col, vec3(1.0,0.5,2.0) );\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSXRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 413, 470, 470, 883]]}
{"id": "ssBXRG", "name": "sdf early out test", "author": "elenzil", "description": "A ring of circles with an 'early out' shell around them.\nWhat problems would I run into extending this to a similar 3D raymarched scene such as [url=https://www.shadertoy.com/view/ssjXWm]a bunch of spheres arranged in a sphere[/url] ?", "tags": ["boundingvolume", "bvh", "earlyout"], "likes": 3, "viewed": 398, "published": 3, "date": "1620458887", "time_retrieved": "2024-07-30T19:21:16.766602", "image_code": "float sdDisk(in vec2 p, in float rad) {\n    return length(p) - rad;\n}\n\nfloat sdCircle(in vec2 p, in float rad) {\n    return abs(sdDisk(p, rad));\n}\n\nfloat sdAnnulus(in vec2 p, in float rad1, in float rad2) {\n    return sdCircle(p, rad1) - rad2;\n}\n\n\nfloat map(in vec2 p) {\n    float d = 1e9;\n    \n    float num  = 7.0;\n    float rad1 = 1.0;\n    float rad2 = (sin(iTime * 0.1) * 0.12 + 0.13) * 10.0 / num;\n    \n    float dEarlyOut = sdAnnulus(p, rad1, rad2) - 0.1 ;\n    if (dEarlyOut > 0.0) {\n        return dEarlyOut + 0.1;\n    }\n    \n    for (float n = 0.0; n < num; ++n) {\n        float theta = 3.14159265359 * 2.0 * n / num;\n        d = min(d, sdDisk(p - vec2(cos(theta), sin(theta)) * rad1, rad2));\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2 uv = (XY - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n    uv *= 3.0;\n\n    float d = map(uv);\n\n    // colorize, thank-you iq.\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-9.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(80.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    RGBA = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBXRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 69], [71, 71, 112, 112, 146], [148, 148, 206, 206, 245], [248, 248, 270, 270, 727], [729, 729, 772, 772, 1137]]}
{"id": "NsSXzy", "name": "Galaxy fractal", "author": "jarble", "description": "An edit of my \"Iridescent portals\" fractal.", "tags": ["fractal", "galaxy"], "likes": 2, "viewed": 287, "published": 3, "date": "1620447601", "time_retrieved": "2024-07-30T19:21:17.528565", "image_code": "//change this variable to change the pattern\n#define pattern vec4(0,0.0,0.8,.5)\n\n#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/20.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.16;\n        float scale1 = 1.16;\n        col_prev = col;\n        \n        for(int i=0;i<ITERS;i++)\n        {\n            float uv1 = uv.x-uv.y;\n            uv= fract(pattern.z-uv-(((vec2(uv1+pattern.x*col.x,-pattern.y-uv1))/(scale1*scale*scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(pattern.z+uv.yx);\n            uv.y /= -scale1;\n            uv -= fract(pattern.w+(uv.x-uv.y)/4.0);\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 155, 155, 944]]}
{"id": "NdBSzy", "name": "Bills Dios de la Destruccion", "author": "jorge2017a1", "description": "Bills Dios de la Destruccion", "tags": ["2d", "anime", "billsdiosdeladestruccion"], "likes": 1, "viewed": 289, "published": 3, "date": "1620439732", "time_retrieved": "2024-07-30T19:21:18.286538", "image_code": "//por jorge2017a1 ----jorgeFloresP---7/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\nconst vec3 colAzul2=vec3(0.0,0.0,0.2);\nconst vec3 colVerde=vec3(0.0,1.0,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n//***------------****-----------****------------******-------\nfloat sdPoly33 POLY(33)\nvec2 pt33[ 33]=vec2[](  \nvec2(.34,.59),vec2(.31,.61),vec2(.30,.62),vec2(.30,.63),vec2(.30,.66),\nvec2(.27,.70),vec2(.26,.73),vec2(.27,.84),vec2(.28,.92),vec2(.29,.94),\nvec2(.28,.97),vec2(.30,.98),vec2(.31,.99),vec2(.33,.97),vec2(.38,.91),\nvec2(.43,.80),vec2(.45,.70),vec2(.47,.70),vec2(.52,.70),vec2(.53,.71),\nvec2(.55,.78),vec2(.58,.84),vec2(.61,.91),vec2(.65,.96),vec2(.66,.98),\nvec2(.69,.99),vec2(.69,.96),vec2(.71,.85),vec2(.71,.72),vec2(.69,.67),\nvec2(.69,.63),vec2(.64,.59),vec2(.34,.59) );\n\nfloat sdPoly26 POLY(26)\nvec2 pt26[ 26]=vec2[](  \nvec2(.33,.59),vec2(.45,.70),vec2(.46,.70),vec2(.52,.70),vec2(.53,.71),\nvec2(.64,.60),vec2(.64,.57),vec2(.63,.55),vec2(.62,.53),vec2(.62,.52),\nvec2(.59,.50),vec2(.57,.50),vec2(.56,.48),vec2(.56,.47),vec2(.54,.46),\nvec2(.51,.45),vec2(.46,.45),vec2(.45,.46),vec2(.43,.47),vec2(.43,.49),\nvec2(.39,.51),vec2(.38,.51),vec2(.38,.53),vec2(.36,.54),vec2(.35,.56),\nvec2(.33,.59) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.37,.58),vec2(.40,.57),vec2(.44,.57),vec2(.45,.55),vec2(.44,.55),\nvec2(.40,.56),vec2(.37,.58) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.52,.55),vec2(.54,.57),vec2(.61,.58),vec2(.59,.56),vec2(.52,.55) );\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[ 7]=vec2[](  \nvec2(.43,.61),vec2(.45,.59),vec2(.46,.58),vec2(.46,.58),vec2(.45,.59),\nvec2(.43,.61),vec2(.43,.61) );\n\nfloat sdPoly7c POLY(7)\nvec2 pt7c[ 7]=vec2[](  \nvec2(.52,.58),vec2(.53,.60),vec2(.55,.61),vec2(.55,.61),vec2(.53,.60),\nvec2(.52,.58),vec2(.52,.58) );\n\nfloat sdPoly7d POLY(7)\nvec2 pt7d[ 7]=vec2[](  \nvec2(.44,.54),vec2(.45,.54),vec2(.46,.55),vec2(.47,.55),vec2(.45,.54),\nvec2(.44,.54),vec2(.44,.54) );\n\nfloat sdPoly7e POLY(7)\nvec2 pt7e[ 7]=vec2[](  \nvec2(.52,.55),vec2(.53,.54),vec2(.54,.53),vec2(.54,.53),vec2(.53,.54),\nvec2(.52,.55),vec2(.52,.55) );\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.48,.50),vec2(.47,.51),vec2(.46,.51),vec2(.47,.52),vec2(.49,.52),\nvec2(.52,.51),vec2(.52,.51),vec2(.51,.50),vec2(.50,.50),vec2(.48,.50) );\n\nfloat sdPoly3 POLY(3)\nvec2 pt3[ 3]=vec2[](  \nvec2(.49,.51),vec2(.49,.50),vec2(.49,.51) );\n\nfloat sdPoly17 POLY(17)\nvec2 pt17[ 17]=vec2[](  \nvec2(.43,.47),vec2(.45,.47),vec2(.46,.47),vec2(.48,.47),vec2(.50,.47),\nvec2(.52,.47),vec2(.54,.47),vec2(.56,.47),vec2(.56,.47),vec2(.54,.47),\nvec2(.52,.47),vec2(.50,.47),vec2(.48,.47),vec2(.46,.47),vec2(.45,.47),\nvec2(.43,.47),vec2(.43,.47) );\n\nfloat sdPoly13 POLY(13)\nvec2 pt13[ 13]=vec2[](  \nvec2(.43,.47),vec2(.43,.47),vec2(.43,.45),vec2(.44,.44),vec2(.49,.44),\nvec2(.53,.44),vec2(.56,.45),vec2(.56,.46),vec2(.56,.47),vec2(.54,.46),\nvec2(.47,.45),vec2(.44,.46),vec2(.43,.47) );\n\nfloat sdPoly25 POLY(25)\nvec2 pt25[ 25]=vec2[](  \nvec2(.43,.46),vec2(.55,.46),vec2(.56,.42),vec2(.78,.36),vec2(.81,.33),\nvec2(.82,.29),vec2(.85,.26),vec2(.88,.19),vec2(.89,.17),vec2(.90,.12),\nvec2(.89,.10),vec2(.10,.10),vec2(.09,.12),vec2(.08,.15),vec2(.10,.18),\nvec2(.10,.21),vec2(.13,.23),vec2(.15,.27),vec2(.17,.29),vec2(.17,.31),\nvec2(.20,.35),vec2(.23,.38),vec2(.42,.42),vec2(.43,.43),vec2(.43,.46) );\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.19,.40),vec2(.35,.42),vec2(.36,.40),vec2(.39,.39),vec2(.47,.38),\nvec2(.56,.38),vec2(.60,.40),vec2(.63,.42),vec2(.79,.40),vec2(.78,.37),\nvec2(.73,.31),vec2(.64,.26),vec2(.51,.23),vec2(.37,.25),vec2(.27,.29),\nvec2(.21,.34),vec2(.19,.38),vec2(.19,.40) );\n\nfloat sdPoly5b POLY(5)\nvec2 pt5b[ 5]=vec2[](  \nvec2(.49,.35),vec2(.44,.31),vec2(.49,.27),vec2(.54,.32),vec2(.49,.35) );\n\nfloat sdPoly5c POLY(5)\nvec2 pt5c[ 5]=vec2[](  \nvec2(.21,.36),vec2(.34,.40),vec2(.36,.39),vec2(.24,.33),vec2(.21,.36) );\n\nfloat sdPoly5d POLY(5)\nvec2 pt5d[ 5]=vec2[](  \nvec2(.39,.37),vec2(.42,.37),vec2(.36,.27),vec2(.30,.28),vec2(.39,.37) );\n\nfloat sdPoly5e POLY(5)\nvec2 pt5e[ 5]=vec2[](  \nvec2(.56,.37),vec2(.59,.38),vec2(.68,.30),vec2(.62,.27),vec2(.56,.37) );\n\nfloat sdPoly5f POLY(5)\nvec2 pt5f[ 5]=vec2[](  \nvec2(.61,.39),vec2(.63,.40),vec2(.76,.37),vec2(.73,.34),vec2(.61,.39) );\n\nfloat sdPoly7f POLY(7)\nvec2 pt7f[ 7]=vec2[](  \nvec2(.37,.53),vec2(.39,.52),vec2(.40,.51),vec2(.40,.51),vec2(.39,.52),\nvec2(.37,.53),vec2(.37,.53) );\n\nfloat sdPoly7g POLY(7)\nvec2 pt7g[ 7]=vec2[](  \nvec2(.62,.54),vec2(.60,.53),vec2(.59,.52),vec2(.59,.51),vec2(.60,.53),\nvec2(.62,.53),vec2(.62,.54) );\n\nfloat sdPoly5g POLY(5)\nvec2 pt5g[ 5]=vec2[](  \nvec2(.47,.70),vec2(.43,.68),vec2(.44,.68),vec2(.48,.70),vec2(.47,.70) );\n\nfloat sdPoly5h POLY(5)\nvec2 pt5h[ 5]=vec2[](  \nvec2(.52,.70),vec2(.55,.67),vec2(.56,.67),vec2(.52,.70),vec2(.52,.70) );\n\nfloat sdPoly6 POLY(6)\nvec2 pt6[ 6]=vec2[](  \nvec2(.71,.83),vec2(.66,.82),vec2(.65,.80),vec2(.66,.79),vec2(.71,.79),\nvec2(.71,.83) );\n\nfloat sdPoly5i POLY(5)\nvec2 pt5i[ 5]=vec2[](  \nvec2(.17,.29),vec2(.17,.25),vec2(.18,.25),vec2(.17,.29),vec2(.17,.29) );\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.28,.28),vec2(.26,.26),vec2(.23,.25),vec2(.19,.24),vec2(.19,.24),\nvec2(.23,.25),vec2(.26,.26),vec2(.28,.27),vec2(.28,.28) );\n\nfloat sdPoly7h POLY(7)\nvec2 pt7h[ 7]=vec2[](  \nvec2(.70,.28),vec2(.73,.26),vec2(.78,.24),vec2(.78,.24),vec2(.74,.26),\nvec2(.71,.28),vec2(.70,.28) );\n\nfloat sdPoly5j POLY(5)\nvec2 pt5j[ 5]=vec2[](  \nvec2(.82,.29),vec2(.81,.25),vec2(.81,.25),vec2(.82,.29),vec2(.82,.29) );\n//***------------****-----------****------------******-------\nvec3 RostroBills(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n   float sd1 = sdPoly33(p, pt33);\n   float sd2 = sdPoly26(p, pt26);\n   float sd3 = sdPoly7(p, pt7);\n   float sd4 = sdPoly5(p, pt5);\n   float sd5 = sdPoly7b(p, pt7b);\n   float sd6 = sdPoly7c(p, pt7c);\n   float sd7 = sdPoly7d(p, pt7d);\n   float sd8 = sdPoly7e(p, pt7e);\n   float sd9 = sdPoly10(p, pt10);\n   float sd10 = sdPoly3(p, pt3);\n   float sd11 = sdPoly17(p, pt17);\n   float sd12 = sdPoly13(p, pt13);\n   float sd13 = sdPoly25(p, pt25);\n   float sd14 = sdPoly18(p, pt18);\n   float sd15 = sdPoly5b(p, pt5b);\n   float sd16 = sdPoly5c(p, pt5c);\n   float sd17 = sdPoly5d(p, pt5d);\n   float sd18 = sdPoly5e(p, pt5e);\n   float sd19 = sdPoly5f(p, pt5f);\n   float sd20 = sdPoly7f(p, pt7f);\n   float sd21 = sdPoly7g(p, pt7g);\n   float sd22 = sdPoly5g(p, pt5g);\n   float sd23 = sdPoly5h(p, pt5h);\n   float sd24 = sdPoly6(p, pt6);\n   float sd25 = sdPoly5i(p, pt5i);\n   float sd26 = sdPoly9(p, pt9);\n   float sd27 = sdPoly7h(p, pt7h);\n   float sd28 = sdPoly5j(p, pt5j);\n   float sd29= sdCircle(p-vec2(0.55,0.56), 0.01 );\n   float sd30= sdCircle(p-vec2(0.43,0.56), 0.01 );\n   \n   sd1= opU(sd1, sd2) ;\n   col= ponerBorde(colGris,col,sd1);// 2 orejas\n   //col= ponerBorde(colGris,col,sd2);// rostro\n   col= ponerBorde(colBlanco,col,sd3);// ojo izq\n   col= ponerBorde(colBlanco,col,sd4);// ojo der\n   col= ponerBorde(colNegro,col,sd5); //linea ceja\n   col= ponerBorde(colNegro,col,sd6); //linea ceja\n   col= ponerBorde(colNegro,col,sd7);\n   col= ponerBorde(colNegro,col,sd8);\n   col= ponerBorde(colGris2,col,sd9); ///nariz\n   col= mix(col,colNegro,S( sd10,0.0));\n   col= ponerBorde(colRojo,col,sd11); \n   col= ponerBorde(vec3(0.4,0.4,0.6),col,sd13);  //cuerpo\n   col= ponerBorde(colVerde,col,sd12); //anillo \n   col= ponerBorde(colAzul2,col,sd14); //adorno\n   col= ponerBorde(colRojo,col,sd15);  //figura 1\n   col= ponerBorde(colAzul,col,sd16);  //figura 2\n   col= ponerBorde(colAzul,col,sd17);  //figura 2\n   col= ponerBorde(colAzul,col,sd18);  //figura 2\n   col= ponerBorde(colAzul,col,sd19);  //figura 2\n   col= ponerBorde(colNegro,col,sd20);  //linea 1\n   col= ponerBorde(colNegro,col,sd21);  //linea 2\n   col= ponerBorde(colNegro,col,sd22);  //linea 2\n   col= ponerBorde(colNegro,col,sd23);  //linea 2\n   col= ponerBorde(colAzul,col,sd24);  //cuadro\n   col= ponerBorde(colNegro,col,sd25);  //linea 2\n   col= ponerBorde(colNegro,col,sd26);  //linea 2\n   col= ponerBorde(colNegro,col,sd27);  //linea 2\n   col= ponerBorde(colNegro,col,sd28);  //linea 2\n   col= ponerBorde(colNegro,col,sd29);  //pupila\n   col= ponerBorde(colNegro,col,sd30);  //pupila\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*1.0;\n    vec2 p=uv*0.5-vec2(-0.5,-0.6);\n    vec3 col=vec3(1.0); //vec3(0.25);\n    //col=RostroBills(p*0.5-vec2(0.0,0.0), col);\n    //col=RostroBills(p*0.5-vec2(-0.5,-0.25), col);\n    col=RostroBills(p+ vec2(0.5*sin(iTime),0.0), col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBSzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 339, 339, 363], [365, 365, 425, 425, 549], [551, 551, 582, 582, 603], [6483, 6545, 6586, 6586, 9158], [9160, 9160, 9217, 9217, 9599]]}
{"id": "fsBSRy", "name": "Square tiling (Material Maker)", "author": "demicuz", "description": "I've decided to replicate one of Dave's creations in Material Maker ([url]https://materialmaker.org/[/url]) and export it to Shadertoy. It turned out to be not as easy as I expected, but it was fun anyway.", "tags": ["animation", "generated", "dave", "materialmaker", "beesandbombs"], "likes": 7, "viewed": 327, "published": 3, "date": "1620429911", "time_retrieved": "2024-07-30T19:21:19.234005", "image_code": "// The code is not meant to be read by humans :)\n// Original: https://twitter.com/beesandbombs/status/1387181859264737282\n// The colors are slightly off, and the shader itself is quite wasteful\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb_to_hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv_to_rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat easeInOutCubic(float x) {\n\treturn x < 0.5 ? 4.0 * x * x * x : 1.0 - pow(-2.0 * x + 2.0, 3.0) / 2.0;\n}vec2 scale(vec2 uv, vec2 center, vec2 scale) {\n\tuv -= center;\n\tuv /= scale;\n\tuv += center;\n    return uv;\n}vec3 blend_normal(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1 + (1.0-opacity)*c2;\n}\n\nvec3 blend_dissolve(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\tif (rand(uv) < opacity) {\n\t\treturn c1;\n\t} else {\n\t\treturn c2;\n\t}\n}\n\nvec3 blend_multiply(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1*c2 + (1.0-opacity)*c2;\n}\n\nvec3 blend_screen(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*(1.0-(1.0-c1)*(1.0-c2)) + (1.0-opacity)*c2;\n}\n\nfloat blend_overlay_f(float c1, float c2) {\n\treturn (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));\n}\n\nvec3 blend_overlay(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_overlay_f(c1.x, c2.x), blend_overlay_f(c1.y, c2.y), blend_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_hard_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*0.5*(c1*c2+blend_overlay(uv, c1, c2, 1.0)) + (1.0-opacity)*c2;\n}\n\nfloat blend_soft_light_f(float c1, float c2) {\n\treturn (c2 < 0.5) ? (2.0*c1*c2+c1*c1*(1.0-2.0*c2)) : 2.0*c1*(1.0-c2)+sqrt(c1)*(2.0*c2-1.0);\n}\n\nvec3 blend_soft_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_soft_light_f(c1.x, c2.x), blend_soft_light_f(c1.y, c2.y), blend_soft_light_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_burn_f(float c1, float c2) {\n\treturn (c1==0.0)?c1:max((1.0-((1.0-c2)/c1)),0.0);\n}\n\nvec3 blend_burn(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_burn_f(c1.x, c2.x), blend_burn_f(c1.y, c2.y), blend_burn_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_dodge_f(float c1, float c2) {\n\treturn (c1==1.0)?c1:min(c2/(1.0-c1),1.0);\n}\n\nvec3 blend_dodge(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_dodge_f(c1.x, c2.x), blend_dodge_f(c1.y, c2.y), blend_dodge_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_lighten(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*max(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_darken(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_difference(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*clamp(c2-c1, vec3(0.0), vec3(1.0)) + (1.0-opacity)*c2;\n}\nconst float p_o5267_cx = 0.000000000;\nconst float p_o5267_cy = 0.000000000;\nconst float p_o5267_scale_x = 0.800000000;\nconst float p_o5267_scale_y = 0.800000000;\nconst float p_o5266_amount = 1.000000000;\nvec3 blend_darken_o5265 (vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec4 master_blend_o5265 (vec4 c1, vec4 c2, float amount){\n\treturn vec4(blend_darken_o5265(c1.rgb, c2.rgb, amount*c1.a),\n\t            min(1.0, c2.a+amount*c1.a));\n}\n\nvec4 blend_o5265 (vec4 c1, vec4 c2, float amount) {\n\tif (c1.a > 0.0 && c2.a > 0.0) return master_blend_o5265 (c1, c2, amount);\n\telse if (c1.a > 0.0) return c1;\n\telse return c2;\n}const float p_o5229_tx = 9.000000000;\nconst float p_o5229_ty = 9.000000000;\nconst float p_o5229_overlap = 1.000000000;\n#define p_o5229_bevel 5.5/iResolution.y\nconst float p_o5217_cx = -1.000000000;\nconst float p_o5217_cy = 0.000000000;\nconst float p_o5222_cx = 1.000000000;\nconst float p_o5222_cy = 0.000000000;\nconst float p_o5221_cx = 0.000000000;\nconst float p_o5221_cy = -1.000000000;\nconst float p_o5220_cx = 0.000000000;\nconst float p_o5220_cy = 1.000000000;\nconst float p_o5214_w = 0.500000000;\nconst float p_o5214_h = 0.500000000;\nconst float p_o5214_cx = 0.000000000;\nconst float p_o5214_cy = 0.000000000;\nconst float p_o5224_cx = 0.000000000;\nconst float p_o5224_cy = 0.000000000;\nfloat o5229_input_in(vec3 p) {\nfloat o5217_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5217_cx+0.5, p_o5217_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5222_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5222_cx+0.5, p_o5222_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5218_0_1_sdf2d = min( o5217_0_1_sdf2d, o5222_0_1_sdf2d);\nfloat o5221_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5221_cx+0.5, p_o5221_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5220_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5220_cx+0.5, p_o5220_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5219_0_1_sdf2d = min( o5221_0_1_sdf2d, o5220_0_1_sdf2d);\nfloat o5216_0_1_sdf2d = min( o5218_0_1_sdf2d, o5219_0_1_sdf2d);\nvec2 o5214_0_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_1_sdf2d = length(max(o5214_0_d,vec2(0)))+min(max(o5214_0_d.x,o5214_0_d.y),0.0);\nfloat o5215_0_1_sdf2d = max(- o5216_0_1_sdf2d, o5214_0_1_sdf2d);\nvec2 o5214_2_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_3_sdf2d = length(max(o5214_2_d,vec2(0)))+min(max(o5214_2_d.x,o5214_2_d.y),0.0);\nfloat o5223_0_1_sdf3d = mix(o5215_0_1_sdf2d, o5214_0_3_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5224_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5224_cx+0.5, p_o5224_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5225_0_1_sdf3d = mix(o5214_0_3_sdf2d, o5224_0_1_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5226_0_1_sdf3d = max(- o5223_0_1_sdf3d, o5225_0_1_sdf3d);\n\nreturn o5226_0_1_sdf3d;\n}\nconst float p_o5263_hue = 0.000000000;\nconst float p_o5263_saturation = 2.000000000;\nconst float p_o5263_value = 1.000000000;\nvec4 o5263_f(vec4 c) {\n\tvec3 hsv = rgb_to_hsv(c.rgb);\n\treturn vec4(hsv_to_rgb(vec3(fract(hsv.x+p_o5263_hue), clamp(hsv.y*p_o5263_saturation, 0.0, 1.0), clamp(hsv.z*p_o5263_value, 0.0, 1.0))), c.a);\n}const float p_o5242_gradient_0_pos = 0.166113000;\nconst float p_o5242_gradient_0_r = 1.000000000;\nconst float p_o5242_gradient_0_g = 0.878431022;\nconst float p_o5242_gradient_0_b = 0.250979990;\nconst float p_o5242_gradient_0_a = 0.486274987;\nconst float p_o5242_gradient_1_pos = 0.500000000;\nconst float p_o5242_gradient_1_r = 1.000000000;\nconst float p_o5242_gradient_1_g = 0.411765009;\nconst float p_o5242_gradient_1_b = 0.717647016;\nconst float p_o5242_gradient_1_a = 0.486274987;\nconst float p_o5242_gradient_2_pos = 0.832226000;\nconst float p_o5242_gradient_2_r = 0.109803997;\nconst float p_o5242_gradient_2_g = 0.760783970;\nconst float p_o5242_gradient_2_b = 0.756862998;\nconst float p_o5242_gradient_2_a = 0.486274987;\nvec4 o5242_gradient_gradient_fct(float x) {\n  if (x < 0.5*(p_o5242_gradient_0_pos+p_o5242_gradient_1_pos)) {\n    return vec4(p_o5242_gradient_0_r,p_o5242_gradient_0_g,p_o5242_gradient_0_b,p_o5242_gradient_0_a);\n  } else if (x < 0.5*(p_o5242_gradient_1_pos+p_o5242_gradient_2_pos)) {\n    return vec4(p_o5242_gradient_1_r,p_o5242_gradient_1_g,p_o5242_gradient_1_b,p_o5242_gradient_1_a);\n  }\n  return vec4(p_o5242_gradient_2_r,p_o5242_gradient_2_g,p_o5242_gradient_2_b,p_o5242_gradient_2_a);\n}\nvec4 o5229_input_color_map(vec2 uv) {\nvec2 o5242_0_wat = abs((uv) - 0.5);\nfloat o5242_0_d = o5242_0_wat.x+o5242_0_wat.y;vec4 o5242_0_1_rgba = o5242_gradient_gradient_fct(fract(2.0*(5.0/3.0)*o5242_0_d));\nvec4 o5263_0_1_rgba = o5263_f(o5242_0_1_rgba);\n\nreturn o5263_0_1_rgba;\n}\nconst float p_o5271_repeat = 0.500000000;\nconst float p_o5271_gradient_0_pos = 0.000000000;\nconst float p_o5271_gradient_0_r = 0.000000000;\nconst float p_o5271_gradient_0_g = 0.000000000;\nconst float p_o5271_gradient_0_b = 0.000000000;\nconst float p_o5271_gradient_0_a = 1.000000000;\nconst float p_o5271_gradient_1_pos = 0.252491694;\nconst float p_o5271_gradient_1_r = 0.000000000;\nconst float p_o5271_gradient_1_g = 0.000000000;\nconst float p_o5271_gradient_1_b = 0.000000000;\nconst float p_o5271_gradient_1_a = 1.000000000;\nconst float p_o5271_gradient_2_pos = 0.750830565;\nconst float p_o5271_gradient_2_r = 1.000000000;\nconst float p_o5271_gradient_2_g = 1.000000000;\nconst float p_o5271_gradient_2_b = 1.000000000;\nconst float p_o5271_gradient_2_a = 1.000000000;\nconst float p_o5271_gradient_3_pos = 1.000000000;\nconst float p_o5271_gradient_3_r = 1.000000000;\nconst float p_o5271_gradient_3_g = 1.000000000;\nconst float p_o5271_gradient_3_b = 1.000000000;\nconst float p_o5271_gradient_3_a = 1.000000000;\nvec4 o5271_gradient_gradient_fct(float x) {\n  if (x < p_o5271_gradient_0_pos) {\n    return vec4(p_o5271_gradient_0_r,p_o5271_gradient_0_g,p_o5271_gradient_0_b,p_o5271_gradient_0_a);\n  } else if (x < p_o5271_gradient_1_pos) {\n    return mix(vec4(p_o5271_gradient_0_r,p_o5271_gradient_0_g,p_o5271_gradient_0_b,p_o5271_gradient_0_a), vec4(p_o5271_gradient_1_r,p_o5271_gradient_1_g,p_o5271_gradient_1_b,p_o5271_gradient_1_a), ((x-p_o5271_gradient_0_pos)/(p_o5271_gradient_1_pos-p_o5271_gradient_0_pos)));\n  } else if (x < p_o5271_gradient_2_pos) {\n    return mix(vec4(p_o5271_gradient_1_r,p_o5271_gradient_1_g,p_o5271_gradient_1_b,p_o5271_gradient_1_a), vec4(p_o5271_gradient_2_r,p_o5271_gradient_2_g,p_o5271_gradient_2_b,p_o5271_gradient_2_a), ((x-p_o5271_gradient_1_pos)/(p_o5271_gradient_2_pos-p_o5271_gradient_1_pos)));\n  } else if (x < p_o5271_gradient_3_pos) {\n    return mix(vec4(p_o5271_gradient_2_r,p_o5271_gradient_2_g,p_o5271_gradient_2_b,p_o5271_gradient_2_a), vec4(p_o5271_gradient_3_r,p_o5271_gradient_3_g,p_o5271_gradient_3_b,p_o5271_gradient_3_a), ((x-p_o5271_gradient_2_pos)/(p_o5271_gradient_3_pos-p_o5271_gradient_2_pos)));\n  }\n  return vec4(p_o5271_gradient_3_r,p_o5271_gradient_3_g,p_o5271_gradient_3_b,p_o5271_gradient_3_a);\n}\nfloat o5229_input_t_map(vec2 uv) {\nvec2 o5271_0_wat = abs((uv) - 0.5);\nfloat o5271_0_d = max(o5271_0_wat.x,o5271_0_wat.y);vec4 o5271_0_1_rgba = o5271_gradient_gradient_fct(2.0*abs(fract(-0.2*iTime + p_o5271_repeat*o5271_0_d)-0.5));\nfloat o118692_0_1_f = easeInOutCubic((dot((o5271_0_1_rgba).rgb, vec3(1.0))/3.0));\n\nreturn o118692_0_1_f;\n}\nvec3 blend_darken_o5229 (vec3 c1, vec3 c2, float opacity) {\n\t//return min(c1, c2);\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec4 master_blend_o5229 (vec4 c1, vec4 c2, float amount){\n\treturn vec4(blend_darken_o5229(c1.rgb, c2.rgb, c1.a*amount),\n\t            min(1.0, c2.a+amount*c1.a));\n}\n\nvec4 tiler_o5229(vec2 uv, vec2 tile, float overlap, float bevel) {\n\tvec2 if_calculated = abs(uv-0.5)-overlap*(1.0/tile);\n\tif (if_calculated.x > 0.5 || if_calculated.y > 0.5) {\n\t\treturn vec4(0.0);\n\t}\n\t\n\tvec2 p = uv*tile;\n\t\n\tvec2 cell_id = floor(p);\n\tvec2 local_uv = fract(p);\n\tvec2 fetching_uv = (cell_id + 0.5)/tile;\n\t\n\tvec4 color = vec4(1.0, 1.0, 1.0, 0.0);\n\t\n\tfor (float dx = -overlap; dx <= overlap; ++dx) {\n\t\tfor (float dy = -overlap; dy <= overlap; ++dy) {\n\t\t\tvec2 local_uv_offset = vec2(dx, dy);\n\t\t\tvec2 local_fetching_uv = fetching_uv - local_uv_offset/tile;\n\t\t\t\n\t\t\tif (local_fetching_uv.x < 0.0 || local_fetching_uv.x > 1.0 || local_fetching_uv.y < 0.0 || local_fetching_uv.y > 1.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvec2 localler_uv = local_uv + local_uv_offset;\n\t\t\t\n\t\t\tfloat sdf = o5229_input_in(vec3(localler_uv, o5229_input_t_map(local_fetching_uv)));\n\t\t\t//float sdf_color = step(sdf, 0.0);\n\t\t\tfloat sdf_color = smoothstep(bevel, -bevel, sdf);\n\t\t\t\n\t\t\tvec4 fetched_color = o5229_input_color_map(local_fetching_uv);\n\t\t\t//if (color == vec4(0.0)) {\n\t\t\t//\tfetched_color.a *= sdf_color;\n\t\t\t//\tcolor = vec4(1.0);\n\t\t\t//}\n\t\t\tif (sdf_color > 0.0) {\n\t\t\t\tfetched_color.a *= sdf_color;\n\t\t\t\tcolor = master_blend_o5229(color,fetched_color,1.0);\n\t\t\t}\n\t\t\t\n\t\t\t//color = max(color, o5229_input_color_map(local_fetching_uv)*sdf);\n\t\t\t//color = blend_darken_o5229(o5229_input_color_map(local_fetching_uv)*sdf,color,1.0);\n\t\t}\n\t}\n\treturn color;\n\t//if (color.a < 0.000001) return vec4(0.0);\n\t//else return color;\n}const float p_o5252_cx = 0.000000000;\nconst float p_o5252_cy = 0.000000000;\nconst float p_o5268_tx = 8.000000000;\nconst float p_o5268_ty = 8.000000000;\nconst float p_o5268_overlap = 1.000000000;\n#define p_o5268_bevel 5.5/iResolution.y\nfloat o5268_input_in(vec3 p) {\nfloat o5217_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5217_cx+0.5, p_o5217_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5222_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5222_cx+0.5, p_o5222_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5218_0_1_sdf2d = min( o5217_0_1_sdf2d, o5222_0_1_sdf2d);\nfloat o5221_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5221_cx+0.5, p_o5221_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5220_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5220_cx+0.5, p_o5220_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5219_0_1_sdf2d = min( o5221_0_1_sdf2d, o5220_0_1_sdf2d);\nfloat o5216_0_1_sdf2d = min( o5218_0_1_sdf2d, o5219_0_1_sdf2d);\nvec2 o5214_0_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_1_sdf2d = length(max(o5214_0_d,vec2(0)))+min(max(o5214_0_d.x,o5214_0_d.y),0.0);\nfloat o5215_0_1_sdf2d = max(- o5216_0_1_sdf2d, o5214_0_1_sdf2d);\nvec2 o5214_2_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_3_sdf2d = length(max(o5214_2_d,vec2(0)))+min(max(o5214_2_d.x,o5214_2_d.y),0.0);\nfloat o5223_0_1_sdf3d = mix(o5215_0_1_sdf2d, o5214_0_3_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5224_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5224_cx+0.5, p_o5224_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5225_0_1_sdf3d = mix(o5214_0_3_sdf2d, o5224_0_1_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5226_0_1_sdf3d = max(- o5223_0_1_sdf3d, o5225_0_1_sdf3d);\n\nreturn o5226_0_1_sdf3d;\n}\nconst float p_o5264_hue = 0.000000000;\nconst float p_o5264_saturation = 2.000000000;\nconst float p_o5264_value = 1.000000000;\nvec4 o5264_f(vec4 c) {\n\tvec3 hsv = rgb_to_hsv(c.rgb);\n\treturn vec4(hsv_to_rgb(vec3(fract(hsv.x+p_o5264_hue), clamp(hsv.y*p_o5264_saturation, 0.0, 1.0), clamp(hsv.z*p_o5264_value, 0.0, 1.0))), c.a);\n}const float p_o183339_cx = 0.000000000;\nconst float p_o183339_cy = 0.000000000;\nvec4 o5268_input_color_map(vec2 uv) {\nvec2 o5242_0_wat = abs((scale((uv), vec2(0.5+p_o183339_cx, 0.5+p_o183339_cy), vec2((9.0/8.0), (9.0/8.0)))) - 0.5);\nfloat o5242_0_d = o5242_0_wat.x+o5242_0_wat.y;vec4 o5242_0_1_rgba = o5242_gradient_gradient_fct(fract(2.0*(5.0/3.0)*o5242_0_d));\nvec4 o183339_0_1_rgba = o5242_0_1_rgba;\nvec4 o5264_0_1_rgba = o5264_f(o183339_0_1_rgba);\n\nreturn o5264_0_1_rgba;\n}\nfloat o5268_input_t_map(vec2 uv) {\nvec2 o5271_0_wat = abs((uv) - 0.5);\nfloat o5271_0_d = max(o5271_0_wat.x,o5271_0_wat.y);vec4 o5271_0_1_rgba = o5271_gradient_gradient_fct(2.0*abs(fract(-0.2*iTime + p_o5271_repeat*o5271_0_d)-0.5));\nfloat o118692_0_1_f = easeInOutCubic((dot((o5271_0_1_rgba).rgb, vec3(1.0))/3.0));\n\nreturn o118692_0_1_f;\n}\nvec3 blend_darken_o5268 (vec3 c1, vec3 c2, float opacity) {\n\t//return min(c1, c2);\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec4 master_blend_o5268 (vec4 c1, vec4 c2, float amount){\n\treturn vec4(blend_darken_o5268(c1.rgb, c2.rgb, c1.a*amount),\n\t            min(1.0, c2.a+amount*c1.a));\n}\n\nvec4 tiler_o5268(vec2 uv, vec2 tile, float overlap, float bevel) {\n\tvec2 if_calculated = abs(uv-0.5)-overlap*(1.0/tile);\n\tif (if_calculated.x > 0.5 || if_calculated.y > 0.5) {\n\t\treturn vec4(0.0);\n\t}\n\t\n\tvec2 p = uv*tile;\n\t\n\tvec2 cell_id = floor(p);\n\tvec2 local_uv = fract(p);\n\tvec2 fetching_uv = (cell_id + 0.5)/tile;\n\t\n\tvec4 color = vec4(1.0, 1.0, 1.0, 0.0);\n\t\n\tfor (float dx = -overlap; dx <= overlap; ++dx) {\n\t\tfor (float dy = -overlap; dy <= overlap; ++dy) {\n\t\t\tvec2 local_uv_offset = vec2(dx, dy);\n\t\t\tvec2 local_fetching_uv = fetching_uv - local_uv_offset/tile;\n\t\t\t\n\t\t\tif (local_fetching_uv.x < 0.0 || local_fetching_uv.x > 1.0 || local_fetching_uv.y < 0.0 || local_fetching_uv.y > 1.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvec2 localler_uv = local_uv + local_uv_offset;\n\t\t\t\n\t\t\tfloat sdf = o5268_input_in(vec3(localler_uv, o5268_input_t_map(local_fetching_uv)));\n\t\t\t//float sdf_color = step(sdf, 0.0);\n\t\t\tfloat sdf_color = smoothstep(bevel, -bevel, sdf);\n\t\t\t\n\t\t\tvec4 fetched_color = o5268_input_color_map(local_fetching_uv);\n\t\t\t//if (color == vec4(0.0)) {\n\t\t\t//\tfetched_color.a *= sdf_color;\n\t\t\t//\tcolor = vec4(1.0);\n\t\t\t//}\n\t\t\tif (sdf_color > 0.0) {\n\t\t\t\tfetched_color.a *= sdf_color;\n\t\t\t\tcolor = master_blend_o5268(color,fetched_color,1.0);\n\t\t\t}\n\t\t\t\n\t\t\t//color = max(color, o5268_input_color_map(local_fetching_uv)*sdf);\n\t\t\t//color = blend_darken_o5268(o5268_input_color_map(local_fetching_uv)*sdf,color,1.0);\n\t\t}\n\t}\n\treturn color;\n\t//if (color.a < 0.000001) return vec4(0.0);\n\t//else return color;\n}const float p_o5270_color_r = 1.000000000;\nconst float p_o5270_color_g = 1.000000000;\nconst float p_o5270_color_b = 1.000000000;\nconst float p_o5270_color_a = 1.000000000;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec4 o5229_0_1_rgba = tiler_o5229((scale((UV), vec2(0.5+p_o5267_cx, 0.5+p_o5267_cy), vec2(p_o5267_scale_x, p_o5267_scale_y))), vec2(p_o5229_tx, p_o5229_ty), p_o5229_overlap, p_o5229_bevel);\nvec4 o5268_0_1_rgba = tiler_o5268((scale((scale((UV), vec2(0.5+p_o5267_cx, 0.5+p_o5267_cy), vec2(p_o5267_scale_x, p_o5267_scale_y))), vec2(0.5+p_o5252_cx, 0.5+p_o5252_cy), vec2((8.0/9.0), (8.0/9.0)))), vec2(p_o5268_tx, p_o5268_ty), p_o5268_overlap, p_o5268_bevel);\nvec4 o5252_0_1_rgba = o5268_0_1_rgba;\nvec4 o5265_0_1_rgba = blend_o5265(o5229_0_1_rgba, o5252_0_1_rgba, 1.0);\nvec4 o5270_0_1_rgba = vec4(p_o5270_color_r, p_o5270_color_g, p_o5270_color_b, p_o5270_color_a);\nvec4 o5266_0_s1 = o5265_0_1_rgba;\nvec4 o5266_0_s2 = o5270_0_1_rgba;\nfloat o5266_0_a = p_o5266_amount*1.0;\nvec4 o5266_0_2_rgba = vec4(blend_normal((scale((UV), vec2(0.5+p_o5267_cx, 0.5+p_o5267_cy), vec2(p_o5267_scale_x, p_o5267_scale_y))), o5266_0_s1.rgb, o5266_0_s2.rgb, o5266_0_a*o5266_0_s1.a), min(1.0, o5266_0_s2.a+o5266_0_a*o5266_0_s1.a));\nvec4 o5267_0_1_rgba = o5266_0_2_rgba;\nfragColor = o5267_0_1_rgba;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBSRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 215, 215, 294], [296, 296, 316, 316, 449], [451, 451, 471, 471, 660], [662, 662, 684, 684, 981], [983, 983, 1005, 1005, 1165], [1167, 1167, 1192, 1192, 1489], [1491, 1491, 1516, 1516, 1676], [1677, 1677, 1708, 1708, 1784], [1784, 1784, 1830, 1830, 1891], [1891, 1891, 1952, 1952, 1993], [1995, 1995, 2058, 2058, 2126], [2128, 2128, 2191, 2191, 2235], [2237, 2237, 2298, 2298, 2360], [2362, 2362, 2405, 2405, 2471], [2473, 2473, 2535, 2535, 2665], [2667, 2667, 2732, 2732, 2813], [2815, 2815, 2861, 2861, 2956], [2958, 2958, 3023, 3023, 3162], [3164, 3164, 3204, 3204, 3257], [3259, 3259, 3318, 3318, 3439], [3441, 3441, 3482, 3482, 3527], [3529, 3529, 3589, 3589, 3713], [3715, 3715, 3777, 3777, 3827], [3829, 3829, 3890, 3890, 3940], [3942, 3942, 4007, 4007, 4080], [4285, 4285, 4344, 4344, 4394], [4396, 4396, 4453, 4453, 4559], [4561, 4561, 4612, 4612, 4739], [5430, 5430, 5460, 5460, 6892], [7019, 7019, 7041, 7041, 7218], [7944, 7944, 7987, 7987, 8434], [8435, 8435, 8472, 8472, 8710], [9721, 9721, 9764, 9764, 10965], [10966, 10966, 11000, 11000, 11304], [11305, 11305, 11364, 11387, 11437], [11439, 11439, 11496, 11496, 11602], [11604, 11604, 11670, 11670, 13099], [13334, 13334, 13364, 13364, 14796], [14923, 14923, 14945, 14945, 15122], [15202, 15202, 15239, 15239, 15598], [15599, 15599, 15633, 15633, 15937], [15938, 15938, 15997, 16020, 16070], [16072, 16072, 16129, 16129, 16235], [16237, 16237, 16303, 16303, 17732], [17905, 17905, 17960, 17960, 19185]]}
{"id": "NdSSRy", "name": "Material Maker Experiment 003", "author": "PauloFalcao", "description": "Generated using the node based material maker using my raymarching lib (see code comments)\nYoutube video making this https://youtu.be/VzV9zOzzUVA", "tags": ["generated", "materialmaker", "nodes"], "likes": 12, "viewed": 539, "published": 3, "date": "1620425599", "time_retrieved": "2024-07-30T19:21:19.983999", "image_code": "// Material Maker Experiment 003\n// By PauloFalcao\n//\n// Made in the node base material maker\n//\n// Youtube video making this https://youtu.be/VzV9zOzzUVA\n//\n// MaterialMaker is a nodebased shader maker to make procedural textures\n// With custom nodes GLSL nodes created directly in the tool,\n// it's possible to make complex stuff like raymarching :)\n//\n// It's also possible to export the generated code to Shadertoy!\n//\n// I made a library with Ray Marching nodes\n// 1st version 0.01 have 44 new nodes\n// Some nodes are based in code from other authors from shadertoy\n// I always refer the shader author and the shadertoy original code\n// The idea is to reuse the code to quicky create something without coding experience\n// Or just focus on the code of a single node\n//\n// You need Material Maker - https://rodzilla.itch.io/material-maker\n// And my library - https://github.com/paulofalcao/MaterialMakerRayMarching\n// \n// The Material Maker source is here\n//    https://github.com/paulofalcao/MaterialMakerRayMarching/blob/main/Examples/pxf003.mms\n// Just copy-paste into Material Maker\n\nfloat sdSmoothXYUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec3 rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o349467_CamY = 0.997000000;\nconst float p_o349467_LookAtX = 0.000000000;\nconst float p_o349467_LookAtY = -0.266000000;\nconst float p_o349467_LookAtZ = 0.000000000;\nconst float p_o349467_CamD = 1.825000000;\nconst float p_o349467_CamZoom = 0.977000000;\nconst float p_o349467_Reflection = 0.200000000;\nconst float p_o349467_Specular = 0.000000000;\nconst float p_o349467_Pow = 64.000000000;\nconst float p_o349467_SunX = 2.500000000;\nconst float p_o349467_SunY = 2.500000000;\nconst float p_o349467_SunZ = 1.000000000;\nconst float p_o349467_AmbLight = 0.250000000;\nconst float p_o349467_AmbOcclusion = 0.502000000;\nconst float p_o349467_Shadow = 1.000000000;\nconst float p_o538946_s = 0.330000000;\nconst float p_o528578_x = 0.000000000;\nconst float p_o528578_y = -1.000000000;\nconst float p_o528578_z = 0.000000000;\nconst float p_o663512_r = 1.270000000;\n\nfloat o360551_input_obj3d(vec3 p) {\n    float o663512_0_1_sdf3d = length((p))-p_o663512_r;\n    return o663512_0_1_sdf3d;\n}\n\nconst float p_o373061_x = 1.000000000;\nconst float p_o373061_y = 1.000000000;\nconst float p_o373061_z = 1.000000000;\nconst float p_o382957_xyz = 0.452000000;\nconst float p_o382957_x = 1.000000000;\nconst float p_o382957_y = 1.000000000;\nconst float p_o382957_z = 1.000000000;\n\nvec4 o360551_input_trans3d(vec4 p) {\n    vec4 o370386_0_1_v4v4 = (vec4(rotate3d((vec4((vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).w)).xyz/vec3(p_o382957_x, p_o382957_y, p_o382957_z)/p_o382957_xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).w)).w)).xyz, -vec3((sin(iTime*0.05)*360.0), (sin(iTime*0.07)*360.0), (sin(iTime*0.03)*360.0))*0.01745329251), (vec4((vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).w)).xyz/vec3(p_o382957_x, p_o382957_y, p_o382957_z)/p_o382957_xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).w)).w)).w));\n    vec4 o371615_0_1_v4v4 = o370386_0_1_v4v4;\n    vec4 o_o382957_0=o371615_0_1_v4v4;vec4 o382957_0_1_v4v4 = vec4(o_o382957_0.xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).w)).w/min(min(p_o382957_x, p_o382957_y), p_o382957_z)/p_o382957_xyz);\n    vec4 o373061_0_1_v4v4 = o382957_0_1_v4v4;\n    vec4 o391263_0_1_v4v4 = o373061_0_1_v4v4;\n    return o391263_0_1_v4v4;\n}\n\nconst float p_o694452_k = 0.010000000;\n\nfloat o360551_input_custombool(vec2 uv) {\n    float o694452_0_1_sdf2d = sdSmoothXYUnion((uv).x, (uv).y, p_o694452_k);\n    return o694452_0_1_sdf2d;\n}\n\nfloat for_custom_o360551(vec4 p) {\n  float d=o360551_input_obj3d(p.xyz);\n  float m=o360551_input_custombool(vec2(999999.0,d));\n  for(int i=0;i<6;i++){\n    p=o360551_input_trans3d(p);\n\td=o360551_input_obj3d(p.xyz);\n\tm=o360551_input_custombool(vec2(m,d/p.w));\n  }\n  return m;\n}\n\nfloat o349467_input_sdf_a(vec3 p) {\n    float o360551_0_1_sdf3d = for_custom_o360551(vec4((rotate3d(((((p))/p_o538946_s)-vec3(p_o528578_x, p_o528578_y, p_o528578_z)), -vec3((iTime*21.0), (iTime*27.0), (iTime*23.0))*0.01745329251)),1.0));\n    vec2 o512498_0_1_sdf3dc = vec2(o360551_0_1_sdf3d, 0.0);\n    vec2 o528578_0_1_sdf3dc = o512498_0_1_sdf3dc;\n    vec2 o538946_0_in = o528578_0_1_sdf3dc;vec2 o538946_0_1_sdf3dc = vec2(o538946_0_in.x*p_o538946_s, o538946_0_in.y);\n    return (o538946_0_1_sdf3dc).x;\n}\n\nvec3 o349467_input_tex3d_a(vec4 p) {\n    return vec3(1.0,0.1,0.1);\n}\n\nfloat o349467_input_sdf_b(vec3 p) {\n    return max((p).y+1.0,length(vec3((p).x,(p).y+1.0,(p).z))-10.0);\n}\n\nvec3 o349467_input_tex3d_b(vec4 p) {\n    return vec3(mod(floor((p).x*2.0)+floor((p).z*2.0),2.0))*0.9+0.1;\n}\n\nvec3 o349467_input_hdri(vec2 uv) {\n    return Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o349467_SunX,p_o349467_SunY,-p_o349467_SunZ)));\n}\n\nvec2 input_o349467(vec3 p) {\n    float sdfa=o349467_input_sdf_a(p);\n\tfloat sdfb=o349467_input_sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o349467(vec3 p){  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=input_o349467(p+e.xyy).x;\n  float v2=input_o349467(p+e.yyx).x;\n  float v3=input_o349467(p+e.yxy).x;\n  float v4=input_o349467(p+e.xxx).x;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o349467(inout float d,inout vec3 p,inout vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = input_o349467(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o349467( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = input_o349467( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o349467( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = input_o349467( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o349467(vec2 uv) {\n    uv-=0.5;\n\tvec3 cam=vec3((sin(sin(iTime*0.2)*0.5+0.5)*4.0),p_o349467_CamY,(sin(sin(iTime*0.3)*0.5+0.5)*4.0))*p_o349467_CamZoom;\n\tvec3 lookat=vec3(p_o349467_LookAtX,p_o349467_LookAtY,p_o349467_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o349467_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_o349467(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=(dS.y<0.5)?o349467_input_tex3d_a(vec4(p,1.0)):o349467_input_tex3d_b(vec4(p,1.0));\n\tvec3 light=normalize(vec3(p_o349467_SunX,p_o349467_SunY,p_o349467_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o349467(p);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o349467(p,n),p_o349467_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o349467(p,light,0.05,5.0),p_o349467_Shadow);\n\t\tcolor=min(vec3(max(shadow,p_o349467_AmbLight)),max(l,p_o349467_AmbLight))*max(cAO,p_o349467_AmbLight)*objColor+pow(r,p_o349467_Pow)*p_o349467_Specular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o349467(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?o349467_input_tex3d_a(vec4(p,1.0)):o349467_input_tex3d_b(vec4(p,1.0));\n\t\t\tn=normal_o349467(p);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o349467_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o349467_input_hdri(equirectangularMap(ref.xzy)).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,p_o349467_Reflection);\n\t} else {\n\t\tcolor=o349467_input_hdri(equirectangularMap(rd.xzy)).xyz;\n\t}\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float minSize = min(iResolution.x, iResolution.y);\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 o349467_0_1_rgb = raymarch_o349467((UV));\n    fragColor = vec4(o349467_0_1_rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSSRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1092, 1092, 1146, 1146, 1245], [1247, 1247, 1278, 1278, 1582], [1615, 1615, 1650, 1650, 1739], [1763, 1837, 1872, 1872, 1989], [1991, 1991, 2024, 2024, 2320], [2322, 2322, 2358, 2358, 2565], [2567, 2567, 2602, 2602, 2811], [2813, 2813, 2850, 2850, 2939], [2941, 2941, 2991, 2991, 3538], [3540, 3540, 3588, 3588, 3858], [4742, 4742, 4777, 4777, 4864], [5142, 5142, 5178, 5178, 6750], [6792, 6792, 6833, 6833, 6941], [6943, 6943, 6977, 6977, 7218], [7220, 7220, 7255, 7255, 7723], [7725, 7725, 7761, 7761, 7793], [7795, 7795, 7830, 7830, 7900], [7902, 7902, 7938, 7938, 8009], [8011, 8011, 8045, 8045, 8174], [8176, 8176, 8204, 8204, 8364], [8366, 8442, 8470, 8470, 8724], [8726, 8726, 8805, 8805, 8968], [8970, 9015, 9064, 9064, 9332], [9334, 9379, 9463, 9463, 9781], [9783, 9783, 9815, 9815, 11497], [11499, 11499, 11554, 11554, 11811]]}
{"id": "NsBXzG", "name": "Material Maker Experiment 002", "author": "PauloFalcao", "description": "Generated using the node based material maker using my raymarching lib (see code comments)\nYoutube video making this https://youtu.be/VzV9zOzzUVA", "tags": ["fractal", "generated", "materialmaker", "nodes"], "likes": 40, "viewed": 913, "published": 3, "date": "1620423579", "time_retrieved": "2024-07-30T19:21:20.733994", "image_code": "// Material Maker Experiment 002\n// By PauloFalcao\n//\n// Made in the node base material maker\n//\n// Youtube video making this https://youtu.be/VzV9zOzzUVA\n//\n// MaterialMaker is a nodebased shader maker to make procedural textures\n// With custom nodes GLSL nodes created directly in the tool,\n// it's possible to make complex stuff like raymarching :)\n//\n// It's also possible to export the generated code to Shadertoy!\n//\n// I made a library with Ray Marching nodes\n// 1st version 0.01 have 44 new nodes\n// Some nodes are based in code from other authors from shadertoy\n// I always refer the shader author and the shadertoy original code\n// The idea is to reuse the code to quicky create something without coding experience\n// Or just focus on the code of a single node\n//\n// You need Material Maker - https://rodzilla.itch.io/material-maker\n// And my library - https://github.com/paulofalcao/MaterialMakerRayMarching\n//\n// The Material Maker source is here\n//    https://github.com/paulofalcao/MaterialMakerRayMarching/blob/main/Examples/pxf002.mms\n// Just copy-paste into Material Maker\n// \n\n\nfloat iq_sdOctahedron( vec3 p, float s){\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n\nvec3 rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o349467_CamY = 2.152000000;\nconst float p_o349467_LookAtX = 0.000000000;\nconst float p_o349467_LookAtY = 0.635000000;\nconst float p_o349467_LookAtZ = 0.000000000;\nconst float p_o349467_CamD = 1.825000000;\nconst float p_o349467_CamZoom = 1.516000000;\nconst float p_o349467_Reflection = 0.200000000;\nconst float p_o349467_Specular = 0.000000000;\nconst float p_o349467_Pow = 64.000000000;\nconst float p_o349467_SunX = 2.500000000;\nconst float p_o349467_SunY = 2.500000000;\nconst float p_o349467_SunZ = 1.000000000;\nconst float p_o349467_AmbLight = 0.250000000;\nconst float p_o349467_AmbOcclusion = 0.502000000;\nconst float p_o349467_Shadow = 1.000000000;\nconst float p_o538946_s = 0.610000000;\nconst float p_o528578_x = 0.000000000;\nconst float p_o528578_y = 1.030000000;\nconst float p_o528578_z = 0.000000000;\nconst float p_o492884_r = 2.514000000;\nconst float p_o492884_x = 0.024000000;\n\nfloat o360551_input_obj3d(vec3 p) {\n    float o492884_0_1_sdf3d = iq_sdOctahedron((p),p_o492884_r)-p_o492884_x;\n    return o492884_0_1_sdf3d;\n}\n\nconst float p_o391263_smooth = 0.000000000;\nconst float p_o373061_x = 1.000000000;\nconst float p_o373061_y = 1.000000000;\nconst float p_o373061_z = 1.000000000;\nconst float p_o382957_xyz = 0.452000000;\nconst float p_o382957_x = 1.000000000;\nconst float p_o382957_y = 1.000000000;\nconst float p_o382957_z = 1.000000000;\n\n\nvec4 o360551_input_trans3d(vec4 p) {\n    vec4 o370386_0_1_v4v4 = (vec4(rotate3d((vec4((vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).w)).xyz/vec3(p_o382957_x, p_o382957_y, p_o382957_z)/p_o382957_xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).w)).w)).xyz, -vec3((sin(iTime*0.05)*360.0), (sin(iTime*0.07)*360.0), (sin(iTime*0.03)*360.0))*0.01745329251), (vec4((vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).w)).xyz/vec3(p_o382957_x, p_o382957_y, p_o382957_z)/p_o382957_xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).w)).w)).w));\n    vec4 o371615_0_1_v4v4 = o370386_0_1_v4v4;\n    vec4 o_o382957_0=o371615_0_1_v4v4;vec4 o382957_0_1_v4v4 = vec4(o_o382957_0.xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).w)).w/min(min(p_o382957_x, p_o382957_y), p_o382957_z)/p_o382957_xyz);\n    vec4 o373061_0_1_v4v4 = o382957_0_1_v4v4;\n    vec4 o391263_0_1_v4v4 = o373061_0_1_v4v4;\n    return o391263_0_1_v4v4;\n}\n\nfloat for_min_o360551(vec4 p) {\n  float d=o360551_input_obj3d(p.xyz);\n  float m=min(999999.0,d);\n  for(int i=0;i<6;i++){\n    p=o360551_input_trans3d(p);\n\td=o360551_input_obj3d(p.xyz);\n\tm=min(m,d/p.w);\n  }\n  return m;\n}\n\n\nfloat o349467_input_sdf_a(vec3 p) {\n    float o360551_0_1_sdf3d = for_min_o360551(vec4((rotate3d(((((p))/p_o538946_s)-vec3(p_o528578_x, p_o528578_y, p_o528578_z)), -vec3((iTime*21.0), (iTime*27.0), (iTime*23.0))*0.01745329251)),1.0));\n    vec2 o512498_0_1_sdf3dc = vec2(o360551_0_1_sdf3d, 0.0);\n    vec2 o528578_0_1_sdf3dc = o512498_0_1_sdf3dc;\n    vec2 o538946_0_in = o528578_0_1_sdf3dc;vec2 o538946_0_1_sdf3dc = vec2(o538946_0_in.x*p_o538946_s, o538946_0_in.y);\n    return (o538946_0_1_sdf3dc).x;\n    }\n\nvec3 o349467_input_tex3d_a(vec4 p) {\n    return vec3(1.0,0.1,0.1);\n}\n\nfloat o349467_input_sdf_b(vec3 p) {\n    return max((p).y+1.0,length(vec3((p).x,(p).y+1.0,(p).z))-10.0);\n}\n\nvec3 o349467_input_tex3d_b(vec4 p) {\n    return vec3(mod(floor((p).x*2.0)+floor((p).z*2.0),2.0))*0.9+0.1;\n}\n\nvec3 o349467_input_hdri(vec2 uv) {\n    return Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o349467_SunX,p_o349467_SunY,-p_o349467_SunZ)));\n}\n\nvec2 input_o349467(vec3 p) {\n    float sdfa=o349467_input_sdf_a(p);\n\tfloat sdfb=o349467_input_sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o349467(vec3 p){  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=input_o349467(p+e.xyy).x;\n  float v2=input_o349467(p+e.yyx).x;\n  float v3=input_o349467(p+e.yxy).x;\n  float v4=input_o349467(p+e.xxx).x;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o349467(inout float d,inout vec3 p,inout vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = input_o349467(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o349467( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = input_o349467( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o349467( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = input_o349467( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o349467(vec2 uv) {\n    uv-=0.5;\n\tvec3 cam=vec3((sin(sin(iTime*0.2)*0.5+0.5)*4.0),p_o349467_CamY,(sin(sin(iTime*0.3)*0.5+0.5)*4.0))*p_o349467_CamZoom;\n\tvec3 lookat=vec3(p_o349467_LookAtX,p_o349467_LookAtY,p_o349467_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o349467_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_o349467(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=(dS.y<0.5)?o349467_input_tex3d_a(vec4(p,1.0)):o349467_input_tex3d_b(vec4(p,1.0));\n\tvec3 light=normalize(vec3(p_o349467_SunX,p_o349467_SunY,p_o349467_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o349467(p);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o349467(p,n),p_o349467_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o349467(p,light,0.05,5.0),p_o349467_Shadow);\n\t\tcolor=min(vec3(max(shadow,p_o349467_AmbLight)),max(l,p_o349467_AmbLight))*max(cAO,p_o349467_AmbLight)*objColor+pow(r,p_o349467_Pow)*p_o349467_Specular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o349467(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?o349467_input_tex3d_a(vec4(p,1.0)):o349467_input_tex3d_b(vec4(p,1.0));\n\t\t\tn=normal_o349467(p);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o349467_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o349467_input_hdri(equirectangularMap(ref.xzy)).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,p_o349467_Reflection);\n\t} else {\n\t\tcolor=o349467_input_hdri(equirectangularMap(rd.xzy)).xyz;\n\t}\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float minSize = min(iResolution.x, iResolution.y);\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 o349467_0_1_rgb = raymarch_o349467((UV));\n    fragColor = vec4(o349467_0_1_rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1096, 1096, 1136, 1136, 1416], [1419, 1419, 1450, 1450, 1754], [1786, 1786, 1821, 1821, 1910], [1934, 2008, 2043, 2043, 2160], [2162, 2162, 2195, 2195, 2491], [2493, 2493, 2529, 2529, 2736], [2738, 2738, 2773, 2773, 2982], [2984, 2984, 3021, 3021, 3110], [3112, 3112, 3162, 3162, 3709], [3711, 3711, 3759, 3759, 4029], [4950, 4950, 4985, 4985, 5093], [5416, 5416, 5452, 5452, 6944], [6946, 6946, 6977, 6977, 7164], [7167, 7167, 7202, 7202, 7671], [7673, 7673, 7709, 7709, 7741], [7743, 7743, 7778, 7778, 7848], [7850, 7850, 7886, 7886, 7957], [7959, 7959, 7993, 7993, 8122], [8124, 8124, 8152, 8152, 8312], [8314, 8390, 8418, 8418, 8672], [8674, 8674, 8753, 8753, 8916], [8918, 8963, 9012, 9012, 9280], [9282, 9327, 9411, 9411, 9729], [9731, 9731, 9763, 9763, 11445], [11447, 11447, 11502, 11502, 11759]]}
{"id": "fsSSzG", "name": "Apply General SDF to Ellipse", "author": "IWBTShyGuy", "description": "Benchmark for general SDF ([url]https://www.shadertoy.com/view/fsBXRG[/url]) by applying to ellipse.\nIn this case, there is already a shader that uses the same idea and seeks to be more efficient ([url]https://www.shadertoy.com/view/4lsXDN[/url]).", "tags": ["sdf"], "likes": 4, "viewed": 287, "published": 3, "date": "1620418671", "time_retrieved": "2024-07-30T19:21:21.485984", "image_code": "// The MIT License\n// Copyright © 2021 IWBTShyGuy\n\nconst int DIV = 50;\nconst int BISECTIONMAX = 10;\n\nconst float PARAM_MIN = -3.141592653;\nconst float PARAM_MAX = 3.141592653;\n\nvec2 curve(in float t, in vec2 ab) {\n    return vec2(ab.x * cos(t), ab.y * sin(t));\n}\n\nvec2 derive(in float t, in vec2 ab) {\n    return vec2(-ab.x * sin(t), ab.y * cos(t));\n}\n\n// Roughly find the parameter hint that minimizes the distance between p and curve(hint).\nfloat rough(in vec2 p, in vec2 ab) {\n    float hint = 0.0, mdist = 10.0;\n    for (int i = 0; i <= DIV; i++) {\n        float t = (PARAM_MAX - PARAM_MIN) * float(i) / float(DIV) + PARAM_MIN;\n        float dist = distance(curve(t, ab), p);\n        mdist = min(dist, mdist);\n        hint = t + sign(dist - mdist) * (hint - t);\n    }\n    return hint;\n}\n\n// Find the critical parameter t of the signed distance between p and curve(t) by the bisection method.\nfloat precise(in vec2 p, in vec2 ab) {\n    float hint = rough(p, ab);\n    float t0 = hint - (PARAM_MAX - PARAM_MIN) / float(DIV);\n    float t1 = hint + (PARAM_MAX - PARAM_MIN) / float(DIV);\n    for (int _i = 0; _i < BISECTIONMAX; _i++) {\n        float f0 = dot(derive(t0, ab), curve(t0, ab) - p);\n        float t = (t0 + t1) / 2.0;\n        float f = dot(derive(t, ab), curve(t, ab) - p);\n        t0 = t0 + max(sign(f * f0), 0.0) * (t - t0);\n        t1 = t1 - min(sign(f * f0), 0.0) * (t - t1);\n    }\n    return (t0 + t1) / 2.0;\n}\n\nfloat sdEllipse(in vec2 p, in vec2 ab) {\n    float t = precise(p, ab);\n    vec2 c = curve(t, ab);\n    vec2 d = derive(t, ab);\n    float s = sign((p.x - c.x) * d.y - (p.y - c.y) * d.x);\n    return s * distance(p, c);\n}\n\n// same mainImage as https://www.shadertoy.com/view/4sS3zz\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n\tm.x *= iResolution.x/iResolution.y;\n\t\n \tfloat d = sdEllipse( uv, vec2(0.6,1.0)*m + vec2(0.4,0.2) );\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n\n\tfragColor = vec4( col, 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSSzG.jpg", "access": "api", "license": "mit", "functions": [[178, 178, 214, 214, 263], [265, 265, 302, 302, 352], [354, 444, 480, 480, 791], [793, 897, 935, 935, 1426], [1428, 1428, 1468, 1468, 1645], [1647, 1706, 1763, 1763, 2217]]}
{"id": "fsBXRG", "name": "General SDF for C1 Curve", "author": "IWBTShyGuy", "description": "This method can be applied in many cases. If the curve is too complicated, it may fail.\nIt may not be applied to SDFs of 3D surfaces; the computational cost is too high to be applied to raymarching.", "tags": ["sdf"], "likes": 2, "viewed": 435, "published": 3, "date": "1620417165", "time_retrieved": "2024-07-30T19:21:22.321749", "image_code": "// The MIT License\n// Copyright © 2021 IWBTShyGuy\n\nconst int DIV = 100;\nconst int BISECTIONMAX = 10;\n\nconst float PARAM_MIN = -3.0;\nconst float PARAM_MAX = 3.0;\n\nvec2 curve(in float t) {\n    float a[4] = float[](0.0, 2.0 * sin(iTime), 0.0, 0.0);\n    float b[4] = float[](0.0, 2.0 * sin(iTime), 0.0, 1.0);\n    return vec2(\n        a[0] + a[1] * t + a[2] * t * t + a[3] * t * t * t,\n        b[0] + b[1] * t + b[2] * t * t + b[3] * t * t * t\n    );\n}\n\nvec2 derive(in float t) {\n    float a[4] = float[](0.0, 2.0 * sin(iTime), 0.0, 0.0);\n    float b[4] = float[](0.0, 2.0 * sin(iTime), 0.0, 1.0);\n    return vec2(\n        a[1] + 2.0 * a[2] * t  + 3.0 * a[3] * t * t,\n        b[1] + 2.0 * b[2] * t  + 3.0 * b[3] * t * t\n    );\n}\n\n// Roughly find the parameter hint that minimizes the distance between p and curve(hint).\nfloat rough(in vec2 p) {\n    float hint = 0.0, mdist = 10.0;\n    for (int i = 0; i <= DIV; i++) {\n        float t = (PARAM_MAX - PARAM_MIN) * float(i) / float(DIV) + PARAM_MIN;\n        float dist = distance(curve(t), p);\n        mdist = min(dist, mdist);\n        hint = t + sign(dist - mdist) * (hint - t);\n    }\n    return hint;\n}\n\n// Find the critical parameter t of the signed distance between p and curve(t).\nfloat precise(in vec2 p) {\n    float hint = rough(p);\n    float t0 = hint - (PARAM_MAX - PARAM_MIN) / float(DIV);\n    float t1 = hint + (PARAM_MAX - PARAM_MIN) / float(DIV);\n    for (int _i = 0; _i < BISECTIONMAX; _i++) {\n        float f0 = dot(derive(t0), curve(t0) - p);\n        float t = (t0 + t1) / 2.0;\n        float f = dot(derive(t), curve(t) - p);\n        t0 = t0 + max(sign(f * f0), 0.0) * (t - t0);\n        t1 = t1 - min(sign(f * f0), 0.0) * (t - t1);\n    }\n    return (t0 + t1) / 2.0;\n}\n\nfloat sdf(in vec2 p) {\n    float t = precise(p);\n    vec2 c = curve(t);\n    vec2 d = derive(t);\n    float s = sign((p.x - c.x) * d.y - (p.y - c.y) * d.x);\n    return s * distance(p, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (4.0 * fragCoord - 2.0 * iResolution.xy) / iResolution.y;\n    float d = sdf(uv) / 2.0;\n\n    // iq's SDF coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBXRG.jpg", "access": "api", "license": "mit", "functions": [[726, 816, 840, 840, 1147], [1149, 1229, 1255, 1255, 1726], [1728, 1728, 1750, 1750, 1915], [1917, 1917, 1972, 1972, 2316]]}
{"id": "NdSSRG", "name": "Beat  spiral", "author": "NikolaErceg", "description": "variation of \"twisting rose\"", "tags": ["procedural", "spiral", "illusion", "glitch", "hypnotic", "polar", "colordistortion"], "likes": 3, "viewed": 354, "published": 3, "date": "1620411368", "time_retrieved": "2024-07-30T19:21:23.069749", "image_code": "#define SPEED 12.0\n\n#define RAYS 12.0\n\n#define RING_PERIOD 129.0\n\n#define TWIST_FACTOR 0.72\n\nfloat getColorComponent(float dist, float angle) {\n    return\n        pow((\n            (\n            \tcos(\n                    (angle * RAYS)\n            \t\t+ pow(\n                        dist * 0.79,\n                \t\t(sin(iTime * SPEED) * TWIST_FACTOR)\n            \t\t) * 3.0\n        \t\t) + sin(\n            \t\tdist * RING_PERIOD\n        \t\t)\n        \t) + 1.6\n        ) / 2.0, 3.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 delta = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    float dist = length(delta),\n    angle = atan(delta.x, delta.y);\n    fragColor = vec4(\n        getColorComponent(dist, angle),\n        getColorComponent(dist * 0.0005, angle),        \n        getColorComponent(dist * 0.07, angle),\n        5.0\n    );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSSRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 143, 143, 475], [477, 477, 532, 532, 854]]}
{"id": "ssjXWm", "name": "fibonacci sphere", "author": "elenzil", "description": "ran across [url=https://stackoverflow.com/a/26127012]this[/url] and wanted to try it out.\nsky from @Gijs's [url=https://www.shadertoy.com/view/7dSSzy]Basic : Less Simple Atmosphere[/url].", "tags": ["fibonacci"], "likes": 13, "viewed": 940, "published": 3, "date": "1620408566", "time_retrieved": "2024-07-30T19:21:24.003253", "image_code": "// sky from @Gijs's [url=https://www.shadertoy.com/view/7dSSzy]Basic : Less Simple Atmosphere[/url].\n\n// Fork of \"mirascope\" by elenzil. https://shadertoy.com/view/NdjXzw\n// 2021-05-07 16:22:59\n\n\n\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nbool gDemoView  = false;\nconst bool gDebugView = false;\nmat2 gSceneRot  = mat2(1.0, 0.0, 0.0, 1.0);\nconst float gutter = 0.175;\nconst float gutterInv = 1.0 - gutter;\n\n// positive for cross-eyed, make negative for wall-eyed viewing.\nconst float stereoSeparation = 0.4;\n\nstruct pol3 {\n    float rho;\n    float tht;\n    float phi;\n};\n\npol3 sphericalFromCartesian(in vec3 cartesian) {\n    pol3 ret;\n\n    ret.tht = atan(cartesian.z, cartesian.x);\n    ret.phi = acos(dot(normalize(cartesian), vec3(0.0, 1.0, 0.0))) - PI/2.0;\n    ret.rho = length(cartesian);\n\n    return ret;\n}\n\nfloat maxPart(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\n//--------------------------------------------------------------------------------\n\n// direction to the light\nvec3 gLightDirection = normalize(vec3(-1.0, 2.0, 0.5));\n\n//--------------------------------------------------------------------------------\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(-pos.y, 0.0)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(vec3 dir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, gLightDirection),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(vec3 p, vec3 d)\n{\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d) * transmittance(l);\n    float f = 1.0 - d.y / gLightDirection.y;\n    float l2 = atmosphereDepth(p, gLightDirection);\n    vec3 sk = simple_sun(gLightDirection) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return sun + sk;\n}\n\n//--------------------------------------------------------------------------------\n\n// I forget the location, but this pattern is from IQ.\n\nvec2 opUnion(in vec2 q1, in vec2 q2) {\n    return q1.x < q2.x ? q1 : q2;\n}\n\nvec2 opSubtraction(in vec2 q1, in vec2 q2) {\n    return -q1.x > q2.x ? vec2(-q1.x, q1.y) : q2;\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n// swap args from stock subtraction().\nvec2 opMinus( in vec2 q1, in vec2 q2 ) { return opSubtraction(q2, q1); }\n\n//--------------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, float r )\n{\n  return length(p.xz) - r;\n}\n\nfloat sdSlab(in vec3 p, float r) {\n    return abs(p.y) - r;\n}\n\nfloat sdCappedCylinderPrecomputedQ(vec2 q, float h, float r)\n{\n  vec2 d = abs(q) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCrateBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdParabola( in vec2 pos, in float k )\n{\n    pos.x = abs(pos.x);\n    \n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    \n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n\n    float x = (h>0.0) ? \n        // 1 root\n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        // 3 roots\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    \n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat sdSphere( in vec3 pos, in float r ) {\n    return length(pos) - r;\n}\n\n\nfloat sdMiraScope(in vec3 pos, in float separation, in float thickness, in float holeRadius) {\n    // convert pos to 2D by revolving it around Y\n    vec2 p = vec2(length(pos.xz), pos.y);\n\n    // an up and down facing parabola, a little apart\n    float sdTop = sdParabola(vec2(p.x, p.y + separation),  0.5);\n    float sdBot = sdParabola(vec2(p.x, p.y - separation), -0.5);\n\n    // intersected\n    float sdMira = max(sdTop, sdBot);\n\n    // onioned\n    sdMira = abs(sdMira) - thickness;\n\n    // slice off the top so we can see inside!\n    // sdMira = max(sdMira, p.y - separation * 0.9);\n    \n    // cut a hole in the top so we can see inside!\n    // this has somewhat less visibility into the interior compared to slicing,\n    // but avoids long thin wedges.\n    sdMira = opSubtraction(sdCappedCylinderPrecomputedQ(vec2(p.x, p.y - separation + thickness), holeRadius, separation * 0.2 + thickness * 3.0), sdMira);\n\n    return sdMira;\n}\n\n\nfloat sdGridOfSpheres(in vec3 pos) {\n    float num = 3.0;\n    float lim = 0.3;\n    float rad = 0.75 * lim / (num - 1.0);\n     \n    pos.y -= lim + rad - 0.4;\n    \n    float step = (lim * 2.0) / (num - 1.0);\n    \n    float d = 1e9;\n    \n    vec3 c = vec3(0.0);\n    \n    for (c.x = -lim; c.x <= lim; c.x += step) {\n    for (c.y = -lim; c.y <= lim; c.y += step) {\n    for (c.z = -lim; c.z <= lim; c.z += step) {\n        d = min(d, sdSphere(pos - c, rad));\n    }}}\n    return d;\n}\n\n/*\nfrom https://stackoverflow.com/a/26127012\ndef fibonacci_sphere(samples=1):\n\n    points = []\n    phi = math.pi * (3. - math.sqrt(5.))  # golden angle in radians\n\n    for i in range(samples):\n        y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n        radius = math.sqrt(1 - y * y)  # radius at y\n\n        theta = phi * i  # golden angle increment\n\n        x = math.cos(theta) * radius\n        z = math.sin(theta) * radius\n\n        points.append((x, y, z))\n\n    return points\n*/\nfloat sdFibSphere(in vec3 pos, in float rad1, in float rad2) {\n\n    float d = 1e9;\n    \n    // early-out.\n    // this approach to bounding volume destroys exactness of SDF.\n    // discussion in https://www.shadertoy.com/view/ssBXRG\n    float sdBounds = abs(sdSphere(pos, rad1)) - rad2;\n    if (sdBounds > rad2 * 0.2) {\n        return sdBounds;\n    }\n\n    // golden angle\n    const float phi = 3.14159265359 * (3.0 - sqrt(5.0));\n    \n    const float num           = 50.0;\n    const float num_minus_one = num - 1.0;\n    \n    for (float n = 0.0; n < num; ++n) {\n        // y goes from 1 to -1\n        float y = 1.0 - (n / num_minus_one * 2.0);\n        \n        // radius at y\n        float radius = sqrt(1.0 - y * y);\n        \n        // shrink the ones near the top\n        float rad2Fac = smoothstep(1.0, 0.0, abs(y)) * 0.4 + 0.6;\n        \n        float theta = phi * n;\n        \n        float x = cos(theta) * radius;\n        float z = sin(theta) * radius;\n        \n        d = min(d, sdSphere(pos - vec3(x, y, z) * rad1, rad2 * rad2Fac));\n    }\n    \n    return d;\n}\n    \n\nfloat sdTheMainAttraction(in vec3 pos) {\n    return sdFibSphere(pos, 0.6, 0.1);\n}\n\n//-----------------------------------------------------------------------\n\n\n// set up scene position of stuff once per pixel\nconst float gBevels        = 0.01;\n\nvec3  gCamPos;\nvec3  gPosMain;\nvec3  gTablePos;\nfloat gTableRad;\nfloat gTableThick;\nfloat gTableHoleRad;\n\nvoid configMap() {\n \n    gPosMain      = vec3(0.0, 0.3, 0.0);\n    \n    gTablePos     = vec3(0.0, -0.4, 0.0);\n    \n    float tableMod = smoothstep(1.0, -2.0, gCamPos.y - gTablePos.y);\n    gTableRad     = 0.9;\n    gTableThick   = 0.01 + 0.6 * tableMod;\n    gTablePos.y   += 0.6 * tableMod;\n    gTableHoleRad = (gTableRad - gBevels * 2.0) * tableMod;\n}\n\n// return.x = distance\n// return.y = material\nvec2 map(in vec3 p) {\n\n\n    p.xz *= gSceneRot;\n\n    vec2 Q  = vec2(1e9, 0.0);\n    const float modSize = 0.3;\n    vec3 p1 = vec3(p.x, mod(p.y + modSize / 2.0, modSize) - modSize / 2.0, p.z);\n\n    \n    // table\n    Q = opUnion(Q, vec2(sdCappedCylinder(p    -       gTablePos, gTableRad, gTableThick), 3.0));    \n    Q = opMinus(Q, vec2(sdCylinder(p, gTableHoleRad), 3.0));\n    Q = opMinus(Q, vec2(sdSlab(p1, 0.05), 3.0));\n    Q.x -= gBevels;\n    \n    Q = opUnion(Q, vec2(sdTheMainAttraction(p - gPosMain), 1.0));\n    Q = opUnion(Q, vec2(sdSphere(p - gPosMain, 0.2), 3.0));\n\n\n    return Q;\n}\n\nconst float closeEps = 0.001;\n\nvec2 march(in vec3 ro, in vec3 rd) {\n    const int maxSteps = 100;\n\n    vec2 Q = vec2(1e9);\n\n    vec3 p = ro;\n    float t = 0.0;\n    for (int n = 1; n <= maxSteps; ++n) {\n        Q = map(ro + rd * t);\n        float closeEnoughEps = (n == maxSteps ? 0.2 : closeEps);\n        if (Q.x < closeEnoughEps) {\n            return vec2(t, Q.y);\n        }\n        t += Q.x;\n        if (t > 200.0) {\n            return vec2(t, Q.y);\n        }\n    }\n    return vec2(t, Q.y);\n}\n\n\n// IQ: https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.002;      // replace by an appropriate value\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * map(p + e*h).x;\n    }\n    return normalize(n);\n}\n\n\nfloat calcDiffuseAmount(in vec3 p, in vec3 n) {\n    return clamp(dot(n, gLightDirection), 0.0, 1.0);\n}\n\nconst float AOFactorMin = 0.5;\nconst float AOFactorMax = 1.0;\nfloat calcAOFactor(in vec3 p, in vec3 n) {\n    const float sampleDist = 0.03;\n    float dist = smoothstep(0.0, sampleDist, map(p + n * sampleDist).x);\n    return mix(AOFactorMin, AOFactorMax, (dist));\n}\n\nfloat calcShadowLight(in vec3 p) {\n    float t = march(p, gLightDirection).x;\n    return t > 40.0 ? 1.0 : 0.0;\n}\n\nvec3 dirToRGB(in vec3 rd) {\n    float tht = atan(rd.z, rd.x);\n    float phi = acos(dot(normalize(rd), vec3(0.0, 1.0, 0.0)));\n    vec3 col = rd * 0.5 + 0.5;\n    col *= smoothstep(0.002, -0.002, sin(tht       * 4.0)) * -0.3 + 1.0;\n    col *= smoothstep(0.002, -0.002, sin(phi * 2.0 * 4.0)) * -0.3 + 1.0;\n    col = mix(col, col / max(col.r, max(col.g, col.b)), 0.2);\n    return col;\n}\n\nvec3 dirToRGB2(in vec3 rd) {\n    vec3 col = rd * 0.5 + 0.5;\n    return col;\n}\n\nvec3 sky(in vec3 rd) {\n    vec3 col = dirToRGB(rd);\n//  col = normalize(col);\n    col = col * 0.3;\n    vec3 ss = simple_sky(vec3(0.0, -0.3, 0.0), vec3(rd.x, rd.y, rd.z));\n    col = mix(col, ss, 0.5);    \n    col *= smoothstep(-0.01, 0.01, rd.y + 0.03) * 0.5 + 0.5;\n    return col;\n}\n\nvec3 getAlbedo(in int material, in vec3 pCrt, in pol3 pPol) {\n    if (material == 1) {\n        vec3 rgb = dirToRGB2(normalize(pCrt - gPosMain));\n       rgb /= length(rgb);\n        return rgb;\n    }\n    else if (material == 3) {\n        return vec3(0.2);\n    }\n    else {\n        return vec3(1e9, 0.0, 1e9);\n    }\n}\n\nvec3 getReflectivity(in int material, in vec3 pCrt, in pol3 pPol) {\n    if (material == 1) {\n        return vec3(0.2);\n    }\n    else if (material == 2) {\n        return vec3(0.0);\n    }\n    else if (material == 3) {\n        return vec3(0.2);\n    }\n    else {\n        return vec3(0.0, 1e9, 0.0);\n    }\n}\n\nvec3 getEmissive(in int material, in vec3 pCrt, in pol3 pPol) {\n    return vec3(0.0);\n}\n\n\n//------------------------------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 rgb = vec3(0.0);\n\n    int bouncesLeft = 4;\n\n    vec3 contributionLeft = vec3(1.0);\n\n    while (bouncesLeft >= 0 && maxPart(contributionLeft) > 0.001) {\n        bouncesLeft -= 1;\n        vec2 q = march(ro, rd);\n        vec3 p = ro + q.x * rd;\n        if (length(p) > 150.0) {\n            rgb += sky(rd) * contributionLeft;\n            break;\n        }\n\n        vec3 normal = calcNormal(p);\n\n        vec3 ptCrt = p;\n        ptCrt.xz *= gSceneRot;\n        pol3 ptSph = sphericalFromCartesian(ptCrt);\n\n        int material = int(q.y);\n\n        float incomingLight = 1.0;\n        incomingLight = min(incomingLight, calcDiffuseAmount(p, normal));\n        if (incomingLight > 0.0) {\n            incomingLight = min(incomingLight, calcShadowLight(p + normal * closeEps * 2.0));\n        }\n        float ambient = 0.2 * calcAOFactor(p, normal);\n        incomingLight += ambient;\n\n        float fres = 0.4 + 0.8 * clamp(pow(1.0 - abs(dot(rd, normal) - 0.1), 2.0), 0.0, 1.0);\n        \n        fres = 1.0;\n\n        vec3 reflectivity = fres * getReflectivity(material, ptCrt, ptSph);\n        vec3 diffuse = incomingLight * getAlbedo(material, ptCrt, ptSph);\n        vec3 emissive = getEmissive(material, ptCrt, ptSph);\n        \n        rgb += diffuse * (1.0 - reflectivity) * contributionLeft;\n        rgb += emissive * contributionLeft;\n        contributionLeft *= reflectivity;\n          \n        ro = p + normal * 0.05;\n        rd = reflect(rd, normal);\n    }\n\n    return rgb;\n}\n\n\n\nvoid mainImage( out vec4 RGBA, in vec2 XY ) {\n    vec4 persistedInfo = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    bool stereo = iMouse.x < iResolution.x * gutter && iMouse.y > iResolution.y * gutterInv;\n    bool leftEye = XY.x > iResolution.x / 2.0;\n    \n    vec2 Res = iResolution.xy;\n    Res.x   *= stereo ? 0.5 : 1.0;\n    XY.x    -= (stereo && leftEye) ? iResolution.x / 2.0 : 0.0;\n\n    setupCoords(Res, 4.2);\n    setupTime(iTime);\n    vec2  uv        = worldFromScreen(XY);\n    vec2  ms        = persistedInfo.xy / iResolution.xy * 2.0 - 1.0;\n    float smoothEps = gWorldFromScreenFac * 2.0;\n\n    // look-from and look-to points\n    // right-handed system where x is right, y is up, z is forward.\n    float t = gTime * 0.23;\n    vec3 trgPt = vec3(0.0, 0.1, 0.0);\n    \n    float camTht = -ms.x * PI * 1.25;\n    float camPhi = ms.y;\n    \n    bool defaultView = stereo;\n //   gDebugView      = !defaultView && (length(iMouse.xy) < iResolution.x * gutter);\n    if (gDebugView) {\n        camTht = sin(iTime * 0.10) * 0.1;\n        camPhi = sin(iTime * 0.12) * 0.1;\n    }\n    else if (defaultView) {\n        camPhi = -20.0 * DEG2RAD;\n    }\n    \n    mat2 camThtRot2 = rot2(camTht);\n    mat2 camPhiRot2 = rot2(camPhi);\n    \n    gDemoView = gDebugView || iMouse.x > iResolution.x * gutterInv;\n    \n    gSceneRot = rot2(gTime * PI * 2.0 / 30.0);\n    // anchor the light to the camera\n    gLightDirection.xz *= -camThtRot2;\n\n    \n    vec3 camPt = vec3(0.0, 0.0, -1.0);\n    camPt.yz *= camPhiRot2;\n    camPt.xz *= camThtRot2;\n    camPt *= gDebugView ? 1.7 : 4.0;\n    \n    // camera's forward, right, and up vectors. right-handed.\n    vec3 camFw = normalize(trgPt - camPt);\n    vec3 camRt = normalize(cross(camFw, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = cross(camRt, camFw);\n    \n    if (stereo) {\n        camPt += camRt * (leftEye ? -1.0 : 1.0) * stereoSeparation / 2.0;\n        camFw = normalize(trgPt - camPt);\n        camRt = normalize(cross(camFw, vec3(0.0, 1.0, 0.0)));\n        camUp = cross(camRt, camFw);\n    }\n    \n    gCamPos = camPt;\n    configMap();\n\n    // ray origin and direction\n    vec3 ro    = camPt;\n    vec3 rd    = normalize(camFw + uv.x * camRt + uv.y * camUp);\n\n    vec3 rgb = render(ro, rd);\n\n    // Vignette from Ippokratis https://www.shadertoy.com/view/lsKSWR\n\tvec2 pq = XY / Res;   \n    pq *=  1.0 - pq.yx;    \n    float vig = pq.x*pq.y * 200.0;    \n    vig = pow(vig, 0.15);\n    rgb *= vig;\n\n    rgb = sqrt(rgb);\n\n    RGBA = vec4(rgb, 1.0);\n}\n\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    if (iFrame < 1) {\n        RGBA = vec4(iResolution.x/2.0, iResolution.y/3.0, -1e9, 0.0);\n        return;\n    }\n\n    ivec2 IJ = ivec2(XY);\n    \n    if (IJ != ivec2(0)) {\n        RGBA = vec4(0.0);\n        return;\n    }\n\n    // data.xy = use this as mouse point, other buffers.\n    // data.zw = actual last mouse position, if mouse was down. else -1e9.\n \n    vec4 data = texelFetch(iChannel0, IJ, 0);\n     \n     \n    bool prevMouseDown = data.z   >  0.0;\n    bool currMouseDown = iMouse.z >  0.0;\n     \n    vec2 prevMp = prevMouseDown ? data.zw : iMouse.xy;\n    data.xy += iMouse.xy - prevMp;\n    data.y = clamp(data.y, iResolution.y * -0.25, iResolution.y * 1.25);\n    data.zw = currMouseDown ? iMouse.xy : vec2(-1.0);\n     \n    \n    RGBA = data;\n}\n\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n\n\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Fork of \"boilerplate stuff\" by elenzil. https://shadertoy.com/view/7dX3R2\n// 2021-04-05 18:18:15\n\nconst float PI      = 3.14159265359;\nconst float TAO     = PI * 2.0;\nconst float DEG2RAD = TAO / 360.0;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\n\n\n// to prevent loop-unrolling\n#define ZERO (min(0, int(iFrame)))\n\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[576, 576, 624, 624, 814], [816, 816, 839, 839, 877], [1471, 1471, 1514, 1514, 1562], [1564, 1564, 1593, 1593, 1632], [1634, 1634, 1661, 1745, 1942], [1944, 1944, 1977, 1977, 2279], [2421, 2421, 2459, 2459, 2495], [2497, 2497, 2541, 2541, 2593], [2595, 2595, 2632, 2632, 2653], [2655, 2655, 2698, 2698, 2720], [2722, 2722, 2766, 2766, 2787], [2789, 2828, 2868, 2868, 2900], [2986, 3035, 3087, 3087, 3194], [3196, 3196, 3233, 3233, 3262], [3264, 3264, 3298, 3298, 3325], [3327, 3327, 3389, 3389, 3475], [3477, 3526, 3571, 3571, 3858], [3862, 3911, 3956, 3956, 4363], [4365, 4365, 4408, 4408, 4438], [4441, 4441, 4535, 4585, 5374], [5377, 5377, 5413, 5413, 5852], [5854, 6350, 6412, 6412, 7416], [7423, 7423, 7463, 7463, 7504], [7773, 7773, 7791, 7791, 8122], [8124, 8170, 8191, 8191, 8758], [8791, 8791, 8827, 8827, 9254], [9257, 9307, 9358, 9358, 9626], [9629, 9629, 9676, 9676, 9731], [9795, 9795, 9837, 9837, 9997], [9999, 9999, 10033, 10033, 10111], [10113, 10113, 10140, 10140, 10494], [10496, 10496, 10524, 10524, 10573], [10575, 10575, 10597, 10597, 10857], [10859, 10859, 10920, 10920, 11173], [11175, 11175, 11242, 11242, 11478], [11480, 11480, 11543, 11543, 11567], [11652, 11652, 11689, 11689, 13166], [13170, 13170, 13215, 13215, 15636]]}
{"id": "fd2XW1", "name": "getErraticWave", "author": "TestCoder", "description": "https://www.desmos.com/calculator/u5zfwind97?lang=es", "tags": ["wave", "time", "pattern"], "likes": 2, "viewed": 243, "published": 3, "date": "1620401405", "time_retrieved": "2024-07-30T19:21:24.832037", "image_code": "float cbrt(float number) {\n    return pow(abs(number), 1. / 3.);\n}\n\nfloat getErraticWave(float number) {\n    float scale = 1.;\n\n    return (\n        cbrt(sin(number))\n      + pow(\n          sin(\n              number + iTime / 3.\n          ),\n          3.\n        )\n    ) / scale;\n}\n\nvec3 getErraticPattern(float x, float y, vec2 uv) {\n    float stretch = 2.;\n    float mainDance = getErraticWave(\n        getErraticWave(uv.y + uv.x)\n      + getErraticWave(uv.y + -uv.x)\n      + getErraticWave(-uv.y + uv.x)\n      + getErraticWave(-uv.y + -uv.x)\n    );\n\n    return (\n        getErraticWave(\n            x\n        ) + getErraticWave(\n            y\n        )\n    ) * stretch * (1. - vec3(\n        mainDance * (\n            sin(\n                iTime / 20. + .5\n            ) + 1.\n        )\n    ,\n        mainDance * (\n            sin(\n                iTime / 4. + .25\n            ) + .5\n        )\n    ,\n        mainDance * (\n            sin(\n                iTime / 4. + 1.\n            ) + .25\n        ) + mainDance\n    ));\n}\n\n#define A .205          // Animation speed factor\n#define B 10          // Fractal iterations\n#define C 9             // Fractal sequence length\n#define D 20      // Array size for weights\n#define E 0.97          // Weight base value\n#define F 0.3028         // Weight oscillation amplitude\n#define G .001         // Weight phase offset\n#define H 0.496          // Weight oscillation speed\n#define I 1.4900  // X update factor\n#define J 4.14159265    // Pi constant\n#define K 0.8           // Color shift red\n#define L 0.55          // Color shift green\n#define M 0.00330       // Color shift blue\n#define N 0.74          // Color shift speed\n#define O 0.5           // Color component base\n#define P 0.3           // Color2 red offset\n#define Q 0.33          // Color2 green offset\n\nprecision highp float;\n#define ANIMATION_SPEED_FACTOR A\n#define FRACTAL_ITERATIONS B\n#define FRACTAL_SEQUENCE_LENGTH C\nint fractalSequence[] = int[C](0, 0, 1, 0, 0, 0, 1, 1, 1);\nvec3 computeColor(vec2 pixelCoordinate) {\n    float currentTime = iTime * A;\n    float weights[D];\n    float x = 0.00000009250;\n    float height = 0.00000920;\n    for (int i = 0; i < D; i++) {\n        weights[i] = E + F * sin(float(i) + G + H * currentTime);\n    }\n    for (int iteration = 0; iteration < B; iteration++) {\n        for (int step = 0; step < C; ++step) {\n            x = weights[step] * pixelCoordinate[fractalSequence[step]] * x * (1.0 - x);\n            height += log2(abs(weights[step] * pixelCoordinate[fractalSequence[step]] * (1.0 - I * x)));\n        }\n    }\n    height /= float(B) * float(C);\n    vec3 colorShift = vec3(K, L, M) + currentTime * N;\n    vec3 color1 = cos((colorShift + -.5 * abs(height)) * J) * O + O;\n    vec3 color2 = vec3(O) + O * sin(vec3(P, Q, P) + 2.5 * abs(height) + currentTime * O);\n    return (height < 0.0) ? mix(color1, color2, pow(abs(height), 13.625)) : vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n\n    uv.x *= iResolution.x/iResolution.y;\n\n    float zoomOut = 10.;\n    \n    vec2 centeredCoordinate = fragCoord - iResolution.xy * 0.5; // Move the fractal center to the screen center\n    vec2 uvColor = computeColor(3.3740 + (1.0 * centeredCoordinate.xy / iResolution.xy)).xy;\n\n    vec3 rgb = (1. - getErraticPattern(\n                uvColor.x, uvColor.y, uvColor * zoomOut\n            ) + getErraticPattern(\n                -uvColor.x, uvColor.y, uvColor * zoomOut\n            ) + getErraticPattern(\n                uvColor.x, -uvColor.y, uvColor * zoomOut\n            ) + getErraticPattern(\n                -uvColor.x, -uvColor.y, uvColor * zoomOut\n            ) );\n    \n    fragColor = vec4(1. - rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 66], [68, 68, 104, 104, 281], [283, 283, 334, 334, 1022], [1986, 1986, 2027, 2027, 2902], [2904, 2904, 2961, 3014, 3770]]}
{"id": "sdjXWw", "name": "NDF: Student-t Anisotropic", "author": "H4w0", "description": "Student-t normal distribution function from Ribardiere et al. (2017) \n[url] https://mribar03.bitbucket.io/projects/eg_2017/ [/url]\n", "tags": ["microfacet", "anisotropic", "ndf", "studentt"], "likes": 9, "viewed": 571, "published": 3, "date": "1620395610", "time_retrieved": "2024-07-30T19:21:25.764544", "image_code": "//=======================================================\n//= Normal Distribution Function : Student-t Anisotropic \n//=======================================================\n//== Slope distributions :\n//== *- Beckmann Isotropic \t : https://www.shadertoy.com/view/WtGXRt\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/WlGXRt\n//== *- GGX Isotropic \t\t : https://www.shadertoy.com/view/WlKXDm\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/3tyXRt\n//== In-Engine ready NDFs:\n//== *- GGX Isotropic \t     : https://www.shadertoy.com/view/flsyWX\n//== *- GGX Anisotropic \t : https://www.shadertoy.com/view/fs2cWw\n//== *- Beckmann Isotropic   : https://www.shadertoy.com/view/fllcWX\n//== *- Beckmann Anisotropic : https://www.shadertoy.com/view/ftsyWX\n//== Related stuff:\n//== *- Student-t Aniso NDF  : https://www.shadertoy.com/view/sdjXWw\n//== *- Specular AA          : https://www.shadertoy.com/view/WssyR7\n//== *- LEADR mapping        : https://www.shadertoy.com/view/WdXfRn\n//=======================================================\n//== Remapping : \n//== *- roughness \t-> alpha = clamp(0.1+uiSlider(0),0.,0.8 )^2;\n//== *- metallic \t-> 0 or 1\n//== *- reflectance used for non-metallic F0 (Filament)\n//==    -> F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n//=======================================================\n//== Implementations details :  \n//== *- Computations are done in tangent space (PBRT-like)\n//== *- Code can be a lot simplified but I wanted a verbose/self-explained code \n//== *- Code could have more checks (non-zero length before normalization, etc.)\n//== *- Fresnel Term uses the Schlick Approximation\n//== *- Equations are written with the lovely style of @valentingalea (https://www.shadertoy.com/view/XtBXDz)\n//== \t( again it's a personal taste :D )\n//=======================================================\n//== I also used some code from :\n//== *- @XT95's \"UI easy to integrate\" on Shadertoy \t  \n//=   \thttps://www.shadertoy.com/view/ldKSDm\t\t\t\t\n//== *- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//==\thttps://www.shadertoy.com/view/4sSSW3\n//== *- @iq's intersectors ( Sphere )\n//== \thttps://iquilezles.org/articles/intersectors\n//=======================================================\n//== Arthur Cavalier\n//=======================================================\n\n/** \n * When gamma is in ]1.5;2.0[  : the distribution lobe is wider than GGX\n * When gamma == 2.0           : the distribution is exactly GGX. \n * When gamma is in ]2.0;+inf[ : the distribution tends to Beckmann.\n **/\nconst float gamma = 1.7; // between ]+1.5;+inf]\n\n\n\n//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst bool  USE_DIFFUSE_TERM = true;\n\nconst vec4  UNIT_SPHERE     = vec4(0.,0.,0.,1.);\nconst float LIGHT_INTENSITY = 2.;\nconst vec3  LIGHT_DIRECTION = normalize(vec3(-0.5,1.5,0.1));\nconst vec3  BACKGROUND_GREY = vec3(0.0);\n\n//-----------------------------------------------------------------------------\n//-- Student-t Distribution ---------------------------------------------------\nfloat ndf_student_t_anisotropic(vec3 omega_h, float alpha_x, float alpha_y, float gamma)\n{\n    float cos_theta = cos_theta(omega_h);\n    if(cos_theta <= 0.)\n        return(0.);\n    float cos_theta_sqr = cos_theta*cos_theta;\n    float exponent = ((omega_h.x*omega_h.x)/(alpha_x*alpha_x) + (omega_h.y*omega_h.y)/(alpha_y*alpha_y)) / cos_theta_sqr;\n    float root = (1.0 + exponent/(gamma-1.0));\n    float pow_root_gamma = pow(root,gamma);\n    return(\n                                        1.0\n    / //--------------------------------------------------------------------------------------\n        (m_pi * alpha_x * alpha_y * cos_theta_sqr * cos_theta_sqr * pow_root_gamma)\n    );\n}\n\n\nfloat lambda_student_t_anisotropic(vec3 omega, float alpha_x, float alpha_y, float gamma)\n{\n    float tan_theta  = tan_theta(omega);\n    if(tan_theta==0.){return 0.;}\n    \n    float cos_phi = cos_phi(omega);\n    float sin_phi = sin_phi(omega);\n    float alpha   = sqrt(cos_phi*cos_phi*alpha_x*alpha_x + sin_phi*sin_phi*alpha_y*alpha_y);\n\n    float root     = alpha * tan_theta;\n    float rootInv  = 1. / root;  \n    float lambda   = 0.; \n\n    float S1 = root * pow(gamma-1.+rootInv*rootInv , 1.5-gamma);\n    float S2 = F_21(rootInv)*F_22(gamma)*F_23(gamma)*F_24(rootInv);\n    float F1 = pow(gamma-1.,gamma) / (2.*gamma-3.);\n    float F2 = Gamma_Approx(gamma-0.5f) / (sqrt(m_pi)*Gamma_Approx(gamma));\n\n    lambda = (S1*F1 + S2*sqrt(gamma-1.))*F2 - 0.5f;\n\n    return( max(lambda,0.) );\n}\n\n//-----------------------------------------------------------------------------\n//-- Fresnel ------------------------------------------------------------------\nvec3 fresnel_schlick(in float wo_dot_wh, in vec3 F0)\n{\n    return F0 + (1. - F0) * pow(1. - wo_dot_wh, 5.);\n}\n\n//-----------------------------------------------------------------------------\n//-- World Functions ----------------------------------------------------------\nfloat \tget_light_intensity()            { return LIGHT_INTENSITY; }\nvec3 \tget_light_direction()            { return LIGHT_DIRECTION; }\nvec3 \tget_background_color(in vec3 rd) { return BACKGROUND_GREY; }\n\n//-----------------------------------------------------------------------------\n//-- UI -----------------------------------------------------------------------\n//-- From XT95's https://www.shadertoy.com/view/ldKSDm\n//-----------------------------------------------------------------------------\nfloat \tuiSlider(int id) {return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy).r;}\nvec3 \tuiColor(int id)\t {return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy).rgb;}\n\n//-----------------------------------------------------------------------------\n//-- Render Functions -----------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3  color         = get_background_color(rd);\n    float sphere_hit    = sphere_get_hit(ro,rd,UNIT_SPHERE);\n    if(sphere_hit > 0.0) \n    {\n        vec3    P = ro + sphere_hit * rd;\n        vec3    L = get_light_direction();\n        vec3    N = sphere_get_normal(P,UNIT_SPHERE);\n        vec3    V = -rd;\n        \n        mat3 TBN    = orthonormal_basis(N);\n        mat3 TBN_t  = transpose(TBN);\n        vec3 wo = normalize(TBN_t * V);\n        vec3 wi = normalize(TBN_t * L);\n        vec3 wg = normalize(TBN_t * N); // ( should be (0,0,1)^t )\n        vec3 wh = normalize(wo+wi);\t\t// ( could check it not zero)\n        \n        float wi_dot_wh = clamp(dot(wi,wh),0.,1.); \t\t// saturate(dot(L,H))\n        float wg_dot_wi = clamp(cos_theta(wi),0.,1.); \t// saturate(dot(N,L))\n                     \n        //-- Filament BRDF parametrization\n        //-- Single scattering\n        //-- diffuse lambertian term + specular term\n        float reflectance \t= clamp(uiSlider(2),0.35,1.); \t// [0.35;1]\n        float metallic \t\t= float(uiSlider(3)>0.5); \t\t// 0. or 1.\n        float roughness_x \t= clamp( 0.1 + uiSlider(0), 0., 0.8);\n        float roughness_y \t= clamp( 0.1 + uiSlider(1), 0., 0.8);\n    \tfloat alpha_x \t\t= roughness_x*roughness_x;\n        float alpha_y \t\t= roughness_y*roughness_y;\n        vec3  base_color    = uiColor(0);\n        vec3 F0 = 0.16*reflectance*reflectance*(1.0-metallic) + base_color*metallic;\n              \n        //-- NDF + G + F\n        float lambda_wo = lambda_student_t_anisotropic(wo,alpha_x,alpha_y,gamma);\n        float lambda_wi = lambda_student_t_anisotropic(wi,alpha_x,alpha_y,gamma);\n        float D = ndf_student_t_anisotropic(wh,alpha_x,alpha_y,gamma);\n        float G = 1. / (1. + lambda_wo + lambda_wi);\n  \n\t\tvec3 F  = fresnel_schlick(wi_dot_wh,F0);\n        \n        //-- Lighting\n        vec3 specular_microfacet = (D * F * G) / ( 4. * cos_theta(wi) * cos_theta(wo) ) ;\n        vec3 diffuse_lambert = m_i_pi*(1.-metallic)*base_color;\n        vec3 diffuse_factor  = vec3(1.0) - F;\n        if(!USE_DIFFUSE_TERM){diffuse_lambert = vec3(0.);}\n        \n        color = wg_dot_wi * get_light_intensity() * (diffuse_factor*diffuse_lambert + specular_microfacet);\n    }\n    return color;\n}\n\n//-----------------------------------------------------------------------------\n//-- Main ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 screen_coords = ( 2.*gl_FragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 ro = vec3( 3. * cos(iTime), 0.5 , 3. * sin(iTime) );\n    vec3 rd = compute_camera_ray_direction(screen_coords, ro, vec3(0.), 0.);\n    fragColor = vec4( render(ro,rd) , 1.);\n    //-- UI integration -----------------------------------------------\n    vec4 ui = texture(iChannel0,gl_FragCoord.xy/iResolution.xy);\n    fragColor.rgb = mix(fragColor.rgb,ui.rgb, ui.a*.8);\n    //-- Tonemapping / Gamma correction -------------------------------\n    fragColor.rgb = fragColor.rgb / (fragColor.rgb + vec3(1.0)); //-- Reinhard Tonemapping\n    fragColor.rgb = pow(fragColor.rgb,vec3(0.4545));\t\t\t //-- Gamma Correction\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-----------------------------------------------------------------------------\n//-- Constants ----------------------------------------------------------------\nconst float m_pi        = 3.14159265359;           /* MathConstant: PI                                 */\nconst float m_i_pi      = 0.31830988618;           /* MathConstant: 1 / PI                             */\nconst float m_sqrt_2    = 1.41421356237;           /* MathConstant: sqrt(2)                            */\nconst float m_i_sqrt_2  = 0.70710678119;           /* MathConstant: 1/sqrt(2)                          */\n\nconst float m_eps_3f    = 0.001;            \nconst float m_eps_4f    = 0.0001;            \n\n//-----------------------------------------------------------------------------\n//-- Tangent Space Maths (PBRT) -----------------------------------------------\nfloat cos_theta(const vec3 w)       {return w.z;}\nfloat cos_2_theta(const vec3 w)     {return w.z*w.z;}\nfloat sin_2_theta(const vec3 w)     {return max(0., 1. - cos_2_theta(w));}\nfloat sin_theta(const vec3 w)       {return sqrt(sin_2_theta(w));}\nfloat tan_theta(const vec3 w)       {return sin_theta(w) / cos_theta(w);}\nfloat cos_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 1. : clamp(w.x / sin_theta(w), -1., 1.);}\nfloat sin_phi(const vec3 w)         {return (sin_theta(w) == 0.) ? 0. : clamp(w.y / sin_theta(w), -1., 1.);}\nfloat cos_2_phi(const vec3 w)       {return cos_phi(w) * cos_phi(w);}\nfloat sin_2_phi(const vec3 w)       {return sin_phi(w) * sin_phi(w);} \n\n//-----------------------------------------------------------------------------\n//-- Ray ----------------------------------------------------------------------\nvec3 compute_camera_ray_direction(in vec2 screen_coordinates, in vec3 origin, in vec3 target, float cr )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw )*normalize(vec3(screen_coordinates,2.0));\n}\n\n//-----------------------------------------------------------------------------\n//-- Sphere Intersection Functions --------------------------------------------\nfloat sphere_get_hit(in vec3 ro, in vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return(-1.0);\n    h = sqrt( h );\n    return min( -b-h, -b+h );\n}\n\nvec3 sphere_get_normal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n//-----------------------------------------------------------------------------\n//-- Orthonormal Basis Function -----------------------------------------------\n//-- @nimitz's \"Cheap orthonormal basis\" on Shadertoy\n//-- https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n\n//-----------------------------------------------------------------------------\n//-- Student t utils ----------------------------------------------------------\nfloat abgam(float x)\n{\n  float gam0 = 1./ 12.;\n  float gam1 = 1./ 30.;\n  float gam2 = 53./ 210.;\n  float gam3 = 195./ 371.;\n  float gam4 = 22999./ 22737.;\n  float gam5 = 29944523./ 19733142.;\n  float gam6 = 109535241009./ 48264275462.;\n  float temp = 0.5*log(2.f*m_pi) - x + (x - 0.5)*log(x)\n    + gam0/(x + gam1/(x + gam2/(x + gam3/(x + gam4 /\n      (x + gam5/(x + gam6/x))))));\n\n  return temp;\n}\n\nfloat Gamma_Approx(float x)\n{\n  return( exp(abgam (x + 5.))/(x*(x + 1.)*(x + 2.)*(x + 3.)*(x + 4.)) );\n}\n\nfloat F_21(float nu)\n{\n    float nu_2  = nu*nu; \n    float nu_3  = nu*nu_2;\n    return(\n           (1.066*nu + 2.655*nu_2 + 4.892*nu_3)\n    / //---------------------------------------------------------------\n        ( 1.038 + 2.969*nu + 4.305*nu_2 + 4.418* nu_3)\n    ); \n}\n\nfloat F_24(float nu)\n{\n    float nu_2  = nu*nu; \n    float nu_3  = nu*nu_2;\n    return(\n          (6.537 + 6.074*nu - 0.623*nu_2 + 5.223*nu_3)\n    / //---------------------------------------------------------------\n          (6.538 + 6.103*nu - 3.218*nu_2 + 6.347*nu_3)\n    ); \n}\n\nfloat F_22(float gamma)\n{\n    float gamma_2  = gamma*gamma; \n    float gamma_3  = gamma*gamma_2; \n    return(\n           (14.402 - 27.145*gamma + 20.574*gamma_2 - 2.745*gamma_3)\n    / //---------------------------------------------------------------\n        ( -30.612 + 86.567*gamma - 84.341*gamma_2 + 29.938* gamma_3)\n    ); \n}\n\nfloat F_23(float gamma)\n{\n    float gamma_2  = gamma*gamma; \n    float gamma_3  = gamma*gamma_2; \n    return(\n           (-129.404 + 324.987*gamma - 299.305*gamma_2 + 93.268*gamma_3)\n    / //---------------------------------------------------------------\n          ( -92.609 + 256.006*gamma - 245.663*gamma_2 + 86.064* gamma_3)\n    ); \n}\n\n", "buffer_a_code": "//-- UI From Anatole Duprat : XT95 \n//-- https://www.shadertoy.com/view/ldKSDm\n//-- Using the following License :\n\n// Created by anatole duprat - XT95/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//-- Modified from line 91 (custom sliders, boxes and cursors...)\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(.5)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\n/* gfx func */ void setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\n//FUNCTIONS :\n// _cursor(x,y) : define the cursor (0,0) == top-left\n// _slider(x,y,id,v) : define a slider at the position x,y with an ID and a default value float v\n// _color(x,y,id,v) : define a color picker at the position x,y with an ID and a default value vec3 v\n// _box(x,y,sx,sy,c) : define a layout box at the position x,y with the size sx,sy and a color vec4 c\n//_[a..Z] : write a character at the position of the cursor\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy;\n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n    \n    //----------------------------------------------\n    //-- Changed Here :: Custom sliders\n    _cursor(20,30) _S _t _u _d _e _n _t _spc _t\n    _box(vec2(15,iResolution.y-35.),vec2(150,3),vec4(1.))\n\n    _slider(24,57, 0, 0.2) _R _o _u _g _h _n _e _s _s _spc _X\n    _slider(24,87, 1, 0.2) _R _o _u _g _h _n _e _s _s _spc _Y\n        \n    _box(vec2(15,iResolution.y-100.),vec2(150,3),vec4(1.))\n        \n    _slider(24,125, 2, 0.5) _R _e _f _l _e _c _t _a _n _c _e \n    _slider(24,155, 3, 1.0) _M _e _t _a _l \n    _color(24,185, 0, vec3(1.000,0.782,0.344)) _C _o _l _o _r\n                \n    fragColor = min(col.rgba,1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjXWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2996, 3156, 3246, 3246, 3836], [3839, 3839, 3930, 3930, 4624], [4626, 4786, 4840, 4840, 4895], [4897, 5057, 5098, 5098, 5124], [5125, 5125, 5165, 5165, 5191], [5192, 5192, 5232, 5232, 5258], [5260, 5555, 5580, 5580, 5648], [5649, 5649, 5673, 5673, 5743], [5745, 5907, 5944, 5944, 8166], [8168, 8328, 8385, 8385, 9087]]}
{"id": "7d2SDD", "name": "GLSL Fast Image Denoiser", "author": "Zerofile", "description": "Just a 2d denoiser, doesn't work to great", "tags": ["filter", "glsl", "denoise"], "likes": 29, "viewed": 2725, "published": 3, "date": "1620389039", "time_retrieved": "2024-07-30T19:21:26.515536", "image_code": "/*\nFAST APPROXIMATION OF https://www.shadertoy.com/view/3dd3Wr\n\n[\nThis project did NOT use any code from the /\\ above, I was creating this\nwhilst comparing its visuals to the above project\n]\n\nBoi if anybody uses this script you better not change the name of the function\n\nBy: Sir Bird / Zerofile\n\n*/\n\n#define SAMPLES 80  // HIGHER = NICER = SLOWER\n#define DISTRIBUTION_BIAS 0.6 // between 0. and 1.\n#define PIXEL_MULTIPLIER  1.5 // between 1. and 3. (keep low)\n#define INVERSE_HUE_TOLERANCE 20.0 // (2. - 30.)\n\n#define GOLDEN_ANGLE 2.3999632 //3PI-sqrt(5)PI\n\n#define pow(a,b) pow(max(a,0.),b) // @morimea\n\nmat2 sample2D = mat2(cos(GOLDEN_ANGLE),sin(GOLDEN_ANGLE),-sin(GOLDEN_ANGLE),cos(GOLDEN_ANGLE));\n\nvec3 sirBirdDenoise(sampler2D imageTexture, in vec2 uv, in vec2 imageResolution) {\n    \n    vec3 denoisedColor           = vec3(0.);\n    \n    const float sampleRadius     = sqrt(float(SAMPLES));\n    const float sampleTrueRadius = 0.5/(sampleRadius*sampleRadius);\n    vec2        samplePixel      = vec2(1.0/imageResolution.x,1.0/imageResolution.y); \n    vec3        sampleCenter     = texture(imageTexture, uv).rgb;\n    vec3        sampleCenterNorm = normalize(sampleCenter);\n    float       sampleCenterSat  = length(sampleCenter);\n    \n    float  influenceSum = 0.0;\n    float brightnessSum = 0.0;\n    \n    vec2 pixelRotated = vec2(0.,1.);\n    \n    for (float x = 0.0; x <= float(SAMPLES); x++) {\n        \n        pixelRotated *= sample2D;\n        \n        vec2  pixelOffset    = PIXEL_MULTIPLIER*pixelRotated*sqrt(x)*0.5;\n        float pixelInfluence = 1.0-sampleTrueRadius*pow(dot(pixelOffset,pixelOffset),DISTRIBUTION_BIAS);\n        pixelOffset *= samplePixel;\n            \n        vec3 thisDenoisedColor = \n            texture(imageTexture, uv + pixelOffset).rgb;\n\n        pixelInfluence      *= pixelInfluence*pixelInfluence;\n        /*\n            HUE + SATURATION FILTER\n        */\n        pixelInfluence      *=   \n            pow(0.5+0.5*dot(sampleCenterNorm,normalize(thisDenoisedColor)),INVERSE_HUE_TOLERANCE)\n            * pow(1.0 - abs(length(thisDenoisedColor)-length(sampleCenterSat)),8.);\n            \n        influenceSum += pixelInfluence;\n        denoisedColor += thisDenoisedColor*pixelInfluence;\n    }\n    \n    return denoisedColor/influenceSum;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const vec2 iChannel0Resolution = vec2(512, 512);\n    \n    vec3 col;\n    \n    float mousePosX = iMouse.x;\n    if (iMouse.x <= 1.) {mousePosX = 0.5*iResolution.x;}\n    \n    if (fragCoord.x > mousePosX) {\n        col = sirBirdDenoise(iChannel0, uv, iChannel0Resolution).rgb;\n    } else {\n        col = texture(iChannel0, uv).rgb;\n    }\n    \n    if (abs(fragCoord.x-mousePosX) < 1.) {col = vec3(0.0,1.0,0.0);}\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2SDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[703, 703, 785, 785, 2278], [2280, 2280, 2337, 2337, 2826]]}
{"id": "fdSSDD", "name": "Roots of Sine Sum", "author": "oneshade", "description": "Roots to a*sin(2x+b) + c*sin(x+d) + e", "tags": ["trig", "quartic", "roots", "solving", "tformulae"], "likes": 9, "viewed": 153, "published": 3, "date": "1620355933", "time_retrieved": "2024-07-30T19:21:27.268523", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nfloat evalSineSum(in float x, in float a, in float b, in float c, in float d, in float e) { return a * sin(2.0 * x + b) + c * sin(x + d) + e; }\nfloat evalSineSumPrime(in float x, in float a, in float b, in float c, in float d, in float e) { return 2.0 * a * cos(2.0 * x + b) + c * cos(x + d); }\n\n// Solves a*sin(2x+b)+c*sin(x+d)+e=0\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nint solveSineSum(in float a, in float b, in float c, in float d, in float e, inout vec4 roots, inout vec4 periods) {\n    periods = vec4(6.28318530718); // 2π\n    float shift = 0.5 * b, s = d - shift, ea = e / a;\n    vec2 sc = vec2(sin(s), 2.0 * cos(s)) * c / a;\n\n    // Solve a quartic in tan((x+b/2)/2)\n    float qa = ea - sc.x;\n    float qb = sc.y - 4.0;\n    float qc = 2.0 * ea;\n    float qd = sc.y + 4.0;\n    float qe = ea + sc.x;\n\n    qb /= qa; qc /= qa; qd /= qa; qe /= qa; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = qb * qb;\n    float p = qc - 3.0 * bb / 8.0;\n    float q = qd -  qb * qc / 2.0 + bb * qb / 8.0;\n    float r = qe -  qb * qd / 4.0 + bb * qc / 16.0 - 3.0 * bb * bb / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * qb;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = atan(vec2(h + z, h - z)) * 2.0 - shift;\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = atan(vec2(h + w, h - w)) * 2.0 - shift;\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    float t = 0.25 * unit;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(mod(uv.x + 0.25, 0.5) - 0.25) + t, vec3(0.0, 0.0, 1.0));\n    draw(abs(mod(uv.y + 0.25, 0.5) - 0.25) + t, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Parameters\n    float a = sin(iTime * 0.25) * 1.25;\n    float b = sin(iTime) * 2.0;\n    float c = sin(iTime) * 2.0;\n    float d = cos(iTime * 0.75);\n    float e = sin(iTime * 0.5);\n\n    // Draw the function and its roots\n    float fx = evalSineSum(uv.x, a, b, c, d, e);\n    float dx = evalSineSumPrime(uv.x, a, b, c, d, e);\n    draw(abs(uv.y - fx) / sqrt(1.0 + dx * dx) - t, vec3(0.5, 0.0, 0.5));\n\n    vec4 roots, periods;\n    int nroots = solveSineSum(a, b, c, d, e, roots, periods);\n    for (int n=0; n < nroots; n++) {\n        float h = 0.5 * periods[n];\n        draw(length(vec2(mod(uv.x - roots[n] + h, periods[n]) - h, uv.y)) - 0.1, vec3(0.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSSDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 159, 159, 211], [212, 212, 308, 308, 362], [364, 401, 425, 425, 468], [469, 469, 585, 585, 2948], [2950, 2950, 3005, 3005, 4109]]}
{"id": "sdSXDm", "name": "point Light -jf", "author": "jorge2017a1", "description": "point Light -jf", "tags": ["pointlightjf"], "likes": 10, "viewed": 339, "published": 3, "date": "1620353944", "time_retrieved": "2024-07-30T19:21:28.216987", "image_code": "//por jorge2017a1-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define REFLECT 2\n//falta depurar....la referencia de punto de luz , necesito buscar\n\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n#define NUM_POINTLIGHTS 4\nvec4 light_p_coord[NUM_POINTLIGHTS]; //W is bool visibility\nvec4 light_p_color[NUM_POINTLIGHTS];\n\n\n\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n\t{ vec3 q = abs(p) - b; return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r; }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\t\n\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n\t\n\t\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared frente\n    float planeDist6 = p.z+40.0;  //pared atras\n    \n    res =opU3(res, vec3(planeDist1,-1.0,7.0)); //inf\n    \n    res =opU3(res, vec3(planeDist2,14.0,MATERIAL_NO)); \n    res =opU3(res, vec3(planeDist3,-1.0,9.0)); \n    res =opU3(res, vec3(planeDist4,-1.0,9.0)); \n    res =opU3(res, vec3(planeDist5,-1.0 ,8.0)); \n    res =opU3(res, vec3(planeDist6,16.0,MATERIAL_NO)); \n    \n          p.y=p.y-5.0;\n    //rotar centro origen\n     float posx=2.5; //es el centro del objeto\n     pp=p;\n     pp.x=pp.x-posx;\n     pp.xz = rotatev2(pp.xz, iTime);\n     pp.x=pp.x+posx;\n   \n    float sdrb3=  sdRoundBox( pp-vec3(posx,-3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 in\n    float sdrb3A= sdRoundBox(pp-vec3(posx,0.0,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    float sdrb3B= sdRoundBox(pp-vec3(posx,3.5,0.0), vec3(2.0,1.0,1.0), 1.0 ); //3 inf\n    \n    res =opU3(res, vec3(sdrb3,13.0,-1)); \n    res =opU3(res, vec3(sdrb3A,14.0,-1)); \n    res =opU3(res, vec3(sdrb3B,15.0,-1)); \n    \n   float sdsp1= sdSphere( p-vec3(-10.0,0.0,0.0), 6.0 );\n    res =opU3(res, vec3(sdsp1,201.0,-1)); \n    float sdsp2= sdSphere( p-vec3(14.0,3.0,10.0), 6.0 );\n    res =opU3(res, vec3(sdsp2,32.0,-1)); \n    \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{\n    float t = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    \n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*t;\n        dS = GetDist(p);\n        t += dS.x;\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {   mObj.hitbln = true; minDist = abs(t); break; }\n        \n        if(t>MAX_DIST)\n        { mObj.hitbln = false;    minDist = t;    break; } \n        \n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return t;\n}\n\n///-----------------------------\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n///============================================================\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ \n   \n    vec3 l = normalize(lp - p);\n    vec3 r = reflect(-l, n);\n    float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n    \n    return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{\n    vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float distA = max(length(l), 0.01);\n    float distB = 1.0/(length(p-lp));\n    float dist=(distA+distB)/2.0;\n    \n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= (dist);\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    \n    float diff=max(dot(normalize(p-lp), -n), 0.0);;\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n            \n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    if (mObj.blnShadow==true)\n    { fshadow=GetShadow(p,lp);}\n    else\n    {   fshadow=0.5; }\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin *= vec3(1.0)*  max(normalize(vec3(length(lin))).z, 0.)+ .75; \n    lin = pow(lin,vec3(0.4545));\n    return lin;\n}\n///============================================================\n//----------------------------------------------------\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\n\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); \n    return col*2.0;\n    }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n}\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos, vec3 lightcol)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    \n    return col;\n}\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    if (id_material==6.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    \n    if (id_material==8.0)\n    {return pattern( p.xy );}\n    \n    if (id_material==9.0)\n    {return pattern( p.zy );}\n    \n    \n}\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    \n     if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if ( float( id_color)>=100.0  && float( id_color)<=199.0 ) \n \t{  vec3 coltex=getColorTextura(p, n, int( id_color));\n        colobj=coltex;\n\t}\n\n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\n\n\n#define ITERATIONS 30\n\nfloat softShadow(vec3 origin, vec3 direction, float mint, float maxt, float k) {\n    float l = 1.0;\n    float t = mint;\n    float dist;\n    for(int i=0;i<ITERATIONS;i++)\n    {\n        dist = GetDist(origin + direction*t).x;\n        if(dist<EPSILON)\n            return 0.0; //If hits a surface, fragment is completely shadowed\n        t += dist;\n        l = min(l, k*dist/t);\n        if(t > maxt)\n            break;\n    }\n    return l;\n}\n\n\nvec3 pointLight(vec3 pos, vec3 lpos, vec3 lcol, vec3 normal)\n{\n    float diff = max(dot(normalize(pos-lpos), -normal), 0.0);\n    float dist = 1.0/(length(pos-lpos));\n    float shadow = softShadow(pos, normalize(lpos-pos), 0.1, length(lpos-pos), 30.0);\n    return dist * diff * lcol * shadow;\n}\n\n\nvec3 lighting(vec3 pos, vec3 ro, vec3 rd, vec3 nor, vec3 colobj) \n{\n    vec3 l = vec3(0.0);\n    vec3 l2 = vec3(0.0);\n    vec3 cam=ro;\n    vec3 light_pos1;\n    vec3 light_color1;\n    \n    \n    for (int i=0; i<NUM_POINTLIGHTS; i++)\n    {\n        vec3 light_pos1 = light_p_coord[i].xyz;\n        vec3 light_color1=light_p_color[i].xyz;\n        l += pointLight(pos, light_pos1, light_color1, nor);\n        \n        if (light_p_coord[i].w > 0.5)\n        {\n            if (length(pos-cam) > length(light_pos1-cam))\n                l += pow(max(dot(normalize(cam-light_pos1), -normalize(pos-cam)), 0.0), 2000.0)*light_p_color[i].xyz;\n        }\n    }\n    \n    vec3 lf1=5.0*l*colobj;\n    return lf1;\n}\n\nvec3 renderReflect(TObj Obj, vec3 ro, vec3 rd, vec3 col )\n{\n   vec3 p;\n   float t;\n   vec3 colobj;  vec3 n;\n  /////-----------REFLECT--------------\n    if (int( Obj.id_color) ==201)\n    {\n     vec3 colref;\n     for(int i=0; i<2; ++i)\n      {  \n       \n        t=RayMarch(ro,rd, MAX_STEPS);\n        Obj=mObj;\n        \n        if( t<0.0 || t>MAX_DIST ) break;\n        p=ro+rd*t;\n        \n        n=GetNormal(p);\n        rd=reflect(rd,n);\n        ro =p+rd * MIN_DIST * 3.;\n        \n        if (t<MAX_DIST)\n        colobj=GetColorYMaterial( p, n, ro, rd,  int( Obj.id_color), Obj.id_material)*2.0;\n        colref=lighting(p, ro, rd, n, colobj);\n        \n       }\n     col+=colref/(float(REFLECT));\n   } \n   return col;\n} \n\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd;\n   mObj.ro=ro;\n   vec3 p ;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        p = (ro + rd * d );  \n        vec3 nor=mObj.normal;\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result+=lighting(p, ro, rd, nor, colobj);\n        col= result;\n    }\n    \n    col= renderReflect(Obj,  ro,  rd,  col );\n   \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,\n        1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c)\n    );\n    \n    //1.055 * pow(c, vec3(1.0/2.4)) - 0.055,\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,360.0);\n    itime=t;\n\tmObj.blnShadow=true;\n    vec3 light_pos3= vec3(5.0, 10.0, -15.0 ); vec3 light_color3=vec3(1.0);\n \tvec3 light_pos4= vec3( -5.0, 20.0, 10.0 );vec3 light_color4=vec3(1.0); \n \n  vec3 light_color1=vec3(1.0,0.0,0.0);\n  vec3 light_color2=vec3(0.0,1.0,0.0);\n  \n light_pos1=vec3(5.0+5.0*sin(iTime)-2.0, 2.0+abs(5.0*sin(iTime)), -10.0+5.0*cos(iTime*2.0));\n light_pos2=vec3(0.2, sin(iTime)*4.+5.0, 3.0);\n \n light_p_coord[0]=vec4(light_pos1,1.0);\n light_p_color[0]=vec4(light_color1,1.0);\n \n light_p_coord[1]=vec4(light_pos2,1.0);\n light_p_color[1]=vec4(light_color2,0.0);\n \n light_p_coord[2]=vec4(light_pos3,1.0);\n light_p_color[2]=vec4(light_color3,0.0);\n \n light_p_coord[3]=vec4(light_pos4,1.0);\n light_p_color[3]=vec4(light_color4,0.0);\n \n \n   vec3 ro=vec3(0.0,7.0+abs(5.0*sin(t)),-25.0);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    vec3 col= Render( ro,  rd);\n    \n    col = linear2srgb(col);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\n///--------------------------------------------FIN\n///--------------------------------------------\nvec3 hsv(vec3 c)\n{\n    vec4 k=vec4(1.,2./3.,1./3.,3.);\n    vec3 p=abs(fract(c.xxx+k.xyz)*6.-k.www);\n    return c.z*mix(k.xxx,clamp(p-k.xxx,0.,1.),c.y);\n}\n\n///Gracias a SHane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[675, 675, 711, 711, 732], [733, 733, 765, 765, 849], [850, 850, 896, 896, 983], [985, 1029, 1076, 1076, 1103], [1105, 1105, 1148, 1148, 1175], [1177, 1177, 1225, 1225, 1253], [1254, 1325, 1359, 1359, 1457], [1458, 1458, 1492, 1492, 1584], [1585, 1585, 1619, 1619, 1711], [1712, 1752, 1786, 1786, 1883], [1884, 1924, 1949, 1949, 3457], [3459, 3510, 3534, 3534, 3722], [3725, 3725, 3774, 3774, 4427], [4429, 4516, 4552, 4552, 4799], [4920, 4920, 4947, 4947, 4964], [4966, 4966, 5002, 5002, 5094], [5095, 5095, 5141, 5141, 5286], [5288, 5288, 5362, 5362, 6942], [6943, 7062, 7111, 7111, 7364], [7365, 7399, 7494, 7494, 7626], [7627, 7716, 7744, 7744, 7939], [7940, 7991, 8038, 8038, 8766], [8821, 8821, 8914, 8914, 9342], [9369, 9369, 9449, 9449, 9805], [9808, 9808, 9870, 9870, 10101], [10104, 10104, 10171, 10171, 10795], [11517, 11517, 11548, 11548, 12075], [12077, 12126, 12152, 12152, 12326], [12328, 12328, 12386, 12386, 12438], [12442, 12491, 12548, 12548, 13603]]}
{"id": "ssSXDm", "name": "Persian rug", "author": "jarble", "description": "This formula generates a pattern that resembles a Persian rug.\nMy [url=https://www.shadertoy.com/view/Nst3R4]\"Persian rug patterns\"[/url] generator is much better than this one.", "tags": ["fractal", "rug"], "likes": 4, "viewed": 350, "published": 3, "date": "1620353895", "time_retrieved": "2024-07-30T19:21:28.965984", "image_code": "//change these constants to get different patterns!\n#define c2 0.0\n\n#define c1 vec4(2.0+c2,2.5+c2,1.4,0)\n//#define c1 vec4(2.0+c2,1.5+c2,1.4,0)\n//#define c1 vec4(1.0,1.5,1.4,0)\n//#define c1 vec4(7.0,5.0,1.4,0)\n//#define c1 vec4(7.0,9.0,1.4,0)\n//#define c1 vec4(5.0,5.5,1.4,0)\n\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.5;\n    float offset = .18;\n    float scale2 = 1.05;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<9;i++)\n        {\n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            //if(uv.x > uv.y) uv *= scale;\n\n            uv.x *= -1.0;\n            uv = triangle_wave(uv+c1.w,scale);\n            scale /= scale2+col.x;\n            offset *= scale2;\n            uv.y *= -1.0;\n            uv = uv.yx;\n            //uv = uv.yx;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 318, 318, 363], [365, 365, 422, 422, 1167]]}
{"id": "7dSXDm", "name": "Fractal maze", "author": "jarble", "description": "A never-ending maze of zig-zagging walls.", "tags": ["fractal", "maze"], "likes": 2, "viewed": 277, "published": 3, "date": "1620353358", "time_retrieved": "2024-07-30T19:21:29.714982", "image_code": "//change this constant to get different patterns\n#define c1 vec4(2.0,2.5,1.4,0)\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.0;\n    float offset = .18;\n    float scale2 = 1.05;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<9;i++)\n        {\n          \n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            uv.x /= -1.0;\n            uv = triangle_wave(uv+c1.w+col.xy,scale);\n            scale /= scale2+col.x;\n            offset *= scale2;\n            //uv.y /= -1.0;\n            uv = uv.yx;\n            //uv = uv.yx;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSXDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 121, 121, 166], [168, 168, 225, 225, 946]]}
{"id": "ssSSDm", "name": "Challenger -Nes", "author": "jorge2017a1", "description": "Challenger -Nes", "tags": ["2d", "nes", "poly", "challenger"], "likes": 6, "viewed": 208, "published": 3, "date": "1620350489", "time_retrieved": "2024-07-30T19:21:30.477942", "image_code": "//por jorge2017a1 ----jorgeFloresP---5/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\nconst vec3 colPelo=vec3(0.79,0.51,0.37);\nconst vec3 colPiel=vec3(0.98,0.92,0.82);\nconst vec3 colPiel2=vec3(0.88,0.82,0.72);\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\n\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly8 POLY(8)\nvec2 pt8[ 8]=vec2[](  \nvec2(.27,.43),vec2(.52,.94),vec2(.77,.43),vec2(.58,.43),vec2(.58,.52),\nvec2(.45,.52),vec2(.42,.43),vec2(.27,.43) );\n\nfloat sdPoly4 POLY(4)\nvec2 pt4[ 4]=vec2[](  \nvec2(.52,.94),vec2(.89,.55),vec2(.77,.43),vec2(.52,.94) );\n\n\nfloat sdPoly4b POLY(4)\nvec2 pt4b[ 4]=vec2[](  \nvec2(.42,.42),vec2(.45,.46),vec2(.45,.52),vec2(.42,.42) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.45,.52),vec2(.48,.52),vec2(.49,.46),vec2(.45,.46),vec2(.45,.52) );\n\nfloat sdPoly5b POLY(5)\nvec2 pt5b[ 5]=vec2[](  \nvec2(.54,.52),vec2(.58,.52),vec2(.58,.46),vec2(.55,.46),vec2(.54,.52) );\n\nfloat sdPoly5c POLY(5)\nvec2 pt5c[ 5]=vec2[](  \nvec2(.48,.52),vec2(.54,.52),vec2(.55,.46),vec2(.49,.46),vec2(.48,.52) );\n\nfloat sdPoly5d POLY(5)\nvec2 pt5d[ 5]=vec2[](  \nvec2(.48,.52),vec2(.54,.52),vec2(.55,.46),vec2(.49,.46),vec2(.48,.52) );\n//***------------****-----------****------------******-------\n//piramide II\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.10,.39),vec2(.21,.67),vec2(.66,.67),vec2(.77,.39),vec2(.49,.39),\nvec2(.49,.50),vec2(.37,.50),vec2(.35,.39),vec2(.10,.39) );\n\n\nfloat sdPoly5e POLY(5)\nvec2 pt5e[ 5]=vec2[](  \nvec2(.25,.60),vec2(.23,.57),vec2(.28,.57),vec2(.29,.60),vec2(.25,.60) );\n\nfloat sdPoly5f POLY(5)\nvec2 pt5f[ 5]=vec2[](  \nvec2(.58,.60),vec2(.56,.57),vec2(.61,.57),vec2(.63,.60),vec2(.58,.60) );\n\nfloat sdPoly5g POLY(5)\nvec2 pt5g[ 5]=vec2[](  \nvec2(.31,.81),vec2(.77,.81),vec2(.66,.67),vec2(.21,.67),vec2(.31,.81) );\n\n\nfloat sdPoly5h POLY(5)\nvec2 pt5h[ 5]=vec2[](  \nvec2(.32,.80),vec2(.73,.80),vec2(.65,.68),vec2(.24,.68),vec2(.32,.80) );\n\nfloat sdPoly5i POLY(5)\nvec2 pt5i[ 5]=vec2[](  \nvec2(.66,.68),vec2(.77,.40),vec2(.95,.62),vec2(.77,.81),vec2(.66,.68) );\n//***------------****-----------****------------******-------\n// piramide 3\n\nfloat sdPoly5j POLY(5)\nvec2 pt5j[ 5]=vec2[](  \nvec2(.03,.45),vec2(.53,.45),vec2(.41,.73),vec2(.16,.73),vec2(.03,.45) );\n\nfloat sdPoly5k POLY(5)\nvec2 pt5k[ 5]=vec2[](  \nvec2(.21,.81),vec2(.16,.73),vec2(.40,.73),vec2(.47,.81),vec2(.21,.81) );\n\nfloat sdPoly5l POLY(5)\nvec2 pt5l[ 5]=vec2[](  \nvec2(.53,.45),vec2(.66,.59),vec2(.47,.81),vec2(.41,.74),vec2(.53,.45) );\n\nfloat sdPoly5m POLY(5)\nvec2 pt5m[ 5]=vec2[](  \nvec2(.22,.79),vec2(.43,.79),vec2(.40,.76),vec2(.19,.76),vec2(.22,.79) );\n\nfloat sdPoly5n POLY(5)\nvec2 pt5n[ 5]=vec2[](  \nvec2(.20,.66),vec2(.18,.63),vec2(.23,.63),vec2(.25,.66),vec2(.20,.66) );\n\nfloat sdPoly5o POLY(5)\nvec2 pt5o[ 5]=vec2[](  \nvec2(.33,.66),vec2(.31,.63),vec2(.36,.63),vec2(.38,.66),vec2(.33,.66) );\n\nfloat sdPoly5p POLY(5)\nvec2 pt5p[ 5]=vec2[](  \nvec2(.33,.63),vec2(.33,.65),vec2(.37,.65),vec2(.36,.63),vec2(.33,.63) );\n\n//***------------****-----------****------------******-------\n\nvec3 Piramide1(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n   \n   float sd1 = sdPoly8(p, pt8);\n   float sd2 = sdPoly4(p, pt4);\n   float sd3 = sdPoly4b(p, pt4b);\n   float sd4 = sdPoly5(p, pt5);\n   float sd5 = sdPoly5b(p, pt5b);\n   float sd6 = sdPoly5c(p, pt5c);\n   col= ponerBorde(colGris,col,sd1); //\n   col= ponerBorde(colNegro,col,sd2); //\n   col= ponerBorde(colNegro,col,sd3); // triangulo ch\n   col= ponerBorde(colGris,col,sd4); // pared ch1\n   col= ponerBorde(colGris,col,sd5); // pared ch2\n   col= mix(col,colNegro ,S( sd6,0.0)); //puerta\n  return col;\n}\n\n\nvec3 piramide2(in vec2 p, vec3 col) \n{\n  float sd1 = sdPoly9(p, pt9);\n  float sd2 = sdPoly5e(p, pt5e);\n  float sd3 = sdPoly5f(p, pt5f);\n  float sd4 = sdPoly5g(p, pt5g);\n  float sd5 = sdPoly5h(p, pt5h);\n  float sd6 = sdPoly5i(p, pt5i);\n  col= ponerBorde(colGris,col,sd1);\n  col= ponerBorde(colAzul,col,sd2); //ventana izq\n  col= ponerBorde(colAzul,col,sd3); //ventana der\n  col= ponerBorde(colGris2,col,sd4);  //techo\n  col= ponerBorde(colGris,col,sd5);  //marco\n  col= ponerBorde(colNegro,col,sd6);  //marco\n  return col;\n}\n\nvec3 piramide3(in vec2 p, vec3 col) \n{\n  float sd1 = sdPoly5j(p, pt5j);\n  float sd2 = sdPoly5k(p, pt5k);\n  float sd3 = sdPoly5l(p, pt5l);\n  float sd4 = sdPoly5m(p, pt5m);\n  float sd5 = sdPoly5n(p, pt5n);\n  float sd6 = sdPoly5o(p, pt5o);\n  float sd7 = sdPoly5p(p, pt5p);\n  \n  col= ponerBorde(colGris,col,sd1); //frente\n  col= ponerBorde(colGris,col,sd2);\n  col= ponerBorde(colNegro,col,sd3); //lateral\n  col= ponerBorde(colGris2,col,sd4); //techo\n  col= ponerBorde(colGris,col,sd5); //ventana izq\n  col= ponerBorde(colGris,col,sd6); //ventana der\n  col= ponerBorde(colAzul,col,sd7); /// ventana vidrio\n  \n  return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    //posicion\n    float t=iTime*1.0;\n    vec2 p=uv+vec2(1.5+0.5*sin(t),0.9+0.5*cos(t));\n    vec3 col=colGris;\n     col= Piramide1( p,col);\n     col= piramide2(p-vec2(-1.0,0.0), col);\n     col= piramide2(p-vec2(1.0,0.0), col);\n     col= piramide3(p-vec2(0.5,0.55), col);\n     col= piramide3(p-vec2(0.5,-0.55), col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSSDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 339, 339, 363], [365, 365, 425, 425, 549], [3930, 3930, 3969, 3969, 4487], [4490, 4490, 4528, 4528, 5013], [5015, 5015, 5053, 5053, 5634], [5638, 5638, 5695, 5695, 6098]]}
{"id": "ssSXWm", "name": "Shane's Noise, but auto tiled", "author": "DEKTEN", "description": "Wanted to test out my auto tiling logic on a cool shader. So copied[ https://www.shadertoy.com/view/ldscWH ]and added auto tiling logic. Pages through all possible 16 auto tile sub tiles.", "tags": ["tiled", "shane", "autotile", "ruletile"], "likes": 3, "viewed": 279, "published": 3, "date": "1620346080", "time_retrieved": "2024-07-30T19:21:31.422416", "image_code": "\n//: A copy of shane's \"Smooth Noise Countours\" with auto tiling math applied to it.\n//: Pages through the 16 possible sub-tiles of an auto tile sets and maps shanes\n//: shader onto the tile. The screen being the coordinate space of the tile.\n//:\n//: You can use this kind of math to create procedural auto tiling.\n//:\n//: Shane's original shader: https://www.shadertoy.com/view/ldscWH\n//: \n//: My twitch coding stream: www.twitch.com/kanjicoder\n\n\n// Variable to a keep a copy of the noise value prior to palettization. Used to run a soft gradient \n// over the surface, just to break things up a little.\nfloat ns;\n\n\n//float sFract(float x, float sm){ float fx = fract(x); return fx - smoothstep(fwidth(x)*sm, 0., 1. - fx); }\n//float sFract(float x, float sm){ float fx = fract(x); return min(fx, fx*(1. - fx)/fwidth(x)/sm); }\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat sFract(float x, float sm){\n    \n    // Extra smoothing factor. \"1\" is the norm.\n    const float sf = 1.; \n    \n    // The hardware \"fwidth\" is cheap, but you could take the expensive route and\n    // calculate it by hand if more quality was required.\n    vec2 u = vec2(x, fwidth(x)*sf*sm);\n    \n    // Ollj's original formula with a transcendental term omitted.\n    u.x = fract(u.x);\n    u += (1. - 2.*u)*step(u.y, u.x);\n    return clamp(1. - u.x/u.y, 0., 1.); // Cos term ommitted.\n}\n\n\n\n// Only correct for nonnegative values, but in this example, numbers aren't negative.\nfloat sFloor(float x){ return x - sFract(x, 1.); } \n\n// Standard hue rotation formula with a bit of streamlining. \nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n\n\n// vec3 to vec3 hash algorithm.\nvec3 hash33(vec3 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as the block below it. However, when framerate\n    // is an issue, and it often is, this is the one to use. Basically, it's a tweaked amalgamation I put\n    // together, based on a couple of other random algorithms I've seen around... so use it with caution,\n    // because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; // return fract(vec3(64, 8, 1)*32768.0*n)*2.-1.; \n\n    // I'll assume the following came from IQ.\n    //p = vec3( dot(p, vec3(127.1, 311.7, 74.7)), dot(p, vec3(269.5, 183.3, 246.1)), dot(p, vec3(113.5, 271.9, 124.6)));\n    //return (fract(sin(p)*43758.5453)*2. - 1.);\n\n}\n\n\n\n// Cheap, streamlined 3D Simplex noise... of sorts. I cut a few corners, so it's not perfect, but it's\n// artifact free and does the job. I gave it a different name, so that it wouldn't be mistaken for\n// the real thing.\n// \n// Credits: Ken Perlin, the inventor of Simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified,\" IQ, other \"ShaderToy.com\" people, etc.\nfloat tetraNoise(in vec3 p)\n{\n    // Skewing the cubic grid, then determining the first vertice and fractional position.\n    vec3 i = floor(p + dot(p, vec3(.333333)) );  p -= i - dot(i, vec3(.166666)) ;\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of the \n    // intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    // Using the above to calculate the other three vertices -- Now we have all four tetrahedral vertices.\n    // Technically, these are the vectors from \"p\" to the vertices, but you know what I mean. :)\n    vec3 p1 = p - i1 + .166666, p2 = p - i2 + .333333, p3 = p - .5;\n  \n\n    // 3D simplex falloff - based on the squared distance from the fractional position \"p\" within the \n    // tetrahedron to the four vertice points of the tetrahedron. \n    vec4 v = max(.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    \n    // Dotting the fractional position with a random vector, generated for each corner, in order to determine \n    // the weighted contribution distribution... Kind of. Just for the record, you can do a non-gradient, value \n    // version that works almost as well.\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n     \n     \n    // Simplex noise... Not really, but close enough. :)\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); // Not sure if clamping is necessary. Might be overkill.\n\n}\n\n\n// The function value. In this case, slightly-tapered, quantized Simplex noise.\nfloat func(vec2 p){\n    \n    // The noise value.\n    float n = tetraNoise(vec3(p.x*4., p.y*4., 0) - vec3(0, .25, .5)*iTime);\n    \n    // A tapering function, similar in principle to a smooth combine. Used to mutate or shape \n    // the value above. This one tapers it off into an oval shape and punches in a few extra holes.\n    // Airtight uses a more interesting triangular version in his \"Cartoon Fire\" shader.\n    float taper = .1 + dot(p, p*vec2(.35, 1));\n\tn = max(n - taper, 0.)/max(1. - taper, .0001);\n    \n    // Saving the noise value prior to palettization. Used for a bit of gradient highlighting.\n    ns = n; \n    \n    // I remember reasoning to myself that the following would take a continuous function ranging\n    // from zero to one, then palettize it over \"palNum\" discreet values between zero and one\n    // inclusive. It seems to work, but if my logic is lacking (and it often is), feel free to \n    // let me know. :)\n    const float palNum = 9.; \n    // The range should strictly fall between zero and one, but for some crazy reason, numbers fall\n    // outside the range, so I've had to clamp it. I know the computer is never wrong, so I'm \n    // probably overlooking something. Having said that, I don't trust the GPU \"fract\" function much.\n    //return clamp(sFloor(n*(palNum - .001))/(palNum - 1.), 0., 1.);\n    return n*.25 + clamp(sFloor(n*(palNum - .001))/(palNum - 1.), 0., 1.)*.75;\n    \n}\n\nvec2 getSubTileCoords( vec2 f_c ){\n\n    //: Pretend the entire screen is one tile for this  -----://\n    //: example code. Center is at [0,0] , top left is  -----://\n    //: at [-1,-1] and bottom right is at [+1,+1]       -----://\n    vec2 uvc   = (f_c -0.5*iResolution.xy)/iResolution.y;\n         uvc.y =( 0.0 - uvc.y ); //:Invert Y axis\n\n//+----------------------------------------------------------+//\n//| What is the current wang-tile touching mask for          |//\n//| the tile you are drawing. In this example,               |//\n//| pretend the entire screen is one tile.                   |//\n//| TIL == Your One Tile                                     |//\n//|          +---+                                           |//\n//|          |y_0|                                           |//\n//|      +---+---+---+      0|1  0|1  |  0|1  0|1            |//\n//|      |x_0|TIL|x_1| -->  ___  ___  |  ___  ___            |//\n//|      +---+---+---+      X_0  X_1  |  Y_0  Y_1            |//\n//|          |y_1|                                           |//\n//|          +---+                                           |//\n//|                                                          |//\n//| toutang means : Touching Tangent                         |//\n//|                                                          |//\n//| [-1,-1]                                                  |//\n//|     +-------------+                                      |//\n//|     |             |                                      |//\n//|     |             |                                      |//\n//|     |     0.0     | <--[ TIL ] www.twitch.com/kanjicoder |//\n//|     |             |                                      |//\n//|     |             |                                      |//\n//|     +-------------+                                      |//\n//|                 [+1,+1]                                  |//\n//|                                                          |//\n//+----------------------------------------------------------+//\n\n    //:Animate the touching value of your tile.         -----://\n    //:Emulating all different combinations of which    -----://\n    //:neighbors can exist above,below,left,and right:  -----://\n\n    uint toutang=(uint(int(mod(iTime,16.0))));\n\n//+----------------------------------------------------------+//\n//|   +-----------------+ If( touself ==BINARY[ 1000 ] )THEN:|//\n//|   |\\\\     y_0     //|                                    |//\n//|   |  \\\\         //  |   We are in the x_0 pie slice.     |//\n//|   |    \\\\     //    |                                    |//\n//|   |      \\\\ //      | If( touself ==BINARY[ 1010 ] )THEN:|//\n//|   |x_0  ( 0.0 )  x_1|                                    |//\n//|   |      // \\\\      |   I fucked up the formula because  |//\n//|   |    //     \\\\    |   only ONE_BIT in touself should   |//\n//|   |  //         \\\\  |   have been set.                   |//\n//|   |//     y_1     \\\\|                                    |//\n//|   +-----------------+                                    |//\n//|   BITS[  0   0   0   0  ]                                |//\n//|   SIDE[ x_0 x_1 y_0 y_1 ]     www.twitch.com/kanjicoder  |//\n//|                                                          |//\n//|   touself means: \"TOUching SELF\"                         |//\n//+----------------------------------------------------------+//\n\n    //:Figure out which pie slice the pixel of  -------------://\n    //:your tile belongs to and set that bit:   -------------://\n    #define A abs\n    #define U uint\n    #define X uvc.x\n    #define Y uvc.y\n    U touself =( U(0)\n    | (( (X <= 0.0 && (A(X)>A(Y))) ? U(1) : U(0) ) << 3)\n    | (( (X >= 0.0 && (A(X)>A(Y))) ? U(1) : U(0) ) << 2)\n    | (( (Y <= 0.0 && (A(Y)>A(X))) ? U(1) : U(0) ) << 1)\n    | (( (Y >= 0.0 && (A(Y)>A(X))) ? U(1) : U(0) ) << 0)\n    );;\n    #undef A\n    #undef U\n    #undef X\n    #undef Y\n\n    //:If we are on a pie slice that is touching a           ://\n    //:neighbor, use the connected gradient(congrad).        ://\n    //:If we are on a pie slice that is __NOT__              ://\n    //:touching a neighbor, use walled-off gradient(walgrad).://\n    float walgrad = float( max( abs(uvc.x),abs(uvc.y) ) );\n    float congrad = float( min( abs(uvc.x),abs(uvc.y) ) );\n    float tougrad = (( touself & toutang )>=uint(1)) \n                 ? congrad   //:TRUE : Connected  Gradient\n                 : walgrad ; //:FALSE: Walled Off Gradient\n\n    float invgrad = (( touself & toutang )>=uint(1)) \n                 ? walgrad   //:INVERTED_GRADIENT\n                 : congrad ; //:INVERTED_GRADIENT\n\n    return( vec2( tougrad , invgrad ) );\n\n} //:[getSubTileCoords]:<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<://\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 u = getSubTileCoords( fragCoord );\n    \n    // Function value.\n    float f = func(u);\n    float ssd = ns; // Saving the unpalettized noise value to add a little gradient to the color, etc.\n    \n    // Four sample values around the original. Used for edging and highlighting.\n    vec2 e = vec2(1.5/iResolution.y, 0);\n    float fxl = func(u + e.xy);\n    float fxr = func(u - e.xy);\n    float fyt = func(u + e.yx);\n    float fyb = func(u - e.yx);\n    \n    // Colorizing the function value, and applying some hue rotation based on position.\n    // Most of it was made up.\n    vec3 col = pow(min(vec3(1.5, 1, 1)*(f*.7 + ssd*.35), 1.), vec3(1, 2., 10)*2.) + .01;\n    col = rotHue(col, -.25+.4*length(u));\n\n    // Applying the dark edges.\n    col *= max(1. - (abs(fxl - fxr) + abs(fyt - fyb))*5., 0.);\n    //col *= max(1. - length(vec2(fxl, fyt) - vec2(fxr, fyb))*7., 0.);\n    // Resampling with a slightly larger spread to provide some highlighting.\n    fxl = func(u + e.xy*1.5);\n    fyt = func(u + e.yx*1.5);\n    col += vec3(.5, .7, 1)*(max(f - fyt, 0.) + max(f - fxl, 0.))*ssd*10.;\n    \n    // Subtle, bluish vignette.\n    //u = fragCoord/iResolution.xy;\n    //col = mix(vec3(0, .1, 1), col, pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125)*.15 + .85);\n\n \t\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSXWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[827, 870, 902, 955, 1360], [1364, 1450, 1472, 1472, 1500], [1503, 1565, 1594, 1594, 1964], [1968, 2000, 2021, 2387, 2766], [2770, 3160, 3189, 3280, 4769], [4772, 4852, 4871, 4900, 6271], [10987, 10987, 11041, 11069, 12414]]}
{"id": "7sSSWm", "name": "AutoTile Basics", "author": "DEKTEN", "description": "How to render wang-tile style auto tiles with interlocking square gradients.\nVisit me on twitch: www.twitch.com/kanjicoder", "tags": ["rule", "auto", "autotile", "ruletile", "autotiling"], "likes": 3, "viewed": 272, "published": 3, "date": "1620344228", "time_retrieved": "2024-07-30T19:21:32.184379", "image_code": "//:----------------------------------------------------------://\n//:                                                          ://\n//:              www.twitch.com/kanjicoder                   ://\n//:                                                          ://\n//:----------------------------------------------------------://\n//:##########################################################://\n//:                                                          ://\n//: Ever wonder how to do wang-tile style auto tiling        ://\n//: with shader code? Here is the basic math to get          ://\n//: you started. Once you've got this figured out,           ://\n//: you can map interesting patterns onto the interlocking   ://\n//: gradient tiles.                                          ://\n//:                                                          ://\n//: If you want to see a more impressive demo of this        ://\n//: you can check out my heroku server demo:                 ://\n//:                                                          ://\n//: https://d3m0.herokuapp.com/                              ://\n//: Sroll down to \"Exhibit #22\"                              ://\n//: Note: Server is freely hosted on heroku,                 ://\n//:       so might take 30 seconds to load page.             ://\n//:                                                          ://\n//:##########################################################://\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    //: Pretend the entire screen is one tile for this  -----://\n    //: example code. Center is at [0,0] , top left is  -----://\n    //: at [-1,-1] and bottom right is at [+1,+1]       -----://\n    vec2 uvc   = (fragCoord -0.5*iResolution.xy)/iResolution.y;\n         uvc.y =( 0.0 - uvc.y ); //:Invert Y axis\n\n//+----------------------------------------------------------+//\n//| What is the current wang-tile touching mask for          |//\n//| the tile you are drawing. In this example,               |//\n//| pretend the entire screen is one tile.                   |//\n//| TIL == Your One Tile                                     |//\n//|          +---+                                           |//\n//|          |y_0|                                           |//\n//|      +---+---+---+      0|1  0|1  |  0|1  0|1            |//\n//|      |x_0|TIL|x_1| -->  ___  ___  |  ___  ___            |//\n//|      +---+---+---+      X_0  X_1  |  Y_0  Y_1            |//\n//|          |y_1|                                           |//\n//|          +---+                                           |//\n//|                                                          |//\n//| toutang means : Touching Tangent                         |//\n//|                                                          |//\n//| [-1,-1]                                                  |//\n//|     +-------------+                                      |//\n//|     |             |                                      |//\n//|     |             |                                      |//\n//|     |     0.0     | <--[ TIL ] www.twitch.com/kanjicoder |//\n//|     |             |                                      |//\n//|     |             |                                      |//\n//|     +-------------+                                      |//\n//|                 [+1,+1]                                  |//\n//|                                                          |//\n//+----------------------------------------------------------+//\n\n    //:Animate the touching value of your tile.         -----://\n    //:Emulating all different combinations of which    -----://\n    //:neighbors can exist above,below,left,and right:  -----://\n\n    uint toutang=(uint(int(mod(iTime,16.0))));\n\n//+----------------------------------------------------------+//\n//|   +-----------------+ If( touself ==BINARY[ 1000 ] )THEN:|//\n//|   |\\\\     y_0     //|                                    |//\n//|   |  \\\\         //  |   We are in the x_0 pie slice.     |//\n//|   |    \\\\     //    |                                    |//\n//|   |      \\\\ //      | If( touself ==BINARY[ 1010 ] )THEN:|//\n//|   |x_0  ( 0.0 )  x_1|                                    |//\n//|   |      // \\\\      |   I fucked up the formula because  |//\n//|   |    //     \\\\    |   only ONE_BIT in touself should   |//\n//|   |  //         \\\\  |   have been set.                   |//\n//|   |//     y_1     \\\\|                                    |//\n//|   +-----------------+                                    |//\n//|   BITS[  0   0   0   0  ]                                |//\n//|   SIDE[ x_0 x_1 y_0 y_1 ]     www.twitch.com/kanjicoder  |//\n//|                                                          |//\n//|   touself means: \"TOUching SELF\"                         |//\n//+----------------------------------------------------------+//\n\n    //:Figure out which pie slice the pixel of  -------------://\n    //:your tile belongs to and set that bit:   -------------://\n    #define A abs\n    #define U uint\n    #define X uvc.x\n    #define Y uvc.y\n    U touself =( U(0)\n    | (( (X <= 0.0 && (A(X)>A(Y))) ? U(1) : U(0) ) << 3)\n    | (( (X >= 0.0 && (A(X)>A(Y))) ? U(1) : U(0) ) << 2)\n    | (( (Y <= 0.0 && (A(Y)>A(X))) ? U(1) : U(0) ) << 1)\n    | (( (Y >= 0.0 && (A(Y)>A(X))) ? U(1) : U(0) ) << 0)\n    );;\n    #undef A\n    #undef U\n    #undef X\n    #undef Y\n\n    //:If we are on a pie slice that is touching a           ://\n    //:neighbor, use the connected gradient(congrad).        ://\n    //:If we are on a pie slice that is __NOT__              ://\n    //:touching a neighbor, use walled-off gradient(walgrad).://\n    float walgrad = float( max( abs(uvc.x),abs(uvc.y) ) );\n    float congrad = float( min( abs(uvc.x),abs(uvc.y) ) );\n    float tougrad = (( touself & toutang )>=uint(1)) \n                 ? congrad   //:TRUE : Connected  Gradient\n                 : walgrad ; //:FALSE: Walled Off Gradient\n\n    //: Output to screen\n    fragColor = vec4(tougrad,tougrad,tougrad,1.0);\n\n} //:[mainImage]:<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<://", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSSWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "7dSSDw", "name": "Random TV", "author": "Dutracgi", "description": "Uint32 Pseudorandom generator example!", "tags": ["noise", "tv", "tv", "random", "static", "pseudorandom"], "likes": 1, "viewed": 253, "published": 3, "date": "1620334543", "time_retrieved": "2024-07-30T19:21:32.936369", "image_code": "// Generator from:\n// https://www.cs.ubc.ca/labs/imager/tr/2008/SchechterTurbulenceSCA08/schechter_turbulence_sca08.pdf\nuint hash(uint s){\n\ts = s ^2747636419u;\n    s *= 2654435769u;\n\ts = s ^ 65536u;\n    s *= 2654435769u;\n\ts = s ^ 65536u;\n    s *= 2654435769u;\n\treturn s;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    uint sx = uint(int(uv.x*iResolution.x+iTime*3600.0));\n    uint sy = uint(int(uv.y*iResolution.y+iTime*6400.0));\n    \n    float c = float(hash(sy*sx)/32u);\n    \n    vec3 col = vec3(c*16.0/2147483647.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSSDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 120, 138, 138, 272], [273, 273, 330, 380, 717]]}
{"id": "NsSSWm", "name": "Menger Sponge 2D", "author": "Hitthesurf", "description": "Fractal Of Menger Sponge\nNot very efficient", "tags": ["fractal"], "likes": 1, "viewed": 244, "published": 3, "date": "1620321809", "time_retrieved": "2024-07-30T19:21:33.688358", "image_code": "float sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n/*float fractal1(in vec2 p, in vec2 size)\n{\n    size = size/3.0;\n    float minimum = min(  sdBox(vec2(p.x-2.0*size.x,p.y), size),\n                          sdBox(vec2(p.x+2.0*size.x,p.y), size));\n    minimum = min(minimum,sdBox(vec2(p.x,p.y+2.0*size.y), size));\n    minimum = min(minimum,sdBox(vec2(p.x,p.y-2.0*size.y), size));\n    \n    minimum = min(minimum,sdBox(vec2(p.x-2.0*size.x,p.y+2.0*size.y), size));\n    minimum = min(minimum,sdBox(vec2(p.x+2.0*size.x,p.y-2.0*size.y), size));\n    \n    minimum = min(minimum,sdBox(p+2.0*size, size));\n    minimum = min(minimum,sdBox(p-2.0*size, size));\n    return minimum;\n\n}*/\n\n\nfloat fractal1(in vec2 p, in vec2 size)\n{\n    return max(sdBox(p,size),-sdBox(p,size/3.0));\n}\n\n\nfloat fractal2(in vec2 p, in vec2 size)\n{\n    size = size/3.0;\n    float minimum = min(  fractal1(vec2(p.x-2.0*size.x,p.y), size),\n                          fractal1(vec2(p.x+2.0*size.x,p.y), size));\n    minimum = min(minimum,fractal1(vec2(p.x,p.y+2.0*size.y), size));\n    minimum = min(minimum,fractal1(vec2(p.x,p.y-2.0*size.y), size));\n    \n    minimum = min(minimum,fractal1(vec2(p.x-2.0*size.x,p.y+2.0*size.y), size));\n    minimum = min(minimum,fractal1(vec2(p.x+2.0*size.x,p.y-2.0*size.y), size));\n    \n    minimum = min(minimum,fractal1(p+2.0*size, size));\n    minimum = min(minimum,fractal1(p-2.0*size, size));\n    return minimum;\n\n}\n\nfloat fractal3(in vec2 p, in vec2 size)\n{\n    size = size/3.0;\n    float minimum = min(  fractal2(vec2(p.x-2.0*size.x,p.y), size),\n                          fractal2(vec2(p.x+2.0*size.x,p.y), size));\n    minimum = min(minimum,fractal2(vec2(p.x,p.y+2.0*size.y), size));\n    minimum = min(minimum,fractal2(vec2(p.x,p.y-2.0*size.y), size));\n    \n    minimum = min(minimum,fractal2(vec2(p.x-2.0*size.x,p.y+2.0*size.y), size));\n    minimum = min(minimum,fractal2(vec2(p.x+2.0*size.x,p.y-2.0*size.y), size));\n    \n    minimum = min(minimum,fractal2(p+2.0*size, size));\n    minimum = min(minimum,fractal2(p-2.0*size, size));\n    return minimum;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    float dis = fractal3(uv-vec2(.5,0.5), vec2(0.2,0.2));\n    if (dis<0.0)\n    {\n     fragColor = vec4(1.0,.0,0.0,1.0);\n    }\n    else\n    {\n    fragColor = vec4(.0,.0,1.0,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSSWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 117], [742, 742, 783, 783, 835], [838, 838, 879, 879, 1478], [1480, 1480, 1521, 1521, 2120], [2123, 2123, 2180, 2230, 2461]]}
{"id": "NdSSDw", "name": "Taotris", "author": "paniq", "description": "Alpha prototype. No win state yet but sort of playable. Left player uses WSAD keys, Right player uses Left/Right/Up/Down. Reset time or press backspace to restart map.", "tags": ["game", "tetris", "tetromino", "tao"], "likes": 41, "viewed": 2050, "published": 3, "date": "1620321062", "time_retrieved": "2024-07-30T19:21:34.703643", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scale = vec2(FIELDSIZE) / iResolution.xy;\n    \n    vec2 tx = fragCoord * max(scale.x,scale.y) - vec2(0,float(FIELDSIZE.y));\n    vec4 mem = vec4(vec3(0.5),1.0);\n    if ((min(tx.x,tx.y) >= 0.0) && (tx.x < float(FIELDSIZE.x)) && (tx.y < float(FIELDSIZE.y))) {\n        mem = texelFetch(iChannel0, ivec2(tx), 0);\n        if (mem.g > 0.5)\n            mem.r = 1.0 - mem.r;\n    }\n\n    fragColor = vec4(vec3(mem.r),1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat4 stone_pattern(int s) {\n    switch(s) {\n    case STONE_NONE: return mat4(0);\n    case STONE_I: return mat4(0,1,0,0,\n                              0,1,0,0,\n                              0,1,0,0,\n                              0,1,0,0);\n    case STONE_O: return mat4(0,0,0,0,\n                              0,1,1,0,\n                              0,1,1,0,\n                              0,0,0,0);\n    case STONE_S: return mat4(0,1,0,0,\n                              0,1,1,0,\n                              0,0,1,0,\n                              0,0,0,0);\n    case STONE_Z: return mat4(0,0,1,0,\n                              0,1,1,0,\n                              0,1,0,0,\n                              0,0,0,0);\n    case STONE_T: return mat4(0,1,0,0,\n                              0,1,1,0,\n                              0,1,0,0,\n                              0,0,0,0);\n    case STONE_L: return mat4(0,1,0,0,\n                              0,1,0,0,\n                              0,1,1,0,\n                              0,0,0,0);\n    case STONE_R: return mat4(0,0,1,0,\n                              0,0,1,0,\n                              0,1,1,0,\n                              0,0,0,0);\n    default: return mat4(0,0,0,0,\n                         0,0,0,0,\n                         0,0,0,0,\n                         0,0,0,0);\n    }\n}\n\n// from https://www.shadertoy.com/view/llySRh\n\n// FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36\n// Modifiers: SHIFT: 16 CTRL: 17 ALT: 18\n// Advice:  Mode: keyToggle(key)  Action: keydown(key)+keyclick(modifier)\n#define keyToggle(ascii)  ( texelFetch(iChannel1,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel1,ivec2(ascii,1),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel1,ivec2(ascii,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel1,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel1,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel1,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n#define K_BACKSPACE 8\n\n#define K_W 87\n#define K_S 83\n#define K_A 65\n#define K_D 68\n\n#define K_LEFT 37\n#define K_UP 38\n#define K_DOWN 40\n#define K_RIGHT 39\n\nmat4 rotate(mat4 m, int r) {\n    switch(r) {\n    case 0: return m;\n    case 1: return\n        mat4(m[3][0], m[2][0], m[1][0], m[0][0],\n             m[3][1], m[2][1], m[1][1], m[0][1],\n             m[3][2], m[2][2], m[1][2], m[0][2],\n             m[3][3], m[2][3], m[1][3], m[0][3]);\n    case 2: return\n        mat4(m[3][3], m[3][2], m[3][1], m[3][0],\n             m[2][3], m[2][2], m[2][1], m[2][0],\n             m[1][3], m[1][2], m[1][1], m[1][0],\n             m[0][3], m[0][2], m[0][1], m[0][0]);\n    case 3: return\n        mat4(m[0][3], m[1][3], m[2][3], m[3][3],\n             m[0][2], m[1][2], m[2][2], m[3][2],\n             m[0][1], m[1][1], m[2][1], m[3][1],\n             m[0][0], m[1][0], m[2][0], m[3][0]);\n    default: return m;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 uv = ivec2(fragCoord);\n    vec4 bstate = texelFetch(iChannel0, BSTATE, 0);\n    int bs = int(bstate.w);\n    int br = int(bstate.z);\n    vec4 wstate = texelFetch(iChannel0, WSTATE, 0);\n    int ws = int(wstate.w);\n    int wr = int(wstate.z);\n    vec4 bwclip = texelFetch(iChannel0, BWCLIP, 0);\n    if ((iFrame == 0) || keyDown(K_BACKSPACE)) {\n        // init\n        if ((uv.x < FIELDSIZE.x) && (uv.y < FIELDSIZE.y)) {\n            fragColor = vec4((uv.x < (FIELDSIZE.x/2))?0.0:1.0, 0.0, 0.0, 1.0);\n        }\n        if (uv == BSTATE) {\n            // position x, position y, rotation, stone type\n            fragColor = vec4(0, FIELDSIZE.y / 2 - 2, 0, 1 + int(hash12(vec2(iFrame,0)) * 7.0));\n        } else if (uv == WSTATE) {\n            fragColor = vec4(FIELDSIZE.x - 4, FIELDSIZE.y / 2 - 2, 2, 1 + int(hash12(vec2(iFrame,1)) * 7.0));\n        } else if (uv == BWCLIP) {\n            // boffset, bsize, woffset, wsize\n            fragColor = vec4(0);\n        }\n    } else {\n        vec4 mem = texelFetch(iChannel0, uv, 0);\n        bool bset = false;\n        bool wset = false;\n        if ((iFrame % 30) == 0) {\n            {\n                // black: z collision check\n                mat4 bm = rotate(stone_pattern(bs), br);\n                ivec2 npos = ivec2(bstate.xy) + ivec2(1,0);\n                for (int y = 0; y < 4; ++y) {\n                    for (int x = 0; x < 4; ++x) {                \n                        if (bm[y][x] > 0.5 && texelFetch(iChannel0, npos + ivec2(x,y), 0).r > 0.5) {\n                            bset = true;\n                        }\n                    }\n                }            \n                if (uv == BSTATE) {\n                    if (!bset) {\n                        mem.xy = vec2(npos);\n                    } else {\n                        mem = vec4(0, FIELDSIZE.y / 2 - 2, 0, 1 + int(hash12(vec2(iFrame,0)) * 7.0));\n                    }\n                }\n            }\n            {\n                mat4 bm = rotate(stone_pattern(ws), wr);\n                // white: z collision check\n                ivec2 npos = ivec2(wstate.xy) - ivec2(1,0);\n                for (int y = 0; y < 4; ++y) {\n                    for (int x = 0; x < 4; ++x) {                \n                        if (bm[y][x] > 0.5 && texelFetch(iChannel0, npos + ivec2(x,y), 0).r < 0.5) {\n                            wset = true;\n                        }\n                    }\n                }            \n                if (uv == WSTATE) {\n                    if (!wset) {\n                        mem.xy = vec2(npos);\n                    } else {\n                        mem = vec4(FIELDSIZE.x - 4, FIELDSIZE.y / 2 - 2, 2, 1 + int(hash12(vec2(iFrame,1)) * 7.0));\n                    }\n                }\n            }\n        } else if (uv == BSTATE) {\n            // y collision check            \n            ivec2 npos = ivec2(bstate.xy);\n            int nr = br;\n            if (keyDown(K_A)) {\n                nr = (nr + 1) % 4;\n            }\n            if (keyDown(K_W)) {\n                npos.y += 1;\n            }\n            if (keyDown(K_S)) {\n                npos.y -= 1;\n            }\n            if ((keyClick(K_D)) && (iFrame % 4 == 0)) {\n                npos.x += 1;\n            }\n            mat4 bm = rotate(stone_pattern(bs), nr);\n            bool blocked = false;\n            for (int y = 0; y < 4; ++y) {\n                for (int x = 0; x < 4; ++x) {                \n                    ivec2 c = npos + ivec2(x,y);\n                    if ((bm[y][x] > 0.5)\n                        && ((c.y < 0)\n                        || (c.y >= FIELDSIZE.y)\n                        || (texelFetch(iChannel0, c, 0).r > 0.5))) {\n                        blocked = true;\n                    }\n                }\n            }            \n            if (!blocked) {\n                mem.xy = vec2(npos);\n                mem.z = float(nr);\n            }\n        } else if (uv == WSTATE) {\n            // y collision check            \n            ivec2 npos = ivec2(wstate.xy);\n            int nr = wr;\n            if (keyDown(K_RIGHT)) {\n                nr = (nr + 1) % 4;\n            }\n            if (keyDown(K_UP)) {\n                npos.y += 1;\n            }\n            if (keyDown(K_DOWN)) {\n                npos.y -= 1;\n            }\n            if ((keyClick(K_LEFT)) && (iFrame % 4 == 0)) {\n                npos.x -= 1;\n            }\n            mat4 bm = rotate(stone_pattern(ws), nr);\n            bool blocked = false;\n            for (int y = 0; y < 4; ++y) {\n                for (int x = 0; x < 4; ++x) {                \n                    ivec2 c = npos + ivec2(x,y);\n                    if ((bm[y][x] > 0.5)\n                        && ((c.y < 0)\n                        || (c.y >= FIELDSIZE.y)\n                        || (texelFetch(iChannel0, c, 0).r < 0.5))) {\n                        blocked = true;\n                    }\n                }\n            }            \n            if (!blocked) {\n                mem.xy = vec2(npos);\n                mem.z = float(nr);\n            }            \n        }\n        if (uv == BWCLIP) {\n            // find cleared rows\n            mem = vec4(0);\n            if (bset) {\n                mat4 bm = rotate(stone_pattern(bs), br);\n                ivec2 npos = ivec2(bstate.xy);   \n                int minrow = FIELDSIZE.x;\n                int maxrow = -1;\n                for (int x = 0; x < 4; ++x) {\n                    bool hastile = false;\n                    bool complete = true;\n                    int xrow = npos.x + x;\n                    for (int y = 0; y < FIELDSIZE.y; ++y) {\n                        ivec2 coord = ivec2(x, y - npos.y);\n                        if (coord.y >= 0 && coord.y < 4 && bm[coord.y][coord.x] > 0.5) {\n                            hastile = true;\n                            continue;\n                        } else if (texelFetch(iChannel0, ivec2(xrow, y), 0).r > 0.5) {\n                            continue;\n                        } else {\n                            complete = false;\n                            break;\n                        }\n                    }\n                    if (complete && hastile) {\n                        minrow = min(minrow, xrow);\n                        maxrow = max(maxrow, xrow);\n                    }\n                }\n                if (minrow <= maxrow) {\n                    mem.xy = vec2(maxrow, maxrow - minrow + 1);\n                }            \n            }\n            if (wset) {\n                mat4 bm = rotate(stone_pattern(ws), wr);\n                ivec2 npos = ivec2(wstate.xy);\n                int minrow = FIELDSIZE.x;\n                int maxrow = -1;\n                for (int x = 0; x < 4; ++x) {\n                    bool hastile = false;\n                    bool complete = true;\n                    int xrow = npos.x + x;\n                    for (int y = 0; y < FIELDSIZE.y; ++y) {                        \n                        ivec2 coord = ivec2(x, y - npos.y);\n                        if (coord.y >= 0 && coord.y < 4 && bm[coord.y][coord.x] > 0.5) {\n                            hastile = true;\n                            continue;\n                        } else if (texelFetch(iChannel0, ivec2(xrow, y), 0).r < 0.5) {\n                            continue;\n                        } else {\n                            complete = false;\n                            break;\n                        }\n                    }\n                    if (complete && hastile) {\n                        minrow = min(minrow, xrow);\n                        maxrow = max(maxrow, xrow);\n                    }\n                }\n                if (minrow <= maxrow) {\n                    mem.zw = vec2(minrow, maxrow - minrow + 1);\n                }            \n            }\n        }\n        if ((uv.x < FIELDSIZE.x) && (uv.y < FIELDSIZE.y)) {\n            ivec4 cl = ivec4(bwclip);\n            if ((cl.y > 0) && (uv.x <= cl.x)) {\n                if ((uv.x - cl.y) < 0)\n                    mem.r = 0.0;\n                else\n                    mem.r = texelFetch(iChannel0, ivec2(uv.x - cl.y, uv.y), 0).r;\n            }\n            if ((cl.w > 0) && (uv.x >= cl.z)) {\n                if ((uv.x + cl.w) >= FIELDSIZE.x)\n                    mem.r = 1.0;\n                else                \n                    mem.r = texelFetch(iChannel0, ivec2(uv.x + cl.w, uv.y), 0).r;\n            }\n            mem.g = 0.0;\n            if (bs != STONE_NONE) {\n                mat4 bm = rotate(stone_pattern(bs), br);\n                ivec2 coord = uv - ivec2(bstate.xy);\n                if (min(coord.x, coord.y) >= 0 && max(coord.x, coord.y) < 4 && bm[coord.y][coord.x] > 0.5) {\n                    if (bset)\n                        mem.r = 1.0;\n                    else\n                        mem.g = 1.0;\n                    \n                }\n            }\n            if (ws != STONE_NONE) {\n                mat4 bm = rotate(stone_pattern(ws), wr);\n                ivec2 coord = uv - ivec2(wstate.xy);\n                if (min(coord.x, coord.y) >= 0 && max(coord.x, coord.y) < 4 && bm[coord.y][coord.x] > 0.5) {\n                    if (wset)\n                        mem.r = 0.0;\n                    else\n                        mem.g = 1.0;\n                    \n                }\n            }\n        }\n        fragColor = mem;\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// 48 x 10: board\n// row 11 holds stone state\n\n#define FIELDSIZE ivec2(48, 10)\n#define BSTATE ivec2(0, 11)\n#define WSTATE ivec2(1, 11)\n#define BWCLIP ivec2(2, 11)\n\n#define STONE_NONE 0\n#define STONE_I 1\n#define STONE_O 2\n#define STONE_S 3\n#define STONE_Z 4\n#define STONE_T 5\n#define STONE_L 6\n#define STONE_R 7\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSSDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 480]]}
{"id": "fdBXWw", "name": "Kaleido Lissajous with Rotation", "author": "IWBTShyGuy", "description": "Rotation with Kaleido Lissajous ([url]https://www.shadertoy.com/view/7d2XWD[/url])\n\nKey R -> Clear the screen", "tags": ["kaleidoscope", "lissajous"], "likes": 4, "viewed": 267, "published": 3, "date": "1620310942", "time_retrieved": "2024-07-30T19:21:35.453638", "image_code": "// Copyright © 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float PI = 3.141592653;\nconst int CUFFS = 36;\n\nconst vec2 sig = vec2(-1, 1);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float c = 0.0;\n    for (int i = 0; i < CUFFS; i++) {\n        float t = 2.0 * PI * float(i) / float(CUFFS) + 0.1 * iTime * sig[i % 2];\n        vec2 tuv = clamp(mat2(cos(t), sin(t), -sin(t), cos(t)) * uv, -1.0, 1.0);\n        vec2 tCoord = (tuv * iResolution.y + iResolution.xy) / 2.0;\n        c = max(c, texture(iChannel0, tCoord / iResolution.xy).x);\n    }\n    fragColor = vec4(c, c, c, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Copyright © 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float X_VELO = 0.5;\nconst float Y_VELO = 0.7;\n\nbool isKeyDown(int code) {\n    return texelFetch(iChannel1, ivec2(code, 0), 0).x > 0.0;\n}\nconst int Key_R = 82;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0 || isKeyDown(Key_R)) {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 point = vec2(cos(X_VELO * iTime), sin(Y_VELO * iTime)) * 0.7;\n    float c = max(sign(0.002 - distance(uv, point)), 0.0);\n    c = max(c, texture(iChannel0, fragCoord / iResolution.xy).x);\n    fragColor = vec4(c, c, c, 1);\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBXWw.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[162, 162, 217, 217, 679]]}
{"id": "wdtfzs", "name": "comp. time opt. gaussian blur", "author": "frhun", "description": "This is my attempt at writing a single pass gaussian blur, that takes advantage of the loop unrolling the compiler will do when it has enough data to do it at compile time. (This only works as long as the blur strength is known at compile time)", "tags": ["blur", "compiler"], "likes": 0, "viewed": 298, "published": 3, "date": "1620309885", "time_retrieved": "2024-07-30T19:21:36.212609", "image_code": "\nconst float EULER = 2.71828;\nconst float PI = 3.14159;\nconst float TAU = 6.28319;\n\n//#define FASTGAMMA //fast is relative; on RDNA for example it saves 12 cycles per operation\n\n//My naive blur implementation, it is just what i came up with without thinking too much\n//or looking how people that actually know what they're doing do it\n// - displayed to the right of the mouse pointer -\nvec4 naiveBlur(sampler2D input_samp, vec2 center, vec2 sampleDist, float samplesPerDir, bool gammaCorrect){\n\tvec4 col_samples;\n    int noOfSamples = 0;\n    for(float rp_i_y = 0.; rp_i_y < samplesPerDir; rp_i_y++){\n        for(float rp_i_x = 0.; rp_i_x < samplesPerDir; rp_i_x++){\n            vec2 unscaled_rel_pos = vec2( (rp_i_x - (samplesPerDir/2.)),\n                                         (rp_i_y - (samplesPerDir/2.)));\n            if(length(unscaled_rel_pos) <= (samplesPerDir/2.)){\n                noOfSamples++;\n                vec4 col_sample = texture(input_samp, center - sampleDist*\n                                          unscaled_rel_pos\n                                       );\n                if(!gammaCorrect)\n                    col_samples += col_sample;\n                else\n                    #ifdef FASTGAMMA\n                    col_samples += vec4(col_sample.rgb*col_sample.rgb, col_sample.a);\n                    #else\n                    col_samples += vec4(pow(col_sample.rgb, vec3(2.2)), col_sample.a);\n                    #endif\n            }\n            \n        }\n    }\n    col_samples /= float(noOfSamples);\n    if(!gammaCorrect)\n        return col_samples;\n    else\n        #ifdef FASTGAMMA\n        return vec4(pow(col_samples.rgb, vec3(1./2.2)), col_samples.a);\n    \t#else\n    \treturn vec4(sqrt(col_samples.rgb), col_samples.a);\n    \t#endif\n}\n\nfloat gaussianWeight(float sigma, vec2 relPos){\n    /* //correct version, with no (noticeable) impact on the result\n \treturn (\n        (1./(TAU * sigma * sigma)) *\n        pow(EULER,\n            -((relPos.x * relPos.x + relPos.y * relPos.y)/(2. * sigma * sigma))\n           )\n           );\n\t*/\n    return ( pow(\n        EULER,\n            -((relPos.x * relPos.x + relPos.y * relPos.y)/(2. * sigma * sigma)))\n           );\n}\n\nvec4 gaussianBlur(sampler2D input_samp, vec2 center, vec2 sampleDist, float samplesPerDir, bool gammaCorrect){\n\tvec4 col_samples = vec4(0.);\n    float sigma = samplesPerDir * 0.2;\n    \n    float cutoffWeight = gaussianWeight(\n        sigma,\n        vec2(\n            ((samplesPerDir-1.)/2.),\n            fract(mod(samplesPerDir - 1., 2.)/2. )\n        ) \n    );\n    float totalWeights = 0.;\n    \n    for(float rp_i_y = 0.; rp_i_y < samplesPerDir; rp_i_y++){\n        for(float rp_i_x = 0.; rp_i_x < samplesPerDir; rp_i_x++){\n    \t\tvec2 relPos = vec2( (rp_i_x - ((samplesPerDir-1.)/2.)),\n                                (rp_i_y - ((samplesPerDir-1.)/2.)));\n            float weight = gaussianWeight(sigma, relPos);\n            //only count the sample when the result will significantly affect the\n            //end result; unnessecairy passes should be optimized away at compile time\n            if(weight > cutoffWeight){\n                totalWeights += weight;\n                vec4 col_sample = texture(input_samp, center - relPos * sampleDist);\n                if(!gammaCorrect)\n                    col_samples += weight * col_sample;\n                else\n                    #ifdef FASTGAMMA\n                    col_samples += weight * vec4(col_sample.rgb*col_sample.rgb, col_sample.a);\n                    #else\n                    col_samples += weight * vec4(pow(col_sample.rgb, vec3(2.2)), col_sample.a);\n                    #endif\n            }\n        }\n    }\n    \n    col_samples /= totalWeights;\n    if(!gammaCorrect)\n        return col_samples;\n    else\n        #ifdef FASTGAMMA\n        return vec4(pow(col_samples.rgb, vec3(1./2.2)), col_samples.a);\n    \t#else\n    \treturn vec4(sqrt(col_samples.rgb), col_samples.a);\n    \t#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tbool in_mouse_range = length(fragCoord-iMouse.xy) < 70.;\n    if(length(fragCoord-iMouse.xy) < 20.){\n        fragColor =  texture(iChannel0, uv);\n        return;\n    }\n    if(in_mouse_range && fragCoord.x > iMouse.x){\n        fragColor = naiveBlur(iChannel0, uv.xy, 1./iResolution.xy, 30., in_mouse_range);\n        return;\n    }\n    \n    fragColor = gaussianBlur(iChannel0, uv.xy, 1./iResolution.xy, 30., !in_mouse_range);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy*0.5))*2./max(iResolution.x, iResolution.y);\n    float effx = uv.x - (sin(iTime));\n    bool beblk = effx < 0.1 && effx > 0.;\n    vec3 col1 = texture(iChannel0, fragCoord.xy/iResolution.xy).xyz;\n    vec3 col2 = vec3(0.1, 0.9, 0.1);\n    vec3 col3 = vec3(0.9, 0.1, 0.1);\n    vec3 col4 = vec3(0.1, 0.1, 0.9);\n    vec3 col = col1;\n    if(beblk)\n        col = col2;\n    if(length(uv) < 0.3 && !(beblk && cos(iTime)>0.))\n        col = col3;\n    float pointdist = length(uv-vec2(0.3, 0.1));\n    float linedist = sin(iTime*1.2)*0.5+0.5;\n    if(pointdist > linedist && pointdist < linedist + 0.1)\n        col = col4;\n    fragColor = vec4(col, 1.);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1768, 1768, 1815, 2061, 2191], [3936, 3936, 3993, 4043, 4508]]}
{"id": "7d2XWD", "name": "Kaleido Lissajous", "author": "IWBTShyGuy", "description": "Key R -> Clear the screen", "tags": ["kaleidoscope", "lissajous"], "likes": 1, "viewed": 247, "published": 3, "date": "1620298851", "time_retrieved": "2024-07-30T19:21:36.965596", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Copyright © 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float PI = 3.141592653;\n\nconst int CUFFS = 72;\nconst float X_VELO = 1.1;\nconst float Y_VELO = 0.7;\n\n\nbool isKeyDown(int code) {\n    return texelFetch(iChannel1, ivec2(code, 0), 0).x > 0.0;\n}\nconst int Key_R = 82;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0 || isKeyDown(Key_R)) {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    bool drawn = false;\n\n    vec2 point = vec2(cos(X_VELO * iTime), sin(Y_VELO * iTime)) * 0.7;\n\n    for (int i = 0; i < CUFFS; i++) {\n        float t = 2.0 * PI * float(i) / float(CUFFS);\n        vec2 c = mat2(cos(t), sin(t), -sin(t), cos(t)) * point;\n        drawn = drawn || distance(c, uv) < 0.002;\n    }\n\n    if (drawn) {\n        fragColor = vec4(1);\n    } else {\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2XWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 123]]}
{"id": "wlyBWV", "name": "Calm line beings", "author": "eimink", "description": "Maybe dj visuals maybe?", "tags": ["sdf"], "likes": 4, "viewed": 331, "published": 3, "date": "1620292879", "time_retrieved": "2024-07-30T19:21:37.814326", "image_code": "\nconst float E = 0.001;\nconst float FAR = 40.0;\nconst int STEPS = 64;\n\nvec3 glow = vec3(0.0);\n\nfloat sphere (vec3 p, float s)\n{\n    return length(p)-s;\n}\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(41,157,353);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvoid rot(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat box (vec3  p, vec3 r){\n    vec3 d = abs(p) - r;\n    return length(max(d,0.0) + min(max(d.x, max(d.y, d.z)), 0.0));\n}\n\nfloat oct( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec3 twistz(vec3 p, float k) {\n    float c = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat scene(vec3 p){\n    vec3 pp = p;\n    for (int i = 0; i < 2; ++i) {\n        pp = abs(pp) - vec3(4.0,3.0,5.0);\n        rot(pp.xy,iTime*0.1);\n        rot(pp.yz,iTime*0.01);\n    }\n    float a = oct(pp, 1.0)+noise(pp);\n    float b = oct(twistz(pp,cos(iTime)), 3.0)+noise(pp);\n    float c = box(twistz(pp,.1), vec3(6.0,8.0,12.0))+noise(p);\n    if (mod(p.z,2.) <= 1.) {\n            glow += vec3(.0,.0,.1)*0.001/(0.01+abs(c));\n        }\n    glow += vec3(0.2, 0.1, 0.6)*0.1 / (0.01+abs(b));\n    glow += vec3(.4,0.1,0.1)*0.01 / (0.01+abs(a));\n    return min(c,max(a,b))+noise(p);\n}\n\nfloat march(in vec3 ro, in vec3 rd, out vec3 p)\n{\n    p = ro;\n    float t = E;\n    for (int i = 0; i < STEPS; ++i) {\n        float d = scene(p);\n        t += d;        \n        if (d < E || t > FAR) {\n            break;\n        }\n        p -= rd*d;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cp = vec3(0, 0, 2);\n    vec3 ct = vec3(0,0,-1);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 cf = normalize(ct-cp);\n    vec3 cr = normalize(cross(vec3(0.0,1.0,0.0),cf));\n    vec3 cu = normalize(cross(cf,cr));\n    \n    vec3 rd = normalize(mat3(cr,cu,cf)*vec3(q,radians(60.0)));\n    \n    vec3 p = vec3(0.0);\n    \n    float t = march(cp,rd,p);\n\n    vec3 col = vec3(0.0);\n    if(t < FAR){\n        col = vec3(0.2,0.6,0.8);\n    }\n    \n    col += glow;\n    //col *= (1.0-vec3(t/FAR));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlyBWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 127, 127, 153], [155, 155, 176, 176, 427], [429, 429, 462, 462, 507], [509, 509, 537, 537, 631], [633, 633, 662, 662, 715], [717, 717, 747, 747, 860], [862, 862, 882, 882, 1438], [1440, 1440, 1489, 1489, 1710], [1713, 1713, 1770, 1770, 2396]]}
{"id": "sd2SWW", "name": "Complex Fibonacci: Binet Formula", "author": "oneshade", "description": "The binet formula in the complex plane and its roots (the fibonacci numbers).\nTODO: use smarter distance-to-parametric method", "tags": ["complex", "fibonacci", "formula", "binet"], "likes": 10, "viewed": 207, "published": 3, "date": "1620285690", "time_retrieved": "2024-07-30T19:21:38.572300", "image_code": "// I've had Matt Parker's video in the back of my head for a while:\n// https://www.youtube.com/watch?v=ghxQA3vvhsk\n\n#define PI 3.14159265359\n#define PHI 1.6180339887 // (1 + sqrt(5)) / 2\n\n#define PLOT_RES 150.0\n\nfloat remap(in float n) {\n    return mix(4.333 * sin(iTime * 0.25), 4.333, n);\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvec2 complexFibonacci(in float n) {\n    float k = pow(PHI, n), np = n * PI;\n    return vec2(k - cos(np) / k, -sin(np) / k) / sqrt(5.0);\n}\n\n// Only defined for integers\nfloat realFibonacci(in float n) {\n    return (pow(PHI, n) - pow(-1.0 / PHI, n)) / sqrt(5.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    vec2 prevPos = complexFibonacci(remap(0.0));\n    float tStep = 1.0 / PLOT_RES;\n    for (float t=tStep; t < 1.0 + tStep; t += tStep) {\n        vec2 curPos = complexFibonacci(remap(t));\n        color = mix(color, vec3(0.8, 0.0, 0.0), smoothstep(unit, 0.0, sdLine(uv, prevPos, curPos)));\n        prevPos = curPos;\n    }\n\n    for (float n=-4.0; n < 5.0; n++) {\n        float fib = realFibonacci(n);\n        color = mix(color, vec3(0.0), smoothstep(unit, 0.0, length(vec2(uv.x - fib, uv.y)) - 0.05));\n    }\n\n    uv *= 0.25;\n    float dd = dot(uv, uv);\n    color -= 0.6 * dd * dd;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2SWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 237, 237, 292], [294, 294, 341, 341, 466], [468, 468, 503, 503, 605], [607, 636, 669, 669, 730], [732, 732, 787, 787, 1542]]}
{"id": "7sjSWW", "name": "Laplacian of texture - 2", "author": "FabriceNeyret2", "description": "playing with the width of the Laplacian filter.\nLeft: reference   Laplacian    Right: approx with MIPmap", "tags": ["bench", "laplacing", "hardwarederivative"], "likes": 6, "viewed": 325, "published": 3, "date": "1620285580", "time_retrieved": "2024-07-30T19:21:39.320300", "image_code": "// variant of https://shadertoy.com/view/fsSSDD\n\n\n#define lapl1    ( ( Txy(-1,0)+ Txy(1,0)+ Txy(0,-1)+ Txy(0,1) ) /4. - T(U,0.) )\n#define lapl2    9./8.* ( T(U,lod) - T(U,0.) )    // approx Laplacian using MIPmap LOD difference\n                                                  // 9/8 because T(1) includes a bit of T(0) ;-)\n#define T(U,l)   texture( iChannel0, (U)*R/size, l+0. ) \n#define Txy(x,y)   T( U+vec2(x,y)/R*width, 0. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,  U = u/R;\n\nfloat size = 256.,                // scale of left texture\n      lod  = 3.*(1.+sin(iTime)),  // width of outlines\n      width = exp2(lod);\n      \n    O = .5 + ( U.x < .5 ?  lapl1 : lapl2 ) *16. / width;\n    if ( abs( fract(2.*U.x)*R.x/2. -.5 ) < .5 ) O = vec4(0,0,1,1);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[431, 431, 469, 469, 781]]}
{"id": "NsjXDD", "name": "Laplacian of textures", "author": "FabriceNeyret2", "description": "Laplacian of textures / texture - Laplacian.", "tags": ["bench", "laplacing", "hardwarederivative"], "likes": 6, "viewed": 712, "published": 3, "date": "1620284154", "time_retrieved": "2024-07-30T19:21:40.176012", "image_code": "// variant of https://shadertoy.com/view/fsSSDD\n\nfloat width = 1.;  // try 2 for thicker outlines\n\n#define lapl1    ( ( Txy(-1,0)+ Txy(1,0)+ Txy(0,-1)+ Txy(0,1) ) /4. - T(U,0.) )\n#define lapl2    9./8.* ( T(U,1.) - T(U,0.) )    // approx Laplacian using MIPmap LOD difference\n                                                 // 9/8 because T(1) includes a bit of T(0) ;-)\n#define T(U,l)   ( I.x < 1. ? I.y < 1. ? texture(iChannel0, U,l)  \\\n                                       : texture(iChannel1, U,l)  \\\n                            : I.y < 1. ? texture(iChannel2, U,l)  \\\n                                       : texture(iChannel3, U,l)  )\n#define Txy(x,y)   T( U+vec2(x,y)*width/R, 0. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 I = U *= 2./R;\n    O = T(U,0.);\n    \n    O = vec4( lapl1.x) * 16.;   // or try lapl2                  // display laplacian( texture )\n // int t = int(iTime)%3;\n // O = vec4( ( t==0 ? lapl1 : t==1 ? lapl2 : 1.3*lapl1-lapl2 ) .x) * 16.;   \n    \n    if ( fract(iTime/4.) < .5 ) O = T(U,0.) - clamp(O,0.,1.);    // texture + outline\n           else                 O += .5;\n    \n    U = fract(2.*U)*R/4.;                                        // separators\n    if (abs (min(U.x,U.y) -.5 )< 1. ) O = vec4(0,0,1,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U *= 2./R;\n    O = U.x < 1. ? U.y < 1. ? texture(iChannel0, U)\n                            : texture(iChannel1, U)\n                 : U.y < 1. ? texture(iChannel2, U)\n                            : texture(iChannel3, U);\n}", "buffer_a_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy", "buffer_b_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U *= 2./R;\n    O = U.x < 1. ? U.y < 1. ? texture(iChannel0, U)\n                            : texture(iChannel1, U)\n                 : U.y < 1. ? texture(iChannel2, U)\n                            : texture(iChannel3, U);\n}", "buffer_b_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U *= 2./R;\n    O = U.x < 1. ? U.y < 1. ? texture(iChannel0, U)\n                            : texture(iChannel1, U)\n                 : U.y < 1. ? texture(iChannel2, U)\n                            : texture(iChannel3, U);\n}", "buffer_c_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define rot(a)         mat2( cos( a + vec4(0,11,33,0) ) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U *= 2./R;\n    vec3 D = vec3( fract(U)*2.-1., 1);\n    D.xy *= rot(.3*iTime);\n    D.yz *= rot(.3*iTime);\n    \n    O = U.x < 1. ? U.y < 1. ? texture(iChannel0, U)\n                            : texture(iChannel1, D)\n                 : U.y < 1. ? texture(iChannel2, D)\n                            : texture(iChannel3, D);\n}", "buffer_d_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjXDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[693, 693, 731, 731, 1253]]}
{"id": "NdjXDD", "name": "Plot tool", "author": "ttg", "description": "I found myself repeatedly editing down [url]https://www.shadertoy.com/view/3t3XWf[/url] to just the basic plot for checking GLSL expressions.  Here's the minimal starting point.", "tags": ["plot", "util", "macro"], "likes": 3, "viewed": 364, "published": 3, "date": "1620282026", "time_retrieved": "2024-07-30T19:21:41.024743", "image_code": "// copied from shadertoy.com/view/3t3XWf by ttg\n// see it for examples of PLOT_ macro modes and styles.\n\nconst float pi = 3.1415927;\n\nvoid mainImage( out vec4 fragData, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(1.);\n    \n    float xmin = -8.,\n          xmax =  8.,\n          ymin = -2.,\n          ymax =  2. ;\n\n    mat2 domain = mat2(xmin,ymin,xmax,ymax);\n    \n    mat2 window = mat2(0,0,1,1);\n\n    //                     window,domain,color,side,blend,linewidth, expression...\n    PLOT_CONTINUOUS(col,uv,window,domain,vec3(0), 0, 0, 0.02, sin(x*2.) );\n\n    fragData = vec4(pow(col,vec3(1./2.2)),0);\n}\n", "image_inputs": [], "common_code": "\n/* \n\nExpression Plotter\n\nUsage: PLOT_CONTINUOUS( fragColor, uv, window, domain,\n                        linecolor, side, blend, linewidth, expression );\n\n  fragColor - output (linear RGB)\n  uv - coordinate system for window\n  window - mat2, first col: window corner, second col: window size\n  domain - mat2, first col: min x,y, second col: max x,y\n  linecolor - RGB\n  side - 0 = line, 1 = below, -1 = above (see demo)\n  blend - 0=paint, 1=light-trace, 2=ink (see demo)\n  linewidth - measured in units of uv.x; only for side=0\n  expression - uses x as the independent variable\n\nThis file may be used and copied under the terms of the ISC License;\nsee end of file.  As an exception, the full permission notice may be\nomitted where this file is copied within Shadertoy and the full URL,\n\"https://www.shadertoy.com/view/3t3XWf\", is displayed within the source.\n\n*/\n\n\n\n// https://www.shadertoy.com/view/3t3XWf by ttg\nvoid PLOT_CONTINUOUS_CHECK_ARGS(inout vec3 fcolor, vec2 fcoord, mat2 window,\n  mat2 domain, vec3 color, int side, int blend, float linewidth) {}\n#define PLOT_CONTINUOUS(_fcolor, _Afcoord, _Awindow, \\\n  _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth, _function) \\\n  { \\\n    PLOT_CONTINUOUS_CHECK_ARGS(_fcolor, _Afcoord, _Awindow, \\\n      _Adomain, _Acolor, _Aside, _Ablend, _Alinewidth); \\\n    vec2 _fcoord = (_Afcoord); \\\n    mat2 _window = (_Awindow); \\\n    mat2 _domain = (_Adomain); \\\n    vec3 _color = (_Acolor); \\\n    int _side = (_Aside); \\\n    int _blend = (_Ablend); \\\n    float _alinewidth = (_Alinewidth); \\\n    vec2 _rcoord = _fcoord-_window[0]; \\\n    vec2 _res = _window[1]/(_domain[1]-_domain[0])/ \\\n        vec2(dFdx(_fcoord.x),dFdy(_fcoord.y)); \\\n    float _linerpa = min(10.,(_alinewidth*_res.x)*.5); \\\n    float _linerp = max(.5,_linerpa); \\\n    if (all(bvec4(greaterThan(_rcoord,vec2(0)), \\\n                  lessThan(_rcoord,_window[1])))) { \\\n      float _pixmixsum = 0.; \\\n      int _passes = 0; \\\n      if (_side==0) _passes = min(10,int(floor(_linerp))); \\\n      vec2 _x = _rcoord/_window[1]*(_domain[1]-_domain[0])+_domain[0]; \\\n      float _ylast; \\\n      for (int _i = -_passes-1; _i <= _passes; _i++) { \\\n        float offset = float(_i) ; \\\n        vec2 _x = _x + vec2(1,0)*offset/_res; \\\n        float _dx = .5/_res.x; \\\n        float _y1, _y2, _ddx; \\\n        float x = _x.x+_dx; _y1 = (_function); \\\n        _y2 = _ylast; _ylast = _y1; \\\n        if (_i==-_passes-1) continue; \\\n        _ddx = ((_y1-_y2)/(_dx*2.))*_res.y/_res.x; \\\n        float _y = (_y1+_y2)/2.; \\\n        float hdiff = (_y-_x.y) *_res.y; \\\n        if (_side==0) hdiff = \\\n          .7*(abs(hdiff)+.5-_linerp*sqrt(1.-pow(offset/_linerp,2.))); \\\n        float pixmix = hdiff/sqrt(1.+_ddx*_ddx); \\\n        if (_side!=0) pixmix = pixmix*sign(float(_side))+0.5; \\\n        if (_side==0) pixmix = 1.-pixmix; \\\n        pixmix = clamp(pixmix,0.,1.); \\\n        if (_blend==1 && _side==0) pixmix /= sqrt(1.+_ddx*_ddx); \\\n        if (_passes!=0 && abs(_i)==_passes) pixmix *= fract(_linerp); \\\n        if (_side==0) pixmix *= \\\n          1./(1.+max(0.,_linerp-2.)/pow(1.+_ddx*_ddx,2.0)); \\\n        _pixmixsum += pixmix; \\\n      } \\\n      if (_blend!=1) _pixmixsum = clamp(_pixmixsum,0.,1.); \\\n      if (_side==0 && _linerpa<.5) _pixmixsum*=max(0.,_linerpa*2.); \\\n      if (_blend==0) _fcolor = mix( _fcolor, _color, _pixmixsum ); \\\n      if (_blend==1) _fcolor = _fcolor + _color*_pixmixsum; \\\n      if (_blend==2) _fcolor = _fcolor * mix( vec3(1.), _color, _pixmixsum ); \\\n      _fcolor = max(vec3(0.), _fcolor); \\\n    } \\\n  }\n\n\n\n/*\nCopyright 2020 Theron Tarigo\n\nPermission to use, copy, modify, and/or distribute this software for any \npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH \nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n*/\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjXDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 190, 190, 642]]}
{"id": "sdBSDW", "name": "Bad Video", "author": "paniq", "description": "4:3 Letterboxing, Trinitron scanlines, NTSC interlace effects, YIQ clamp and shift, IQ noise, bad tracking. Try the other videos as well.", "tags": ["video", "ntsc", "degradation"], "likes": 39, "viewed": 1409, "published": 3, "date": "1620229561", "time_retrieved": "2024-07-30T19:21:41.930321", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 rez = TVREZ;\n    \n    vec2 uvscale = rez / iResolution.xy;\n    \n    vec2 uv = (fragCoord / iResolution.xy);// * vec2(iResolution.x / iResolution.y,1);\n    \n    \n\n    vec3 col = texture(iChannel0, uv * uvscale).rgb;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// RGB <-> FCC YIQ conversion as defined in\n// https://en.wikipedia.org/wiki/YIQ\nvec3 rgb_fccyiq(vec3 rgb) {\n    float Y = 0.3 * rgb.r + 0.59 * rgb.g + 0.11 * rgb.b;\n    float Q = 0.41 * (rgb.b - Y) + 0.48 * (rgb.r - Y);\n    float I = -0.27 * (rgb.b - Y) + 0.74 * (rgb.r - Y);\n    return vec3(Y, I, Q);\n}\n\nvec3 fccyiq_rgb(vec3 yiq) {\n    return vec3(\n        yiq[0] + 0.9469 * yiq[1] + 0.6236 * yiq[2],\n        yiq[0] - 0.2748 * yiq[1] - 0.6357 * yiq[2],\n        yiq[0] - 1.1 * yiq[1] + 1.7 * yiq[2]\n    );\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// after http://forums.nesdev.com/viewtopic.php?f=21&t=15125\nvec3 video_degraded_3x3(sampler2D src, ivec2 fc, vec2 res) {  \n    vec3 n0 = hash33(vec3(vec2(fc),iFrame*3));\n    vec3 n1 = hash33(vec3(vec2(fc)*vec2(0.00001,1),iFrame*3+1));\n    vec3 n2 = hash33(vec3(vec2(fc)*vec2(0.000001,1),iFrame*3+2));\n    vec3 n = ((n0 + n1 + n2) / 3.0);\n    vec3 q = hash33(vec3(iFrame));\n    n.xy = n.xy*2.0 - 1.0;\n    float y = 1.0 - mod(float(fc.y - iFrame/2) / res.y,1.0);\n    float namp = max(0.1, pow(1.0 - y, 4.0))*0.5;\n    vec2 uv = (vec2(fc) - vec2(pow(1.0 - y, 80.0)*(70.0 - q.x*70.0)*40.0 + pow(y, 20.0)*(10.0 - q.x*10.0), 0)) / res;\n    vec2 uvd = vec2(2.0, 0) / res;\n    float Y = rgb_fccyiq(texture(src, uv).rgb)[0] + pow(n0.z*0.5+0.5,2.0)*0.1;\n    float Yx = (1.0 - clamp(abs(min(pow(y,0.25)*2.0,(0.999 - y)*200.0)), 0.0, 1.0))*step(0.3,n.x)*2.0;\n    const float cr = 0.18;\n    float ca = 0.7 * (1.0 - pow(1.0 - y, 2.0));\n    float I = mix(clamp(rgb_fccyiq(texture(src, uv + uvd).rgb)[1],-cr,cr)*ca,n.x,namp);\n    float Q = mix(clamp(rgb_fccyiq(texture(src, uv - uvd).rgb)[2],-cr,cr)*ca,n.y,namp);\n    vec3 texcolor = fccyiq_rgb(vec3(Y,I,Q));\n    int channel = (fc.x + fc.y) % 3;\n    vec3 col = vec3(0.0);    \n    col[channel] = texcolor[channel];\n    return mix(col, vec3(Yx), pow(1.0 - y, 30.0));\n}\n\nvec3 video_degraded_3x3_conv111(sampler2D src, ivec2 fc, vec2 res) {\n    const int scale = 2;\n    fc /= scale;\n    res = res / float(scale);    \n    vec3 col0 = video_degraded_3x3(src, fc + ivec2(-1,0), res);\n    vec3 col1 = video_degraded_3x3(src, fc, res);\n    vec3 col2 = video_degraded_3x3(src, fc + ivec2(1,0), res);\n    return col0 + col1 + col2;\n}\n\nvec3 bad_video(sampler2D src, ivec2 fc, vec2 res) {\n    vec3 p = vec3(0.0);\n    for (int y = -1; y <= 1; ++y) {\n        for (int x = -2; x <= 2; ++x) {\n            p += video_degraded_3x3_conv111(iChannel0, fc + ivec2(x,y), res);\n        }\n    }\n    return p / 15.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 rez = TVREZ;\n    vec2 uv = (fragCoord / rez) * vec2(rez.x / rez.y,1);\n    vec2 vaspect = iChannelResolution[0].xy / rez;\n    vec3 col;\n    if (abs((fragCoord.x / rez.x)*2.0-1.0) > (3.0/4.0))\n        col = vec3(0.0);\n    else\n        col = bad_video(iChannel0, ivec2(fragCoord), rez) * (((int(fragCoord.y) & 1) == 1)?0.707:1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TVREZ vec2(640, 360)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBSDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 409]]}
{"id": "7sBXWW", "name": "girl bunny -dragon", "author": "jorge2017a1", "description": "girl bunny -dragon", "tags": ["points", "poly", "girlbunnydragon", "2ddraw"], "likes": 7, "viewed": 345, "published": 3, "date": "1620220716", "time_retrieved": "2024-07-30T19:21:42.967548", "image_code": "//por jorge2017a1 ----jorgeFloresP---5/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly32 POLY(32)\nvec2 pt32[ 32]=vec2[](  \nvec2(.54,.79),vec2(.29,.65),vec2(.29,.60),vec2(.29,.60),vec2(.29,.59),\nvec2(.27,.60),vec2(.25,.60),vec2(.24,.59),vec2(.24,.57),vec2(.24,.54),\nvec2(.25,.53),vec2(.28,.52),vec2(.29,.51),vec2(.31,.50),vec2(.32,.51),\nvec2(.34,.51),vec2(.36,.51),vec2(.36,.49),vec2(.37,.48),vec2(.45,.45),\nvec2(.48,.44),vec2(.51,.44),vec2(.54,.45),vec2(.61,.48),vec2(.63,.50),\nvec2(.65,.51),vec2(.65,.53),vec2(.67,.61),vec2(.67,.62),vec2(.68,.65),\nvec2(.69,.68),vec2(.54,.79) );\n\nfloat sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.26,.52),vec2(.28,.47),vec2(.29,.42),vec2(.30,.38),vec2(.34,.33),\nvec2(.38,.27),vec2(.39,.28),vec2(.39,.38),vec2(.37,.45),vec2(.36,.49),\nvec2(.26,.52) );\n\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.67,.61),vec2(.70,.62),vec2(.70,.52),vec2(.70,.45),vec2(.69,.40),\nvec2(.66,.34),vec2(.63,.29),vec2(.60,.27),vec2(.61,.30),vec2(.62,.33),\nvec2(.62,.36),vec2(.60,.34),vec2(.57,.33),vec2(.59,.36),vec2(.62,.41),\nvec2(.62,.45),vec2(.62,.59),vec2(.67,.61) );\n\nfloat sdPoly24 POLY(24)\nvec2 pt24[ 24]=vec2[](  \nvec2(.11,.45),vec2(.16,.46),vec2(.26,.47),vec2(.66,.61),vec2(.70,.62),\nvec2(.73,.63),vec2(.76,.65),vec2(.78,.67),vec2(.77,.71),vec2(.75,.75),\nvec2(.71,.79),vec2(.65,.82),vec2(.51,.86),vec2(.44,.87),vec2(.36,.86),\nvec2(.27,.83),vec2(.22,.79),vec2(.18,.74),vec2(.17,.66),vec2(.17,.59),\nvec2(.18,.57),vec2(.17,.54),vec2(.15,.49),vec2(.11,.45) );\n\nfloat sdPoly11b POLY(11)\nvec2 pt11b[ 11]=vec2[](  \nvec2(.33,.76),vec2(.25,.92),vec2(.24,.96),vec2(.25,1.00),vec2(.45,1.00),\nvec2(.40,.96),vec2(.40,.95),vec2(.39,.94),vec2(.40,.93),vec2(.41,.80),\nvec2(.33,.76) );\n\nfloat sdPoly11c POLY(11)\nvec2 pt11c[ 11]=vec2[](  \nvec2(.54,.82),vec2(.61,.99),vec2(.62,1.00),vec2(.83,1.00),vec2(.76,.96),\nvec2(.74,.94),vec2(.72,.93),vec2(.69,.88),vec2(.69,.86),vec2(.63,.80),\nvec2(.54,.82) );\n\nfloat sdPoly13 POLY(13)\nvec2 pt13[ 13]=vec2[](  \nvec2(.32,.75),vec2(.36,.78),vec2(.40,.80),vec2(.53,.82),vec2(.63,.80),\nvec2(.65,.78),vec2(.64,.77),vec2(.58,.79),vec2(.51,.79),vec2(.43,.78),\nvec2(.37,.76),vec2(.33,.74),vec2(.32,.75) );\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.58,.68),vec2(.59,.69),vec2(.61,.69),vec2(.63,.68),vec2(.63,.68),\nvec2(.61,.69),vec2(.59,.69),vec2(.58,.68),vec2(.58,.68) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.39,.67),vec2(.42,.68),vec2(.43,.68),vec2(.47,.67),vec2(.47,.67),\nvec2(.43,.68),vec2(.42,.68),vec2(.39,.68),vec2(.39,.67) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.37,.59),vec2(.46,.57),vec2(.45,.61),vec2(.44,.63),vec2(.42,.64),\nvec2(.39,.63),vec2(.37,.59) );\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.58,.58),vec2(.62,.58),vec2(.63,.59),vec2(.63,.61),vec2(.63,.63),\nvec2(.62,.63),vec2(.60,.63),vec2(.59,.63),vec2(.58,.61),vec2(.58,.58) );\n\nfloat sdPoly8 POLY(8)\nvec2 pt8[ 8]=vec2[](  \nvec2(.43,.58),vec2(.43,.60),vec2(.43,.61),vec2(.42,.63),vec2(.39,.63),\nvec2(.38,.62),vec2(.38,.59),vec2(.43,.58) );\n\nfloat sdPoly9c POLY(9)\nvec2 pt9c[ 9]=vec2[](  \nvec2(.57,.58),vec2(.61,.58),vec2(.62,.61),vec2(.61,.62),vec2(.60,.63),\nvec2(.59,.63),vec2(.58,.61),vec2(.58,.60),vec2(.57,.58) );\n\nfloat sdPoly11d POLY(11)\nvec2 pt11d[ 11]=vec2[](  \nvec2(.54,.57),vec2(.55,.56),vec2(.55,.55),vec2(.55,.55),vec2(.54,.54),\nvec2(.54,.54),vec2(.55,.55),vec2(.56,.55),vec2(.55,.56),vec2(.55,.57),\nvec2(.54,.57) );\n\nfloat sdPoly8b POLY(8)\nvec2 pt8b[ 8]=vec2[](  \nvec2(.49,.51),vec2(.51,.51),vec2(.52,.52),vec2(.53,.52),vec2(.54,.51),\nvec2(.53,.51),vec2(.51,.52),vec2(.49,.51) );\n\nfloat sdPoly9d POLY(9)\nvec2 pt9d[ 9]=vec2[](  \nvec2(.49,.51),vec2(.51,.51),vec2(.52,.51),vec2(.54,.51),vec2(.54,.51),\nvec2(.53,.50),vec2(.51,.50),vec2(.50,.51),vec2(.49,.51) );\n\nfloat sdPoly10b POLY(10)\nvec2 pt10b[ 10]=vec2[](  \nvec2(.31,.51),vec2(.33,.51),vec2(.34,.52),vec2(.35,.51),vec2(.36,.50),\nvec2(.36,.49),vec2(.34,.48),vec2(.33,.48),vec2(.31,.50),vec2(.31,.51) );\n\nfloat sdPoly9e POLY(9)\nvec2 pt9e[ 9]=vec2[](  \nvec2(.66,.54),vec2(.66,.54),vec2(.68,.54),vec2(.69,.53),vec2(.68,.52),\nvec2(.67,.51),vec2(.66,.51),vec2(.65,.51),vec2(.66,.54) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.25,.57),vec2(.25,.59),vec2(.26,.59),vec2(.27,.59),vec2(.29,.57),\nvec2(.29,.55),vec2(.30,.54),vec2(.31,.53),vec2(.29,.53),vec2(.28,.53),\nvec2(.25,.54),vec2(.25,.57) );\n\nfloat sdPoly29 POLY(29)\nvec2 pt29[ 29]=vec2[](  \nvec2(.00,.35),vec2(.07,.40),vec2(.12,.45),vec2(.14,.46),vec2(.36,.47),\nvec2(.36,.48),vec2(.59,.47),vec2(.59,.47),vec2(.65,.45),vec2(.71,.44),\nvec2(.74,.40),vec2(.75,.36),vec2(.79,.25),vec2(.80,.16),vec2(.89,.07),\nvec2(.72,.07),vec2(.70,.10),vec2(.68,.14),vec2(.65,.13),vec2(.61,.10),\nvec2(.57,.07),vec2(.01,.07),vec2(.11,.10),vec2(.14,.12),vec2(.16,.16),\nvec2(.16,.23),vec2(.14,.29),vec2(.00,.21),vec2(.00,.35) );\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[ 7]=vec2[](  \nvec2(.50,.30),vec2(.52,.26),vec2(.53,.23),vec2(.53,.23),vec2(.52,.26),\nvec2(.50,.30),vec2(.50,.30) );\n\nfloat sdPoly7c POLY(7)\nvec2 pt7c[ 7]=vec2[](  \nvec2(.19,.32),vec2(.22,.30),vec2(.21,.27),vec2(.21,.27),vec2(.22,.30),\nvec2(.20,.32),vec2(.19,.32) );\n\nfloat sdPoly7d POLY(7)\nvec2 pt7d[ 7]=vec2[](  \nvec2(.69,.37),vec2(.68,.35),vec2(.72,.28),vec2(.73,.28),vec2(.69,.35),\nvec2(.70,.37),vec2(.69,.37) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.13,.29),vec2(.21,.34),vec2(.21,.34),vec2(.13,.29),vec2(.13,.29) );\n\nfloat sdPoly7e POLY(7)\nvec2 pt7e[ 7]=vec2[](  \nvec2(.38,.63),vec2(.38,.63),vec2(.37,.63),vec2(.37,.63),vec2(.38,.63),\nvec2(.38,.62),vec2(.38,.63) );\n\nfloat sdPoly7f POLY(7)\nvec2 pt7f[ 7]=vec2[](  \nvec2(.38,.62),vec2(.37,.62),vec2(.36,.62),vec2(.36,.62),vec2(.37,.62),\nvec2(.38,.61),vec2(.38,.62) );\n\nfloat sdPoly7g POLY(7)\nvec2 pt7g[ 7]=vec2[](  \nvec2(.38,.60),vec2(.36,.60),vec2(.35,.60),vec2(.35,.60),vec2(.36,.60),\nvec2(.38,.60),vec2(.38,.60) );\n\nfloat sdPoly7h POLY(7)\nvec2 pt7h[ 7]=vec2[](  \nvec2(.63,.63),vec2(.64,.62),vec2(.65,.63),vec2(.65,.63),vec2(.64,.62),\nvec2(.63,.62),vec2(.63,.63) );\n\nfloat sdPoly7i POLY(7)\nvec2 pt7i[ 7]=vec2[](  \nvec2(.63,.61),vec2(.64,.61),vec2(.66,.61),vec2(.66,.61),vec2(.64,.61),\nvec2(.63,.61),vec2(.63,.61) );\n\n\nfloat sdPoly20 POLY(20)\nvec2 pt20[ 20]=vec2[](  \nvec2(.16,.23),vec2(.17,.22),vec2(.26,.25),vec2(.36,.27),vec2(.40,.27),\nvec2(.52,.22),vec2(.66,.28),vec2(.69,.29),vec2(.72,.27),vec2(.74,.23),\nvec2(.73,.18),vec2(.68,.14),vec2(.65,.14),vec2(.55,.06),vec2(.00,.06),\nvec2(.09,.10),vec2(.13,.11),vec2(.16,.15),vec2(.16,.23),vec2(.16,.23) );\n\n\nfloat sdPoly16 POLY(16)\nvec2 pt16[ 16]=vec2[](  \nvec2(.36,.47),vec2(.40,.45),vec2(.46,.42),vec2(.50,.42),vec2(.51,.42),\nvec2(.57,.45),vec2(.57,.46),vec2(.59,.47),vec2(.60,.42),vec2(.59,.35),\nvec2(.57,.30),vec2(.56,.30),vec2(.51,.41),vec2(.44,.29),vec2(.38,.41),\nvec2(.36,.47) );\n\nconst vec3 colPelo=vec3(0.79,0.51,0.37);\nconst vec3 colPiel=vec3(0.98,0.92,0.82);\nconst vec3 colPiel2=vec3(0.88,0.82,0.72);\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.55);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\n\nvec3 RostroChica(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n   \n   float sd1 = sdPoly32(p, pt32); \n   float sd2 = sdPoly11(p, pt11);\n   float sd3 = sdPoly18(p, pt18);\n   float sd4 = sdPoly24(p, pt24);\n   float sd5 = sdPoly11b(p,pt11b);\n   float sd6 = sdPoly11c(p,pt11c);\n   float sd7 = sdPoly13(p,pt13);\n   float sd8 = sdPoly9(p,pt9);\n   float sd9 = sdPoly9b(p,pt9b);\n   float sd10 = sdPoly7(p,pt7);\n   float sd11 = sdPoly10(p,pt10);\n   float sd12 = sdPoly8(p,pt8);\n   float sd13 = sdPoly9c(p,pt9c);\n   float sd14 = sdPoly11d(p,pt11d);\n   float sd15 = sdPoly8b(p,pt8b);\n   float sd16 = sdPoly9d(p,pt9d);\n   float sd17 = sdPoly10b(p,pt10b);\n   float sd18 = sdPoly9e(p,pt9e);\n   float sd19 = sdPoly12(p,pt12);\n   float sd20 = sdPoly29(p,pt29);\n   float sd21 = sdPoly7b(p,pt7b);\n   float sd22 = sdPoly7c(p,pt7c);\n   float sd23 = sdPoly7d(p,pt7d);\n   float sd24 = sdPoly5(p,pt5);\n   float sd25 = sdPoly7e(p,pt7e);\n   float sd26 = sdPoly7f(p,pt7f);\n   float sd27 = sdPoly7g(p,pt7g);\n   float sd28 = sdPoly7h(p,pt7h);\n   float sd29 = sdPoly7i(p,pt7i);\n   float sd30 = sdPoly20(p,pt20);\n   float sd31 = sdPoly16(p,pt16);\n   float sd32= sdCircle( p-vec2(0.4,0.60), 0.01 );\n   float sd33= sdCircle( p-vec2(0.59,0.59), 0.01 );\n   \n   col= ponerBorde(colPiel,col,sd20); // cuerpo\n   col= ponerBorde(colPelo,col,sd2); //pelo1\n   col= ponerBorde(colPelo,col,sd3); //pelo2\n   col= ponerBorde(colPelo,col,sd4); //pelo3\n   col= ponerBorde(colPiel,col,sd1); //rostro\n   col= ponerBorde(colGris,col,sd5); //colita 1\n   col= ponerBorde(colGris,col,sd6); //colita 2\n   col= ponerBorde(colGris,col,sd7); //centro colita \n   col= ponerBorde(colNegro,col,sd8); // ceja izq\n   col= ponerBorde(colNegro,col,sd9); // ceja der\n   col= ponerBorde(colBlanco,col,sd10); // ojo izq\n   col= ponerBorde(colBlanco,col,sd11); // ojo der\n   col= ponerBorde(colGris,col,sd12); //  pupila izq\n   col= ponerBorde(colGris,col,sd13); // pupila der\n   col= ponerBorde(colGris,col,sd14); // nariz\n   col= ponerBorde(colRojo,col,sd15); // labio sup\n   col= ponerBorde(colRojo,col,sd16); // labio inf\n   col= ponerBorde(colRojo,col,sd17); // bola\n   col= ponerBorde(colRojo,col,sd18); // bola 2\n   col= ponerBorde(colPiel2,col,sd19); // oreja\n   col= ponerBorde(colPiel2,col,sd21); // linea busto\n   col= ponerBorde(colPiel2,col,sd22); // linea axila\n   col= ponerBorde(colNegro,col,sd23); // \n   col= ponerBorde(colNegro,col,sd24); // linea 2 axila\n   col= ponerBorde(colNegro,col,sd25); //\n   col= ponerBorde(colNegro,col,sd26); //\n   col= ponerBorde(colNegro,col,sd27); //\n   col= ponerBorde(colNegro,col,sd28); //\n   col= ponerBorde(colNegro,col,sd29); //\n   col= ponerBorde(colNegro,col,sd30); // ropa\n   col= ponerBorde(colNegro,col,sd31); // ropa\n   \n   col = mix(col,colNegro ,S( sd32,0.0));\n   col = mix(col,colNegro ,S( sd33,0.0));\n   \n  return col;\n}\nconst vec4 red = vec4( 0.8, 0.1 ,0.2, 1.0 ) ;\nconst vec4 blue = vec4(0.0, 0.0 ,1.0,1 );\n\nvec4 fondo( vec2 pp)\n{\n    vec2 p=pp;\n    vec4 color = vec4( 1.0 );\n\tfloat xOffset = 0.5*sin(iTime);\n    //rays\n    float r = cos( atan( p.y, p.x + xOffset ) * 16.0 );\n    float f = smoothstep( r, r + 0.1, length( p )*0.25 );\n\tcolor = mix( blue, color, f );\n    //circle\n    r = 0.6;\n    f = smoothstep( r, r + 0.01, length( p + vec2( xOffset, 0.0 ) ) );\n    color = mix( red, color, f );\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    //posicion\n    vec2 p=uv+vec2(1.5,0.9);\n    p*=1.7;\n    p.x*=0.7;\n    p.y*=0.5; p.y+=0.15;\n    vec4 colf=fondo(p*1.0);\n    vec3 col=colf.xyz;\n     col= RostroChica( p,col*2.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBXWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 339, 339, 363], [365, 365, 425, 425, 549], [7815, 7815, 7856, 7856, 10629], [10719, 10719, 10741, 10741, 11127], [11129, 11129, 11186, 11186, 11454]]}
{"id": "fsSSDD", "name": "compare laplacian approx", "author": "FabriceNeyret2", "description": "left: Channel0: smooth     right: Channel1: HF random    extremes: red/green = under/overflow\ntop to bottom : \nreference laplacian, hardware laplacian, error ", "tags": ["bench", "laplacing", "hardwarederivative"], "likes": 15, "viewed": 479, "published": 3, "date": "1620217474", "time_retrieved": "2024-07-30T19:21:43.808300", "image_code": "float size = 256.;  // scale of left texture\n#define lapl1    ( ( Txy(-1,0)+ Txy(1,0)+ Txy(0,-1)+ Txy(0,1) ) /4. - T(U,0.) )\n#define lapl2    9./8.* ( T(U,1.) - T(U,0.) )    // approx Laplacian using MIPmap LOD difference\n                                                 // 9/8 because T(1) includes a bit of T(0) ;-)\n#define T(U,l)   ( left ? texture( iChannel0, (U)*R/size, l+0. ) : texture( iChannel1, (U)*R/1024., l+0. ) )\n//#define T(U,l) ( left ? texture( iChannel0, U, l+0. ) : texelFetch( iChannel1, (ivec2((U)*R)%1024)>>int(l), int(l) ) )\n#define Txy(x,y)   T( U+vec2(x,y)/R, 0. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,  U = u/R;\n    bool  left = U.x < .5;\n    int l = int(U.y*3.);\n    \n    float s =  left ? size / 64. : .7,\n          k =  left ? 2.1 : 1.,                  // left: l2/l1 ~ 1.6(size=64) to 2.1(size=256) why ?  ( and not for right )\n         l1 = lapl1.x*s*k, l2 = lapl2.x*s, \n          err = ( l2 - l1 ); //   / l1;          // relative not convenient since l1 get close to 0\n     \n    O =  vec4( l==2 ? l1 : l==1 ? l2 : err );\n    if (left) O *= 5.;\n    O = .5 + 1.*O;                               // show abs(err) and abs(lapl)\n // O =  1.*abs(O);                              // show signed err and lapl\n    if ( abs(U.x-.5) > .25 ) {\n        if (O.x < 0.) O = vec4(1,0,0,0);         // overflow\n        if (O.x > 1.) O = vec4(0,1,0,0);\n    }\n    \n    if ( abs( fract(U.y*3.)/3.*R.y -.5) < .5 ) O = vec4(0,0,1,0); // separators\n    if ( abs( fract(U.x*4.)/4.*R.x -.5) < .5 ) O = vec4(0,0,1,0);\n // O = T(U,0.);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSSDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[591, 591, 629, 629, 1574]]}
{"id": "NsBXDD", "name": "Polymers In Spinning Drum", "author": "dr2", "description": "Polymer dynamics (see source)", "tags": ["collision", "simulation", "interactive", "dynamics", "physics", "chain"], "likes": 24, "viewed": 327, "published": 3, "date": "1620210247", "time_retrieved": "2024-07-30T19:21:45.070924", "image_code": "// \"Polymers In Spinning Drum\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Slightly stiff bead-necklace polymers (based on \"Balls in Spinning Drum\" \n  and \"Polymer Chains 2\")\n\n  Slider controls spin rate; mouse controls both cylinder axis and view\n  orientations - click button to switch.\n\n  No. 5 in \"Chain Dynamics\" series\n    \"Snake Run\"              (ltjfR1)\n    \"Polymer Chains\"         (4dcBRs)\n    \"Jamming Polymers\"       (XtGfz3)\n    \"Polymer Chains 2\"       (wlsSWl)\n    \"Leaping Snakes\"         (ttjXW10\n    \"Leaping Snakes 2\"       (3lBXWV)\n    \"Knot Dynamics\"          (ttKXzc)\n*/\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nmat3 StdVuMat (float el, float az);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 QtToRMat (vec4 q);\nfloat Fbm2 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\nconst int nChain = 24, lenChain = 20, nBall = nChain * lenChain;\n\nvec3 ltDir, qHit, vnObj;\nfloat dstFar, cylRad, cylLen, cylRot, cylEl, cylAz;\nint idObj, idBall, idChain;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec3 OrCyl (vec3 p)\n{\n  p.xz = Rot2D (p.xz, cylAz);\n  p.yz = Rot2D (p.yz, cylEl);\n  return p;\n}\n\nvec3 OrCylT (vec3 p)\n{\n  p.yz = Rot2D (p.yz, - cylEl);\n  p.xz = Rot2D (p.xz, - cylAz);\n  return p;\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 ss;\n  float dMin, d, tr, f;\n  dMin = dstFar;\n  tr = 0.08;\n  q = p;\n  q = OrCyl (q);\n  q.z = abs (q.z) - cylLen;\n  d = PrTorusDf (q, tr, cylRad);\n  DMINQ (1);\n  q.z -= tr;\n  d = PrCylDf (q, 0.08 * cylRad, tr);\n  DMINQ (2);\n  tr = 0.15;\n  q = p;\n  q = OrCyl (q);\n  d = min (PrRoundBoxDf (vec3 (q.xy, abs (q.z) - cylLen - 2. * tr),\n     vec3 (cylRad + 4. * tr, tr, tr) - 0.1, 0.1),\n     PrRoundBoxDf (vec3 (abs (q.x) - cylRad - 3. * tr, q.yz),\n     vec3 (tr, tr, cylLen + 3. * tr) - 0.1, 0.1));\n  DMINQ (3);\n  d = PrCylDf (vec3 (abs (q.x) - cylRad - 4.5 * tr, q.yz).yzx, 0.8 * tr, tr);\n  DMINQ (4);\n  q = p;\n  q.xz = Rot2D (q.xz, cylAz);\n  f = 0.57 * length (vec2 (cylRad, cylLen));\n  d = min (PrRoundBoxDf (vec3 (abs (q.x) - (cylRad + 6. * tr), q.y + f - tr, q.z),\n     vec3 (tr, f, tr) - 0.1, 0.1),\n     PrRoundBoxDf (vec3 (q.x, q.y + 2. * f - 2. * tr, q.z),\n     vec3 (cylRad + 6. * tr, tr, tr) - 0.1, 0.1));\n  DMINQ (3);\n  d = PrCylDf (vec3 (q.x, q.y + 2. * f - 2. * tr, q.z).xzy, 1.4 * tr, 1.4 * tr);\n  DMINQ (4);\n  q = p;\n  q.y -= - 2. * f - 0.05;\n  d = PrRoundBoxDf (q, vec3 (cylRad + 14. * tr, 0.2, cylRad + 14. * tr) - 0.05, 0.05);\n  DMINQ (5);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\n#define TUBE 1    // = 0/1, show polymer beads/tubes\n\n#if TUBE\n\nfloat CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s;\n  float dMin, d, a, b, w;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    d /= a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      vnObj = vec3 (s.xy, 0.);\n    } else {\n      ro.z -= len * sign (s.z);\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          dMin = d;\n          vnObj = ro + d * rd;\n        }\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat PolyHit (vec3 ro, vec3 rd)\n{\n  mat3 rMat, rMatS;\n  vec3 r, rp, vnObjS;\n  float dMin, d, sz;\n  sz = 0.4;\n  dMin = dstFar;\n  idChain = -1;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    if (mod (float (n), float (lenChain)) == 0.) r = Loadv4 (4 + 4 * n).xyz;\n    else {\n      rp = r;\n      r = Loadv4 (4 + 4 * n).xyz;\n      rMat = DirToRMatT (normalize (r - rp), vec3 (0., 0., 1.));\n      d = CapsHit ((ro - 0.5 * (r + rp)) * rMat, rd * rMat, sz, 0.5 * length (r - rp));\n      if (d < dMin) {\n        dMin = d;\n        rMatS = rMat;\n        vnObjS = vnObj;\n        idChain = n / lenChain;\n      }\n    }\n  }\n  if (idChain >= 0) vnObj = rMatS * normalize (vnObjS);\n  return dMin;\n}\n\n#else\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  idBall = -1;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.5 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        idBall = n;\n      }\n    }\n  }\n  if (idBall >= 0) {\n    p = Loadv4 (4 + 4 * idBall);\n    vnObj = (ro - p.xyz + dMin * rd) / (0.5 * p.w);\n  }\n  return dMin;\n} \n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat (Loadv4 (4 + 4 * idBall + 2));\n  a = mod (floor (8. * vec2 (atan (u.x, u.y), asin (u.z)) / pi), 2.) - 0.5;\n  return step (0., sign (a.x) * sign (a.y));\n}\n\n#endif\n\nvec4 CylHit (vec3 ro, vec3 rd, float cylRad, float cylLen)\n{\n  vec3 s, vn;\n  float dMin, d, a, b, w, srdz;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - cylRad * cylRad);\n  if (w > 0.) {\n    srdz = sign (rd.z);\n    if (a > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0.) {\n        d /= a;\n        s = ro + d * rd;\n      } else s.z = cylLen;\n    } else s.z = cylLen;\n    if (abs (s.z) < cylLen) {\n      dMin = d;\n      vn = vec3 (s.xy / cylRad, 0.);\n    } else if (srdz * ro.z < - cylLen) {\n      d = - (srdz * ro.z + cylLen) / abs (rd.z);\n      if (d > 0.) {\n        s = ro + d * rd;\n        if (length (s.xy) < cylRad) {\n          dMin = d;\n          vn = vec3 (0., 0., - srdz);\n        }\n      }\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd, vec3 col)\n{\n  vec4 dc4, col4;\n  vec3 roo, rdo, vn;\n  float dstBT, dstObj, c, a, nDotL;\n  dstObj = ObjRay (ro, rd);\n  dstBT = dstFar;\n  roo = ro;\n  rdo = rd;\n  ro = OrCyl (ro);\n  rd = OrCyl (rd);\n  dc4 = CylHit (ro, rd, cylRad, cylLen);\n  if (dc4.x < dstFar) {\n#if TUBE\n    dstBT = PolyHit (ro, rd);\n#else   \n    dstBT = BallHit (ro, rd);\n#endif\n    if (dstBT < min (dstObj, dstFar)) {\n      vn = OrCylT (vnObj);\n#if TUBE\n      c = 0.9 * float (idChain) / float (nChain);\n      col4 = vec4 (HsvToRgb (vec3 (mod (c, 1.), 1., 1.)), 0.1);\n#else   \n      c = 0.7 * mod (float (idBall / lenChain) / float (nChain), 1.);\n      col4 = vec4 (mix (HsvToRgb (vec3 (mod (c, 1.), 1., 1.)),\n         HsvToRgb (vec3 (mod (mod (c + 0.25, 1.), 1.), 1., 1)), BallChqr (idBall, vnObj)), 0.1);\n#endif\n      idObj = -1;\n    }\n  }\n  if (dstObj < min (dstBT, dstFar)) {\n    ro = roo;\n    rd = rdo;\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1 || idObj == 2) {\n      qHit.xy = Rot2D (qHit.xy, cylRot);\n      a = atan (qHit.y, - qHit.x);\n      col4 = vec4 (0.9, 0.7, 0.3, 0.2);\n      if (idObj == 1) col4 *= 1. - 0.3 * step (0.5, sin (16. * a));\n      else col4 *= 1. - 0.3 * step (0.01 * cylRad, length (qHit.xy)) * step (0., sin (8. * a));\n    } else if (idObj == 3) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2);\n    } else if (idObj == 4) {\n      col4 = vec4 (0.8, 0.7, 0.7, 0.2);\n    } else if (idObj == 5) {\n       col4 = mix (vec4 (0.7, 0.3, 0.1, 0.1), vec4 (0.4, 0.2, 0.1, 0.1),\n          Fbm2 (qHit.xz * vec2 (0.5, 4.)));\n       qHit.xz = Rot2D (qHit.xz, cylAz);\n       col4 *= 0.7 + 0.3 * smoothstep (0.1, 0.15, length (max (abs (qHit.xz) -\n          vec2 (cylRad + 1., 0.1), 0.)));\n    }\n  }\n  if (min (dstBT, dstObj) < dstFar) {\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (idObj != 5) nDotL *= nDotL;\n    col = col4.rgb * (0.2 + 0.8 * nDotL + col4.a * pow (max (0.,\n       dot (ltDir, reflect (rd, vn))), 32.));\n  } else if (dc4.x < dstFar) col *= 0.7;\n  if (dc4.x < min (dstObj, dstFar)) {\n    vn = OrCylT (dc4.yzw);\n    col = mix (col, vec3 (0.8, 0.8, 1.), 0.1 + 0.8 * pow (1. - abs (dot (vn, rdo)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col, float slVal, float msMode)\n{\n  vec4 wgBx[2];\n  vec3 c1, c2;\n  vec2 ut, ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.42 * asp, 0., 0.015 * asp, 0.2);\n  wgBx[1] = vec4 (0.42 * asp, -0.44, 0.02, 0.);\n  c1 = vec3 (0.3, 0.3, 0.8);\n  c2 = vec3 (0.7, 0.7, 1.);\n  ut = 0.5 * uv - wgBx[0].xy;\n  ust = abs (ut) - wgBx[0].zw * vec2 (0.7, 1.);\n  if (max (ust.x, ust.y) < 0.) {\n    if  (min (abs (ust.x), abs (ust.y)) * canvas.y < 2.) col = c2;\n    else col = (mod (0.5 * ((0.5 * uv.y - wgBx[0].y) / wgBx[0].w - 0.99), 0.1) *\n       canvas.y < 5.) ? c2 : vec3 (0.4);\n  }\n  ut.y -= (slVal - 0.5) * 2. * wgBx[0].w;\n  ut = abs (ut) * vec2 (1., 2.);\n  if (abs (max (ut.x, ut.y) - 0.02) < 0.008) col = c1;\n  ut = 0.5 * uv - wgBx[1].xy;\n  if (length (ut) < wgBx[1].z) col = mix (((msMode > 0.) ? vec3 (1., 0.3, 0.3) : vec3 (0.3, 0.3, 1.)),\n     vec3 (0.4), smoothstep (1., 3., abs (length (ut) - 0.02) * canvas.y));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 col, rd, ro;\n  vec2 canvas, uv;\n  float b, slVal, zmFac, el, az, msMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  cylRad = stDat.x - 0.4;\n  cylLen = stDat.y - 0.4;\n  cylRot = stDat.w;\n  stDat = Loadv4 (1);\n  el = stDat.x;\n  az = stDat.y;\n  cylEl = stDat.z;\n  cylAz = stDat.w;\n  vuMat = StdVuMat (el, az);\n  b = length (vec2 (cylRad, cylLen));\n  dstFar = 20. * b;\n  zmFac = 6.;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., -0.3 * b, - 8. * b);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  col = vec3 (0.1, 0.2 + 0.1 * uv.y, 0.1);\n  col = ShowScene (ro, rd, col);\n  stDat = Loadv4 (3);\n  slVal = stDat.y;\n  msMode = stDat.w;\n  col = ShowWg (uv, canvas, col, slVal, msMode);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  vc = normalize (cross (vu, vd));\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Polymers In Spinning Drum\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nChain = 24, lenChain = 20, nBall = nChain * lenChain;\n\nvec3 gVec;\nfloat nStep, cylRad, cylLen, angV, fOvlap, fricN, fricS, fricT, fBend, delT;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv;\n  float diamN, rSep, diamAv, h, fc, ft, c11, c22, c12, cd, c;\n  int inChain, ic, k1, k2;\n  inChain = mId / lenChain;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (4 + 4 * n + 1).xyz;\n      wmN = Loadv4 (4 + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    if ((n == mId + 1 || n == mId - 1) && n / lenChain == inChain && rSep > diamAv)\n       am += fOvlap * (1. / rSep - 1.) * dr;\n  }\n  ic = mId - inChain * lenChain;\n  for (int m = VAR_ZERO; m < 4; m ++) {\n    if (m == 0 && ic <= 1 || (m == 1 || m == 2) && (ic == 0 || ic == lenChain - 1) ||\n       m == 3 && ic >= lenChain - 2) continue;\n    k1 = mId;\n    k2 = mId;\n    if (m == 0) {\n      k1 -= 1;\n      k2 -= 2;\n    } else if (m == 1 || m == 2) {\n      k1 -= 1;\n      k2 += 1;\n    } else if (m == 3) {\n      k1 += 1;\n      k2 += 2;\n    }\n    rmN1 = Loadv4 (4 + 4 * k1).xyz;\n    rmN2 = Loadv4 (4 + 4 * k2).xyz;\n    if (m == 0) {\n      dr1 = rmN1 - rmN2;\n      dr2 = rm - rmN1;\n    } else if (m == 1 || m == 2) {\n      dr1 = rm - rmN1;\n      dr2 = rmN2 - rm;\n    } else if (m == 3) {\n      dr1 = rmN1 - rm;\n      dr2 = rmN2 - rmN1;\n    }\n    c11 = dot (dr1, dr1);\n    c12 = dot (dr1, dr2);\n    c22 = dot (dr2, dr2);\n    cd = sqrt (c11 * c22);\n    c = c12 / cd - 1.;\n    if (m == 0 || m == 3) c = - c;\n    am += fBend * (c / cd) * ((m <= 1) ? dr1 - (c12 / c22) * dr2 : (c12 / c11) * dr1 - dr2);\n  }  \n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rSep = cylRad - length (rm.xy);\n  if (rSep < diamAv) {\n    dr = - rSep * normalize (vec3 (rm.xy, 0.));\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * cylRad * normalize (vec3 (rm.y, - rm.x, 0.));\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.z = abs (rm.z) - cylLen;\n  rSep = abs (dr.z);\n  if (rSep < diamAv) {\n    dr.z *= sign (rm.z);\n    dr.xy = vec2 (0.);\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * vec3 (- rm.y, rm.x, 0.);\n    h = dot (dr, dv) / (rSep * rSep);\n    fc -= fricN * h;\n    am += fc * dr;\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 200.;\n  fBend = 10.;\n  fricN = 5.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 2.;\n  p = Loadv4 (4 + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  vm = Loadv4 (4 + 4 * mId + 1).xyz;\n  qm = Loadv4 (4 + 4 * mId + 2);\n  wm = Loadv4 (4 + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf, r;\n  mIdf = float (mId);\n  r = 0.7 * cylRad;\n  rm = vec3 (r * sin (2. * pi * mod (0.9 * mIdf / (2. * pi * r), 1.) + vec2 (0.5 * pi, 0.)),\n     -0.9 * (mIdf - 0.5 * float (nBall)) / (2. * pi * cylLen));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[2], stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, ust;\n  float el, az, asp, diam, cylRot, cylEl, cylAz, angVMax, slVal, msMode;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 4) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= 4) mId = (pxId - 4) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  angVMax = 3.;\n  if (doInit) {\n    cylRad = 0.9 * floor (pow (float (nBall), 1./3.));\n    cylLen = cylRad;\n    nStep = 0.;\n    cylRot = 0.;\n    wgSel = -1;\n    slVal = 0.3;\n    angV = slVal * angVMax;\n    el = -0.08 * pi;\n    az = 0.;\n    cylEl = 0.;\n    cylAz = 0.;\n    msMode = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    cylRad = stDat.x;\n    cylLen = stDat.y;\n    angV = stDat.z;\n    cylRot = stDat.w;\n    stDat = Loadv4 (1);\n    el = stDat.x;\n    az = stDat.y;\n    cylEl = stDat.z;\n    cylAz = stDat.w;\n    mPtrP = Loadv4 (2);\n    stDat = Loadv4 (3);\n    nStep = stDat.x;\n    slVal = stDat.y;\n    wgSel = int (stDat.z);\n    msMode = stDat.w;\n    ++ nStep;\n    cylRot = mod (cylRot + delT * angV, 2. * pi);\n  }\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.42 * asp, 0., 0.015 * asp, 0.2);\n    wgBx[1] = vec4 (0.42 * asp, -0.44, 0.02, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) {\n      wgReg = 0;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) < wgBx[1].z) {\n      if (mPtrP.z <= 0.) msMode = 1. - msMode;\n    } else if (wgSel < 0) {\n      if (msMode == 0.) {\n        cylAz = -2. * pi * mPtr.x;\n        cylEl = - 2. * pi * mPtr.y;\n      } else {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.08 * pi + pi * mPtr.y, -0.45 * pi, 0.);\n      }\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel == 0) {\n    slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    angV = slVal * angVMax;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), cylEl));\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (cylRad, cylLen, angV, cylRot);\n  else if (pxId == 1) stDat = vec4 (el, az, cylEl, cylAz);\n  else if (pxId == 2) stDat = mPtr;\n  else if (pxId == 3) stDat = vec4 (nStep, slVal, float (wgSel), msMode);\n  else {\n    mId = pxId - (4 + 4 * mId);\n    stDat = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Polymers In Spinning Drum\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nChain = 24, lenChain = 20, nBall = nChain * lenChain;\n\nvec3 gVec;\nfloat nStep, cylRad, cylLen, angV, fOvlap, fricN, fricS, fricT, fBend, delT;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv;\n  float diamN, rSep, diamAv, h, fc, ft, c11, c22, c12, cd, c;\n  int inChain, ic, k1, k2;\n  inChain = mId / lenChain;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (4 + 4 * n + 1).xyz;\n      wmN = Loadv4 (4 + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    if ((n == mId + 1 || n == mId - 1) && n / lenChain == inChain && rSep > diamAv)\n       am += fOvlap * (1. / rSep - 1.) * dr;\n  }\n  ic = mId - inChain * lenChain;\n  for (int m = VAR_ZERO; m < 4; m ++) {\n    if (m == 0 && ic <= 1 || (m == 1 || m == 2) && (ic == 0 || ic == lenChain - 1) ||\n       m == 3 && ic >= lenChain - 2) continue;\n    k1 = mId;\n    k2 = mId;\n    if (m == 0) {\n      k1 -= 1;\n      k2 -= 2;\n    } else if (m == 1 || m == 2) {\n      k1 -= 1;\n      k2 += 1;\n    } else if (m == 3) {\n      k1 += 1;\n      k2 += 2;\n    }\n    rmN1 = Loadv4 (4 + 4 * k1).xyz;\n    rmN2 = Loadv4 (4 + 4 * k2).xyz;\n    if (m == 0) {\n      dr1 = rmN1 - rmN2;\n      dr2 = rm - rmN1;\n    } else if (m == 1 || m == 2) {\n      dr1 = rm - rmN1;\n      dr2 = rmN2 - rm;\n    } else if (m == 3) {\n      dr1 = rmN1 - rm;\n      dr2 = rmN2 - rmN1;\n    }\n    c11 = dot (dr1, dr1);\n    c12 = dot (dr1, dr2);\n    c22 = dot (dr2, dr2);\n    cd = sqrt (c11 * c22);\n    c = c12 / cd - 1.;\n    if (m == 0 || m == 3) c = - c;\n    am += fBend * (c / cd) * ((m <= 1) ? dr1 - (c12 / c22) * dr2 : (c12 / c11) * dr1 - dr2);\n  }  \n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rSep = cylRad - length (rm.xy);\n  if (rSep < diamAv) {\n    dr = - rSep * normalize (vec3 (rm.xy, 0.));\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * cylRad * normalize (vec3 (rm.y, - rm.x, 0.));\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.z = abs (rm.z) - cylLen;\n  rSep = abs (dr.z);\n  if (rSep < diamAv) {\n    dr.z *= sign (rm.z);\n    dr.xy = vec2 (0.);\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * vec3 (- rm.y, rm.x, 0.);\n    h = dot (dr, dv) / (rSep * rSep);\n    fc -= fricN * h;\n    am += fc * dr;\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 200.;\n  fBend = 10.;\n  fricN = 5.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 2.;\n  p = Loadv4 (4 + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  vm = Loadv4 (4 + 4 * mId + 1).xyz;\n  qm = Loadv4 (4 + 4 * mId + 2);\n  wm = Loadv4 (4 + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf, r;\n  mIdf = float (mId);\n  r = 0.7 * cylRad;\n  rm = vec3 (r * sin (2. * pi * mod (0.9 * mIdf / (2. * pi * r), 1.) + vec2 (0.5 * pi, 0.)),\n     -0.9 * (mIdf - 0.5 * float (nBall)) / (2. * pi * cylLen));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[2], stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, ust;\n  float el, az, asp, diam, cylRot, cylEl, cylAz, angVMax, slVal, msMode;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 4) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= 4) mId = (pxId - 4) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  angVMax = 3.;\n  if (doInit) {\n    cylRad = 0.9 * floor (pow (float (nBall), 1./3.));\n    cylLen = cylRad;\n    nStep = 0.;\n    cylRot = 0.;\n    wgSel = -1;\n    slVal = 0.3;\n    angV = slVal * angVMax;\n    el = -0.08 * pi;\n    az = 0.;\n    cylEl = 0.;\n    cylAz = 0.;\n    msMode = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    cylRad = stDat.x;\n    cylLen = stDat.y;\n    angV = stDat.z;\n    cylRot = stDat.w;\n    stDat = Loadv4 (1);\n    el = stDat.x;\n    az = stDat.y;\n    cylEl = stDat.z;\n    cylAz = stDat.w;\n    mPtrP = Loadv4 (2);\n    stDat = Loadv4 (3);\n    nStep = stDat.x;\n    slVal = stDat.y;\n    wgSel = int (stDat.z);\n    msMode = stDat.w;\n    ++ nStep;\n    cylRot = mod (cylRot + delT * angV, 2. * pi);\n  }\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.42 * asp, 0., 0.015 * asp, 0.2);\n    wgBx[1] = vec4 (0.42 * asp, -0.44, 0.02, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) {\n      wgReg = 0;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) < wgBx[1].z) {\n      if (mPtrP.z <= 0.) msMode = 1. - msMode;\n    } else if (wgSel < 0) {\n      if (msMode == 0.) {\n        cylAz = -2. * pi * mPtr.x;\n        cylEl = - 2. * pi * mPtr.y;\n      } else {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.08 * pi + pi * mPtr.y, -0.45 * pi, 0.);\n      }\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel == 0) {\n    slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    angV = slVal * angVMax;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), cylEl));\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (cylRad, cylLen, angV, cylRot);\n  else if (pxId == 1) stDat = vec4 (el, az, cylEl, cylAz);\n  else if (pxId == 2) stDat = mPtr;\n  else if (pxId == 3) stDat = vec4 (nStep, slVal, float (wgSel), msMode);\n  else {\n    mId = pxId - (4 + 4 * mId);\n    stDat = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// \"Polymers In Spinning Drum\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nChain = 24, lenChain = 20, nBall = nChain * lenChain;\n\nvec3 gVec;\nfloat nStep, cylRad, cylLen, angV, fOvlap, fricN, fricS, fricT, fBend, delT;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv;\n  float diamN, rSep, diamAv, h, fc, ft, c11, c22, c12, cd, c;\n  int inChain, ic, k1, k2;\n  inChain = mId / lenChain;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (4 + 4 * n + 1).xyz;\n      wmN = Loadv4 (4 + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    if ((n == mId + 1 || n == mId - 1) && n / lenChain == inChain && rSep > diamAv)\n       am += fOvlap * (1. / rSep - 1.) * dr;\n  }\n  ic = mId - inChain * lenChain;\n  for (int m = VAR_ZERO; m < 4; m ++) {\n    if (m == 0 && ic <= 1 || (m == 1 || m == 2) && (ic == 0 || ic == lenChain - 1) ||\n       m == 3 && ic >= lenChain - 2) continue;\n    k1 = mId;\n    k2 = mId;\n    if (m == 0) {\n      k1 -= 1;\n      k2 -= 2;\n    } else if (m == 1 || m == 2) {\n      k1 -= 1;\n      k2 += 1;\n    } else if (m == 3) {\n      k1 += 1;\n      k2 += 2;\n    }\n    rmN1 = Loadv4 (4 + 4 * k1).xyz;\n    rmN2 = Loadv4 (4 + 4 * k2).xyz;\n    if (m == 0) {\n      dr1 = rmN1 - rmN2;\n      dr2 = rm - rmN1;\n    } else if (m == 1 || m == 2) {\n      dr1 = rm - rmN1;\n      dr2 = rmN2 - rm;\n    } else if (m == 3) {\n      dr1 = rmN1 - rm;\n      dr2 = rmN2 - rmN1;\n    }\n    c11 = dot (dr1, dr1);\n    c12 = dot (dr1, dr2);\n    c22 = dot (dr2, dr2);\n    cd = sqrt (c11 * c22);\n    c = c12 / cd - 1.;\n    if (m == 0 || m == 3) c = - c;\n    am += fBend * (c / cd) * ((m <= 1) ? dr1 - (c12 / c22) * dr2 : (c12 / c11) * dr1 - dr2);\n  }  \n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rSep = cylRad - length (rm.xy);\n  if (rSep < diamAv) {\n    dr = - rSep * normalize (vec3 (rm.xy, 0.));\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * cylRad * normalize (vec3 (rm.y, - rm.x, 0.));\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.z = abs (rm.z) - cylLen;\n  rSep = abs (dr.z);\n  if (rSep < diamAv) {\n    dr.z *= sign (rm.z);\n    dr.xy = vec2 (0.);\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * vec3 (- rm.y, rm.x, 0.);\n    h = dot (dr, dv) / (rSep * rSep);\n    fc -= fricN * h;\n    am += fc * dr;\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 200.;\n  fBend = 10.;\n  fricN = 5.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 2.;\n  p = Loadv4 (4 + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  vm = Loadv4 (4 + 4 * mId + 1).xyz;\n  qm = Loadv4 (4 + 4 * mId + 2);\n  wm = Loadv4 (4 + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf, r;\n  mIdf = float (mId);\n  r = 0.7 * cylRad;\n  rm = vec3 (r * sin (2. * pi * mod (0.9 * mIdf / (2. * pi * r), 1.) + vec2 (0.5 * pi, 0.)),\n     -0.9 * (mIdf - 0.5 * float (nBall)) / (2. * pi * cylLen));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[2], stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, ust;\n  float el, az, asp, diam, cylRot, cylEl, cylAz, angVMax, slVal, msMode;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 4) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= 4) mId = (pxId - 4) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  angVMax = 3.;\n  if (doInit) {\n    cylRad = 0.9 * floor (pow (float (nBall), 1./3.));\n    cylLen = cylRad;\n    nStep = 0.;\n    cylRot = 0.;\n    wgSel = -1;\n    slVal = 0.3;\n    angV = slVal * angVMax;\n    el = -0.08 * pi;\n    az = 0.;\n    cylEl = 0.;\n    cylAz = 0.;\n    msMode = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    cylRad = stDat.x;\n    cylLen = stDat.y;\n    angV = stDat.z;\n    cylRot = stDat.w;\n    stDat = Loadv4 (1);\n    el = stDat.x;\n    az = stDat.y;\n    cylEl = stDat.z;\n    cylAz = stDat.w;\n    mPtrP = Loadv4 (2);\n    stDat = Loadv4 (3);\n    nStep = stDat.x;\n    slVal = stDat.y;\n    wgSel = int (stDat.z);\n    msMode = stDat.w;\n    ++ nStep;\n    cylRot = mod (cylRot + delT * angV, 2. * pi);\n  }\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.42 * asp, 0., 0.015 * asp, 0.2);\n    wgBx[1] = vec4 (0.42 * asp, -0.44, 0.02, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) {\n      wgReg = 0;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) < wgBx[1].z) {\n      if (mPtrP.z <= 0.) msMode = 1. - msMode;\n    } else if (wgSel < 0) {\n      if (msMode == 0.) {\n        cylAz = -2. * pi * mPtr.x;\n        cylEl = - 2. * pi * mPtr.y;\n      } else {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.08 * pi + pi * mPtr.y, -0.45 * pi, 0.);\n      }\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel == 0) {\n    slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    angV = slVal * angVMax;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), cylEl));\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (cylRad, cylLen, angV, cylRot);\n  else if (pxId == 1) stDat = vec4 (el, az, cylEl, cylAz);\n  else if (pxId == 2) stDat = mPtr;\n  else if (pxId == 3) stDat = vec4 (nStep, slVal, float (wgSel), msMode);\n  else {\n    mId = pxId - (4 + 4 * mId);\n    stDat = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// \"Polymers In Spinning Drum\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nChain = 24, lenChain = 20, nBall = nChain * lenChain;\n\nvec3 gVec;\nfloat nStep, cylRad, cylLen, angV, fOvlap, fricN, fricS, fricT, fBend, delT;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv;\n  float diamN, rSep, diamAv, h, fc, ft, c11, c22, c12, cd, c;\n  int inChain, ic, k1, k2;\n  inChain = mId / lenChain;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 + 4 * n);\n    rmN = p.xyz;\n    diamN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    diamAv = 0.5 * (diam + diamN);\n    if (n != mId && rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      vmN = Loadv4 (4 + 4 * n + 1).xyz;\n      wmN = Loadv4 (4 + 4 * n + 3).xyz;\n      dv = vm - vmN;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n    if ((n == mId + 1 || n == mId - 1) && n / lenChain == inChain && rSep > diamAv)\n       am += fOvlap * (1. / rSep - 1.) * dr;\n  }\n  ic = mId - inChain * lenChain;\n  for (int m = VAR_ZERO; m < 4; m ++) {\n    if (m == 0 && ic <= 1 || (m == 1 || m == 2) && (ic == 0 || ic == lenChain - 1) ||\n       m == 3 && ic >= lenChain - 2) continue;\n    k1 = mId;\n    k2 = mId;\n    if (m == 0) {\n      k1 -= 1;\n      k2 -= 2;\n    } else if (m == 1 || m == 2) {\n      k1 -= 1;\n      k2 += 1;\n    } else if (m == 3) {\n      k1 += 1;\n      k2 += 2;\n    }\n    rmN1 = Loadv4 (4 + 4 * k1).xyz;\n    rmN2 = Loadv4 (4 + 4 * k2).xyz;\n    if (m == 0) {\n      dr1 = rmN1 - rmN2;\n      dr2 = rm - rmN1;\n    } else if (m == 1 || m == 2) {\n      dr1 = rm - rmN1;\n      dr2 = rmN2 - rm;\n    } else if (m == 3) {\n      dr1 = rmN1 - rm;\n      dr2 = rmN2 - rmN1;\n    }\n    c11 = dot (dr1, dr1);\n    c12 = dot (dr1, dr2);\n    c22 = dot (dr2, dr2);\n    cd = sqrt (c11 * c22);\n    c = c12 / cd - 1.;\n    if (m == 0 || m == 3) c = - c;\n    am += fBend * (c / cd) * ((m <= 1) ? dr1 - (c12 / c22) * dr2 : (c12 / c11) * dr1 - dr2);\n  }  \n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  rSep = cylRad - length (rm.xy);\n  if (rSep < diamAv) {\n    dr = - rSep * normalize (vec3 (rm.xy, 0.));\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * cylRad * normalize (vec3 (rm.y, - rm.x, 0.));\n    h = dot (dr, dv) / (rSep * rSep);\n    fc = max (fc - fricN * h, 0.);\n    am += fc * dr;\n    dv -= h * dr + cross (wm, dr);\n    ft = min (fricT, fricS * abs (fc) * rSep / max (0.001, length (dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross (dr, dv);\n  }\n  dr.z = abs (rm.z) - cylLen;\n  rSep = abs (dr.z);\n  if (rSep < diamAv) {\n    dr.z *= sign (rm.z);\n    dr.xy = vec2 (0.);\n    fc = fOvlap * (diamAv / rSep - 1.);\n    dv = vm - angV * vec3 (- rm.y, rm.x, 0.);\n    h = dot (dr, dv) / (rSep * rSep);\n    fc -= fricN * h;\n    am += fc * dr;\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 200.;\n  fBend = 10.;\n  fricN = 5.;\n  fricT = 10.;\n  fricS = 0.5;\n  fDamp = 0.001;\n  grav = 2.;\n  p = Loadv4 (4 + 4 * mId);\n  rm = p.xyz;\n  diam = p.w;\n  vm = Loadv4 (4 + 4 * mId + 1).xyz;\n  qm = Loadv4 (4 + 4 * mId + 2);\n  wm = Loadv4 (4 + 4 * mId + 3).xyz;\n  ms = diam * diam * diam;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  PairInt (mId, rm, vm, wm, diam, am, wam);\n  BdyInt (rm, vm, wm, diam, am, wam);\n  am -= grav * gVec + fDamp * vm;\n  wam -= fDamp * wm;\n  vm += delT * am / ms;\n  rm += delT * vm;\n  wm += delT * wam / (0.2 * ms * diam);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * delT * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  float mIdf, r;\n  mIdf = float (mId);\n  r = 0.7 * cylRad;\n  rm = vec3 (r * sin (2. * pi * mod (0.9 * mIdf / (2. * pi * r), 1.) + vec2 (0.5 * pi, 0.)),\n     -0.9 * (mIdf - 0.5 * float (nBall)) / (2. * pi * cylLen));\n  vm = 2. * normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, wgBx[2], stDat, p, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas, ust;\n  float el, az, asp, diam, cylRot, cylEl, cylAz, angVMax, slVal, msMode;\n  int mId, pxId, wgSel, wgReg;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 4) discard;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= 4) mId = (pxId - 4) / 4;\n  else mId = -1;\n  wgReg = -2;\n  doInit = false;\n  if (iFrame <= 5) doInit = true;\n  asp = canvas.x / canvas.y;\n  delT = 0.005;\n  angVMax = 3.;\n  if (doInit) {\n    cylRad = 0.9 * floor (pow (float (nBall), 1./3.));\n    cylLen = cylRad;\n    nStep = 0.;\n    cylRot = 0.;\n    wgSel = -1;\n    slVal = 0.3;\n    angV = slVal * angVMax;\n    el = -0.08 * pi;\n    az = 0.;\n    cylEl = 0.;\n    cylAz = 0.;\n    msMode = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    cylRad = stDat.x;\n    cylLen = stDat.y;\n    angV = stDat.z;\n    cylRot = stDat.w;\n    stDat = Loadv4 (1);\n    el = stDat.x;\n    az = stDat.y;\n    cylEl = stDat.z;\n    cylAz = stDat.w;\n    mPtrP = Loadv4 (2);\n    stDat = Loadv4 (3);\n    nStep = stDat.x;\n    slVal = stDat.y;\n    wgSel = int (stDat.z);\n    msMode = stDat.w;\n    ++ nStep;\n    cylRot = mod (cylRot + delT * angV, 2. * pi);\n  }\n  if (mPtr.z > 0.) {\n    wgBx[0] = vec4 (0.42 * asp, 0., 0.015 * asp, 0.2);\n    wgBx[1] = vec4 (0.42 * asp, -0.44, 0.02, 0.);\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) - wgBx[0].zw;\n    if (max (ust.x, ust.y) < 0.) {\n      wgReg = 0;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) < wgBx[1].z) {\n      if (mPtrP.z <= 0.) msMode = 1. - msMode;\n    } else if (wgSel < 0) {\n      if (msMode == 0.) {\n        cylAz = -2. * pi * mPtr.x;\n        cylEl = - 2. * pi * mPtr.y;\n      } else {\n        az = 2. * pi * mPtr.x;\n        el = clamp (-0.08 * pi + pi * mPtr.y, -0.45 * pi, 0.);\n      }\n    }\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel == 0) {\n    slVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx[0].y) / wgBx[0].w, 0., 1.);\n    angV = slVal * angVMax;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), cylEl));\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (cylRad, cylLen, angV, cylRot);\n  else if (pxId == 1) stDat = vec4 (el, az, cylEl, cylAz);\n  else if (pxId == 2) stDat = mPtr;\n  else if (pxId == 3) stDat = vec4 (nStep, slVal, float (wgSel), msMode);\n  else {\n    mId = pxId - (4 + 4 * mId);\n    stDat = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QtToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize (q);\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXDD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1223, 1223, 1244, 1244, 1318], [1320, 1320, 1342, 1342, 1420], [1493, 1493, 1515, 1515, 2700], [2702, 2702, 2735, 2735, 2919], [2921, 2921, 2942, 2942, 3199], [5422, 5422, 5482, 5482, 6222], [6224, 6224, 6269, 6269, 8404], [8406, 8406, 8479, 8479, 9385], [9387, 9387, 9440, 9440, 10292], [10294, 10294, 10340, 10340, 10387], [10389, 10389, 10431, 10431, 10482], [10484, 10484, 10530, 10530, 10587], [10589, 10589, 10625, 10625, 10713], [10715, 10715, 10740, 10740, 11136], [11138, 11138, 11174, 11174, 11380], [11382, 11382, 11412, 11412, 11525], [11527, 11527, 11551, 11551, 11673], [11707, 11707, 11731, 11731, 11843], [11845, 11845, 11870, 11870, 12056], [12058, 12058, 12079, 12079, 12234], [12328, 12328, 12353, 12353, 12476]]}
{"id": "fdBXWW", "name": "Rotating Hour Glasses", "author": "DEKTEN", "description": "www.twitch.com/kanjicoder     <--Render Engine\nhttps://d3m0.herokuapp.com/  <--Tech Demos\nCompositing box gradients to create two box wire frames. Pinching those wire frames. And then rotating them in opposite directions by rotating their input UVs.", "tags": ["rotation", "boxgradient"], "likes": 0, "viewed": 220, "published": 3, "date": "1620184129", "time_retrieved": "2024-07-30T19:21:45.881756", "image_code": "//: www.twitch.com/kanjicoder\n//: Been working on a fractal auto tiling engine.\n//: I made a build system that allows me to compile C99 as\n//: C99 or GLSL. Which allows me to run unit tests on my\n//: shader code. Come give me a visit and I'll give you\n//: a technical demo and explain why I think I am up to\n//: something no one has ever done before.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //: org: origin\n    //: u_v: UV's as in UVW\n    //: sg1 , sg2 : Square_Gradient 1 & 2\n    //: ca1 , ca2 : Current Angles 1 & 2\n    //: l_1 , l_2 : lengths 1 & 2\n    //: uv1 , uv2 : u_v copies 1 & 2\n    //: c_1 , c_2 : Colors 1 & 2\n    //: t_1 , t_2 : Thickness 1 & 2\n    //: d_1 , d_2 : Distance 1 & 2\n    //: v_a ......: Variable \"A\" (yes, not creative at all)\n    \n    //:Center Gradient , copy UVs twice:\n        vec2  u_v = ((fragCoord.xy * 2.0)-iResolution.xy) / iResolution.y ;\n        vec2  uv1 = vec2( u_v );\n        vec2  uv2 = vec2( u_v );\n    \n    //:Rotate Two Sets Of UV's in opposite directions:\n    //:SEE[ https://www.shadertoy.com/view/Mt2XDK ]\n        vec2 org = vec2(0.0, 0.0) ;\n        float ca1 = -(iTime * 36.0); //:current_angle_1\n        float ca2 = +(iTime * 36.0); //:current_angle_2\n\n        uv1 -= org;\n        float ang_001 = radians(90.0) - radians(ca1) + atan(uv1.y, uv1.x);\n        float l_1 = length(uv1);\n        uv1 = vec2(cos(ang_001) * l_1, sin(ang_001) * l_1) + org;\n\n        uv2 -= org;\n        float ang_002 = radians(90.0) - radians(ca2) + atan(uv2.y, uv2.x);\n        float l_2 = length(uv2);\n        uv2 = vec2(cos(ang_002) * l_2, sin(ang_002) * l_2) + org;\n\n        uv1.x = uv1.x / ( uv1.y);\n        uv1.y = uv1.y / ( 0.5  );\n\n        uv2.x = uv2.x / ( 0.5  );\n        uv2.y = uv2.y / ( uv2.x);\n    \n    //:Create Square Gradients:\n        vec2  sg1 = vec2( max( abs(uv1.x),abs(uv1.y) ) );\n        vec3  c_1 = vec3( 1.0 );\n\n        vec2  sg2 = vec2( max( abs(uv2.x),abs(uv2.y) ) );\n        vec3  c_2 = vec3( 1.0 );\n    \n    //:Create Box Lines:\n        float t_1=(cos(iTime*1.0)*2.0); //:Thickness #1\n        float t_2=(sin(iTime*1.0)*2.0); //:Thickness #2\n     \n        float d_1 = length(sg1 - vec2(clamp(sg1.x,-.5,.5),0));\n        c_1 -= (smoothstep( 1.00-t_1 , 1.00         , d_1 )); //:blackBox\n        c_1 -= (smoothstep( 1.00-t_1 , 1.00-t_1-t_1 , d_1 )); //:Whitebox\n\n        float d_2 = length(sg2 - vec2(clamp(sg2.x,-.5,.5),0));\n        c_2 -= (smoothstep( 1.00-t_2 , 1.00         , d_2 )); //:blackBox\n        c_2 -= (smoothstep( 1.00-t_2 , 1.00-t_2-t_2 , d_2 )); //:Whitebox\n\n    //:Blend Two Patterns:\n        vec3 v_a =( c_1 + c_2 );\n  \n     fragColor = vec4( (v_a) , 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBXWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 352, 409, 826, 2652]]}
{"id": "fdBSWW", "name": "Fork glitch boi arqb 036", "author": "arqb", "description": "glitch", "tags": ["glitch", "vhs"], "likes": 3, "viewed": 670, "published": 3, "date": "1620180055", "time_retrieved": "2024-07-30T19:21:46.638732", "image_code": "float rand(vec2 p)\n{\n    float t = floor(iTime * 20.) / 10.;\n    return fract(sin(dot(p, vec2(t * 12.9898, t * 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 uv, float blockiness)\n{   \n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    float n1 = rand(id);\n    float n2 = rand(id+vec2(1,0));\n    float n3 = rand(id+vec2(0,1));\n    float n4 = rand(id+vec2(1,1));\n    \n    vec2 u = smoothstep(0.0, 1.0 + blockiness, lv);\n\n    return mix(mix(n1, n2, u.x), mix(n3, n4, u.x), u.y);\n}\n\nfloat fbm(vec2 uv, int count, float blockiness, float complexity)\n{\n    float val = 0.0;\n    float amp = 0.5;\n    \n    while(count != 0)\n    {\n    \tval += amp * noise(uv, blockiness);\n        amp *= 0.5;\n        uv *= complexity;    \n        count--;\n    }\n    \n    return val;\n}\n\nconst float glitchAmplitude = 0.2; // increase this\nconst float glitchNarrowness = 4.0;\nconst float glitchBlockiness = 2.0;\nconst float glitchMinimizer = 5.0; // decrease this\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 a = vec2(uv.x * (iResolution.x / iResolution.y), uv.y);\n    vec2 uv2 = vec2(a.x / iResolution.x, exp(a.y));\n\tvec2 id = floor(uv * 8.0);\n    //id.x /= floor(texture(iChannel0, vec2(id / 8.0)).r * 8.0);\n\n    // Generate shift amplitude\n    float shift = glitchAmplitude * pow(fbm(uv2, int(rand(id) * 6.), glitchBlockiness, glitchNarrowness), glitchMinimizer);\n    \n    // Create a scanline effect\n    float scanline = abs(cos(uv.y * 400.));\n    scanline = smoothstep(0.0, 2.0, scanline);\n    shift = smoothstep(0.00001, 0.2, shift);\n    \n    // Apply glitch and RGB shift\n    float colR = texture(iChannel0, vec2(uv.x + shift, uv.y)).r * (1. - shift) ;\n    float colG = texture(iChannel0, vec2(uv.x - shift, uv.y)).g * (1. - shift) + rand(id) * shift;\n    float colB = texture(iChannel0, vec2(uv.x - shift, uv.y)).b * (1. - shift);\n    // Mix with the scanline effect\n    vec3 f = vec3(colR, colG, colB) - (0.1 * scanline);\n    \n    // Output to screen\n    fragColor = vec4(f, 1.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBSWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 137], [139, 139, 179, 179, 484], [486, 486, 553, 553, 765], [944, 944, 1001, 1051, 2083]]}
{"id": "NdfSRr", "name": "Inverse Reflection - Disk I", "author": "oneshade", "description": "Finally learned how to transform it into a quartic polynomial with t-formulae and solved it: [url=https://www.qc.edu.hk/math/Certificate%20Level/t%20method.htm]https://www.qc.edu.hk/math/Certificate%20Level/t%20method.htm[/url]", "tags": ["reflection", "math", "light", "physics", "quartic", "optics", "inverse", "disk", "tformulae"], "likes": 14, "viewed": 177, "published": 3, "date": "1620178940", "time_retrieved": "2024-07-30T19:21:47.646039", "image_code": "// Formulating and simplifying the problem as an equation: https://www.desmos.com/calculator/tnxdrshgt3\n// Attempting to solve the equation: https://www.desmos.com/calculator/ybqpz6ypwy\n// Not sure how to deal with incorrect side reflections due to bad quadrant information in atan().\n// Works fine for near and far incidence points though aside from precision issues.\n\n// Drawing utilities\n#define drawSDF(dist, transp, col) color = mix(color, col, smoothstep(unit, 0.0, dist) * transp)\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n// tx: transmitter\n// rx: receiver\n// pos: disk position\n// rad: disk radius\nint getIncidences(in vec2 tx, in vec2 rx, in vec2 pos, in float rad, out vec2[4] incidences) {\n    rx -= pos, tx -= pos;\n\n    vec2 tr1 = tx + rx;\n    vec2 tr2 = rx * mat2(tx.yx, tx.x, -tx.y);\n\n    float k = rad * sqrt(dot(tr1, tr1) / dot(tr2, tr2));\n    float a1 = atan(tr2.x / tr2.y), a2 = atan(tr1.y / tr1.x);\n\n    float shift = 0.5 * a1;\n    float sa = shift - a2;\n\n    vec2 bd = vec2(4.0, -4.0) / sin(sa) / k - 2.0 / tan(sa); // Coefficients (a=1, c=0, e=-1)\n    vec4 t;\n\n    // Solve a quartic equation in tan(x/2)\n    float bb = bd.x * bd.x;\n    float p = -0.375 * bb;\n    float q = bd.y + 0.125 * bb * bd.x;\n    float r = -1.0 - 0.25 * bd.x * bd.y - 0.01171875 * bb * bb;\n    int n = 0; // Root counter\n\n    // Solve for an arbitary root to x^3 + 2px^2 + (p^2 - 4r)x - q^2\n    float ra = 2.0 * p;\n    float rb = p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float raa = ra * ra;\n    float inflect = ra / 3.0;\n\n    float rp = rb - raa / 3.0;\n    float rq = raa * ra / 13.5 - ra * rb / 3.0 + rc;\n    float rppp = rp * rp * rp, rqq = rq * rq;\n\n    float p2 = abs(rp);\n    float v1 = 1.5 / rp * rq;\n\n    float lambda;\n    if (rqq * 0.25 + rppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (rp < 0.0) lambda = sign(rq) * cosh(acosh(v2 * -sign(rq)) / 3.0);\n        else lambda = sinh(asinh(v2) / 3.0);\n        lambda = -sqrt(p2 / 3.0) * lambda;\n    }\n\n    else lambda = sqrt(-rp / 3.0) * cos(acos(v1 * sqrt(-3.0 / rp)) / 3.0);\n    lambda = 2.0 * lambda - inflect;\n\n    // Solve two quadratic equations (checking for negative sqrts which should be complex)\n    if (lambda < 0.0) return n;\n    float sqrtLambda = sqrt(lambda);\n\n    float pLambda = p + lambda, qLambda = q / sqrtLambda;\n    float offs = 0.25 * bd.x;\n\n    float foo = lambda - 2.0 * (pLambda + qLambda);\n    float bar = lambda - 2.0 * (pLambda - qLambda);\n\n    if (foo >= 0.0) {\n        vec2 qRoots = atan((vec2(1.0, -1.0) * sqrt(foo) + sqrtLambda) * 0.5 - offs) * 2.0 + shift;\n\n        incidences[0] = vec2(cos(qRoots.x), sin(qRoots.x)) * rad + pos;\n        incidences[1] = vec2(cos(qRoots.y), sin(qRoots.y)) * rad + pos;\n\n        n += 2;\n    }\n\n    if (bar >= 0.0) {\n        vec2 qRoots = atan((vec2(1.0, -1.0) * sqrt(bar) - sqrtLambda) * 0.5 - offs) * 2.0 + shift;\n\n        incidences[n    ] = vec2(cos(qRoots.x), sin(qRoots.x)) * rad + pos;\n        incidences[n + 1] = vec2(cos(qRoots.y), sin(qRoots.y)) * rad + pos;\n\n        n += 2;\n    }\n\n    return n;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float unit = 8.0 / iResolution.y;\n\n    // Default if mouse is not set\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        mouse = vec4(2.541, 0.722, 0.402, 1.638);\n    }\n\n    vec2 light = mouse.zw;\n    vec2 point = mouse.xy;\n\n    vec2 reflectorPos = vec2(0.0, 0.0);\n    float reflectorRadius = 1.0 + 0.25 * sin(iTime);\n\n    // Draw the reflector\n    drawSDF(sdDisc(uv, reflectorPos, reflectorRadius) - 0.01, 1.0, vec3(0.0, 0.0, 1.0));\n\n    // Draw light path\n    vec2[4] i;\n    int n = getIncidences(light, point, reflectorPos, reflectorRadius, i);\n    for (int k=0; k < n; k++) {\n        vec2 fromLight = i[k] - light;\n        vec2 toPoint = point - i[k];\n        drawSDF(sdVectorArrow(uv - light, fromLight - normalize(fromLight) * 0.2) + 0.01, 1.0, vec3(1.0));\n        drawSDF(sdVectorArrow(uv - i[k], toPoint - normalize(toPoint) * 0.2) + 0.01, 1.0, vec3(1.0));\n    }\n\n    // Draw light, point, and incident point\n    drawSDF(sdDisc(uv, light, 0.05), 1.0, vec3(0.0, 1.0, 0.0));\n    drawSDF(sdDisc(uv, point, 0.05), 1.0, vec3(1.0, 0.0, 0.0));\n    for (int k=0; k < n; k++) {\n        drawSDF(sdDisc(uv, i[k], 0.05), 1.0, vec3(1.0, 0.8, 0.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfSRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 497, 545, 545, 577], [579, 579, 626, 626, 734], [736, 736, 781, 781, 849], [851, 851, 905, 905, 1181], [1183, 1183, 1226, 1226, 1414]]}
{"id": "7dSSW1", "name": "Free voronoi cells", "author": "iapafoto", "description": "Some tools to play with voronoi cells\n", "tags": ["2d", "voronoi", "worley", "cells", "polygon"], "likes": 31, "viewed": 806, "published": 3, "date": "1620167321", "time_retrieved": "2024-07-30T19:21:48.651353", "image_code": "// Created by Sebastien Durand - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------\n// Inspired by \n// tomkh [Faster Voronoi Edge Distance] https://shadertoy.com/view/llG3zy\n// iq    [Voronoi - distance]           https://www.shadertoy.com/view/ldl3W8\n// https://iquilezles.org/articles/voronoilines\n//-----------------------------------\n// An other way to extract polygons in a stylish shader\n// shane [Triangle-Voronoi Graph Weave] https://www.shadertoy.com/view/XsycDd\n// 3D voronoi cell distance field\n// iapafoto [https://www.shadertoy.com/view/ssBXWW] https://www.shadertoy.com/view/ssBXWW\n//-----------------------------------\n\n#define ANIMATE\n#define WITH_BOUNDING_CIRCLE\n//#define WITH_INSCRIBE_CIRCLE\n\n// How far cells can go off center during animation \n// minimal voronoi doesn not like more than .3 \n#define ANIMATE_D .3\n\n// get ids in a cyclic order to i,j neigbourg elements\n#define ID_POS(x) clamp(abs(4.-8.*fract(vec2(x+3,x-3)/8.))-2.,-1.,1.)\n//#define ID_POS(id) vec2(clamp(abs((id-ivec2(27,29))%8+4)-2,-1,1)) // % does not likes negative values\n\nfloat time;\n\n//-----------------------------------\n// cells position that show how to put limits on cells\n// an intersection with a bbox distance field may do the job also\n//-----------------------------------\nvec2 hash2(vec2 p) {\n    vec2 o = ANIMATE_D*texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    o = ANIMATE_D*cos(.5*(3.+o)*time + o*6.2831853);\n    // Stop noise on borders\n         if (p.x >= 3.) return vec2(-.3,p.y<-1.?.3:p.y>=3.?-.3:0.);\n    else if (p.x < -1.) return vec2(.3,p.y<-1.?.3:p.y>=3.?-.3:0.);\n         if (p.y >= 3.) return vec2(0,-.3);\n    else if (p.y < -1.) return vec2(0,.3);\n    return o;\n}\n\n//-----------------------------------\n// Minimalist voronoi distance for one cell\n// Inexact outside of cells\n// Generalisable to 3D cells\n//-----------------------------------\nvec3 sdVoronoiCell(in vec2 p, in vec2 cellId ) {\n    float md = 8.0;    \n    vec2 mr = hash2(cellId);\n    for(int i=0; i<8; i++) {\n        vec2 g = ID_POS(i),\n             r = g + hash2(cellId + g);\n        md = min(md, dot(.5*(mr+r)-p, normalize(r-mr)));\n    }\n    return vec3(-md, mr-p);\n}\n\n//-----------------------------------\n// Indicate if a point is inside a voronoi cell\n//-----------------------------------\nbool isInsideVoronoiCell(in vec2 p, in vec2 cellId) {\n    float dm = length(hash2(cellId)-p);\n    for(int i=0; i<8; i++) {\n        vec2 g = ID_POS(i),\n             r = g + hash2(cellId + g);\n        if (length(r-p) < dm) return false;\n    }\n    return true;\n}\n\n//-----------------------------------\n// Draw construction lines on voronoi\n//-----------------------------------\nvec3 drawVoronoiLines(in vec2 p, in vec2 cellId) {\n    vec2 rm = hash2(cellId); // center of cell\n    vec3 d = vec3(999.);\n    for(int i=0; i<8; i++) {\n        vec2 g = ID_POS(i),                     // relative pos of neigbourg cell\n             r = g + hash2(cellId + g),         // center of the neigbourg cell\n             n = r - rm,                     \n             c = rm + n*.5;                     // ref pt between cells\n        n = normalize(vec2(-n.y,n.x));          // normal on the edge\n        d = min(d, vec3(length(c-p),            // distance to the \n                        sdSegment(p,r,rm),      // distance to segment between cells \n                        sdSegment(p,c+n,c-n))); // distance to edge of cell\n    }\n    return d;\n}\n\n//-----------------------------------\n// Extract voronoi cell polygon\n//-----------------------------------\nvec2[8] getVoronoiPolygon(in vec2 p, in vec2 cellId, out int out_sz) {\n\tvec2 rm = hash2(cellId); // center of cell\n    vec2 c[8], n[8];\n    // Get liste of lines\n    for(int i=0; i<8; i++) {\n        vec2 g0 = ID_POS(i),\n             r0 = g0 + hash2(cellId + g0),  // centre de l'autre cellule\n             n0 = r0 - rm;\n         c[i] = rm + n0*.5;  // Pt entre les 2 cellules             \n         n[i] = normalize(vec2(-n0.y,n0.x));\n    }\n    // Find intersection between lines\n    vec4 seg[8]; // x:-2 y:-1 z:+1 w:+2  \n    for(int i=2; i<10; i++) { // Intersection point with two previous lines\n        vec2 t1 = intersect(c[i%8], n[i%8], c[(i-1)%8], n[(i-1)%8]),\n             t2 = intersect(c[i%8], n[i%8], c[(i-2)%8], n[(i-2)%8]);\n        seg[i%8].x = t2.x;     // -2 of seg  0\n        seg[i%8].y = t1.x;     // -1 of seg  0\n        seg[(i-1)%8].z = t1.y; // +1 of seg -1\n        seg[(i-2)%8].w = t2.y; // +2 of seg -2      \n    }\n    // Reconstruct the polygon\n    out_sz = 0;\n    for(int i=0; i<8; i++) {\n        float dmin = max(seg[i].z,seg[i].w);\n        if (dmin < min(seg[i].x,seg[i].y)) { // skip useless segments\n            n[out_sz] = c[i]+dmin*n[i];\n            out_sz++;\n        }\n    }\n    return n;\n}\n\n\n//-----------------------------------\n// Animate all this\n//-----------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    time = mod(iTime-4., 40.);\n    \n    // Animation ticks\n    float a0 = smoothstep( 7., 5.,time),\n          a1 = smoothstep( 2., 5.,time),\n          a2 = smoothstep( 8.,11.,time)-smoothstep(14.,17.,time),\n          a5 = smoothstep(28.,32.,time),\n          a4 = smoothstep(20.,22.,time)-a5,\n          a3 = smoothstep(14.,16.,time)-a5;\n    \n    // Coords on screen\n    float sc = step(512., iResolution.y)*4. + 6., // Scale differently for fullscreen\n\t      ss = (a5+sc) / iResolution.y; // Size of 1 pixel\n    vec2 p = (fragCoord.xy - iResolution.xy*.5)*ss + .4;\n    float k = 1.+a5;                    // Separation distance between cells\n    p *= 1.-.4*a5;\n    p += (1.5+.5*cos(.5*iTime))*a5;\n    \n    // The selected cell\n    vec2 cellId = vec2(1,1);\n\n    float d2 = 999., d = 999., dm;\n    // Very slow to display cell by cell like this but this enables the final effect! :)\n    // for normal cases, use Faster Voronoi Edge Distance\" by tomkh. https://shadertoy.com/view/llG3zy\n    for( int j=-2; j<=3; j++)\n    for( int i=-2; i<=3; i++) {\n         vec2 g = vec2(i,j);\n         if (length(k*g-p)<1.5) { // do it only on neighbourhood\n             vec3 v = sdVoronoiCell(p-k*g, g);\n             d  = min(d,v.x);\n             d2 = min(d2, length(v.yz));\n         }\n    }\n    \n    // Find if a pixel is inside a specified cell\n    bool insideCell = isInsideVoronoiCell(p-cellId*k, cellId);\n    \n    // Find if a pixel is inside a specified cell\n    vec3 dseg = drawVoronoiLines(p-cellId*k, cellId);\n    \n    // Extract polygon\n    int out_psz;\n    vec2[8] poly = getVoronoiPolygon(p-cellId*k, cellId, out_psz);\n    float dPoly = sdPolygon(p-cellId*k, poly, out_psz);\n    // Dots of polygon\n    float d1 = 999.;\n    for(int i=0; i<out_psz; i++) {\n        d1 = min(d1, length(p-cellId*k-poly[i])-.05);\n    }\n    \n    // Display the animation\n    float dall;\n    if (a5 > 0.) {\n        dall = dPoly;\n    } else {\n        dall = d;\n        if (dall>0.) dall = sdBox(p-vec2(.47,.47),vec2(2.7,2.7)); // fake outside for full square display\n    }\n    vec3 col = vec3(1) - sign(dall)*vec3(.1,.4,.7);\n\tcol *= 1. - exp(-2.*abs(dall));\n\tcol *= .8 + .2*cos(120.*dall);\n    col *= a0+a5;\n#ifdef WITH_BOUNDING_CIRCLE    \n    if (a4>0.) {\n        vec3 circle = minimumEnclosingCircle(poly,out_psz); \n        col = mix(col, vec3(.4), a4*smoothstep(.07,.04,abs(length(p-cellId*k - circle.xy)-circle.z)-.035)); \n    }\n#endif  \n#ifdef WITH_INSCRIBE_CIRCLE    \n    if (anim4>0.) {\n        vec3 circle = findInscribeCircle(poly,out_psz);\n        col = mix(col, vec3(1.), anim4*smoothstep(.02,.0,abs(length(p-cellId*k - circle.xy)-circle.z)-.01)); \n    }\n#endif  \n    if (insideCell) col = mix(col,vec3(1,0,0),.4*(a1-a5)); \n\tcol = mix(col, vec3(1.),        (.2*(1.-a5)+.8*a0)*smoothstep(.03,0.,abs(d))); // borders\n   \tcol = mix(col, vec3(1.),        a2*smoothstep(.05,.03,abs(d2)));               // centers\n    col = mix(col, vec3(1.,0,0),    a3*smoothstep(.02,.0,dseg.z));                 // segments\n    col = mix(col, vec3(1.),           smoothstep(.03,.0,abs(dPoly)));             // polygon\n    col = mix(col, vec3(1.),        a2*smoothstep(.02,.0,dseg.y));\n    col = mix(col, vec3(0.5,.8,.8), a4*smoothstep(.03,.02,d1));                    // points\n    col = mix(col, vec3(1.),        a4*smoothstep(.03,.01,abs(d1-.04)));\n    col = mix(col, vec3(1.,0,0),    a2*smoothstep(.07,.05,dseg.x));\n    col = mix(col, vec3(1),        a2*smoothstep(.03,.01,abs(dseg.x-.07)));    \n\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa - ba*h);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.)) + min(max(d.x,d.y),0.);\n}\n\n// iq: https://www.shadertoy.com/view/wdBXRW\nfloat sdPolygon(in vec2 p, in vec2[8] v, int num ) {\n    float s = 1., d = dot(p-v[0],p-v[0]);\n    for( int i=0, j=num-1; i<num; j=i, i++ ) {\n        vec2 e = v[j] - v[i], w = p - v[i],\n             b = w - e*clamp( dot(w,e)/dot(e,e), 0., 1.);\n        d = min(d, dot(b,b));\n        bvec3 cond = bvec3(p.y>=v[i].y, p.y <v[j].y,  e.x*w.y>e.y*w.x );\n        if (all(cond) || all(not(cond))) s=-s;  \n    }\n    return s*sqrt(d);\n}\n\n// basic line line intersection\nvec2 intersect(vec2 p0, vec2 n0, vec2 p1, vec2 n1) {\n    float d = n0.x*n1.y-n0.y*n1.x; // 0 if paralelle but does not append here\n    vec2 p = (p0-p1)/d;\n    return vec2(p.y*n1.x-p.x*n1.y, p.y*n0.x-p.x*n0.y);\n}\n\n\n// https://www.geeksforgeeks.org/minimum-enclosing-circle-set-1/\n\nfloat INF = 1e5;\n  \n// Function to check whether a vec2 lies inside\n// or on the boundaries of the vec3\nbool isInside(vec3 c, vec2 p) {\n    return distance(c.xy, p) <= c.z;\n}\n\n// Function to return the smallest vec3\n// that intersects 2 Points\nvec3 circleFrom(vec2 A, vec2 B) {\n    vec2 C = .5*(A+B); // Set the center to be the midPoint of A and B\n    return vec3(C, distance(A,B)*.5); // Set the radius to be half the distance AB\n}\n\n  \n// The following two functions are the functions used\n// To find the equation of the vec3 when three Points are given.\n// Helper method to get a vec3 defined by 3 Points\nvec2 getCircleCenter(vec2 b, vec2 c) {\n    float B = dot(b,b),\n          C = dot(c,c),\n          D = b.x * c.y - b.y * c.x;\n     return vec2(c.y*B-b.y*C, b.x*C-c.x*B) / (D+D);\n}\n\n// Function to return a unique vec3 that intersects\n// three Points\nvec3 circleFrom(vec2 A, vec2 B, vec2 C) {\n    vec2 I = getCircleCenter(B-A,C-A) + A;\n    return vec3(I, distance(I, A));\n}\n\n// Function to check whether a vec3 encloses the given Points\nbool isValidCircle(vec3 c, vec2[8] P, int num) { \n    // Iterating through all the Points to check\n    // whether the Points lie inside the vec3 or not\n    for (int i=0; i<num; i++)\n        if (distance(c.xy, P[i]) > c.z+1e-2)\n            return false;\n    return true;\n}\n \n// Function to return find the minimum enclosing\n// vec3 from the given set of Points\nvec3 minimumEnclosingCircle(vec2[8] P, int n) {\n    if (n == 0) return vec3(0);\n    if (n == 1) return vec3(P[0],0);\n  \n    vec3 mec = vec3(0,0,INF);\n    // Go over all pair of Points\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n              // Get the smallest circle that intersects P[i] and P[j]\n            vec3 tmp = circleFrom(P[i], P[j]);\n            // Update MEC if tmp encloses all Points and has a smaller radius\n            if (tmp.z < mec.z && isValidCircle(tmp, P, n))\n                mec = tmp;\n        }\n    }\n  \n    // Go over all triples of Points\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                // Get the vec3 that intersects P[i], P[j], P[k]\n                vec3 tmp = circleFrom(P[i], P[j], P[k]);\n                // Update MEC if tmp encloses all Points and has smaller radius\n                if (tmp.z < mec.z && isValidCircle(tmp, P, n))\n                    mec = tmp;\n            }\n        }\n    }\n    return mec;\n}\n\n// does not calculate sign\nfloat sdPoly(in vec2 p, in vec2[8] v, int num ) {\n    float d = dot(p-v[0],p-v[0]);\n    for(int i=0, j=num-1; i<num; j=i, i++ ) {\n        vec2 e = v[j] - v[i], w = p - v[i],\n             b = w - e*clamp(dot(w,e)/dot(e,e), 0., 1.);\n        d = min(d, dot(b,b));\n    }\n    return -sqrt(d);\n}\n\n#define NB_ITER 14\n// Not very acurate\nvec3 findInscribeCircle(vec2[8] P, int n) {\n    vec2 p0,p=P[0]; // p0 to avoid too much occilation\n    for (int i=1; i<n; i++) p+=P[i];\n    p0 = p/=float(n); // start at mass center of points\n    // find scale of polygon\n    float d, len = 1e5; \n    for (int i=1; i<n; i++) if ((d=distance(p,P[i]))<len) len = d;\n    // gradiant descent to find min value of distance field\n    float dt = .4*len;\n    vec2 dd = vec2(.1*dt,0);\n    for (int i=0; i<NB_ITER; i++) {\n        p0 = p;\n        p -= dt*normalize(vec2(sdPoly(p+dd,P,n)    - sdPoly(p-dd,P,n), \n                               sdPoly(p+dd.yx,P,n) - sdPoly(p-dd.yx,P,n)));\n        dt *= .8;\n    }\n    return vec3((p+p0)*.5, -sdPolygon((p+p0)*.5, P, n));\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSSW1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1157, 1354, 1374, 1374, 1765], [1767, 1944, 1992, 1992, 2235], [2237, 2361, 2414, 2414, 2620], [2622, 2736, 2786, 2786, 3489]]}
{"id": "sd2SWh", "name": "Fork Parallax SpectaJin 012", "author": "spectajin", "description": "Quick crystals parallax occlusion - unoptimized", "tags": ["parallaxocclusion"], "likes": 6, "viewed": 252, "published": 3, "date": "1620158852", "time_retrieved": "2024-07-30T19:21:49.412317", "image_code": "// Made by Darko Supe (omegasbk) 3.5.2021.\n// Sub here youtube.com/c/DarkoSupe for educational videos\n\nstruct Camera\n{\n    vec3 position;\n    vec3 direction;\n    float focalDistance;\n};\n\nCamera camera = Camera(\n    vec3(0., 0., -.3), \n    vec3(1., 0., 1.),\n    0.5);\n    \nstruct Material \n{\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambience;\n    float reflection;\n};\n\nconst Material material = Material(0.4, 0.2, 76.8, 0.8, 0.1);\n\nstruct Plane \n{\n    vec3 position;\n    vec3 normal;\n    vec3 color;\n    Material material;\n};\n\nPlane plane = Plane(\n    vec3(0., -0.3, 0.), \n    vec3(0., 1., 0.), \n    vec3(0.2, 0.2, 0.2), \n    material);\n    \nstruct PointLight\n{\n    vec3 position;\n    float intensity;\n};\n\nPointLight light = PointLight(\n    vec3(0.12, 11.5, 10.), // position\n    10.);              // intensity\n\nvec3 getLitColor(in vec3 viewDir, in vec3 surfacePointPosition, in vec3 objectColor, in PointLight pointLight, in vec3 surfaceNormal, in Material material)\n{\n    vec3 lightVector = surfacePointPosition - pointLight.position;\n    vec3 lightDir = normalize(lightVector);   \n    \n   \tfloat lightIntensity = (pow(0.05, 12.) / pow(length(lightVector), 12.)) * pointLight.intensity;\n    \n    float coeff = -dot(lightDir, surfaceNormal);     \n    \n    vec3 ambient = material.ambience * objectColor;\n        \n    vec3 diffuse = material.diffuse * max(coeff, 0.) * objectColor * lightIntensity;\n       \n    vec3 halfwayDir = normalize(lightDir + viewDir);  \n    vec3 specular = pow(max(-dot(surfaceNormal, halfwayDir), 0.2), material.shininess) * material.specular * objectColor * lightIntensity;\n    \n    vec3 color = ambient + diffuse + specular;\n    \n    return color;\n}\n\nbool intersectPlane(in Plane plane, in vec3 origin, in vec3 rayDirection, out float t, out vec3 pHit) \n{    \n    // Assuming vectors are all normalized\n    float denom = dot(plane.normal, rayDirection); \n    if (denom < 1e-6) \n    { \n        vec3 p0l0 = plane.position - origin; \n        t = dot(p0l0, plane.normal)  - normalize(denom / iTime);\n        \n        if (t >= 0.)\n        {\n            pHit = origin + rayDirection * t;\n            return true;\n        }             \n    } \n \n    return false; \n} \n\n#define RESOLUTION 0.1\n#define MAP_SCALE 2.\n\nfloat getDepth(vec2 coord, float scale)\n{\n    return (.0000013602 - texture(iChannel1, coord).r) * scale ;\n}\n\nvec3 getParallax(vec3 pHit, vec3 direction, float scale)\n{\n    float height = getDepth(pHit.xz, scale);\n    \n    vec3 newPoint = pHit;\n    newPoint.y = height;\n    \n    const float layerCount = 10.;\n    const float layerSize = 1.5 / layerCount;\n    \n    for (int i = 0; i < int(layerCount); i++)\n    {\n        vec3 point = pHit + direction * layerSize * float(i) * iTime;\n        float sampleDepth = getDepth(point.xz, scale);\n        if (sampleDepth < float(i) * layerSize)\n        {\n            newPoint = point;\n            newPoint.y = sampleDepth;\n            return newPoint;\n        }\n    }\n    \n    return newPoint;\n}\n\nvec3 rayTrace(vec3 origin, vec3 direction, float scale)\n{\n    float dist;\n    vec3 pHit;\n\n    Plane parallaxPlane = plane; \n    \n    if (intersectPlane(parallaxPlane, origin, direction, dist, pHit))\n    {\n        pHit *= MAP_SCALE * cos(iTime/-50.1) / sin(iTime/-50.1);\n        \n        pHit = getParallax(pHit, direction, scale);        \n        \n        vec3 right = pHit + vec3(RESOLUTION, 10., 0.34);\n        right = getParallax(right, normalize(right - pHit), scale);\n        right.y = getDepth(right.xz, scale);\n        vec3 down = pHit + vec3(0., 0., RESOLUTION); \n        down = getParallax(down, normalize(down - pHit), scale);\n        down.y = getDepth(down.xz, scale);\n        \n        vec3 a = normalize(right - pHit);\n        vec3 b = normalize(down - pHit);\n        \n        vec3 normal = cross(a, b);\n                        \n        vec3 texColor = texture(iChannel1, pHit.xz).rrr;\n        texColor = mix(texture(iChannel2, pHit.zz * pHit.y).rrr, texColor, -4.5);\n        texColor *= vec3(-0.4197614, 0.3396, -0.13944) * 1.0;\n        vec3 baseColor = getLitColor(direction, pHit, texColor, light, normal, plane.material).rgb;\n         \n        vec3 refl = reflect(direction, normal);\n        vec3 reflColor = texture(iChannel0, refl).rgb;\n        \n        return mix(baseColor, reflColor, plane.material.reflection);\n    }\n    \n    return texture(iChannel0, direction).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - cos(iTime * 0.00015);\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    float rotation = cos(iTime / 93.);\n    camera.position = vec3(cos(rotation), 0.00195, sin(rotation)) * camera.focalDistance;\n    camera.direction = normalize(vec3(0., clamp((iMouse.y / 200.) - 4., -4., -2.), 0.) + camera.position);\n    vec3 right = normalize(cross(camera.direction, vec3(0., 1., 0.)));\n    vec3 up = cross(right, camera.direction);\n   \tvec3 dir =  normalize(uv.x * right + uv.y * up + camera.direction);\n    \n    light.position = camera.position;\n                 \n    vec3 finalColor = rayTrace(camera.position, dir, 20.7); \n     \n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}", "image_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2SWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[841, 841, 998, 998, 1706], [1708, 1708, 1812, 1859, 2216], [2264, 2264, 2305, 2305, 2372], [2374, 2374, 2432, 2432, 2999], [3001, 3001, 3058, 3058, 4392], [4394, 4394, 4451, 4507, 5239]]}
{"id": "sd2XWh", "name": "Color Illusion Demo", "author": "drayde", "description": "Optical Illusion inspired by https://twitter.com/NovickProf/status/1389225250437615619", "tags": ["illusion"], "likes": 1, "viewed": 188, "published": 3, "date": "1620157738", "time_retrieved": "2024-07-30T19:21:50.288973", "image_code": "float circle( in vec2 uv, in float size, in vec2 position)\n{\n    return step(distance(uv, position), size);\n}\nvec3 circles3( in vec2 uv )\n{\n    vec3 intensity = vec3(0.0);\n    float size = 0.1;\n    \n    intensity.xy += vec2(circle(uv, size, vec2(0.2, 0.3)));\n    intensity.xz += vec2(circle(uv, size, vec2(0.8, 0.3)));\n    intensity.zy += vec2(circle(uv, size, vec2(0.5, 0.3)));\n\n    intensity.yz += vec2(circle(uv, size, vec2(0.2, 0.7)));\n    intensity.yx += vec2(circle(uv, size, vec2(0.8, 0.7)));\n    intensity.zx += vec2(circle(uv, size, vec2(0.5, 0.8)));\n    \n    return min(vec3(1.0), intensity);\n}\nvec3 colorize( in vec3 gridColor, in vec3 otherColor )\n{\n    gridColor *= 1.0 - step(vec3(0.2), otherColor);\n    if (gridColor.x == gridColor.y && gridColor.y == gridColor.z)\n    {\n        gridColor += 0.8;\n    }\n    return gridColor;\n}\nfloat raster( in float x, in float height, in float size )\n{\n    return step(fract(x / height), size);\n}\nvec3 raster( in vec3 x, in vec3 height, in vec3 size )\n{\n    return vec3(\n        raster(x.x, height.x, size.x),\n        raster(x.y, height.y, size.y),\n        raster(x.z, height.z, size.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 markSize = vec2(0.2, 0.04);\n    vec2 markSpeed = vec2(0.5, 0.0);\n    vec2 markPos = (0.5 * (1.0-markSize)) + (0.5 * (0.8-markSize)) * sin(iTime * markSpeed);\n    markPos.y -= 0.2;\n    vec2 mark = step(markPos, uv) * step(uv, markPos + markSize);\n\n\n    float gridHeight = 0.04;\n    vec3 grid = raster(\n        vec3(uv.y, uv.y + gridHeight/3., uv.y + gridHeight * 2.0/3.),\n        vec3(gridHeight),\n        vec3(1.0/3.0)\n        );\n\n\n    vec3 col = colorize( grid, circles3(uv));\n    float markIntensity = mark.x * mark.y;\n    col = col * (1.0-markIntensity) + markIntensity * 0.8;\n\n\n    col = min (vec3(1.0), col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2XWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 60, 60, 109], [110, 110, 139, 139, 604], [605, 605, 661, 661, 841], [842, 842, 902, 902, 946], [947, 947, 1003, 1003, 1140], [1142, 1142, 1199, 1249, 1970]]}
{"id": "NdjXWh", "name": "Two Layers Reaction-Diffusion", "author": "clepirelli", "description": "Made for the willstall challenge - 1 shader a week keeps the depression meek\n\nTwo layers of reaction-diffusion which change each-other's parameters \nPress space to reset the sim \nPressing shift changes switches between the two layers\n", "tags": ["mouse", "diffusion", "reaction"], "likes": 5, "viewed": 442, "published": 3, "date": "1620139820", "time_retrieved": "2024-07-30T19:21:51.088834", "image_code": "vec2 getBufferOutput(vec2 uv)\n{\n    if(mergeOutputs)\n    {\n        vec2 outputs = mix(texture(iChannel0, uv).xy, texture(iChannel1, uv).xy, .5);\n        return outputs/maxAmount;\n    } else \n    {\n        if(keyToggled(iChannel2, SHIFT_KEY))\n        {\n            return texture(iChannel0, uv).xy/maxAmount;\n        } else \n        {\n            return texture(iChannel1, uv).xy/maxAmount;\n        }\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 bufferOutput = getBufferOutput(uv);\n    \n    if(usingPalette)\n    {\n        bool shiftPressed = keyToggled(iChannel2, SHIFT_KEY);\n        fragColor = vec4(pal(bufferOutput.x, palettes[shiftPressed ? 1 : 0]) , 1.0);\n    } else \n    {\n        fragColor = vec4(bufferOutput.xxx,1.0);\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int bufferCount = 2;\n\n//---- reaction-diffusion constants\nconst float firstDiffusionRate[bufferCount] = float[bufferCount]( 1.0, .8);\nconst float growthRate[bufferCount] = float[bufferCount](.03, .025);\nconst float growthVariation[bufferCount] = float[bufferCount](.018, .010);\n\nconst float secondDiffusionRate[bufferCount] = float[bufferCount](.4, .4);\nconst float deathRate[bufferCount] = float[bufferCount](.057, .057);\nconst float deathVariation[bufferCount] = float[bufferCount](.001, .003);\n\nconst float startRadius[bufferCount] = float[bufferCount](.05, .05);\n\nconst float maxAmount = 1.0;\nconst float speed = 100.0;\n\nconst bool useMouse = false;\nconst float mouseRadius = .1;\n\nconst bool mergeOutputs = false;\n\n//---- aesthetic constants\nconst bool usingPalette = true; //true: v gets converted to palette\n\nstruct Palette \n{\n    vec3 a, b, c, d;\n};\n\nconst Palette palettes[bufferCount] = Palette[bufferCount](\n    Palette(\n        vec3(0.5,0.5,0.5),\n        vec3(0.5,0.5,0.5),\n        vec3(1.0,1.0,0.5),\n        vec3(0.8,0.90,0.30)),\n    Palette(\n        vec3(0.5,0.5,0.5),\n        vec3(0.5,0.5,0.7),\n        vec3(1.0,1.0,1.0),\n        vec3(0.05,0.10,0.1))\n);\n\n//from iq: https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, Palette p )\n{\n    return p.a + p.b*cos( 6.28318*(p.c*t+p.d) );\n}\n\n//---- kernel stuff\nconst float laplacianKernel[9] = float[9](\n    .05, .2, .05, \n    .2, -1., .2, \n    .05, .2, .05);\n    \nvec2 _applyKernel(vec2 uv, vec2 resolution, sampler2D image, float kernel[9])\n{\n    vec2 pixelSize = 1./resolution.xy;\n    vec2 afterKernel = vec2(.0);\n    for(int i = 0; i < 3; i++)\n    for(int j = 0; j < 3; j++)\n    {\n        vec2 sampleUV = uv + vec2(float(i-1), float(j-1)) * pixelSize;\n        afterKernel += texture(image, sampleUV).xy * kernel[j*3+i];\n    }\n    \n    return afterKernel;\n}\n#define applyKernel(uv, image, kernel) _applyKernel(uv, iResolution.xy, image, kernel)\n\n//---- boilerplate\n\n#define keyPressed(sampler, ascii) (texelFetch(sampler,ivec2(ascii, 0), 0).x > 0.0)\n#define keyToggled(sampler, ascii)  ( texelFetch(sampler,ivec2(ascii,2),0).x > 0.)\nconst int SPACE_KEY = 32;\nconst int SHIFT_KEY = 16;\n\n//---- reaction-diffusion macro\n\n#define REACTION_DIFFUSION(number) \\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \\\n{\\\n    vec2 bufferUV = fragCoord.xy/iResolution.xy; \\\n    float aspectRatio = iResolution.x/iResolution.y;\\\n    \\\n    vec2 aspectCorrectedUV = bufferUV;\\\n    aspectCorrectedUV.x *= aspectRatio;\\\n    \\\n    if(iFrame < 3 || keyPressed(iChannel1, SPACE_KEY))\\\n    {\\\n        fragColor = vec4(1.0, distance(aspectCorrectedUV, vec2(.5*aspectRatio,.5)) < startRadius[number], .0, 1.0);\\\n        return;\\\n    }\\\n    \\\n    if(useMouse)\\\n    {\\\n        vec2 mouse = iMouse.xy/iResolution.xy;\\\n        mouse.x *= aspectRatio;\\\n        \\\n        if((distance(mouse, aspectCorrectedUV) < mouseRadius) && sign(iMouse.z) > .0)\\\n        {\\\n            fragColor = vec4(1.0, 1.0, .0, 1.0);\\\n            return;\\\n        }\\\n    }\\\n    \\\n    vec2 lastFrame = clamp(texture(iChannel0, bufferUV).xy, .0, maxAmount);\\\n    \\\n    const vec2 diffusionRates = vec2(firstDiffusionRate[number], secondDiffusionRate[number]);\\\n    vec2 diffusion = applyKernel(bufferUV, iChannel0, laplacianKernel) * diffusionRates;\\\n    \\\n    vec2 otherBufferValues = clamp(texture(iChannel2, bufferUV).xy, .0, maxAmount);\\\n    float currentGrowthRate = mix(growthRate[number]-growthVariation[number], growthRate[number]+growthVariation[number], otherBufferValues.x);\\\n    float currentDeathRate = mix(deathRate[number]-deathVariation[number], deathRate[number]+deathVariation[number], otherBufferValues.y);\\\n    \\\n    float reactionAmount = lastFrame.x * lastFrame.y * lastFrame.y;\\\n    vec2 change = diffusion + vec2(\\\n        -reactionAmount + currentGrowthRate * (maxAmount - lastFrame.x),\\\n        reactionAmount - (currentGrowthRate + currentDeathRate) * lastFrame.y\\\n    );\\\n    \\\n    fragColor = clamp(vec4(lastFrame+change*iTimeDelta*speed, 1.0, 1.0), .0, maxAmount);\\\n}\n\n\n\n", "buffer_a_code": "REACTION_DIFFUSION(0)", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "REACTION_DIFFUSION(1)", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 407], [410, 410, 465, 465, 803]]}
{"id": "fsSXz1", "name": "Joran's Maze", "author": "j0ran", "description": "Maze", "tags": ["maze"], "likes": 6, "viewed": 220, "published": 3, "date": "1620122384", "time_retrieved": "2024-07-30T19:21:51.950531", "image_code": "float hash21(vec2 v) \n{\n    return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nmat2 Rot(float a)\n{\n    return mat2(sin(a), cos(a), -sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;  \n    uv = uv * Rot(radians(-45.0));\n    \n    uv *= (sin(iTime*1.0) + 1.0) * 20. + 5.;\n    uv.x += iTime * 7.;\n\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n                \n    float d = 0.;\n    float dir = hash21(id) < 0.5 ? -1. : 1.;\n\n    d += smoothstep(0.25, 0.15, abs(gv.x  + gv.y * dir));\n    \n    vec3 col = vec3(d);    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSXz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 95], [97, 97, 116, 116, 168], [170, 170, 227, 227, 665]]}
{"id": "sdSXDh", "name": "Simple 2D Metaballs - laggermc", "author": "laggermc", "description": "2D rendering of simple metaballs  - click to move ball", "tags": ["isosurface"], "likes": 2, "viewed": 255, "published": 3, "date": "1620106906", "time_retrieved": "2024-07-30T19:21:52.760365", "image_code": "#define SPHERE_COUNT 3\nvec3 spheres[SPHERE_COUNT];\n\nfloat f(vec2 p) {\n\n    float sum = 0.0;\n    for (int i = 0; i < SPHERE_COUNT; i++) {\n        sum += spheres[i].z * spheres[i].z / (pow(p.x - spheres[i].x, 2.0) + pow(p.y - spheres[i].y, 2.0));\n    }\n\n    return sum;\n}\n\nvoid update_spheres(void) {\n    spheres[0].xy = (iMouse.xy / iResolution.xy * 20.0) - 10.0;\n    //spheres[1].xy +=  vec2(2.0 * cos(iTime), 10.0 * sin(iTime));\n    //spheres[2].xy += vec2(6.0 * sin(iTime), 2.5 * cos(iTime));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get coords between -10.0 and 10.0\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.xy; // Normalized coordinates\n    float scale = 20.0;\n    uv *= scale;\n    uv -= scale / 2.0;\n    uv.y *= 1.0 / aspect_ratio;\n\n    // Define spheres\n    vec3 s1 = vec3(0.0, 0.0, 1.0);\n    vec3 s2 = vec3(0.0, 0.0, 1.5);\n    vec3 s3 = vec3(-6.0, -3.0, 2.0);\n\n    spheres[0] = s1;\n    spheres[1] = s2;\n    spheres[2] = s3;\n\n    update_spheres(); // Update sphere positions\n    vec3 col = vec3(step(1.0, f(uv))); // Pixel is in sphere if f(uv) > 1.0\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSXDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 69, 69, 269], [271, 271, 298, 298, 496], [498, 498, 555, 596, 1217]]}
{"id": "ssSXWh", "name": "Trilinear Isosurface Refactored", "author": "oneshade", "description": "A retake on the intersection with a trilinear isosurface. Much simpler and neater, there is even some symmetry.", "tags": ["3d", "raytracing", "ray", "raycasting", "intersection", "isosurface", "trilinear", "refactored"], "likes": 7, "viewed": 174, "published": 3, "date": "1620100728", "time_retrieved": "2024-07-30T19:21:53.572195", "image_code": "vec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float aa = a * a, bb = b * b;\n\n    float denom = 3.0 * aa;\n    float inflect = b / (3.0 * a);\n\n    float p = c / a - bb / denom;\n    float q = bb * b / (13.5 * aa * a) - b * c / denom + d / a;\n    float ppp = p * p * p, qq = q * q;\n\n    float p2 = abs(p);\n    float v1 = 1.5 / p * q;\n\n    vec4 roots = vec4(0.0, 0.0, 0.0, 1.0);\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (p < 0.0) roots[0] = sign(q) * cosh(acosh(v2 * -sign(q)) / 3.0);\n        else roots[0] = sinh(asinh(v2) / 3.0);\n        roots[0] = -2.0 * sqrt(p2 / 3.0) * roots[0] - inflect;\n    }\n\n    else {\n        float ac = acos(v1 * sqrt(-3.0 / p)) / 3.0; // 0π/3,       2π/3,               4π/3\n        roots = vec4(2.0 * sqrt(-p / 3.0) * cos(vec3(ac, ac - 2.09439510239, ac - 4.18879020479)) - inflect, 3.0);\n    }\n\n    return roots;\n}\n\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots.x = 1.0 / roots.x;\n    if (roots.w > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\n// Intersection\nvec4 iTrilinearIsoSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    vec4 ka = vec4(-a + b + c - d + e - f - g + h, a - b - c + d, a - b - e + f, a - c - e + g);\n    vec3 kb = vec3(b, c, e) - a;\n\n    vec3 oo = ro.xxy * ro.yzz;\n    vec3 dd = rd.xxy * rd.yzz;\n\n    float t3 = ka.x * rd.x * rd.y * rd.z;\n    float t2 = dot(ro.zyx, dd) * ka.x + dot(ka.yzw, dd);\n    float t1 = dot(ka, vec4(dot(oo, rd.zyx), dot(ro.xy, rd.yx), dot(ro.xz, rd.zx), dot(ro.yz, rd.zy))) + dot(kb, rd);\n    float t0 = ka.x * ro.x * ro.y * ro.z + dot(ka.yzw, oo) + dot(kb, ro) + a;\n\n    return solveCubic2(t3, t2, t1, t0);\n}\n\n// Normal\nvec3 nTrilinearIsoSurf(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    vec4 k = vec4(-a + b + c - d + e - f - g + h, a - b - c + d, a - b - e + f, a - c - e + g);\n    return normalize(k.x * p.yxx * p.zzy + k.yyz * p.yxx + k.zww * p.zzy + vec3(b, c, e) - a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 7.0);//1.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    float a = sin(time * 0.5) * 2.0;\n    float b = -cos(time);\n    float c = cos(time * 1.25);\n    float d = sin(time * 2.0) * 0.5;\n    float e = cos(time * 0.5) * 1.5;\n    float f = -sin(time * 1.5) * 0.25;\n    float g = sin(time);\n    float h = cos(time) * 0.75;\n\n    // Render\n    vec4 hit = iTrilinearIsoSurf(ro + 0.5, rd, a, b, c, d, e, f, g, h);\n\n    vec3 hitPos;\n    float t = -1.0;\n    for (int n=0; n < int(hit.w); n++) {\n        vec3 posCandid = ro + rd * hit[n];\n        float tCandid = hit[n];\n        if (tCandid > 0.0 && (t < 0.0 ? true : tCandid < t) && all(lessThan(abs(posCandid), vec3(2.0)))) {\n            hitPos = posCandid;\n            t = tCandid;\n        }\n    }\n\n    if (t > 0.0) {\n        vec3 hitPos = ro + rd * t;\n        vec3 n = nTrilinearIsoSurf(hitPos + 0.5, a, b, c, d, e, f, g, h);\n        float diff = abs(dot(n, -rd));\n        float checkers = mod(dot(floor(hitPos), vec3(1.0)), 2.0);\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25);\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSXWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 65, 65, 918], [920, 920, 986, 986, 1126], [1128, 1144, 1288, 1288, 1820], [1822, 1832, 1963, 1963, 2156], [2158, 2158, 2213, 2213, 3971]]}
{"id": "WtyBRw", "name": "Circuit board fractal 10", "author": "jarble", "description": "I found a fractal pattern that looks like a circuit board.", "tags": ["fractal", "circuit"], "likes": 7, "viewed": 315, "published": 3, "date": "1620093173", "time_retrieved": "2024-07-30T19:21:54.527640", "image_code": "//vec3 c1 = vec3(7.0,5.0,1.4); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.0,9.0,1.4);\nvec3 c1 = vec3(2.0,2.5,1.4); //looks like a maze\n//vec3 c1 = vec3(1.7,1.9,1.3);\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.0;\n    float offset = .16;\n    float scale2 = 1.05;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<6;i++)\n        {\n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            uv = triangle_wave(uv+col.xy,scale);\n            //uv.y *= -1.0;\n            scale /= scale2+col.x;\n            offset /= scale2;\n            uv.y /= -1.0;\n            //uv = uv.yx;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtyBRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 233, 233, 278], [280, 280, 337, 337, 1018]]}
{"id": "NsSSD1", "name": "Tanglecube Ray Intersection II", "author": "oneshade", "description": "Simplifying/compacting my tanglecube intersector. Now only a single root is evaluated and inside/outside cases seem to work. Btw, I've noticed the constant coefficient always turns out to be the implicit equation applied to the ray origin...", "tags": ["intersection", "wip", "simplified", "tanglecube"], "likes": 3, "viewed": 162, "published": 3, "date": "1620084486", "time_retrieved": "2024-07-30T19:21:55.503032", "image_code": "// Intersection\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\nfloat iTangleCube(in vec3 ro, in vec3 rd, in float size, in float iso) {\n    ro /= size, rd /= size;\n    vec3 oo = ro * ro, od = ro * rd, dd = rd * rd;\n\n    float a =       dot(dd, dd);\n    float b = 4.0 * dot(od, dd);\n    float c = 6.0 * dot(oo, dd) - 1.25 * dot(rd, rd);\n    float d = 4.0 * dot(oo, od) - 2.50 * dot(ro, rd);\n    float e =       dot(oo, oo) - 1.25 * dot(ro, ro) + 0.6875 - 0.0625 * iso;\n\n    vec4 roots;\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = c - 0.375 * bb;\n    float q = d - 0.5 * b * c + 0.125 * bb * b;\n    float r = e - 0.25 * b * d + 0.0625 * bb * c - 0.01171875 * bb * bb;\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of λ^3 + ra * λ^2 + rb * λ + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    if (lambda < 0.0) return -1.0;\n    float sqrtLambda = sqrt(lambda);\n\n    float pLambda = 2.0 * (p + lambda), qLambda = 2.0 * q / sqrtLambda;\n\n    float bar = lambda - pLambda + qLambda;\n    if (bar > 0.0) return -(sqrtLambda + sign(e) * sqrt(bar)) * 0.5 - 0.25 * b;\n\n    float foo = lambda - pLambda - qLambda;\n    if (foo > 0.0) return +(sqrtLambda - sign(e) * sqrt(foo)) * 0.5 - 0.25 * b;\n}\n\n// Normal\nvec3 nTangleCube(in vec3 p, in float size, in float iso) {\n    p /= size;\n    return normalize(1.6 * p * p * p - p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);//1.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    float size = 1.25 + 0.25 * cos(iTime);\n    float iso = sin(iTime) * 5.0;\n\n    // Render\n    float t = iTangleCube(ro, rd, size, iso);\n    if (t > 0.0) {\n        vec3 hitPos = ro + rd * t;\n        vec3 n = nTangleCube(hitPos, size, iso);\n        float diff = abs(dot(n, -rd));\n        float checkers = mod(dot(floor(hitPos / size * 3.0), vec3(1.0)), 2.0);\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25);\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSSD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 16, 40, 40, 83], [84, 84, 156, 156, 2644], [2646, 2656, 2714, 2714, 2774], [2776, 2776, 2831, 2831, 4028]]}
{"id": "3lyBWz", "name": "Circuit board fractal 11", "author": "jarble", "description": "I found a fractal pattern that looks like a circuit board.", "tags": ["fractal", "circuit"], "likes": 10, "viewed": 326, "published": 3, "date": "1620080577", "time_retrieved": "2024-07-30T19:21:56.483411", "image_code": "//vec3 c1 = vec3(7.0,5.0,1.4); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.0,9.0,1.4);\nvec3 c1 = vec3(2.0,2.5,1.4); //looks like a maze\n//vec3 c1 = vec3(1.7,1.9,1.4);\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.0;\n    float offset = .16;\n    float scale2 = 1.05;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<9;i++)\n        {\n          \n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            uv = triangle_wave(uv+col.xy,scale);\n            //if(uv.y<uv.x) uv=uv.yx/2.;\n\n            scale /= scale2+col.x;\n            offset *= scale2;\n            uv.y /= -1.0;\n            //uv = uv.yx;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 233, 233, 278], [280, 280, 337, 337, 1043]]}
{"id": "NsSSDh", "name": "Temporal low pass filter", "author": "kaihagseth", "description": "Just a simple implementatiopn of a temporal low pass filter. \nInspired by javidx9s video on youtube!\n https://www.youtube.com/watch?v=mRM5Js3VLCk", "tags": ["imageprocessing"], "likes": 1, "viewed": 557, "published": 3, "date": "1620073661", "time_retrieved": "2024-07-30T19:21:57.355080", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float nSin(float x)\n{\n return .5 + (sin(x)*.5);\n}\n\nvec4 RC()\n{\n    return .1 *  vec4(nSin(iTime), nSin(2.*iTime), nSin(3.*iTime), 1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bufferVal = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 cam = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec4 diff = (cam - bufferVal) * RC();\n    fragColor = bufferVal + diff;\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = ( fragCoord * iChannelResolution[0].xy) / iResolution.xy;\n    fragColor = texelFetch(iChannel0, ivec2(st), 0);\n}", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSSDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 119]]}
{"id": "7d2SDR", "name": "Lunar Arcans", "author": "jhabaa", "description": "Nice illusion", "tags": ["lunar"], "likes": 2, "viewed": 254, "published": 3, "date": "1620071901", "time_retrieved": "2024-07-30T19:21:58.337454", "image_code": "/*\n    ///Voici les arcanes lunaires inspirées du manga Naruto\n    \n    Le code est basé sur celui de  FabriceNeyret2-- shortest rotation dot (91 chars) -- \n    pour les effets lumineux et rotationnel des élements. \n    \n    La sphère centrale qui représente la lune est la même utilisée par Deefunct --Light circles--\n    \n    Le disque central rouge est acquis grace au code disponible en cours\n    \n    les effets de lumières, couleurs, et animations resultent d'une modification des codes acquis.\n    \n*/\n\n\n//Fonction de création d'un disque. Prise en cours\nvec4 disk(vec2 uv, vec2 center, float radius, vec4 color) {\nfloat inDisk = step(length(center - uv), radius);\nif (inDisk==0.0) return vec4(0.0, 0.0, 0.0, 1.0);\nelse return vec4(inDisk, inDisk, inDisk, 1.0)*color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //disque central rouge\n    vec2 xy = fragCoord.xy;\n    xy = iResolution.xy;\n    vec2 center = iResolution.xy * 0.5;\n    float radius = 0.12 * iResolution.y;\n    vec4 layer3 = disk(fragCoord.xy, center, radius, vec4(1.0, 0.0, 0.0, 1.0));\n    layer3 -= 0.1 / length( (fragCoord+fragCoord-xy)/xy.y*2.0 + tan( iTime  + vec2(33,0) )  ) ; //ajout d'un halo noir tangent à la lune\n    \n    //cercle luminlumineux blanc lunaire\n    vec2 uv1 = 7.2*(2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 light_color1 = vec3(1.0,1.0,1.0);\n    float light1 = 2.0 / distance(normalize(uv1), uv1);\n    vec4 layer2 = vec4(light1*light_color1,1.0) + layer3;\n    layer2 += .1 / length( (fragCoord+fragCoord-xy)/xy.y*1.8 + sin( iTime  + vec2(33,0) )  ) ;\n\n   // cercle central\n\tvec2 uv = 1.8*(2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 light_color = vec3(0.9, 0.1, 0.1);\n\tvec2 offset = vec2(tan(iTime),sin(iTime));;\n\tfloat light = 0.1 / distance(normalize(uv), uv); // Point de chute du ryon à la surface de la lune\n    float light2 = 0.5 / distance(normalize(uv), uv); // satellite\n    float light3 = 0.3 / distance(normalize(uv), uv*2.5); // rayon envoyé par le satellite\n    if(length(uv) > 1.0  ){\n\t\tlight *= 0.7 /  length( (fragCoord+fragCoord-xy)/xy.y + sin( iTime  + vec2(33,0) ) + light2 * light3);\n\n\t}\n    vec4 layer1 = vec4(light*light_color,0.0);\n\tfragColor = mix(layer1,mix(layer2,layer3,0.5),0.5); // affichage de tous les calques\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2SDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[519, 571, 630, 630, 785], [788, 788, 845, 872, 2303]]}
{"id": "7sBSWR", "name": "MandelBrot Set Pan and Zoom", "author": "Hitthesurf", "description": "It is the MandelBrot Set. It also has pan and zoom. It stores the data for the pan and zoom in Buffer A.\nZoom in press W\nZoom out press S\nThe pan and zoom code could be better, but this was a proof of concept.", "tags": ["mouse", "math", "interactive", "zoom", "keyboard", "pan"], "likes": 0, "viewed": 331, "published": 3, "date": "1620059341", "time_retrieved": "2024-07-30T19:21:59.278936", "image_code": "vec2 cmpxcjg(in vec2 c) {\n\treturn vec2(c.x, -c.y);\n}\n\nvec2 cmpxmul(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nfloat cmpxmodsquared(in vec2 a)\n{\n    return (a.x*a.x+a.y*a.y);\n}\n\nbool isMandelBrot(in vec2 cnum)\n{\n    vec2 currentnum = cnum;\n    float comparnum = cmpxmodsquared(cnum)*1000.0;\n    for(int i = 0; i <= 50; i++)\n    {\n        currentnum = cmpxmul(currentnum,currentnum)+cnum;\n        if (cmpxmodsquared(currentnum)>=comparnum)\n        {\n        //Diverges\n            return false;\n        }\n    }\n    return true;\n}\n\nfloat MandelBrotNum(in vec2 cnum)\n{\n    //0,0 for diverges, other number convergers to that number\n    vec2 currentnum = cnum;\n    float comparnum = cmpxmodsquared(cnum)*1000.0;\n    for(int i = 0; i <= 50; i++)\n    {\n        currentnum = cmpxmul(currentnum,currentnum)+cnum;\n        if (cmpxmodsquared(currentnum)>=comparnum)\n        {\n        //Diverges\n            return 0.0;\n        }\n    }\n    return cmpxmodsquared(currentnum);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    /*float pan_x = (iMouse.x - iMouse.z);\n    float pan_y = (iMouse.y - iMouse.w) - iResolution.y;\n    \n    if (iMouse.z < 0.0)\n    {\n        pan_x = 0.0;\n        pan_y = 0.0;\n    }*/\n    \n    vec4 pan_vals = textureLod(iChannel0, vec2(0.0,0.0),0.0);\n    float Zoom = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy, 0.0).x;\n    //Why do i have to add 0.5?\n    \n    float pan_x = pan_vals.x;\n    float pan_y = pan_vals.y;\n    \n    float ylow = -1.0*Zoom; //Could be stored in vec4\n    float yhigh = 1.0*Zoom;\n    float xleft = -1.0*Zoom;\n    float xright = 1.0*Zoom;\n    \n    float R_x = (fragCoord.x-pan_x*pow(Zoom,-1.0))/iResolution.x;\n    float R_y = (fragCoord.y-pan_y*pow(Zoom,-1.0))/iResolution.y;\n    \n    \n    vec2 cmplxnum = vec2(xleft+(xright-xleft)*R_x,ylow + (yhigh - ylow)*R_y);\n    \n    /*if (isMandelBrot(cmplxnum))\n    {\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0,1.0,0.0,1.0);\n    }*/\n    \n    float MandelBrotVal = MandelBrotNum(cmplxnum);\n    if (MandelBrotVal == 0.0)\n    {\n        fragColor = vec4(0.0,1.0,0.0,1.0);\n    }\n    else\n    {\n        fragColor = vec4(MandelBrotVal/0.5,0.0,0.0,1.0);\n    }\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Keyboard Code to make it work\n// keys are javascript keycode\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\n\n\n//Storage Code For Pan and Zoom\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    //Only run once each frame\n    \n        if (ivec2(fragCoord.xy) == ivec2(0,0) )\n        {\n            //Mouse Pan Stored In Here\n        \n        \n            vec4 prev_info = textureLod(iChannel0, vec2(0.0,0.0),0.0);\n            float Zoom = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy,0.0).x;\n            float prev_pan_x = prev_info.x;\n            float prev_pan_y = prev_info.y;\n            \n            float legacy_pan_x = prev_info.z;\n            float legacy_pan_y = prev_info.w;\n            \n            float pan_x = (iMouse.x - abs(iMouse.z))*Zoom + legacy_pan_x;\n            float pan_y = (iMouse.y - abs(iMouse.w))*Zoom + legacy_pan_y;\n    \n            if (iMouse.z < 0.0)\n            {\n                //Mouse has been lifted up\n                legacy_pan_x = prev_pan_x;\n                legacy_pan_y = prev_pan_y;\n                pan_x = legacy_pan_x;\n                pan_y = legacy_pan_y;\n\n            }\n\n            \n            \n            \n            \n            fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n    \n        \n        }\n        \n    //Zoom settings\n    if (ivec2(fragCoord.xy) == ivec2(10,10) )\n    {\n    \n        float x = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy,0.0).y;\n        //Number of times zoom in - zoom out has happend\n        \n        x += ReadKey(Key_W)-ReadKey(Key_S);\n        \n        float Zoom = pow(2.71, -x*0.05); //Times all limits by this value\n        \n        //Save Zoom data to bufferA pixel (10,10)\n        fragColor = vec4(Zoom, x,0.0,0.0);\n    }\n    \n    \n}\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBSWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 52], [54, 54, 90, 90, 152], [154, 154, 187, 187, 219], [221, 221, 254, 254, 571], [573, 573, 608, 671, 1008], [1011, 1011, 1068, 1254, 2253]]}
{"id": "NsjXDz", "name": "Laser scattering", "author": "michael0884", "description": "Rasterizing light rays that are traced forward. Use 8x paint calls at minimum", "tags": ["raster"], "likes": 26, "viewed": 1436, "published": 3, "date": "1620055491", "time_retrieved": "2024-07-30T19:22:00.558516", "image_code": "//SHOW\n\nbool isKeyToggled(int KEY)\n{\n\treturn texelFetch( iChannel1, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    if(isKeyToggled(KEY_SPACE))\n    {\n        vec4 col = texelFetch(iChannel0, ivec2(p), 0);\n        float k = float(pixelID(col.xy))/pixelnum;\n        \n        c = vec4(k);\n    }\n    else\n    {\n       \n            vec4 col = texelFetch(iChannel2, ivec2(p), 0);\n            float exposure = 1. - (iMouse.x/R.x);\n            c = tanh(col/col.w);\n        \n    }\n   \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define TWO_PI 6.28318530718\n#define ANG 0.01\n\n//#define REAL_TIME\n\n#ifdef REAL_TIME\n    #define IFRAME 0\n    #define SPEED 0.1\n#else\n    #define IFRAME iFrame\n    #define SPEED 0.0\n    #define ACCUMULATION\n#endif\n\n\n#define FOV 1.0\nvec2 R;\nint sort_iters;\nfloat pixelnum;\n\nbool onScreen(vec3 p)\n{\n    return all(greaterThan(p.xy, vec2(0))) && all(greaterThan(R,p.xy)) && p.z > 0.0;\n}\n\nint pixelID(vec2 pix)\n{\n    return int(pix.x) + int(pix.y)*int(R.x);\n}\n\nivec2 pixel(int pid)\n{\n    return ivec2(pid%int(R.x), pid/int(R.x));\n}\n\n//thanks rory618 (https://www.shadertoy.com/view/WssfDn) for this incredible magic function\nint getPartner(int x, int s){\n    float j = floor(sqrt(float(2*s)+1.25)-0.5);\t\t//Major stage\n    float n = floor(float(s) - 0.5*(j*j+j) + 0.5);\t//Minor stage\n    float b = floor(exp2(j-n+1.)+0.5);\t\t\t\t//Block size\n    float bot = floor(float(x)/b)*b;\t\t\t\t//Bottom index in block \n    float top = bot + b - 1.;\t\t\t\t\t\t//Top index in block\n    if(n<0.5){\t\t\t\t\t\t\t\t\t\t//Swap with opposite index in block\n        return int(top - (float(x)-bot) + 0.5);\n    }else{\t\t\t\t\t\t\t\t\t\t\t//Swap with index a constant distance away in block\n        if(float(x)-bot < b/2.-0.5){\n            return int(float(x) + b/2. + 0.5);\n        }else{\n            return int(float(x) - b/2. + 0.5);\n        }\n    }\n}\n\n\n//internal RNG state \nuvec4 s0; \n\nvec2 pix;\n\nvoid initialize(inout vec2 p, int frame, vec3 res)\n{\n    p = floor(p);\n    pix = p;\n    \n    R = res.xy;\n    pixelnum = R.x*R.y;\n    float lg2 = ceil(log2(pixelnum));\n    sort_iters = 3*int(ceil(lg2*(lg2 + 1.0)/6.0) + 1.0);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec3 udir(vec2 rng)\n{\n    vec2 r = vec2(2.*PI*rng.x, acos(2.*rng.y-1.));\n    vec2 c = cos(r), s = sin(r);\n    return vec3(c.x*s.y, s.x*s.y, c.y);\n}\n\nvec2 cmul(vec2 x, vec2 y)\n{\n    return vec2(x.x*y.x - x.y*y.y, x.x*y.y + x.y*y.x);\n}\n\nvec2 disk()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nconst int max_iterations = 256;\nconst vec4 color_threshholds = vec4(255,130,80,255);\n\nvec4 buddhabrot(int iters)\n{\n    vec3 z = vec3(0.01);\n    vec3 c = (rand3() - 0.5)*1.5 + vec3(0.0, 0.0, 0.0);\n\n\n    int i = 0;\n   \tfor(; i<iters; i++ )\n    {\n        float r = length(z);\n        float b = 2.0*acos( z.y/r);\n        float a = 2.0*atan( z.x, z.z );\n        z = c + pow(r,2.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n\t\tif(length(z) > 4.0 )\n            break;\n    }\n    \n    if(i >= iters) return vec4(1e5);\n    \n    int maxj = int(rand()*1000.0)%i;\n    \n    z = vec3(0.01);\n    \n    for(int j = 0; j <= maxj; j++)\n    {\n        float r = length(z);\n        float b = 3.0*acos( z.y/r);\n        float a = 3.0*atan( z.x, z.z );\n        z = c + pow(r,3.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n    }\n    \n    return vec4(z, i);\n    \n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\nmat3 get_cam(vec2 ang)\n{\n    vec3 x_dir = vec3(cos(ang.x)*sin(ang.y), cos(ang.y), sin(ang.x)*sin(ang.y));\n    vec3 y_dir = normalize(cross(x_dir, vec3(0,1,0)));\n    vec3 z_dir = normalize(cross(y_dir, x_dir));\n    return mat3(-x_dir, y_dir, z_dir);\n}\n\n//project to clip space\nvec3 project(mat3 cam_mat, vec3 cam_pos, vec3 p)\n{\n    float td = distance(cam_pos, p);\n    float zd = dot(cam_mat[0],p - cam_pos);\n    vec3 dir = (p - cam_pos)/td;\n    vec3 screen = vec3(dot(cam_mat[0],dir),dot(cam_mat[1],dir),dot(cam_mat[2],dir));\n    return vec3(screen.yz*R.y/(FOV*screen.x) + 0.5*R.xy,zd);\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_BSPACE = 8;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n", "buffer_b_code": "//BITONIC SORT\n\n#define scatter 50.0\n#define extinct 0.\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdMandelbulb( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n\tfor( int i=0; i<3; i++ )\n    {\n        // trigonometric version (MUCH faster than polynomial)\n        \n        // dz = 8*z^7*dz\n\t\tdz = 8.0*pow(m,3.5)*dz + 1.0;\n      //dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n      \n        // z = z^8+z\n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25*log(m)*sqrt(m)/dz;\n}\n\nvec4 map(vec3 p)\n{\n    float sd = 1e10;\n    vec4 col = vec4(1.0);\n    sd = min(sdMandelbulb(p, col), sd);\n\n    return vec4(col.xyz, sd);\n}\n\nvec3 normal(vec3 p, float dx) {\n\tconst vec3 k = vec3(1,-1,0);\n\treturn normalize(k.xyy*map(p + k.xyy*dx).x +\n\t\t\t         k.yyx*map(p + k.yyx*dx).x +\n\t\t\t         k.yxy*map(p + k.yxy*dx).x +\n\t\t\t         k.xxx*map(p + k.xxx*dx).x);\n}\n\n#define rstep 0.03\n\n//trace up to a scattering threshold\nbool trace(inout vec3 ro, vec3 rd, float maxc, float wv, out vec4 ex)\n{\n    vec4 c = vec4(0.); //rgb extinction and w scattering\n    float td = 0.0 + rstep*rand();\n    for(int i = 0; i < 150; i++)\n    {\n        vec4 d = map(ro.xyz + rd*td); //distance\n        float dx = rstep; //ray step\n        \n        float rho = ((d.w < 0.0) ? scatter : 0.2)*(7./5. - wv/500.0 );\n       \n        vec4 dc = rho*vec4(extinct*d.xyz, 1.0);\n        if(c.w + dc.w*dx > maxc) \n        {\n            dx = (maxc - c.w)/dc.w;\n            td += dx; \n            c += dc*dx;\n            break;\n        }\n        c += dc*dx;\n        td += dx;\n        \n        if(td > 10.0) break;\n    }\n    ro += rd*td; \n    ex = exp(-c); //return extinction\n    return c.w >= maxc;\n}\n\nvoid getRay(out vec3 ro, out vec3 rd, out float wv, out vec3 I)\n{\n    float r = rand();\n    \n    //mat3 c = get_cam(vec2(iTime,PI*0.5));\n    if(r<0.3)  //lazer\n    {\n       ro = vec3(-0.3,1.5,0.3);\n       rd = vec3(0.,-1.,0.);\n    }\n    else \n    {\n       ro = vec3(1.5,1.25*disk());\n       rd = vec3(-1.,0.,0.);\n    }\n    \n    /*vec2 uv = (pix - R*0.5)/R;\n    \n    ro = vec3(1.5,2.*uv);\n    rd = vec3(-1.,0.,0.);*/\n    \n    //amount of light\n    I = vec3(12.);\n    //random wavelength\n    wv = 400. + 280.*rand();\n}\n\n//the opposite of path tracing, the actual way light is propagating\nvec4 forwardtrace(mat3 cam, vec3 campos)\n{\n   \n    vec3 rd,ro,I;\n    float wv;\n    //generate light rays at light sources\n    getRay(ro,rd,wv,I);\n    \n  \n    \n    int max_bounce = int(rand()*2.0)+1;\n   \n    for(int i = 0; i < max_bounce; i++)\n    {\n        vec4 ex;\n        float thresh = -log(rand());\n        bool hit = trace(ro, rd, thresh, wv, ex);\n        if(hit) \n        {\n            rd = udir(rand2());\n        }\n        else return vec4(100000);\n    }\n    \n    //project onto screen\n    vec3 clip = project(cam, campos, ro);\n    \n    //this will be omitted\n    clip.xy += nrand2(0.33,vec2(0.0));\n    \n    if(onScreen(clip))\n    {\n        vec4 ex;\n        trace(ro, normalize(campos - ro), 1e5, wv, ex);\n        I *= ex.w/clip.z; //brightness inversly proportional to camera distance\n    }\n    else\n    {\n        I *=0.0;\n    }\n    return vec4(clip.xy, min(length(I),10.0), wv);\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, IFRAME, iResolution);\n    \n    int sort_iter = 3*iFrame + 0;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters - 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n  \n    \n    if(sort_iter%sort_iters == 0) //intialize with some random points, in this case pseudo caustic\n    {\n        vec2 ang = vec2(TWO_PI, PI)*iMouse.xy/R + vec2(0.4);\n        mat3 cam = get_cam(ang);\n        \n        vec3 campos = -cam*vec3(3.3,0,0);\n    \n        vec4 bp = vec4(101);\n       \n        bp = forwardtrace(cam, campos);\n        \n       \n        bp.xy = clamp(bp.xy, vec2(0), R);\n        \n        \n        //bp.xy = clamp(toScreen(bp.xy), vec2(-1), R);\n        c = bp; \n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//BITONIC SORT\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    int sort_iter = 3*iFrame + 1;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters- 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//BITONIC SORT\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    int sort_iter = 3*iFrame + 2;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters- 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//BINARY SEARCH OF POINTS THAT FELL INTO THIS PIXEL\n\n\nint search(int id)\n{\n    ivec2 range = ivec2(0, pixelnum);\n    \n    for(int i = 0; i < 128; i++)\n    {\n        //check the middle of the range\n        int middle = (range.x + range.y)/2;\n        vec4 data = texelFetch(iChannel1, pixel(middle), 0);\n        //get point id\n        int pid = pixelID(data.xy);\n        \n        //if found then stop\n        if(pid == id) return middle;\n        \n        if(range.y - range.x < 2) break;\n        \n        if(pid > id) //if our id of interest is below the found id\n            range.y = middle; //then set the end of the range as middle\n        else //if our id we search is above\n            range.x = middle; //then set the beginning of the range as middle\n    }\n    \n    return -1; //nothing found;\n}\n\nconst vec3 C = vec3(0.027,0.169,0.949);\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    c = texelFetch(iChannel0, ivec2(p), 0);\n    \n    int sort_iter = 3*iFrame + 2;\n    \n    if((sort_iter+1)%sort_iters == 0) //if last sorting step\n    {\n        #ifdef ACCUMULATION\n        if(iMouse.z > 0.0)\n        #endif\n            c *= 0.3;\n        int pixid = pixelID(p);\n        int id = search(pixid);\n        \n        vec2 ang = vec2(TWO_PI, PI)*iMouse.xy/R + vec2(0.4);\n        mat3 cam = get_cam(ang);\n        \n        vec3 campos = -cam*vec3(1.0,0,0);\n        vec2 uv = (p - 0.5*R.xy)/R.y;\n        vec3 rd = normalize(cam*vec3(1, FOV*uv));\n        \n        vec3 col = vec3(0.0);\n        float mind = 1e5;\n        if(id >= 0) //found at least 1 point in this pixel\n        {\n           \n            \n            for(int j = 0; j < 1024; j++) //go left\n            {\n                int idx = id + j;\n                vec4 data = texelFetch(iChannel1, pixel(idx), 0);\n                int pid = pixelID(data.xy); //get point id\n                if(pid!=pixid) break; //not in this pixel anymore\n                col += data.z*spectral_zucconi(data.w);\n            }\n            for(int j = 0; j < 1024; j++) //go right\n            {\n                int idx = id - j - 1;\n                vec4 data = texelFetch(iChannel1, pixel(idx), 0);\n                int pid = pixelID(data.xy); //get point id\n                if(pid!=pixid) break; //not in this pixel anymore \n                col += data.z*spectral_zucconi(data.w);\n            }\n            c.xyz += col.xyz;\n        }\n        \n      \n       \n        c.w++;\n    }\n    \n    if(iFrame == 0) c = vec4(0);\n}", "buffer_d_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8, 8, 36, 36, 96], [98, 98, 139, 139, 545]]}
{"id": "7djSDR", "name": "very expensive smooth min/max", "author": "mds2", "description": "Trying out the very expensive, but very smooth, analogs to the classic blend functions", "tags": ["sdf", "testing", "experiment", "blend", "expensive"], "likes": 4, "viewed": 505, "published": 3, "date": "1620051679", "time_retrieved": "2024-07-30T19:22:01.336435", "image_code": "#define USE_SQUIRCLES_INSTEAD_OF_BOXES 0\n\n\nfloat wiggle = 0.0; // overwritten in main.  global variable\n\n\nfloat box_sdf(in vec2 pt) {\n  vec2 rel = abs(pt) - vec2(0.5);\n  float out_dist = length(max(rel, vec2(0.0)));\n  float in_dist = max(rel.x, rel.y);\n  return mix(in_dist, out_dist, step(-in_dist, out_dist));\n}\n\nfloat squircle_sdf(in vec2 pt) {\n  vec2 squares = pt * pt;\n  float l = sqrt(sqrt(dot(squares, squares)));\n  return l - 0.5;\n}\n\n/**\n * standard blend func, courtesy IQ\n */\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\nfloat sdf(in vec2 pt_in) {\n  vec2 pt = pt_in / 200.0;\n  vec2 vals;\n#if USE_SQUIRCLES_INSTEAD_OF_BOXES\n  vals = vec2(squircle_sdf(pt - vec2(0.2, 0.1)), \n              squircle_sdf(pt + vec2(0.75 + wiggle, 0.7))); \n#else\n  vals = vec2(box_sdf(pt - vec2(0.2, 0.1)), \n              box_sdf(pt + vec2(0.75 + wiggle, 0.7))); \n#endif\n\n  if (pt_in.x + 0.5 * iResolution.x > iMouse.x) {\n    return checked_smooth_min(vals.x, vals.y, 0.5);\n  }\n  return conventional_smin(vals.x, vals.y, 0.25);\n}\n\n/** first component is a repeating wave function of distance, for contour lines,\n  * second component determines whether we are inside or outside the shape\n  */\nvec2 contour(in vec2 pt) {\n  float val = sdf(pt);\n  return vec2(cos(20.0 * val) - 1.0, val);\n}\n\n/** first and third component are the gradient of the first component of \"contour\"\n  * second and fourth component are the gradient of the second component of \"countour\"\n  */\nvec4 contour_grad(in vec2 pt) {\n  vec2 f = contour(pt);\n  return 1000.0 * vec4(contour(pt + vec2(0.001, 0.0)) - f,\n                       contour(pt + vec2(0.0, 0.001)) - f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy - 0.5 * iResolution.xy;\n    \n    wiggle = 0.5 * sin(0.5 * iTime);\n    \n    // uv = 5.0 * uv;\n    \n    vec2 val = contour(uv);\n    vec4 grad = contour_grad(uv);\n    \n    val = 0.5 * val / vec2(length(grad.xz), length(grad.yw));\n    val = vec2(1.0) + max(vec2(-1.0), min(vec2(0.0), val));\n\n    // val.y = 1.0 - val.y;\n    \n    vec3 col = val.yxx;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 133, 133, 313], [315, 315, 347, 347, 440], [865, 865, 925, 925, 966], [1178, 1178, 1204, 1204, 1663], [1665, 1826, 1852, 1852, 1920], [1922, 2097, 2128, 2128, 2273], [2275, 2275, 2332, 2382, 2812]]}
{"id": "sdjSDR", "name": "FBM Waves", "author": "oneshade", "description": "I found this interesting variant of noise when I made my autodiff utilities.", "tags": ["noise", "waves", "fbm"], "likes": 7, "viewed": 145, "published": 3, "date": "1620051524", "time_retrieved": "2024-07-30T19:22:02.181177", "image_code": "#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nvec2 noise(in vec2 x) {\n    return fFract(367.436 * fCos(439.573 * x));\n}\n\nvec2 snoise(in vec2 x) {\n    return fMix(noise(fFloor(x)), noise(fCeil(x)), fSmoothstep(const2dual(0.0), const2dual(1.0), fFract(x)));\n}\n\nvec2 rollingNoise(in vec2 x, in float scale, in float roll, in int octaves) {\n    x /= scale;\n\n    vec2 value = const2dual(0.0);\n    float tscale = 0.0;\n    float nscale = 1.0;\n\n    for (int o=0; o < octaves; o++) {\n        value += snoise(x - const2dual(roll)) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        x *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n\n    // Draw the function\n    vec2 y = rollingNoise(var2dual(uv.x), 3.0, iTime, 10) * 3.0;\n    float d = abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y);\n\n    fragColor = vec4(smoothstep(unit, 0.0, d) + 0.25 * y.x);\n}", "image_inputs": [], "common_code": "vec2 const2dual(in float x) {\n    return vec2(x, 0.0);\n}\n\nvec2 var2dual(in float x) {\n    return vec2(x, 1.0);\n}\n\nvec2 fMul(in vec2 a, in vec2 b) {\n    return vec2(a.x * b.x, a.x * b.y + a.y * b.x);\n}\n\nvec2 fDiv(in vec2 a, in vec2 b) {\n    return vec2(a.x / b.x, (b.x * a.y - a.x * b.y) / (b.x * b.x));\n}\n\nvec2 fSquare(in vec2 z) {\n    return vec2(z.x * z.x, 2.0 * z.x * z.y);\n}\n\nvec2 fCos(in vec2 z) {\n    return vec2(cos(z.x), -sin(z.x) * z.y);\n}\n\nvec2 fMin(in vec2 a, in vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 fMax(in vec2 a, in vec2 b) {\n    return a.x > b.x ? a : b;\n}\n\nvec2 fFloor(in vec2 z) {\n    return vec2(floor(z.x), 0.0);\n}\n\nvec2 fCeil(in vec2 z) {\n    return vec2(ceil(z.x), 0.0);\n}\n\nvec2 fFract(in vec2 z) {\n     return vec2(fract(z.x), z.y);\n}\n\nvec2 fClamp(in vec2 z, in vec2 edge0, in vec2 edge1) {\n    return fMax(edge0, fMin(edge1, z));\n}\n\nvec2 fSmoothstep(in vec2 edge0, in vec2 edge1, in vec2 z) {\n    z = fClamp(fDiv(z - edge0, edge1 - edge0), vec2(0.0), vec2(1.0, 0.0));\n    vec2 sq = fSquare(z);\n    return 3.0 * sq - 2.0 * fMul(sq, z);\n}\n\nvec2 fMix(in vec2 a, in vec2 b, in vec2 t) {\n    return a + fMul(b - a, t);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 91, 91, 141], [143, 143, 167, 167, 279], [281, 281, 358, 358, 655], [657, 657, 712, 712, 1033]]}
{"id": "fsjSDz", "name": "Fork shutter Transition", "author": "turboplay", "description": "A shutter transition based on https://www.shadertoy.com/view/sd2Gz3", "tags": ["shutter"], "likes": 3, "viewed": 342, "published": 3, "date": "1620039541", "time_retrieved": "2024-07-30T19:22:03.023923", "image_code": "// 2D Random\n\n\nvec2 polarCoordinates(in vec2 st){\n    \n    const float pi = 3.1415926;\n    \n    vec2 sc = (st.xy - iResolution.xy / 2.0) / iResolution.y;\n    float phi = atan(sc.y, sc.x + 1e-6);\n    return vec2(fract(phi / (pi * 2.f)), length(sc));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 uvx = (fragCoord.xy/iResolution.xy);\n    vec2 coord = gl_FragCoord.xy;\n    const float pi = 3.1415926;\n    \n    vec4 c1 = texture(iChannel0,uvx);\n    vec4 c2 = texture(iChannel1,uvx);\n    \n    vec2 pc = polarCoordinates(coord);\n    float dis = 0.8f;\n    \n    pc.x = pc.x + dis*pc.y;\n    \n    float h_divnum = 12.0;\n    float dived = fract(pc.x * h_divnum);\n    float h = 0.5f;\n        vec4 c = vec4(0.0f,0.0f,0.0f,0.0f);\n    float ti = iTime + 8.;\n   \n    float value = sin(ti)*2.0;\n\n    float th = value - dived*h;\n\n\n\n    if(pc.y > th){\n        c = c2;\n    }else{\n        c = c1;\n    }\n\n    // Output to screen\n    fragColor = vec4(c.xyz,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjSDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[15, 15, 49, 49, 250], [253, 253, 310, 310, 968]]}
{"id": "fs2SWz", "name": "Pentile Matrix", "author": "milesWaugh", "description": "Click the right side of the screen to clear after one sample, click the left side to progressively refine.", "tags": ["screen", "matrix", "computer", "pentile"], "likes": 5, "viewed": 303, "published": 3, "date": "1620033575", "time_retrieved": "2024-07-30T19:22:04.021257", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb * 1.;\n\n    for(int i = -5; i < 5; i++) {\n        col += texture(iChannel0, uv - vec2(i, 0.) / iResolution.xy).rgb / 6.;\n        col += texture(iChannel0, uv - vec2(0., i) / iResolution.xy).rgb / 6.;\n    }\n\n    col /= col + 1.;\n    col.r = pow(col.r, 0.45);\n    col.g = pow(col.g, 0.45);\n    col.b = pow(col.b, 0.45);\n    col *= 1.2;\n    fragColor = vec4(col, 0.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Update: fixed DOF to sample uniformally\n//Update: gamma correction\n\nvec2 random(vec3 pos) {\n    return vec2(fract(sin(dot(pos, vec3(64.25375463, 23.27536534, 86.29678483))) * 59482.7542), fract(sin(dot(pos, vec3(46.28694826, 12.69483724, 75.34867263))) * 18694.3847));\n}\n\n#define sq2 sqrt(.5)\n#define sq3 sqrt(.75)\n#define pi 3.1415926535897932\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float frames = 10. * texture(iChannel0, vec2(1., 1.) / iResolution.xy).r;\n    \n    if(iMouse.x < iResolution.x / 2.) {\n        frames++;\n    } else {\n        frames = 0.;\n    }\n    \n    vec3 col;\n    vec2 of = fragCoord.xy - vec2(1., 1.);\n    if(dot(of, of) <= .5) {\n        col = vec3(frames / 10.);\n        fragColor = vec4(col, 1.0);\n    } else {\n        frames = round(frames);\n        vec2 uv = fragCoord / iResolution.xy;\n        uv = (fragCoord + random(vec3(uv.x, uv.y, iTime)) - iResolution.xy / 2.) / iResolution.xy;\n        vec3 inc = normalize(vec3(uv, 1.9));\n        inc = vec3(inc.x * .5 - inc.z * sq3, inc.y, inc.z * .5 + inc.x * sq3);\n        inc = vec3(inc.x, inc.y * sq2 - inc.z * sq2, inc.z * sq2 + inc.y * sq2);\n        vec3 p = vec3(inc.x, inc.y, inc.z) * (-1. / inc.y);\n        vec2 r = random(p);\n        r = vec2(cos(r.x * 2. * pi), sin(r.x * 2. * pi)) * sqrt(r.y); //DOF\n        vec3 p2 = p - vec3(-2., -1., 1.);\n        p += vec3(r.x, 0., r.y) * dot(p2, p2) / 7.;\n        p *= 3.;\n        \n        if(inc.y < 0.) {\n            int sel;\n            p -= floor(p);\n            sel = p.x < .5 ? p.z < .5 ? 2 : 1 : p.z < .5 ? 3 : 2;\n            sel *= (abs(p.x * 2. - floor(p.x * 2.) - 0.5) < .43) ? 1 : 0; //horizontal black spacer\n            sel *= (abs(p.z * 2. - floor(p.z * 2.) - 0.5) < .35) ? 1 : 0; //vertical black spacer\n            sel += (abs(p.z * 2. - floor(p.z * 2.) - 0.5) > .485) ? 4 : 0; //gray strip between vertical spacers\n            1 == sel ? col = vec3(1, 0, 0) : 2 == sel ? col = vec3(0, .5, 0) : 3 == sel ? col = vec3(0, 0, 1) : 4 == sel ? col = vec3(.1) : col = vec3(.002);\n            frames++;\n        } else {\n            col = vec3(.1);\n        }\n        \n        fragColor = (vec4(col, 1.0) + texture(iChannel0, fragCoord.xy / iResolution.xy) * frames) / (frames + 1.);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2SWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 508]]}
{"id": "fdjSDR", "name": "audio illus: missing fundamental", "author": "FabriceNeyret2", "description": "See sound tab: ( rise gain if necessary )\n4 seconds cycle:  pure 200Hz, pure 400Hz, harmonics from 200Hz, same without the fundamental 200Hz.\nThe tune of #4 timbre sounds like #1 note, not #2.\n[url]https://en.wikipedia.org/wiki/Missing_fundamental[/url]", "tags": ["audio", "illusion"], "likes": 5, "viewed": 380, "published": 3, "date": "1620025363", "time_retrieved": "2024-07-30T19:22:04.849044", "image_code": "// rise sound if necessary.\n// The interesting part is in the Sound tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// === icon message: \"sound in\". link: https://www.shadertoy.com/view/MtyXRW\n\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 O, in vec2 u ) {\n    if (iResolution.y<2000.) {float c=message((u/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){O=vec4(c);return;}}\n\n    \n    vec2 uv = u / iResolution.xy;\n\tO = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// rise sound gain if necessary.\n// NB: sound quality degenerate over time because of float precision of time. fix: https://www.shadertoy.com/view/4ltfRN\n// some explanations here: https://www.desmos.com/calculator/hdihomdojm\n\n#define hash(p)  fract(sin( (p) * 12.9898 ) * 43758.5453) // random\n\n\nvec2 mainSound( int it, float t )\n{\n    float v = 0., w, A=0., tau = 6.2831853, f, phi, \n          n = mod(floor(t),4.), i0, i1;\n    \n    if      (n==0.)  i0 = 1., i1 = 2.;                 // note 1 = f\n    else if (n==1.)  i0 = 2., i1 = 3.;                 // note 2 = 2f\n    else if (n==2.)  i0 = 1., i1 = 10.;                // harmonics from note 1\n    else             i0 = 2., i1 = 10.;                // just droping note 1: still same tune perceived.\n    \n    for (float i = i0; i < i1; i++ ) {\n        f = 200.;                                      // freq fi in Hz\n        phi = 0.;                                      // sync phases\n     // phi = tau*hash(i+.5);                          // random phases\n        w = 1./(i*i);                                  // weight for freq fi\n        v +=  cos( tau * f * i * t  + phi  ) *w;       // weighted wave\n        A += w;                                        // cumul weight for normalization\n    }\n     \n    return .5* vec2(  v / A );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[443, 443, 466, 513, 692], [694, 694, 735, 735, 926]]}
{"id": "fd2XWR", "name": "Autodiff Utilities", "author": "oneshade", "description": "Utilities for automatic differentiation. Demo shows how constant width graphs can be made using derivatives. Maybe I can differentiate my cubic solver now! Suggestions for other functions are welcome.", "tags": ["1d", "derivatives", "autodiff", "utilities"], "likes": 10, "viewed": 204, "published": 3, "date": "1620018806", "time_retrieved": "2024-07-30T19:22:05.767588", "image_code": "// Everything is done with vec2s\n// x component contains the output value\n// y component contains the derivative\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\n// Differentiating noise?!? :D\nvec2 noise(in vec2 x) {\n    return fFract(fMul(const2dual(367.436), fCos(fMul(const2dual(439.573), x))));\n}\n\nvec2 smoothNoise(in vec2 x) {\n    return fMix(noise(fFloor(x)), noise(fCeil(x)), fSmoothstep(const2dual(0.0), const2dual(1.0), fFract(x)));\n}\n\nvec2 rollingFbm(in vec2 x) {\n    vec2 value = const2dual(0.0);\n    float tscale = 0.0;\n    float nscale = 1.0;\n    for (int o=0; o < 10; o++) {\n        value = fAdd(value, smoothNoise(fSub(x, const2dual(iTime))) * nscale);\n        tscale += nscale;\n        nscale *= 0.5;\n        x *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvec2 f(in vec2 x) {\n    return fMix(fCos(x), rollingFbm(x), const2dual(0.5 + 0.5 * cos(iTime)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Draw the function\n    vec2 y = f(var2dual(uv.x));\n    draw(abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y), vec3(0.8, 0.0, 0.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "// Copy-paste this entire line to include in your shader\nvec2 const2dual(float x){return vec2(x,0);}vec2 var2dual(float x){return vec2(x,1);}vec2 fAdd(vec2 a,vec2 b){return a+b;}vec2 fSub(vec2 a,vec2 b){return a-b;}vec2 fMul(vec2 a,vec2 b){return vec2(a.x*b.x,a.x*b.y+a.y*b.x);}vec2 fDiv(vec2 a,vec2 b){return vec2(a.x/b.x,(b.x*a.y-a.x*b.y)/(b.x*b.x));}vec2 fInv(vec2 z){float q=1./z.x;return vec2(q,-z.y*q/z.x);}vec2 fPow(vec2 a,vec2 b){float q=pow(a.x,b.x);return vec2(q,q*(b.x*a.y/a.x+b.y*log(a.x)));}vec2 fConstPow(vec2 z,float power){float q=pow(z.x,power);return vec2(q,power*z.y*q/z.x);}vec2 fIntPow(vec2 z,int power){float res=1.;for(int n=0;n<abs(power);n++){res*=z.x;}if(power<0)res=1./res;return vec2(res,float(power)*res/z.x*z.y);}vec2 fSquare(vec2 z){return vec2(z.x*z.x,2.*z.x*z.y);}vec2 fSqrt(vec2 z){float q=sqrt(z.x);return vec2(q,.5*z.y/q);}vec2 fExp(vec2 z,float base){float q=pow(base,z.x);return vec2(q,q*z.y);}vec2 fLn(vec2 z){return vec2(log(z.x),z.y/z.x);}vec2 fSin(vec2 z){return vec2(sin(z.x),cos(z.x)*z.y);}vec2 fCos(vec2 z){return vec2(cos(z.x),-sin(z.x)*z.y);}vec2 fTan(vec2 z){float q=cos(z.x);return vec2(tan(z.x),z.y/(q*q));}vec2 fAsin(vec2 z){return vec2(asin(z.x),z.y/sqrt(1.-z.x*z.x));}vec2 fAcos(vec2 z){return vec2(acos(z.x),-z.y/sqrt(1.-z.x*z.x));}vec2 fAtan(vec2 z){return vec2(atan(z.x),z.y/(1.+z.x*z.x));}vec2 fSinh(vec2 z){return vec2(sinh(z.x),cosh(z.x)*z.y);}vec2 fCosh(vec2 z){return vec2(cosh(z.x),sinh(z.x)*z.y);}vec2 fTanh(vec2 z){float q=cosh(z.x);return vec2(tanh(z.x),z.y/(q*q));}vec2 fAsinh(vec2 z){return vec2(asinh(z.x),z.y/sqrt(z.x*z.x+1.));}vec2 fAcosh(vec2 z){return vec2(acosh(z.x),z.y/sqrt(z.x*z.x-1.));}vec2 fAtanh(vec2 z){return vec2(atanh(z.x),z.y/(1.-z.x*z.x));}vec2 fMin(vec2 a,vec2 b){return a.x<b.x?a:b;}vec2 fMax(vec2 a,vec2 b){return a.x>b.x?a:b;}vec2 fFloor(vec2 z){return vec2(floor(z.x),0);}vec2 fCeil(vec2 z){return vec2(ceil(z.x),0);}vec2 fAbs(vec2 z){return vec2(abs(z.x),z.y*sign(z.x));}vec2 fSign(vec2 z){return vec2(sign(z.x),0);}vec2 fMod(vec2 a,vec2 b){return vec2(mod(a.x,b.x),a.y);}vec2 fFract(vec2 z){return vec2(fract(z.x),z.y);}vec2 fClamp(vec2 z,vec2 edge0,vec2 edge1){return fMax(edge0,fMin(edge1,z));}vec2 fSmoothstep(vec2 edge0,vec2 edge1,vec2 z){z=fClamp(fDiv(z-edge0,edge1-edge0),vec2(0),vec2(1,0));vec2 sq=fSquare(z);return 3.*sq-2.*fMul(sq,z);}vec2 fMix(vec2 a,vec2 b,vec2 t){return a+fMul(b-a,t);}\n\n/*\n// FOR DEVELOPEMENT\n\n// Conversion to dual numbers\n// Variables are what you are differentiating with respect to\n// Constants are everything else\nvec2 const2dual(in float x) {\n    return vec2(x, 0.0);\n}\n\nvec2 var2dual(in float x) {\n    return vec2(x, 1.0);\n}\n\n// Elementary operations (+/-,\nvec2 fAdd(in vec2 a, in vec2 b) {\n    return a + b;\n}\n\nvec2 fSub(in vec2 a, in vec2 b) {\n    return a - b;\n}\n\n// Multiply or divide by a constant (as well as +/-) can be done\n// as though x were an ordinary number without extra overhead\nvec2 fMul(in vec2 a, in vec2 b) {\n    return vec2(a.x * b.x, a.x * b.y + a.y * b.x);\n}\n\nvec2 fDiv(in vec2 a, in vec2 b) {\n    return vec2(a.x / b.x, (b.x * a.y - a.x * b.y) / (b.x * b.x));\n}\n\n// 1/z\nvec2 fInv(in vec2 z) {\n    float q = 1.0 / z.x;\n    return vec2(q, -z.y * q / z.x);\n}\n\n// a^b\nvec2 fPow(in vec2 a, in vec2 b) {\n    float q = pow(a.x, b.x);\n    return vec2(q, q * (b.x * a.y / a.x + b.y * log(a.x)));\n}\n\n// Less expensive cases of fPow()\nvec2 fConstPow(in vec2 z, in float power) {\n    float q = pow(z.x, power);\n    return vec2(q, power * z.y * q / z.x);\n}\n\n// For integer powers (0 and negative powers supported)\nvec2 fIntPow(in vec2 z, in int power) {\n    float res = 1.0;\n    for (int n=0; n < abs(power); n++) { res *= z.x; }\n    if (power < 0) res = 1.0 / res;\n    return vec2(res, float(power) * res / z.x * z.y);\n}\n\n// z^2\nvec2 fSquare(in vec2 z) {\n    return vec2(z.x * z.x, 2.0 * z.x * z.y);\n}\n\n// sqrt(z)\nvec2 fSqrt(in vec2 z) {\n    float q = sqrt(z.x);\n    return vec2(q, 0.5 * z.y / q);\n}\n\n// base^z\nvec2 fExp(in vec2 z, in float base) {\n     float q = pow(base, z.x);\n     return vec2(q, q * z.y);\n}\n\n// ln(z)\nvec2 fLn(in vec2 z) {\n    return vec2(log(z.x), z.y / z.x);\n}\n\n// Trig\nvec2 fSin(in vec2 z) {\n    return vec2(sin(z.x), cos(z.x) * z.y);\n}\n\nvec2 fCos(in vec2 z) {\n    return vec2(cos(z.x), -sin(z.x) * z.y);\n}\n\nvec2 fTan(in vec2 z) {\n    float q = cos(z.x);\n    return vec2(tan(z.x), z.y / (q * q));\n}\n\n// Inverse trig\nvec2 fAsin(in vec2 z) {\n    return vec2(asin(z.x), z.y / sqrt(1.0 - z.x * z.x));\n}\n\nvec2 fAcos(in vec2 z) {\n    return vec2(acos(z.x), -z.y / sqrt(1.0 - z.x * z.x));\n}\n\nvec2 fAtan(in vec2 z) {\n    return vec2(atan(z.x), z.y / (1.0 + z.x * z.x));\n}\n\n// Hyperbolic trig\nvec2 fSinh(in vec2 z) {\n    return vec2(sinh(z.x), cosh(z.x) * z.y);\n}\n\nvec2 fCosh(in vec2 z) {\n    return vec2(cosh(z.x), sinh(z.x) * z.y);\n}\n\nvec2 fTanh(in vec2 z) {\n    float q = cosh(z.x);\n    return vec2(tanh(z.x), z.y / (q * q));\n}\n\n// Inverse hyperbolic trig\nvec2 fAsinh(in vec2 z) {\n    return vec2(asinh(z.x), z.y / sqrt(z.x * z.x + 1.0));\n}\n\nvec2 fAcosh(in vec2 z) {\n    return vec2(acosh(z.x), z.y / sqrt(z.x * z.x - 1.0));\n}\n\nvec2 fAtanh(in vec2 z) {\n    return vec2(atanh(z.x), z.y / (1.0 - z.x * z.x));\n}\n\n// Miscellaneous\nvec2 fMin(in vec2 a, in vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 fMax(in vec2 a, in vec2 b) {\n    return a.x > b.x ? a : b;\n}\n\nvec2 fFloor(in vec2 z) {\n    return vec2(floor(z.x), 0.0);\n}\n\nvec2 fCeil(in vec2 z) {\n    return vec2(ceil(z.x), 0.0);\n}\n\nvec2 fAbs(in vec2 z) {\n    return vec2(abs(z.x), z.y * sign(z.x));\n}\n\nvec2 fSign(in vec2 z) {\n    return vec2(sign(z.x), 0.0);\n}\n\nvec2 fMod(in vec2 a, in vec2 b) {\n     return vec2(mod(a.x, b.x), a.y);\n}\n\nvec2 fFract(in vec2 z) {\n     return vec2(fract(z.x), z.y);\n}\n\nvec2 fClamp(in vec2 z, in vec2 edge0, in vec2 edge1) {\n    return fMax(edge0, fMin(edge1, z));\n}\n\nvec2 fSmoothstep(in vec2 edge0, in vec2 edge1, in vec2 z) {\n    z = fClamp(fDiv(z - edge0, edge1 - edge0), vec2(0.0), vec2(1.0, 0.0));\n    vec2 sq = fSquare(z);\n    return 3.0 * sq - 2.0 * fMul(sq, z);\n}\n\nvec2 fMix(in vec2 a, in vec2 b, in vec2 t) {\n    return a + fMul(b - a, t);\n}\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 212, 235, 235, 319], [321, 321, 350, 350, 462], [464, 464, 492, 492, 789], [791, 791, 810, 810, 889], [891, 891, 946, 946, 1499]]}
{"id": "sdBSDz", "name": "smoothstep hue cycle", "author": "RavenWorks", "description": "smoother than the traditional, but it still hits the six primaries and secondaries unlike that siney one whose name I can't remember", "tags": ["color", "demo", "hue", "smooth"], "likes": 1, "viewed": 267, "published": 3, "date": "1620004431", "time_retrieved": "2024-07-30T19:22:06.665188", "image_code": "float slowSawStraight(float x){\n    float result = min(1.0, mod(x,0.5)*6.0);\n    if (mod(x,1.0) >= 0.5) result = 1.0-result;\n    return result;\n}\nvec3 slowSawStraightThree(float x){\n    return vec3(\n        slowSawStraight(x+0.0),\n        slowSawStraight(x+1.0/3.0),\n        slowSawStraight(x+2.0/3.0)\n    );\n}\n\nfloat slowSawSmooth(float x){\n    float result = smoothstep(0.0,1.0, mod(x,0.5)*6.0);\n    if (mod(x,1.0) >= 0.5) result = 1.0-result;\n    return result;\n}\nvec3 slowSawSmoothThree(float x){\n    return vec3(\n        slowSawSmooth(x),\n        slowSawSmooth(x+1.0/3.0),\n        slowSawSmooth(x+2.0/3.0)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    float hueVal = iTime*0.2+uv.x;\n    vec3 col = slowSawSmoothThree(hueVal);\n    if (uv.y < 0.2) col = slowSawStraightThree(hueVal);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBSDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 145], [146, 146, 181, 181, 310], [312, 312, 341, 341, 466], [467, 467, 500, 500, 619], [621, 621, 677, 677, 891]]}
{"id": "sdSXDR", "name": "Tanglecube Ray Intersection", "author": "oneshade", "description": "I need to spend some time making a simpler version for just the first intersection (I doubt I'll beat iq though :D).", "tags": ["3d", "raytracing", "ray", "raycasting", "intersection", "tanglcube"], "likes": 6, "viewed": 133, "published": 3, "date": "1619996750", "time_retrieved": "2024-07-30T19:22:07.422164", "image_code": "struct Hit4 {\n    int numHits;\n    vec4 hits;\n};\n\n// Quartic solver I made here: https://www.shadertoy.com/view/fsB3Wt\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    float bb = b * b;\n    float p = c - 0.375 * bb;\n    float q = d - 0.5 * b * c + 0.125 * bb * b;\n    float r = e - 0.25 * b * d + 0.0625 * bb * c - 0.01171875 * bb * bb;\n    int n = 0;\n\n    // Solve for an arbitary root to x^3 + 2px^2 + (p^2 - 4r)x - q^2\n    float ra = 2.0 * p;\n    float rb = p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float raa = ra * ra;\n    float inflect = ra / 3.0;\n\n    float rp = rb - raa / 3.0;\n    float rq = raa * ra / 13.5 - ra * rb / 3.0 + rc;\n    float rppp = rp * rp * rp, rqq = rq * rq;\n\n    float p2 = abs(rp);\n    float v1 = 1.5 / rp * rq;\n\n    float lambda;\n    if (rqq * 0.25 + rppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (rp < 0.0) lambda = sign(rq) * cosh(acosh(v2 * -sign(rq)) / 3.0);\n        else lambda = sinh(asinh(v2) / 3.0);\n        lambda = -sqrt(p2 / 3.0) * lambda;\n    }\n\n    else lambda = sqrt(-rp / 3.0) * cos(acos(v1 * sqrt(-3.0 / rp)) / 3.0);\n    lambda = 2.0 * lambda - inflect;\n\n    // Solve two quadratic equations (checking for negative sqrts which should be complex)\n    if (lambda < 0.0) return n;\n    float sqrtLambda = sqrt(lambda);\n\n    float pLambda = p + lambda, qLambda = q / sqrtLambda;\n    float offs = 0.25 * b;\n\n    float foo = lambda - 2.0 * (pLambda + qLambda);\n    float bar = lambda - 2.0 * (pLambda - qLambda);\n\n    if (foo >= 0.0) {\n        roots.xy = (vec2(1.0, -1.0) * sqrt(foo) + sqrtLambda) * 0.5 - offs;\n        n += 2;\n    }\n\n    if (bar >= 0.0) {\n        vec2 others = (vec2(1.0, -1.0) * sqrt(bar) - sqrtLambda) * 0.5 - offs;\n        if (n > 0) roots.zw = others;\n        else roots.xy = others;\n        n += 2;\n    }\n\n    return n;\n}\n\n// Relying on reverse coefficients trick for now\nint solveQuartic2(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    int nroots = solveQuartic(e, d, c, b, a, roots);\n    if (nroots == 0) return 0;\n    if (nroots == 2) roots.xy = 1.0 / roots.xy;\n    if (nroots == 4) roots = 1.0 / roots;\n    return nroots;\n}\n\n// Intersection\nHit4 iTangleCube(in vec3 ro, in vec3 rd, in float size, in float iso) {\n    ro /= size, rd /= size;\n    vec3 oo = ro * ro, od = ro * rd, dd = rd * rd;\n\n    float a =       dot(dd, dd);\n    float b = 4.0 * dot(od, dd);\n    float c = 6.0 * dot(oo, dd) - 1.25 * dot(rd, rd);\n    float d = 4.0 * dot(oo, od) - 2.50 * dot(ro, rd);\n    float e =       dot(oo, oo) - 1.25 * dot(ro, ro) + 0.6875 - 0.0625 * iso;\n\n    vec4 roots;\n    int numRoots = solveQuartic2(a, b, c, d, e, roots);\n\n    return  Hit4(numRoots, roots);\n}\n\n// Normal\nvec3 nTangleCube(in vec3 p, in float size, in float iso) {\n    p /= size;\n    return normalize(1.6 * p * p * p - p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    float size = 1.25 + 0.25 * cos(iTime);\n    float iso = sin(iTime) * 5.0;\n\n    // Find the closest hit in front of the camera\n    Hit4 hit = iTangleCube(ro, rd, size, iso);\n    float t = -1.0;\n    vec3 hitPos;\n    for (int n=0; n < int(hit.numHits); n++) {\n        vec3 hitCandid = ro + rd * hit.hits[n];\n        if (hit.hits[n] > 0.0 && (t < 0.0 ? true : hit.hits[n] < t)) {\n            t = hit.hits[n];\n            hitPos = hitCandid;\n        }\n    }\n\n    // Render the shape if hitting\n    if (t > 0.0) {\n        vec3 n = nTangleCube(hitPos, size, iso);\n        float diff = abs(dot(n, -rd));\n        float checkers = mod(dot(floor(hitPos / size * 3.0), vec3(1.0)), 2.0);\n        fragColor = mix(vec4(0.5 + 0.5 * checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, n)), 0.25);\n        fragColor.rgb *= diff;\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSXDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 119, 215, 215, 1946], [1948, 1997, 2094, 2094, 2289], [2291, 2307, 2378, 2378, 2821], [2823, 2833, 2891, 2891, 2951], [2953, 2953, 3008, 3008, 4517]]}
{"id": "NsBXDz", "name": "juststars1", "author": "Del", "description": "stars - a rejig of the stars here https://www.shadertoy.com/view/MdSSzW by luther, using less texture fetches\nuse mouse to pan around", "tags": ["juststars"], "likes": 5, "viewed": 306, "published": 3, "date": "1619989815", "time_retrieved": "2024-07-30T19:22:08.438447", "image_code": "// slight rejig of stars from https://www.shadertoy.com/view/MdSSzW by luther\n// use mouse to pan around\n\n// colour gradient\nvec3 colgrad(float x)\n{    \n    float r = 1.0 - (pow(x, 1.2) * 0.5);\n    float g = (pow(min(1.0, x+0.6), 2.0) * 0.9) - (x * 0.4);    \t\n    float b = (1.9-r) * 0.5;\n    return vec3(r*0.7,g,b) * 1.1;\n}\n\n// voronoi stars - simplified and slightly optimized to use a single texture fetch for the randomness\nvec3 stars(in vec2 pos)\n{\n    vec3 col = vec3(0.0);\n    vec2 n = floor(pos);\n    vec2 f = fract(pos);\n    vec2 dir = sign(f-0.5);\n    for( float j=0.0; j<=1.0; j+=1.0 )\n    {\n   \t\tfor( float i=0.0; i<=1.0; i+=1.0 )    \n\t    {\n            vec2 cell = vec2(i*dir.x,j*dir.y);\n            vec2 p = (n + cell)+0.5;\n            vec4 rnd1 = texture( iChannel0, p/256.0, -100.0 ).xyzw; // random offset,col,brightness\n            float d = length(cell + rnd1.xy - f);                \n\n            // falloff\n            float dist = max(0.1, 1.0 - d);\n            float starfo = pow(dist, 60.0) * 6.5 + pow(dist, 120.0);\n\t        col += colgrad(rnd1.z*1.2) * rnd1.w * starfo;\n        }\n    }\n    return col;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float zoom = 0.8+sin(iTime)*0.2;\n    uv *= zoom;\n    uv *= rot(iTime*0.05);\n\n    // mouse pan\n    vec2 mousep = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    mousep *= zoom;\n    mousep *= rot(iTime*0.05);\n    uv += vec2(3.1, 1.3)-mousep; // origin\n\n    vec3 col = vec3(0.0);\n    float starscale = 0.5;\n    float starbrightness = 0.6 * (1.0 / pow(zoom, 0.3));\n    for (int i = 0; i < 8; i++)\n    {        \n        col += stars(uv*starscale ) * starbrightness;\n        starbrightness *= .95;// .9\n        starscale *= 1.5;\n        \n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 125, 148, 148, 324], [326, 428, 453, 453, 1129], [1131, 1131, 1152, 1152, 1220], [1222, 1222, 1279, 1279, 1929]]}
{"id": "7sSXWR", "name": "Circle Gradience", "author": "Chidebe", "description": "I tried making a circle with gradience.", "tags": ["length", "gradience"], "likes": 3, "viewed": 260, "published": 3, "date": "1619988977", "time_retrieved": "2024-07-30T19:22:09.188441", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0f) / iResolution.y;\n    vec3 Col = vec3(0, 0, 0);\n    vec3 AfterCol = vec3(0, 0, 0);\n    \n    if( iTime <= 10.0f)\n    {\n        Col = vec3(sin(iTime), sin(iTime + length(uv)), cos(iTime * 0.4f));\n        vec2 Position = vec2(0, 0);\n        Col += distance(uv, Position);\n        vec2 GradienceDir = vec2(0, 0.3f);\n        float Intensity = 0.6f;\n        Col *= sin(iTime);\n    }\n    if( iTime > 11.0f)\n    {\n        /*AfterCol = vec3(sin(iTime) - 0.4f, sin(iTime + length(uv)), cos(iTime * 0.4f) - 0.4f);\n        vec2 Position = vec2(sin(iTime * uv.x), sin(iTime - 0.4f));\n        AfterCol += distance(uv, Position);\n        vec2 GradienceDir = vec2(0, 0.3f);\n        float Intensity = 0.6f;\n        AfterCol *= sin(iTime);*/\n        /*Col.x = mix(Col.x, AfterCol.x, 0.001f);\n        Col.y = mix(Col.y, AfterCol.y, 0.001f);\n        Col.z = mix(Col.z, AfterCol.z, 0.006f);*/\n    }\n    if( iTime > 9.0f)\n    {\n        Col = vec3(sin(iTime) - 0.4f, sin(iTime + length(uv)), cos(iTime * 0.4f) - 0.4f);\n        vec2 Position = vec2(sin(iTime * uv.x), sin(iTime - 0.4f));\n        Col += distance(uv, Position);\n        vec2 GradienceDir = vec2(0, 0.3f);\n        float Intensity = 0.6f;\n        Col *= sin(iTime);\n    }\n    \n    fragColor = vec4(Col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSXWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1409]]}
{"id": "sdBSWR", "name": "Tanglesquare and Tanglecube", "author": "oneshade", "description": "Tangled?\n[url=https://mathworld.wolfram.com/Tanglecube.html]https://mathworld.wolfram.com/Tanglecube.html[/url]", "tags": ["3d", "raymarching", "tanglesquare", "tanglecube"], "likes": 13, "viewed": 193, "published": 3, "date": "1619986806", "time_retrieved": "2024-07-30T19:22:09.937439", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float unit = 2.0 / iResolution.y;\n\n    // Offset to left side and shrink to fit\n    uv.x += 0.4;\n    uv *= 5.0;\n\n    float d = dot(16.0 * uv * uv, uv * uv) - dot(20.0 * uv, uv) + 5.0; // -6 to produce similar visual results\n    vec2 grad = 64.0 * uv * uv * uv - 40.0 * uv;\n    d /= max(length(grad), 20.0); // Distance estimate\n    d *= 0.2; // Undo shrinking in the distance field\n\n    fragColor.rgb += 0.125 + 0.125 * sin(d * 1000.0); // Isolines\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.5 + 0.01 * grad, 0.0), smoothstep(unit, 0.0, d)); // Fill\n\n    // Unshrink to fit and offset to right side\n    uv /= 5.0;\n    uv.x -= 0.8;\n\n    // Ray\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Double rotation\n    float c = cos(iTime), s = sin(iTime);\n    mat3 mat = mat3(  c, -s * s, -s * c,\n                    0.0,      c,     -s,\n                      s,  s * c,  c * c);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        p *= mat;\n\n        vec3 grad = 64.0 * p * p * p - 40.0 * p; // Gradient\n        float g = length(grad);\n\n        float d = dot(16.0 * p * p, p * p) - dot(20.0 * p, p) + 11.0;\n        d /= max(g, 20.0); // This turns raymarching into Newton-Raphson, hacked to prevent too large of steps\n\n        if (abs(d) < 0.001) {\n            vec3 nor = grad / g * transpose(mat);\n            vec3 light = -rd;\n\n            float diff = abs(dot(nor, light));\n            float checkers = 0.5 + 0.5 * mod(dot(floor(p * 5.0), vec3(1.0)), 2.0);\n            fragColor = mix(vec4(checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, nor)), 0.25);\n            fragColor.rgb *= diff;\n        }\n\n        if (t > 20.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBSWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1954]]}
{"id": "NdSXDz", "name": "Basic Start", "author": "Hitthesurf", "description": "Fighting Man, With Moving Background", "tags": ["greenscreen"], "likes": 2, "viewed": 198, "published": 3, "date": "1619985931", "time_retrieved": "2024-07-30T19:22:10.701396", "image_code": "float my_max4(in vec4 vector);\n\nfloat my_max4(in vec4 vector)\n{\n    return max(max(vector.x,vector.y),vector.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    // Output to screen\n    \n    vec4 my_texture_0 = texture(iChannel0, (fragCoord.xy-vec2(iTime*10.0,0))/iResolution.xy);\n    vec4 my_video = texture(iChannel1, fragCoord.xy/iResolution.xy);\n    \n    //Find if green\n    if (my_max4(abs(my_video - vec4(0.051,0.639,0.145,1.0))) <= 0.2)\n    {\n        // es ist grun\n        fragColor = my_texture_0;\n    }\n    else\n    {\n        // es ist nicht grun\n        fragColor = my_video;\n    }\n    \n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSXDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 63, 63, 114], [116, 116, 173, 203, 621]]}
{"id": "fsSXWR", "name": "Day 500", "author": "jeyko", "description": "ptot", "tags": ["mdtmjvm"], "likes": 18, "viewed": 353, "published": 3, "date": "1619985307", "time_retrieved": "2024-07-30T19:22:11.741615", "image_code": "// thx to wyatt for teaching me storing voronoi particle tracking stuff in different buffers and packing!\n// int packing from somewhere on shadertoy\n\n// ~500 ellastic 5s and 0s\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 pPntr = T1(U);\n    vec4 p = T(pPntr.xy);\n    vec2 pos = unpackU16(p.x);\n    \n    C = texture(iChannel0,U/R);\n    \n        \n    vec2 uv = (U - 0.5*R)/R.y;\n    \n    C = 1. - C;\n    \n    //C = 1. - C*2.5;\n    \n    \n    C = max(C,0.);\n    C = pow(C,vec4(0.4545)*vec4(2.5,1.,1,1));  \n    \n    \n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ------------------------------- //\n//           Movement              //\n// ------------------------------- //\n\nint neighborsCnt = 0;\nvec4 neighborPtrs[] = vec4[8](vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0));\n\n//#define steps  floor(particleSz*iResolution.x*8.)\n\nfloat steps = 20.;\nfloat stepSz = 2.;\nvoid findNeighbors( vec4 me, vec2 mePos, vec2 dir){\n\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = TF1( mePos.xy * R + dir * i*stepSz );\n        vec4 otherP    = T( otherPntr.xy );\n        \n        //if ( otherP.x != me.x){\n        //if ( unpackU16(otherP.x) != me.xy ){\n        if ( unpackU16(otherP.x).x != mePos.x && unpackU16(otherP.x).y != mePos.y ){\n            for(int i = 0; i < neighborsCnt; i++){\n                if (neighborPtrs[i] == otherPntr)\n                    return;\n            }\n            neighborPtrs[neighborsCnt++] = otherPntr;\n            return;\n        }\n    }\n\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\n    if (iFrame < 3){\n        \n        float pc = floor(sqrt(particleCount));\n        vec2 id = floor(U/R*pc) + 0.0001;\n        vec2 cellSz = R/(pc + 1.);\n        \n        vec2 pos = id*cellSz/R + cellSz/R;\n\n        vec2 vel = r24(id).xy*2. - 1.;\n\n        C.x = packU16(pos);\n        C.y = packS8(vel.xyxy);    \n        C.z = packU8(r24(id));\n        \n    } else {\n        C = T(U);\n        \n        vec4 pPtr = T1(C.xy*R);\n        \n        if (iFrame > startOffs){\n            \n            //C = T( pPtr.xy );\n            \n            vec2 pos = unpackU16(C.x);\n            vec2 vel = unpackS8(C.y).xy;\n            vec4 data = unpackU8(C.z);\n    \n\n            findNeighbors( C, pos, vec2(1,0));\n            findNeighbors( C, pos, vec2(-1,0));\n            findNeighbors( C, pos, vec2(0,1));\n            findNeighbors( C, pos, vec2(0,-1));\n            \n            findNeighbors( C, pos, vec2(1,1));\n            findNeighbors( C, pos, vec2(1,-1));\n            findNeighbors( C, pos, vec2(-1,1));\n            findNeighbors( C, pos, vec2(-1,-1));\n            \n            vec2 meToMouse = iMouse.xy/iResolution.xy-pos;\n            meToMouse *= resFact;\n            \n            if(iMouse.z > 0.)\n                vel -= 1.*normalize(meToMouse)*smoothstep(0.34,0.,length(meToMouse));\n            // elastic collisions\n            for(int i = 0; i < neighborsCnt; i++){    \n                vec4 otherPtr = neighborPtrs[i];\n                vec4 other = T(otherPtr.xy);\n                vec2 otherVel = unpackS8(other.y).xy;\n                vec4 otherData = unpackU8(other.z);\n                \n                other.xy = unpackU16(other.x);\n                vec2 meToOther = (other.xy - pos.xy)*resFact.xy;\n                \n                \n                float distBetween = length(meToOther);\n                \n                \n                float sizes =  getSize(data.x) + getSize(otherData.x); \n                \n                if( distBetween < sizes ){\n                    \n\n                    vec2 normal = normalize(meToOther);\n                    vec2 tangent = vec2(-normal.y,normal.x);\n\n\n                    float meNorm = dot(vel, normal);\n                    float meTan = dot(vel, tangent);\n                    float otherNorm = dot(otherVel, normal);\n                    float otherTan = dot(otherVel, tangent);\n\n                    float massMe = 1.;\n                    float massOther = 1.;\n                    \n                    \n                    meNorm = ( meNorm * (massMe - massOther) + 2.*massOther*otherNorm ) / (massMe + massOther);\n                    \n                    vel = tangent * meTan + normal*meNorm;\n                    \n                    pos -= normalize(meToOther)*(abs(distBetween - sizes));\n                    \n                }\n\n\n\n\n            }\n        \n        \n            if (abs(pos.x - 0.5) > 0.5 - particleSz*0.5){\n                vel.x *= -1.;\n                if ( sign(vel.x) != sign(-pos.x + 0.5) )\n                    vel.x *= -1.;\n            }\n            if (abs(pos.y - 0.5) > 0.5 - particleSz*0.5){\n                vel.y *= -1.;\n                if ( sign(vel.y) != sign(-pos.y + 0.5) )\n                    vel.y *= -1.;            \n            }\n\n            \n            \n            pos += vel/resFact*0.002;\n            \n            \n            C.x = packU16(pos);\n            C.y = packS8(vel.xyxy);\n            //C.x = packSnorm(vec4(pos,vel));\n        }\n    }\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R (iResolution.xy)\n#define T(u) texture(iChannel0,(u)/R)\n#define T1(u) texture(iChannel1,(u)/R)\n#define T2(u) texture(iChannel2,(u)/R)\n#define T3(u) texture(iChannel3,(u)/R)\n#define TF(u)  texelFetch(iChannel0,ivec2(u), 0)\n#define TF1(u) texelFetch(iChannel1,ivec2(u), 0)\n#define TF2(u) texelFetch(iChannel2,ivec2(u), 0)\n#define TF3(u) texelFetch(iChannel3,ivec2(u), 0)\n\n#define pi acos(-1.)\n\n#define startOffs 6\n\n//#define iTime mod(iTime,2.)\n\n#define particleCount pow(2.,9.)\n\n#define particleSz 0.015\n\n//#define getSize(idx) particleSz*(sin(idx*26. + iTime)*0.5 + 0.5)\n\n#define getSize(idx) particleSz*(pow((sin(idx*126. +iTime + sin(iTime))*0.5 + 0.5),8.)+1.)\n\n\n#define resFact vec2(R.x/R.y,1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define getIdx(a) vec2(mod(a,R.x), floor((a+R.x)/R.x)-1.)\n\n// 8bit\nhighp uint packU8(mediump uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nmediump uvec4 unpackU8(highp uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\nfloat packU8(  vec4  a) { return uintBitsToFloat(packU8(uvec4(round(clamp(a, 0., 1.)*255.)))); }\nvec4  unpackU8(float a) { return vec4(unpackU8(floatBitsToUint(a))) / 255.; }\nfloat packS8(  vec4  a) { return uintBitsToFloat(packU8(uvec4(round(clamp(a, -1., 1.)*127.5+127.5)))); }\nvec4  unpackS8(float a) { return clamp((vec4(unpackU8(floatBitsToUint(a))) - 127.5) / 127.5, -1., 1.); }\n\n\n// 16bit\nhighp uint packU16(highp uvec2 a) {\n    return uint( (a.x << 16)\n               | (a.y << 0)); }\nmediump uvec2 unpackU16(highp uint a) {\n    return uvec2( (a & 0xFFFF0000u) >> 16\n                , (a & 0x0000FFFFu) >> 0   ); }\nfloat packU16(  vec2  a) { return uintBitsToFloat(packU16(uvec2(round(clamp(a, 0., 1.)* (pow(2.,16.) - 1.))))); }\nvec2  unpackU16(float a) { return vec2(unpackU16(floatBitsToUint(a))) / (pow(2.,16.) - 1.); }\n\n\n\nvec4 r24(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\nfloat hash13(vec3 p3){\n    p3 = fract((p3)*0.1031);\n    p3 += dot(p3, p3.yzx  + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\n\n", "buffer_b_code": "// ------------------------------- //\n//           Tracking              //\n// ------------------------------- //\n\nfloat steps = 15.;\nfloat stepSz = 2.;\nvoid findMe( inout vec4 pPntr, inout vec2 pos, vec2 U, vec2 dir){\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = T1(U + dir*i);\n        vec4 otherP = T(otherPntr.xy);\n        vec2 otherPos = unpackU16(otherP.x);\n        \n        if (length( (U/R - otherPos.xy)/resFact.yx ) < length( (U/R - pos.xy)/resFact.yx )){\n            pos = otherPos;\n            pPntr = otherPntr;\n        }\n        \n    }\n\n}\n        \n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n\n    if (iFrame < 3) {\n        //C = r24(U);\n        C.xy = U;\n        C.zw -= C.zw;\n    } else {        \n        C = T1(U);\n        \n        if (iFrame < startOffs){\n            steps = 100.;\n        }\n        \n        \n        vec4 pPntr = C;\n        vec4 p = T(pPntr.xy);\n        vec2 pos = unpackU16(p.x);\n        \n        findMe(pPntr,pos,U,vec2(0,1));\n        findMe(pPntr,pos,U,vec2(0,-1));\n        findMe(pPntr,pos,U,vec2(1,0));\n        findMe(pPntr,pos,U,vec2(-1,0));\n        findMe(pPntr,pos,U,vec2(1,1));\n        findMe(pPntr,pos,U,vec2(1,-1));\n        findMe(pPntr,pos,U,vec2(-1,1));\n        findMe(pPntr,pos,U,vec2(-1,-1));\n        \n        C = pPntr;\n        \n        if (iFrame == startOffs-1){\n            C.zw = 1. + floor(r24(C.xy).xy*2.99);\n        }\n    }\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// ------------------------------- //\n//           Painting              //\n// ------------------------------- //\n\n\nint neighborsCnt = 0;\nvec4 neighborPtrs[] = vec4[8](vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0),vec4(0));\n\nfloat steps = 7.;\nvoid findNeighbors( vec2 p, vec2 dir){\n    float stepSz = 1. + mod(float(iFrame),2.);\n    for(float i = 1.; i < steps; i++){\n        vec4 otherPntr = TF1( p.xy * R + dir * i*stepSz );\n        vec4 otherP    = T( otherPntr.xy );\n        vec2 otherPos = unpackU16(otherP.x);\n        \n        // TODO: don't unpack here\n        if ( otherPos.x != p.x ){\n            for(int i = 0; i < neighborsCnt; i++){\n                if (neighborPtrs[i] == otherPntr)\n                    return;\n            }\n            neighborPtrs[neighborsCnt++] = otherPntr;\n            return;\n        }\n    }\n\n}\n\nfloat sdSq(vec2 p, float s){p = abs(p) - s; return max(p.x,p.y);}\n\n\nconst int charsCnt = 1;\nfloat text(vec2 p, float[charsCnt] chars, float spacing, float s, bool isAbs, float absWidth) {\n\t\n    p *= s;  \n    p.x +=  1./16./2.;\n    p.y +=  1./16./2.;\n    \n    p.x *= 1. - spacing;\n    \n    vec2 id = floor(p*16.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing);\n    float char = chars[int(id.x)];\n    //char += 112. ;\n    \n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < float(charsCnt)  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w -0.5;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nfloat texta(vec2 p, float[charsCnt] chars, float spacing, float s, bool isAbs, float absWidth) {\n\tp *= s;\n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 0.1375*0.;\n    float char = chars[int(id.x)];\n    //char += 112. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - 0.5;\n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n     \n\n\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = U/R;\n    float pixelSize = dFdx(uv.x)*3.;\n    \n    vec4 mePntr = T1(U);\n    vec4 me = T(mePntr.xy);\n    \n    vec2 mePos = unpackU16(me.x);\n    vec4 meData = unpackU8(me.z);\n    \n    \n    C = texture(iChannel2,U/R);\n    findNeighbors( mePos, vec2(1,0));\n    findNeighbors( mePos, vec2(-1,0));\n    findNeighbors( mePos, vec2(0,1));\n    findNeighbors( mePos, vec2(0,-1));\n    \n    findNeighbors( mePos, vec2(1,1));\n    findNeighbors( mePos, vec2(1,-1));\n    findNeighbors( mePos, vec2(-1,1));\n    findNeighbors( mePos, vec2(-1,-1));\n    \n    for(int i = -1; i < neighborsCnt; i++){\n        vec4 otherPtr;\n        vec4 otherP;\n        if (i == -1){\n            otherPtr = mePntr;\n            otherP = me;\n        } else {\n            otherPtr= neighborPtrs[i];\n            otherP = T(otherPtr.xy);\n        }\n        \n        \n        vec2 pos = unpackU16(otherP.x);\n        vec4 data = unpackU8(otherP.z);\n    \n        float size = data.x;\n    \n    \n        //vec3 col = pal(0.6,vec3(0.5,0.5,0.5),vec3(5,2,3),5. + sin(data.z), 0. + data.w*6. + iTime); \n        vec3 col = pal(0.5*vec3(1.,1.,1.),vec3(0.1,0.5,0.5),vec3(5,2,3),5. + sin(data.z), 0. + data.w*6. + iTime*4.); \n        vec3 colb = pal(0.5*vec3(1.,1.,1.),vec3(0.1,0.5,0.5),vec3(5,2,3),5. + sin(data.z), 0. + data.w*6. + iTime*4. + 1.); \n        \n        //col -= col - 1.;\n        float dFill = length((pos.xy - uv)*resFact.xy) - getSize(size) ;\n        float s = getSize(size);\n        float charIdx = data.x < 0.5 ? 69. : 64.;\n        float t = text((uv-pos.xy + 0.*s)*resFact.xy, float[1](charIdx), 0.,   0.325/s/16., false, 0.);\n        \n        t /= 1.;\n        dFill = t;\n        vec3 crot = col - 1.;\n        crot.xz *= rot(-1.4);\n        crot += vec3(1,1.6,1.5);\n        \n        \n        float dOutline = abs(dFill) - 0.0001;\n        dFill += 0.00;\n        \n        vec3 crotb = crot;\n        C.xyz = mix(C.xyz,vec3(0),smoothstep(pixelSize,0.,dFill));\n        C.xyz = mix(C.xyz,crotb*0.6,smoothstep(pixelSize,0.,dOutline));\n        \n        //C.xyz = mix(C.xyz,crotb*0.6,smoothstep(pixelSize,0.,dFill));\n        //C.xyz = mix(C.xyz,vec3(0.1),smoothstep(pixelSize,0.,dOutline));\n        \n        if (data.y >= meData.y){\n        \n        \n        }\n        //C = mix(C,pal(0.5,0.5,vec4(3,2,1,1.),1.,otherPtr.z*1.*14. + 0.*otherPtr.w ),smoothstep(dFdx(uv.x),0.,length((otherP.xy - uv)*resFact.xy) - particleSz));\n    }\n\n    \n    \n    if(iFrame < 4)\n        C = vec4(0);\n}", "buffer_c_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSXWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 219, 219, 520]]}
{"id": "fd2XR1", "name": "Try1", "author": "Chidebe", "description": "This is my first try on ShaderToy with an account.", "tags": ["firsttrywithanaccount"], "likes": 0, "viewed": 190, "published": 3, "date": "1619981595", "time_retrieved": "2024-07-30T19:22:12.502580", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0, 0, 0);\n    //col.x = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n    col.x = mix(0.0f, cos(iTime * 1.0f), 1.0f);\n    col.y = mix(0.0f, sin(iTime * 1.0f), 0.5f);\n    col.y = mix(0.0f, sin(iTime * 1.0f), 0.7f);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 437]]}
{"id": "fdSSDR", "name": "piramide tunel", "author": "jorge2017a1", "description": "piramide tunel", "tags": ["piramidetunel"], "likes": 9, "viewed": 257, "published": 3, "date": "1619970873", "time_retrieved": "2024-07-30T19:22:13.428106", "image_code": "//por jorge2017a1-  //2-may-2021-\n//piramide tunel\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n\n//referencia piso patron\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\n\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\nvec3 light_pos3;  vec3 light_color3;\n//operacion de Union  por FabriceNeyret2\n#define opU3(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n#define opU(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n///------------------------------------\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n///https://www.shadertoy.com/view/Ws3SDl\n// signed distance to a pyramid of base 1x1 and height h\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz); // do p=abs(p) instead for double pyramid\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y-0.5*p.x, h*p.x+0.5*p.y);\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*q.x)/(m2+0.25), 0.0, 1.0 );\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    float d2 = max(-q.y,q.x*m2+q.y*0.5) < 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\nfloat opScalePiramide( in vec3 p,  float escala  )\n{\n    float h=1.0 ;\n    float s=escala;\n    vec3 ps=p/s;\n    return sdPyramid(ps, h)*s;\n}\n///-----------------------------------\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\n// path functions \nvec2 path(in float z)\n{ \n    vec2 p1 =vec2(2.13*sin(z * .15), 1.74*cos(z * .085));\n    vec2 p2 =vec2(2.97*sin(z * .079), 1.23*sin(z * .127));\n    return p1 - p2;\n}\n\nfloat pathxconz(in float z)\n{ \n    float p1 =2.13*sin(z * .15);\n    float p2 =2.97*sin(z * .079);\n    return p1 - p2;\n}\n\nvec3 piramidePuerta(vec3 p)\n{\n    vec3 res= vec3(9999.0, -1.0,-1.0);\n    float sdpy5= opScalePiramide(  p, 35.  );\n    float sdpuerta= sdBox(  p-vec3(0.0,14.0,5.0), vec3(2.0,4.0,20.0) );\n    p= rotate_y(p-vec3(-10.0,0.0,-20.0), radians(90.0));\n    float sdpy6= sdTriPrism(  p-vec3(0.0,0.0,-10.0), vec2(10.0,4.0) );\n    \n    vec3 pr=p;\n    pr.xy= rotatev2(pr.xy, radians(180.0));\n    float sdpy7= sdTriPrism(  pr-vec3(-8.7,-5.0,-10.0), vec2(10.0,4.0) );\n    sdpy5= differenceSDF(sdpy5,sdpuerta);\n    float sdpy7y6= unionSDF(sdpy7, sdpy6);\n    \n    res =opU3(res, vec3(sdpy7y6,-1.0,8.0));\n    res =opU3(res, vec3(sdpy5,-1.0,8.0));\n    res =opU3(res, vec3(sdpy7,-1.0,8.0));\n    return res;\n }   \n\n///------------------------------------\nvec3 GetDist(vec3 p  ) \n{\n\n\tvec3 res= vec3(9999.0, -1.0,-1.0);\n    vec3 pp=p;\n\tfloat planeDist1 = p.y+0.0;  //piso inf\n    res =opU3(res, vec3(planeDist1,-1.0,6.0)); //inf\n   \n   vec3 pb=p;\n   vec3 pc=p;\n   pb.x+= pathxconz(pb.z);\n   pb.x=abs(pb.x)-25.0;\n   pb.z= opRep1D( pb.z, 20.0 );\n   \n   pc.x+= pathxconz(pc.z);\n   pc.x=abs(pc.x)-27.0;\n   pc.z= opRep1D( pc.z, 20.0 );\n   \n   float banqueta1= sdBox(pb, vec3(2.0,5.0,10.0) );\n   float banqueta2= sdBox(pc, vec3(2.0,7.0,10.0) );\n   \n   p.z= opRep1D( p.z, 65.0 );\n   vec3 pip= piramidePuerta(p);\n\n    res =opU3(res, pip);\n    res =opU3(res, vec3(banqueta1,6.0,-1.0));\n    res =opU3(res, vec3(banqueta2,7.0,-1.0));\n      //res =opU3(res, vec3(1.0,0.0,MATERIAL_NO)); \n    //return (dist, id_color, id_material)\n    return res;\n}\n\n//------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{\n    float dO = 0.; \n    vec3 dS=vec3(9999.0,-1.0,-1.0);\n    float marchCount = 0.0;\n    vec3 p;\n    float minDist = 9999.0; \n    \n    for(int i=0; i <= PMaxSteps; i++) \n    {  \tp = ro + rd*dO;\n        dS = GetDist(p);\n        if ( abs(dS.x)<MIN_DIST  || i == PMaxSteps)\n        {   mObj.hitbln = true; minDist = abs(dO); break; }\n        \n        if(dO>MAX_DIST)\n        { mObj.hitbln = false;    minDist = dO;    break; } \n        dO += dS.x;\n        marchCount++;\n    }\n    mObj.dist = minDist;\n    mObj.id_color = dS.y;\n    mObj.marchCount=marchCount;\n    mObj.id_material=dS.z;\n    mObj.normal=GetNormal(p);\n    mObj.phit=p;\n    return dO;\n}\n//---------------------------------------------------\nfloat GetShadow(vec3 p, vec3 plig)\n{\n    vec3 lightPos = plig;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*MIN_DIST*2., l , MAX_STEPS/2);\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n//----------------------------------------------------\n///============================================================\n\nvec3 amb(vec3 c, float k)\n{  return c * k; }\n\nfloat diff(vec3 p,vec3 lp,vec3 n )\n{   vec3 l = normalize(lp - p);\n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    return dif;\n}\nfloat spec( vec3 p, vec3 lp,vec3 rd,vec3 n )\n{ \n   \n    vec3 l = normalize(lp - p);\n    vec3 r = reflect(-l, n);\n    float spe =pow(clamp(dot(r, -rd), 0.0, 1.0), 20.0);\n    \n    return spe;\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 col) \n{\n    vec3 l = lp - p;\n    vec3 ldir = normalize(p-rd);\n    \n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = normal;\n   \tvec3 r = reflect(-l, n);\n    \n    vec3 amb=amb(col, 0.5);\n    float dif = diff( p, lp, n );\n    float diff=max(0.,dot(ldir,-n));\n    vec3 ln=normalize(lp);\n    \n    float spe= spec(  p,  lp, rd, n );\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n     float bac=clamp(dot(n,-l),0.0,1.0);\n    float rim=pow(1.0+dot(n,rd),3.0);\n    float dn=.15*max(0.,dot(normalize(rd),-n));\n    \n    \n     vec3  hal = normalize(-rd+l);\n     float dif3 = clamp( dot(n,l), 0.0, 1.0 );\n     float amb2 = clamp( 0.5 + 0.5*dot(n,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n     float occ = 0.5 + 0.5*n.y;\n            \n    \n    float fshadow;\n    float sh = clamp(dot(n,normalize(lp)),0.0,1.0);\n    \n    \n    if (mObj.blnShadow==true)\n    { fshadow=GetShadow(p,lp);}\n    else\n    {   fshadow=0.5; }\n\n    vec3 lin=vec3(1.0);\n    lin*= amb*amb2*occ;\n    lin += 1.0*(dif+diff+dif3)*sh;\n    lin += 2.5*spe*vec3(1.0);\n    lin += 2.5*fre*vec3(1.);\n    lin += 0.5*dom*vec3(1.);\n    lin += 0.35*bac*vec3(1.);\n    lin += 0.35*rim*vec3(1.);\n    lin += 0.35*rim*dn*vec3(1.);\n    lin += 0.4*pow(clamp(dot(hal,n),0.0,1.0),12.0)*dif3;\n    lin *= atten*0.5*col*fshadow;\n    lin = pow(lin,vec3(0.4545));\n    return lin;\n}\n///============================================================\n//-------------------------------\nvec3 Getluz(vec3 p, vec3 ro, vec3 rd, vec3 nor , vec3 colobj ,vec3 plight_pos)\n{\n    float intensity=1.0;\n     vec3 result;\n     \n    result = lightingv3( nor, p, plight_pos,  rd,ro, colobj);\n    return result;\n}\n///-------------------------------------\nvec3 getSkyColA(vec3 rd) \n{\n    float t = (rd.x + 1.0) / 2.0;\n    return vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n}\n\nvec3 render_sky_color(vec3 rd)\n{\n    float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n\tvec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n//------------------------------------------------\nvec3 getMaterial( vec3 pp, float id_material)\n{\n  vec3 col=vec3(1.0);\n  vec3 p=pp;\n  vec3 l1;\n    \n    if (id_material==5.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*2.0),2.0);\n\t    return vec3( clamp(d,0.0,1.0) );\n    }\n    \n    if (id_material==6.0)\n    {\n        float escala=0.25;\n    \tfloat d = mod(floor(p.x*escala)+floor(p.z*escala*3.0),2.0);\n\t    vec3 col= vec3( clamp(d,0.0,1.0) );\n        l1= amb(col, 0.5) + col*diff( p,light_pos1, mObj.normal) + col*spec( p, light_pos1,mObj.rd, mObj.normal);\n        return l1;\n    }\n    \n    if (id_material==7.0)\n    {return pattern( p.xz );}\n    \n    if (id_material==8.0)\n    {return pattern( p.xy ); }\n    \n}\n\n//-------------------------------------------------\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material)\n{\n   \tvec3 colobj; \n    \n     if( mObj.hitbln==false) return  render_sky_color(rd);\n    \n    if (id_color<100)\n\t\t{ colobj=getColor(int( id_color)); }\n    \n    if (id_material>-1.0 && id_color==-1)\n        { \n            colobj=vec3(0.5);\n            colobj*=getMaterial(p, id_material); \n            return colobj;\n        }\n    return colobj;\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n  vec3 col = vec3(0);\n   TObj Obj;\n   mObj.rd=rd; mObj.ro=ro;\n   vec3 p ;\n\n   float d=RayMarch(ro,rd, MAX_STEPS);\n   \n    Obj=mObj;\n    if(mObj.hitbln) \n    {\n        p = (ro + rd * d );  \n          vec3 nor=mObj.normal;\n\n        vec3 colobj;\n        colobj=GetColorYMaterial( p, nor, ro, rd,  int( Obj.id_color), Obj.id_material);\n\n        float dif1=1.0;\n        vec3 result;\n        result=  Getluz( p,ro,rd, nor, colobj ,light_pos1);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos2);\n        result+= Getluz( p,ro,rd, nor, colobj ,light_pos3);\n        //result/=1.25;\n        col= result;\n    }\n    else if(d>MAX_DIST)\n    col= render_sky_color(rd);\n    \n       \n   return col;\n}\n\n///---------------------------------------------\nvec3 linear2srgb(vec3 c) {\n    return mix(\n        12.92 * c,\n        1.055 * pow(c, vec3(1.0/1.8)) - 0.055,\n        step(vec3(0.0031308), c)\n    );\n    \n    //1.055 * pow(c, vec3(1.0/2.4)) - 0.055,\n}\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{    return vec3(1.0) - exp(-hdrColor * exposure);  }\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   mObj.uv=uv;\n    float t;\n    t=mod(iTime*8.0,500.0);\n    itime=t;\n\t//mObj.blnShadow=false;\n    mObj.blnShadow=true;\n        \n \tlight_pos1= vec3(0.0, 30.0, 20.0 ); light_color1=vec3( 1.0 );\n \tlight_pos2= vec3( 0.0, 40.0, -20.0 ); light_color2 =vec3( 1.0 ); \n    light_pos3= vec3( 10.0, 15.0, 0.0 ); light_color3 =vec3( 1.0 ); \n \n   \n   vec3 ro=vec3(0.0,12.0,-40.0+t);\n     vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      \n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    light_pos3+=ro;\n    vec3 col= Render( ro,  rd);\n    //col = exposureToneMapping(2.0, col);\n    col = linear2srgb(col);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "///------------------------------------\nstruct TObj\n{\n    float id_color;\n    float id_objeto;\n    float id_material;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 phit; //22-mar-2021\n    vec3 rf;\n    float marchCount;\n    bool blnShadow;\n    bool hitbln;\n};\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\nfloat itime;\n\n#define PI 3.14159265358979323846264\n#define MATERIAL_NO -1.0\n#define COLOR_NO -1.0\n#define COLORSKY vec3(0.1, 0.1, 0.6)\n\n\nfloat random() \n{ return fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453); }\n\nvec3 checkerBoard(float u, float v, float interval)\n{\n    float uu = floor(u/interval*2.0);\n    float vv = floor(v/interval*2.0);\n    float p =mod(uu+vv,2.0);\n    return vec3(0.1+0.9*p);\n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9) \n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n    if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSSDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[603, 603, 639, 639, 660], [661, 661, 693, 693, 777], [779, 823, 870, 870, 897], [899, 899, 942, 942, 969], [971, 971, 1019, 1019, 1047], [1048, 1132, 1168, 1168, 1213], [1215, 1280, 1314, 1314, 1412], [1413, 1413, 1447, 1447, 1539], [1540, 1540, 1574, 1574, 1666], [1667, 1707, 1741, 1741, 1838], [1840, 1938, 1980, 1980, 2604], [2606, 2606, 2658, 2658, 2746], [2747, 2786, 2822, 2822, 2905], [2908, 2927, 2950, 2950, 3090], [3092, 3092, 3121, 3121, 3211], [3213, 3213, 3242, 3242, 3902], [3907, 3947, 3972, 3972, 4725], [4727, 4778, 4802, 4802, 4990], [4993, 4993, 5042, 5042, 5688], [5689, 5743, 5779, 5779, 6026], [6147, 6147, 6174, 6174, 6191], [6193, 6193, 6229, 6229, 6321], [6322, 6322, 6368, 6368, 6513], [6515, 6515, 6589, 6589, 8009], [8010, 8108, 8188, 8188, 8320], [8321, 8362, 8389, 8389, 8499], [8501, 8501, 8533, 8533, 8729], [8731, 8779, 8807, 8807, 8997], [8999, 9050, 9097, 9097, 9755], [9810, 9810, 9903, 9903, 10247], [10249, 10249, 10280, 10280, 10974], [10976, 11025, 11051, 11051, 11225], [11227, 11227, 11285, 11285, 11337], [11339, 11388, 11445, 11445, 12136]]}
{"id": "ss2Szm", "name": "Sunday Threads", "author": "mrange", "description": "License CC0: Sunday threads\nResult after a bit of random coding on sunday afternoon\n", "tags": ["3d", "raymarching"], "likes": 33, "viewed": 787, "published": 3, "date": "1619960548", "time_retrieved": "2024-07-30T19:22:14.458351", "image_code": "// License CC0: Sunday threads\n// Result after a bit of random coding on sunday afternoon\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(a)         (0.5+0.5*cos(a))\n\n#define TOLERANCE       0.00001\n#define MAX_RAY_LENGTH  10.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.001\n\n#define PATHA vec2(0.1147, 0.2093)\n#define PATHB vec2(13.0, 3.0)\n\nconst mat2 rot0             = ROT(0.0);\nconst vec3 std_gamma        = vec3(2.2);\n\nmat2  g_rot  = rot0;\nfloat g_hit  = 0.0;\n\nfloat hash(float x) {\n  return fract(sin(x*12.9898) * 13758.5453);\n}\n\n// From https://www.shadertoy.com/view/XdcfR8\nvec3 cam_path(float z) {\n  return vec3(sin(z*PATHA)*PATHB, z);\n}\n\nvec3 dcam_path(float z) {\n  return vec3(PATHA*PATHB*cos(PATHA*z), 1.0);\n}\n\nvec3 ddcam_path(float z) {\n  return vec3(-PATHA*PATHA*PATHB*sin(PATHA*z), 0.0);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// From: http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// From: https://stackoverflow.com/a/17897228/418488\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat df(vec3 p) {\n  vec3 cam = cam_path(p.z);\n  vec3 dcam = normalize(dcam_path(p.z));\n  p.xy -= cam.xy;\n  p -= dcam*dot(vec3(p.xy, 0), dcam)*0.5*vec3(1,1,-1);\n\n  float dc = length(p.xy) - 0.5;\n  vec2 p2 = p.xy;\n  mat2 rr = ROT(p.z*0.5);\n  p2      *= rr;\n  rr      *= g_rot;\n  \n  float d = 1E6;\n\n  const float ss = 0.45;\n  const float oo = 0.125;\n  float s = 1.0;\n\n  vec2 np = mod2(p2, vec2(0.75));\n  float hit = 0.0;\n  float qs  = 0.5; \n  const int max_iter = 3;\n  for (int i = 0; i < max_iter; ++i) {\n    vec2 sp2 = sign(p2);\n    hit += qs*(3.0 + sp2.x + 2.0*sp2.y)/8.0;\n    p2 = abs(p2);\n    p2 -= oo*s;\n    float dp = length(p2) - 0.75*ss*oo*s;\n//    d = max(d, -(dp-0.1*s));\n    if (dp < d) {\n      d = dp;\n      g_hit = hit+np.x+10.0*np.y;\n    }\n    s  *= ss;\n    rr  = transpose(rr);\n    p2 *= rr;\n    qs *= 0.5;\n  }\n  return max(d, -dc);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int iter) {\n  float t = 0.0;\n  int i = 0;\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += d;\n  }\n  iter = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat softShadow(vec3 pos, vec3 ld, float ll, float mint, float k) {\n  const float minShadow = 0.25;\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<24; i++) {\n    float d = df(pos + ld*t);\n    res = min(res, k*d/t);\n    if (ll <= t) break;\n    if(res <= minShadow) break;\n    t += max(mint*0.2, d);\n  }\n  return clamp(res,minShadow,1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 lightPos = cam_path(ro.z+0.85);\n  float alpha   = 0.05*TIME;\n  \n  const vec3 skyCol = vec3(0.0);\n\n  int iter    = 0;\n  g_hit       = 0.0;\n  float t     = rayMarch(ro, rd, iter);\n  float hit   = g_hit;\n  float r     = hash(hit+123.4);\n\n  if (t >= MAX_RAY_LENGTH) {\n    return vec3(0.0);\n  }\n\n  vec3 pos    = ro + t*rd;\n  vec3 nor    = normal(pos);\n  vec3 refl   = reflect(rd, nor);\n\n  float ifade= 1.0-tanh_approx(1.25*float(iter)/float(MAX_RAY_MARCHES));\n  float aa   = 10.0*pos.z-6.0*TIME*fract(113.0*r);\n  float band = smoothstep(0.9, 0.92, PCOS(aa));\n  vec3 hsv   = (vec3(fract(-0.25+0.25*r+0.025*pos.z), (1.0-ifade), mix(0.125, 2.0, band)));\n  vec3 color = hsv2rgb(hsv);\n\n  vec3 lv   = lightPos - pos;\n  float ll2 = dot(lv, lv);\n  float ll  = sqrt(ll2);\n  vec3 ld   = lv / ll;\n  float sha = softShadow(pos, ld, ll*0.95, 0.01, 16.0);\n\n  float dm  = .5/ll2;\n  float dif = max(dot(nor,ld),0.0)*(dm+0.05);\n  float spe = pow(max(dot(refl, ld), 0.), 20.);\n  float l   = dif*sha;\n\n  vec3 col = l*color + spe*sha;\n\n  return col*ifade;\n}\n\nvec3 effect3d(vec2 p, vec2 q) {\n  float z   = TIME;\n  g_rot     = ROT(0.25*TIME); \n  vec3 cam  = cam_path(z);\n  vec3 dcam = dcam_path(z);\n  vec3 ddcam= ddcam_path(z);\n  \n  vec3 ro = cam;\n  vec3 ww = normalize(dcam);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+ddcam*2.0, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  return render(ro, rd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect3d(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2Szm.jpg", "access": "api", "license": "cc0-1.0", "functions": [[639, 639, 660, 660, 707], [709, 755, 779, 779, 819], [821, 821, 846, 846, 894], [896, 896, 922, 922, 977], [979, 979, 1007, 1027, 1103], [1105, 1142, 1178, 1178, 1272], [1274, 1327, 1349, 1349, 1518], [1520, 1520, 1556, 1556, 1789], [1791, 1791, 1809, 1809, 2639], [2641, 2641, 2689, 2689, 2884], [2886, 2886, 2909, 2909, 3117], [3119, 3119, 3187, 3187, 3466], [3468, 3468, 3499, 3499, 4539], [4541, 4541, 4572, 4572, 4936], [4938, 4938, 4993, 4993, 5183]]}
{"id": "7s2Szw", "name": "ReactionDiffusion - MIPmap Lapl", "author": "FabriceNeyret2", "description": "mouse paint.  Use plugin to accelerate x16.\n\nsimplifes aiekick RD [url]https://shadertoy.com/view/MlByzR[/url] using MIPmap LOD to compute Laplacian  ( + other things, but far from golfed ;-) )\nTry changing Laplacian width in Common ( default = 1. = LOD )", "tags": ["diffusion", "3", "reaction", "gpmipmap"], "likes": 20, "viewed": 660, "published": 3, "date": "1619946042", "time_retrieved": "2024-07-30T19:22:15.328026", "image_code": "// simplified version of \"ReactionDiffusion 3\" by aiekick. https://shadertoy.com/view/MlByzR\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n   \n    float c = T().g, c2;\n    U--; c2 = T().g;               // c2 = offseted state for lighting\n \n    O =   c*c*1.5\n        + vec4(.2, .4, 1, 0) * max(c2*c2*c2 - c*c*c, 0.)*R.y*.2;  // Shane lighting model\n    O = sqrt(O);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2  diffusionCoef = vec2(1,.3);\nfloat feedCoef = .05,\n      killCoef = .062;\n      \nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = T();                                     // previous state\n    float l;\n   \tif (iFrame < 1)\n        l =  length(U+U-R)/R.y,                  // init\n        O.rg = vec2( l, 1.-l );\n\n    else if (iMouse.z > 0.)\t{                    // mouse paint\n        l = length(U-iMouse.xy)/R.y;\n        if ( l < .05 ) O.rg = vec2( l, 1.-l ); \n\t}\n    else {                                       // simulates reaction - diffusion\n        float feed =   feedCoef * (1. - O.x),\n              kill = ( feedCoef + killCoef ) * O.y,\n              reaction = O.x * O.y * O.y;\n        vec2 diffusion = diffusionCoef  *  lapl.rg;\n\n        O.rg += diffusion + vec2( feed - reaction, reaction - kill );\n     // O = clamp(O,0.,10.);\n    }\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R       iResolution.xy\n#define T(l)    texture( iChannel0, U/R, l+0. )\n#define lapl    9./8.* ( T(1.) - T(0.) )         // approx Laplacian using MIPmap LOD difference\n                                                 // 9/8 because T(1) includes a bit of T(0) ;-)\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2Szw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 132, 132, 361]]}
{"id": "NdjXzw", "name": "mirascope", "author": "elenzil", "description": "@oneshade's recent parabola stuff made me wonder if a working MiraScope was possible.\nThis was previously done by @benburrill [url]https://www.shadertoy.com/view/wtKGzd[/url] , that I could find.\nUL: Cross-eyed stereo.\nLL: Cut-Away.\nR: Matte interior.", "tags": ["illusion", "mirror", "parabolic", "mirascope"], "likes": 10, "viewed": 362, "published": 3, "date": "1619938337", "time_retrieved": "2024-07-30T19:22:16.351290", "image_code": "// @oneshade's recent parabola stuff made me wonder if a working MiraScope was possible.\n// This was previously done by @benburrill [url]https://www.shadertoy.com/view/wtKGzd[/url] , that I could find.\n// UL: Cross-eyed stereo.\n// LL: Cut-Away.\n// R: Matte interior.\n\n\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\nbool gDemoView  = false;\nbool gDebugView = false;\nmat2 gSceneRot  = mat2(1.0, 0.0, 0.0, 1.0);\nconst float gutter = 0.175;\nconst float gutterInv = 1.0 - gutter;\n\n// positive for cross-eyed, make negative for wall-eyed viewing.\nconst float stereoSeparation = 0.4;\n\nstruct pol3 {\n    float rho;\n    float tht;\n    float phi;\n};\n\npol3 sphericalFromCartesian(in vec3 cartesian) {\n    pol3 ret;\n\n    ret.tht = atan(cartesian.z, cartesian.x);\n    ret.phi = acos(dot(normalize(cartesian), vec3(0.0, 1.0, 0.0))) - PI/2.0;\n    ret.rho = length(cartesian);\n\n    return ret;\n}\n\nfloat maxPart(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\n//--------------------------------------------------------------------------------\n\n// I forget the location, but this pattern is from IQ.\n\nvec2 opUnion(in vec2 q1, in vec2 q2) {\n    return q1.x < q2.x ? q1 : q2;\n}\n\nvec2 opSubtraction(in vec2 q1, in vec2 q2) {\n    return -q1.x > q2.x ? vec2(-q1.x, q1.y) : q2;\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n//--------------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, float r )\n{\n  return length(p.xz) - r;\n}\n\nfloat sdCappedCylinderPrecomputedQ(vec2 q, float h, float r)\n{\n  vec2 d = abs(q) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCrateBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdParabola( in vec2 pos, in float k )\n{\n    pos.x = abs(pos.x);\n    \n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    \n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n\n    float x = (h>0.0) ? \n        // 1 root\n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        // 3 roots\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    \n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat sdSphere( in vec3 pos, in float r ) {\n    return length(pos) - r;\n}\n\n\nfloat sdMiraScope(in vec3 pos, in float separation, in float thickness, in float holeRadius) {\n    // convert pos to 2D by revolving it around Y\n    vec2 p = vec2(length(pos.xz), pos.y);\n\n    // an up and down facing parabola, a little apart\n    float sdTop = sdParabola(vec2(p.x, p.y + separation),  0.5);\n    float sdBot = sdParabola(vec2(p.x, p.y - separation), -0.5);\n\n    // intersected\n    float sdMira = max(sdTop, sdBot);\n\n    // onioned\n    sdMira = abs(sdMira) - thickness;\n\n    // slice off the top so we can see inside!\n    // sdMira = max(sdMira, p.y - separation * 0.9);\n    \n    // cut a hole in the top so we can see inside!\n    // this has somewhat less visibility into the interior compared to slicing,\n    // but avoids long thin wedges.\n    sdMira = opSubtraction(sdCappedCylinderPrecomputedQ(vec2(p.x, p.y - separation + thickness), holeRadius, separation * 0.2 + thickness * 3.0), sdMira);\n\n    return sdMira;\n}\n\n//-----------------------------------------------------------------------\n\n\n// set up scene position of stuff once per pixel\nconst float gMiraThickness = 0.01;\nconst float gMiraSep       = 0.3;\n      float gMiraHole      = 0.3;\nconst float gTableThick    = 0.01;\n\n\nvec3 gPosMira;\nvec3 gPosColumn;\nvec3 gPosCrate;\nvec3 gCrateSize;\nvec3 gPosTable;\n\nvoid configMap() {\n    const float columnDist = 0.565;\n    const float crateSize = 0.07;\n    const float crateLift = 0.014;\n \n    gPosMira   = vec3(0.0);\n    gPosColumn = vec3(columnDist, -0.22, columnDist);\n    gPosCrate  = vec3(0.0, -gMiraSep + crateSize + gMiraThickness + crateLift, 0.0);\n    gCrateSize = vec3(crateSize);\n    \n    gPosTable  = vec3(0.0, - gMiraSep - gMiraThickness - gTableThick - 0.1, 0.0);\n}\n\n// return.x = distance\n// return.y = material\nvec2 map(in vec3 p) {\n\n    p.xz *= gSceneRot;\n\n    vec2 Q = vec2(1e9, 0.0);\n\n    // mirascope\n    Q = opUnion(Q, vec2(sdMiraScope(p - gPosMira, gMiraSep, gMiraThickness, gMiraHole), 1.0)) ;\n\n    // 4 colums\n    vec3 pAbs = vec3(abs(p.xz), p.y).xzy;\n    Q = opUnion(Q, vec2(sdCappedCylinder(pAbs - gPosColumn, 0.03, 0.4), 3.0));\n    \n    if (gDebugView) {\n        // slice off half the mirascope + columns\n        Q = opSubtraction(vec2(p.z, 2), Q);\n    }\n\n    Q = opUnion(Q, vec2(sdCrateBox(p - gPosCrate, vec3(gCrateSize), 0.0) - 0.01, 4.0));\n    Q = opUnion(Q, vec2(sdCappedCylinder(p    -       gPosTable, 0.9, gTableThick), 3.0));    \n\n    return Q;\n}\n\nconst float closeEps = 0.001;\n\nvec2 march(in vec3 ro, in vec3 rd) {\n    const int maxSteps = 100;\n\n    vec2 Q = vec2(1e9);\n\n    vec3 p = ro;\n    float t = 0.0;\n    for (int n = 1; n <= maxSteps; ++n) {\n        Q = map(ro + rd * t);\n        float closeEnoughEps = (n == maxSteps ? 0.2 : closeEps);\n        if (Q.x < closeEnoughEps) {\n            return vec2(t, Q.y);\n        }\n        t += Q.x;\n        if (t > 200.0) {\n            return vec2(t, Q.y);\n        }\n    }\n    return vec2(t, Q.y);\n}\n\n\n// IQ: https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.002;      // replace by an appropriate value\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * map(p + e*h).x;\n    }\n    return normalize(n);\n}\n\nvec3 lightDirection = normalize(vec3(1.0, -4.0, -0.5));\n\nfloat calcDiffuseAmount(in vec3 p, in vec3 n) {\n    return clamp(dot(n, -lightDirection), 0.0, 1.0);\n}\n\nconst float AOFactorMin = 0.5;\nconst float AOFactorMax = 1.0;\nfloat calcAOFactor(in vec3 p, in vec3 n) {\n    const float sampleDist = 0.03;\n    float dist = smoothstep(0.0, sampleDist, map(p + n * sampleDist).x);\n    return mix(AOFactorMin, AOFactorMax, (dist));\n}\n\nfloat calcShadowLight(in vec3 p) {\n    float t = march(p - lightDirection * 0.01, -lightDirection).x;\n    return t > 40.0 ? 1.0 : 0.0;\n}\n\nconst vec3 albedo1 = vec3(0.0, 0.6, 1.0);\nconst vec3 albedo2 = vec3(0.7, 0.2, 0.3);\nconst vec3 albedo3 = vec3(0.5, 0.1, 0.2);\nconst vec3 albedo4 = vec3(1.0, 1.0, 0.2);\nconst vec3 albedo5 = vec3(1.0, 0.2, 0.2);\n\nvec3 dirToRGB(in vec3 rd) {\n    float tht = atan(rd.z, rd.x);\n    float phi = acos(dot(normalize(rd), vec3(0.0, 1.0, 0.0)));\n    vec3 col = rd * 0.5 + 0.5;\n    col *= smoothstep(0.002, -0.002, sin(tht       * 4.0)) * -0.3 + 1.0;\n    col *= smoothstep(0.002, -0.002, sin(phi * 2.0 * 4.0)) * -0.3 + 1.0;\n    col = mix(col, col / max(col.r, max(col.g, col.b)), 0.2);\n    return col;\n}\n\nvec3 sky(in vec3 rd) {\n    vec3 col = normalize(dirToRGB(rd));\n    col *= rd.y < 0.0 ? 0.5 : 1.0;\n    col = col * 0.1 + 0.1;\n    return col;\n}\n\nvec3 getAlbedo(in int material, in vec3 pCrt, in pol3 pPol) {\n    if (material == 1 || material == 2) {\n        float th = mod((pPol.tht + 0.5 + pPol.rho * 7.0 * sign(pCrt.y)) * 5.0, PI * 2.0) / 5.0 - 0.5;\n        float rh = mod((pPol.rho * 5.0 + 1.15), 1.0) - 0.5;\n        float x = length(vec2(th, rh) * 5.0) - 2.0;\n        float c = smoothstep(0.17, 0.0, x);\n        c = c * 0.2 + 0.1;\n\n        vec3 rgb1 = vec3(0.2);\n        vec3 rgb2 = vec3(1.0, 0.9, 0.8) * c;\n        \n        if (material == 2) {\n            return rgb2;\n        }\n        else {\n            if (gDemoView) {\n                return mix(rgb1, rgb2, smoothstep(-0.4, 0.4, sin(gTime * 2.0)));\n            }\n            else {\n                return rgb2;\n            }\n        }\n    }\n    else if (material == 3) {\n        return vec3(0.2);\n    }\n    else if (material == 4) {\n        vec3 rgb = dirToRGB(normalize(pCrt - gPosCrate));\n        rgb /= length(rgb);\n        return rgb;\n    }\n    else {\n        return vec3(1e9, 0.0, 1e9);\n    }\n}\n\nvec3 getReflectivity(in int material, in vec3 pCrt, in pol3 pPol) {\n    if (material == 1) {\n        vec3 rgb = vec3(0.9);\n        if (gDemoView) {\n            return mix(rgb, vec3(0.0), smoothstep(-0.4, 0.4, sin(gTime)));\n        }\n        else {\n            return rgb;\n        }\n    }\n    else if (material == 2) {\n        return vec3(0.0);\n    }\n    else if (material == 3) {\n        return vec3(0.2);\n    }\n    else if (material == 4) {\n        return vec3(0.2);\n    }\n    else {\n        return vec3(0.0, 1e9, 0.0);\n    }\n}\n\nvec3 getEmissive(in int material, in vec3 pCrt, in pol3 pPol) {\n    return vec3(0.0);\n}\n\n\n//------------------------------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3 rgb = vec3(0.0);\n\n    int bouncesLeft = 20;\n\n    vec3 contributionLeft = vec3(1.0);\n\n    while (bouncesLeft >= 0 && maxPart(contributionLeft) > 0.001) {\n        bouncesLeft -= 1;\n        vec2 q = march(ro, rd);\n        vec3 p = ro + q.x * rd;\n        if (length(p) > 150.0) {\n            rgb += sky(rd) * contributionLeft;\n            break;\n        }\n\n        vec3 normal = calcNormal(p);\n\n        vec3 ptCrt = p;\n        ptCrt.xz *= gSceneRot;\n        pol3 ptSph = sphericalFromCartesian(ptCrt);\n\n        int material = int(q.y);\n\n        // distinguish inside and outside of mirascope\n        if (material == 1) {\n            if (dot(p, normal) > 0.0 || abs(normal.y) < 0.7) {\n                material = 2;\n            }\n        }\n\n        float incomingLight = 1.0;\n        incomingLight = min(incomingLight, calcDiffuseAmount(p, normal));\n        if (incomingLight > 0.0) {\n            incomingLight = min(incomingLight, calcShadowLight(p));\n        }\n        float ambient = 0.2 * calcAOFactor(p, normal);\n        incomingLight += ambient;\n\n        float fres = 0.4 + 0.8 * clamp(pow(1.0 - abs(dot(rd, normal) - 0.1), 2.0), 0.0, 1.0);\n        \n        fres = 1.0;\n\n        vec3 reflectivity = fres * getReflectivity(material, ptCrt, ptSph);\n        vec3 diffuse = incomingLight * getAlbedo(material, ptCrt, ptSph);\n        vec3 emissive = getEmissive(material, ptCrt, ptSph);\n        \n        rgb += diffuse * (1.0 - reflectivity) * contributionLeft;\n        rgb += emissive * contributionLeft;\n        contributionLeft *= reflectivity;\n          \n        ro = p + normal * 0.05;\n        rd = reflect(rd, normal);\n    }\n\n    return rgb;\n}\n\n\nvoid mainImage( out vec4 RGBA, in vec2 XY ) {\n    vec4 persistedInfo = texelFetch(iChannel0, ivec2(0, 0), 0);\n    \n    bool stereo = iMouse.x < iResolution.x * gutter && iMouse.y > iResolution.y * gutterInv;\n    bool leftEye = XY.x > iResolution.x / 2.0;\n    \n    vec2 Res = iResolution.xy;\n    Res.x   *= stereo ? 0.5 : 1.0;\n    XY.x    -= (stereo && leftEye) ? iResolution.x / 2.0 : 0.0;\n\n    setupCoords(Res, 4.2);\n    setupTime(persistedInfo[2]);\n    vec2  uv        = worldFromScreen(XY);\n    vec2  ms        = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    float smoothEps = gWorldFromScreenFac * 2.0;\n\n    // look-from and look-to points\n    // right-handed system where x is right, y is up, z is forward.\n    float t = gTime * 0.23;\n    vec3 trgPt = vec3(0.0, -0.2, 0.0);\n    \n    float camTheta = -ms.x * PI * 1.25;\n    float camAlttd = sin(t * 0.32) * 0.2 - (ms.y - 0.9) * 3.0;\n    \n    bool defaultView = stereo || length(iMouse.xy) < 1.0;\n    gDebugView      = !defaultView && (length(iMouse.xy) < iResolution.x * gutter);\n    if (gDebugView) {\n        camTheta = sin(iTime * 0.10) * 0.1;\n        camAlttd = sin(iTime * 0.12) * 0.1;\n    }\n    else if (defaultView) {\n        camAlttd = mix(10.0, 0.9, smoothstep(0.0, 8.0, gTime));\n    }\n    \n    gDemoView = gDebugView || iMouse.x > iResolution.x * gutterInv;\n    \n    vec3 camPt = vec3(sin(camTheta), camAlttd, cos(camTheta)) * (gDebugView ? 1.7 : 4.0);\n    \n    // camera's forward, right, and up vectors. right-handed.\n    vec3 camFw = normalize(trgPt - camPt);\n    vec3 camRt = cross(camFw, vec3(0.0, 1.0, 0.0));\n    vec3 camUp = cross(camRt, camFw);\n    \n    bool AA = !false;\n    int AAM = AA ? 3 : 1;\n    float AAdelt[3] = float[3](0.0, -0.3, 0.3);\n    float aaAccum = 0.0;\n\n    if (stereo) {\n        camPt += camRt * (leftEye ? -1.0 : 1.0) * stereoSeparation / 2.0;\n        camFw = normalize(trgPt - camPt);\n        camRt = cross(camFw, vec3(0.0, 1.0, 0.0));\n        camUp = cross(camRt, camFw);\n    }\n    \n    gSceneRot = rot2(gTime * PI * 2.0 / 30.0);\n    configMap();\n    \n    vec3 rgb = vec3(0.0);\n    \n    for (int aaN = 0; aaN < AAM; ++aaN) {\n    for (int aaM = 0; aaM < AAM; ++aaM) {\n\n        // ray origin and direction\n        float uvx  = uv.x - AAdelt[aaN] * gWorldFromScreenFac;\n        float uvy  = uv.y - AAdelt[aaM] * gWorldFromScreenFac;\n        vec3 ro    = camPt;\n        vec3 rd    = normalize(camFw + uvx * camRt + uvy * camUp);\n\n        rgb += render(ro, rd);\n        aaAccum += 1.0;\n    }}\n    \n    rgb /= aaAccum;\n\n\n    // Vignette from Ippokratis https://www.shadertoy.com/view/lsKSWR\n\tvec2 pq = XY / Res;   \n    pq *=  1.0 - pq.yx;    \n    float vig = pq.x*pq.y * 200.0;    \n    vig = pow(vig, 0.15);\n    rgb *= vig;\n\n    rgb = sqrt(rgb);\n\n    RGBA = vec4(rgb, 1.0);\n}\n\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#ifdef GRIMOIRE\n#include <common.glsl>\n#endif\n\n// This buffer just does mouse filtering\n\n// 0, 0:\n// [0] = is mouse down\n// [1] = is time frozen\n// [2] = current time\n// [3] = timescale\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n\n    RGBA = texelFetch(iChannel0, IJ, 0);\n\n    if (iFrame == 0 || IJ.x != 0 || IJ.y != 0) {\n        RGBA = vec4(0.0, 0.0, iTime, 1.0);\n        return;\n    }\n\n    bool  mouseWasDown = RGBA[0] == 1.0;\n    bool  timeIsFrozen = RGBA[1] == 1.0;\n    float time         = RGBA[2];\n    float timeScale    = RGBA[3];\n\n    bool mouseIsDown = iMouse.z > 0.0;\n\n    timeIsFrozen = timeIsFrozen ^^ (!mouseIsDown && mouseWasDown);\n    \n    timeIsFrozen = mouseIsDown;\n\n    timeScale = clamp(timeScale + (timeIsFrozen ? -0.01 : 0.01) * 60.0 / iFrameRate, 0.0, 1.0);\n    time += iTimeDelta * timeScale;\n\n    RGBA[0] = mouseIsDown  ? 1.0 : 0.0;\n    RGBA[1] = timeIsFrozen ? 1.0 : 0.0;\n    RGBA[2] = time;\n    RGBA[3] = timeScale;\n\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// Fork of \"boilerplate stuff\" by elenzil. https://shadertoy.com/view/7dX3R2\n// 2021-04-05 18:18:15\n\nconst float PI  = 3.14159265359;\nconst float TAO = PI * 2.0;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\n\n\n// to prevent loop-unrolling\n#define ZERO (min(0, int(iFrame)))\n\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\nmat2 rot2(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[642, 642, 690, 690, 880], [882, 882, 905, 905, 943], [1085, 1085, 1123, 1123, 1159], [1161, 1161, 1205, 1205, 1257], [1259, 1259, 1296, 1296, 1317], [1319, 1319, 1362, 1362, 1384], [1386, 1386, 1430, 1430, 1451], [1537, 1586, 1638, 1638, 1745], [1747, 1747, 1784, 1784, 1813], [1815, 1815, 1877, 1877, 1963], [1965, 2014, 2059, 2059, 2346], [2350, 2399, 2444, 2444, 2851], [2853, 2853, 2896, 2896, 2926], [2929, 2929, 3023, 3073, 3862], [4211, 4211, 4229, 4229, 4626], [4628, 4674, 4695, 4695, 5329], [5362, 5362, 5398, 5398, 5825], [5828, 5878, 5929, 5929, 6197], [6256, 6256, 6303, 6303, 6358], [6422, 6422, 6464, 6464, 6624], [6626, 6626, 6660, 6660, 6762], [6975, 6975, 7002, 7002, 7356], [7358, 7358, 7380, 7380, 7500], [7502, 7502, 7563, 7563, 8516], [8518, 8518, 8585, 8585, 9046], [9048, 9048, 9111, 9111, 9135], [9220, 9220, 9257, 9257, 10911], [10914, 10914, 10959, 10959, 13674]]}
{"id": "sslSR7", "name": "Santraginus V", "author": "Chaotnix", "description": "This is based on Fractal 51_gaz by gaz\n\n“You can lie on the brilliant marble-sanded beaches of Santraginus V, inhaling the heady sea vapours”\n— The Hitchhiker's Guide to the Galaxy", "tags": ["fractal", "audioreactive", "soundcloud"], "likes": 2, "viewed": 354, "published": 3, "date": "1619919448", "time_retrieved": "2024-07-30T19:22:17.103279", "image_code": "//This shader is based on Fractal 51_gaz by gaz\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nvoid mainImage(out vec4 fragColor,  in vec2 fragCoord)\n{\n    vec4 O=vec4(0);\n\tvec2 C = fragCoord;\n    vec3 p,r=iResolution,\n    d=normalize(vec3((C-.7*r.xy)/r.y,1));  \n    for(float i=0.,s,e,g=0.;\n        ++i<40.;\n        O.xyz+=mix(vec3(1),H(log(s)*.45),.3)*.03*exp(-.2*i*i*e) \n    )\n    {\n        p=g*d +( .005 * texture(iChannel0,O.xy).xy,7.);// vec3(0,0,.5);\n        //p+= .001 * texture(iChannel0, vec2(length(C),.3) ).x;\n        p=R(p.zxy,normalize(vec3(0.2,0.4,0.9)),iTime*.03);\n        s=2.;\n        for(int i;i++<6;)\n            p=abs(p-vec3(1,2.8,1.5+sin(0.1 * clamp(texture(iChannel0, vec2(length(C),.3) ).x,0.3,.5)-g*.1)*.04))-vec3(1,3.+sin(iTime*.7)*.3,2.1),\n            p*=(fract(iTime*.5)>1.)?-1.:1.,\n            s*=e=7./clamp(dot(p,p),1.2,7.),\n            p*=e;\n            p+= clamp(texture(iChannel0, vec2(length(O),.8) ).y,0.1,1.) * .5, 5.;\n        g+=e=min(abs(p.z),length(p.xy)-.05)/s+1e-3;\n    }\n    \n \n     vec4 cTexture1 = texture(iChannel1,p.xy);\n     vec4 cTexture2 = texture(iChannel2,p.xy);\n     vec4 cTexture = mix(cTexture1, cTexture2, .7);\n//     fragColor -= .5 * O - cTexture;\n//     fragColor =  (.70 + O) - (1. - 0.5 * cTexture) ;\n//     fragColor = mix( 0.7 * O , cTexture, .25);\n//     fragColor = max( 0.7 * O , 0.3 * cTexture);\n\n    vec2 p1 = fragCoord.xy / iResolution.xy ;\n\tp1.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 col = vec3(0);\n    int tx = int(p1.x*200.0);\n    float wave = sin(texelFetch( iChannel0, ivec2(tx,1), 0 ).x);\n    col += .2 -  0.5 * smoothstep( 0.0, 0.15, abs(wave - p1.y) );\n        \n\n    fragColor =   vec4(col, 1.0)*0.3 + .7 + O - (1. - 0.2 * cTexture);\n  \n\n}    ", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26942, "src": "https://soundcloud.com/psychedelic-trance/goa-gil-deep-trance", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p1 = 2.0*( fragCoord.xy / iResolution.xy ) -1.0;\n\tp1.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 col = vec3(0);\n\tfloat t = 0.0;\n\tvec2 op = p1;\n\tfor (int i = 0; i < 50; i++) {\n\t\t// blackle's asin trick\n\t\tp1 += 0.5*asin(sin(vec2(iTime+t,0.5454*(iTime+t)))); \n\t\tif (length(p1) < 0.01) col = vec3(0,1,1);\n\t\tt += 0.1;\n\t\tp1 = op;\n\t}\n\tfragColor = vec4(col, 1.0);\n\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sslSR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[155, 155, 211, 211, 1777]]}
{"id": "fd2Xzw", "name": "Box of swirls", "author": "michael0884", "description": "Due to the limited number of sorting steps you can do on shadertoy per frame, this is kinda slow, but the frametimes should be super small. In a perfect world the buffer B would be repeated N times. If you have the shadertoy plugin just use 64 paint calls", "tags": ["raster"], "likes": 13, "viewed": 444, "published": 3, "date": "1619914081", "time_retrieved": "2024-07-30T19:22:18.029802", "image_code": "//SHOW\n\nbool isKeyToggled(int KEY)\n{\n\treturn texelFetch( iChannel1, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    if(isKeyToggled(KEY_SPACE))\n    {\n        vec4 col = texelFetch(iChannel0, ivec2(p), 0);\n        float k = float(pixelID(col.xy))/pixelnum;\n        \n        c = vec4(k);\n    }\n    else\n    {\n       \n            vec4 col = texelFetch(iChannel2, ivec2(p), 0);\n            float exposure = 1. - (iMouse.x/R.x);\n            c = tanh(2.0*col/col.w);\n        \n    }\n   \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define TWO_PI 6.28318530718\n\n//#define REAL_TIME\n\n#ifdef REAL_TIME\n    #define IFRAME 0\n    #define SPEED 0.1\n#else\n    #define IFRAME iFrame\n    #define SPEED 0.0\n    #define ACCUMULATION\n#endif\n\n\n#define FOV 1.0\nvec2 R;\nint sort_iters;\nfloat pixelnum;\n\nvec2 toScreen(vec2 p)\n{\n    return 0.8*p*R.y + R*0.5;\n}\n\nbool onScreen(vec2 p)\n{\n    return all(greaterThan(p, vec2(0))) && all(greaterThan(R,p));\n}\n\nint pixelID(vec2 pix)\n{\n    return int(pix.x) + int(pix.y)*int(R.x);\n}\n\nivec2 pixel(int pid)\n{\n    return ivec2(pid%int(R.x), pid/int(R.x));\n}\n\n//thanks rory618 (https://www.shadertoy.com/view/WssfDn) for this incredible magic function\nint getPartner(int x, int s){\n    float j = floor(sqrt(float(2*s)+1.25)-0.5);\t\t//Major stage\n    float n = floor(float(s) - 0.5*(j*j+j) + 0.5);\t//Minor stage\n    float b = floor(exp2(j-n+1.)+0.5);\t\t\t\t//Block size\n    float bot = floor(float(x)/b)*b;\t\t\t\t//Bottom index in block \n    float top = bot + b - 1.;\t\t\t\t\t\t//Top index in block\n    if(n<0.5){\t\t\t\t\t\t\t\t\t\t//Swap with opposite index in block\n        return int(top - (float(x)-bot) + 0.5);\n    }else{\t\t\t\t\t\t\t\t\t\t\t//Swap with index a constant distance away in block\n        if(float(x)-bot < b/2.-0.5){\n            return int(float(x) + b/2. + 0.5);\n        }else{\n            return int(float(x) - b/2. + 0.5);\n        }\n    }\n}\n\n\n//internal RNG state \nuvec4 s0; \n\nvoid initialize(inout vec2 p, int frame, vec3 res)\n{\n    p = floor(p);\n    \n    R = res.xy;\n    pixelnum = R.x*R.y;\n    float lg2 = ceil(log2(pixelnum));\n    sort_iters = 3*int(ceil(lg2*(lg2 + 1.0)/6.0) + 1.0);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec2 cmul(vec2 x, vec2 y)\n{\n    return vec2(x.x*y.x - x.y*y.y, x.x*y.y + x.y*y.x);\n}\n\nvec2 disk()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nconst int max_iterations = 256;\nconst vec4 color_threshholds = vec4(255,130,80,255);\n\nvec4 buddhabrot(int iters)\n{\n    vec3 z = vec3(0.01);\n    vec3 c = (rand3() - 0.5)*1.5 + vec3(0.0, 0.0, 0.0);\n\n\n    int i = 0;\n   \tfor(; i<iters; i++ )\n    {\n        float r = length(z);\n        float b = 2.0*acos( z.y/r);\n        float a = 2.0*atan( z.x, z.z );\n        z = c + pow(r,2.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n\t\tif(length(z) > 4.0 )\n            break;\n    }\n    \n    if(i >= iters) return vec4(1e5);\n    \n    int maxj = int(rand()*1000.0)%i;\n    \n    z = vec3(0.01);\n    \n    for(int j = 0; j <= maxj; j++)\n    {\n        float r = length(z);\n        float b = 3.0*acos( z.y/r);\n        float a = 3.0*atan( z.x, z.z );\n        z = c + pow(r,3.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n    }\n    \n    return vec4(z, i);\n    \n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\nmat3 get_cam(vec2 ang)\n{\n    vec3 x_dir = vec3(cos(ang.x)*sin(ang.y), cos(ang.y), sin(ang.x)*sin(ang.y));\n    vec3 y_dir = normalize(cross(x_dir, vec3(0,1,0)));\n    vec3 z_dir = normalize(cross(y_dir, x_dir));\n    return mat3(-x_dir, y_dir, z_dir);\n}\n\n//project to clip space\nvec3 project(mat3 cam_mat, vec3 cam_pos, vec3 p)\n{\n    float td = distance(cam_pos, p);\n    float zd = dot(cam_mat[0],p - cam_pos);\n    vec3 dir = (p - cam_pos)/td;\n    vec3 screen = vec3(dot(cam_mat[0],dir),dot(cam_mat[1],dir),dot(cam_mat[2],dir));\n    return vec3(screen.yz*R.y/(FOV*screen.x) + 0.5*R.xy,zd);\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_BSPACE = 8;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n", "buffer_b_code": "//BITONIC SORT\n\nvec3 sbf(vec3 c, vec3 w, float s){\n    vec3 k = sin(PI*c*w) * cos(PI*c.yzx*w.yzx) * cos(PI*c.zxy*w.zxy);\n    k = mix(k, k* cross(normalize(w), normalize(vec3(2,4,1))), s);\n    return k;\n}\n\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, IFRAME, iResolution);\n    \n    int sort_iter = 3*iFrame + 0;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters - 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n  \n    \n    if(sort_iter%sort_iters == 0) //intialize with some random points, in this case pseudo caustic\n    {\n        vec2 ang = vec2(TWO_PI, PI)*iMouse.xy/R + vec2(0.4);\n        mat3 cam = get_cam(ang);\n        \n        vec3 campos = -cam*vec3(0.75,0,0);\n    \n        vec4 bp = vec4(10001);\n        /*bp.xy = 1.0*(p - R*0.5 + 0.1*(rand2() - 0.5))/R;\n        bp.xy = vec2(sin(TWO_PI*bp.x), cos(TWO_PI*bp.x))*sqrt(bp.y + 0.5);\n        bp.z = 0.5*rand() - 0.05;\n        bp +=  0.2*sin(15.0*bp.yxx + 10.*iMouse.x/R.x + 3.);\n        bp += 0.1*sin(15.*length(bp)+ 10.*iMouse.y/R.y + 2.0);\n        bp.z = 550.0 + 350.7*bp.z;*/\n        \n           \n        vec3 p = 0.6*(rand3() - 0.5);\n        bp.w = 600.0 + 300.0*p.z;\n        \n        float dt = 0.5 + 0.5*sin(SPEED*iTime);\n         float dc1 = 0.5 + 0.5*sin(4.0*iTime);\n          float dc2 = 0.5 + 0.5*sin(6.0*iTime);\n          vec3 pd = vec3(-3,3 ,3);\n        for(int i = 0; i < 100; i++)\n        {\n            pd += dt*600.*sbf(pd, vec3(1,2,3),.9 )/1300.;\n            p += dt*30.*sbf(p, pd,.9 )/1300.;\n            p += dt*10.*sbf(p.zyx,vec3(1,23,1) + pd*0.3, .9 )/1445.;\n            p += dt*40.*sbf(p.xzy,vec3(3,12,5) - pd*0.5, .9)/753.;\n        }\n        \n        vec3 clip = project(cam, campos, p);\n        bp.xyz = clip;\n        bp.xy = clamp(bp.xy, vec2(0), R);\n        \n        //bp.xy = clamp(toScreen(bp.xy), vec2(-1), R);\n        c = bp; \n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//BITONIC SORT\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    int sort_iter = 3*iFrame + 1;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters- 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//BITONIC SORT\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    int sort_iter = 3*iFrame + 2;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters- 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//BINARY SEARCH OF POINTS THAT FELL INTO THIS PIXEL\n\n\nint search(int id)\n{\n    ivec2 range = ivec2(0, pixelnum);\n    \n    for(int i = 0; i < 128; i++)\n    {\n        //check the middle of the range\n        int middle = (range.x + range.y)/2;\n        vec4 data = texelFetch(iChannel1, pixel(middle), 0);\n        //get point id\n        int pid = pixelID(data.xy);\n        \n        //if found then stop\n        if(pid == id) return middle;\n        \n        if(range.y - range.x < 2) break;\n        \n        if(pid > id) //if our id of interest is below the found id\n            range.y = middle; //then set the end of the range as middle\n        else //if our id we search is above\n            range.x = middle; //then set the beginning of the range as middle\n    }\n    \n    return -1; //nothing found;\n}\n\nconst vec3 C = vec3(0.027,0.169,0.949);\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    c = texelFetch(iChannel0, ivec2(p), 0);\n    \n    int sort_iter = 3*iFrame + 2;\n    \n    if((sort_iter+1)%sort_iters == 0) //if last sorting step\n    {\n        #ifdef ACCUMULATION\n        if(iMouse.z > 0.0)\n        #endif\n            c *= 0.6;\n        int pixid = pixelID(p);\n        int id = search(pixid);\n        \n        vec2 ang = vec2(TWO_PI, PI)*iMouse.xy/R + vec2(0.4);\n        mat3 cam = get_cam(ang);\n        \n        vec3 campos = -cam*vec3(1.0,0,0);\n        vec2 uv = (p - 0.5*R.xy)/R.y;\n        vec3 rd = normalize(cam*vec3(1, FOV*uv));\n        \n        vec3 col = vec3(0.0);\n        float mind = 1e5;\n        if(id >= 0) //found at least 1 point in this pixel\n        {\n           \n            \n            for(int j = 0; j < 32; j++) //go left\n            {\n                int idx = id + j;\n                vec4 data = texelFetch(iChannel1, pixel(idx), 0);\n                int pid = pixelID(data.xy); //get point id\n                if(pid!=pixid) break; //not in this pixel anymore\n                if(data.z < mind && data.z > 0.0)\n                {\n                    mind = data.z;\n                    col = spectral_zucconi(data.w);\n                }\n               \n                \n            }\n            for(int j = 0; j < 32; j++) //go right\n            {\n                int idx = id - j - 1;\n                vec4 data = texelFetch(iChannel1, pixel(idx), 0);\n                int pid = pixelID(data.xy); //get point id\n                if(pid!=pixid) break; //not in this pixel anymore\n                if(data.z < mind && data.z > 0.0)\n                {\n                    mind = data.z;\n                    col = spectral_zucconi(data.w);\n                }\n            }\n          \n        }\n        \n        if(mind >= 1e5)\n        col = 0.3*texture(iChannel2, rd).xyz;\n        c.xyz += col.xyz;\n        c.w++;\n    }\n    \n    if(iFrame == 0) c = vec4(0);\n}", "buffer_d_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2Xzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8, 8, 36, 36, 96], [98, 98, 139, 139, 549]]}
{"id": "NdjXRw", "name": "Polluted waters", "author": "jarble", "description": "A river full of burning debris.", "tags": ["automata", "feedback", "river", "cellularautomata"], "likes": 2, "viewed": 284, "published": 3, "date": "1619900744", "time_retrieved": "2024-07-30T19:22:19.005194", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 2.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 6.0;\n\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = A/2.0;\nconst float NUM_NEIGH = A;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum = (GET(d)+sum)/1.1;\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL + ((-NUM_NEIGH) * (sum));\n        hash = (hash - sum)/2.0;\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]]}
{"id": "fdjXRw", "name": "Raining blobs", "author": "jarble", "description": "This cellular automaton has many gliders that move in the same direction.", "tags": ["automata", "feedback", "swarm", "cellularautomata"], "likes": 1, "viewed": 286, "published": 3, "date": "1619899785", "time_retrieved": "2024-07-30T19:22:19.912768", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 1.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 5.0;\n\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = A/2.0;\nconst float NUM_NEIGH = A;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum = (GET(d)+sum)/1.1;\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL + ((cen-NUM_NEIGH) * (sum-cen));\n        hash = (hash - sum)/2.0;\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]]}
{"id": "Ns2SRw", "name": "316_lokhno_v0v6", "author": "ivanlokhno", "description": "0", "tags": ["0"], "likes": 1, "viewed": 218, "published": 3, "date": "1619899045", "time_retrieved": "2024-07-30T19:22:20.697669", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(2, 1.9, -6);\nconst vec3 LIGHT1_POS = vec3(-3, 1.5, 5);\nconst float LIGHT1_RADIUS = 0.5;\nconst vec3 LIGHT1_COLOR = vec3(1, 1, 1);\n\nconst vec3 LIGHT2_POS = vec3(1, 0.5, 2);\nconst float LIGHT2_RADIUS = 0.25;\nconst vec3 LIGHT2_COLOR = vec3(0.1, 0.1, 1);\nvec3 randDir;\n\n\n// (CAMERA_POS + t * viewVec).y == -1\n// t = (-1 - CAMERA_POS.y) / viewVec.y;\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 sphNorm;\n    float sphT = traceSphere(pos, dir, 1.0, sphNorm);\n    if (sphT < dist)\n        return true;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : 20.0f / distSq1;\n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 10.0f / distSq2;\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + texture(iChannel1, normal).rgb * 0.1\n    );\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.) return vec3(0.0);\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat pow2(float x) {\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float n1 = AIR_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    const float WATER_N = 1.3;\n    float WATER_R = pow2(WATER_N - GLASS_N) / pow2(WATER_N + GLASS_N);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < 10; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n        }\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, l1Norm);\n        if (light1T < t) {\n            t = light1T;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = l1Norm;\n        }\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, l2Norm);\n        if (light2T < t) {\n            t = light2T;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = l2Norm;\n        }\n        vec3 sphNorm;\n        float sphT = traceSphere(curPos, curDir, 1.0, sphNorm);\n        if (sphT < t) {\n            t = sphT;\n            normal = sphNorm;\n            if (randVals.x < GLASS_R) {\n                materialType = REFLECTION;\n            } else {\n                //colorMult *= vec3(0.5, 0.5, 1);\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        float sph2T = traceSphere(curPos, curDir, 0.125, sphNorm);\n        if (sph2T < t) {\n            t = sph2T;\n            normal = sphNorm;\n            if (randVals.x < WATER_R) {\n                materialType = REFLECTION;\n            } else {\n                //colorMult *= vec3(1, 0.5, 0.75);\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = GLASS_N;\n                } else {\n                    nEnter = WATER_N;\n                }\n            }\n        }\n        float sph3T = traceSphere(curPos - vec3(0.25, 0.15, 0.), curDir, 0.125, sphNorm);\n        if (sph3T < t) {\n            t = sph3T;\n            normal = sphNorm;\n            if (randVals.x < WATER_R) {\n                materialType = REFLECTION;\n            } else {\n                //colorMult *= vec3(1, 0.5, 0.75);\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = GLASS_N;\n                } else {\n                    nEnter = WATER_N;\n                }\n            }\n        }\n        float sph4T = traceSphere(curPos - vec3(-0.25, 0.15, 0.), curDir, 0.125, sphNorm);\n        if (sph4T < t) {\n            t = sph4T;\n            normal = sphNorm;\n            if (randVals.x < WATER_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = GLASS_N;\n                } else {\n                    nEnter = WATER_N;\n                }\n            }\n        }\n        float sph5T = traceSphere(curPos - vec3(0.125, -0.15, 0.), curDir, 0.075, sphNorm);\n        if (sph5T < t) {\n            t = sph5T;\n            normal = sphNorm;\n            if (randVals.x < WATER_R) {\n                materialType = REFLECTION;\n            } else {\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = GLASS_N;\n                } else {\n                    nEnter = WATER_N;\n                }\n            }\n        }\n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < t) {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n        }\n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                \n                vec3 tmpDir = refraction(curDir, normal, n1, nEnter);\n                if (tmpDir == vec3(0.0)) {\n                    curDir = reflect(curDir, normal);\n                } else {\n                    curDir = tmpDir;\n                    n1 = nEnter;\n                }\n                curPos = worldPos + curDir * 1e-5;\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2SRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 234]]}
{"id": "ssBXzm", "name": "Fast caustic", "author": "michael0884", "description": "Due to the limited number of sorting steps you can do on shadertoy per frame, this is kinda slow, but the frametimes should be super small. In a perfect world the buffer B would be repeated N times. If you have the shadertoy plugin just use 64 paint calls", "tags": ["raster"], "likes": 14, "viewed": 535, "published": 3, "date": "1619894023", "time_retrieved": "2024-07-30T19:22:21.458634", "image_code": "//SHOW\n\nbool isKeyToggled(int KEY)\n{\n\treturn texelFetch( iChannel1, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    if(isKeyToggled(KEY_SPACE))\n    {\n        vec4 col = texelFetch(iChannel0, ivec2(p), 0);\n        float k = float(pixelID(col.xy))/pixelnum;\n        \n        c = vec4(k);\n    }\n    else\n    {\n        if(all(greaterThan(vec2(50,50),p)))\n        {\n            vec4 col = texture(iChannel0, p/50.0);\n            float k = float(pixelID(col.xy))/pixelnum; \n            c = vec4(k);\n        }\n        else\n        {\n            vec4 col = texelFetch(iChannel2, ivec2(p), 0);\n            float exposure = 1. - (iMouse.x/R.x);\n            c = 0.5*col/col.w;\n        }\n    }\n   \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define TWO_PI 6.28318530718\n\nvec2 R;\nint sort_iters;\nfloat pixelnum;\n\nvec2 toScreen(vec2 p)\n{\n    return 0.5*p*R.y + R*0.5;\n}\n\nbool onScreen(vec2 p)\n{\n    return all(greaterThan(p, vec2(0))) && all(greaterThan(R,p));\n}\n\n\nint pixelID(vec2 pix)\n{\n    return int(pix.x) + int(pix.y)*int(R.x);\n}\n\nivec2 pixel(int pid)\n{\n    return ivec2(pid%int(R.x), pid/int(R.x));\n}\n\n//thanks rory618 (https://www.shadertoy.com/view/WssfDn) for this incredible magic function\nint getPartner(int x, int s){\n    float j = floor(sqrt(float(2*s)+1.25)-0.5);\t\t//Major stage\n    float n = floor(float(s) - 0.5*(j*j+j) + 0.5);\t//Minor stage\n    float b = floor(exp2(j-n+1.)+0.5);\t\t\t\t//Block size\n    float bot = floor(float(x)/b)*b;\t\t\t\t//Bottom index in block \n    float top = bot + b - 1.;\t\t\t\t\t\t//Top index in block\n    if(n<0.5){\t\t\t\t\t\t\t\t\t\t//Swap with opposite index in block\n        return int(top - (float(x)-bot) + 0.5);\n    }else{\t\t\t\t\t\t\t\t\t\t\t//Swap with index a constant distance away in block\n        if(float(x)-bot < b/2.-0.5){\n            return int(float(x) + b/2. + 0.5);\n        }else{\n            return int(float(x) - b/2. + 0.5);\n        }\n    }\n}\n\n\n//internal RNG state \nuvec4 s0; \n\nvoid initialize(inout vec2 p, int frame, vec3 res)\n{\n    p = floor(p);\n    \n    R = res.xy;\n    pixelnum = R.x*R.y;\n    float lg2 = ceil(log2(pixelnum));\n    sort_iters = 3*int(ceil(lg2*(lg2 + 1.0)/6.0) + 1.0);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec2 cmul(vec2 x, vec2 y)\n{\n    return vec2(x.x*y.x - x.y*y.y, x.x*y.y + x.y*y.x);\n}\n\nvec2 disk()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nconst int max_iterations = 256;\nconst vec4 color_threshholds = vec4(255,130,80,255);\n\nvec3 buddhabrot(int iters)\n{\n    vec2 z = vec2(0.0);\n    vec2 c = disk()*1.5 + vec2(-0.5, 0.0);\n\n    bool t = true;\n    int i = 0;\n    for(; i < iters; i++)\n    {\n        if(length(z) > 4.0) break;\n        \n        z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + c;\n    }\n    \n    if(i >= iters) return vec3(1e5);\n    \n    int maxj = int(rand()*1000.0)%i;\n    z = vec2(0.0);\n    for(int j = 0; j <= maxj; j++)\n    {\n         z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + c;\n    }\n    return vec3(z, i);\n    \n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_BSPACE = 8;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n", "buffer_b_code": "//BITONIC SORT\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    int sort_iter = 3*iFrame + 0;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters - 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n  \n    \n    if(sort_iter%sort_iters == 0) //intialize with some random points, in this case pseudo caustic\n    {\n        vec3 bp = vec3(-1);\n        bp.xy = 1.4*(p - R*0.5 + rand2() - 0.5)/R.y;\n        bp.z = 0.1*rand() - 0.05;\n        bp +=  0.2*sin(15.0*bp.yxx + 10.*iMouse.x/R.x + 3.);\n        bp += 0.1*sin(15.*length(bp)+ 10.*iMouse.y/R.y + 2.0);\n        bp.z = 550.0 + 350.7*bp.z;\n        //bp.xy = clamp(toScreen(bp.xy), vec2(-1), R);\n        c = vec4(toScreen(bp.xy),bp.z, 0.5); \n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//BITONIC SORT\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    int sort_iter = 3*iFrame + 1;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters- 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//BITONIC SORT\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    int sort_iter = 3*iFrame + 2;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters- 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//BINARY SEARCH OF POINTS THAT FELL INTO THIS PIXEL\n\nint search(int id)\n{\n    ivec2 range = ivec2(0, pixelnum);\n    \n    for(int i = 0; i < 128; i++)\n    {\n        //check the middle of the range\n        int middle = (range.x + range.y)/2;\n        vec4 data = texelFetch(iChannel1, pixel(middle), 0);\n        //get point id\n        int pid = pixelID(data.xy);\n        \n        //if found then stop\n        if(pid == id) return middle;\n        \n        if(range.y - range.x < 2) break;\n        \n        if(pid > id) //if our id of interest is below the found id\n            range.y = middle; //then set the end of the range as middle\n        else //if our id we search is above\n            range.x = middle; //then set the beginning of the range as middle\n    }\n    \n    return -1; //nothing found;\n}\n\nconst vec3 C = vec3(0.027,0.169,0.949);\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    c = texelFetch(iChannel0, ivec2(p), 0);\n    \n    int sort_iter = 3*iFrame + 2;\n    \n    if((sort_iter+1)%sort_iters == 0) //if last sorting step\n    {\n        if(iMouse.z > 0.0) c *= 0.05;\n        int pixid = pixelID(p);\n        int id = search(pixid);\n        \n        vec3 col = vec3(0.0);\n        if(id >= 0) //found at least 1 point in this pixel\n        {\n            for(int j = 0; j < 32; j++) //go left\n            {\n                int idx = id + j;\n                vec4 data = texelFetch(iChannel1, pixel(idx), 0);\n                int pid = pixelID(data.xy); //get point id\n                if(pid!=pixid) break; //not in this pixel anymore\n                c += vec4(spectral_zucconi(data.z), 0.0);\n                \n            }\n            for(int j = 0; j < 32; j++) //go right\n            {\n                int idx = id - j - 1;\n                vec4 data = texelFetch(iChannel1, pixel(idx), 0);\n                int pid = pixelID(data.xy); //get point id\n                if(pid!=pixid) break; //not in this pixel anymore\n                c += vec4(spectral_zucconi(data.z), 0.0);\n            }\n          \n        }\n        else\n        c += vec4(0,0,0,0);\n        c.w++;\n    }\n    \n    if(iFrame == 0) c = vec4(0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8, 8, 36, 36, 96], [98, 98, 139, 139, 755]]}
{"id": "NssXD2", "name": "Basic Reaction-Diffusion", "author": "clepirelli", "description": "Made for the willstall challenge - 1 shader a week keeps the depression meek\n\nSimple reaction-diffusion with a palette - you can draw reagents with your mouse, and press space to reset the sim\n\n", "tags": ["diffusion", "reaction", "nouse"], "likes": 1, "viewed": 431, "published": 3, "date": "1619891751", "time_retrieved": "2024-07-30T19:22:22.300384", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 bufferA = texture(iChannel0, fragCoord/iResolution.xy).xy/maxAmount;\n    \n    if(usingPalette)\n    {\n        fragColor = vec4(pal(bufferA.x, palette) , 1.0);\n    } else \n    {\n        fragColor = vec4(bufferA.yyy,1.0);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//---- reaction-diffusion constants\nconst float firstDiffusionRate = .8;\nconst float growthRate = .04;\nconst float growthVariation = .010;\n\nconst float secondDiffusionRate = .4;\nconst float deathRate = .06;\nconst float deathVariation = .001;\n\nconst float maxAmount = 1.0;\nconst float speed = 100.0;\n\nconst float mouseRadius = .1;\nconst float startRadius = .01;\n\n//---- aesthetic constants\nconst bool usingPalette = true; //true: v gets converted to palette\n#define palette \\\n    vec3(0.5,0.5,0.5),\\\n    vec3(0.5,0.5,0.7),\\\n    vec3(1.0,1.0,1.0),\\\n    vec3(0.05,0.10,0.1) \n\n//from iq: https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//---- kernel stuff\nconst float laplacianKernel[9] = float[9](\n    .05, .2, .05, \n    .2, -1., .2, \n    .05, .2, .05);\n    \nvec2 _applyKernel(vec2 uv, vec2 resolution, sampler2D image, float kernel[9])\n{\n    vec2 pixelSize = 1./resolution.xy;\n    vec2 afterKernel = vec2(.0);\n    for(int i = 0; i < 3; i++)\n    for(int j = 0; j < 3; j++)\n    {\n        vec2 sampleUV = uv + vec2(float(i-1), float(j-1)) * pixelSize;\n        afterKernel += texture(image, sampleUV).xy * kernel[j*3+i];\n    }\n    \n    return afterKernel;\n}\n#define applyKernel(uv, image, kernel) _applyKernel(uv, iResolution.xy, image, kernel)", "buffer_a_code": "#define spacePressed(sampler) texelFetch(sampler,ivec2(32, 0), 0).x > 0.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 bufferUV = fragCoord.xy/iResolution.xy; \n    float aspectRatio = iResolution.x/iResolution.y;\n    \n    vec2 aspectCorrectedUV = bufferUV;\n    aspectCorrectedUV.x *= aspectRatio;\n    \n    if(iFrame < 3 || spacePressed(iChannel1))\n    {\n        fragColor = vec4(1.0, distance(aspectCorrectedUV, vec2(.5*aspectRatio,.5)) < startRadius, .0, 1.0);\n        return;\n    }\n   \n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.x *= aspectRatio;\n    \n    if((distance(mouse, aspectCorrectedUV) < mouseRadius) && sign(iMouse.z) > .0)\n    {\n        fragColor = vec4(1.0, 1.0, .0, 1.0);\n        return;\n    }\n\n    vec2 lastFrame = clamp(texture(iChannel0, bufferUV).xy, .0, maxAmount);\n    \n    const vec2 diffusionRates = vec2(firstDiffusionRate, secondDiffusionRate);\n    vec2 diffusion = applyKernel(bufferUV, iChannel0, laplacianKernel) * diffusionRates;\n    \n    float currentGrowthRate = mix(growthRate-growthVariation, growthRate+growthVariation, bufferUV.x);\n    float currentDeathRate = mix(deathRate-deathVariation, deathRate+deathVariation, bufferUV.y);\n    \n    float reactionAmount = lastFrame.x * lastFrame.y * lastFrame.y;\n    vec2 change = diffusion + vec2(\n        -reactionAmount + currentGrowthRate * (maxAmount - lastFrame.x),\n        reactionAmount - (currentGrowthRate + currentDeathRate) * lastFrame.y\n    );\n\n    fragColor = clamp(vec4(lastFrame+change*iTimeDelta*speed, 1.0, 1.0), .0, maxAmount);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssXD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 291]]}
{"id": "ssBXRm", "name": "hairy Britney 2 ", "author": "FabriceNeyret2", "description": "BuffA pauses the video to avoid the shower door effect.\nOk, very far from\nreference: Murat Yıldırım work  ( see image at forum bottom ).\n[url]https://www.designboom.com/art/murat-yildirim-furry-artworks-09-19-2020/[/url]\n", "tags": ["worley", "short", "lic", "hairy"], "likes": 24, "viewed": 878, "published": 3, "date": "1619889116", "time_retrieved": "2024-07-30T19:22:23.057864", "image_code": "// variant of https://shadertoy.com/view/NsSSzW\n\n#define S(v)    smoothstep( 30./R.y,0., v )\n#define hash(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define sqr(v)  ( (v) * (v) )\n\nfloat h; // pos along line\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    h = clamp(dot(p, b) / dot(b, b), 0., 1.);           // proj coord on line\n    return length(p - b * h);                           // dist to segment\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, I,I0,H,\n         P = ( 2.*u - R ) / R.y,\n         U = 20.*u/R.y,\n      // F = vec2(P.y,-P.x);                            // field direction of hairs\n         F = vec2(2,2);\n         F = 1. + cos(3.14/2.*P);\n      // F = normalize(mix(F,vec2(2),.5+.5*sin(2.*iTime))) ; \n    float l = 1e5, d;\n    O = vec4(0);\n    \n    for( int k=0; k<16; k++ ) {                         // check neighbor cells\n        I = vec2(k%4-1,k/4-1);\n        for (float n=0.; n<17.; n++) {                  // N hair per cell\n            H =  hash(floor(U)+I+n/1.71);               // random position in cell\n         // H =  1.5*(hash(floor(U)+I+n/1.71)-.5)+.9;   // random position in cell\n            P = I + H + .1*cos(5.*iTime+n+vec2(0,11));  // relative to current cell, + motion\n         // d = length(fract(U)-P);                     // ( used only to draw debug points )\n         // if ( d < l ) l = d, I0=I; // P0 = P;        // ( used only to draw debug points )\n            O = max( O,  \n                     S( line(fract(U),I+.5,P-F))        // blend hair strends\n                  // S( line(fract(U),I+H,P-F))         // variant without strends\n                     * sqr(texture(iChannel0, (floor(U)+I+.5*H) *R.y/20./R ) *h*h) ); // hair color\n        }\n    }\n    O = sqrt(O);\n                                                        // debug:\n//O = vec4( S(l-.1) );                                  //  show points\n//O = S(l-.1) *vec4(mod(floor(U)+I0,2.),.5,1) ;         //  color points(tile)\n//O = mix( vec4(mod(floor(U),2.),0,1), O, O.a );        //  show tiles\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// select a frame in the video\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n    O = iChannelTime[1] < .9\n          ? texture(iChannel1, U ) \n          : texture(iChannel0, U );\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 229, 264, 264, 440], [442, 442, 480, 480, 2067]]}
{"id": "7sSSRw", "name": "Bouncy balls II", "author": "Leasel", "description": "Uses a similar way of thinking in my sketch of pressure fluids. \n(Second version with less glitches, but still disappearing balls. Thus something is not right with the collission)", "tags": ["buffer"], "likes": 5, "viewed": 335, "published": 3, "date": "1619887176", "time_retrieved": "2024-07-30T19:22:23.808856", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = T(ivec2(fragCoord)).wwww;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid ConfigureOwnBall(inout vec4 myBall)\n{\n    //Get all variables\n    ivec2 dir = GetTexelDirection(myBall);\n    \n    //Look if it will lose its ball\n    myBall *= WillLandInThisCell(dir);\n}\n\nvoid ConfigureNeighbourBall(inout vec4 myBall, in ivec2 RelativePositionToNeighbour, in ivec2 p)\n{\n    //Get all variables of neighbourball\n    vec4 NeighbourBall = T(p - RelativePositionToNeighbour);\n    ivec2 dirN = GetTexelDirection(NeighbourBall);\n    \n    //Look if will get neighbour ball\n    NeighbourBall *= WillLandInThisCell(dirN - RelativePositionToNeighbour);\n    \n    //Apply physics to the neighbour ball(this is not accurate)\n    //NeighbourBall.xy -= min(GetSpeed(NeighbourBall), 1.) * GetDirection(NeighbourBall) * iTimeDelta * GetWeight(NeighbourBall);\n    \n    //Get neighbour ball if landing on own cell\n    myBall += NeighbourBall;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Get start variables\n    ivec2 p = ivec2(fragCoord);\n    vec4 myBall = T(p);\n   \n    //Look if myBall will lose its ball\n    ConfigureOwnBall(myBall);\n    \n    //Look around at neightbours balls if you can inherit one\n    ConfigureNeighbourBall(myBall, ivec2(-1., -1.), p);\n    ConfigureNeighbourBall(myBall, ivec2(-0., -1.), p);\n    ConfigureNeighbourBall(myBall, ivec2( 1., -1.), p);\n    ConfigureNeighbourBall(myBall, ivec2(-1., -0.), p);\n    //Center\n    ConfigureNeighbourBall(myBall, ivec2( 1., -0.), p);\n    ConfigureNeighbourBall(myBall, ivec2(-1.,  1.), p);\n    ConfigureNeighbourBall(myBall, ivec2(-0.,  1.), p);\n    ConfigureNeighbourBall(myBall, ivec2( 1.,  1.), p);\n    \n    //Return the ball to this cell\n    fragColor = myBall;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 GetStarterBalls(in vec2 fragCoord)\n{\n    vec4 ball = texture(iChannel1, fragCoord/iResolution.xy);\n    \n    ball.x = 0.;\n    ball.y = 2.;\n    \n    ball.w = ceil(ball.z-0.5);\n    \n    ball.w = clamp(round(ball.w), 0., 1.);\n    ball.xy *= ball.w;\n\n    return ball;\n}\n\nbool AtBorder(in ivec2 p)\n{\n    return p.x < 2 || p.y < 2 || p.x > int(iResolution.x) - 3 || p.y > int(iResolution.y) - 3;\n}\n\nvec4 GetBorderBalls(in ivec2 p)\n{\n    return vec4(0.);\n}\n\nvoid ApplyGravity(inout vec4 myBall)\n{\n    myBall.y += GetWeight(myBall) * -9.81 * iTimeDelta;\n}\n\nvec2 reflectionDir(in ivec2 p, in ivec2 dir)\n{\n    return GetBall(T(p + dir)) * -vec2(dir);\n}\n\nvoid ApplyCollission(inout vec4 myBall, in ivec2 p)\n{\n    //The best option is to look around and compute how much speed it gets from its neighbours and loses from its neighbours\n\n    //Get variables\n    ivec2 dir = GetTexelDirection(myBall);\n    vec4 colBall = T(p + dir);\n    vec2 reflectDir = vec2(0);\n    \n    //Make reflection dir\n    for(int i = 0; i < 8; i++)\n    {\n        reflectDir += reflectionDir(p, neighbourPosses[i]);\n    }\n    \n    ////Look if direction to move will not be occupied\n    //bool canMove = true;\n    //vec2 moveToDir = reflect(normalize(vec2(dir)), normalize(reflectDir))*length(myBall.xy);\n    //ivec2 moveToTexelDir = GetTexelDirection(moveToDir);\n    //for(int i = 0; i < 8 && canMove; i++)\n    //{\n    //    if(neighbourPosses[i] != -moveToTexelDir)\n    //    {\n    //        vec4 ball = T(neighbourPosses[i] + p + moveToTexelDir);\n    //        ivec2 oDir = GetTexelDirection(ball);\n    //        \n    //        canMove = (neighbourPosses[i] + oDir) != ivec2(0) && !isBall(ball);\n    //    }\n    //}\n    //\n    ////Stand still for now if occupied(crued fix)\n    //myBall.xy = canMove || moveToTexelDir == ivec2(0) ? myBall.xy : vec2(0.);\n    \n    myBall.xy = isBall(myBall) && dir != ivec2(0) && reflectDir != vec2(0.) && isBall(colBall) ? \n        reflect(normalize(vec2(dir)), normalize(reflectDir))*length(myBall.xy) : \n        myBall.xy;\n}\n\nvoid ApplyDamping(inout vec4 myBall)\n{\n    myBall.xy *= 0.99;//Sort of air resistance\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //Get start variables\n    ivec2 p = ivec2(fragCoord);\n    vec4 myBall = T(p);\n    \n    //Add in some balls\n    myBall += iFrame < 10 && !isBall(myBall) ? GetStarterBalls(fragCoord) : vec4(0.); \n    \n    //Apply physics to ball\n    ApplyGravity(myBall);\n    \n    //Apply some damping\n    ApplyDamping(myBall);\n    \n    //Apply collission to ball\n    ApplyCollission(myBall, p);\n    \n    //Add the border balls\n    myBall = AtBorder(p) ? vec4(0.,0.,0.,1.) : myBall;\n    \n    //Return the ball to this cell\n    fragColor = myBall;\n}", "buffer_b_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(fragCoord) texelFetch(iChannel0, fragCoord, 0)\n\nconst ivec2 neighbourPosses[] = ivec2[]\n(\n    ivec2(-1., -1.),\n    ivec2( 0., -1.),\n    ivec2( 1., -1.),\n    ivec2( 1.,  0.),\n    ivec2( 1.,  1.),\n    ivec2( 0.,  1.),\n    ivec2(-1.,  1.),\n    ivec2(-1.,  0.)\n);\n\nivec2 GetTexelDirection(in vec2 dir)\n{\n    return ivec2(clamp(dir, -1., 1.));\n}\nivec2 GetTexelDirection(in vec4 ball)\n{\n    return GetTexelDirection(ball.xy);\n}\n\nvec2 GetDirection(in vec4 ball)\n{\n    return ball.x + ball.y == 0. ? vec2(0.) : normalize(ball.xy);\n}\n\nvec2 GetImpulse(in vec4 ball)\n{\n    return ball.xy;\n}\n\nfloat GetSpeed(in vec4 ball)\n{\n    return length(ball.xy);\n}\n\nfloat GetWeight(in vec4 ball)\n{\n    return ball.z;\n}\n\nbool isBall(in vec4 ball)\n{\n    return ball.w > 0.;\n}\n\nfloat GetBall(in vec4 ball)\n{\n    return ball.w;//Get this value and multiply this with the force, but this can also be checked with mass\n}\n\nfloat WillLandInThisCell(in ivec2 pos)\n{\n    return pos == ivec2(0) ? 1. : 0.;\n}\n\nfloat WillLandInThisCell(in vec2 pos)\n{\n    return pos == vec2(0.) ? 1. : 0.;\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSSRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 101]]}
{"id": "7dBSRm", "name": "Bitonic rasterizer", "author": "michael0884", "description": "Due to the limited number of sorting steps you can do on shadertoy per frame, this is kinda slow, but the frametimes should be super small. In a perfect world the buffer B would be repeated N times. If you have the shadertoy plugin just use 64 paint calls", "tags": ["raster"], "likes": 9, "viewed": 513, "published": 3, "date": "1619886819", "time_retrieved": "2024-07-30T19:22:24.706456", "image_code": "//SHOW\n\nbool isKeyToggled(int KEY)\n{\n\treturn texelFetch( iChannel1, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    if(isKeyToggled(KEY_SPACE))\n    {\n        vec4 col = texelFetch(iChannel0, ivec2(p), 0);\n        float k = float(pixelID(col.xy))/pixelnum;\n        \n        c = vec4(k);\n    }\n    else\n    {\n        if(all(greaterThan(vec2(50,50),p)))\n        {\n            vec4 col = texture(iChannel0, p/50.0);\n            float k = float(pixelID(col.xy))/pixelnum; \n            c = vec4(k);\n        }\n        else\n        {\n            vec4 col = texelFetch(iChannel2, ivec2(p), 0);\n            float exposure = 1. - (iMouse.x/R.x);\n            c.xyz = tanh(2.0*exposure*pow(col.xyz/col.w,vec3(0.561,0.561,0.561)));\n        }\n    }\n   \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265\n#define TWO_PI 6.28318530718\n\nvec2 R;\nint sort_iters;\nfloat pixelnum;\n\nvec2 toScreen(vec2 p)\n{\n    return (0.5*(p - vec2(-0.5, 0.0)))*R.y + R*0.5;\n}\n\nbool onScreen(vec2 p)\n{\n    return all(greaterThan(p, vec2(0))) && all(greaterThan(R,p));\n}\n\n\nint pixelID(vec2 pix)\n{\n    return int(pix.x) + int(pix.y)*int(R.x);\n}\n\nivec2 pixel(int pid)\n{\n    return ivec2(pid%int(R.x), pid/int(R.x));\n}\n\n//thanks rory618 (https://www.shadertoy.com/view/WssfDn) for this incredible magic function\nint getPartner(int x, int s){\n    float j = floor(sqrt(float(2*s)+1.25)-0.5);\t\t//Major stage\n    float n = floor(float(s) - 0.5*(j*j+j) + 0.5);\t//Minor stage\n    float b = floor(exp2(j-n+1.)+0.5);\t\t\t\t//Block size\n    float bot = floor(float(x)/b)*b;\t\t\t\t//Bottom index in block \n    float top = bot + b - 1.;\t\t\t\t\t\t//Top index in block\n    if(n<0.5){\t\t\t\t\t\t\t\t\t\t//Swap with opposite index in block\n        return int(top - (float(x)-bot) + 0.5);\n    }else{\t\t\t\t\t\t\t\t\t\t\t//Swap with index a constant distance away in block\n        if(float(x)-bot < b/2.-0.5){\n            return int(float(x) + b/2. + 0.5);\n        }else{\n            return int(float(x) - b/2. + 0.5);\n        }\n    }\n}\n\n\n//internal RNG state \nuvec4 s0; \n\nvoid initialize(inout vec2 p, int frame, vec3 res)\n{\n    p = floor(p);\n    \n    R = res.xy;\n    pixelnum = R.x*R.y;\n    float lg2 = ceil(log2(pixelnum));\n    sort_iters = 3*int(ceil(lg2*(lg2 + 1.0)/6.0) + 1.0);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nuvec4 pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    return v;\n}\n\nfloat rand(){ return float(pcg4d(s0).x)/float(0xffffffffu); }\nvec2 rand2(){ return vec2(pcg4d(s0).xy)/float(0xffffffffu); }\nvec3 rand3(){ return vec3(pcg4d(s0).xyz)/float(0xffffffffu); }\nvec4 rand4(){ return vec4(pcg4d(s0))/float(0xffffffffu); }\n\nvec2 nrand2(float sigma, vec2 mean)\n{\n\tvec2 Z = rand2();\n    return mean + sigma * sqrt(-2.0 * log(Z.x)) * \n           vec2(cos(TWO_PI * Z.y),sin(TWO_PI * Z.y));\n}\n\nvec2 cmul(vec2 x, vec2 y)\n{\n    return vec2(x.x*y.x - x.y*y.y, x.x*y.y + x.y*y.x);\n}\n\nvec2 disk()\n{\n    vec2 r = rand2();\n    return vec2(sin(TWO_PI*r.x), cos(TWO_PI*r.x))*sqrt(r.y);\n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\n\nconst int max_iterations = 256;\nconst vec4 color_threshholds = vec4(255,130,80,255);\n\nvec3 buddhabrot(int iters)\n{\n    vec2 z = vec2(0.0);\n    vec2 c = disk()*1.5 + vec2(-0.5, 0.0);\n\n    bool t = true;\n    int i = 0;\n    for(; i < iters; i++)\n    {\n        if(length(z) > 4.0) break;\n        \n        z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + c;\n    }\n    \n    if(i >= iters) return vec3(1e5);\n    \n    int maxj = int(rand()*1000.0)%i;\n    z = vec2(0.0);\n    for(int j = 0; j <= maxj; j++)\n    {\n         z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y) + c;\n    }\n    return vec3(z, i);\n    \n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_BSPACE = 8;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n", "buffer_b_code": "//BITONIC SORT\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    int sort_iter = 3*iFrame + 0;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters - 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n  \n    \n    if(sort_iter%sort_iters == 0) //intialize with some random points, in this case buddhabrot samples\n    {\n        vec3 bp = vec3(-1);\n        for(int i = 0; i < 64; i++)\n        {\n            bp = buddhabrot(256);\n            bp.z = (bp.z > 20.)?(380.0 + 6.0*(bp.z - 20.0)):1000.0;\n            bp.xy = toScreen(bp.xy);\n            if(onScreen(bp.xy) && bp.z < 1000.) break;\n        }\n        bp.xy = clamp(bp.xy, vec2(-1), R);\n        c = vec4(bp, 0.5); \n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//BITONIC SORT\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    int sort_iter = 3*iFrame + 1;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters - 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//BITONIC SORT\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    int sort_iter = 3*iFrame + 2;\n    \n    int id0 = pixelID(p);\n    int id1 = getPartner(id0, sort_iter%sort_iters - 1);\n    \n    if(id1 < int(pixelnum) && id1 >= 0)\n    {\n        vec4 A = texelFetch(iChannel0, pixel(id0), 0);\n        vec4 B = texelFetch(iChannel0, pixel(id1), 0);\n\n        int zA = pixelID(A.xy);\n        int zB = pixelID(B.xy);\n\n        if(id0 > id1) c = (zA>zB)?A:B;\n        else c = (zA<zB)?A:B;\n    }\n    else c = texelFetch(iChannel0, ivec2(p), 0);\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//BINARY SEARCH OF POINTS THAT FELL INTO THIS PIXEL\n\nint search(int id)\n{\n    ivec2 range = ivec2(0, pixelnum);\n    \n    for(int i = 0; i < 64; i++)\n    {\n        //check the middle of the range\n        int middle = (range.x + range.y)/2;\n        vec4 data = texelFetch(iChannel1, pixel(middle), 0);\n        //get point id\n        int pid = pixelID(data.xy);\n        \n        //if found then stop\n        if(pid == id) return middle;\n        \n        if(pid > id) //if our id of interest is below the found id\n            range.y = middle; //then set the end of the range as middle\n        else //if our id we search is above\n            range.x = middle; //then set the beginning of the range as middle\n    }\n    \n    return -1; //nothing found;\n}\n\nconst vec3 C = vec3(0.133,0.141,0.184);\n\nvoid mainImage( out vec4 c, in vec2 p )\n{\n    initialize(p, iFrame, iResolution);\n    \n    c = texelFetch(iChannel0, ivec2(p), 0);\n    \n    int sort_iter = 3*iFrame + 2;\n    \n    if((sort_iter+1)%sort_iters == 0) //if last sorting step\n    {\n        int pixid = pixelID(p);\n        int id = search(pixid);\n        \n        vec3 col = vec3(0.0);\n        if(id >= 0) //found at least 1 point in this pixel\n        {\n             for(int j = 0; j < 32; j++) //go left\n            {\n                int idx = id + j;\n                vec4 data = texelFetch(iChannel1, pixel(idx), 0);\n                int pid = pixelID(data.xy); //get point id\n                if(pid!=pixid) break; //not in this pixel anymore\n                c += vec4(spectral_zucconi(data.z), 0.0);\n                \n            }\n            for(int j = 0; j < 32; j++) //go right\n            {\n                int idx = id - j - 1;\n                vec4 data = texelFetch(iChannel1, pixel(idx), 0);\n                int pid = pixelID(data.xy); //get point id\n                if(pid!=pixid) break; //not in this pixel anymore\n                c += vec4(spectral_zucconi(data.z), 0.0);\n            }\n          \n        }\n        c.w++;\n    }\n    \n    if(iFrame == 0) c = vec4(0);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBSRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8, 8, 36, 36, 96], [98, 98, 139, 139, 807]]}
{"id": "ssSXzw", "name": "GLSL bug on vectors", "author": "FabriceNeyret2", "description": "On OpenGL / Chrome / nVidia,  vec.x = k = expr ( top ) is wrong, \nand differs from k = expr ( top ) ,   vec.x = k  ( bottom ) .\nCorrect on Firefox. \nCorrect if float instead of vec.x", "tags": ["glslbugvec12"], "likes": 1, "viewed": 304, "published": 3, "date": "1619880006", "time_retrieved": "2024-07-30T19:22:25.551197", "image_code": "// acid simplification of the new GLSL bug in https://shadertoy.com/view/lst3R7\n\n\n    #define DEST U.x   // vec.x = float = expr doesn't work\n//  #define DEST u     // float = float = expr doesn't work\n  \nvoid mainImage( out vec4 O,  vec2 U ) {\n    \n    vec2 R = iResolution.xy;\n     \n    float s=1., w = 1., u=U.x;\n\n    if (U.y > R.y/2.)\n        DEST *= s = sin( w );      // top: wrong result if DEST = vec.x\n\n    else \n        s = sin( w ), DEST *= s;   // bottom: ref.\n    \n    O = vec4(.5+DEST/R.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSXzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 244, 244, 506]]}
{"id": "NsBXRw", "name": "Noisey Cube", "author": "tangerine", "description": "cube", "tags": ["3d", "cube"], "likes": 0, "viewed": 244, "published": 3, "date": "1619875502", "time_retrieved": "2024-07-30T19:22:26.402920", "image_code": "float Distline(vec3 ro, vec3 rd, vec3 p) {//distance from a point to a line    \n    return length(cross(p-ro,rd))/length(rd);\n}\nfloat Drawpoint(vec3 ro, vec3 rd, vec3 p) {\n    float d = Distline(ro,rd,p);\n    d =smoothstep(.3,.01,d);\n    return d;\n}    \nfloat PHI = 1.61803398874989484820459;  // Φ = Golden Ratio   \n\nfloat noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\nfloat bitwiseXOR(in vec2 p) // thanks to https://www.shadertoy.com/view/4tt3z2\n{\n    float result = 0.0;\n    for(float n = 0.0; n < 6.0; n+=1.0)\n    {\n        vec2 a = floor(p);\n        result += mod(a.x+a.y,2.0);\n        p/=2.0;\n        result/=2.0;\n    };    \n    return result;\n}\n\n\nvoid DrawScanline( inout vec3 color, vec2 uv )\n{\n    float scanline \t= clamp( 0.5 + 0.5 * cos( 3.14 * ( uv.y + 0.1 * iTime ) * 4.5 * 1.0 ), 0.0, 1.0 );\n    float grille \t= 0.5 + 0.5 * clamp( 1.5 * cos( 3.14 * uv.x * 10.0 * 1.0 ), 0.0, 1.0 );    \n    color += abs(scanline * grille * 1.2);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5; // center is 0,0      \n    uv.x *= iResolution.x / iResolution.y; // make it square    \n    \n    vec3 ro = vec3(5.*cos(t/10.15),5.*sin(t/10.13),6.+3.*cos(t/30.)); //camera position   \n    vec3 lookat = vec3(.5,.5,.5);\n    vec3 f = normalize(lookat - ro); \n    vec3 r = cross(vec3(0., 1., 0.),f);\n    vec3 u = cross(f,r);\n    float zoom = sin(t/4.)/2.-2.;\n    vec3 c = ro + f*zoom;   \n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i - ro; //screeeen\n    // Time varying pixel color\n    vec3 col = cos(iTime/20.+uv.xyx+vec3(0,8,4));\n    DrawScanline(col, uv);\n    vec3 p = vec3(sin(iTime),0.,cos(iTime));\n    float d = 0.;      \n    for(float i=-1.01;i<1.01;i+= .25){\n        d += Drawpoint(ro,rd,vec3(i,1.,1.));   \n        d += Drawpoint(ro,rd,vec3(i,-1.,1.)); \n        d += Drawpoint(ro,rd,vec3(i,1.,-1.));\n        d += Drawpoint(ro,rd,vec3(i,-1.,-1.)); \n        \n        d += Drawpoint(ro,rd,vec3(1.,i,-1.));   \n        d += Drawpoint(ro,rd,vec3(1.,i,1.));\n        d += Drawpoint(ro,rd,vec3(-1.,i,-1.));\n        d += Drawpoint(ro,rd,vec3(-1.,i,1.));\n        \n        d += Drawpoint(ro,rd,vec3(-1.,-1.,i));\n        d += Drawpoint(ro,rd,vec3(1.,-1.,i));\n        d += Drawpoint(ro,rd,vec3(-1.,1.,i));\n        d += Drawpoint(ro,rd,vec3(1.,1.,i));\n    }    \n        float wave = texture( iChannel0, vec2(uv.x,0.75) ).x;\n        d+= 1.0 -  smoothstep( 0.0, 0.9, abs(wave/20. - uv.y) );     \n        d += bitwiseXOR(vec2(d,col.x));\n        float fft  = texture( iChannel0, vec2(uv.x,0.25) ).x;    \n\n        \n\n    d -= noise(-vec2(d, col.y), 1.);  \n    //d= mod(d,.001);  \n    //d*=1000.;\n    col *= vec3(d,d/2.,d ) ; \n    vec3 four = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n    // Output to screen\n    fragColor = abs(vec4(col,1)) ;\n}", "image_inputs": [{"id": 26940, "src": "https://soundcloud.com/endsville/nnlu-fayz2", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 79, 127], [128, 128, 171, 171, 249], [319, 319, 358, 358, 418], [419, 419, 499, 499, 701], [704, 704, 752, 752, 994], [995, 995, 1052, 1052, 2916]]}
{"id": "fsSXzm", "name": "feature Z", "author": "yasuo", "description": "feature Z", "tags": ["puma"], "likes": 10, "viewed": 296, "published": 3, "date": "1619857256", "time_retrieved": "2024-07-30T19:22:27.238685", "image_code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat threeDF(vec3 p) {\n    vec3 prevP = p;\n    \n    float d = sdBox(p,vec3(1.0,1.0,0.3));\n    p*=matRotateZ(radians(-45.0));\n    d = max(-p.x,d);\n    p = prevP;\n    float mask = sdBox(p-vec3(-0.7,0.35,0.0),vec3(1.0,0.15,0.5));\n    d = max(-mask,d);\n    return d;\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    float animate = sin(iTime*2.0)*0.1;\n    float d = threeDF((p-vec3(0.1+animate,0.3+animate*0.5,0.0)));\n    p*=-1.0;\n    float d2 = threeDF((p-vec3(0.1+animate,0.3+animate*0.5,0.0)));\n    d = min(d,d2);\n    vec4 res = vec4(vec3(1.0),d);\n\n    vec4 model = res;\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,5,-3);\n    \n    lightPos.yz *= Rot(radians(-30.0));\n    lightPos.xz *= Rot(iTime*1.5+1.0);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.6;\n    \n    return vec2((lambert+dif),max(0.9, 1.0)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat animationMask(vec2 p, float speed){\n    float t = mod(iTime*speed,360.0);\n    float rad = radians(t);\n    float d = sdPie(p,vec2(sin(rad),cos(rad)),0.15);\n    return d;\n}\n\nfloat charF(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float size = 0.1;\n    float d = sdBox(p,vec2(size));\n    p*=Rot(radians(45.0));\n    d = max(p.x,d);\n    p = prevP;\n    float mask = sdBox(p-vec2(0.06,0.025),vec2(0.1,0.015));\n    d = max(-mask,d);\n    \n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat charU(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.03;\n    float size = 0.1;\n    float d = abs(length(p)-(size-w))-w;\n    d = max(p.y,d);\n    float d2 = sdBox(p,vec2(size));\n    d2 = max(-p.y,d2);\n    float mask = sdBox(p,vec2(w*1.34,size+0.1));\n    d2 = max(-mask,d2);\n    d = min(d,d2);\n    p*=Rot(radians(45.0));\n    p.x+=0.075;\n    d = max(-p.x,d);\n    \n    p = prevP;\n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat charT(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.03;\n    float size = 0.1;\n    float d = sdBox(p,vec2(size));\n    \n    float mask = sdBox(p-vec2(0.031,-0.031),vec2(0.071));\n    d = max(-mask,d);\n    \n    p*=Rot(radians(45.0));\n    p.x+=0.075;\n    d = max(-p.x,d);\n    \n    p = prevP;\n    p*=Rot(radians(45.0));\n    d = max(p.x,d);\n    \n    p = prevP;\n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat charR(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.025;\n    float size = 0.11;\n    float d = abs(length(p-vec2(0.032,0.032))-((size-w)*0.5))-w;\n    d = max(-p.x+0.04,d);\n    float d2 = sdBox(p-vec2(-0.0302,0.032),vec2(0.07,0.067));\n    d = min(d,d2);\n    float mask = sdBox(p-vec2(-0.032,0.032),vec2(0.074,0.0155));\n    d = max(-mask,d);\n    d2 = sdBox((p-vec2(0.042,-0.07))*Rot(radians(-40.0)),vec2(0.025,0.08));\n    d = min(d,d2);\n    mask = sdBox(p,vec2(0.1));\n    d = max(mask,d);\n    p*=Rot(radians(45.0));\n    p.x+=0.082;\n    d = max(-p.x,d);\n    \n    p = prevP;\n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat charE(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.025;\n    float size = 0.1;\n    float d = sdBox(p,vec2(size));\n    p.y = abs(p.y);\n    p.y-=0.032;\n    float mask = sdBox(p-vec2(0.03,0.0),vec2(0.072,0.012));\n    d = max(-mask,d);\n    p = prevP;\n    mask = sdBox(p-vec2(0.07,0.0),vec2(0.05,0.03));\n    d = max(-mask,d);\n    d = max(p.x-0.06,d);\n    p*=Rot(radians(45.0));\n    p.x+=0.082;\n    d = max(-p.x,d);\n    p = prevP;\n    p.x-=0.1;\n    p*=Rot(radians(45.0));\n    d = max(p.x,d);\n    \n    p = prevP;\n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat future(vec2 p, int animate){\n    float d = charF(p-vec2(-0.5,0.0),animate,90.0);\n    float d2 = charU(p-vec2(-0.36,0.0),animate,80.0);\n    d = min(d,d2);\n    d2 = charT(p-vec2(-0.14,0.0),animate,70.0);\n    d = min(d,d2);\n    d2 = charU(p-vec2(0.,0.0),animate,60.0);\n    d = min(d,d2);\n    d2 = charR(p-vec2(0.22,0.0),animate,50.0);\n    d = min(d,d2);\n    d2 = charE(p-vec2(0.44,0.0),animate,40.0);\n    d = min(d,d2);\n    return d;\n}\n\nfloat background(vec2 p, int animate){\n    p*=6.0;\n    \n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    float n = Hash21(id);\n    \n    float width = 0.15;\n    \n    if(n<.5)gv*=-1.0;\n    if(n>=.5 && n<0.7)gv*=Rot(radians(90.0));\n    if(n>=.7)gv*=Rot(radians(-90.0));\n    \n    gv*=0.2;\n    float d = charF(gv,animate,70.0);\n    if(n>.2 && n<.4) {\n        d = charU(gv,animate,50.0);\n    }\n    if(n>=.4 && n<.6) {\n        d = charR(gv,0,30.0);\n    }\n    if(n>=.8 && n<.9) {\n        d = charT(gv,animate,60.0);\n    }\n    if(n>=.9) {\n        d = charE(gv,0,30.0);\n    }\n    return d;\n}\n\nvec3 twoDRender(vec2 uv) {\n    vec2 prevUV = uv;\n    vec3 col = vec3(0.1,0.2,0.3);\n    uv.y-=iTime*.1;\n    float bg = background(uv,0);\n    col = mix(col,vec3(0.5),S(bg,0.0));\n    bg = background(uv,1);\n    col = mix(col,vec3(0.8),S(bg,0.0));\n    \n    uv = prevUV;\n    \n    float y = 0.2;\n    float d = future(uv-vec2(0.06,y-0.01),0);\n    \n    col = mix(col,vec3(0.2),S(d,0.0));\n    d = future(uv-vec2(0.055,y),0);\n    col = mix(col,vec3(1,1,0.1),S(d,0.0));\n    uv = prevUV;\n    d = future(uv-vec2(0.055,y),1);\n    col = mix(col,vec3(0.8,0.9,0.2),S(d,0.0));\n    return col;\n}\n\nvec3 Bg(vec3 rd, vec3 bcol) {\n    float k = rd.y*0.7+1.5;\n    vec3 col = mix(bcol,vec3(1.0,0.8,.0),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    //uv.x+=sin(floor(uv.y*500.0)*iTime*20.)*0.002;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -10);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-20.0));\n    ro.xz *= Rot(iTime*1.2);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1.5,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    vec3 bgCol = twoDRender(uv);\n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),30.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(Bg(r,bgCol),vec3(dif),0.5)+spec;\n        //col += d.rgb;\n    } else {\n        // background\n        col += bgCol;\n    }\n    \n    fragColor = vec4(col*0.8,1.0)+(noise(uv.x*uv.y*iTime*0.1))*0.12;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSXzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[623, 623, 654, 654, 741], [743, 743, 766, 766, 1008], [1010, 1010, 1032, 1032, 1339], [1341, 1341, 1374, 1374, 1627], [1629, 1629, 1653, 1653, 1854], [1856, 1856, 1879, 1879, 2269], [2271, 2271, 2313, 2313, 2508], [2510, 2510, 2532, 2532, 2606], [2608, 2608, 2630, 2630, 2720], [2722, 2722, 2759, 2759, 2839], [2841, 2841, 2890, 2890, 3058], [3060, 3060, 3101, 3101, 3236], [3238, 3238, 3285, 3285, 3620], [3622, 3622, 3669, 3669, 4136], [4138, 4138, 4185, 4185, 4632], [4634, 4634, 4681, 4681, 5344], [5346, 5346, 5393, 5393, 5992], [5994, 5994, 6028, 6028, 6432], [6434, 6434, 6472, 6472, 7027], [7029, 7029, 7055, 7055, 7604], [7606, 7606, 7635, 7635, 7726], [7728, 7728, 7785, 7785, 8724]]}
{"id": "NdBSzm", "name": "Worm tunnels", "author": "jarble", "description": "Another bizarre cellular automaton rule.", "tags": ["automata", "feedback", "swarm", "cellularautomata"], "likes": 5, "viewed": 306, "published": 3, "date": "1619852055", "time_retrieved": "2024-07-30T19:22:28.141272", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 2.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 7.0;\n\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = A/2.0;\nconst float NUM_NEIGH = A;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum += GET(d);\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL + ((cen-NUM_NEIGH) * (sum-cen));\n        hash = (hash - sum)/2.0;\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBSzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]]}
{"id": "fdBXRR", "name": "Raymarching blobby sphere", "author": "disambiguator", "description": "adapted from https://www.shadertoy.com/view/Xtd3z7", "tags": ["raymarching"], "likes": 3, "viewed": 271, "published": 3, "date": "1619847270", "time_retrieved": "2024-07-30T19:22:29.068792", "image_code": "/**\n * Part 3 Challenges\n * - Make the camera move up and down while still pointing at the cube\n * - Make the camera roll (stay looking at the cube, and don't change the eye point)\n * - Make the camera zoom in and out\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159;\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p, vec3 eye) { \n    float v = sin(iTime) > 0. ? p.x : p.y;\n    \n    float jitter = sin(10.*sin(iTime)*v*PI/2.)/15.;\n\n    return length(p) +\n        jitter -\n       (1. + sin(20.*sin(iTime + PI/2.)*p.x*PI/2.))/20.-\n        1.5;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint, vec3 eye) {\n    return cubeSDF(samplePoint, eye);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection, eye);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p, vec3 eye) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), eye) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), eye),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), eye) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), eye),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON), eye) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), eye)\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p, eye);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(5.0 * sin(iTime/3.), 8.0 * sin(iTime/3.), 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(p.x, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, p.y, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, p.z);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBXRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 482, 515, 515, 729], [731, 971, 1015, 1015, 1055], [1057, 1478, 1569, 1569, 1880], [1895, 2149, 2214, 2214, 2346], [2348, 2437, 2476, 2476, 2816], [2818, 3310, 3450, 3450, 4045], [4047, 4417, 4502, 4502, 5302], [5304, 5631, 5680, 5715, 5941], [5943, 5943, 6000, 6000, 6875]]}
{"id": "NdBXRm", "name": "Bubbling slime", "author": "jarble", "description": "Another bizarre cellular automaton rule.", "tags": ["automata", "feedback", "swarm", "cellularautomata"], "likes": 3, "viewed": 316, "published": 3, "date": "1619845153", "time_retrieved": "2024-07-30T19:22:29.976366", "image_code": "// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / 2.0), 0).x;\n    \n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define GET(d) texelFetch(iChannel0, ivec2(mod(fragCoord + vec2(d) + res, res)), 0).x\n\n// Change these constants to adjust behavior of CA\nconst float A = 7.0;\n\n\n// Alternatively, you might change how 'hash' is computed instead\n\nconst float MAX_VAL = A/2.0;\nconst float NUM_NEIGH = A;\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n\n    if (iFrame > 0) {\n    \tivec2 d;\n        \n        float cen = GET(vec2(0.0, 0.0));\n        float sum = 0.0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++)\n            \tsum += GET(d);\n\n        // Value used to choose next state of the cell\n        float hash = A * MAX_VAL + ((cen-NUM_NEIGH) * (sum+cen*NUM_NEIGH));\n        //hash = (hash + sum)/2.0;\n        float min_dist = 100000.0, val;\n        \n        // Find neighbor with value closest to 'hash'\n        for(d.y = -1; d.y <= +1; d.y++)\n            for(d.x = -1; d.x <= +1; d.x++){\n                float new_val = GET(d);\n                if (abs(new_val - hash) < min_dist){\n                    min_dist = abs(new_val - hash);\n                    val = new_val;\n                }\n            }\n\n        // Copy its state\n        fragColor.x = val;\n    } else {\n        // Randomize initial state on zeroth frame\n        fragColor.x = noise(fragCoord/res);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.x = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    else\n        fragColor.x = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 39, 95, 95, 284]]}
{"id": "NsSXRm", "name": "Tetrahedral Barycentric Coords", "author": "oneshade", "description": "Barycentric coordinates within a tetrahedron. I'm planning to use this to make a planar marching cubes SDF operator.", "tags": ["3d", "barycentric", "interpolation", "systemofequations", "tetrahedral"], "likes": 7, "viewed": 297, "published": 3, "date": "1619843410", "time_retrieved": "2024-07-30T19:22:31.030547", "image_code": "#define t1 iTime\n#define t2 iTime * 1.25\n#define t3 iTime * 1.5\n\n#define cs1 vec2(cos(t1), sin(t1))\n#define cs2 vec2(cos(t2), sin(t2))\n#define cs3 vec2(cos(t3), sin(t3))\n\n// Tetrahedron vertices\n#define tet1 vec3(-1.5, -1.5, -1.5) + vec3(cs1.x, cs2.y, cs3.y)\n#define tet2 vec3(1.5, -1.5, -1.5) + vec3(cs3.y, cs2.x, cs1.y)\n#define tet3 vec3(0.0, -1.5, 1.5) + vec3(cs1.y, cs2.x, cs2.x)\n#define tet4 vec3(0.0, 1.5, 0.0) + vec3(cs2.x, cs1.x, cs3.y)\n\n// https://iquilezles.org/articles/distfunctions\nfloat dot2(in vec3 v) { return dot(v, v); }\nfloat sdTriangle(in vec3 p, in vec3 a, in vec3 b, in vec3 c) {\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n        (sign(dot(cross(ba, nor), pa)) +\n         sign(dot(cross(cb, nor), pb)) +\n         sign(dot(cross(ac, nor), pc)) < 2.0)\n         ?\n         min(min(\n         dot2(ba * clamp(dot(ba, pa) / dot2(ba), 0.0, 1.0) - pa),\n         dot2(cb * clamp(dot(cb, pb) / dot2(cb), 0.0, 1.0) - pb)),\n         dot2(ac * clamp(dot(ac, pc) / dot2(ac), 0.0, 1.0) - pc))\n         :\n         dot(nor, pa) * dot(nor, pa) / dot2(nor));\n}\n\n// Solve 4x4 linear system by hand (some annoying edge cases)\n// a.xu + b.xv + c.xw + d.xk = p.x\n// a.yu + b.yv + c.yw + d.yk = p.y\n// a.zu + b.zv + c.zw + d.zk = p.z\n// u + v + w + k = 1\nvec4 bary4(in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4) {\n    vec3 c11 = v1 - v4, c21 = v2 - v4, c31 = v3 - v4, c41 = v4 - p;\n\n    vec2 m1 = c31.yz / c31.x;\n    vec2 c12 = c11.yz - c11.x * m1, c22 = c21.yz - c21.x * m1, c32 = c41.yz - c41.x * m1;\n\n    vec4 uvwk = vec4(0.0);\n    float m2 = c22.y / c22.x;\n    uvwk.x = (c32.x * m2 - c32.y) / (c12.y - c12.x * m2);\n    uvwk.y = -(c32.x + c12.x * uvwk.x) / c22.x;\n    uvwk.z = -(c41.x + c21.x * uvwk.y + c11.x * uvwk.x) / c31.x;\n    uvwk.w = 1.0 - uvwk.z - uvwk.y - uvwk.x;\n\n    return uvwk;\n}\n\n// Lazy way\n//vec4 bary4(in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4) {\n//    return vec4(p, 1.0) * inverse(mat4(v1.x, v2.x, v3.x, v4.x,\n//                                       v1.y, v2.y, v3.y, v4.y,\n//                                       v1.z, v2.z, v3.z, v4.z,\n//                                        1.0,  1.0,  1.0,  1.0));\n//}\n\n// Codegolfed\n//#define bary4(p, a, b, c, d) vec4(p, 1) * inverse(transpose(mat4(a, 1, b, 1, c, 1, d, 1)))\n\nfloat mapScene(in vec3 p) {\n    float scene = sdTriangle(p, tet4, tet1, tet2);\n    scene = min(scene, sdTriangle(p, tet4, tet2, tet3));\n    scene = min(scene, sdTriangle(p, tet4, tet3, tet1));\n    scene = min(scene, sdTriangle(p, tet1, tet2, tet3));\n    return scene - 0.05;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    float time = iTime;\n\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 6.28;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p);\n        if (d < 0.001) {\n            vec4 bary = bary4(p, tet1, tet2, tet3, tet4);\n            fragColor.rgb = bary.xyz * (1.0 - bary.w) + bary.w;\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSXRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 495, 518, 518, 538], [539, 539, 601, 601, 1185], [1187, 1375, 1446, 1446, 1929], [2392, 2392, 2419, 2419, 2668], [2670, 2670, 2697, 2697, 2944], [2946, 2946, 3001, 3001, 3938]]}
{"id": "fsSSzw", "name": "GalaxyRipple", "author": "Del", "description": "ripple nebula FBM voronoi", "tags": ["voronoi", "fbm", "nebula", "ripple"], "likes": 12, "viewed": 614, "published": 3, "date": "1619823562", "time_retrieved": "2024-07-30T19:22:32.158531", "image_code": "// galaxy ripple nebula effect\n//#define PROCEDURAL_HASH\n\n#ifdef PROCEDURAL_HASH\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n#else\nvec3 hash33( vec3 x )\n{\n\treturn texture( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, -100.0 ).xyz;\n}\n#endif\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.05);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n#define TWO_PI 6.2831853\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float dd = length(uv*uv)*.025;\n    \n\tvec3 rd = vec3(uv.x, uv.y, 1.0);\n    \n    float rip = 0.5+sin(length(uv)*20.0+iTime)*0.5;\n    rip = pow(rip*.38,4.15);\n    rd.z=1.0+rip*1.15;// apply a subtle ripple\n    rd = normalize(rd);\n    rd.xy *= rot(dd-iTime*.025);\n    rd*=2.0;\n\t\n\tfloat c = noiseLayers(rd*1.85);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.55,2.5);    \n    vec3 col =  vec3(.55,0.5,1.25);\n    vec3 col2 =  vec3(1.95,0.95,1.4)*5.0;\n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSSzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[429, 449, 471, 471, 868], [870, 883, 913, 913, 1186], [1188, 1188, 1209, 1209, 1277], [1305, 1305, 1362, 1362, 2100]]}
{"id": "NdBXRw", "name": "Bilinear Patch Ray Intersection", "author": "oneshade", "description": "This was a lot of fun (3x3 system of equations)! I've been trying to figure out how to do it for a while.", "tags": ["raytracing", "ray", "raycasting", "intersection", "parametric", "bilinear", "patch", "systemofequations"], "likes": 13, "viewed": 219, "published": 3, "date": "1619822242", "time_retrieved": "2024-07-30T19:22:33.002275", "image_code": "// Comment out to see the entire surface\n#define ONLY_PATCH\n\nstruct PatchIsect {\n    bool hit;\n    vec2 t;\n    vec2[2] uv;\n    vec3[2] nor;\n};\n\n// Bilinear patch intersection\n// Parametric equation: mix(mix(a, d, u), mix(b, c, u), v)\n// ---> (a - b + c - d)uv + (d - a)u + (b - a)v + a\n// Involves solving a 3x3 system that has two or no solutions\n// Vertices are expected to be winding in counterclockwise order\nfloat cross2D(in vec2 a, in vec2 b) { return a.y * b.x - a.x * b.y; }\nPatchIsect iBilinearPatch(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    vec2 m = rd.yz / rd.x;\n    vec3 p = a - b + c - d, q = d - a, r = b - a;\n    vec2 c1 = p.yz - p.x * m, c2 = q.yz - q.x * m, c3 = r.yz - r.x * m;\n    vec2 c4 = (ro.x - a.x) * m + a.yz - ro.yz;\n\n    // Quadratic coefficients (reversed as a trick to deal with edge cases)\n    float qa = cross2D(c4, c2);\n    float qb = cross2D(c4, c1) + cross2D(c3, c2);\n    float qc = cross2D(c3, c1);\n\n    float discr = qb * qb - 4.0 * qa * qc;\n    if (discr > 0.0) {\n        vec2 v = 2.0 * qa / (vec2(-1.0, 1.0) * sqrt(discr) - qb); // Solve for v parameter\n        vec2 u = -(c4.x + c3.x * v) / (c1.x * v + c2.x); // Substitute v and solve for u parameter\n        vec2 t = (p.x * u * v + q.x * u + r.x * v + a.x - ro.x) / rd.x; // Substitute u and v and solve for t parameter\n\n        // Compute normals (cross products of partial derivatives)\n        vec3 n1 = normalize(cross(p * v.x + q, p * u.x + r));\n        vec3 n2 = normalize(cross(p * v.y + q, p * u.y + r));\n\n        return PatchIsect(true, t, vec2[2](vec2(u.x, v.x), vec2(u.y, v.y)), vec3[2](n1, n2));\n    }\n\n    return PatchIsect(false, vec2(-1.0), vec2[2](vec2(0.0), vec2(0.0)), vec3[2](vec3(0.0), vec3(0.0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Environment map\n    fragColor = texture(iChannel0, rd);\n\n    // Patch vertices\n    float t1 = iTime, t2 = iTime * 2.0, t3 = iTime * 2.5;\n\n    float c1 = cos(t1), s1 = sin(t1);\n    float c2 = cos(t2), s2 = sin(t2);\n    float c3 = cos(t3), s3 = sin(t3);\n\n    vec3 a = vec3(-1.5, -1.5, -0.5) + vec3(c1, c2, s3) * 0.5;\n    vec3 b = vec3(-1.5,  1.5,  0.5) + vec3(s2, c1, s3) * 0.5;\n    vec3 c = vec3( 1.5,  1.5, -0.5) + vec3(s2, c3, c1) * 0.5;\n    vec3 d = vec3( 1.5, -1.5,  0.5) + vec3(c2, s3, s1) * 0.5;\n\n    // Find the closest hit in front of the camera\n    PatchIsect isect = iBilinearPatch(ro, rd, a, b, c, d);\n    if (isect.hit) {\n        float dist = -1.0;\n        vec3 pos, nor;\n        vec2 patchUv;\n        for (int n=0; n < 2; n++) {\n            #ifdef ONLY_PATCH\n            bool inPatch = all(lessThan(abs(isect.uv[n] - 0.5), vec2(0.5)));\n            #else\n            bool inPatch = true;\n            #endif\n\n            if (isect.t[n] > 0.0 && (dist < 0.0 ? true : isect.t[n] < dist) && inPatch) {\n                dist = isect.t[n];\n                pos = ro + rd * isect.t[n];\n                nor = isect.nor[n];\n                patchUv = isect.uv[n];\n            }\n        }\n\n        // Render the shape if hitting\n        if (dist > 0.0) {\n            vec3 light = -rd;\n            float diff = abs(dot(nor, light));\n            float checkers = 0.5 + 0.5 * mod(dot(floor(patchUv * 8.0), vec2(1.0)), 2.0);\n            fragColor = mix(vec4(checkers, 0.0, 0.0, 1.0), texture(iChannel0, reflect(-rd, nor)), 0.25);\n            fragColor.rgb *= diff;\n        }\n    }\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.75));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBXRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 413, 450, 450, 482], [483, 483, 578, 578, 1742], [1744, 1744, 1799, 1799, 3975]]}
