{"id": "7ttfRM", "name": "Rounded Rectangle with border", "author": "i509VCB", "description": "Rounded rectangle with borders drawn using an SDF. ", "tags": ["sdf", "rectangle", "rounded"], "likes": 5, "viewed": 968, "published": 3, "date": "1664573111", "time_retrieved": "2024-07-30T16:28:48.198522", "image_code": "// The size of the shape as a ratio.\n//\n// One value must always be 1.0. The other value may be greater than 1.0 to create a rectangle.\nconst vec2 size = vec2(1.0, 1.0);\n\n// The radius in a fraction.\n//\n// A value of 0.0 indicates that a quad should be drawn.\n// A value of 1.0 indicates that the radius of the curves should occupy the entire width or height (whichever is shorter).\n// Values between 0.0 and 1.0 will result in a quad with curved edges.\nconst float radius = 0.15;\n\n// The thickness of the shape.\n//\n// A thickness of 1.0 means the shape will be solid.\n// A thickness of 0.0 means the shape will be invisible.\n//\n// Note: With smaller values for radius, the inner border might be a right angle.\nconst float thickness = 0.05;\n\n// The fade applied to edges of the shape.\n//\n// This value is used to smooth the edges of the shape and remove jagged edges.\n//\n// A fade of 0.0 will not smooth the shape.\n// High fade values will cause the shape to become invisible.\nconst float fade = 0.006;\n\nfloat _distance(vec2 position, vec2 size, float radius) {\n    return length(max(abs(position) - size + radius, 0.0)) - radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 0 -> 1 local space, adjusted for aspect ratio\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    // Subtract half the fade to ensure the rectangle is not clipped.\n    vec2 size = size - (fade / 2.0);\n\n    // Calculate distance and fill circle with white\n    float distance = _distance(uv, size, radius);\n    float smoothed_alpha = 1.0 - smoothstep(0.0, fade, distance);\n    float border_alpha = 1.0 - smoothstep(thickness - fade, thickness, abs(distance));\n\n    vec4 bg_color = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 rect_color = vec4(0.85, 0.35, 0.2, 1.0);\n\n    // Set output color\n    fragColor = mix(bg_color, mix(bg_color, rect_color, border_alpha), smoothed_alpha);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1004, 1004, 1061, 1061, 1132], [1134, 1134, 1189, 1242, 1943]], "test": "untested"}
{"id": "NtyfRR", "name": "Raymarcher with movement", "author": "fishy", "description": "Phong distribution for the specular highlights. Now with ACES tonemapping from https://www.shadertoy.com/view/XsGfWV. Still working on adding a sky. Mouse, WASD, Space and Shift to move\nSkybox reflections!", "tags": ["shadow", "raymarcher", "penumbra", "diffuse"], "likes": 2, "viewed": 249, "published": 3, "date": "1664568862", "time_retrieved": "2024-07-30T16:28:48.970459", "image_code": "#define PI 3.1415926535\n\n#define AMBIENT 0.2\n#define SHADOW_STRENGTH 0.5\n#define SHADOW_K 4.0\n#define AO_DIST 0.03\n#define AO_STRENGTH 0.5\n\n#define FRESNEL_IOR 2.0\n#define FRESNEL_BASE 0.2\n\nstruct material\n{\n    vec3 baseColor;\n    float roughness;\n    float reflectivity;\n    int matOverride;\n};\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\n\nvec3 rotX(vec3 p, float r)\n{\n    return vec3(p.x, p.yz * rotMat(r));\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    vec2 t = p.xz * rotMat(r);\n    return vec3(t.x, p.y, t.y);\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    return vec3(p.xy * rotMat(r), p.z);\n}\n\nvec3 lightingDir = normalize(vec3(0.0, 1.0, 1.0));\n\nvec3 evaluateMatOverride(int i, vec3 p, vec3 n, vec3 vDir, material mat)\n{\n    vec3 c;\n    switch (i)\n    {\n        case 0:\n            c = mix(skyTex(reflect(vDir, n), lightingDir).rgb, mat.baseColor, FRESNEL_BASE+pow(abs(dot(normalize(vDir), n)), FRESNEL_IOR)*(1.-FRESNEL_BASE));\n            break;\n        case 1:\n            c = texture(iChannel3, vec2(p.x+p.y, p.z)).rgb;\n            break;\n        case 2:\n            c = pow(texture(iChannel1, n).rgb, vec3(1./2.2));\n            break;\n    }\n    return c;\n}\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\nfloat perlinNoise1(float x)\n{\n    return mix(hash11(floor(x)), hash11(floor(x) + 1.0), erp(fract(x), 2.0)) - 0.5;\n}\n\n\n\n\nvec3 aces_tonemap(vec3 color) // https://www.shadertoy.com/view/XsGfWV\n{\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nfloat calcSpecular(vec3 e, vec3 n, vec3 l, float p)\n{\n    return pow(clamp(dot(l, reflect(e, n)), 0.0, 1.0), p);\n}\n\nfloat join(inout float a, float b, material bm, inout material m)\n{\n    if(a < b)\n    {\n        return a;\n    }\n    else\n    {\n        m = bm;\n        return b;\n    }\n    \n}\n\nfloat sdPlane(vec3 p, float y)\n{\n    return (p.y - y);\n}\n\nfloat sdSphere(vec3 p, vec3 pos, float r)\n{\n    return length(p - pos) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec3 p, vec3 b, vec3 bPos )\n{\n    return sdBox(p - bPos, b);\n}\nfloat sdCross( in vec3 p )\n{\n    float da = sdBox(p.xyz,vec3(100000.0,1.0,1.0));\n    float db = sdBox(p.yzx,vec3(1.0,100000.0,1.0));\n    float dc = sdBox(p.zxy,vec3(1.0,1.0,100000.0));\n    return min(da,min(db,dc));\n}\n\nfloat sdMenger(vec3 p)\n{\n    float d = sdBox(p,vec3(1.0));\n\n    float s = 1.0;\n    \n    for( int m=0; m<4; m++ )\n    {\n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = 1.0 - 3.0*abs(a);\n\n        float c = sdCross(r)/s;\n        d = max(d,c);\n    }\n\n    return d;\n}\n\nfloat sceneDist(vec3 p, out material m)\n{\n    p.y -= 0.3;\n    m = material(vec3(0.0, 0.0, 1.0), 1.0, 1.0, 0);\n    float dist = sdSphere(p, vec3(0.3, cos(iTime)*0.1, 2.0), 0.2);\n    \n    dist = join(dist, sdSphere(p, vec3(-0.3, sin(iTime)*0.1, 2.0), 0.2),\n                material(vec3(0.0, 0.5, 1.0), 8.0, 0.0, 2), m);\n    \n    dist = join(dist, sdBox(p, vec3(0.5, 0.06, 0.5), vec3(0.0,-0.3, 2.0)) - 0.02,\n                material(vec3(1.0, 0.0, 0.0), 8.0, 1.0, -1), m);\n    \n    dist = join(dist, sdMenger(p / 0.5 - vec3(0.5, 0.4, 8.0)) * 0.5,\n                material(vec3(1.0, 1.0, 1.0), 8.0, 1.0, 0), m);\n    p.y += 0.3;\n    dist = join(dist, sdPlane(p, 0.0),\n                material(vec3(0.2, 0.5, 0.05), 1.0, 0.0, -1), m);\n    \n    return dist;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    material m;\n    const float h = 0.0001;      // replace by an appropriate value\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sceneDist(p+e*h, m);\n    }\n    return normalize(n);\n}\n\nfloat calcAO(vec3 p, float dist)\n{\n    material m;\n    return 1.0 - sceneDist(p + dist*calcNormal(p), m) / dist;\n}\n\nvoid march(vec3 dir, inout vec3 p, int maxSteps, float minDist, out bool hit, out float depth, out vec3 normal, out material m)\n{\n    vec3 oldP = p;\n    depth = 0.0;\n    for(int i = 0; i < maxSteps; i++)\n    {\n        depth = sceneDist(p, m);\n        p += depth*dir;\n        hit = depth < minDist;\n        if(hit)\n        {\n            normal = calcNormal(p);\n            depth = distance(oldP, p);\n            return;\n        }\n    }\n    normal = calcNormal(p);\n}\n\nvoid marchShadow(vec3 dir, vec3 p, int maxSteps, float minDist, out float inShadow, float k)\n{\n    vec3 oldP = p;\n    float dist = 0.002;\n    float totalDist = dist;\n\n    p += dist*dir;\n    inShadow = 1.0;\n    material m = material(vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0);\n    for(int i = 0; i < maxSteps; i++)\n    {\n        dist = sceneDist(p, m);\n        totalDist += dist;\n\n        if(dist < minDist)\n        {\n            inShadow = 1.0;\n            return;\n        }\n        \n        p += dist*dir;\n        inShadow = min(inShadow, k*dist/totalDist);\n    }\n    inShadow = 1.0-inShadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 c = texture(iChannel0, vec2(0.0)).rgb;\n\n    vec3 eyeDir = normalize(vec3(uv * vec2(1.0, 1.0), 1.0));\n    vec2 mouse = iMouse.z > 0.0?iMouse.xy/iResolution.xy * 8.0 - 4. : vec2(perlinNoise1(iTime*1.0 + 100.0), perlinNoise1(iTime*1.0)) * 0.0;\n    eyeDir = rotX(eyeDir, -mouse.y);\n    eyeDir = rotY(eyeDir, -mouse.x);\n    vec3 eyePos = vec3(c.y, -c.z, c.x);\n\n    lightingDir = normalize(rotX(vec3(0.0, 0.0, -1.0), (sin(iTime*0.2)+1.)*PI*0.5));\n\n    \n    bool hit = false;\n    float depth = 0.0;\n    vec3 normal = vec3(0.0);\n    material hitMat;\n    march(eyeDir, eyePos, 512, 0.0001, hit, depth, normal, hitMat);\n    float ao = calcAO(eyePos, AO_DIST);\n    if(hitMat.matOverride > -1)\n    {\n        hitMat.baseColor = evaluateMatOverride(hitMat.matOverride, eyePos, normal, eyeDir, hitMat);\n    }\n    float fresnel = FRESNEL_BASE+pow(abs(dot(normalize(eyeDir), normal)), FRESNEL_IOR)*(1.-FRESNEL_BASE);\n    hitMat.baseColor = mix(hitMat.baseColor, mix(skyTex(reflect(eyeDir, normal), lightingDir).rgb, hitMat.baseColor, fresnel), hitMat.reflectivity);\n    \n    float inShadow = 0.0;\n    marchShadow(lightingDir, eyePos, 32, 0.00001, inShadow, SHADOW_K);\n    \n    //lightingDir = vec3(0.0, 1.0, 0.0);\n    float lighting = max(0.0, dot(normal, lightingDir));\n    float specular = calcSpecular(eyeDir, normal, lightingDir, 8.0 * hitMat.roughness);\n    specular = clamp(specular, 0.0, 1.0);\n    inShadow *= float(hit);\n    inShadow = mix(0.0, inShadow, SHADOW_STRENGTH);\n\n    vec3 color = (vec3(lighting + specular) * hitMat.baseColor) * (1.0-inShadow);\n    color = mix(color, vec3(0.0), pow(min(1.0, depth / 16.0), 1.3));\n    color = mix(color, hitMat.baseColor, AMBIENT);\n    \n    color *= 1.0 - ao*AO_STRENGTH;\n    color = hit? color : skyTex(eyeDir, lightingDir).rgb;\n    color = aces_tonemap(color);\n\n    //fragColor = vec4(vec3(pow(ao, 1.0)),1.0);\n    fragColor = vec4(color,1.0);\n    //fragColor = vec4(eyeDir.xy,0.0, 1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int keyW = 87;\nconst int keyA = 65;\nconst int keyS = 83;\nconst int keyD = 68;\n\nconst int keySpace = 16;\nconst int keyShift = 32;\n\n\n\nfloat keyPressed(int keyCode)\n{\n    return texelFetch(iChannel0, ivec2(keyCode, 0), 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 keyVec = texture(iChannel1, uv);\n    \n    if(iTime < 0.1)\n    {\n        keyVec = vec4(0.0, 0.0, -0.3, 0.0);\n    }\n    \n    keyVec.x += (keyPressed(keyW) - keyPressed(keyS)) * iTimeDelta;\n    keyVec.y += (keyPressed(keyD) - keyPressed(keyA)) * iTimeDelta;\n    keyVec.z += (keyPressed(keySpace) - keyPressed(keyShift)) * iTimeDelta;\n    \n    fragColor = keyVec;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 skyTex(vec3 ray, vec3 sun)\n{\n    ray.y = abs(ray.y);\n    float raySun = dot(ray,sun);\n    \n    vec3 col = exp2(-(ray.y-raySun*0.5)/vec3(.1,.3,.6)); // Base gradient\n    col *= sqrt(max(0.00001, dot(vec3(sun.x, sun.y+0.3, sun.z), vec3(0.0, 1.0, 0.0)))); //Darken the sky the lower the sun is\n    return mix(col, vec3(10.0, 3.0, 0.2), smoothstep(0.9995, 1.0, max(0.0, raySun))) * sqrt(max(0.0, (dot(abs(ray+0.03), vec3(0.0, 1.0, 0.0))))); // Sun disc\n}", "cube_a_code": "vec3 SkyColour( vec3 ray )\n{\n    return exp2(-ray.y/vec3(.1,.3,.6)); // blue\n//    return exp2(-ray.y/vec3(.18,.2,.28))*vec3(1,.95,.8); // overcast\n//    return exp2(-ray.y/vec3(.1,.2,.8))*vec3(1,.75,.5); // dusk\n//    return exp2(-ray.y/vec3(.03,.2,.9)); // tropical blue\n//    return exp2(-ray.y/vec3(.4,.06,.01)); // orange-red\n//    return exp2(-ray.y/vec3(.1,.2,.01)); // green\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    rayDir.y = abs(rayDir.y);\n    fragColor = vec4(SkyColour(rayDir),1.0);\n}", "cube_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 298, 319, 319, 368], [371, 371, 399, 399, 441], [443, 443, 471, 471, 536], [538, 538, 566, 566, 608], [662, 662, 736, 736, 1176], [1179, 1179, 1202, 1202, 1287], [1289, 1289, 1318, 1318, 1393], [1395, 1395, 1424, 1424, 1510], [1515, 1515, 1587, 1587, 2034], [2036, 2036, 2089, 2089, 2150], [2152, 2152, 2219, 2219, 2325], [2327, 2327, 2359, 2359, 2383], [2385, 2385, 2428, 2428, 2462], [2464, 2464, 2495, 2495, 2586], [2588, 2588, 2630, 2630, 2663], [2664, 2664, 2692, 2692, 2881], [2883, 2883, 2907, 2907, 3170], [3172, 3172, 3213, 3213, 3925], [3927, 3927, 3978, 3978, 4320], [4322, 4322, 4356, 4356, 4436], [4438, 4438, 4567, 4567, 4902], [4904, 4904, 4998, 4998, 5490], [5492, 5492, 5549, 5599, 7635]], "test": "untested"}
{"id": "fttBDB", "name": "Silent Assimilation", "author": "Dave_Hoskins", "description": "The day Earth's DNA streams changed forever.", "tags": ["3d", "raymarch", "voxel", "mountains", "aliens", "silent", "assimilation"], "likes": 44, "viewed": 781, "published": 3, "date": "1664567157", "time_retrieved": "2024-07-30T16:28:50.009680", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\nvec3 cameraPos, cameraTar;\nvec3 camRay;\nfloat gTime;\nfloat fade;\n\n#define ANG2 1.33\n#define ANG3 1.4\n#define ZERO min(0, iFrame)\nconst mat2 rotMat = mat2(cos(ANG2), sin(ANG3), -sin(ANG3), cos(ANG2)) * 2.;\nconst vec3 MOON_DIR = normalize(vec3(-.5, .4, -.5));\nconst vec3 MOON_DIR2 = normalize(MOON_DIR + vec3(.02, -0.002, 0.0));\n\n#define MOUSE_SCRUB\n\n//----------------------------------------------------------------------------------------------------------\n// Thanks for palette, iq...\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 getColour(float id)\n {\n    \n    return pal(id, vec3(0.25,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n\n}\n\n\nconst int   SEEDS = 50;\nconst float STEP_SIZE = 150.;\n#define SIZE .3\n\n//----------------------------------------------------------------------------------------------------------\nvec2 distanceRayPoint(vec3 ro, vec3 rd, vec3 p)\n{\n    p -= ro;\n    float h = dot(p,rd);\n    return vec2(length(p-rd*h), h);\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getOffset(in vec3 id, float si)\n{\n    return clamp(tri(id+gTime*.1), si*.25, (1.0-si*.25));\n}\n\n// Find a single seed at ground position.\n// Needs surrounding squares to prevent edge cutoff...\n\n//----------------------------------------------------------------------------------------------------------\nvec3 singleSeed(in vec3 ro)\n{\n    ro.y += gTime*250.0+3.; // A very subtle +3 increase for ground lights to arrive early!\n\n    vec3 p = ro / STEP_SIZE, sm3at = vec3(0);\n    float i = 0.0;\n    float sb = .1;\n    vec3 col = vec3(0);\n    \n    vec3 pos = floor(p);\n    for (int z = -1; z <= 1; z++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int x = -1; x <= 1; x++)\n            {\n                vec3 p2     = pos;\n                p2         += vec3(x, y, z);\n                vec3 id     = hash33(p2*19.31);\n                float si    = (id.x+id.z)*.3+.04;\n                vec3 offset = getOffset(id, si);\n                vec3 mat    = getColour(id.x+id.y);\n                p2 += offset;\n                p2-= p;\n                i = dot(p2,p2);\n                if (i < si*.2)\n                {\n                    col += mat*smoothstep(si*.05, 0.0, i)*fade;\n                    i= max((i-si*.15),0.0)*4.;\n                     col += sin(smoothstep(si*.3,si*.1,i)*3.14)*.2*fade;//* smoothstep(si*.1,si*.15,i);//smoothstep(0.014, .013, i)*fade*.4;\n                }\n            }\n        }\n    }\n\n\n    return col;\n}\n\n//----------------------------------------------------------------------------------------------------------\n// Render all seeds...\n// This uses iq's 'Voxel Edges' renderer, it visits every voxel and adds a randomly positioned point,\n// producing a evenly distributed cloud of seeds.\n// I believe I was inspired by iapafoto, who does the same here:\n// https://www.shadertoy.com/view/Xl2BRR\nvec3 floatingSeeds(in vec3 ro, in vec3 rd, in float tmax)\n{ \n \n    vec2 d;\n    ro.y += 250.*gTime; // ...float down\n    \n    ro /= STEP_SIZE;\n\tvec3 pos = floor(ro),\n         ri = 1./rd,\n\t\t rs = sign(rd),\n\t\t dis = (pos-ro + 0.5 +rs*.5) * ri,\n         sum = vec3(0), col = sum;\n    \n\tfor( int i = 0; i < SEEDS; i++ )\n    {\n        vec3 id = hash33(pos*19.31);\n        float si = (id.x+id.z)*.3+.04;\n\n        vec3 offset = getOffset(id, si);\n\n        d = distanceRayPoint(ro, rd, pos+offset);\n        \n        float d2 = d.y * STEP_SIZE - tmax;\n\n        vec3 mat =  getColour(id.x+id.y);\n        \n        if (d2 < 0.0 && d.y > 0.0)\n        {\n            col = mat * pow(smoothstep(si, 0.0,d.x),80.)*15.;\n            col *= fade;\n            sum += col;\n        }\n        fade *= .92;\n        // step through voxel borders...\n\t\tvec3 mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\n\t}\n  \n\treturn sum;\n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat moon(vec3 dir)\n{\n    float d = clamp(pow(max(dot(MOON_DIR, camRay), 0.), 8000.0)*1., 0.0, .002)*1000.;\n    float d2 = pow(max(dot(MOON_DIR2, camRay), 0.), 4000.0)*30.;\n    return clamp(d-d2, 0.0, 1.);\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getSky(vec3 dir)\n{\n\tvec3 col = mix(vec3(FOG_COLOUR), vec3(0.01, 0.01,0.03),clamp((1.-exp(-dir.y))*3., 0.0, 1.));\n\n    col += moon(dir)* vec3(.35,.3,.2);\n    return col;\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 noiseD(in vec2 x) \n{\n    vec2 f = fract(x);\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.*f*f*(f*(f-2.0)+1.);\n\n\tvec4 n = texelFetch(iChannel0, ivec2(floor(x)) & TWRAP, 0);\n\treturn vec3(n.x + n.y * u.x + n.z * u.y + n.w * u.x*u.y,\n\t\t\t\tdu * (n.yz + n.w*u.yx));\n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat terrain( in vec2 p, float z)\n{\n   \n    float a = 0.0;\n    \n    p+= vec2(-260,300);\n    \n    vec2  d = vec2(0.0);\n    float h = length(p);\n\n    // Mountains and flats depending on distance from 0\n    float b = smoothstep(0.0, 2000.0, h)*500.0;\n    b*= (1.0+smoothstep(3000.0,6000.0,h)*.6);\n    \n    p = p*0.0005;\n    \n    // Decrease iteration detail with distance..\n    int iter = 13-int(log2(z*.05+2.0));\n    \n    iter = clamp(iter, 1, 12);\n    \n\tfor (int i = ZERO; i < iter; i++)\n\t{\n       vec3 n = noiseD(p);\n        \n        d += n.yz;\n        a += b*n.x/(.7+dot(d,d));\n\t\tb *= 0.51;\n        p = rotMat*p;\n        //p -= n.yz*.3;\n\t} \n\n\treturn a;\n}\n\n//-------------------------------------------------------------------------------------------------------\nfloat map(vec3 p, float z)\n{\n    return  p.y-terrain(p.xz, z);\n}\n\n//-------------------------------------------------------------------------------------------------------\n// March the whole scene...\n#define FAR 10000.\nfloat rayMarch(in vec3 rO, in vec3 rD, in float t)\n{\n\tfloat d;\n    float adj = .5;// Estimate error adjust starts very small\n\n    for(int j = ZERO; j < 200 && t < FAR; j++)\n\t{\n        d = map(rO + t*rD, t);\n        if (d < .01) break;\n        t += d * adj;\n        adj += .003;\n\t}\n \n\treturn t;\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getNormal(vec3 pos, float ds)\n{\n\n    float c = map(pos, 0.);\n    vec2 eps_zero = vec2(max(ds, .01), 0.0);\n    return normalize(vec3(map(pos + eps_zero.xyy, 0.0),\n                          map(pos + eps_zero.yxy, 0.0),\n                          map(pos + eps_zero.yyx, 0.0)) - c);\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nvec3 getCamera(vec2 uv)\n{\n\n\tcameraPos = vec3(sin(gTime*.37)*300., 500.+sin(gTime)*250., cos(gTime*.83)*300.);\n\tcameraTar = cameraPos+vec3(sin(gTime*.5)*150.,sin(gTime*.33+3.3)*90.-7., cos(gTime*.5)*150.);\n\n    vec3 cw = normalize(cameraTar-cameraPos);\n\tvec3 cu = normalize(cross(cw,vec3(0,1,0)));\n\tvec3 cv = normalize(cross(cu,cw));\n    return normalize(uv.x*cu + uv.y*cv + cw * 1.);\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nvec3 lighting(vec3 p, vec3 nor)\n{\n    float l = max(dot(MOON_DIR, nor), 0.0);\n    vec3 ref = reflect(nor, camRay);\n    l += pow(max(dot(ref, MOON_DIR), 0.0), 30.0);\n    \n    return vec3(l);\n    \n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 material(vec3 p, vec3 nor)\n{\n    vec3 g = texture(iChannel3, p.xz*0.004).xyz;\n    vec3 mat = g*.2+vec3(0,0,.035);\n\n    g = texture(iChannel1, p.xz*0.002).xyz;\n    g = g*vec3(.15,.16,.1);\n    mat  = mix(mat, g, smoothstep(.8, 1.0, nor.y));\n    mat  = mix(mat, vec3(.0,.0,0.0), smoothstep(.9, .8, nor.y) *  smoothstep(.7, .8, nor.y));\n    \n    return mat+vec3(0.04,0.04,nor.y*.1);\n}\n\n//----------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = iTime * .25+272.;\n    #ifdef MOUSE_SCRUB\n    gTime += iMouse.x*30./iResolution.x;\n    #endif\n    gTime += hash12(fragCoord)*.005;\n\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    camRay = getCamera(uv);\n\n\n    fade = min(1.0, iTime*.02);\n\n    vec3 col = getSky(camRay);\n    \n    float dis = rayMarch(cameraPos, camRay, hash12(fragCoord)*4.);\n    float d = 0.0;\n    if (dis < FAR)\n    {\n        vec3 pos = cameraPos+camRay * dis;\n        d = dis*.0001;\n        vec3 nor = getNormal(pos, d*d*100.);\n        \n        // Do all the lighting...\n        // I got enough contrast from the texturing/lighting so I left out the shadows...\n        col = material(pos,nor) * lighting(pos, nor);\n        col += singleSeed(pos);\n        col =  mix(FOG_COLOUR, col, exp(-d*d));\n    } \n     \n    col += floatingSeeds(cameraPos, camRay, dis-hash12(fragCoord)*5.);\n    col =  mix(FOG_COLOUR, col, exp(-d*d));\n    col = clamp(col, 0.0, 1.0);  // ...Don't want of over egg it.\n    col = col*col*(3.0-2.0*col); // ...Stretch for higher contrast\n    col *= smoothstep(0.0, 8.0, iTime);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29897, "src": "https://soundcloud.com/ambientindigo/abductions-from-the-album-alien-invasion?si=13136b4f5b784872a7ba7de19364a87a&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n#define TSIZE 256.\n#define TWRAP 255\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n\n#define SUN_COLOUR vec3(1., .9, .8)\n#define FOG_COLOUR vec3(.1, .13, .16)\n\n\n#define tri(x) abs(fract(x)-.5)*2.\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n\nvec2 hash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\n\nvec3 hash32(vec2 q)\n{\n\tuvec3 n = uvec3(ivec3(q.xyx)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n\n", "buffer_a_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By David Hoskins, 2022.\n\n\n// Derivative pre-process...\n\nfloat derivHash(ivec2 q2)\n{\n   uvec2 q = uvec2((q2+9) & TWRAP);  // ...Seeded and wrapped.\n   float f = hash12(q);\n   return pow(f, .85 );\n}\n\n//---------------------\n//|                   |\n//|                   |\n//|                   |\n//|                   |\n//|                   |\n//|****               |\n//|****               |\n//|****               |\n//---------------------\n// The block is in the bottom left 256x256 of buffer texture\nvoid mainImage( out vec4 colour, in vec2 coord )\n{\n\n// Draw it ony once to relavent area...\n\n// It seems the buffers are also doubled as I need to draw 2 frames...\n  if (iFrame < 2 && coord.x < TSIZE && coord.y < TSIZE)\n  {\n\n    vec4 data, n;\n    ivec2 co = ivec2(floor(coord));\n\n    float a = derivHash(co);\n    float b = derivHash((co+ivec2(1,0)));\n    float c = derivHash((co+ivec2(0,1)));\n    float d = derivHash((co+ivec2(1,1)));\n\n// Pre-calc all we can...\n    data.x = a;\t \t\t\n    data.y = b-a; \t\t\t\n    data.z = c-a; \t\t\t\n    data.w = a - b - c + d;\n\n    colour = data;\n  }\n  else discard;\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttBDB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[465, 644, 712, 712, 755], [756, 756, 783, 783, 888], [962, 1071, 1120, 1120, 1196], [1198, 1307, 1345, 1345, 1405], [1505, 1614, 1643, 1643, 2752], [2754, 3144, 3203, 3203, 4095], [4097, 4206, 4228, 4228, 4414], [4417, 4526, 4549, 4549, 4701], [4703, 4812, 4837, 4837, 5091], [5093, 5202, 5238, 5238, 5858], [5860, 5966, 5994, 5994, 6030], [6185, 6185, 6237, 6237, 6480], [6483, 6592, 6628, 6628, 6878], [6881, 6990, 7015, 7015, 7375], [7378, 7487, 7520, 7520, 7683], [7685, 7794, 7827, 7827, 8179], [8181, 8290, 8347, 8347, 9482]], "test": "untested"}
{"id": "flGfDw", "name": "Circle Grid SDF - Distance 2D", "author": "MysteryPancake", "description": "My implementation of a circle grid SDF", "tags": ["2d", "distancefield", "grid", "sdf", "circle", "distance"], "likes": 1, "viewed": 268, "published": 3, "date": "1664562015", "time_retrieved": "2024-07-30T16:28:50.753691", "image_code": "// My SDF circle grid implementation\nfloat sdCircleGrid(in vec2 position, in float radius) {\n\t// Calculate distance from 0.5 to position mod 1\n\treturn length(fract(position) - 0.5) - radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Normalized coordinates, ripped from Inigo Quilez\n\tvec2 p = (4.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec2 m = (4.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\t\n\tfloat radius = 0.25 + sin(iTime * 2.0) * 0.25;\n\tfloat d = sdCircleGrid(p, radius);\n\n\t// Coloring, ripped from Inigo Quilez\n\tvec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcol *= 1.0 - exp(-6.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(120.0 * d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n\tif (iMouse.z > 0.001) {\n\t\td = sdCircleGrid(m, radius);\n\t\tcol = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.0025));\n\t\tcol = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n\t}\n\t\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 92, 142, 192], [194, 194, 249, 303, 1036]], "test": "untested"}
{"id": "ftGfDw", "name": "Grid SDF - Distance 2D", "author": "MysteryPancake", "description": "My implementation of a grid SDF (corrected outer distance based on box SDF by Inigo Quilez)", "tags": ["2d", "distancefield", "grid", "sdf", "distance"], "likes": 4, "viewed": 558, "published": 3, "date": "1664561641", "time_retrieved": "2024-07-30T16:28:51.610400", "image_code": "float sdGrid(in vec2 position, in float margin) {\n\n\t// Calculate per-axis distance from 0.5 to position mod 1\n\tvec2 gridDist = abs(fract(position) - 0.5) - margin;\n\t\n\t// Calculate length for round outer corners, ripped from Inigo Quilez\n\tfloat outsideDist = length(max(gridDist, 0.0));\n\t// Calculate inside separately, ripped from Inigo Quilez\n\tfloat insideDist = min(max(gridDist.x, gridDist.y), 0.0);\n\t\n\treturn outsideDist + insideDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Normalized coordinates, ripped from Inigo Quilez\n\tvec2 p = (4.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec2 m = (4.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\t\n\tfloat margin = 0.25 + sin(iTime * 2.0) * 0.25;\n\tfloat d = sdGrid(p, margin);\n\n\t// Coloring, ripped from Inigo Quilez\n\tvec3 col = vec3(1.0) - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcol *= 1.0 - exp(-6.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(120.0 * d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n\tif (iMouse.z > 0.001) {\n\t\td = sdGrid(m, margin);\n\t\tcol = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.0025));\n\t\tcol = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n\t}\n\t\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 109, 440], [442, 442, 497, 551, 1272]], "test": "untested"}
{"id": "NtGfWw", "name": "file", "author": "emreboyraz1", "description": "cineshader", "tags": ["cineshader"], "likes": 7, "viewed": 3653, "published": 3, "date": "1664558159", "time_retrieved": "2024-07-30T16:28:52.387323", "image_code": "float noise(vec2 p)\n{\n\tfloat s = texture(iChannel1,vec2(1.,2.*cos(iTime))*iTime*8. + p*1.).x;\n\ts *= s;\n\treturn s;\n}\n\nfloat onOff(float a, float b, float c)\n{\n\treturn step(c, sin(iTime + a*cos(iTime*b)));\n}\n\nfloat ramp(float y, float start, float end)\n{\n\tfloat inside = step(start,y) - step(end,y);\n\tfloat fact = (y-start)/(end-start)*inside;\n\treturn (1.-fact) * inside;\n\t\n}\n\nfloat stripes(vec2 uv)\n{\n\t\n\tfloat noi = noise(uv*vec2(0.5,1.) + vec2(1.,3.));\n\treturn ramp(mod(uv.y*4. + iTime/2.+sin(iTime + sin(iTime*0.63)),1.),0.5,0.6)*noi;\n}\n\nvec3 getVideo(vec2 uv)\n{\n\tvec2 look = uv;\n\tfloat window = 1./(1.+20.*(look.y-mod(iTime/4.,1.))*(look.y-mod(iTime/4.,1.)));\n\tlook.x = look.x + sin(look.y*10. + iTime)/50.*onOff(4.,4.,.3)*(1.+cos(iTime*80.))*window;\n\tfloat vShift = 0.4*onOff(2.,3.,.9)*(sin(iTime)*sin(iTime*20.) + \n\t\t\t\t\t\t\t\t\t\t (0.5 + 0.1*sin(iTime*200.)*cos(iTime)));\n\tlook.y = mod(look.y + vShift, 1.);\n\tvec3 video = vec3(texture(iChannel0,look));\n\treturn video;\n}\n\nvec2 screenDistort(vec2 uv)\n{\n\tuv -= vec2(.5,.5);\n\tuv = uv*1.2*(1./1.2+2.*uv.x*uv.x*uv.y*uv.y);\n\tuv += vec2(.5,.5);\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = screenDistort(uv);\n\tvec3 video = getVideo(uv);\n\tfloat vigAmt = 3.+.3*sin(iTime + 5.*cos(iTime*5.));\n\tfloat vignette = (1.-vigAmt*(uv.y-.5)*(uv.y-.5))*(1.-vigAmt*(uv.x-.5)*(uv.x-.5));\n\t\n\tvideo += stripes(uv);\n\tvideo += noise(uv*2.)/2.;\n\tvideo *= vignette;\n\tvideo *= (12.+mod(uv.y*30.+iTime,1.))/13.;\n\t\n\tfragColor = vec4(video,1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 115], [117, 117, 157, 157, 205], [207, 207, 252, 252, 373], [375, 375, 399, 399, 537], [539, 539, 563, 563, 968], [970, 970, 999, 999, 1099], [1101, 1101, 1158, 1158, 1539]], "test": "untested"}
{"id": "slKBWW", "name": "2bit Enemy Generator", "author": "SnoopethDuckDuck", "description": "Now comes with 2 emotions!!!", "tags": ["feedback", "cellularautomata"], "likes": 30, "viewed": 432, "published": 3, "date": "1664542489", "time_retrieved": "2024-07-30T16:28:53.138370", "image_code": "vec4 cell(ivec2 f) {\n    return texelFetch(iChannel0, f, 0);\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    col = vec4(0.0);\n    int frame = iFrame % 120;\n    float o = floor(float(iFrame)/120.);\n    // Translate and zoom\n    f -= 0.5 * iResolution.xy;\n    f *= 1.5 * dim.y/iResolution.y; \n    f += 0.5 * dim;\n    // s = 1. if right side, 0. if left\n    float s = step(floor(f.x), 0.5 * dim.x);   \n    \n    // Mirrored coords \n    ivec2 ff = ivec2(s * dim.x + (1. - f.x) * (2. * s - 1.), f.y);\n    f += 1.;\n    ivec2 ff2 = ivec2(s * dim.x + (1. - f.x) * (2. * s - 1.), f.y);\n    col = cell(ff);\n    float g = col.g;\n    vec4 col2 = cell(ff + ivec2(0,1));\n    vec4 col3 = cell(ff2);\n    float b = col.b;\n    col.rgb = col.rrr;\n\n    vec3 pl = pal(0.2 * o, vec3(0,1,2)/3.);\n    \n    // Uncomment me to remove colors\n    col.rgb += col2.r * pl;\n    //col.rgb += max(col2.r, col3.r) * pl;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    col = vec4(0.0);\n    ivec2 px = ivec2(f);\n    int frame = iFrame % 120;\n    // not my finest line of code!\n    int h = 3 + int(floor(9. * h21(vec2(floor(float(iFrame)/120.), 19.))));\n    \n    ivec2 g = ivec2(f + vec2(100.,151.) * iTime * 60.) & 1023;\n    float rand = texelFetch(iChannel2, g, 0).r;\n           \n    if (frame == 0 || key_down(KEY_RESET)) {     \n        col.g = rand;\n        return;\n    }\n           \n    // Center cell\n    vec4 e = cell(px);\n    col = e;\n    \n    // Neighbour cells\n    vec4 b = cell(px - ivec2(0,1));\n    vec4 t = cell(px + ivec2(0,1));\n    vec4 l = cell(px - ivec2(1,0));\n    vec4 r = cell(px + ivec2(1,0));   \n    vec4 bl = cell(px + ivec2(-1,-1));\n    vec4 br = cell(px + ivec2(1, -1));\n    vec4 tl = cell(px + ivec2(-1, 1));\n    vec4 tr = cell(px + ivec2(1,  1));   \n    \n    vec4 bb = cell(px - ivec2(0,2));\n    vec4 tt = cell(px + ivec2(0,2));\n    vec4 ll = cell(px - ivec2(2,0));\n    vec4 rr = cell(px + ivec2(2,0));  \n    \n    vec4 sum = b + t + l + r;\n    vec4 diag = bl + br + tl + tr;\n    vec4 dif = abs(b-t) * abs(l-r);\n    vec4 dif2 = (t + b) * (l + r);\n    vec4 diDif = (tl + br) * (tr + bl);\n    \n    if (frame < 10) {\n        col.g = 0.3 * diag.g + 0.2 * sum.g - e.g;\n    } else if (frame == 10) {\n        col.g = 1. - step(0.1, e.g);\n    } else if (frame == 11 && diag.g == 0.) {\n       if (b.g+t.g==2. && l.g+r.g==0. && bb.g+tt.g>=1.)  \n           col.g = 1.;\n       else if (l.g+r.g==2. && b.g+t.g==0. && ll.g+rr.g>=1.)  \n           col.g = 1.;         \n    } else if (frame <= 13) {\n       if (e.g == 1. && dif2.g == 1.)\n           col.g = 0.;\n    } else if (frame == 14) {\n       if (f.x > dim.x + 1. || f.y > dim.y)\n           col *= 0.;\n       else if (f.x < 0.5 * dim.x + 1. && abs(f.y - 0.5 * dim.y) < 4.) //could replace 4 with random val\n           col.r = 1.;\n    } else if (frame < 36) {\n        if (e.g == 1. && (sum+diag).r > 0.)\n            col.r = 1.;\n    } else if (frame < 36 + h) {\n        col = l;\n    } else if (frame == 36 + h) { // :)\n        float h2 = mod(floor(float(iFrame) / 120.), 2.) - 0.5;\n\n        float s = step(abs(f.x - 0.5 * dim.x - 2.5), 0.5);\n        s *= step(abs(f.y - 0.5 * dim.y - 1.5), 0.5);\n        float s2 = step(abs(f.x - 0.5 * dim.x), 2.);\n        s2 *= step(abs(f.y - 0.5 * dim.y + 2. + h2), 0.5);\n        float s3 = step(abs(f.x - 0.5 * dim.x - 2.5), 0.5);\n        s3 *= step(abs(f.y - 0.5 * dim.y + 2. - h2), 0.5);\n        \n        s += s2 + s3;\n        \n        s = clamp(s, 0., 1.);\n        col.r *= 1. - s;\n    }\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define dim vec2(64, 52)\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 62], [64, 64, 105, 105, 887]], "test": "untested"}
{"id": "NlVBWD", "name": "Vasarely Zebra tets", "author": "rubioh", "description": "Inspire by https://www.composition.gallery/FR/art/victor-vasarely-zebra-ceramique/", "tags": ["vasarely", "reproduction"], "likes": 6, "viewed": 375, "published": 3, "date": "1664526990", "time_retrieved": "2024-07-30T16:28:53.935185", "image_code": "\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n// Value noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ),\n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ),\n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat lines(in vec2 pos){\n    float scale = 10.0;\n    pos *= scale;\n    float v = sin(pos.x*3.1415);\n    \n    return smoothstep(-1., 1., v/fwidth(v));\n}\n\n\n// https://thebookofshaders.com/edit.php#11/circleWave-noise.frag\nfloat shape(vec2 st, float radius) {\n    float r = length(st)*2.0;\n    float a = atan(st.y,st.x);\n    float m = abs(mod(a+iTime*2.,3.14*2.)-3.14)/3.6;\n    float f = radius ;\n    m += noise(st+iTime*0.1)*.5;\n    // a *= 1.+abs(atan(u_time*0.2))*.1;\n    // a *= 1.+noise(st+u_time*0.1)*0.1;\n    f += sin(a*10.)*noise(st+iTime*.2)*.1;\n    f += (sin(a*20.)*.1*pow(m,2.));\n    return 1.-smoothstep(f,f+0.1,r);\n}\n\nfloat shapeBorder(vec2 st, float radius, float width) {\n    return shape(st,radius)-shape(st,radius-width);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n\n    vec2 pos = uv.yx*vec2(2.,4.);\n\n    float circle = 1. - step(shapeBorder(uv,0.6+ abs(cos(iTime))*.2, 10.), length(uv));\n\n\n    float pattern_ext = 0.;\n    float pattern_int = 0.;\n\n    pos += abs(cos(.5*iTime*vec2(0.1+sin(iTime/1600.), cos(iTime)/1600.+.2)*.2+ .1*length(pos)*vec2(1.,.1)));\n\n    // Add noise\n    pos = rotate2d(noise(pos) ) * pos;\n    // Draw lines\n    pattern_ext = 2.*lines(pos*(1.-circle));\n    \n    pattern_int = 2.*lines(pos*circle);\n    \n    vec3 pattern_color = (1.-circle)*pattern_ext*vec3(.6, .2, .1);\n    pattern_color += (circle)*(1.-pattern_int)*vec3(.2, .4, .3);\n    \n    \n\n    // Output to screen\n    fragColor = vec4(pattern_color,1.0);\n    \n }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 29, 29, 145], [147, 229, 251, 251, 549], [552, 552, 579, 579, 661], [663, 663, 688, 688, 815], [818, 884, 920, 920, 1290], [1292, 1292, 1347, 1347, 1401], [1405, 1405, 1462, 1512, 2234]], "test": "untested"}
{"id": "ftVfWW", "name": "4efficient poisson distribution", "author": "FabriceNeyret2", "description": "nothing interesting here !\nJust had to publish to help inspect a GLSL bug occuring in the live icon.\n\nThe real comparative shader was [url] https://shadertoy.com/view/NtcfDn [/url]", "tags": ["glsl", "bug"], "likes": 2, "viewed": 222, "published": 3, "date": "1664519290", "time_retrieved": "2024-07-30T16:28:54.722080", "image_code": "// variant of https://shadertoy.com/view/7lyBRw\n// DEBUG sub-part3 \"efficient poisson distribution\" by FabriceNeyret2. https://shadertoy.com/view/NtcfDn\n\n//#define sqrt(x) sqrt(max(x,0.))\n//#define log(x)  log(clamp(x,1e-9,1.))   // debug crash <><><>\n\n#define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n#define Poisson(n, seed)  Normal(n,sqrt(n),seed)               // approx valid for n not too small https://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\n#define Normal(m,s,seed)  m + s * Gauss(seed)\n#define Gauss(u)          sqrt(-2.*log(u.x)) * cos(6.283*u.y ) // takes u = rand2_uniform()\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = 8.* ( 2.*u - R ) / R.y,\n          I = floor(U),\n          h = H2(I);\n    float n = ( .5+.5*sin(iTime) ) * min( R.x*R.y/100., 1e4 ) / 64., d=n;\n\n    if ( int(u.x) == int(R.x)/2 || int(u.y) == int(R.y)/2 ) { O = vec4(1); return; } // red separator \n // if ( U.y < 0. && U.x > 0. ) // try (un)comment\n    {\n\n        if(d<0.)       { O = vec4(1,1,0,1); return; };        // yellow\n        if(h.x<0.)     { O = vec4(0,1,1,1); return; };        // cyan\n        if(h.x==0.)    { O = vec4(0,.5,.5,1); return; };      // dark cyan\n        if(h.x>1.)     { O = vec4(1,0,1,1); return; };        // pink\n        if(-2.*log(h.x)<0.) { O = vec4(.5,0,.5,1); return; }; // dark pink\n\n        d = Poisson(d, H2(I)) -.5;\n        if( isnan(d) ) { O = vec4(1,0,0,1); return; };        // R\n        if( isinf(d) ) { O = vec4(0,1,0,1); return; };        // G\n        if( d > 170.)  { O = vec4(0,0,1,1); return; };        // B\n        O = vec4( d/170. );\n    //  if( d < 0. )   { O = .5*vec4((int(u.x)+int(u.y))%2); return; }\n    //  O = .5* vec4(.5* ( d - n ) / 3./ sqrt(n) +.5 );\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[641, 641, 679, 679, 1790]], "test": "untested"}
{"id": "7lyfWD", "name": "Land Tide", "author": "xenn", "description": "All hail michael10884\nTry swapping out iChannel 3 for a webcam source\nSPACE to restart\n\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 21, "viewed": 467, "published": 3, "date": "1664504335", "time_retrieved": "2024-07-30T16:28:55.806182", "image_code": "\n// Fork of \"Random slime mold generator\" by michael0884. https://shadertoy.com/view/ttsfWn\n// 2020-08-19 23:28:40\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap iChannel3\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 2.56\n#define RAD R.x*01.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.0*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = 0.5*(D+0.07)*texture(iChannel3, c.xy).xyz;\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= 3.7*r*texture(iChannel3, c.xy + pos/R);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 25\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 01.07\n\n\n\n#define sense_num 64\n#define sense_ang 0.5*(3.*sin(iTime/5.))\n//#define sense_dis 12.0*(010.51*cos(iTime*0.51))\n#define sense_dis 150.*(1.*cos(iTime/3.))\n#define sense_oscil 0.01\n#define oscil_scale 0.0\n#define oscil_pow 0.05\n#define sense_force 0.05\n#define distance_scale 00.9\n#define force_scale 2.\n#define trailing 0.\n#define acceleration 0.09\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.3*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.2, 0.05);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n       // slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.01;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor.xy = C(pos - V0*dt).xy - V0*dt/R;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy =vec2(0.);\n    }\n}", "buffer_d_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 354, 381, 381, 559], [600, 600, 631, 631, 665], [667, 667, 719, 719, 838], [840, 840, 875, 875, 899], [901, 901, 932, 932, 1019], [1021, 1021, 1042, 1042, 1135], [1137, 1137, 1159, 1159, 1255], [1258, 1258, 1278, 1278, 1473], [1476, 1476, 1511, 1511, 1696], [1735, 1735, 1767, 1767, 1935], [1937, 1937, 1982, 1982, 4772]], "test": "untested"}
{"id": "slGfWD", "name": "Infinite Maze Zoom", "author": "BEN1JEN", "description": "Pretty simple infinite maze zoom tunnel.", "tags": ["tunnel", "zoom", "infinite", "maze"], "likes": 11, "viewed": 289, "published": 3, "date": "1664501271", "time_retrieved": "2024-07-30T16:28:56.684833", "image_code": "const float PI = 3.1415926535897932;\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 tunnel(vec2 uv) {\n    vec2 tunnel = vec2(atan(uv.y/uv.x)/PI, 1.0/length(uv)+iTime/2.0);\n    if (uv.x > 0.0) {\n        tunnel.x += 0.5;\n    }\n    tunnel *= 10.0;\n    tunnel = vec2(tunnel.x + tunnel.y, tunnel.x - tunnel.y);\n\n    bool flip = rand(floor(tunnel)/10.0) < 0.5;\n    return abs(mod(tunnel.x, 1.0)-mod(flip ? 1.0-tunnel.y : tunnel.y, 1.0)) < 0.1 ? vec4(0.3, 0.9, 1.0, 1.0) : vec4(0.05, 0.05, 0.2, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    float total = 0.0;\n    for (float x = -1.0; x < 1.0; x += 0.1) {\n        for (float y = -1.0; x < 1.0; x += 0.1) {\n            col += tunnel((fragCoord+vec2(x, y)-iResolution.xy/2.0)/iResolution.yy*2.0);\n            total += 1.0;\n        }\n    }\n    col /= total;\n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 58, 58, 128], [130, 130, 152, 152, 546], [548, 548, 605, 605, 937]], "test": "untested"}
{"id": "ftGfDD", "name": "Vasarely Fancy", "author": "rubioh", "description": "Inspire by https://www.fondationvasarely.org/periode-folklore-planetaire/", "tags": ["vasarely", "reproduction"], "likes": 20, "viewed": 404, "published": 3, "date": "1664486130", "time_retrieved": "2024-07-30T16:28:57.516609", "image_code": "#define N_tile 30.\n\nvec3 mix4ColorGradient(float ratio, vec3 start, vec3 mid1, vec3 mid2, vec3 end){\n    return\n    mix(\n        mix(\n            mix(start, mid1, ratio/.33), mix(mid1, mid2, (ratio - .33)/.66), \n            step(.33, ratio)), \n        mix(mid2, end, (ratio-.66)/.33), \n            step(.66, ratio));\n}\n\n\n\n\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\n\nvec3 random_color(vec2 p)\n{\n    return vec3(hash(p).x, hash(2.*p).x, hash(3.*p).x);\n}\n\n\nvec3 make_cell(vec2 tile_coord, vec2 tile_idx, vec3 background_noise){\n    \n    vec3 res = vec3(0, 0, 0);\n    float length_coord = length(tile_coord);\n    float l_inf_coord = max(abs(tile_coord.x), abs(tile_coord.y));\n    float radius = (0.35 + hash(tile_idx).x*.5)/2.;\n    \n    float activation_int = 1.-smoothstep(radius-0.04, radius+0.04, length_coord);\n    float activation_contour = smoothstep(.47, .5, l_inf_coord);\n    \n    vec3 color_int = activation_int*random_color(tile_idx);\n    vec3 color_cell = (1.-activation_int)*background_noise*(1.-activation_contour);\n    vec3 color_ext = activation_contour*vec3(0., 0., 0.);\n\n    res = color_int+color_cell+color_ext;\n    return res;\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    float a = hash(i).x;\n    float b = hash(i + vec2(1.0, 0.0)).x;\n    float c = hash(i + vec2(0.0, 1.0)).x;\n    float d = hash(i + vec2(1.0, 1.0)).x;\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat fbm( in vec2 x)\n{    \n    float t = 0.0;\n    for( int i=0; i<6; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -1. );\n        t += a*noise(f*x);\n    }\n    return t*1.-.4;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy - .5;\n\n    vec2 pos = vec2(uv*6.0);\n\n    vec2 tile_coord = fract(uv*N_tile)-.5;\n    vec2 tile_idx = floor(uv*N_tile)-.5;\n    \n \n    // Use the noise function\n    float reshape = 16.;\n    \n    vec2 tmp = sin( vec2(0.27+iTime/2000.,0.23)*iTime + .1*length(tile_idx)*vec2(2.1,2.3))+tile_idx*.1;\n    \n    float n = fbm(tmp+fbm(tmp));\n    \n    \n    vec3 color_low = vec3(5., 0., 40.);\n    vec3 color_mid1 = vec3(30., 80., 20.);\n    vec3 color_mid2 = vec3(210., 20., 60.);\n    vec3 color_high = vec3(210., 230., 0.);\n    \n    \n    vec3 background_color = mix4ColorGradient(n, color_low, color_mid1, color_mid2, color_high);\n    background_color = normalize(background_color);\n    \n    \n    vec3 color = make_cell(tile_coord, tile_idx, background_color);\n    \n    \n\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 100, 100, 318], [323, 323, 344, 375, 495], [498, 498, 525, 525, 583], [586, 586, 656, 656, 1275], [1277, 1364, 1390, 1390, 1723], [1726, 1726, 1749, 1749, 1935], [1938, 1938, 1995, 2045, 2904]], "test": "untested"}
{"id": "NlyBWD", "name": "Star Blur Streaks", "author": "MysteryPancake", "description": "Modified version of my star glow streaks shader", "tags": ["blur", "star", "glow", "streaks", "streak", "directionalbloom"], "likes": 9, "viewed": 441, "published": 3, "date": "1664472958", "time_retrieved": "2024-07-30T16:28:58.423185", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n\t\n\tconst float range = 0.2; // Length of glow streaks\n\tconst float steps = 0.002; // Texture samples\n\tconst float threshold = 0.0; // Color key threshold (0-1)\n\t\n\tfor (float i = -range; i < range; i += steps) {\n\t\n\t\tfloat falloff = 1.0 - abs(i / range);\n\t\n\t\tvec4 blur = texture(iChannel0, uv + i);\n\t\tif (blur.r + blur.g + blur.b > threshold * 3.0) {\n\t\t\tfragColor = max(fragColor, blur * falloff);\n\t\t}\n\t\t\n\t\tblur = texture(iChannel0, uv + vec2(i, -i));\n\t\tif (blur.r + blur.g + blur.b > threshold * 3.0) {\n\t\t\tfragColor = max(fragColor, blur * falloff);\n\t\t}\n\t}\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 690]], "test": "untested"}
{"id": "stVBD1", "name": "tinted glass lamborghini", "author": "flockaroo", "description": "path tracing experiment - tinted glass lamborghini", "tags": ["glass", "pathtracing", "refract", "car", "lamborghini"], "likes": 48, "viewed": 829, "published": 3, "date": "1664471840", "time_retrieved": "2024-07-30T16:28:59.391596", "image_code": "// created by florian berger (flockaroo) - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// path traced lamborghini countach made of glass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c0=textureLod(iChannel0,fragCoord/iResolution.xy,0.);\n    vec4 c=textureLod(iChannel0,fragCoord/iResolution.xy,max(1.7-1.7*(1.-exp2(-c0.w/12.)),0.));\n    fragColor=c/c0.w;\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// created by florian berger (flockaroo) - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// path traced lamborghini countach made of glass\n\n//#define HOLLOW_CAR\n\n#ifndef SHADEROO\n#define iMouseData vec4(iMouse.xy,0,0)\n#define UNIFORM(tp,name,val) tp name = val; \n#else\n#define UNIFORM(tp,name,val) uniform tp name;\n#endif\n\n// new/old model of countach (basically just the tires differ for now)\n#define NEW_MODEL\n\n#define RandTex iChannel0\n\n////////////////////////\n//// quaternions, sdf's, helper funcs\n////////////////////////\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\nvec3 rotZ(float ang,vec3 v) { return vec3(ROTM(ang)*v.xy,v.z); }\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(lang*.5+vec4(0,0,0,PI2*.25));\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(ang*.5+vec4(0,0,0,PI2*.25));\n}\n\n// iq's sdf primitives\nfloat distBox( vec3 p, vec3 halfSize)\n{\n    vec3 q = abs(p) - halfSize;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distBoxR( vec3 p, vec3 halfSize, float r) { return distBox( p, halfSize-r ) - r ; }\n\nfloat distCyl( vec3 p, float r, float h )\n{\n  vec2 d = vec2( length(p.xy)-r, abs(p.z) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat distCylR( vec3 p, float r, float h, float R )\n{\n  vec2 d = vec2( length(p.xy)-(r-R), abs(p.z) - (h*.5-R) );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0))-R;\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// flatness: // 0->sphere, 100-> nearly cylindric\nfloat distTire(vec3 p, float r, float w, float h, float flatness)\n{\n    float l=length(p.xy);\n    //p=abs(p);\n    float d=1000.;\n    // outer sphere\n    float rfl=r*(1.+flatness);\n    d=min(d,length(vec2(l+rfl-r,p.z))-rfl);\n    float rz=-(rfl-r)+sqrt(rfl*rfl-p.z*p.z);\n    //d=min(d,l-rz);\n    float ang = atan(p.x,p.y);\n    //p.z+=cos(ang*100.)*w*.01*smoothstep(.87*r,1.*r,l);\n    // main torus\n    d=max(d,length(vec2(l-r+h*.5,p.z))-w*.5);\n    //d=max(d,-l+r*.61);\n    float w_l=sqrt(w*w-h*h); // w_laufflaeche\n    float dz=.122*w_l;\n    float zfr=mod(p.z,dz);\n    float z=p.z-zfr+dz*.5;\n    // rillen\n    d=max(d,-length(vec2(l-rz,p.z-z))+dz*.2);\n    // rim radius\n    d=max(d,-(l-(r-h)));\n    return d;\n}\n\nfloat distRim(vec3 p, float r, float w, float sh)  // outer rim radius, rim width;\n{\n    vec3 p0=p;\n    p.z=abs(p.z);\n\n    float d=1000.;\n    float dmain=distCyl(p,r+sh-.005,w-.005)-.005;\n    d=min(d,dmain);\n\n    //d=max(d,-(distCyl(p-vec3(0,0,w*.5),r-sh*.5-.005,w*.05-.005)-.005));\n    float d2=length(p-vec3(0,0,+w*.03+r*1.5))-r*1.5;\n    d2=-smin_(-d2,-(distCyl(p-vec3(0,0,w*.5),r-sh*1.2-.005,w*1.-.005)-.005),.005);\n    d=-smin(-d,d2,.01);\n\n    float mang,ang;\n    float ang0 = atan(p.y,p.x);\n    float dang;\n#ifdef NEW_MODEL\n    dang=PI2/5.;\n#else\n    dang=PI2/15.;\n#endif\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    // rim holes\n#ifdef NEW_MODEL\n    d=max(d,-distCyl(p-vec3(r*.53*cos(ang-vec2(0,PIH)),0.),.17*r,w*1.3));\n#else\n    d=max(d,-distBox(rotZ(-ang,p-vec3(r*.64*cos(ang-vec2(0,PIH)),0.)),vec3(.17*r,.17*r,w*1.3)*.52));\n#endif\n    dang=PI2/5.;\n    mang=mod(ang0+dang*.5,dang);\n    ang=ang0-mang+dang*.5;\n    // screw holes\n    d2=distCyl(p-vec3(r*.28*cos(ang-vec2(0,PIH)),w*.05),.016,w*.19);\n    d=max(d,-d2);\n    // screws\n    d=min(d, d2+.005);\n\n    // axle\n    d=min(d, distCyl(p,.03-.01,w*.25-.01)-.01);\n    return d;\n}\n\nfloat distWheelDim(vec3 p, float w_mm, float h_perc, float rimD_inch, float shoulder_mm, float flatness)\n{\n    float w=w_mm*.001;\n    float h=w*h_perc/100.;\n    float d=10000.,d2;\n    float rrim=rimD_inch*.5*.0254;\n    d2=distTire(p, rrim+h, w, h, flatness );\n    d=min(d,d2);\n    float rimw=sqrt(w*w-h*h)+shoulder_mm*.001;\n    d2=distRim(p, rrim, rimw, shoulder_mm*.001 );\n    d=min(d,d2);\n    return d;\n}\n\n\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nUNIFORM(float,LightAzim,.2)\nUNIFORM(float,LightElev,.8)\n\nvec3 getLightDir() \n{\n    return normalize(vec3(-cos(LightAzim-vec2(0,1.57))*cos(LightElev),sin(LightElev)));\n    float t=iTime*1.+3.;\n    return normalize(vec3(cos(t*.3-vec2(0,1.57)),.5*sin(t*.7)));\n}\n\nvec4 getRand(vec2 coord)\n{\n    float t=iTime*0.;\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*t);\n    c+=texture(RandTex,coord/2.+.003*t)*2.;\n    c+=texture(RandTex,coord/4.+.003*t)*4.;\n    c+=texture(RandTex,coord/8.+.003*t)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n#ifdef CUBEMAP    \n    return texture(iChannel1,dir.yzx);\n#endif\n    vec3 sun = normalize(getLightDir());\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.3);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    //col+=15.*(1.-smoothstep(.02,.03,sunang));\n    //col+=6.*exp(-sunang/.20);\n    col+=15.*clamp(2.*exp(-sunang/.042),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\n#define Res (iResolution.xy)\n\nvec3 BodySize=vec3(1.8,4.14,1.0);\n\nfloat distCar(vec3 p)\n{\n    vec3 p1,p2;\n    p.x=abs(p.x);\n    vec3 p0=p;\n    // torus\n    float d=10000.,d2;\n    p=p0-vec3(-p.y*.01,0,0);\n    vec3 p01=p;\n    float yfall=min((p.y+0.0)*abs(p.y+0.0),0.);\n    float yfall2=(p.y>.0?2.5:7.)*min((-abs(p.y)+1.2)*abs(-abs(p.y)+1.2),0.);\n    yfall=mix(yfall,yfall2,step(0.,-p.z));\n    //yfall=0.;\n    // ----------- 1 ------------------ side phase\n    d2=dot(p-.51*BodySize*vec3(.5,0,1.+.15*yfall)-(.2+.2*p.y)*max(0.,p.x-.92+p.y*.03)*vec3(0,0,1),normalize(vec3(.8,0,1.-.9*yfall)));\n    d=min(d,d2);\n    \n    // ----------- 3 ------------------\n    vec3 n=normalize(vec3(0,1,2.5));\n    float dpx=max(p.x*1.-1.,-.5);\n    float dpy=max(p.y-.78+.65*dpx,0.);\n    p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*(1.-exp(-dpy/.2)-dpy*.8);\n    //vec3 p2=p-.05*(1.-dpx*5.-dpx*dpx*10.)*min(1.-dpy*.2,1.);\n    // ----------- 2 ------------------ front cut\n    d2=dot(p2-.5*BodySize*vec3(0,1,1)-vec3(0,0,-.75),normalize(vec3(0,1,2.5)));\n    d=-smin_(-d,-d2,.06*exp(-(p.y-1.1)*(p.y-1.1)*3.));\n    //d=-smin(-d,-d2,.13*clamp(1.-(p.y-1.)*(p.y-1.)*1.2,0.,1.));\n    //d=-min(-d,-d2);\n    \n    // -------------------------------- main box ---- done after cuts to get sharp contour line on sides (no smin there)\n    d2=distBoxR(p+vec3(min(+.35*p.z*p.z,.1),0,0),\n                vec3(BodySize.xz,100).xzy*.5*vec3(exp(-(step(0.,p.y)*2.+2.)*p.y*p.y*p.y*p.y/500.),1,1.+.15*yfall),\n                max(.02,-1.*p.z-.07*p.y));\n    d=max(d,d2);\n    \n    // ----------- 4 ------------------ engine cover\n    p-=vec3(0,-1.65,.48);\n    vec3 bs=vec3(BodySize.x*.25*1.1-p.y*.17+p.z*.4,1,.3);\n    d2=distBoxR(p+vec3(0,0,-p.y*.14),bs,.02);\n    d=max(d,-d2);\n    float pry=clamp(floor(p.y/.22+.5),1.,4.)*.22;\n    d2=distBoxR(p+vec3(0,-pry,.01-p.y*.14),bs-vec3(.06,.92,0),.02);\n    d=max(d,-d2);\n\n    d2=abs(p0.y)-BodySize.y*.5;\n    d2+=.005*exp(-(length(vec2(max(d+.03,0.),d2)))/.0025);\n    d=-smin_(-d,-d2,.01);\n    \n    d2=distBox(p01-vec3(0,-1.1,.3),vec3(.47,.5,.5));\n    d+=.004*exp(-abs(d2)/.004);\n\n    // ------------------------------- side air hole\n    p=p0-vec3(.9,-.35,.04);\n    float sn=(.6-.4*sin(p.y*6.));\n    d2=distBox(p,vec3(.2*sn,.5,.23*sn)*.5-.02)-.02;\n    d=max(d,-d2);\n\n    // ------------------------------- upper air hole\n    p=p01-vec3(.67,-.627,.35);\n    d2=distBoxR(p,vec3(.32,.45,.25)*.5,.02-p.y*.15);\n    //d=max(d,-d2);\n    float d3=dot(p,normalize(vec3(.58,-.5,1.)));\n    float lw=.028+p.x*.028;\n    d3=(fract(d3/lw)-.5)*lw;\n    d3=abs(d3)-lw*.3;\n    d3=max(d2,-d3);\n    //d2=max(d2,-d3);\n    d3=max(d3,(d+.01-p.y*.045));\n    d=max(d,-d2);\n    d=min(d,d3);\n\n    // make hollow (6cm thick)\n    //d=abs(d+.03)-.03;\n    \n    // ------------------------------ door\n    //   --- front win border\n    d2=dot(p01-vec3(.475,.19,0),normalize(vec3(2.,-1,0)));\n    //   --- inner border\n    d2=min(d2, dot(p01-vec3(.475,.19,0),normalize(vec3(1,0,0))) );\n    d3 = d2;\n    p=p01-vec3(.475,-.4,0);\n    float s=step(0.,-(p0.z-.2))*((p0.z-.2)*(p0.z-.2)-.25*(p0.z-.2));\n    p.y=p.y-s;\n    //   --- front door border\n    float dr=dot(p,normalize(vec3(0,1,0)));\n    d2=min(d2, dr );\n    p.y=p.y+2.*s-1.35;\n    float d4=10000.;\n    //   --- rear door border\n    d4=min(d4, dot(p,normalize(vec3(0,-1,0))) );\n    //   --- floor door border\n    d4=min( d4, dot(p01-vec3(0,0,-.22),normalize(vec3(0,0,1))) );\n    //d+=.005*exp2(-length(vec2(d2-.0,d))/.0025);\n    d2=min(d2,d4);\n    d+=.003*exp2(-abs(d2)/.003);\n    \n    // ------------------------------ side window\n    d4=min(d4, dot(p01-vec3(.87,0,0),normalize(vec3(-1,0,0))) );\n    d2=min(d2,d4);\n    d3-=.22;\n    //d3=min(d3,min(d4,dr)-.04);\n    //d3-=.22;\n    d+=.005*exp2(-length(vec2(min(d2-.04,0.),d))/.0025);\n    if(d3<min(d4,dr)-.04)\n    //d+=.003*exp2(-d3*d3/.003/.003);\n    d=min(d,length(vec2(d3,d))-.003);\n\n    // ------------------------------- front lights\n    p=p0-vec3(.65,1.6,0);\n    d2=distBox(p,vec3(.32-step(0.,p.x)*.25*p.y,.16,.2)*.5);\n    //d=max(d,-sqrt(d*d+d2*d2)+.005);\n    d+=.003*exp(-abs(d2)/.003);\n    p=p0-vec3(.63,1.85,0);\n    d2=distBox(p,vec3(.29-step(0.,p.x)*.45*p.y,.16,.34)*.5);\n    d=max(d,-d2);\n\n    // ------------------------------ wheels\n    p1=BodySize*.5*vec3(1, .59,-.65);\n    p2=BodySize*.5*vec3(1,-.63,-.65);\n    d=max(d,-distCylR((p0-p1).yzx,.35,.85,.05));\n    //d=max(d,-distCylR((p0-p2).yzx,.35,.8,.05));\n    d=max(d,-distBoxR(rotZ(0.4,(p0-p2).yzx),vec3(.37,.28,.45)+.015,.2-(p0-p2).y*.2));\n    //d=min(d,distCylR((p0-p1-vec3(-.18,0,.04)).yzx,.31,.27,.08));\n    //d=min(d,distCylR((p0-p2-vec3(-.145,0,.04)).yzx,.31,.27,.08));\n    //return distWheelDim(pos,345.,35.,15.,10.,2.7);\n\n    //d=min(d,distWheelDim((p0-p2-vec3(-.13,0,.04)).yzx,215.,70.,14.,20.,1.));\n    //d=min(d,distWheelDim((p0-p1-vec3(-.16,0,.04)).yzx,205.,70.,14.,20.,1.));\n\n#ifndef NEW_MODEL    \n    float wheelDimRear [] = float[](215.,70.,14.,15.,1.);\n    float wheelDimFront[] = float[](205.,70.,14.,15.,1.);\n    vec3 pfront = p1+vec3(-.16,0,.04);\n    vec3 prear  = p2+vec3(-.13,0,.04);\n#else\n    float wheelDimRear [] = float[](345.,35.,15.,12.,2.7);\n    float wheelDimFront[] = float[](205.,50.,15.,12.,1.);\n    vec3 pfront = p1+vec3(-.15,0,.04);\n    vec3 prear  = p2+vec3(-.19,0,.04);\n#endif\n    \n    bool front = p0.y>0.;\n    p=p0-(front?pfront:prear);\n    d=min(d,\n        distWheelDim(p.yzx,\n                     front?wheelDimFront[0]:wheelDimRear[0],\n                     front?wheelDimFront[1]:wheelDimRear[1],\n                     front?wheelDimFront[2]:wheelDimRear[2],\n                     front?wheelDimFront[3]:wheelDimRear[3],\n                     front?wheelDimFront[4]:wheelDimRear[4])\n         );\n         \n    //d=min(d,distWheelDim((p0-p2-vec3(-.19,0,.04)).yzx,345.,35.,15.,10.,2.7));\n    //d=min(d,distWheelDim((p0-p1-vec3(-.15,0,.04)).yzx,205.,50.,15.,10.,1.));\n    //d=max(d,-(length(p0-p1*vec3(1,-1,1))-.37));\n    \n    //p=p0-vec3(p.y*.02,0,0);\n    \n    /*d=min(d,length(p0.xy-floor(p0.xy+.5))-.01);\n    d=min(d,length(p0.yz-floor(p0.yz+.5))-.01);\n    d=min(d,length(p0.zx-floor(p0.zx+.5))-.01);*/\n    \n    //d2=length(vec2(length(p.xy)-2.5,p.z))-.01;\n    //d=min(d,d2);\n    return d;\n}\n\nbool carEnabled;\n\nfloat distFloor(vec3 p)\n{\n    return abs(p.z+.8)-.2;\n}\n\nfloat dist(vec3 p)\n{\n    float d=10000.;\n    \n    // ----------------------------- car\n    if(carEnabled) {\n        d=min(d,distCar(p));\n        #ifdef HOLLOW_CAR\n        d=abs(d+.015)-.015;\n        #endif\n    }\n    //d=min(d,length(p-vec3(1.3,2.5,0))-.6);\n    \n    // ----------------------------- floor\n    d=min(d,distFloor(p));\n    return d;  \n}\n\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec3 d=vec3(eps,0,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\nfloat eps=.005;\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    for(int i=0;i<80;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*abs(d*.35);\n        if (abs(d)<eps) return 1.;\n    }\n    return 0.;\n}\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    dir=normalize(vec3(0,0,-1.5)+vec3(sc,0));\n    pos=vec3(0,0,4.5*exp(-iMouseData.z/3000.));\n    float ph = iMouse.x/600.*10.;\n    float th = iMouse.y/400.*10.;\n    if (iMouse.x<1.) { ph=-iTime*.3*0.+2.; th=1.3; }\n    pos=vec3(pos.x,ROTM(th)*pos.yz);\n    dir=vec3(dir.x,ROTM(th)*dir.yz);\n    pos=vec3(ROTM(ph)*pos.xy,pos.z);\n    dir=vec3(ROTM(ph)*dir.xy,dir.z);\n}\n\nfloat fermi(float x) { return 1./(1.+exp(-x)); }\n\nfloat myrefract(inout vec3 dir, vec3 n, float N) // return fres (N supposed to be >1)\n{\n    float dn=dot(dir,n);\n    float fres=1.-abs(dot(dir,n));\n    fres*=fres*fres;\n    fres=.1+.9*fres;\n    if (dn>0.) { N=1./N; }\n    vec3 ds=dir-dn*n;\n    if(length(ds)*(1.-1./N)>1.) {  // total reflection\n        dir=reflect(dir,n); return 1.;\n    }\n    dir-=ds*(1.-1./N);\n    if (dn>0.) {\n        fres=1.-abs(dot(dir,n));\n        fres*=fres*fres;\n        fres=.2+.8*fres;\n    }\n    dir=normalize(dir);\n    return fres;\n}\n\nvec4 getRand(int i) { ivec2 r=textureSize(RandTex,0); return texelFetch(RandTex,ivec2(i,i/r.x)%r,0); }\n\nuniform float simpleRender;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fragCoord0=fragCoord;\n    ivec2 randCoord=(ivec2(fragCoord0)+iFrame*ivec2(63,7))&0xFF;\n    vec4 r =texelFetch(RandTex,randCoord,0);\n    vec4 r0=r;\n    fragCoord.xy+=r.yz-.5;\n    fragColor = texelFetch(iChannel1,ivec2(fragCoord0),0);\n    vec3 pos,dir;\n    getTrafo(pos,dir,fragCoord);\n    pos.z-=.2;\n    pos-=dir*r.x*.5;\n    vec3 pos0=pos;\n    \n    const int MaxNumBounce=6;\n    vec3 col=vec3(1);\n    for(int i=0;i<MaxNumBounce;i++) {\n        vec3 posp=pos;\n        carEnabled=intersectBox(pos-vec3(0,0,-.05),dir,BodySize+vec3(0,0,.1));\n        float hit;\n        hit=march(pos,dir);\n        \n        if(dist(pos-dir*eps*2.)<0.) col*=exp(-length(pos-posp)/2.*vec3(.5,.65,1));\n\n        vec3 n=normalize(getGrad(pos,eps));\n        \n        if(simpleRender>.5) { fragColor=vec4((n*.5+.5)*100.,100); return; }\n        \n        if(hit<.5) {\n             if(dist(pos)>1.) break;\n             else continue;\n        }\n        \n        vec3 dirRefr=dir;\n        float fres=myrefract(dirRefr, n, 1.5);\n        \n        randCoord+=ivec2(0,i+1)+iFrame*ivec2(r0.w*10.,0);\n        vec4 r =texelFetch(RandTex,randCoord&0xFF,0);\n    \n        if (dist(pos)==distFloor(pos)) { fres=fres*.5; }\n        \n        if(r.x>fres){ //refract\n            dir=dirRefr;\n            if (dist(pos)==distFloor(pos))\n            {\n                dir=(r.yzw-.5); dir=dir-dot(dir,n)+abs(dot(dir,n))*n; dir=normalize(dir);\n                col*=mix(vec3(.8,.2,.2),vec3(.8),mod(floor(pos.x)+floor(pos.y),2.));\n            }\n        } else { //reflect\n            dir=reflect(dir,n);\n        }\n        \n        pos+=dir*eps*2.;\n    }\n    \n    col*=myenv(vec3(0),dir,1.).xyz;\n    \n    fragColor.xyz+=col;\n    fragColor.w++;\n    \n    if (iFrame<10 || iMouse.xy!=texelFetch(iChannel1,ivec2(0),0).xy || iMouseData.z!=texelFetch(iChannel1,ivec2(0),0).z) {\n        fragColor=vec4(col,1);\n    }\n    if (ivec2(fragCoord0)==ivec2(0)) {\n        fragColor.xy=iMouse.xy;\n        fragColor.z=iMouseData.z;\n    }\n}\n\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVBD1.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[187, 187, 244, 244, 427]], "test": "untested"}
{"id": "NlyfDW", "name": "Star Glow Streaks (Bloom)", "author": "MysteryPancake", "description": "Two-way directional blur makes a nice starry effect", "tags": ["blur", "star", "bloom", "glow", "starry", "directional", "streaks", "streak"], "likes": 12, "viewed": 737, "published": 3, "date": "1664471507", "time_retrieved": "2024-07-30T16:29:00.222374", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n    \n    const float range = 0.1; // Length of glow streaks\n    const float steps = 0.005; // Number of texture samples / 2\n    const float threshold = 0.6; // Color key threshold (0-1)\n    const float brightness = 5.0; // Glow brightness\n    \n    for (float i = -range; i < range; i += steps) {\n    \n        float falloff = 1.0 - abs(i / range);\n    \n        vec4 blur = texture(iChannel0, uv + i);\n        if (blur.r + blur.g + blur.b > threshold * 3.0) {\n            fragColor += blur * falloff * steps * brightness;\n        }\n        \n        blur = texture(iChannel0, uv + vec2(i, -i));\n        if (blur.r + blur.g + blur.b > threshold * 3.0) {\n            fragColor += blur * falloff * steps * brightness;\n        }\n    }\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyfDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 868]], "test": "untested"}
{"id": "stKBD1", "name": "Pixel Art Alien Structures", "author": "SnoopethDuckDuck", "description": "I found an interesting CA on this website, and played with it here :)\nhttps://neuralpatterns.io/  <-- strobe/flashing warning", "tags": ["feedback", "cellularautomata"], "likes": 14, "viewed": 276, "published": 3, "date": "1664470395", "time_retrieved": "2024-07-30T16:29:01.024230", "image_code": "vec4 cell(ivec2 f) {\n    return texelFetch(iChannel0, f, 0);\n}\n\nvoid mainImage(out vec4 col, in vec2 f)\n{\n    col = vec4(0.0);\n    int frame = iFrame % 120;\n    \n    // Translate and zoom\n    f -= 0.5 * iResolution.xy;\n    f *= 1.1 * dim.y/iResolution.y; \n    f += 0.5 * dim;\n    // s = 1. if right side, 0. if left\n    float s = step(floor(f.x), 0.5 * dim.x);   \n    \n    // Mirrored coords \n    ivec2 ff = ivec2(s * dim.x + (1. - f.x) * (2. * s - 1.), f.y);\n    col = cell(ff);\n    vec4 col2 = cell(ff + ivec2(0,1));\n    vec4 col3 = cell(ff + ivec2(0,2));\n    \n    float g = col.g;\n    float g2 = col2.g;\n    \n    if (frame > 60)\n        col.rgb = col.rrr;\n    if (f.x <= 0. || f.x > dim.x + 2. || f.y > dim.y)\n           col *= 0.;            \n    \n    float v = step(floor(0.5 * dim.x) + 1., f.x);\n    float o = 2. * h21(vec2(floor(float(iFrame) / 120.), 132.));  \n    o += 0.1 * v;\n    float y = f.y / dim.y;\n    col *= 0.5 + 0.5 * v;\n    col *= 0.75 + 0.5 * y;\n    col.rgb *= pal(0.5 * col3.r + 0.1 * y + o + 0.25 * h21(vec2(ff)), vec3(0,1,2)/3.);       \n    if (length(col.rgb) < 0.05)\n        col.rgb += g2 * col2.r * pal(-0.5 + 0.1 * y + o + 0.25 * h21(vec2(ff.x, ff.y - 1)), vec3(0,1,2)/3.);\n    else\n        col *= g;\n  \n    col.rgb = sqrt(col.rgb);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    col = vec4(0.0);\n    ivec2 px = ivec2(f);\n    int frame = iFrame % 120;\n    \n    ivec2 g = ivec2(f + vec2(100.,151.) * iTime * 60.) & 1023;\n    float rand = texelFetch(iChannel2, g, 0).r;\n           \n    if (frame == 0 || key_down(KEY_RESET)) {\n        col.g = rand;\n        return;\n    }\n           \n    // Center cell\n    vec4 e = cell(px);\n    col = e;\n    \n    // Neighbour cells\n    vec4 b = cell(px - ivec2(0,1));\n    vec4 t = cell(px + ivec2(0,1));\n    vec4 l = cell(px - ivec2(1,0));\n    vec4 r = cell(px + ivec2(1,0));   \n    vec4 bl = cell(px + ivec2(-1,-1));\n    vec4 br = cell(px + ivec2(1, -1));\n    vec4 tl = cell(px + ivec2(-1, 1));\n    vec4 tr = cell(px + ivec2(1,  1));   \n    \n    vec4 bb = cell(px - ivec2(0,2));\n    vec4 tt = cell(px + ivec2(0,2));\n    vec4 ll = cell(px - ivec2(2,0));\n    vec4 rr = cell(px + ivec2(2,0));  \n    \n    vec4 sum = b + t + l + r;\n    vec4 diag = bl + br + tl + tr;\n    vec4 dif = abs(b-t) * abs(l-r);\n    vec4 dif2 = (t + b) * (l + r);\n    vec4 diDif = (tl + br) * (tr + bl);\n    \n    if (frame < 10) { // run CA\n        col.g = 0.5 * diag.g + 0.2 * sum.g - e.g;\n    } else if (frame == 10) { // invert and map to 0 or 1\n        col.g = 1. - step(0.1, e.g);\n    } else if (frame == 11 && diag.g == 0.) { // connect lines\n       if (b.g+t.g==2. && l.g+r.g==0. && bb.g+tt.g>=1.)  \n           col.g = 1.;\n       else if (l.g+r.g==2. && b.g+t.g==0. && ll.g+rr.g>=1.)  \n           col.g = 1.;         \n    } else if (frame <= 13) { // remove corners\n       if (e.g == 1. && dif2.g == 1.)\n           col.g = 0.;\n    } else if (frame == 14) { \n       if (f.x > dim.x + 1. || f.y > dim.y) // restrict to bounds (slightly wrong)\n           col *= 0.;\n       else if (f.x < 0.5 * dim.x + 1.) // make centre line red\n           col.r = 1.;\n    } else { // traverse greens when adjacent to reds\n        if (e.g == 1. && (sum+diag).r > 0.) \n            col.r = 1.;\n    }\n    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define dim vec2(48, 96)\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 62], [64, 64, 105, 105, 1262]], "test": "untested"}
{"id": "slKfD1", "name": "Volume Phase Test", "author": "BeardThings", "description": "Reference volumetric phase functions", "tags": ["test", "volumetric", "phase"], "likes": 0, "viewed": 34, "published": 3, "date": "1664466519", "time_retrieved": "2024-07-30T16:29:01.943772", "image_code": "#define PI 3.1415926\n#define PHASE 0.73\n\nfloat HG(float aCosTheta, float aAnisotropy)\n{\n\t/*\n\t\t\t1                  1 - g^2\n\t\t ----- * -------------------------------------\n\t\t  4PI     (1 + g^2 - 2g * cos(theta)) ^ (3/2)\n\t*/\n\tfloat g = aAnisotropy;\n\tfloat numerator = (1.f / (4.0*PI)) * (1.f - g * g);\n\n\tfloat x = 1.f + g * g - 2.f * g * aCosTheta;\n\tfloat f = 1.0/sqrt(max(x, 0.00001)); // x^(-1/2)\n\tfloat denominator = f * f * f; // x^(-3/2)\n\treturn numerator * denominator;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 screenSpace = uv * 2.0 - 1.0;\n\t\n    vec3 o = vec3(0.0, 0.0, -0.5);\n    \n    vec3 f = normalize(-o);\n    vec3 u = vec3(0,1,0);\n    vec3 r = normalize(cross(f, u));\n    \n    vec3 direction = normalize(f * 2.0 + \n                         r * screenSpace.x * iResolution.x / iResolution.y +\n                         u * screenSpace.y);\n\n    vec3 bg = texture(iChannel0,direction).rgb;\n    \n    float transmittance = 1.0;\n    vec3 scattering = vec3(0.0,0.0,0.0);\n    \n    vec3 indirectScattering = vec3(0.0, 0.0, 0.0);\n    float ts = 2.0*PI/64.0;\n    for(float t = 0.0; t < 2.0*PI; t += ts)\n    {\n        float ps = PI / 64.0;\n        for(float p = 0.0; p < PI; p += ps)\n        {\n            vec3 l = vec3(cos(t)*sin(p), cos(p), sin(t)*sin(p));\n            vec3 lc = texture(iChannel0,l).rgb * 2.0;\n\n            float slice = ts * ps * sin(p);\n            indirectScattering += lc * slice * HG(dot(l,direction), PHASE);\n        }\n    }\n    \n    float d = 0.0;\n    for(; d < 1.;)\n    {\n        float ss = 0.001;\n        vec3 pos = o + direction * d;\n\n        if(abs(pos).x < 0.15 && abs(pos).y < 0.15 && abs(pos).z < 0.15)\n        {\n            float extinction = 1.0/0.1* ss;\n            scattering += indirectScattering * transmittance * extinction;\n            transmittance *= exp(-extinction);\n        }\n        \n        d += ss;\n    }\n    \n    fragColor.rgb = scattering + bg * transmittance;\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 87, 222, 475], [477, 477, 534, 534, 1981]], "test": "untested"}
{"id": "ftGfWW", "name": "Tunnel of ocean", "author": "OzoneOnYou", "description": "This was supposed to be a normal raymarching test but it quiclky turned into something wiered...", "tags": ["raymarching", "normal", "wiered"], "likes": 1, "viewed": 161, "published": 3, "date": "1664466308", "time_retrieved": "2024-07-30T16:29:02.789511", "image_code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n#define PERCISION .01\n\nfloat sdSphere(vec3 p, vec3 q, float r){\n    return length(p-q)-r;\n}\n\nfloat sdWall(vec3 p, float q){\n    return max(q, p.z) - min(q, p.z + p.y);\n}\n\nfloat sdPlane(vec3 p, float q){\n    return max(q, p.y) - min(q, p.y);\n}\n\nfloat sdDirCylinder(vec3 p, vec2 q, vec2 d, float r){\n    float relativeDist = sqrt(pow(p.y * d.x, 2.) + pow(p.y * d.y, 2.)) - r;\n    return relativeDist + sqrt(pow(q.x, 2.) + pow(q.y, 2.));\n}\n\nfloat sdScene(vec3 p){\n    float sphere = sdSphere(p, vec3(1., 1.5, 5.), 1.);\n    float wall  = sdWall(p, 10.);\n    float ground  = sdPlane(p, 0.);\n    \n    return  min(sphere, min(wall, ground));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float dO;\n    \n    for(int i=0;i<MAX_STEPS;i++){\n        float cO     = sdScene( ro + rd * dO);\n        dO += cO;\n        if(dO > MAX_DISTANCE || cO < PERCISION)break;\n    }\n    return dO;\n}\n\nvec3 compute(float ray, vec3 ro, vec3 rd){\n    vec3 position = ro + rd * ray;\n    \n    float lastSd = sdScene(position);\n    vec2 error = vec2(.01 * (sin(iTime) + 1.5), 0);\n    vec3 normal = lastSd + vec3(\n        sdScene(position - error.xyy),\n        sdScene(position - error.yxy),\n        sdScene(position - error.yyx)\n    );\n    normal = normalize(normal);\n    \n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy *.5) / iResolution.y;\n\n    vec3 ro = vec3(1, 2, 1);\n    vec3 rd = vec3(uv.x, uv.y, 0.8 + sin(iTime)/5.);\n    \n    float ray = rayMarch(ro, rd);\n\n    vec3 col = compute(ray, ro, rd);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 111, 111, 139], [141, 141, 171, 171, 217], [219, 219, 250, 250, 290], [292, 292, 345, 345, 484], [486, 486, 508, 508, 684], [686, 686, 719, 719, 914], [916, 916, 958, 958, 1302], [1304, 1304, 1361, 1361, 1619]], "test": "untested"}
{"id": "7tVBW1", "name": "大龙猫 - GPU Heating for winter", "author": "totetmatt", "description": "Clearly not the most accurate simulation ever :D ", "tags": ["fire"], "likes": 28, "viewed": 457, "published": 3, "date": "1664464229", "time_retrieved": "2024-07-30T16:29:03.581393", "image_code": "/*\nForget Gas heating, invest into GPU Heating !\n\n\n*/\nvec3 erot(vec3 p,vec3 ax,float t){return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    \n    vec3 p,d=normalize(vec3(uv,1.));\n    \n    for(float i=0.,e=0.,g=0.;i++<99.;){\n        p = d*g;\n        vec3 op=p;\n        p.z -=15.+sin(iTime);\n        \n        float v=0.3,qq=0.;\n        for(v=.3;v<50.;op=erot(op,vec3(0.,1.,0.),v+=v)){\n                 // ^-- Thermostat, increase to make GPU hotter\n            qq+=abs(dot((sin(op*v)),vec3(.2)/v));           \n           op = erot(op,normalize(vec3(-.5,.7,2.7)),iTime*.1+.741);\n        }\n        float h = length(p)-1.-qq;;\n        h = max((abs(p.y)-5.1),abs(qq)-.5);\n        g+=e=max(.01,abs(h));\n        col += vec3(1.)*.0255/exp(e*e*i);\n    }\n    col =mix(vec3(.2,.05,.01),vec3(.95,.4,.1),col*col);\n    fragColor = vec4(mix(col,sqrt(col),.5),1.0);\n                          // ^-- this is the a color normalization technics\n                          // based on a new scientific approach \n                          // developed at the International Institute of La RACHE\n                          // https://www.la-rache.com/\n                          // Scientific paper will come soon\n                          \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 88, 88, 142], [143, 143, 200, 200, 1380]], "test": "untested"}
{"id": "stKBDz", "name": "Moving Vasarely", "author": "rubioh", "description": "Vasarely vibes inspire by https://www.fondationvasarely.org/periode-structures-universelles-expansives-regressives/", "tags": ["vasarely", "reproduction"], "likes": 5, "viewed": 182, "published": 3, "date": "1664460487", "time_retrieved": "2024-07-30T16:29:04.328396", "image_code": "#define N_tile 21.\n\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(175.1,311.7)),\n             dot(p,vec2(260.5,752.3)));\n    return fract(sin(p+455.)*18.5453);\n}\n\n\nvec3 mix3ColorGradient(float ratio, vec3 start, vec3 mid, vec3 end){\n    float h = .5;\n    return\nmix(mix(start, mid, ratio/h), mix(mid, end, (ratio - h)/(1.0 - h)), step(h, ratio));\n}\n\n\n\nvec3 cell_shade(in vec2 uv, in vec2 uv_floor, \n                vec3 col_int_orig, vec3 col_int_mid, vec3 col_int_target, \n                vec3 col_ext_orig, vec3 col_ext_mid, vec3 col_ext_target,\n                vec3 col_ring_orig, vec3 col_ring_mid, vec3 col_ring_target, vec2 st) {\n    vec3 res = vec3(.0);\n    \n    // Activation/Step things\n    //float radius = length(uv); // Change size of the ring\n    \n    float N = 10.*(1.-abs(cos(iTime*.2)))+2.; // Norm 2 to norm 12 (circle to square) if using norm 1 -> losange\n    \n    float absX = pow(abs(uv.x), N);\n    float absY = pow(abs(uv.y), N);\n    \n    float radius = pow(absX+absY, 1./N); \n    \n    \n    float ring_dist = (1.-length(st))/2.;\n    float ring_thickness = 0.15;\n    float activation_ext = smoothstep(ring_dist+ring_thickness - 0.04, ring_dist+ring_thickness, radius);\n    float activation_int = (1.-smoothstep(ring_dist-0.04, ring_dist, radius));\n    float activation_ring = (1.-activation_int)*(1.-activation_ext);\n    \n    // Color things\n    \n    vec3 col_interior = mix3ColorGradient(length(uv_floor)/N_tile*2.5, col_int_orig, col_int_mid, col_int_target);\n    vec3 col_exterior = mix3ColorGradient(length(uv_floor)/N_tile*2.5, col_ext_orig, col_ext_mid, col_ext_target);\n    vec3 col_ring = mix3ColorGradient(length(uv_floor)/N_tile*2.5, col_ring_orig, col_ring_mid, col_ring_target);\n    \n    //Render\n    res += col_interior*activation_int;\n    res += col_exterior*activation_ext;\n    res += col_ring*activation_ring;\n    \n    return res;\n}\n\nvec3 sphere_warp(in vec2 uv) {\n\n//uv += floor(uv);\n    vec2 st = (uv+.5) * 2.;\n\n    vec2 corner = floor(st);\n    vec2 sphere_coord = (fract(st) - corner)/2.;\n    //return sphere_coord;\n    sphere_coord *= N_tile/(N_tile/2.-.5);\n    vec2 sphere_uv = normalize(sphere_coord)*(asin(length(sphere_coord)) / 3.1415926);\n    float mask = max(0., 1. - length(sphere_uv));\n    \n    \n    // Moving Sphere\n\n    return vec3(sphere_uv, mask);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy-.5;    \n    \n    float center_scale = 1.0 + sin(iTime/2.0) / 2.0;\n    float angle = iTime / 2.0;\n    mat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n    \n    // Sphere texture\n    vec3 sphere_uv = sphere_warp(uv);\n    vec2 sphere_uv_floor = floor(-1.*(sphere_uv.xy)*N_tile);// *-1. move the center on the corner\n    \n    vec2 corner = floor((uv+.5) * 2. )- .5;\n    sphere_uv.xy += iTime / 20. * normalize(-corner);\n   \n \n    vec3 col_int_target = vec3(38., 51., 160.)/255.;\n    vec3 col_int_orig = vec3(176., 200., 223.)/255.;\n    vec3 col_int_mid = vec3(118., 160., 227.)/255.;\n\n    vec3 col_ext_target = vec3(70., 24., 24.)/255.;\n    vec3 col_ext_orig = vec3(222., 147., 139.)/255.;\n    vec3 col_ext_mid = vec3(185., 25., 12.)/255.;\n\n    vec3 col_ring_target = vec3(38., 51., 160.)/255.;\n    vec3 col_ring_orig = vec3(98., 85., 155.)/255.;\n    vec3 col_ring_mid = vec3(110., 96., 169.)/255.;\n\n    vec3 col = cell_shade((fract(sphere_uv.xy*N_tile)-.5)*2., sphere_uv_floor, \n                           col_int_orig, col_int_mid, col_int_target, \n                           col_ext_orig, col_ext_mid, col_ext_target,\n                           col_ring_orig, col_ring_mid, col_ring_target, vec2(1.-length(uv)))*(1.-step(0., -sphere_uv.z)); \n    //Lumière add *pow(sphere_uv.z*1.5, 2.)\n    \n    // Plane texture\n    vec2 cell_uv = (fract(rotation*center_scale*uv*(N_tile)+vec2(0.5,0.5))-.5)*2.;\n    vec2 cell_uv_floor = floor(rotation*center_scale*uv*N_tile+.5);\n    \n    \n    col_int_target = vec3(31., 13., 28.)/255.;\n    col_int_orig = vec3(235., 163., 157.)/255.;\n    col_int_mid = vec3(159., 11., 10.)/255.;\n \n    col_ext_target = vec3(11., 13., 137.)/255.;\n    col_ext_orig = vec3(140., 183., 237.)/255.;\n    col_ext_mid = vec3(29., 43., 174.)/255.;\n\n\n    col_ring_target = vec3(20., 12., 13.)/255.;\n    col_ring_orig = vec3(24., 14., 18.)/255.;\n    col_ring_mid = vec3(24., 14., 18.)/255.;\n\n    vec3 col2 = cell_shade(cell_uv, cell_uv_floor, \n                           col_int_orig, col_int_mid, col_int_target,\n                           col_ext_orig, col_ext_mid, col_ext_target,\n                           col_ring_orig, col_ring_mid, col_ring_target, uv)*step(0., -sphere_uv.z);\n    \n  \n    fragColor = vec4(max(col, col2)*(1.-step(.5, uv.x)), 1.0);\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKBDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 41, 72, 192], [195, 195, 263, 263, 379], [383, 383, 666, 666, 1899], [1901, 1901, 1931, 1951, 2333], [2335, 2335, 2392, 2442, 4781]], "test": "untested"}
{"id": "7lVBWh", "name": "Test 3D projection", "author": "rubioh", "description": "test", "tags": ["test"], "likes": 3, "viewed": 178, "published": 3, "date": "1664457615", "time_retrieved": "2024-07-30T16:29:05.350663", "image_code": "#define N_tile 21.\nvec3 cell_shade(in vec2 uv, in vec2 uv_floor) {\n    vec3 res = vec3(.0);\n    \n    // Activation/Step things\n    float radius = length(uv);\n    float ring_dist = 0.7;\n    float ring_thickness = 0.15;\n    float activation_ext = smoothstep(ring_dist+ring_thickness - 0.04, ring_dist+ring_thickness, radius);\n    float activation_int = (1.-smoothstep(ring_dist-0.04, ring_dist, radius));\n    float activation_ring = (1.-activation_int)*(1.-activation_ext);\n    \n    // Color things\n    float uv_floor_x_value = 1.;\n    float uv_floor_y_value = 1.;\n   \n    vec3 col_interior = vec3(uv_floor_x_value*uv_floor_y_value, 0., 0.);\n    vec3 col_exterior = vec3(0., uv_floor_x_value*uv_floor_y_value, 0.);\n    vec3 col_ring = vec3(0., 0., uv_floor_x_value*uv_floor_y_value);    \n    \n    //Render\n    res += col_interior*activation_int;\n    res += col_exterior*activation_ext;\n    res += col_ring*activation_ring;\n    \n    return res;\n}\n\nvec2 shape_interpolation(vec2 shape1, vec2 shape2, float ratio){\n    return mix(shape1, shape2,  smoothstep(0.0,1.0, ratio));\n}\n\n\nvec3 Sphere(in vec2 st, float radius) {\n    //return sphere_coord;\n    vec2 uv = (st/radius);\n    vec2 sphere_uv = normalize(uv)*(asin(length(uv)) / 3.1415926);\n    float mask = 1.-step(radius, length(st));\n    return vec3(sphere_uv, mask);\n}\n\nvec3 Parabole(vec2 uv, float radius){\n    vec3 res = vec3(.0, .0, 0.);\n    vec2 uv_parabol = (uv)*(pow(length(uv), -.5))*1./pow(radius, -.5);// Change le pow pour du turfu\n    float mask =(1.-step(radius, length(uv)));\n    return vec3(uv_parabol, mask);\n}\n\n\nvec3 Gaussian2D(vec2 uv, float radius){\n    vec3 res = vec3(.0, .0, 0.);\n    \n    float sigma = 5.1;\n    vec2 uv_Gaussian = uv * exp(dot(uv, uv)*sigma)/(2.*sqrt(sigma));    \n    float mask =(1.-step(radius, length(uv)));\n    return vec3(uv_Gaussian, mask);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    \n    float radius = .4;\n    vec3 parabole = Parabole(uv, radius);    \n    vec2 parabole_uv_floor = floor(parabole.xy*N_tile);// *-1. move the center on the corner\n    vec3 col_parabole = cell_shade((fract(parabole.xy*N_tile-.5)-.5)*2., parabole_uv_floor)*(parabole.z);\n    \n    //Lumière add *pow(sphere_uv.z*1.5, 2.)    \n    vec3 sphere = Sphere(uv, radius);    \n    vec2 sphere_uv_floor = floor(sphere.xy*(N_tile));// *-1. move the center on the corner\n    vec3 col_sphere = cell_shade((fract(sphere.xy*N_tile*radius*2.-.5)-.5)*2., sphere_uv_floor)*(sphere.z); \n   \n   \n    vec3 gaussian_uv = Gaussian2D(uv, radius);    \n    vec2 gaussian_uv_floor = floor(gaussian_uv.xy*N_tile);// *-1. move the center on the corner\n    vec3 col_gaussian = cell_shade((fract(gaussian_uv.xy*N_tile*2.-.5)-.5)*2., gaussian_uv_floor)*(gaussian_uv.z); \n   \n   \n   \n    vec2 sphere2 = sphere.xy*N_tile*radius*2.-.5;\n    vec2 gaussian2 = gaussian_uv.xy*N_tile*2.-.5;\n    vec2 parabole2 = parabole.xy*N_tile-.5;\n    \n    vec2 interp = shape_interpolation(parabole2, gaussian2, .5*cos(iTime)+.5);\n    vec3 col_interp = cell_shade((fract(interp.xy)-.5)*2., sphere_uv_floor)*(sphere.z); \n    \n    \n    // Plane texture\n    vec2 cell_uv = (fract(uv*(N_tile)+vec2(0.5,0.5))-.5)*2.;\n    vec2 cell_uv_floor = floor(uv*N_tile+.5);\n    vec3 col_shade = cell_shade(cell_uv, cell_uv_floor)*(1.-parabole.z);\n    \n\n    // Output to screen\n    fragColor = vec4(col_shade+col_interp,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 66, 66, 943], [945, 945, 1009, 1009, 1072], [1075, 1075, 1114, 1141, 1317], [1319, 1319, 1356, 1356, 1574], [1577, 1577, 1616, 1616, 1835], [1839, 1839, 1896, 1946, 3449]], "test": "untested"}
{"id": "NtGfDh", "name": "Animated Vasarely", "author": "rcargou", "description": "Hi", "tags": ["reproduction"], "likes": 7, "viewed": 220, "published": 3, "date": "1664455853", "time_retrieved": "2024-07-30T16:29:06.150524", "image_code": "#define N_tile 21.\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n\nvec3 cell_shade(in vec2 uv, vec2 id) {\n    vec3 res = vec3(.0);\n    float radius = length(uv);\n    vec2 t = vec2(iTime / 1.0);\n    float sound = texture(iChannel0, vec2(iTime)).x - 0.5;\n    float ring_dist = 0.5 + hash(id).x / 5.0 +  abs(hash(vec2(t) + id).y) * pow(abs(sound), 1.5) * .5;\n    float ring_thickness = 0.15;\n    vec3 col_interior = vec3(.15, .2, 0.3);\n\n    vec3 col_exterior =vec3( hash(vec2(id.y , 0.0)).x / 20.0, 0.0, 0.0)\n    + vec3( hash(vec2(id.x , 0.0)).x / 20.0, 0.0, 0.0);\n    col_exterior.x += 0.05;\n    //0.6 * pal( hash(id).x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25));\n    vec3 col_ring = vec3(0.15, 0., .4);\n    \n    float activation_ext = smoothstep(ring_dist+ring_thickness - 0.14, ring_dist+ring_thickness, radius);\n    float activation_int = (1.-smoothstep(ring_dist-0.14, ring_dist, radius));\n    float activation_ring = (1.-activation_int)*(1.-activation_ext);\n    \n    \n    res += col_interior*activation_int;\n    res += col_exterior*activation_ext;\n    res += col_ring*activation_ring;\n    \n    \n    return res;\n}\n\n\n\nvec3 sphere_warp(in vec2 uv) {\n\n//uv += floor(uv);\n    vec2 st = (uv+.5) * 2.;\n\n    vec2 corner = floor(st);\n    vec2 sphere_coord = (fract(st) - corner)/2.;\n    //return sphere_coord;\n    sphere_coord *= N_tile/(N_tile/2.-.5);\n    vec2 sphere_uv = normalize(sphere_coord)* ((asin(length(sphere_coord)) / 3.1415926));\n   \n    float mask = max(0., 1. - length(sphere_uv));\n    corner -= 0.5;\n    \n    sphere_uv.xy += vec2(iTime / 20.0) * normalize(-corner);\n    return vec3(sphere_uv, mask);\n}\n\nfloat mask(inout vec2  uv) {\n    \n    if (uv.x > 2.0 * 9.3 / 21.0) {\n        return 0.0;\n    }\n    if (uv.x < -0.11) {\n        return 0.0;\n    }\n    uv.x -= 8.15 / 21.0;\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    if (mask(uv) < 1.0) {\n        fragColor = vec4(0.1);\n        return ;\n    }\n    float center_scale = 1.0 + sin(iTime/2.0) / 2.0;\n    float angle = iTime / 2.0;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 cell_uv = (fract(rot*center_scale*uv*(N_tile)+vec2(0.5,0.5))-.5)*2.;\n    vec2 cell_id = (floor(rot*center_scale*uv*(N_tile)+vec2(0.5,0.5))-.5)*2.;\n    vec3 sphere_uv = sphere_warp(uv);\n\n    vec2 sphere_cell_uv = (fract(sphere_uv.xy*N_tile)-.5)*2.;\n    vec2 sphere_cell_id = (floor(sphere_uv.xy*N_tile)-.5)*2.;\n    // Sphere texture\n    vec3 col = max(vec3(.0), cell_shade(sphere_cell_uv, sphere_cell_id / 21.)* pow(sphere_uv.z*1.5, 4.)); //Lumière\n    \n    // Plane texture\n    col += 0.7 * cell_shade(cell_uv, cell_id)*step(0., -sphere_uv.z);\n    \n    vec2 plane_center = vec2(0.0);\n    \n    col +=  vec3(0.21) * pow(1.0 / (.5 + length(uv * 2.0 * center_scale)), 1.5);\n    fragColor = vec4(pow(col, vec3(1.1)) , 1.0);\n}\n", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGfDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 88, 88, 131], [133, 133, 154, 185, 300], [302, 302, 340, 340, 1383], [1387, 1387, 1417, 1437, 1879], [1881, 1881, 1909, 1909, 2067], [2069, 2069, 2126, 2176, 3184]], "test": "untested"}
{"id": "7lKBW1", "name": "liquid dust", "author": "xenn", "description": "SPACE to restart\n\nUse mouse to spawn vortices", "tags": ["particles", "ca"], "likes": 9, "viewed": 211, "published": 3, "date": "1664455091", "time_retrieved": "2024-07-30T16:29:07.091010", "image_code": "\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\n//3d mode\n//#define heightmap iChannel3\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 2.56\n#define RAD R.x*01.7\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nvec3 color(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n\n    vec4 v = C(pos.xy);\n    return v.xyz;\n}\n\n\nfloat DE(vec3 pos)\n{\n    float y = 1.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.7*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n    #ifdef heightmap\n        // Normalized pixel coordinates \n        pos = (pos - R*0.5)/max(R.x,R.y);\n\t\tpos = vec2(pos.x, pos.y);\n        vec2 uv = iMouse.xy/R;\n        vec2 angles = vec2(-1.5 + 0.0*iTime, -0.5)*PI;\n\n        vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n        vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n        vec3 camera_y = -normalize(cross(camera_x,camera_z));\n\n        //tracking particle\n        vec4 fp = vec4(R*0.5 + 0.*vec2(150.*iTime, 0.), 0., 0.);\n\n        vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n        vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n\n        vec4 X = ray_march(cam_pos, ray);\n\n        if(X.w < min_d)\n        {\n\n            float D = rho(X.xyz);\n          \tvec3 c = color(X.xyz);\n           \n            vec3 albedo = 0.5*(D+0.07)*texture(iChannel3, c.xy).xyz;\n            float rough = 1. - 0.1*distance(albedo, vec3(1.));\n\n            vec4 N0 = calcNormal(X.xyz, 2.*X.w)*vec4(4.,4.,1.,1.);\n            vec3 n = normalize(N0.xyz);\n            vec3 rd = reflect(ray, n);\n            vec3 colA =texture(iChannel2,  rd.yzx).xyz;\n            vec3 colB = (vec3(0.5) + 0.5*dot(rd, normalize(vec3(1.))));\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(1.))), 0.), 10.);\n            colB += 3.*rough*pow(max(dot(rd, normalize(vec3(-0.5,-0.9,0.8))), 0.), 10.);\n            float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n            float K = 1. - pow(max(dot(n,rd),0.), 2.);\n            col.xyz = 1.*albedo*colB + 0.*rough*colA*K;\n        }\n        else\n        {    \n            //background\n            col = 1.*texture(iChannel2,  ray.yzx);\n        }\n    col = tanh(8.*col);\n    #else\n    \tfloat r = P(pos.xy).z;\n    \tvec4 c = C(pos.xy);\n    \t\n    \t//get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //velocity operators\n        float div = (v_r.x - v_l.x + v_u.y - v_d.y);\n        float curl = (v_r.y - v_l.y - v_u.x + v_d.x);\n    \t\n    \t\n    \tcol= 3.7*r*texture(iChannel3, c.xy + pos/R);\n    \t//col.xyz += vec3(1,0.1,0.1)*max(curl,0.) + vec3(0.1,0.1,1.)*max(-curl,0.);\n    \t\n    #endif\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n#define C(p) texture(iChannel1, mod(p,R)/R)\n#define D(p) texture(iChannel2, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.\n#define R iResolution.xy\n\nconst vec2 dx = vec2(0, 1);\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n#define rand_interval 25\n#define random_gen(a, b, seed) ((a) + ((b)-(a))*hash11(seed + float(iFrame/rand_interval)))\n\n\n#define distribution_size 01.07\n\n\n\n#define sense_num 8\n#define sense_ang 0.27511\n//#define sense_dis 12.0*(010.51*cos(iTime*0.51))\n#define sense_dis 4.4*+(20.0*cos(iTime*0.1))\n#define sense_oscil 00.1\n#define oscil_scale 0.51*(01.1*cos(iTime*0.1))\n#define oscil_pow 01.0\n#define sense_force 0.2*(010.1*cos(iTime*0.51))\n#define distance_scale 00.51*(0.51*cos(iTime*0.951))\n#define force_scale 01.51+ (0.5*sin(iTime/3.0))\n#define trailing 0.\n#define acceleration 0.09\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GSS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define Rot(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//SPH pressure\n#define Pressure(rho) 0.3*rho.z\n#define fluid_rho 0.2\n\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "const int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = distribution_size;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //mass renormalization\n    float prevM = M;\n    M = mix(M, 0.2, 0.05);\n    V = V*prevM/M;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        X = pos;\n        vec2 dx0 = (pos - R*0.3); vec2 dx1 = (pos - R*0.7);\n        V = 0.5*Rot(PI*0.5)*dx0*GS(dx0/30.) - 0.5*Rot(PI*0.5)*dx1*GS(dx1/30.);\n        V += 0.2*Dir(2.*PI*hash11(floor(pos.x/20.) + R.x*floor(pos.y/20.)));\n        M = 0.1 + pos.x/R.x*0.01 + pos.y/R.x*0.01;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 uv = pos/R;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the force\n        vec2 F = vec2(0.);\n        \n        //get neighbor data\n        vec4 d_u = T(pos + dx.xy), d_d = T(pos - dx.xy);\n        vec4 d_r = T(pos + dx.yx), d_l = T(pos - dx.yx);\n        \n        //position deltas\n        vec2 p_u = DECODE(d_u.x), p_d = DECODE(d_d.x);\n        vec2 p_r = DECODE(d_r.x), p_l = DECODE(d_l.x);\n        \n        //velocities\n        vec2 v_u = DECODE(d_u.y), v_d = DECODE(d_d.y);\n        vec2 v_r = DECODE(d_r.y), v_l = DECODE(d_l.y);\n       \n        \n        \n        //pressure gradient\n        vec2 p = vec2(Pressure(d_r) - Pressure(d_l),\n                      Pressure(d_u) - Pressure(d_d));\n        \n        //density gradient\n        vec2 dgrad = vec2(d_r.z - d_l.z,\n                      d_u.z - d_d.z);\n        \n        //velocity operators\n        float div = v_r.x - v_l.x + v_u.y - v_d.y;\n        float curl = v_r.y - v_l.y - v_u.x + v_d.x;\n        //vec2 laplacian = \n            \n        F -= M*p;\n        \n\n        float ang = atan(V.y, V.x);\n        float dang =sense_ang*PI/float(sense_num);\n        vec2 slimeF = vec2(0.);\n        //slime mold sensors\n        range(i, -sense_num, sense_num)\n        {\n            float cang = ang + float(i) * dang;\n        \tvec2 dir = (1. + sense_dis*pow(M, distance_scale))*Dir(cang);\n        \tvec3 s0 = C(X + dir).xyz;  \n   \t\t\tfloat fs = pow(s0.z, force_scale);\n            float os = oscil_scale*pow(s0.z - M, oscil_pow);\n        \tslimeF +=  sense_oscil*Rot(os)*s0.xy \n                     + sense_force*Dir(ang + sign(float(i))*PI*0.5)*fs; \n        }\n        \n        //remove acceleration component and leave rotation\n       // slimeF -= dot(slimeF, normalize(V))*normalize(V);\n\t\tF += slimeF/float(2*sense_num);\n        \n        if(iMouse.z > 0.)\n        {\n            vec2 dx= pos - iMouse.xy;\n             F += 0.1*Rot(PI*0.5)*dx*GS(dx/30.);\n        }\n        \n        //integrate velocity\n        V += Rot(-0.*curl)*F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?v/1.:1.;\n    }\n    \n    //mass decay\n   // M *= 0.999;\n    \n    //input\n    //if(iMouse.z > 0.)\n    //\\\\\tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    //else\n     //   M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define radius 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    float rho = 0.01;\n    vec2 vel = vec2(0., 0.);\n\n    //compute the smoothed density and velocity\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n\n        vec2 X0 = DECODE(data.x) + tpos;\n        vec2 V0 = DECODE(data.y);\n        float M0 = data.z;\n        vec2 dx = X0 - pos;\n\n        float K = GS(dx/radius)/(radius);\n        rho += M0*K;\n        vel += M0*K*V0;\n    }\n\n    vel /= rho;\n\n    fragColor = vec4(vel, rho, 1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//normal advection\nconst int KEY_SPACE = 32;\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec2 V0 = vec2(0.);\n    if(iFrame%1 == 0)\n    {\n    \tvec4 data = T(pos);\n    \tV0 = 1.*DECODE(data.y);\n   \t\tfloat M0 = data.z;\n    }\n    else\n    {\n      \n    }\n    \n    fragColor.xy = C(pos - V0*dt).xy - V0*dt/R;\n    \n    //initial condition\n    if(iFrame < 1 || isKeyPressed(KEY_SPACE))\n    {\n        fragColor.xy =vec2(0.);\n    }\n}", "buffer_d_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 143, 170, 170, 348], [389, 389, 420, 420, 454], [456, 456, 508, 508, 627], [629, 629, 664, 664, 688], [690, 690, 721, 721, 808], [810, 810, 831, 831, 924], [926, 926, 948, 948, 1044], [1047, 1047, 1067, 1067, 1262], [1265, 1265, 1300, 1300, 1485], [1524, 1524, 1556, 1556, 1724], [1726, 1726, 1771, 1771, 4561]], "test": "untested"}
{"id": "NtVfDh", "name": "Hilbertian Saltation", "author": "dr2", "description": "Leaping along a Hilbert curve", "tags": ["hilbert", "jump", "path"], "likes": 23, "viewed": 322, "published": 3, "date": "1664445278", "time_retrieved": "2024-07-30T16:29:07.891868", "image_code": "// \"Hilbertian Saltation\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrSphDf (vec3 p, float r);\nvec3 HsvToRgb (vec3 c);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val);\n\nconst int nBall = 8;\nvec3 bPos[nBall], ltDir, qHit;\nvec2 gId;\nfloat tCur, dstFar, gSize, bSize, hInd, vDirI, vDirO, cHt;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\n// Hilbert indexing - without bit ops (from \"Hilbert's Path\")\n\nint LoBit (int x)\n{\n  return x - 2 * (x / 2);\n}\n\nint FlipLoBit (int x)\n{\n  return 4 * (x / 2) - x + 1;\n}\n\nconst int maxBits = 7;\n\nint HilXy2D (ivec2 p, int n)\n{\n  ivec2 r;\n  int j, td, d;\n  d = 0;\n  td = 1;\n  j = n / 2;\n  for (int b = 0; b < maxBits - 1; b ++) {\n    td *= 2;\n    j /= 2;\n    if (j == 1) break;\n  }\n  j = n / 2;\n  for (int b = 0; b < maxBits - 1; b ++) {\n    r = ivec2 (LoBit (p.x / td), LoBit (p.y / td));\n    d += j * j * ((r.y == 0) ? 3 * r.x : FlipLoBit (3 * r.x));\n    if (r.y == 0) {\n      if (r.x == 1) p = n - 1 - p;\n      p = p.yx;\n    }\n    td /= 2;\n    j /= 2;\n    if (j == 0) break;\n  }\n  return d;\n}\n\nivec2 HilD2Xy (int d, int n)\n{\n  ivec2 p, r;\n  int j, td;\n  td = d;\n  p = ivec2 (0);\n  j = 1;\n  for (int b = 0; b < maxBits; b ++) {\n    r.x = LoBit (td / 2);\n    r.y = LoBit ((r.x == 0) ? td : FlipLoBit (td));\n    if (r.y == 0) {\n      if (r.x == 1) p = j - 1 - p;\n      p = p.yx;\n    }\n    p += j * r;\n    td /= 4;\n    j *= 2;\n    if (j == n) break;\n  }\n  return p;\n}\n\n#define HT(x) (1. - 0.8 * (x) / (bSize * bSize))\n\nvoid SetGParm ()\n{\n  vec2 dq;\n  int ic, ib;\n  ib = int (bSize);\n  ic = HilXy2D (ivec2 (gId), ib);\n  hInd = float (ic);\n  cHt = HT (hInd);\n  vDirI = -1.;\n  vDirO = -1.;\n  if (ic > 0) {\n    dq = gId - vec2 (HilD2Xy (ic - 1, ib));\n    vDirI = (dq.y == 0.) ? ((dq.x > 0.) ? 0. : 2.) : ((dq.y > 0.) ? 1. : 3.);\n  }\n  if (ic < ib * ib - 1) {\n    dq = vec2 (HilD2Xy (ic + 1, ib)) - gId;\n    vDirO = (dq.y == 0.) ? ((dq.x > 0.) ? 0. : 2.) : ((dq.y > 0.) ? 1. : 3.);\n  }\n}\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, r;\n  dMin = dstFar;\n  r = 0.12;\n  if (Minv2 (gId) >= 0. && Maxv2 (gId) < bSize) {\n    q = p;\n    q.xz -= gSize * (gId + 0.5);\n    qq = q;\n    qq.y -= r + 0.08;\n    q.y -= cHt + 0.02;\n    d = PrRoundCylDf (q.xzy, 0.3, 0.02, cHt);\n    DMINQ (1);\n    if (vDirI >= 0.) {\n      q = qq;\n      if (vDirI > 0.) q.xz = vec2 (-1., 1.) * ((vDirI == 2.) ? q.xz : q.zx *\n         sign (vDirI - 2.));\n      d = max (length (q.yz) - r, q.x);\n      DMINQ (2);\n    }\n    if (vDirO >= 0.) {\n      q = qq;\n      if (vDirO > 0.) q.xz = vec2 (-1., 1.) * ((vDirO == 2.) ? q.xz : q.zx *\n         sign (vDirO - 2.));\n      d = max (length (q.yz) - r, - q.x);\n      DMINQ (2);\n    }\n  }\n  return dMin;\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi;\n  vec2 gIdP;\n  float dHit, d, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  rdi.xz = 1. / rd.xz;\n  gIdP = vec2 (-999.);\n  eps = 0.001;\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + dHit * rd;\n    gId = floor (p.xz / gSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGParm ();\n    }\n    d = GObjDf (p);\n    dHit += min (d, eps + max (0., Minv2 ((gSize * (gId + step (0., rd.xz)) - p.xz) * rdi.xz)));\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvoid BPos ()\n{\n  vec3 bp1, bp2;\n  float t, bb;\n  int ib1, ib2;\n  bb = bSize * bSize;\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    t = tCur + (float (k) / float (nBall)) * (bb + 1.);\n    ib1 = int (mod (t, bb));\n    ib2 = int (mod (t + 1., bb));\n    bp1 = vec3 (HilD2Xy (ib1, int (bSize)), 2. * HT (float (ib1))).xzy;\n    bp2 = vec3 (HilD2Xy (ib2, int (bSize)), 2. * HT (float (ib2))).xzy;\n    t = clamp (1.3 * fract (t) - 0.15, 0., 1.);\n    if (ib1 < int (bb) - 1) {\n      bPos[k] = mix (bp1, bp2, t);\n      bPos[k].y += 3. * t * (1. - t);\n    } else {\n      bPos[k] = mix (bp1, bp2, step (0.5, t));\n      bPos[k].y -= mix (t, 1. - t, step (0.5, t));\n    }\n    bPos[k].xz += 0.5;\n    bPos[k].y += 0.2;\n  }\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q.xz -= 0.5 * bSize;\n  q.y -= -0.1;\n  d = PrBoxDf (q, vec3 (0.5 * bSize, 0.1, 0.5 * bSize));\n  DMINQ (3);\n  for (int k = VAR_ZERO; k < nBall; k ++) {\n    q = p - bPos[k];\n    d = PrSphDf (q, 0.2);\n    DMINQ (4 + k);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, qHitG;\n  float dstObj, dstObjG, s;\n  int idObjG;\n  dstObjG = GObjRay (ro, rd);\n  idObjG = idObj;\n  qHitG = qHit;\n  BPos ();\n  dstObj = ObjRay (ro, rd);\n  if (dstObjG < min (dstObj, dstFar)) {\n    dstObj = dstObjG;\n    idObj = idObjG;\n    qHit = qHitG;\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = (idObj == idObjG) ? GObjNf (ro) : ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n      if (vn.y > 0.99) {\n        for (int k = VAR_ZERO; k < nBall; k ++) {\n          s = length (ro.xz - bPos[k].xz);\n          if (s < 0.3) {\n            col4.rgb = mix (HsvToRgb (vec3 (float (k) / float (nBall), 0.8, 1.)), col4.rgb, \n               smoothstep (0.1, 0.3, s));\n            break;\n          }\n        }\n        col4 *= 1. - 0.4 * smoothstep (0.05, 0.1,\n           ShowIntPZ (qHit.xz - vec2 (0.2, -0.1), 0.9 * vec2 (0.5, 0.2), 3., hInd + 1.));\n      } else col4 *= 0.9 + 0.1 * cos (32. * pi * qHit.y);\n    } else if (idObj == 2) {\n      col4 = vec4 (0.7, 0.75, 0.7, 0.2) * (0.7 + 0.3 * step (0., sin (8. * pi * (qHit.x - tCur))));\n    } else if (idObj == 3) {\n      col4 = vec4 (0.4, 0.2, 0.1, 0.2) * (0.5 + 0.5 * smoothstep (0., 0.1,\n         length (fract (qHit.xz) - 0.5) - 0.32));\n    } else if (idObj >= 4) {\n      col4 = vec4 (HsvToRgb (vec3 (float (idObj - 4) / float (nBall), 0.8, 1.)), -1.);\n    }\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.);\n    else col = col4.rgb * (0.6 - 0.4 * dot (rd, vn));\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.05 * pi;\n  el = -0.25 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  gSize = 1.;\n  bSize = 8.;\n  ro = vuMat * vec3 (0., 0.2, -2.5 * bSize);\n  ro.xz += 0.5 * bSize;\n  zmFac = 4.5;\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowIntPZ (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (Minv2 (q) >= 0. && Maxv2 (q) < 1.) {\n    q.x *= mxChar;\n    nDig = mxChar;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = max (val, 0.) / pow (10., mxChar - idChar - 1.);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtVfDh.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[847, 847, 866, 866, 894], [896, 896, 919, 919, 951], [977, 977, 1007, 1007, 1475], [1477, 1477, 1507, 1507, 1846], [1898, 1898, 1916, 1916, 2361], [2363, 2363, 2386, 2386, 3096], [3098, 3098, 3132, 3132, 3697], [3699, 3699, 3721, 3721, 3977], [4691, 4691, 4713, 4713, 5005], [5007, 5007, 5040, 5040, 5224], [5226, 5226, 5247, 5247, 5502], [5504, 5504, 5539, 5539, 7235], [7237, 7237, 7293, 7293, 8365], [8367, 8367, 8399, 8399, 8499], [8501, 8501, 8558, 8558, 8634], [8636, 8636, 8669, 8669, 8696], [8698, 8698, 8722, 8722, 8844], [8846, 8846, 8868, 8868, 8895], [8897, 8897, 8919, 8919, 8946], [8948, 8948, 8984, 8984, 9190], [9192, 9192, 9222, 9222, 9335], [9337, 9337, 9360, 9360, 9462], [9535, 9535, 9567, 9567, 10109], [10111, 10111, 10173, 10173, 10540]], "test": "untested"}
{"id": "stGBWh", "name": "Kelvin wake visualisation", "author": "skal", "description": "The boat is now generating a wave train, each approximated as planar,\nwith a wide distribution of wavelengths, each with their own propagation speed.\n\nWe visualise the crests of the wave trains.\nhit 'space' to show the accumulated wave.\n\n", "tags": ["fluid", "shockwave", "shipwake", "machcone"], "likes": 6, "viewed": 282, "published": 3, "date": "1664443517", "time_retrieved": "2024-07-30T16:29:08.705692", "image_code": "// How does a ship wake form? Why are they 'universal'?\n//\n// A boat moving in deep water generates planar wave trains for\n// a distribution of wavelength, each having their own propagation\n// speed (/ Mach cone).\n// Accumulating these waves (hit 'space'!) shows the typical ship-wake,\n// called Kelvin wake.\n// It is a physical mini-wonder that this shape (basically, a caustic,\n// similar to your coffee mug's cardiod!) is relatively universal, independant\n// of shape and speed.\n// Changing the wavelength distribution (that is, taking the actual\n// shape of the boat, propeller, etc.) doesn't change the final\n// result much.\n//\n// See https://en.wikipedia.org/wiki/Wake_(physics)#Kelvin_wake_pattern\n//\n//  Some results:\n//    . wake angle is 2.asin(1/3) ~= 38.9°\n//    . diverging wave angle is ~55°\n//    . transverse stern waves have a maximal wavelength 2𝜋 V^2 / g. \n//      This is used to evaluate the boat's speed V.\n//    \n//   Hope the vizualisation is telling!\n//   Use the 'space' key to see the full wave train accumulated, and\n//   mouse to change the scale.\n//\n//  See also: \n//    https://www.shadertoy.com/view/slKfWR <= Why do we approximate with planar waves?\n//    https://www.shadertoy.com/view/7ltfDS <= Inaccurate but fun visu\n//    https://www.youtube.com/watch?v=95sQcSulRFM  <= 5mins physics\n//    https://www.youtube.com/watch?v=0cr6vZKe6HI  <= bow waves can cancel stern waves!\n//    http://www.scullen.com.au/DSc/Publications/tuck_scullen_lazauskas_00e.pdf <= some maths\n//\n// skal/ (Pascal Massimino)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// Some physics\nconst float V0 = 1.2;    // base boat speed [m/s]\nconst float g  = 9.81;   // gravity\nconst float k_min = g / (V0 * V0);   // the only physical constant that matters\n// Wavelength spectrum (basic)\nconst float L0 = 0.00;   // min wavelength [m]\nconst float NL = 30.;    // number of samples\n// Boat position\nconst vec2 boat = vec2(3.20, 0.00);\n// Colors\nconst vec3 ocean_col = vec3(.3, .5, .9);   // ocean background color\nconst vec3 boat_col  = vec3(.3, .7, .2);   // boat color (~green)\nconst vec3 shock_col = vec3(.6, .6, .1);   // wake-angle color (~yellow)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  bool show_waves = (texelFetch(iChannel0, ivec2(32, 0),0 ).x > 0.5);\n  vec2 uv = 2. * fragCoord / iResolution.yy - vec2(0.0, 1.0);  // y-screen = [-1, 1]\n  \n  float nL = NL;\n  if (show_waves) nL *= 100.;\n\n  float km = k_min * (1. + 3.7 * iMouse.x / iResolution.x);\n  float Lmax = 6.2831 / km;\n\n  // position relative to boat\n  vec2 r = boat - uv;\n  r = vec2(r.x, -abs(r.y));  // fold\n\n  // color mixing factors\n  float shock_mix = 0.;\n  float boat_mix = 1. - smoothstep(0.18, 0.19, length(r - vec2(0., 0.15)));  // boat\n\n  // Accumulate per-wavelength amplitude.\n  float acc = 0.5;\n  float progress = min(mod(iTime, 10.) * 0.3, 1.);\n  for (float i = 1.; i <= nL; ++i) {\n    float frac = i / nL;\n    if (frac > progress) break;\n    // sigmoid: sample more densely around 0. and 1.\n    // This sampling is really where the actual shape of the boat/propeller would matter!\n    frac = frac * (3. - 2. * frac); \n    float k0 = 6.2831 / mix(L0, Lmax, frac);\n\n    float c2_phi = km / k0;\n    float sin_th = sqrt(c2_phi);\n    float cos_th = sqrt(1. - c2_phi);\n    float phi = k0 * dot(r, vec2(sin_th, cos_th));\n    float wave = (phi >= 0.) ? cos(phi) : 0.;\n    if (show_waves) {\n      acc += 2. * wave / nL;  // accumulate wave trains\n    } else {\n      // represent wave crests with lines:\n      acc = max(acc, smoothstep(0.98, 1.0, wave));\n    }\n  }\n  \n  {  // Draw the limiting cone\n    float c_Mach = 1. / 3.;  // critical angle\n    // get the distance to the  cone\n    vec2 shock_n = vec2(c_Mach, sqrt(1. - c_Mach * c_Mach));\n    float d = abs(dot(r, shock_n));\n    shock_mix = 1. - smoothstep(0.001, .005, d);\n  }\n\n  // final mix\n  vec3 col = acc * ocean_col;\n  col = mix(col, shock_col, shock_mix);\n  col = mix(col, boat_col, boat_mix);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGBWh.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[2189, 2189, 2244, 2244, 4016]], "test": "untested"}
{"id": "NtKBWh", "name": "Dark chocolate FBM", "author": "mrange", "description": "License CC0: Dark chocolate FBM\nWorking on a cake related shader and created kind of dark chocolate\nbackground. Nothing unique but different colors than what I usually \ndo so sharing.", "tags": ["2d", "fbm"], "likes": 13, "viewed": 259, "published": 3, "date": "1664430301", "time_retrieved": "2024-07-30T16:29:09.508546", "image_code": "// License CC0: Dark chocolate FBM\n//  Working on a cake related shader and created kind of dark chocolate\n//  background. Nothing unique but different colors than what I usually \n//  do so sharing.\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TTIME       (TAU*TIME)\n#define DOT2(p)     dot(p, p)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// License: CC0, author: Mårten Rånge, found: https://github.com/mrange/glsl-snippets\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat heart(vec2 p) {\n  p.y -= -0.6;\n  p.x = pabs(p.x, 0.125);\n\n  if( p.y+p.x>1.0 )\n      return sqrt(DOT2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n  return sqrt(min(DOT2(p-vec2(0.00,1.00)),\n                  DOT2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 n = floor(p + 0.5);\n  p = fract(p+0.5)-0.5;\n  return n;\n}\n\nfloat hf(vec2 p) {  \n  p *= 0.25;\n  vec2 p0 = p;\n  vec2 n0 = mod2_1(p0);\n  vec2 p1 = p*vec2(1.0, -1.0)+vec2(0.5, 0.66);\n  vec2 n1 = mod2_1(p1);\n  const float ss = 0.60;\n  float d0 = heart(p0/ss)*ss;\n  float d1 = heart(p1/ss)*ss;\n  float d = min(d0, d1);\n  return tanh_approx(smoothstep(0.0, -0.1,d)*exp(8.0*-d));\n}\n\nfloat height(vec2 p) {\n  const mat2 rot1 = ROT(1.0);\n  float tm = 123.0+TTIME/240.0;\n  p += 5.0*vec2(cos(tm), sin(tm*sqrt(0.5)));\n  const float aa = -0.45;\n  const mat2  pp = (1.0/aa)*rot1;\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < 4; ++i) {\n    h += a*hf(p);\n    d += a;\n    a *= aa;\n    p *= pp;\n  }  \n  const float hf = -0.125;\n  return hf*(h/d)+hf;\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  vec2 ppp = p;\n  const float s     = 1.0;\n  const vec3 lp1    = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2    = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lcol1  = HSV2RGB(vec3(0.06, 0.9 , .5));\n  const vec3 lcol2  = HSV2RGB(vec3(0.05, 0.25, 1.0));\n  const vec3 mcol   = HSV2RGB(vec3(0.1 , 0.95, 0.2));\n  const float spe1  = 20.0;\n  const float spe2  = 40.0;\n  float aa = 2.0/RESOLUTION.y;\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  vec3 lpow1 = 0.15*lcol1/DOT2(ld1);\n  vec3 lpow2 = 0.25*lcol2/DOT2(ld2);\n  vec3 dm = mcol*tanh_approx(-h*5.0+0.125);\n  vec3 col = vec3(0.0);\n  col += dm*diff1*lpow1;\n  col += dm*diff2*lpow2;\n  vec3 rm = vec3(1.0)*mix(0.25, 1.0, tanh_approx(-h*1000.0));\n  col += rm*pow(ref1, spe1)*lcol1;\n  col += rm*pow(ref2, spe2)*lcol2;\n\n  const float top = 10.0;\n\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p, q);  \n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKBWh.jpg", "access": "api", "license": "cc0-1.0", "functions": [[592, 592, 614, 614, 760], [1055, 1155, 1174, 1174, 1261], [1263, 1370, 1396, 1396, 1580], [1582, 1642, 1670, 1690, 1766], [1768, 1868, 1907, 1907, 1992], [1994, 2082, 2112, 2112, 2140], [2142, 2260, 2281, 2281, 2514], [2516, 2516, 2543, 2543, 2608], [2610, 2610, 2628, 2628, 2924], [2926, 2926, 2948, 2948, 3311], [3313, 3313, 3334, 3334, 3540], [3542, 3542, 3571, 3571, 4863], [4865, 4865, 4922, 4922, 5084]], "test": "ok"}
{"id": "flVBRw", "name": "Metal Recrystalization", "author": "fenix", "description": "Attempting to simulate the recrystalization of cooling metal. I am primarily trying to demonstrate the effect of cooling rate on grain size.\n*mouse to add heat*\n*shift + mouse to remove heat*\n*space to reset and resume attract mode*", "tags": ["automata", "cellular", "polarization", "crystal", "ising", "annealing", "atomaton"], "likes": 16, "viewed": 291, "published": 3, "date": "1664424039", "time_retrieved": "2024-07-30T16:29:10.871901", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Attempting to simulate the recrystalization of cooling metal. I am primarily trying\n//  to demonstrate the effect of cooling rate on grain size. You should see smaller grains\n//  where the material cools quickly.\n//\n//  I am not any kind of expert on this, but from my Googling and reading Wikipedia, I\n//  believe that the two direction scenes could be called Ising (or Ising-Lenz) models, but\n//  that the more general term is a Classical XY Model.\n//\n//  https://en.wikipedia.org/wiki/Ising_model\n//  https://en.wikipedia.org/wiki/Classical_XY_model\n//  https://en.wikipedia.org/wiki/Recrystallization_(metallurgy)\n//\n//  When above the melting point, the directions become randomized. As the material cools,\n//  it becomes solid, but the atoms are still free to reorient themselves to match their\n//  neighbors. Once the material cools below its recrystalization temperature, the grain\n//  pattern becomes frozen, and the pattern it is frozen in has significant effects on the\n//  material properties such has hardness.\n//\n//  In this shader there is a discrete set of directions the crystals can align to, controlled\n//  by the w component of the state vector (stored in 0, 0 of buffer A). This is randomized\n//  each time the scene resets or when you press the space bar. Lower counts are more\n//  likely so that low (2- and 3-) color scenes have higher chances, just because I think they\n//  look interesting. You can increase MAX_DIRECTIONS but at some point you can't see\n//  much difference.\n//\n//  Clicking interrupts the attract mode and gives you mouse control over the heat. Click\n//  to add heat, shift-click to remove heat. Space resets and resumes the attract mode.\n//\n//  You can see multi-colored micrographs similar to this in real life using a polarized\n//  light and/or various colorizing etchants:\n//\n//  https://vacaero.com/information-resources/metallography-with-george-vander-voort/991-color-metallography.html\n//\n//  Buffer A computes the temperature (mostly just diffusion)\n//  Buffer B computes the grain directions\n//\n// ---------------------------------------------------------------------------------------\n\n\nconst float TWO_PI = 3.141592653589793 * 2.;\n\nvec2 circ(float a)\n{\n    return vec2(sin(a * TWO_PI), cos(a * TWO_PI));\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.x, sc.y, sc.y, -sc.x);\n}\n\nfloat computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular;\n}\n\nconst float MAX_TEMP = 1.0;\n\nvec3 fxBlackBody(float _t)\n{\n    _t = max(0., _t);\n    vec3 temp = vec3(min(1.0, _t / MAX_TEMP), min(1.0, _t / (2.0 * MAX_TEMP)), min(1.0, _t / (3.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dir = texelFetch(iChannel1, ivec2(fragCoord), 0).x;\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    float directions = abs(state.w);\n\n    vec2 steelCoord = rot2((dir + 0.5) * TWO_PI / (directions*2.)) * fragCoord * vec2(2.0, 0.004);\n    vec3 steelNorm = texture(iChannel2, steelCoord/iResolution.xy).xyz;\n\n  \tvec2 p = fragCoord/iResolution.xy;\n    steelNorm = normalize(steelNorm);\n    vec2 c = circ(iTime*0.3)*0.4;\n    vec3 lightDir = normalize(vec3(c.x + 1., 1., c.y + 1.));\n    float steelSpec = computeSpecular(0.8, 15.0, steelNorm, lightDir, vec3(0.0, p.x - 0.5, p.y - 0.5));\n    vec3 steel = vec3(steelSpec) * 0.9 + 0.5;\n\n    vec3 color = sin((dir + 1.) * vec3(5, 11, 14) / directions * 0.5 + iTime*0.25) * 0.3 + 0.7;\n    fragColor.xyz = steel * color;\n    \n    // Add heat radiative light\n    fragColor.xyz += fxBlackBody(texelFetch(iChannel0, ivec2(fragCoord), 0).x) * 0.5;\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// -----------------------------------------------------------------------------------------------\n// Computes the temperature, which is mostly just diffusion cooling inwards from the edge,\n// but there is a constant sapping of heat simulating the heat being lost in the Z direction also.\n// -----------------------------------------------------------------------------------------------\n\nconst float HEAT_LOSS = 0.99;\n\nfloat initHeat(vec2 fc)\n{\n    vec3 res = iResolution;\n    vec2 coord = (fc/iResolution.y)*2. - vec2(iResolution.x / iResolution.y, 1.);\n    switch(iFrame % 7)\n    {\n        case 0:\n            // spiral\n            return atan(coord.y, coord.x) + 4.;\n            \n        case 1:\n            // phoenix\n            coord.x *= 0.6;\n            float sdp = sdPhoenix(coord);\n            if (sdp < 0.) return 2.5;\n            return 0.9;\n            \n        case 2:\n            // diagonal\n            return abs(coord.x + coord.y) * 1.6 + 0.9;\n\n        case 3:\n            // checker       \n            vec2 fl = floor(coord * 5.);\n            if ((int(fl.x) + int(fl.y)) % 2 == 0) return 2.5;\n            return 0.83;\n            \n        case 4:\n            // multi-spiral\n            return mod((atan(coord.y, coord.x) + 4.) * 3.0, 4.0) + 0.82;\n            \n        case 5:\n            // vertical fade\n            return square(coord.y - 1.0) + .9;\n\n        case 6:\n            // stripes\n            return step(0.5, mod(coord.x * 3.0, 1.0)) * 1.6 + 0.84;\n            \n    }\n}\n\nvoid handleState(inout vec4 fragColor, ivec2 ifc)\n{\n    vec3 h = hash(uvec3(ifc.y, ifc.x, iFrame * 984 + int(iDate.w)));\n    \n    if (iFrame == 0) fragColor = vec4(0, 0, -1, 3);\n    if (iMouse.z > 0.)\n    {\n        // Remember last mouse position so we can draw a line\n        fragColor.xy = iMouse.xy;\n    }\n\n    if (keyClick(KEY_SPACE) ||\n        abs(fragColor.z) != iResolution.x * iResolution.y ||\n        (fragColor.xy == vec2(0) && (iFrame % 331 == 0))) \n    {\n        if (fragColor.z >= 0.)\n        {\n            // Compute how many directions to allow\n            fragColor.w = max(2., floor(pow(h.x, 2.) * float(MAX_DIRECTIONS)));\n        }\n        fragColor.xy = vec2(0);\n        fragColor.z = -iResolution.x * iResolution.y;\n    }\n    else\n    {\n        // Reset the reset\n        fragColor.z = abs(fragColor.z);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n\n    fragColor = texelFetch(iChannel0, ifc, 0);\n    \n    if (ifc == ivec2(0))\n    {\n        handleState(fragColor, ifc);\n        return;\n    }\n    \n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    if (iFrame == 0 || state.z < 0.)\n    {\n        fragColor.x = initHeat(fragCoord);\n        fragColor.yzw = vec3(0);\n    }\n    else\n    {\n        // Diffuse heat\n        float avgTemp = 0.;\n        const int RANGE = 3;\n        for (int x = -RANGE; x <= RANGE; ++x)\n        {\n            for (int y = -RANGE; y <= RANGE; ++y)\n            {\n                ivec2 ni = ifc + ivec2(x, y);\n                if (ni == ivec2(0)) continue;\n                vec4 n = texelFetch(iChannel0, ni, 0);\n                avgTemp += n.x;\n            }\n        }\n        \n        fragColor.r = HEAT_LOSS * avgTemp / square(float(RANGE + RANGE + 1));\n        \n        // Handle mouse input\n        if (iMouse.z > 0. && iMouse.w < 0. && state.xy != vec2(0))\n        {\n            float dist = sqrt(linePointDist2(iMouse.xy, state.xy, fragCoord));\n            \n            if (keyDown(KEY_SHIFT))\n            {\n                fragColor.r -= 20. / dist;\n            }\n            else\n            {\n                fragColor.r += 10. / dist;\n            }\n            \n            fragColor.r = clamp(fragColor.r, 0., 2.5);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int MAX_DIRECTIONS = 23;\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\n// from my Spark Phoenix shader: https://www.shadertoy.com/view/7tGcRz\nconst int NUM_WING_POINTS = 25;\nvec2 WING_POINTS[NUM_WING_POINTS] = vec2[](\n    vec2(-0.9,  0.8),\n    vec2(-0.65,  0.5),\n    vec2(-0.85,  0.45),\n    vec2(-0.55,  0.3),\n    vec2(-0.75,  0.125),\n    vec2(-0.45,  0.1),\n    vec2(-0.63,  -0.2),\n    vec2(-0.35, -0.1),\n    vec2(-0.51,  -0.45),\n    vec2(-0.25, -0.3),\n    vec2(-0.2, -0.3),\n    vec2(-0.1, -0.4),\n    vec2(-0.075, -0.6),\n    vec2(-0.175, -0.75),\n    vec2(-0.05, -0.7),\n    vec2(-0.15, -0.85),\n    vec2(-0.045, -0.8),\n    vec2(-0.05, -0.9),\n    vec2(-0.0, -0.85),\n    vec2(-0.0, 0.125),\n    vec2(-0.045, 0.0),\n    vec2(-0.125, -0.1),\n    vec2(-0.2, -0.0),\n    vec2(-0.3,  0.2),\n    vec2(-0.6,  0.6)\n);\n\nfloat sdPolygon( in vec2[NUM_WING_POINTS] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=NUM_WING_POINTS-1; i<NUM_WING_POINTS; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nconst int NUM_HEAD_POINTS = 9;\nvec2 HEAD_POINTS[NUM_HEAD_POINTS] = vec2[](\n    vec2(-0.0, -0.2),\n    vec2(0.0, 0.3),\n    vec2(-0.1, 0.4),\n    vec2(-0.2, 0.425),\n    vec2(-0.145, 0.5),\n    vec2(-0.05, 0.7),\n    vec2(0.15, 0.75),\n    vec2(0.25, 0.55),\n    vec2(0.2, 0.35)\n);\n\nfloat sdPolygon( in vec2[NUM_HEAD_POINTS] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=NUM_HEAD_POINTS-1; i<NUM_HEAD_POINTS; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n\nfloat sdPhoenix(in vec2 p)\n{\n    float minDist = sdPolygon(WING_POINTS, p);\n    minDist = min(minDist, sdPolygon(WING_POINTS, vec2(-p.x, p.y)));\n    minDist = min(minDist, sdPolygon(HEAD_POINTS, p));\n    return minDist;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    return dot(closestDelta, closestDelta);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n", "buffer_b_code": "// --------------------------------------------------------------------------------------------\n// Computes the grain directions by attempting to match nearby pixels under correct conditions.\n// --------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n\n    vec3 h = hash(uvec3(ifc.y, ifc.x, iFrame + int(iDate.w)));\n    \n    fragColor = texelFetch(iChannel1, ifc, 0);\n    \n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    float directions = abs(state.w);\n    \n    if (iFrame == 0 || state.z < 0.)\n    {\n        fragColor.x = floor(h.x * float(directions));\n        fragColor.zw = vec2(0);\n    }\n    else\n    {\n        float t = texelFetch(iChannel0, ifc, 0).x;\n        if (t > 0.99 + 0.9 * h.x)\n        {\n            fragColor.x = floor(h.y * float(directions));            \n        }\n        else if (t > 0.8 && h.x < 0.99)\n        {\n            // Count how many neighbors in range have each possible direction\n            int counts[MAX_DIRECTIONS];\n            for (int i = 0; i < int(directions); ++i)\n            {\n                counts[i] = 0;\n            }\n\n            const int RANGE = 3;\n            for (int x = -RANGE; x <= RANGE; ++x)\n            {\n                for (int y = -RANGE; y <= RANGE; ++y)\n                {\n                    ivec2 ni = ifc + ivec2(x, y);\n                    if (any(lessThan(ni, ivec2(0)))) continue;\n                    if (any(greaterThanEqual(ni, ivec2(iResolution)))) continue;\n                    vec4 n = texelFetch(iChannel1, ni, 0);\n                    counts[int(n.x)]++;\n                }\n            }\n\n            // Find the direction most popular among neighbors\n            int bestCount = -1;\n            int bestDir;\n            bool unique;\n\n            for (int d = 0; d < int(directions); ++d)\n            {\n                if (counts[d] > bestCount)\n                {\n                    bestCount = counts[d];\n                    bestDir = d;\n                    unique = true;\n                }\n                else if (counts[d] == bestCount)\n                {\n                    unique = false;\n                }\n            }\n\n            if (unique)\n            {\n                fragColor.r = float(bestDir);\n            }\n        }\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVBRw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[2401, 2401, 2421, 2421, 2474], [2476, 2476, 2496, 2496, 2576], [2578, 2578, 2741, 2741, 2946], [2977, 2977, 3005, 3005, 3180], [3182, 3182, 3239, 3239, 4164]], "test": "untested"}
{"id": "slKfWR", "name": "Mach cone visualisation", "author": "skal", "description": "Simulation for Mach cone: imagine a boat dropping stones at sea regularly behind her!\n\nEach produces a wave train that accumulates.\nHit 'space' to see the total waves.\n\nmouse-x controls the interval between 'stones'.\nmouse-y changes the boat speed.", "tags": ["fluid", "shockwave", "shipwake", "machcone"], "likes": 7, "viewed": 263, "published": 3, "date": "1664376769", "time_retrieved": "2024-07-30T16:29:13.934712", "image_code": "// Mach cone visualisation\n//\n// boat is moving left to right at constant speed (mouse-y)\n// She drops 'stones' at regular interval (mouse-x), each stone\n// producing a wave of wavelength L0, decaying in amplitude (Phi0).\n// The accumulated result is either a move-ahead planar wave in\n// the sub-sonic case, or a lagging-behind Mach cone for supersonic.\n//\n//   Hope the vizualisation is telling!\n//   See also:  https://www.shadertoy.com/view/stGBWh\n//\n// skal/ (Pascal Massimino)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// Some physics\nconst float WS = 10.0;   // [m/px] world scale (px -> m)\nconst float V0 = 0.10;   // min boat speed [m/s]\nconst float V1 = 1.00;   // max boat speed [m/s]\nconst float g  = 9.81;   // gravity\nconst float dE = 0.5;    // max distance between emitters [m]\nconst float L0 = 30.;    // wavelength of emitter [m]\nconst float A0 = 0.5;    // global wave amplitude factor (mostly esthetic)\nconst float Phi0 = 9.0;  // phase-based decay length for emitter's amp\n\n// Boat\nconst vec2 boat_pos0 = vec2(0.00, -0.08);        // initial boat position [m]\nconst vec2 boat_dir  = normalize(vec2(1., 0.0));   // direction of the boat [m/s]\n\n// Color\nconst vec3 ocean_col = vec3(.3, .5, .9);   // ocean background color\nconst vec3 boat_col  = vec3(.3, .7, .2);   // boat color (~green)\nconst vec3 emit_col  = vec3(.5, .9, .2);   // emitter color\nconst vec3 shock_col = vec3(.6, .6, .1);   // shock-wave color (~yellow)\nconst vec3 mach1_col = vec3(.8, .3, .3);   // faint line materializing Mach=1\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  bool show_waves = (texelFetch(iChannel0, ivec2(32, 0),0 ).x > 0.5);\n  vec2 uv = 2. * fragCoord / iResolution.yy - vec2(0.0, 1.0);  // y-screen = [-1, 1]\n  vec2 M = iMouse.xy / iResolution.xy;\n  if (length(iMouse.xy) < 4.) M = vec2(0.2, 0.3);\n\n  // boat speed\n  float V = mix(V0, V1, M.y);\n  // emitter interval\n  float dt = (dE / V) * mix(0.01, 1.12, M.x);\n\n  // boat position and speed\n  float screen_period = 2. * iResolution.x / iResolution.y;\n  float cur_t = mod(iTime, 1.5 * screen_period / V);\n  vec2 boat_v = V * boat_dir;\n  vec2 boat_pos = boat_pos0 + cur_t * boat_v;\n\n  // monochromatic emitter with wavelength L0\n  float L = L0 / WS;\n  float k = 6.2831 / L;\n  float w = sqrt(g * k);\n\n  // color mixing factors\n  float emitter_mix = 0.;\n  float shock_mix = 0.;\n  float mach1_mix = 0.;\n  float boat_mix = 1. - smoothstep(0.02, 0.03, length(uv - boat_pos));\n\n  // draw a faint line at the Mach1 transition, for the mouse-y\n  float dy = abs(2. * (sqrt(g / k) / WS - V0) / (V1 - V0) - 1. - uv.y);\n  mach1_mix = 1. - step(0.005, dy);\n  mach1_mix *= .4 * step(3., mod(fragCoord.x, 10.));  // dotted\n\n  // Accumulate emitter's amplitude\n  float acc = 0.;\n  for (float t = -10. * dt; t <= cur_t; t += dt) {\n    vec2 emitter = boat_pos0 + t * boat_v;\n    float r = length(emitter - uv) * WS;  // distance to emitter\n    float phi = w * (cur_t - t) - k * r;\n    float base_wave = (phi >= 0.) ? cos(phi) : 0.;\n    float amp = exp(-phi / Phi0);  // emitter strength decay\n    float wave = amp * base_wave;\n    if (show_waves) {\n      acc += A0 * wave;  // accumulate wave trains\n    } else {\n      // represent waves with circles:\n      wave = smoothstep(0.98, 1.00, base_wave) * amp;\n      acc = max(acc, wave);\n      // and draw spots at emitters' location:\n      float emitter_strength = amp * (1. - smoothstep(0.15, 0.5, r));\n      emitter_mix = max(emitter_mix, emitter_strength);\n    }\n  }\n\n  // Draw the shock-wave for Mach >= 1\n  float c_Mach = sqrt(g / k) / (V * WS);\n  if (c_Mach <= 1.) {\n     vec2 r = uv - boat_pos;\n     // rotate along the boat's direction\n     r = mat2(boat_dir.x, -boat_dir.y, boat_dir.y, boat_dir.x) * r;\n     // fold\n     r = vec2(r.x, abs(r.y));\n     // and get the distance to the Mach cone\n     vec2 shock_n = vec2(c_Mach, sqrt(1. - c_Mach * c_Mach));\n     float d = abs(dot(r, shock_n));\n     shock_mix = 1. - smoothstep(0.001, .005, d);\n  }\n \n\n  // final mix\n  acc = 0.5 + 0.5 * acc;\n\n  vec3 col = acc * ocean_col;\n  col = mix(col, mach1_col, mach1_mix);\n  col = mix(col, emit_col, emitter_mix);\n  col = mix(col, shock_col, shock_mix);\n  col = mix(col, boat_col, boat_mix);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKfWR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1549, 1549, 1604, 1604, 4251]], "test": "untested"}
{"id": "ftVBDz", "name": "generative art deco 2", "author": "morisil", "description": "I just played a bit with the coefficients of my original \"generative art deco\". I changed color grading to be based on polar coordinates and put the shape in motion.", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 15, "viewed": 376, "published": 3, "date": "1664364590", "time_retrieved": "2024-07-30T16:29:14.754520", "image_code": "// Fork of \"generative art deco\" by morisil. https://shadertoy.com/view/7sKfDd\n// 2022-09-28 11:25:15\n\n// Copyright Kazimierz Pogoda, 2022 - https://xemantic.com/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// copyright statement borrowed from Inigo Quilez\n\n// Music by Giovanni Sollima, L'invenzione del nero:\n// https://soundcloud.com/giovanni-sollima/linvenzione-del-nero\n\n// See also The Mathematics of Perception to check the ideas behind:\n// https://www.shadertoy.com/view/7sVBzK\n\nconst float SHAPE_SIZE = .618;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 10.;\nconst float INITIAL_LUMA = .4;\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat sdPolygon(in float angle, in float distance) {\n  float segment = TWO_PI / 4.0;\n  return cos(floor(.5 + angle / segment) * segment - angle) * distance;\n}\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y) + sin(iTime * .08) * 9.0;\n    dist = sdPolygon(angle, dist);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    vec2 origSt = st;\n    st *= rotate2d(sin(iTime * .14) * .3);\n    st *= (sin(iTime * .15) + 2.) * .3;\n    st *= log(length(st * .28)) * .8;\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .5 + sin(iTime * .5) * .3;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .12), cos(iTime * .13));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1 + getColorComponent(center, modScale, .04) * 1.;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .6;\n        blur *= .63;\n    }\n    const float GRADING_INTENSITY = .4;\n    vec3 topGrading = vec3(\n        1. - sin(iTime * 1.1 * .3) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.2 * .3) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.3 * .3) * GRADING_INTENSITY\n    );\n    vec3 bottomGrading = vec3(\n        1. + cos(iTime * 1.4 * .3) * GRADING_INTENSITY,\n        1. - cos(iTime * 1.5 * .3) * GRADING_INTENSITY,\n        1. - cos(iTime * 1.6 * .3) * GRADING_INTENSITY\n    );\n    vec3 colorGrading = mix(topGrading, bottomGrading, length(origSt));\n    fragColor = vec4(pow(color.rgb, colorGrading), 1.);\n}", "image_inputs": [{"id": 29472, "src": "https://soundcloud.com/giovanni-sollima/linvenzione-del-nero", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVBDz.jpg", "access": "api", "license": "proprietary-license", "functions": [[1229, 1229, 1257, 1257, 1343], [1345, 1345, 1397, 1397, 1503], [1505, 1505, 1576, 1576, 1872], [1874, 1874, 1929, 1929, 3581]], "test": "untested"}
{"id": "7lGfDz", "name": "Tower Bubble", "author": "Visiware", "description": "Tower with chained bubble", "tags": ["raymarching"], "likes": 0, "viewed": 248, "published": 3, "date": "1664348258", "time_retrieved": "2024-07-30T16:29:15.642146", "image_code": "// License: MIT\n// This shader was ported to shadertoy from my GLSL experiments on PC for a video: https://www.youtube.com/watch?v=PBI_yvz25aI\n// There is very many roughs\n\n#define PI 3.1415926535897932384626433832795\n#define PI2 (PI*2.)\n\n#define radians(x) ((x/360.0*PI2))\n\n#define FOV 1.309\n\nfloat intersectSDF(float distA,float distB) {\n\treturn max(distA,distB);\n}\n\nfloat unionSDF(float distA,float distB) {\n\treturn min(distA,distB);\n}\n\nfloat differenceSDF(float distA,float distB) {\n\treturn max(distA,-distB);\n}\n\nfloat smoothIntersectSDF(float distA, float distB, float k) {\n\tfloat h = clamp(0.5 - 0.5*(distA - distB)/k,0.0,1.0);\n\treturn mix(distA,distB,h) + k*h*(1.0 - h); \n}\n\nfloat smoothUnionSDF(float distA,float distB,float k) {\n\tfloat h = clamp(0.5 + 0.5*(distA - distB)/k,0.0,1.0);\n \treturn mix(distA,distB,h) - k*h*(1.0 - h); \n}\n\nfloat smoothDifferenceSDF(float distA, float distB, float k) {\n\tfloat h = clamp(0.5 - 0.5*(distB + distA)/k,0.0,1.0);\n\treturn mix(distA,-distB,h) + k*h*(1.0 - h); \n}\n\n\n\nmat4 TransMatrix(float x,float y,float z) {\n\tmat4 m = mat4(1);\n\t\n\tm[3][0] = x;\n\tm[3][1] = y;\n\tm[3][2] = z;\n\t\n\treturn m;\n}\n\nmat4 RotMatrixX(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[1][1] = cos(angle);\n\tm[2][1] = -sin(angle);\n\tm[1][2] = sin(angle);\n\tm[2][2] = cos(angle);\n\t\n\treturn m;\n}\n\n\nmat4 RotMatrixY(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][2] = -sin(angle);\n\tm[2][0] = sin(angle);\n\tm[2][2] = cos(angle);\n\t\n\treturn m;\n}\n\nmat4 RotMatrixZ(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][1] = sin(angle);\n\tm[1][0] = -sin(angle);\n\tm[1][1] = cos(angle);\n\t\n\treturn m;\n}\n\n\n\nstruct MarchRet_t {\n\tfloat d;\n\tint i;\n};\n\n\nstruct CastRet_t {\n\tvec3 intersect;\n\tvec3 normal;\n\tbool casted;\n\t\n\tMarchRet_t march;\n};\n\n#define SMALLADD 0.004\n\n#define DISTMAX 3000.0\n\n\nMarchRet_t marchUnionSDF(MarchRet_t a,MarchRet_t b) {\n\tif (a.d < b.d) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn b;\n\t}\n}\n\n\n\n#define HEX_SEMISIZE 2.1\n#define HEX_SIZE (HEX_SEMISIZE*2.)\n#define HEX_MAXRADIUS (HEX_SEMISIZE/0.866)\n\n#define HEXAMAP_HEIGHT 10.0\n\n\n\nMarchRet_t HexagonSDF(vec3 ori) {\n\tif (ori.y > HEXAMAP_HEIGHT) {\n\t\treturn MarchRet_t(ori.y - (HEXAMAP_HEIGHT - 1.),0);\n\t}\n\t\n\tivec2 coord;\n\t\n\tvec3 o = ori;\n\tint zv = int(ori.z/5.0);\n\tif (ori.z < 0.) {\n\t\tzv++;\n\t}\n\tif (zv%2 == 1) {\n\t\to.x += HEX_MAXRADIUS;\n\t}\n\tcoord.x = int(o.x/5.0);\n\tcoord.y = int(o.z/5.0);\n\to.x = mod(o.x,5.0) - 2.5;\n\to.z = mod(o.z,5.0) - 2.5;\n\t\n\t\n\tvec2 norm0 = vec2(cos(radians(30.)),sin(radians(30.)));\n\tvec2 norm1 = vec2(cos(radians(90.)),sin(radians(90.)));\n\tvec2 norm2 = vec2(cos(radians(150.)),sin(radians(150.)));\n\t\n\tvec2 dir = normalize(o.xz);\n\t\n\tfloat v0 = length(o.xz)*sin(acos(dot(dir,norm0)));\n\tfloat v1 = length(o.xz)*sin(acos(dot(dir,norm1)));\n\tfloat v2 = length(o.xz)*sin(acos(dot(dir,norm2)));\n\t\n\tfloat d = max(max(max(abs(v0) - HEX_SEMISIZE,abs(v1) - HEX_SEMISIZE),abs(v2) - HEX_SEMISIZE),o.y + cos(float(coord.x)*3.0) + sin(float(coord.y)*1.5) - 1.0);\n\t\n\td /= 1.2;\n\t\n\treturn MarchRet_t(d,0);\n}\n\n\nMarchRet_t WallsSDF(vec3 o,vec3 dir) {\n\tfloat minuscube = max(-length(o.xz) + 30.,-o.y + 40.);\n\t\n\tfloat d = differenceSDF(length(o.xz) - 50.,minuscube);\n\t\n\treturn MarchRet_t(d,1);\n}\n\n\n\n#define CHAIN_WIDTH 800.0\n\nMarchRet_t ChainSDF(vec3 o) {\n\to = (RotMatrixZ(radians(239.98 - 30.0*(o.y/CHAIN_WIDTH)))*vec4(o,1.0)).xyz; // There is a bug, because this is a ported version\n\t\n\tfloat yv = o.y/1.5;\n\t\n\tfloat my = mod(yv,PI2);\n\t\n\tfloat av = sin(yv)*1.2;\n\t\n\tfloat d0 = length(vec2(o.x + av*float(my < PI2/2.),o.z + av*float(my >= PI2/2.))) - 0.5;\n\tfloat d1 = length(vec2(o.x + -av*float(my < PI2/2.),o.z + -av*float(my >= PI2/2.))) - 0.5;\n\t\n\tfloat d = smoothUnionSDF(d0,d1,0.25);\n\t\n\td = intersectSDF(d,max(o.y - CHAIN_WIDTH,-o.y));\n\t\n\treturn MarchRet_t(d,2);\n}\n\nMarchRet_t MainCloudSDF(vec3 o) {\n\treturn MarchRet_t(length(o) - 50.,3);\n}\n\n\nMarchRet_t SceneSDF(vec3 ori,vec3 dir) {\n\tMarchRet_t ret;\n\tret.i = 0;\n\t\n\tret = HexagonSDF(ori);\n\t\n\tret = marchUnionSDF(ret,WallsSDF(ori,dir));\n\t\n\tret = marchUnionSDF(ret,ChainSDF(ori + vec3(0,-20,0)));\n\t\n\tret = marchUnionSDF(ret,MainCloudSDF(ori + vec3(-600,-500,0)));\n\t\n\treturn ret;\n}\n\n#define NORM_EPSILON 0.0001\n\nvec3 SceneNormal(vec3 ori) {\n\treturn normalize(vec3(SceneSDF(vec3(ori.x + NORM_EPSILON,ori.y,ori.z),vec3(0,1,0)).d - SceneSDF(vec3(ori.x - NORM_EPSILON,ori.y,ori.z),vec3(0,1,0)).d,\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y + NORM_EPSILON,ori.z),vec3(0,1,0)).d - SceneSDF(vec3(ori.x,ori.y - NORM_EPSILON,ori.z),vec3(0,1,0)).d,\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y,ori.z + NORM_EPSILON),vec3(0,1,0)).d - SceneSDF(vec3(ori.x,ori.y,ori.z - NORM_EPSILON),vec3(0,1,0)).d));\n}\n\n\n\n#define ITERMAX 200\n\n#define EPSILON 0.008\n\nCastRet_t TraceObjects(vec3 pos,vec3 dir,float outmax) {\n\tCastRet_t maincast;\n\t\n\tmaincast.intersect = pos;\n\tmaincast.normal = vec3(0.0,0.0,0.0);\n\tmaincast.casted = false;\n\t\n\t\n\t\n\tvec3 ori = pos;\n\tfloat l = 0.;\n\t\n\tfor (int i = 0; i < ITERMAX; i++) {\n\t\tMarchRet_t march = SceneSDF(ori,dir);\n\t\t\n\t\tfloat d = march.d/1.5;\n\t\t\n\t\t\n\t\tif (l > outmax) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tl += d;\n\t\t\n\t\t\n\t\tif (d < EPSILON) {\n\t\t\tvec3 epspos = ori - dir*EPSILON;\n\t\t\t\n\t\t\tmaincast.casted = true;\n\t\t\tmaincast.intersect = epspos;\n\t\t\tmaincast.normal = SceneNormal(epspos);\n\t\t\t\n\t\t\tmaincast.march = march;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (d > DISTMAX) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tori += dir*d;\n\t}\n\t\n\treturn maincast;\n}\n\n\n\nvec3 ColorByMaterial(int index) {\n\tif (index == 0) {\n        return vec3(1.0,1.0,0.95);\n    }\n    else if (index == 1) {\n        return vec3(1.0,0.9,0.0);\n    }\n    else if (index == 2) {\n        return vec3(0.1,0.8,0.95);\n    }\n    else if (index == 3) {\n        return vec3(0.0,0.7,0.8);\n    }\n    return vec3(0);\n}\n\n\n\nbool mat_traceshadow(int index) {\n    return index == 1;\n}\n\nfloat mat_specular(int index) {\n    if (index == 0) {\n        return 900.0;\n    }\n    else if (index == 1) {\n        return 30.0;\n    }\n    else if (index == 2) {\n        return 80.0;\n    }\n    else if (index == 3) {\n        return 75.0;\n    }\n    return 0.0;\n}\n\n\n\n#define MINCOLOR 0.04\n\nvec3 RaytraceObjects(vec3 pos,vec3 dir,vec3 camera_pos) {\n\tvec3 color = vec3(0.0,0.0,0.0);\n\t\n\tCastRet_t maincast = TraceObjects(pos,dir,DISTMAX);\n\t\n\tif (maincast.casted) {\n\t\tcolor = ColorByMaterial(maincast.march.i);\n\t\t\n\t\tvec3 lightpos = camera_pos + vec3(1.0,0,0);\n\t\tvec3 lightvecfull = lightpos - maincast.intersect;\n\t\tvec3 lightvec = normalize(lightvecfull);\n\t\t\n\t\tfloat cval = dot(maincast.normal,lightvec);\n\t\t\n\t\tbool shadowcasted = false;\n\t\t\n\t\tif (mat_traceshadow(maincast.march.i)) {\n\t\t\tvec3 shadow_pos = maincast.intersect + lightvec*SMALLADD;\n\t\t\t\n\t\t\t\n\t\t\tCastRet_t shadowcast = TraceObjects(shadow_pos,lightvec,length(lightvecfull));\n\t\t\tshadowcasted = shadowcast.casted;\n\t\t\t\n\t\t\t\n\t\t\tfloat spec = mat_specular(maincast.march.i);\n\t\t\t\n\t\t\tvec3 refl = normalize(maincast.normal*2.*dot(maincast.normal,lightvec) - lightvec);\n\t\t\t\n\t\t\tvec3 tocam = normalize(camera_pos - maincast.intersect);\n\t\t\t\n\t\t\tfloat cosangle = clamp(dot(tocam,refl),0.,1.);\n\t\t\tcval += pow(cosangle,spec);\n\t\t}\n\t\t\n\t\tif (cval < 0.0) {\n\t\t\tcolor = color*MINCOLOR;\n\t\t}\n\t\telse {\n\t\t\tif (shadowcasted) {\n\t\t\t\tcolor = color*MINCOLOR;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = color*max(MINCOLOR,cval);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn color;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float x = fragCoord.x;\n\tfloat y = fragCoord.y;\n    \n    mat4 camera = RotMatrixY(iTime*2.)*TransMatrix(150.0,300.0,1000.0 - 600.0*sin(iTime*0.97));\n    \n    mat4 camera_notrans = camera;\n    camera_notrans[3][0] = 0.0;\n    camera_notrans[3][1] = 0.0;\n    camera_notrans[3][2] = 0.0;\n    \n\tvec3 pos = (camera*vec4(0.0,0.0,0.0,1.0)).xyz;\n\tvec3 dir = (camera_notrans*normalize(vec4((x - iResolution.x/2.0)/iResolution.x*tan(FOV/2.0)*iResolution.x/iResolution.y,(y - iResolution.y/2.0)/iResolution.y*tan(FOV/2.0),-1.0,1.0))).xyz;\n\t\n\tfragColor = vec4(RaytraceObjects(pos,dir,vec3(camera[3][0],camera[3][1],camera[3][2])),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGfDz.jpg", "access": "api", "license": "mit", "functions": [[294, 294, 339, 339, 367], [369, 369, 410, 410, 438], [440, 440, 486, 486, 515], [517, 517, 578, 578, 680], [682, 682, 737, 737, 840], [842, 842, 904, 904, 1007], [1011, 1011, 1054, 1054, 1132], [1134, 1134, 1164, 1164, 1293], [1296, 1296, 1326, 1326, 1455], [1457, 1457, 1487, 1487, 1616], [1801, 1801, 1854, 1854, 1912], [2051, 2051, 2084, 2084, 2978], [2981, 2981, 3019, 3019, 3162], [3193, 3193, 3222, 3222, 3734], [3736, 3736, 3769, 3769, 3810], [3813, 3813, 3853, 3853, 4098], [4129, 4129, 4157, 4157, 4587], [4635, 4635, 4691, 4691, 5302], [5306, 5306, 5339, 5339, 5623], [5627, 5627, 5660, 5660, 5685], [5687, 5687, 5718, 5718, 5948], [5975, 5975, 6032, 6032, 7149], [7155, 7155, 7211, 7211, 7839]], "test": "untested"}
{"id": "7tGfDz", "name": "CineShader.com", "author": "kamonlai", "description": "This is my shader.", "tags": ["cineshader"], "likes": 0, "viewed": 2428, "published": 3, "date": "1664347213", "time_retrieved": "2024-07-30T16:29:16.491874", "image_code": "\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm( vec3 p ) {\n        float f = 0.0;\n        f += 0.5000*snoise( p ); p = p*2.02;\n        f += 0.2500*snoise( p ); p = p*2.03;\n        f += 0.1250*snoise( p ); p = p*2.01;\n        f += 0.0625*snoise( p );\n        return f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    float noise = 0.25 + fbm(vec3(uv * 12.0 + (iMouse.xy - fragCoord.xy) * mouseRatio * 0.05, iTime * 0.18 + 0.5 * mouseRatio));\n    noise *= 0.25 + snoise(vec3(uv * 4.0 + 1.5, iTime * 0.15));\n    fragColor = vec4(1.0, 1.0, 1.0, noise);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 1\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 55, 76, 76, 113], [114, 114, 141, 141, 189], [191, 191, 212, 212, 2194], [2196, 2196, 2217, 2217, 2435], [2437, 2437, 2494, 2494, 2856]], "test": "untested"}
{"id": "7lyfRw", "name": "My first scene", "author": "ArmandB", "description": "doughnut.", "tags": ["3d", "struct", "doughnut"], "likes": 3, "viewed": 233, "published": 3, "date": "1664344018", "time_retrieved": "2024-07-30T16:29:17.272786", "image_code": "//scene setup\n\nconst Material myMat = Material(\n    vec3(1,0.5,0), //base color\n    vec3(1,0.5,0), //ambient color\n    vec3(1,0.5,0), //diffuse color\n    vec3(1,1,1), //specular color\n    0.5, //ambient amount\n    1.0, //diffuse amount\n    0.1, //specular amount\n    1.0  //smoothness\n);\n\nFog myFog = Fog(10.0,20.0,vec3(0.6));\n\nPointLight myLight = PointLight(vec3(0,20,0),vec3(1));\n\nSphere mySphere = Sphere(vec3(0,0,10), vec3(0), vec3(0,0,10), 2.0, myMat);\n\nTorus myTorus = Torus(vec3(0,0,0), vec3(PI/2.0,0,0), vec3(0,0,0), 2.0, 0.8, myMat);\n\n//main drawing\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float time = iTime*0.1;\n    Camera cam = createCamera(fragCoord.xy, iResolution.xy, vec3(-sin(time)*5.0,3,-cos(time)*5.0), vec3(sin(time)/10.0 + 0.5,time,0), 1.0);\n    vec4 col = vec4(0,0,0,-1);\n    \n    //set depth\n    col.w = torIntersect(cam.ray, myTorus);\n    //col.w = sphIntersect(cam.ray, mySphere);\n    if (col.w >= 0.0){ //draw the hit object\n        vec3 drawnPoint = col.w*cam.ray.direction + cam.ray.origin;\n        vec3 normal = torNormal(drawnPoint, myTorus);\n        //vec3 normal = normalize(drawnPoint - mySphere.origin);\n        vec3 lightDirection = myLight.origin - drawnPoint;\n        Material mat = mySphere.mat;\n        \n        vec3 icingColor = vec3(0.7,0.7,0.6);\n        vec3 baseColor = vec3(0.5,0.25,0) - 0.15*voronoi3d(rotate3d(drawnPoint, -myTorus.rotation, myTorus.origin));\n        \n        float icingInterpolant = voronoi3d(rotate3d(drawnPoint, -myTorus.rotation, myTorus.origin)*2.0) + 2.0*rotate3d(drawnPoint, -myTorus.rotation, myTorus.origin).z + 0.5;\n        vec3 b = mix(icingColor, baseColor, smoothstep(0.0, 0.01, icingInterpolant));\n        normal = mix(roundNormal(0.6, icingInterpolant, normal), normal, smoothstep(0.0, 0.2, icingInterpolant));\n\n        float cracks = voronoi3dedges(rotate3d(drawnPoint, -myTorus.rotation, myTorus.origin)*10.0)*0.1;\n\n        float d = clamp(dot(normal,normalize(lightDirection))*mat.diffuse,0.0,1.0);\n        float s;\n        if (icingInterpolant < 0.02){ //icing\n            s = pow(max(dot(reflect(cam.ray.direction,normal),normalize(lightDirection)),0.0),mat.smoothness + cracks*10.0)*(mat.specular + cracks*10.0);\n        } else { //dough\n            s = pow(max(dot(reflect(cam.ray.direction,normal),normalize(lightDirection)),0.0),mat.smoothness)*mat.specular;\n        }\n        float a = mat.ambient;\n        col.rgb = b*a + b*d + mat.specularColor*s;\n        //col.rgb = normal;\n        col.rgb = mix(col.rgb,myFog.color,smoothstep(myFog.start, myFog.end, col.w));\n    \n    } else { //draw the sky\n    \n        float interpolant = dot(cam.ray.direction,vec3(0,1,0));\n        vec3 water = vec3(0.3,0.4,0.8);\n        vec3 sky = vec3(0,0.6,1);\n        vec3 haze = vec3(0.9);\n        if (interpolant < 0.0) {\n            col.rgb = mix(haze, water, -interpolant);\n        } else {\n            col.rgb = mix(haze, sky, interpolant);\n        }\n    }\n    fragColor = col;\n}", "image_inputs": [], "common_code": "const float PI = 3.14;\n\nstruct Material {\n    vec3 baseColor;\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float ambient;\n    float diffuse;\n    float specular;\n    float smoothness;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Fog {\n    float start;\n    float end;\n    vec3 color;\n};\n\nstruct Sphere {\n    vec3 origin;\n    vec3 rotation;\n    vec3 pivot;\n    float radius;\n    Material mat;\n};\n\nstruct Torus {\n    vec3 origin;\n    vec3 rotation;\n    vec3 pivot;\n    float width;\n    float radius;\n    Material mat;\n};\n\nstruct PointLight {\n    vec3 origin;\n    vec3 color;\n};\n\nstruct Camera {\n    vec3 position;\n    Ray ray;\n};\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    //calculate consts\n    float cx = cos(angle.x);\n    float sx = sin(angle.x);\n    float cy = cos(angle.y);\n    float sy = sin(angle.y);\n    float cz = cos(angle.z);\n    float sz = sin(angle.z);\n    //rotate point\n    point *= mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n    point += origin; //add pivot\n    return point;\n}\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 cameraPos, vec3 camRot, float frustumLength){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y * 2.0, frustumLength);\n    Ray ray = Ray(rotate3d(uv,camRot,vec3(0)) + cameraPos, rotate3d(normalize(uv), camRot, vec3(0)));\n    \n    return Camera(cameraPos, ray);\n}\n\n// https://www.shadertoy.com/view/4d2XWV\n// sphere of size ra centered at point ce\n// returns x = first intersect, y = second intersect\nfloat sphIntersect(in Ray ray, in Sphere sph){\n    vec3 oc = ray.origin - sph.origin;\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius*sph.radius;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0; // no intersection\n    h = sqrt( h );\n    return -b-h;\n}\n\nvec3 sphNormal(in vec3 pos, in Sphere sph){\n    pos -= sph.origin; \n    return normalize(pos);\n}\n\n// https://www.shadertoy.com/view/4sBGDy\n// input: ray origin, ray direction, torus origin, torus width, torus radius\nfloat torIntersect(in Ray ray, in Torus tor){\n    vec3 ro = ray.origin - tor.origin;\n    float po = 1.0;\n    \n    vec3 rd = ray.direction = rotate3d(ray.direction,-tor.rotation,vec3(0));\n    ro = rotate3d(ray.origin,-tor.rotation,tor.pivot);\n    \n    float Ra2 = tor.width*tor.width;\n    float ra2 = tor.radius*tor.radius;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n    float k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\n    \n    if( abs(k3*(k3*k3-k2)+k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    if( h>=0.0 )  \n    {\n        h = sqrt(h);\n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t = 1e20;\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n        return t;\n    }\n    \n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n    float d2 = -(w+c2); if( d2<0.0 ) return -1.0;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n    float t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    if (t == 1e20) t = -1.0;\n    return t;\n}\n\nvec3 torNormal( in vec3 pos, in Torus tor){\n    pos -= tor.origin; \n    pos = rotate3d(pos,-tor.rotation,tor.pivot);\n    vec3 normal = normalize(pos*(dot(pos,pos) - tor.radius*tor.radius - tor.width*tor.width*vec3(1,1,-1)));\n    return rotate3d(normal,tor.rotation,tor.pivot);\n}\n\n//given a radius, distance, and normal, bends the normal to add a circular bevel\nvec3 roundNormal(float r, float d, vec3 normal){\n    if (d < -r) return vec3(0,1,0);\n    float b = d*d + 2.0*d*r;\n    float m = (d+r)/sqrt(abs(b));\n    float l = sqrt(d*d*(m*m + 1.0));\n    vec2 v = sign(d)*vec2(-m*d,d)/l;\n    vec2 a = normalize(normal.xz)*v.x;\n    vec3 x = vec3(-a.y,v.y,-a.x);\n    return x/length(x);\n}\n\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nfloat voronoi3d(vec3 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                n = min(n,distance(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv));\n            }\n        }\n    }\n    return n;\n}\n\nfloat powDist(vec3 a, vec3 b, float p){\n    vec3 d = abs(a-b);\n    return pow(d.x,p) + pow(d.y,p) + pow(d.z,p);\n}\n\nfloat voronoi3dedges(vec3 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                float d = powDist(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv,3.0);\n                if (d < d1) {\n                    d2 = d1;\n                    d1 = d;\n                } else if (d < d2){\n                    d2 = d;\n                }\n            }\n        }\n    }\n    return abs(d1-d2);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[545, 560, 614, 614, 2972]], "test": "untested"}
{"id": "7lyfWz", "name": "Loading Sphere Anim", "author": "spenceryonce", "description": "Loading sphere animation", "tags": ["sphere", "animation", "distance", "loading"], "likes": 1, "viewed": 189, "published": 3, "date": "1664343014", "time_retrieved": "2024-07-30T16:29:18.125507", "image_code": "void mainImage(out vec4 c, in vec2 fc)\n{\n    vec2 uv = (2.0*fc.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    \n    vec4 color1 = vec4(0.4,0.4,0.3,1.0);\n    vec4 color2 = vec4(0.1,0.1,0.1,1.0);\n    \n    color1*=.8-distance(uv,vec2(-.1,-.2));\n    color2*=.6-distance(uv,vec2(.25,.3));\n    vec4 sphere = color1+color2 ;\n    \n    float d = distance(uv, vec2(0.0));\n    float t =1.0- smoothstep(.595,.61, d);\n    sphere*=t+.2*uv.y;\n    \n    \n    \n    c = fract(sphere*1.4+sin(iTime)*0.02*60.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 515]], "test": "untested"}
{"id": "slyBWz", "name": "Graphing Plot Fractal", "author": "spenceryonce", "description": "I decided to created a graphing calculator plot similar to desmos that allow for plotting points equations. This was done all offline without reference as a way to test myself on shader knowledge. I love math. lol", "tags": ["graph", "plot", "graphing", "v2"], "likes": 2, "viewed": 186, "published": 3, "date": "1664338085", "time_retrieved": "2024-07-30T16:29:18.908413", "image_code": "float plot(vec2 uv, float y) {\n    return smoothstep(y-0.02,y,uv.y)-\n    smoothstep(y,y+0.02,uv.y);\n\n}\n\nvec2 grid(vec2 uv, float w, float h){\n    uv.x = fract(uv.x * w);\n    uv.y = fract(uv.y * h);\n    return uv;\n}\n\nfloat vwall(vec2 uv, float w){\n    return uv.x < 1.0 - w ? 0.0 : 1.0;\n}\nfloat hwall(vec2 uv, float h){\n    return uv.y < 1.0 - h ? 0.0 : 1.0;\n}\nfloat xlabel(vec2 uv, float h){\n    return uv.y > -h && uv.y < h ? 1.0 : 0.0;\n}\nfloat ylabel(vec2 uv, float w){\n    return uv.x > -w && uv.x < w ? 1.0 : 0.0;\n}\n\nfloat point(vec2 uv, float r,float x, float y){\n    return smoothstep(-0.01,0.02,(uv.x-(x*0.1))*(uv.x-(x*0.1))*r+(uv.y-(y*0.1))*(uv.y-(y*0.1))*r);\n}\n\nvoid mainImage(out vec4 c, in vec2 fc)\n{\n    vec2 uv = (2.0*fc.xy-iResolution.xy)/iResolution.y;\n    float a = 1.2 + sin(iTime)*0.3;\n    uv *= 1.0+sin(iTime)*0.3;\n    for(float i = 1.0;i<32.0;i+=1.0){\n        uv = abs(uv);\n        uv -= 0.5;\n        uv *= mat2(sin(a),-sin(a),cos(a),sin(a));\n        uv+= 0.5;\n    }\n    \n    vec3 color = vec3(0.0);\n    \n    float y = uv.x*uv.x*uv.x;\n    vec2 g = grid(uv,10.,10.);\n    float p = plot(uv, y);\n    \n    float ci = point(uv, 7.8, 5.0,6.0);\n    float ci2 = point(uv, 7.8, -5.0,6.0);\n    \n    color = vec3(p);\n    \n    float w = vwall(g,0.1);\n    float h = hwall(g,0.1);\n    \n    float xlab = xlabel(uv,0.01);\n    float ylab = ylabel(uv,0.01);\n    color += vec3(w*0.1);\n    color += vec3(h*0.08);\n    color += vec3(xlab*1.0,0.,0.);\n    color += vec3(0.,ylab*1.0,0.0);\n    \n    color += 1.0-ci;\n    color += 1.0-ci2;\n    \n    \n    c = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 102], [104, 104, 141, 141, 214], [216, 216, 246, 246, 287], [288, 288, 318, 318, 359], [360, 360, 391, 391, 439], [440, 440, 471, 471, 519], [521, 521, 568, 568, 669], [671, 671, 711, 711, 1568]], "test": "untested"}
{"id": "7tyBWz", "name": "Improved Graphing Plot v2", "author": "spenceryonce", "description": "I decided to created a graphing calculator plot similar to desmos that allow for plotting points equations. This was done all offline without reference as a way to test myself on shader knowledge. I love math. lol", "tags": ["graph", "plot", "graphing", "v2"], "likes": 0, "viewed": 237, "published": 3, "date": "1664337655", "time_retrieved": "2024-07-30T16:29:19.837928", "image_code": "float plot(vec2 uv, float y) {\n    return smoothstep(y-0.02,y,uv.y)-\n    smoothstep(y,y+0.02,uv.y);\n\n}\n\nvec2 grid(vec2 uv, float w, float h){\n    uv.x = fract(uv.x * w);\n    uv.y = fract(uv.y * h);\n    return uv;\n}\n\nfloat vwall(vec2 uv, float w){\n    return uv.x < 1.0 - w ? 0.0 : 1.0;\n}\nfloat hwall(vec2 uv, float h){\n    return uv.y < 1.0 - h ? 0.0 : 1.0;\n}\nfloat xlabel(vec2 uv, float h){\n    return uv.y > -h && uv.y < h ? 1.0 : 0.0;\n}\nfloat ylabel(vec2 uv, float w){\n    return uv.x > -w && uv.x < w ? 1.0 : 0.0;\n}\n\nfloat point(vec2 uv, float r,float x, float y){\n    return smoothstep(-0.01,0.02,(uv.x-(x*0.1))*(uv.x-(x*0.1))*r+(uv.y-(y*0.1))*(uv.y-(y*0.1))*r);\n}\n\nvoid mainImage(out vec4 c, in vec2 fc)\n{\n    vec2 uv = (2.0*fc.xy-iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    \n    float y = uv.x*uv.x;\n    vec2 g = grid(uv,10.,10.);\n    //don't change grid size as point function \n    //is dependent on it for correct placing\n    //unless you want to make it not dependent, of course :)\n    float p = plot(uv, y);\n    \n    float ci = point(uv, 7.8, 5.0,6.0);\n    float ci2 = point(uv, 7.8, -5.0,6.0);\n    \n    color = vec3(p);\n    \n    float w = vwall(g,0.1);\n    float h = hwall(g,0.1);\n    \n    float xlab = xlabel(uv,0.01);\n    float ylab = ylabel(uv,0.01);\n    color += vec3(w*0.1);\n    color += vec3(h*0.08);\n    color += vec3(xlab*1.0,0.,0.);\n    color += vec3(0.,ylab*1.0,0.0);\n    \n    color += 1.0-ci;\n    color += 1.0-ci2;\n    \n    \n    c = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 102], [104, 104, 141, 141, 214], [216, 216, 246, 246, 287], [288, 288, 318, 318, 359], [360, 360, 391, 391, 439], [440, 440, 471, 471, 519], [521, 521, 568, 568, 669], [671, 671, 711, 711, 1498]], "test": "untested"}
{"id": "7lyfWR", "name": "The harmonics of a Guitar", "author": "AlexApps99", "description": "Basically the audio of a guitar from a bunch of weird nerd symbols I found on the internet", "tags": ["harmonics", "guitar"], "likes": 8, "viewed": 409, "published": 3, "date": "1664321382", "time_retrieved": "2024-07-30T16:29:20.742510", "image_code": "// Go to the \"sound\" tab for the code and tunable parameters\n\n// Text from https://www.shadertoy.com/view/MtyXRW\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.) )\nfloat message(vec2 U) {\n    vec4 T = vec4(0);\n    C(83);C(111);C(117);C(110);C(100);C(32);C(105);C(110); // message \"Sound in\"\n    return length(T.yz)==0. ? -1. : T.x;\n}\n\n\nfloat sdbEllipsoidV2(in vec2 p, in vec2 r) {\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return k1*(k1-1.0)/k2;\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}\n\n    vec2 uv = 3. * (fragCoord / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    float body = min(sdbEllipsoidV2(uv-vec2(-.5,0.),vec2(1.2)), sdbEllipsoidV2(uv-vec2(.75,0.), vec2(1.0)));\n    body = max(body, -sdbEllipsoidV2(uv-vec2(.5,0.), vec2(0.25)));\n    body = min(body, sdBox(uv-vec2(3.,0.), vec2(2., .2)));\n    vec3 col = mix(vec3(.5, .3, 0.), vec3(0.), smoothstep(0., fwidth(body), body));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// based on a bunch of math I found on the internet, put into code\n// http://large.stanford.edu/courses/2007/ph210/pelc2/\n\n// maximum number of harmonics to compute\n// fiddle with this number to see what it's like with less harmonics\nconst uint MAX_HARMONICS = 50u;\n\n// fundamental frequencies of each string\n// changing these will \"tune\" the guitar\nconst float FUNDAMENTAL[6] = float[6](\n    329.63, // E4\n    246.94, // B3\n    196.00, // G3\n    146.83, // D3\n    110.00, // A2\n    082.41  // E2\n);\n\n// length of string (approx 25 inches, standard guitar string length)\nconst float L = 0.635;\n// height of pluck (12.5 cm, just a random number to make it clearly audible)\nconst float h = 0.125;\n// position of pluck along string (5 inches from lower bridge)\nconst float d = 0.15;\n\n// Damping coefficient (bigger = shorter)\nconst float GAMMA = 2.5;\n\n// String stiffness coefficient\nconst float b = 0.008;\n\n// The stuff below is code that isn't really worth fiddling with\n// =============================================================\n\nconst float TAU = 6.283185307179586476925286766559;\nconst float PI = TAU / 2.0;\n\nvec2 mainSound(int samp, float time) {\n    float sig = 0.0;\n    // for each string\n    for (uint s = 0u; s < 6u; s++) {\n        // repeat at a different offset\n        // I fixed some floating point errors by using the sample number directly and using integers\n        //float t = mod(time + (float(s) / 6.), 8./6.);\n        float t = float((6 * samp + int(iSampleRate) * int(s)) % (8 * int(iSampleRate))) / (6. * iSampleRate);\n        // for each harmonic\n        for (uint n = 0u; n < MAX_HARMONICS; n++) {\n            // amplitude for each harmonic\n            float a_n = ((2. * h * L * L)/(PI * PI * d * (L - d) * float(n+1u) * float(n+1u))) * sin((float(n+1u) * PI * d)/L);\n            // frequency for each harmonic\n            float f_n = float(n+1u) * FUNDAMENTAL[s] * sqrt(1. + b * b * float(n+1u) * float(n+1u));\n            // add value to total sound signal, with exponential falloff\n            sig += a_n * sin(TAU * f_n * t) * exp(-float(n+1u) * GAMMA * t);\n        }\n    }\n\n    return vec2(sig);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 263, 263, 409], [412, 412, 456, 456, 545], [547, 547, 582, 582, 662], [664, 664, 719, 719, 1266]], "test": "untested"}
{"id": "slVBzm", "name": "storing voxels", "author": "FabriceNeyret2", "description": "implement 128³ voxel storage.  SPACE toggles animated/still volume.\n setVoxel( P in [0,1]³ )  in CubeA\n getVoxel( P in [0,1]³ )  in Image.\ntrilinearly interpolated, but MIPmap is not implemented.\n\nNote that we could store more, e.g. 192x192x150 RGBA\n", "tags": ["volume", "voxels", "cubemapa"], "likes": 30, "viewed": 593, "published": 3, "date": "1664298325", "time_retrieved": "2024-07-30T16:29:21.726878", "image_code": "// using \"one more cubemap access\" https://shadertoy.com/view/3tGBDz\n\nvec4 getVoxel(vec3 q) {  // ----------- should really be in Common, but iChannel0 forbiden there... :-( \n    if ( q.x<0. || q.y < 0. || q.z < 0. || q.x > 1. || q.y > 1. || q.z > 1. ) return vec4(0);\n    float t = 64.* fract(2.*q.z); \n    int   n = q.z<.5 ? 0 : 1,\n          i = int(t);\n    vec4 O =       T( ( q.xy + vec2( i%8, i/8 ) )/8., n ); // return O; // uncomment to cancel z-interpolation\n    i++; if (i>63) n++, i -= 64; // if (n>1) return O;     // attention: borders interpolate to other faces\n    return mix( O, T( ( q.xy + vec2( i%8, i/8 ) )/8., n ), fract(t) ); // +.05;\n }\n\n\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))                      // rotation \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,T, s=1.57;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -40.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q,r,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n //   p += .5/128.* texelFetch(iChannel1,ivec2(U)%1024,0).x * D; // jitter against pseudo-shading banding\n    \n    O = vec4(0);\n    p += 19.*D;\n    float dx = 1.;\n    for ( float i=0.; i<200.; i+=dx )                      // march scene\n        q = p + i/128. * D,\n        q.yz *= rot(-M.y),                                 // rotations\n        q.xz *= rot(-M.x-1.57),  q+=.5,\n        O += (1.-O.a)* dx* .6* getVoxel(q);\n\n    O += (1.-O.a) * vec4(.2,.3,.4,1);\n // O = sqrt(O);                                           // to sRGB\n \n // U /= R.y, O = T(U,0), U = floor(8.*U), O.x += mod(U.x+U.y,2.) ; if (U.x >7.) O-=O; // debug\n}\n\n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "// Note that MIPmap works in direction xy, but not z. ( to be implemented ).\n// Only 2 faces are used over 6: Other volumes could be used to store velocity or shadowing data.\n// For efficiency we rely on hardware texture interpolation, but you could implement degree 3 to improve quality.\n\n#define keyToggle(a)  ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n\n#define H(p) fract( sin((p+17.1)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*3e4 )\n\nfloat _z = .3;\nvec3 hash( vec3 x ) \n{\n // float s = 0.;                          // standard Perlin noise\n    float s = mod(x.x+x.y+x.z,2.)*2.-1.;   // flow noise checkered rotation direction\n // float s = mod(floor(x.x)+floor(x.y),2.)*2.-1.;   // should be this but x is integer\n // float s = 1.;                         // flow noise universal rotation direction\n // s *= iTime;                           // same rotation speed at all scales\n    s *= iTime/ _z;                       // rotation speed increase with small scale    \n\n    x = 2.*H(x) - 1.;\n    x.xy *= mat2(cos( s + vec4(0,33,11,0))); // rotating gradients. rot: https://www.shadertoy.com/view/XlsyWX\n    return x;\n}\n\nfloat noise( vec3 p )\n{\n    vec3 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n\n#define P(x,y,z) dot( hash( i + vec3(x,y,z) ) , f - vec3(x,y,z) )\n    return mix( mix( mix( P(0,0,0), P(1,0,0), u.x),\n                     mix( P(0,1,0), P(1,1,0), u.x), u.y),\n                mix( mix( P(0,0,1), P(1,0,1), u.x),\n                     mix( P(0,1,1), P(1,1,1), u.x), u.y) , u.z );\n}\n\nfloat perlin( vec3 p )  //fractal noise\n{\t\n    mat3 m =  mat3(2); // mat2( 1.6,  1.2, -1.2,  1.6 );\n           // mat3( 1.6,  1.2, 1.4,    1.3, -1.2,  1.6, -1.4, -1.6, 1.2 ) / 2.;\n    float v  = 0.,s = 1.;\n    for( int i=0; i < 5; i++, s /= 2. ) {  _z = s; // for flownoise\n        v += s*noise( p ); p *= m; p-=.5;\n    }\n    return v/2.;\n}\n\nvec4 getVoxel(vec3 q) {  // ----------- should really be in Common, but iChannel0 forbiden there... :-( \n// ( used only for shadowing )\n    if ( q.x<0. || q.y < 0. || q.z < 0. || q.x > 1. || q.y > 1. || q.z > 1. ) return vec4(0);\n    float t = 64.* fract(2.*q.z); \n    int   n = q.z<.5 ? 0 : 1,\n          i = int(t);\n    vec4 O =       T( ( q.xy + vec2( i%8, i/8 ) )/8., n ); return O;\n    i++; if (i>63) n++, i -= 64; // if (n>1) return O;\n    return mix( O, T( ( q.xy + vec2( i%8, i/8 ) )/8., n ), fract(t) ); // +.05;\n }\n\n\nvec4 setVoxel( vec3 P ) {  // ---------- set your volume definition here. \n\n // P = floor(P*128.); return vec4(P.z==float(iFrame%128));    // debug\n\n    P = 2.*P-1.;                                               // centering\n    vec4 O;\n // O = vec4( length( P ) < .8 );\n // O = vec4( smoothstep( 4.* 2./128., 0., abs( length(P) -.8 ) ) );\n // O = vec4(max(0., noise( 8.*P + 171.) ));\n // O = vec4(max(0., perlin( 4.*P + 171.) ));\n // O = vec4( .3* smoothstep( .1, 0., abs( length( P+ perlin(4.*P) ) -.8) ) );\n    float v = .1 * smoothstep( .1, 0., abs( length( P+ perlin(4.*P) ) -.8) ); O = v* vec4(exp(-v/vec3(8,.25,.12)),1);\n // O = vec4( smoothstep( .3, 0., abs( length(P) -.75 ) ) * max(0., perlin(4.*P) ) );\n // float v = smoothstep( .3, 0., abs( length(P) -.75 ) ) * max(0., perlin(4.*P) ); O = v* vec4(exp(v*vec3(1,.1,.01)),1);\n // float v = smoothstep( .3, 0., abs( length(P) -.75 ) ) * .4*smoothstep(.05,.2, perlin(4.*P) ); O = v* vec4(exp(v*vec3(1,.1,.01)),1);\n \n    // ---------------------------------- computing shadows -------------------\n    // ( maybe would be cleaner to stores light in a separate volume.\n    //   e.g. it would allows to have still density with animated shadowing ).\n    float t = 1.; P = .5+.5*P;\n    for (float z = P.z; z < 1.; z += 1./128. )\n        t *= 1.- getVoxel( vec3(P.xy,z) ).a;\n    O.rgb *= .1 + 2.*exp(-3.*t);\n    return O;\n}\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    vec3 A = abs(D);\n    int n = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2; // faceID\n    if (D[n]<0.) n += 3;\n    \n    if ( n > 1 ) { O*=0.; return; }                            // we use only 2 faces.\n    if ( keyToggle(32) && iFrame>0 ) { O = texture(iChannel0,D); return; }        // uncomment if data not evolving.\n\n    U = ( 8.*floor(U) + .5 ) / 1024.;\n    vec2 I = floor(U);                                         // tile ID = (I,n)\n    vec3 P = vec3( fract(U), ( I.x +8.*I.y + 64.*float(n) +.5 ) /128. ); // 3D pos in normalized volume [0,1]³ of resolution 128³\n    O = setVoxel(P);\n}\n\n", "cube_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nvec3 E;\n#define T(U,n) ( E = vec3( 2.*fract(U) -1., 1 )                                 \\\n                   * vec3( n==0||n==5 ?-1:1 , n!=1 ?-1:1 , n>2 ?-1:1 ),         \\\n                 E = (n)%3 != 2 ? E.yzx : E.xzy,                                \\\n                 texture( iChannel0, vec3( E[(n+1)%3], E[(n)%3], E[(n+2)%3] ) ) \\\n               )\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 93, 174, 657], [744, 744, 780, 780, 1741]], "test": "untested"}
{"id": "7tKBRm", "name": "Sinusoidal dish and smoothies", "author": "Visiware", "description": "You can see here sinusoidal circle and a few shapes unioned smoothly.", "tags": ["raymarching", "sinusoidal", "smoothunion"], "likes": 4, "viewed": 230, "published": 3, "date": "1664282045", "time_retrieved": "2024-07-30T16:29:22.535715", "image_code": "// License: MIT\n// This shader was ported to shadertoy from my GLSL experiments on PC for a video: https://www.youtube.com/watch?v=PBI_yvz25aI\n// There is many roughs\n\n#define PI 3.1415926535897932384626433832795\n#define PI2 (PI*2.)\n\n#define CirclePart(angle) (angle*PI2)\n\n#define FOV 1.309\n\nfloat intersectSDF(float distA,float distB) {\n\treturn max(distA,distB);\n}\n\nfloat unionSDF(float distA,float distB) {\n\treturn min(distA,distB);\n}\n\nfloat differenceSDF(float distA,float distB) {\n\treturn max(distA,-distB);\n}\n\nfloat smoothIntersectSDF(float distA, float distB, float k) {\n\tfloat h = clamp(0.5 - 0.5*(distA - distB)/k,0.0,1.0);\n\treturn mix(distA,distB,h) + k*h*(1.0 - h); \n}\n\nfloat smoothUnionSDF(float distA,float distB,float k) {\n\tfloat h = clamp(0.5 + 0.5*(distA - distB)/k,0.0,1.0);\n \treturn mix(distA,distB,h) - k*h*(1.0 - h); \n}\n\nfloat smoothDifferenceSDF(float distA, float distB, float k) {\n\tfloat h = clamp(0.5 - 0.5*(distB + distA)/k,0.0,1.0);\n\treturn mix(distA,-distB,h) + k*h*(1.0 - h); \n}\n\n\n\nmat4 TransMatrix(float x,float y,float z) {\n\tmat4 m = mat4(1);\n\t\n\tm[3][0] = x;\n\tm[3][1] = y;\n\tm[3][2] = z;\n\t\n\treturn m;\n}\n\nmat4 RotMatrixY(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][2] = -sin(angle);\n\tm[2][0] = sin(angle);\n\tm[2][2] = cos(angle);\n\t\n\treturn m;\n}\n\nmat4 RotMatrixX(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][1] = sin(angle);\n\tm[1][0] = -sin(angle);\n\tm[1][1] = cos(angle);\n\t\n\treturn m;\n}\n\n\n\nstruct MarchRet_t {\n\tfloat d;\n\tint i;\n};\n\n\nstruct CastRet_t {\n\tvec3 intersect;\n\tvec3 normal;\n\tbool casted;\n\t\n\tMarchRet_t march;\n};\n\n#define SMALLADD 0.004\n\n#define DISTMAX 3000.0\n\n\n\n\n\nMarchRet_t marchSmoothUnionSDF(MarchRet_t a,MarchRet_t b,float k) {\n\tint i = 0;\n\tif (a.d < b.d) {\n\t\ti = a.i;\n\t}\n\telse {\n\t\ti = b.i;\n\t}\n\t\n\treturn MarchRet_t(smoothUnionSDF(a.d,b.d,k),i);\n}\n\n\nMarchRet_t marchIntersectSDF(MarchRet_t a,MarchRet_t b) {\n\treturn MarchRet_t(max(a.d,b.d),a.i);\n}\n\nMarchRet_t marchUnionSDF(MarchRet_t a,MarchRet_t b) {\n\tif (a.d < b.d) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn b;\n\t}\n}\n\nMarchRet_t marchDifferenceSDF(MarchRet_t a,MarchRet_t b) {\n\tint i = 0;\n\tif (a.d > 0.) {\n\t\ti = a.i;\n\t}\n\telse {\n\t\ti = b.i;\n\t}\n\t\n\treturn MarchRet_t(max(a.d,-b.d),i);\n}\n\n\n\n\nMarchRet_t RoomSDF(vec3 o) {\n\tfloat cube0 = max(max(abs(o.x) - 5.,abs(o.z) - 8.),abs(o.y) - 5.);\n\to.x -= 8.9;\n\t\n\tfloat cube1 = max(max(abs(o.x) - 4.,abs(o.z) - 4.),abs(o.y) - 2.);\n\t\n\tfloat d = smoothUnionSDF(cube0,cube1,(sin(CirclePart(float(iFrame%80)/80.0)) + 1.0)/8.0 + 0.25);\n\t\n\treturn MarchRet_t(-d,0);\n}\n\n\n\nvec3 obj0_pos() {\n    return vec3(8,1.0 + cos(iTime*2.3)*1.2,1.0 + sin(iTime*3.0)*2.0);\n}\nvec3 obj1_pos() {\n    return vec3(8,-1.0 + cos(iTime*4.3)*1.5,2.0 + sin(iTime*2.1)*2.0);\n}\nvec3 obj2_pos() {\n    return vec3(8,-1.2 + cos(iTime*7.3)*1.1,-3.0 + sin(iTime*1.3)*1.5);\n}\nvec3 obj3_pos() {\n    return vec3(8,0.3 + cos(iTime*1.5)*0.7,-2.5 + sin(iTime*2.2)*2.2);\n}\nvec3 obj4_pos() {\n    return vec3(8,0.0 + cos(iTime*2.1)*1.1,1.2 + sin(iTime*1.3)*3.0);\n}\n\nMarchRet_t shapesSDF(vec3 o) {\n\tfloat t = CirclePart(float(iFrame%200)/200.0);\n\t\n\tfloat sphere0 = length(o - obj0_pos()) - 0.7;\n\t\n\tfloat sphere1 = length(o - obj1_pos()) - 0.5;\n\t\n\tfloat sphere2 = length(o - obj2_pos()) - 0.25;\n\t\n\tvec3 cbo = o - obj3_pos();\n\tfloat sphere3 = max(max(abs(cbo.x) - 0.7,abs(cbo.z) - 0.7),abs(cbo.y) - 0.5);\n\t\n\tfloat sphere4 = length(o - obj4_pos()) - 0.8;\n\t\n\tfloat d = smoothUnionSDF(sphere0,sphere1,1.5);\n\td = smoothUnionSDF(d,sphere2,1.5);\n\td = smoothUnionSDF(d,sphere3,1.5);\n\td = smoothUnionSDF(d,sphere4,1.5);\n\t\n\treturn MarchRet_t(d,1);\n}\n\n\nMarchRet_t effectSDF(vec3 o) {\n\tfloat tangle = CirclePart(float(iFrame%30)/30.0);\n\t\n\tfloat powbase = cos(CirclePart(float(iFrame%70)/70.0))/2.0 + 2.8;\n\t\n\tfloat d = intersectSDF(length(o.yz) - 1.2,abs(o.x) - ((cos(length(o.yz*(pow(powbase,length(o.yz) + 1.5))) - tangle) + 1.2)*0.05));\n\t\n\treturn MarchRet_t(d,2);\n}\n\n\nMarchRet_t SceneSDF(vec3 ori,vec3 dir) {\n\tMarchRet_t ret;\n\tret.i = 0;\n\t\n\tret = RoomSDF(ori);\n\t\n\tret = marchUnionSDF(ret,shapesSDF(ori));\n\t\n\tret = marchUnionSDF(ret,effectSDF(ori));\n\t\n\treturn ret;\n}\n\n#define NORM_EPSILON 0.0001\n\nvec3 SceneNormal(vec3 ori) {\n\treturn normalize(vec3(SceneSDF(vec3(ori.x + NORM_EPSILON,ori.y,ori.z),vec3(0,1,0)).d - SceneSDF(vec3(ori.x - NORM_EPSILON,ori.y,ori.z),vec3(0,1,0)).d,\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y + NORM_EPSILON,ori.z),vec3(0,1,0)).d - SceneSDF(vec3(ori.x,ori.y - NORM_EPSILON,ori.z),vec3(0,1,0)).d,\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y,ori.z + NORM_EPSILON),vec3(0,1,0)).d - SceneSDF(vec3(ori.x,ori.y,ori.z - NORM_EPSILON),vec3(0,1,0)).d));\n}\n\n\n\n#define ITERMAX 300\n\n#define EPSILON 0.008\n\nCastRet_t TraceObjects(vec3 pos,vec3 dir,float outmax) {\n\tCastRet_t maincast;\n\t\n\tmaincast.intersect = pos;\n\tmaincast.normal = vec3(0.0,0.0,0.0);\n\tmaincast.casted = false;\n\t\n\t\n\t\n\t\n\t\n\tvec3 ori = pos;\n\tfloat l = 0.;\n\t\n\tfor (int i = 0; i < ITERMAX; i++) {\n\t\tMarchRet_t march = SceneSDF(ori,dir);\n\t\t\n\t\tfloat d = march.d/1.5;\n\t\t\n\t\t\n\t\tif (l > outmax) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tl += d;\n\t\t\n\t\t\n\t\tif (d < EPSILON) {\n\t\t\tvec3 epspos = ori - dir*EPSILON;\n\t\t\t\n\t\t\tmaincast.casted = true;\n\t\t\tmaincast.intersect = epspos;\n\t\t\tmaincast.normal = SceneNormal(epspos);\n\t\t\t\n\t\t\tmaincast.march = march;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (d > DISTMAX) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tori += dir*d;\n\t}\n\t\n\treturn maincast;\n}\n\nvec3 ColorByMaterial(int index) {\n\tif (index == 0) {\n        return vec3(1.0,1.0,0.95);\n    }\n    else if (index == 1) {\n        return vec3(1.0,0.9,0.0);\n    }\n    else if (index == 2) {\n        return vec3(0.1,0.8,0.95);\n    }\n    else if (index == 3) {\n        return vec3(0.0,0.7,0.8);\n    }\n    return vec3(0);\n}\n\n\n\nbool mat_traceshadow(int index) {\n    return index == 1;\n}\n\nfloat mat_specular(int index) {\n    if (index == 0) {\n        return 900.0;\n    }\n    else if (index == 1) {\n        return 30.0;\n    }\n    else if (index == 2) {\n        return 80.0;\n    }\n    else if (index == 3) {\n        return 75.0;\n    }\n    return 0.0;\n}\n\n\n\n#define MINCOLOR 0.04\n\nvec3 RaytraceObjects(vec3 pos,vec3 dir,vec3 camera_pos) {\n\tvec3 color = vec3(0.0,0.0,0.0);\n\t\n\tCastRet_t maincast = TraceObjects(pos,dir,DISTMAX);\n\t\n\tif (maincast.casted) {\n\t\tcolor = ColorByMaterial(maincast.march.i);\n\t\t\n\t\tvec3 lightpos = vec3(-2.7,0,-2.0);\n\t\tvec3 lightvecfull = lightpos - maincast.intersect;\n\t\tvec3 lightvec = normalize(lightvecfull);\n\t\t\n\t\tfloat cval = dot(maincast.normal,lightvec);\n\t\t\n\t\tbool shadowcasted = false;\n\t\t\n\t\tif (mat_traceshadow(maincast.march.i)) {\n\t\t\tvec3 shadow_pos = maincast.intersect + lightvec*SMALLADD;\n\t\t\t\n\t\t\t\n\t\t\tCastRet_t shadowcast = TraceObjects(shadow_pos,lightvec,length(lightvecfull));\n\t\t\tshadowcasted = shadowcast.casted;\n\t\t\t\n\t\t\t\n\t\t\tfloat spec = mat_specular(maincast.march.i);\n\t\t\t\n\t\t\tvec3 refl = normalize(maincast.normal*2.*dot(maincast.normal,lightvec) - lightvec);\n\t\t\t\n\t\t\tvec3 tocam = normalize(camera_pos - maincast.intersect);\n\t\t\t\n\t\t\tfloat cosangle = clamp(dot(tocam,refl),0.,1.);\n\t\t\tcval += pow(cosangle,spec);\n\t\t}\n\t\t\n\t\tif (cval < 0.0) {\n\t\t\tcolor = color*MINCOLOR;\n\t\t}\n\t\telse {\n\t\t\tif (shadowcasted) {\n\t\t\t\tcolor = color*MINCOLOR;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = color*max(MINCOLOR,cval);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn color;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float x = fragCoord.x;\n\tfloat y = fragCoord.y;\n    \n    mat4 camera = RotMatrixY(-PI/2. + iMouse.x/iResolution.x - 0.3)*TransMatrix(-3.0 + iMouse.y/iResolution.y*3.0,0.0,4.0);\n    \n    mat4 camera_notrans = camera;\n    camera_notrans[3][0] = 0.0;\n    camera_notrans[3][1] = 0.0;\n    camera_notrans[3][2] = 0.0;\n    \n\tvec3 pos = (camera*vec4(0.0,0.0,0.0,1.0)).xyz;\n\tvec3 dir = (camera_notrans*normalize(vec4((x - iResolution.x/2.0)/iResolution.x*tan(FOV/2.0)*iResolution.x/iResolution.y,(y - iResolution.y/2.0)/iResolution.y*tan(FOV/2.0),-1.0,1.0))).xyz;\n\t\n\tfragColor = vec4(RaytraceObjects(pos,dir,vec3(camera[3][0],camera[3][1],camera[3][2])),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKBRm.jpg", "access": "api", "license": "mit", "functions": [[292, 292, 337, 337, 365], [367, 367, 408, 408, 436], [438, 438, 484, 484, 513], [515, 515, 576, 576, 678], [680, 680, 735, 735, 838], [840, 840, 902, 902, 1005], [1009, 1009, 1052, 1052, 1130], [1132, 1132, 1162, 1162, 1291], [1293, 1293, 1323, 1323, 1452], [1640, 1640, 1707, 1707, 1826], [1829, 1829, 1886, 1886, 1926], [1928, 1928, 1981, 1981, 2039], [2041, 2041, 2099, 2099, 2205], [2210, 2210, 2238, 2238, 2519], [2523, 2523, 2540, 2540, 2612], [2613, 2613, 2630, 2630, 2703], [2704, 2704, 2721, 2721, 2795], [2796, 2796, 2813, 2813, 2886], [2887, 2887, 2904, 2904, 2976], [2978, 2978, 3008, 3008, 3549], [3552, 3552, 3582, 3582, 3865], [3868, 3868, 3908, 3908, 4065], [4096, 4096, 4124, 4124, 4554], [4602, 4602, 4658, 4658, 5273], [5275, 5275, 5308, 5308, 5592], [5596, 5596, 5629, 5629, 5654], [5656, 5656, 5687, 5687, 5917], [5944, 5944, 6001, 6001, 7109], [7115, 7115, 7171, 7171, 7827]], "test": "untested"}
{"id": "ftVfRm", "name": "Cubes and spheres-bipyramids", "author": "Visiware", "description": "This shader is about cubes and spheres", "tags": ["raymarching", "cubes"], "likes": 1, "viewed": 213, "published": 3, "date": "1664267050", "time_retrieved": "2024-07-30T16:29:23.342558", "image_code": "// License: MIT\n// This shader is ported here for a video: https://www.youtube.com/watch?v=PBI_yvz25aI\n// At first this shader was written and runned on my local machine, so there may be rough\n\n#define PI 3.1415926535897932384626433832795\n#define PI2 (PI*2)\n\n#define CirclePart(angle) (angle*PI2)\n\n#define FOV 1.309\n\nfloat intersectSDF(float distA,float distB) {\n\treturn max(distA,distB);\n}\n\nfloat unionSDF(float distA,float distB) {\n\treturn min(distA,distB);\n}\n\nfloat differenceSDF(float distA,float distB) {\n\treturn max(distA,-distB);\n}\n\n\n\nmat4 TransMatrix(float x,float y,float z) {\n\tmat4 m = mat4(1);\n\t\n\tm[3][0] = x;\n\tm[3][1] = y;\n\tm[3][2] = z;\n\t\n\treturn m;\n}\n\nmat4 RotMatrixY(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][2] = -sin(angle);\n\tm[2][0] = sin(angle);\n\tm[2][2] = cos(angle);\n\t\n\treturn m;\n}\n\nmat4 RotMatrixX(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][1] = sin(angle);\n\tm[1][0] = -sin(angle);\n\tm[1][1] = cos(angle);\n\t\n\treturn m;\n}\n\n\n\n\nfloat GeoSphereSDF(vec3 o,float r) {\n\tvec3 onorm = normalize(o);\n\t\n\tfloat value = -max(abs(onorm.x),abs(onorm.z));\n\tif (value < -0.25) {\n\t\tvalue = -0.25;\n\t}\n\t\n\treturn length(o) - (r + 1.2*value);\n}\n\nfloat CubeSDF(vec3 o,float size) {\n\tvec3 d = abs(o) - vec3(size/2.,size/2.,size/2.);\n\t\n\tfloat distin = min(max(d.x, max(d.y, d.z)), 0.0);\n\tfloat distout = length(max(d, 0.0));\n\t\n\treturn distin + distout;\n}\n\n\n\nfloat MultiSphereCubeSDF(vec3 o,float r,float size,float l) {\n\tfloat ly = l*2.;\n\t\n\tfloat mx = mod(o.x,l);\n\tfloat my = mod(o.y,ly);\n\tfloat mz = mod(o.z,l);\n\t\n\tbool xodd = (mod(o.x,l*2.0) > 0. && mod(o.x,l*2.0) < l);\n\tbool zodd = (mod(o.z,l*2.0) > 0. && mod(o.z,l*2.0) > l);\n\t\n\to.x = mx - l/2.;\n\to.y = my - ly/2.;\n\to.z = mz - l/2.;\n\t\n\tbool which = (xodd && !zodd) || (!xodd && zodd);\n\t\n\treturn GeoSphereSDF(o,r)*float(which) + CubeSDF(o,size)*float(!which);\n}\n\n\n\nfloat SceneSDF(vec3 ori) {\n\tfloat d = MultiSphereCubeSDF(ori,0.8,1.5,5.0);\n\treturn d;\n}\n\n#define NORM_EPSILON 0.0001\n\nvec3 SceneNormal(vec3 ori) {\n\treturn normalize(vec3(SceneSDF(vec3(ori.x + NORM_EPSILON,ori.y,ori.z)) - SceneSDF(vec3(ori.x - NORM_EPSILON,ori.y,ori.z)),\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y + NORM_EPSILON,ori.z)) - SceneSDF(vec3(ori.x,ori.y - NORM_EPSILON,ori.z)),\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y,ori.z + NORM_EPSILON)) - SceneSDF(vec3(ori.x,ori.y,ori.z - NORM_EPSILON))));\n}\n\n\n\n\n#define ITERMAX 500\n\n#define DISTMAX 1500.0\n\n#define EPSILON 0.005\n\nstruct CastRet_t {\n    bool casted;\n    vec3 normal;\n};\n\nCastRet_t TraceObjects(vec3 pos,vec3 dir,float outmax) {\n\tCastRet_t maincast;\n\t\n\tmaincast.normal = vec3(0.0,0.0,0.0);\n\tmaincast.casted = false;\n\t\n\tvec3 ori = pos;\n\tfloat l = 0.;\n\t\n\tfor (int i = 0; i < ITERMAX; i++) {\n\t\tfloat d = SceneSDF(ori);\n\t\t\n\t\t\n\t\tif (l > outmax) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tl += d;\n\t\t\n\t\t\n\t\tif (d < EPSILON) {\n\t\t\tvec3 epspos = ori - dir*EPSILON;\n\t\t\t\n\t\t\tmaincast.casted = true;\n\t\t\tmaincast.normal = SceneNormal(epspos);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (d > DISTMAX) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tori += dir*d;\n\t}\n\t\n\treturn maincast;\n}\n\n\n\n#define MINCOLOR 0.04\n\nvec3 RaytraceObjects(vec3 pos,vec3 dir) {\n\tvec3 color = vec3(0.0,0.0,0.0);\n\t\n\tCastRet_t maincast = TraceObjects(pos,dir,DISTMAX);\n\t\n\tif (maincast.casted) {\n\t\tcolor = (maincast.normal + vec3(1.0,1.0,1.0))/2.0;\n\t}\n\t\n\t\n\treturn color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float x = fragCoord.x;\n\tfloat y = fragCoord.y;\n    \n    mat4 camera = RotMatrixX(PI/2. + iMouse.x/iResolution.x)*TransMatrix(0.0,0.0,0.0 - iTime*10.0);\n    \n    mat4 camera_notrans = camera;\n    camera_notrans[3][0] = 0.0;\n    camera_notrans[3][1] = 0.0;\n    camera_notrans[3][2] = 0.0;\n    \n\tvec3 pos = (camera*vec4(0.0,0.0,0.0,1.0)).xyz;\n\tvec3 dir = (camera_notrans*normalize(vec4((x - iResolution.x/2.0)/iResolution.x*tan(FOV/2.0)*iResolution.x/iResolution.y,(y - iResolution.y/2.0)/iResolution.y*tan(FOV/2.0),-1.0,1.0))).xyz;\n\t\n\tfragColor = vec4(RaytraceObjects(pos,dir),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVfRm.jpg", "access": "api", "license": "mit", "functions": [[317, 317, 362, 362, 390], [392, 392, 433, 433, 461], [463, 463, 509, 509, 538], [542, 542, 585, 585, 663], [665, 665, 695, 695, 824], [826, 826, 856, 856, 985], [990, 990, 1026, 1026, 1187], [1189, 1189, 1223, 1223, 1394], [1398, 1398, 1459, 1459, 1855], [1859, 1859, 1885, 1885, 1946], [1977, 1977, 2005, 2005, 2351], [2481, 2481, 2537, 2537, 3013], [3040, 3040, 3081, 3081, 3272], [3277, 3277, 3333, 3333, 3920]], "test": "untested"}
{"id": "flKBzw", "name": "Boolean shapes, hazed", "author": "Visiware", "description": "This is a shader of cubes/spheres, all in boolean.", "tags": ["cubes", "boolean"], "likes": 0, "viewed": 202, "published": 3, "date": "1664260693", "time_retrieved": "2024-07-30T16:29:24.182313", "image_code": "// License: MIT\n// This shader is ported here for a video: https://www.youtube.com/watch?v=PBI_yvz25aI\n// At first it was written at my local PC as GLSL another version, there may be roughness\n\n#define M_PI 3.1415926535897932384626433832795\n#define M_PI2 (M_PI*2.0)\n\n#define FOV 1.309\n\n#define SMALLADD 0.004\n\nfloat intersectSDF(float distA,float distB) {\n\treturn max(distA,distB);\n}\n\nfloat unionSDF(float distA,float distB) {\n\treturn min(distA,distB);\n}\n\nfloat differenceSDF(float distA,float distB) {\n\treturn max(distA,-distB);\n}\n\n\n\nmat4 TransMatrix(float x,float y,float z) {\n\tmat4 m = mat4(1);\n\t\n\tm[3][0] = x;\n\tm[3][1] = y;\n\tm[3][2] = z;\n\t\n\treturn m;\n}\n\nmat4 RotMatrixY(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][2] = -sin(angle);\n\tm[2][0] = sin(angle);\n\tm[2][2] = cos(angle);\n\t\n\treturn m;\n}\n\n\n\nfloat SphereSDF(vec3 o,vec3 pos,float r) {\n\treturn length(o - pos) - r*r;\n}\n\nfloat CubeSDF(vec3 o,vec3 pos,float size) {\n\tvec3 d = abs(o - pos) - vec3(size,size,size);\n\t\n\tfloat distin = min(max(d.x, max(d.y, d.z)), 0.0);\n\tfloat distout = length(max(d, 0.0));\n\t\n\treturn distin + distout;\n}\n\n\n\nfloat OneObjSDF(vec3 ori,vec3 pos) {\n\treturn differenceSDF(unionSDF(CubeSDF(ori,pos + vec3(0,0,0),1.0),SphereSDF(ori,pos + vec3(0,0,0),1.15)),SphereSDF(ori,pos + vec3(-0.8 - 0.4*sin(float(iFrame%45)/45.0*M_PI2),1.0*sin(float(iFrame%300)/300.0*M_PI2),1.0*sin(float(iFrame%500)/500.0*M_PI2)),0.8));\n}\n\n\nfloat SceneSDF(vec3 ori) {\n\tfloat angle = float(iFrame%100)/100.0*M_PI2;\n\t\n\treturn unionSDF(unionSDF(unionSDF(unionSDF(OneObjSDF(ori,vec3(2.0*cos(angle),2.0*cos(angle + 0.65) + cos(float(iFrame%20)/20.0*M_PI2),30.0*cos(angle + 1.23))),\n\t                                           OneObjSDF(ori,vec3(-5.0*cos(angle + 0.3),23.0*cos(angle + 0.3),23.0*cos(angle + 1.3)))),\n\t                                           OneObjSDF(ori,vec3(-12.3*cos(angle + 1.6),-4.0*cos(angle + 1.12),12.0*cos(angle + 0.54)))),\n\t                                           OneObjSDF(ori,vec3(0,0,0))),\n\t                                           OneObjSDF(ori,vec3(30.0*cos(angle),30.0*sin(angle),30.0*tan(angle))));\n}\n\n#define NORM_EPSILON 0.0001\n\nvec3 SceneNormal(vec3 ori) {\n\treturn normalize(vec3(SceneSDF(vec3(ori.x + NORM_EPSILON,ori.y,ori.z)) - SceneSDF(vec3(ori.x - NORM_EPSILON,ori.y,ori.z)),\n\t                      SceneSDF(vec3(ori.x,ori.y + NORM_EPSILON,ori.z)) - SceneSDF(vec3(ori.x,ori.y - NORM_EPSILON,ori.z)),\n\t                      SceneSDF(vec3(ori.x,ori.y,ori.z + NORM_EPSILON)) - SceneSDF(vec3(ori.x,ori.y,ori.z - NORM_EPSILON))));\n}\n\n#define ITERMAX 200\n\n#define DISTMAX 1000.0\n\n#define EPSILON 0.005\n\nstruct CastRet_t {\n    bool casted;\n    vec3 normal;\n    float minlen;\n};\n\nCastRet_t TraceObjects(vec3 pos,vec3 dir) {\n\tCastRet_t maincast;\n\t\n\tmaincast.normal = vec3(0.0,0.0,0.0);\n\tmaincast.casted = false;\n\tmaincast.minlen = 1000000.0;\n\t\n\t\n\t\n\tvec3 ori = pos;\n\t\n\tfor (int i = 0; i < ITERMAX; i++) {\n\t\tfloat d = SceneSDF(ori);\n\t\t\n\t\tmaincast.minlen = min(maincast.minlen,d);\n\t\t\n\t\tif (d < EPSILON) {\n\t\t\tvec3 epspos = ori - dir*EPSILON;\n\t\t\t\n\t\t\tmaincast.casted = true;\n\t\t\tmaincast.normal = SceneNormal(epspos);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (d > DISTMAX) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tori += dir*d;\n\t}\n    \n    return maincast;\n}\n\n#define MINCOLOR 0.04\n\nvec3 RaytraceObjects(vec3 pos,vec3 dir) {\n\tvec3 color = vec3(0.0,0.0,0.0);\n    \n    \n    \n    CastRet_t maincast = TraceObjects(pos,dir);\n\t\n\t\n\tif (maincast.casted) {\n\t\tcolor = (maincast.normal + vec3(1.0,1.0,1.0))/2.0;\n\t}\n\telse if (maincast.minlen < 2.0) {\n\t\tfloat c = 1.0*(1.0 - maincast.minlen/2.0);\n\t\tcolor = vec3(c*0.8,c,c);\n\t}\n\t\n\t\n\treturn color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float x = fragCoord.x;\n\tfloat y = fragCoord.y;\n\t\n    float f0 = -0.2*iMouse.y/iResolution.y + sin(iTime/3.2)/5.0;\n    float f1 = (iMouse.x/iResolution.x + sin(iTime))*20.0;\n    \n    mat4 camera = TransMatrix(-5.0,1.0,12.0)*RotMatrixY(-0.35 + f0)*TransMatrix(0.0,0.0,-2.0 + f1);\n    \n    mat4 camera_notrans = camera;\n    camera_notrans[3][0] = 0.0;\n    camera_notrans[3][1] = 0.0;\n    camera_notrans[3][2] = 0.0;\n    \n\tvec3 pos = (camera*vec4(0.0,0.0,0.0,1.0)).xyz;\n\tvec3 dir = (camera_notrans*normalize(vec4((x - iResolution.x/2.0)/iResolution.x*tan(FOV/2.0)*iResolution.x/iResolution.y,(y - iResolution.y/2.0)/iResolution.y*tan(FOV/2.0),-1.0,1.0))).xyz;\n\t\n\tfragColor = vec4(RaytraceObjects(pos,dir),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKBzw.jpg", "access": "api", "license": "mit", "functions": [[310, 310, 355, 355, 383], [385, 385, 426, 426, 454], [456, 456, 502, 502, 531], [535, 535, 578, 578, 656], [658, 658, 688, 688, 817], [821, 821, 863, 863, 896], [898, 898, 941, 941, 1109], [1113, 1113, 1149, 1149, 1411], [1414, 1414, 1440, 1440, 2108], [2139, 2139, 2167, 2167, 2543], [2688, 2688, 2731, 2731, 3223], [3248, 3248, 3289, 3289, 3600], [3605, 3605, 3662, 3662, 4375]], "test": "untested"}
{"id": "7tGfRm", "name": "Twisted neon knots", "author": "jarble", "description": "More experiments with fractal knot patterns.", "tags": ["fractal", "knot", "neon", "arabesque"], "likes": 11, "viewed": 373, "published": 3, "date": "1664234002", "time_retrieved": "2024-07-30T16:29:25.081908", "image_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        \n        //vec2(1.5,0.5)\n        //vec2(1.5,0.)\n        //vec2(2.5,1.5)\n        //vec2(1.25,1.75)\n        //vec2(-2.,.5+mod(floor(a.x),2.))\n        //vec2(abs(mod(a.x-.5,2.)-1.),abs(mod(a.y-.5,2.)-1.))\n    ,\n    \n    a1 = a+a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvec3 image1(vec2 uv,float sign1,float sign2,float sign3,float sign4,float sign5){\n    vec3 col = vec3(0.);\n    vec3 col1 = col;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 3; k++){\n        uv = abs(uv+t2*sign1);\n        t2 = triangle_wave(uv+.5*sign2);\n        uv = sign5*t2-triangle_wave(uv.yx);\n        col.x =\n            //abs((t2.x+t2.y*sign3)-(uv.x-uv.y*sign4))\n            //length(abs(uv-t2.yx*sign4)+uv.x*sign3)*9.\n            (length(uv+t2.yx*sign4)+uv.x*sign3)*9.\n        ;\n        col =\n            min(abs(abs(col-1.)-col),abs(abs(col-1.)-col.yzx));\n        col1 =\n            abs(col1+col.yzx-1.);\n    }\n    return col1;\n}\n\nvec3 max1(vec3 col1,vec3 col2){\n    return vec3(max(col1.x,col2.x),max(col1.y,col2.y),max(col1.z,col2.z));\n}\n\n#define loop1(a,b) for(float a = -1.; a < 2.; a += 2.){ b }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += iTime/t1/24.;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    loop1(i,\n        loop1(j,\n            loop1(k,\n                loop1(l,\n                    loop1(m,\n                        col = max1(col,image1(uv,i,j,k,l,m));\n                    )\n                )\n            )\n        )\n    )\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "#define fmod(x,y) mod(floor(x),y)\n//#define fmod(x,y) floor(mod(floor(x),y)*mod(floor(x/y),y)/2.)\n\n\nvec2 mainSound(int samp, float t){\n  vec2 a1 = vec2(\n      8.,3.5\n      //0.,4.\n      //fmod(t/3.5,3.5)/3.5,3.5\n  );\n  float s1 = a1.x,\n  tempo =\n      a1.y,\n      //2.5+fmod(t/4.+floor(t/4.),8.)/4.,\n      t1 = (t)*tempo,\n      c2 = fmod(t1/tempo,4.),\n      c1 = fmod(t1/4.+c2,2.+fmod(t1*2.,4.)+c2),\n  m2 = c1,\n\n  a= ((1.-sqrt(fract((t*tempo+m2+t1)/2.)/1.25)))*.2,\n  \n  nb = t*pow(2.,m2/5.+7.5);\n\n  return abs(.5-vec2(fract(nb*.998)\n   ,fract(nb)))*a;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 61, 61, 516], [518, 518, 599, 599, 1180], [1182, 1182, 1213, 1213, 1290]], "test": "untested"}
{"id": "NdKXWt", "name": "blipsy", "author": "Wally869", "description": "blips", "tags": ["blips"], "likes": 0, "viewed": 162, "published": 3, "date": "1664228663", "time_retrieved": "2024-07-30T16:29:26.425317", "image_code": "\nvec2 gridSize = vec2(10.0, 10.0);\n\nfloat maskSize = 0.33;\n\nvec2 resolution = vec2(800.0, 800.0);\n\n\n\nfloat fullCycle = 10.0;\nfloat timeToVisible = 1.0;\nfloat timeToInvisible = 1.0;\nfloat timeVisible = 2.0;\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat getDistance(vec2 p) {\n    return sqrt((p.x - 0.5) * (p.x - 0.5) + (p.y - 0.5) * (p.y - 0.5));\n}\n\nfloat easeInOutBack(float x) {\nfloat c1 = 1.70158;\nfloat c2 = c1 * 1.525;\n\nreturn x < 0.5\n  ? (pow(2.0 * x, 2.0) * ((c2 + 1.0) * 2.0 * x - c2)) / 2.0\n  : (pow(2.0 * x - 2.0, 2.0) * ((c2 + 1.0) * (x * 2.0 - 2.0) + c2) + 2.0) / 2.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvMask = fract(fragCoord/iResolution.xy * gridSize);\n    uv += vec2(0.05, 0.05);\n    \n    vec2 uvID = round(uv * gridSize) / gridSize;\n    \n    float id = hash(uvID);\n\n    \n    float normalTime = mod(iTime + id * 10.0, fullCycle);\n    \n    float fullDuration = timeToVisible + timeToInvisible + timeVisible;\n    float timeStartToInvisible = timeToVisible + timeVisible;\n    \n    float baseMaskLevel = normalTime > fullDuration ? 0.0 : easeInOutBack(clamp(normalTime / timeToVisible, 0.0, 1.0));\n    float otherMaskLevel = normalTime < timeToVisible + timeVisible || normalTime > fullDuration ? 0.0 : easeInOutBack(clamp((normalTime - timeToVisible - timeVisible) / timeToInvisible, 0.0, 1.0));\n\n    float mask = getDistance(uvMask) < maskSize * baseMaskLevel ? 1.0 : 0.0; \n    float mask2 = getDistance(uvMask) < maskSize * otherMaskLevel ? 0.0 : 1.0;\n\n\n    \n    fragColor = vec4(mask * mask2, 0.0, 0.0, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKXWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 264, 264, 368], [370, 370, 397, 397, 471], [473, 473, 503, 503, 705], [708, 708, 765, 765, 1731]], "test": "untested"}
{"id": "7lyBRw", "name": "3efficient poisson distribution", "author": "FabriceNeyret2", "description": "nothing interesting here !\nJust had to publish to help inspect a GLSL bug.\n\nThe real comparative shader was [url] https://shadertoy.com/view/NtcfDn [/url]", "tags": ["glsl", "bug"], "likes": 4, "viewed": 273, "published": 3, "date": "1664225577", "time_retrieved": "2024-07-30T16:29:27.172318", "image_code": "// DEBUG sub-part3 \"efficient poisson distribution\" by FabriceNeyret2. https://shadertoy.com/view/NtcfDn\n//#define sqrt(x) sqrt(max(x,0.))\n//#define log(x)  log(clamp(x,1e-9,1.))   // debug crash <><><>\n\n// top-left: Brute force distribution of all points is way too costly\n// bottom-right: smaller distrib or N=Poisson points per cell is equivalent but hugely cheaper ( as in Cell noise Workey paper: http://www.rhythmiccanvas.com/research/papers/worley.pdf )\n// top-right: fix density small distrib per cell is ok if the number of points per cell is big enough.\n//                                but for small density it lacks lacunarity. cf https://www.desmos.com/calculator/sjjo3qgnfp\n#define Z     min(0.,iTime)\n#define H(p)  fract(sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453)\n#define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n#define Poisson(n, seed)  Normal(n,sqrt(n),seed)               // approx valid for n not too small https://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\n#define Normal(m,s,seed)  m + s * Gauss(seed)\n#define Gauss(u)          sqrt(-2.*log(u.x)) * cos(6.283*u.y ) // takes u = rand2_uniform()\n\n#define D(seed,aa) O += max(0., 1.- R.y/3./aa * length( abs(U) - H(seed)*R/R.y ) ) // * H(seed+7.5).x // variant with varying intensity\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, I,\n          U = ( 2.*u - R ) / R.y;\n    float d = ( length(iMouse.xy)<20. ? .5+.5*sin(iTime) : iMouse.y/R.y ) * min(R.x*R.y, 1e6) / 100., // min(): debug Windows crash\n          S = 1.; // put 0 to use same seed in each cell\n    O-=O;  // if ( iTime<.1 || ( iTime >= 10. && iTime < 10.3 )) return; // debug Windows crash\n    if ( U.y < 0. ) \n       if ( U.x > 0. ) {\n            I = floor( U *= 8. ); U = fract(U);       // --- bottom right: accurate draw Poisson(Npix*d/64) points per cell\n            if (H2(I).x==0.) { O=vec4(1,0,0,1); return; };  // debug crash <><><>\n            d = Poisson(d/64., H2(I)) -.5;\n         // if( isnan(d) ) { O=vec4(1,0,0,1); return; };  // debug crash <><><>\n         // if( isnan(d) ) { O=vec4(0,1,0,1); return; };  // debug crash <><><>\n         // if( d > 1000.) { O=vec4(0,0,1,1); return;  }; // debug crash <><><>\n            for( float k=Z; k < d; k++ )\n                D( k - S*(7.7*I.x-13.3*I.y) , 8. );\n        }\n    O = sqrt(O);                                      // to sRGB\n    if ( int(u.x) == int(R.x)/2 || int(u.y) == int(R.y)/2 ) O = vec4(1,0,0,1);  // red separator \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyBRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1311, 1311, 1349, 1349, 2504]], "test": "untested"}
{"id": "slyBRw", "name": "2efficient poisson distribution", "author": "FabriceNeyret2", "description": "nothing interesting here !\nJust had to publish to help inspect a GLSL bug.\n\nThe real comparative shader was [url] https://shadertoy.com/view/NtcfDn [/url]", "tags": ["glsl", "bug"], "likes": 2, "viewed": 231, "published": 3, "date": "1664225572", "time_retrieved": "2024-07-30T16:29:27.923310", "image_code": "// DEBUG sub-part2 \"efficient poisson distribution\" by FabriceNeyret2. https://shadertoy.com/view/NtcfDn\n\n// top-left: Brute force distribution of all points is way too costly\n// bottom-right: smaller distrib or N=Poisson points per cell is equivalent but hugely cheaper ( as in Cell noise Workey paper: http://www.rhythmiccanvas.com/research/papers/worley.pdf )\n// top-right: fix density small distrib per cell is ok if the number of points per cell is big enough.\n//                                but for small density it lacks lacunarity. cf https://www.desmos.com/calculator/sjjo3qgnfp\n#define Z     min(0.,iTime)\n#define H(p)  fract(sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453)\n#define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n#define Poisson(n, seed)  Normal(n,sqrt(n),seed)               // approx valid for n not too small https://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\n#define Normal(m,s,seed)  m + s * Gauss(seed)\n#define Gauss(u)          sqrt(-2.*log(u.x)) * cos(6.283*u.y ) // takes u = rand2_uniform()\n\n#define D(seed,aa) O += max(0., 1.- R.y/3./aa * length( abs(U) - H(seed)*R/R.y ) ) // * H(seed+7.5).x // variant with varying intensity\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, I,\n          U = ( 2.*u - R ) / R.y;\n    float d = ( length(iMouse.xy)<20. ? .5+.5*sin(iTime) : iMouse.y/R.y ) * min(R.x*R.y, 1e6) / 100., // min(): debug Windows crash\n          S = 1.; // put 0 to use same seed in each cell\n    O-=O;  // if ( iTime<.1 || ( iTime >= 10. && iTime < 10.3 )) return; // debug Windows crash\n    if ( U.y > 0. ) \n        if ( U.x > 0. )                               // --- top left: brute force draw Npix*d Uniform points \n           {\n            I = floor( U *= 8. ); U = fract(U);       // --- top right:draw Npix*d/64 Uniform points per cell \n            for( float k=Z; k < d/64.; k++ )          // at 640x360 , d=1% : 36 dots ( per cell )\n                D(k - S*(7.7*I.x-13.3*I.y) , 8. );\n        }\n        \n    O = sqrt(O);                                      // to sRGB\n    if ( int(u.x)/4 == int(R.x)/8 || int(u.y) == int(R.y)/2 ) O = vec4(1,0,0,1);  // red separator\n    if (u.x<10. && u.y/R.y < (iTime-texture(iChannel0,vec2(0)).y)*55. ) O = vec4(0,1,0,1); // iTimeDelta don't work in icon\n    else if(u.x<12.) O = vec4(0,.4,0,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    O.x = iTime;\n    O.y = texture(iChannel0, vec2(0)).x;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyBRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1213, 1213, 1251, 1251, 2358]], "test": "untested"}
{"id": "styBRw", "name": "1efficient poisson distribution", "author": "FabriceNeyret2", "description": "nothing interesting here !\nJust had to publish to help inspect a GLSL bug.\n\nThe real comparative shader was [url] https://shadertoy.com/view/NtcfDn [/url]", "tags": ["glsl", "bug"], "likes": 3, "viewed": 199, "published": 3, "date": "1664225566", "time_retrieved": "2024-07-30T16:29:28.690260", "image_code": "// DEBUG sub-part1 \"efficient poisson distribution\" by FabriceNeyret2. https://shadertoy.com/view/NtcfDn\n\n// top-left: Brute force distribution of all points is way too costly\n// bottom-right: smaller distrib or N=Poisson points per cell is equivalent but hugely cheaper ( as in Cell noise Workey paper: http://www.rhythmiccanvas.com/research/papers/worley.pdf )\n// top-right: fix density small distrib per cell is ok if the number of points per cell is big enough.\n//                                but for small density it lacks lacunarity. cf https://www.desmos.com/calculator/sjjo3qgnfp\n#define Z     min(0.,iTime)\n#define H(p)  fract(sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453)\n#define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n#define Poisson(n, seed)  Normal(n,sqrt(n),seed)               // approx valid for n not too small https://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\n#define Normal(m,s,seed)  m + s * Gauss(seed)\n#define Gauss(u)          sqrt(-2.*log(u.x)) * cos(6.283*u.y ) // takes u = rand2_uniform()\n\n#define D(seed,aa) O += max(0., 1.- R.y/3./aa * length( abs(U) - H(seed)*R/R.y ) ) // * H(seed+7.5).x // variant with varying intensity\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, I,\n          U = ( 2.*u - R ) / R.y;\n    float d = ( length(iMouse.xy)<20. ? .5+.5*sin(iTime) : iMouse.y/R.y ) * min(R.x*R.y, 1e6) / 100., // min(): debug Windows crash\n          S = 1.; // put 0 to use same seed in each cell\n    O-=O;  // if ( iTime<.1 || ( iTime >= 10. && iTime < 10.3 )) return; // debug Windows crash\n    if ( U.y > 0. ) \n        if ( U.x < 0. )                               // --- top left: brute force draw Npix*d Uniform points \n            for( float k=Z; k < d; k++ )              // at 640x360 , d=1% : 2304 dots\n                D(k,1.);\n    O = sqrt(O);                                      // to sRGB\n    if ( int(u.x) == int(R.x)/2 || int(u.y) == int(R.y)/2 ) O = vec4(1,0,0,1);  // red separator \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styBRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1213, 1213, 1251, 1251, 2012]], "test": "untested"}
{"id": "flGBzm", "name": "Little Planet Thing", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 4, "viewed": 226, "published": 3, "date": "1664224727", "time_retrieved": "2024-07-30T16:29:30.092511", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0. * iResolution.xy) / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb; \n    col = length(col) * pal(col.g * 0.2 + uv.y + 0.6, 0.5 * vec3(0,1,2)/3.);\n    col *= 1.8 * pow(0.5 + 0.5 * uv.y, 4.);\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 uv2 = fragCoord / iResolution.xy;\n    float mx = 0.5 + 0.5 * thc(4., 8. * (uv.x + uv.y) + 0.5 * iTime);\n    \n    float m = mix(1., 0.01, tanh(0.6 * iTime));\n    vec2 o1 = vec2(m * cos(10. * uv.y + 200. * iTime),\n                   m * sin(10. * uv.x + 200. * iTime));\n    vec2 o2 = vec2(m * cos(10. * uv.y + 0.25 * iTime),\n                   m * sin(10. * uv.x + 0.25 * iTime)); \n    vec2 o = mix(o2, o1, mx);\n    uv2 += o;\n                \n    uv2 = fract(uv2);\n    vec3 col = texture(iChannel0, uv2).rgb; \n\n    float xp = exp(-pow(8. * dot(uv,uv), 6.));\n    \n    if (length(col) < 0.75 + 0.25 * cos(iTime))\n        col = mix(1.5, 3., mx) * xp * pal(1., 1.* vec3(0,1,1)/3.);\n    \n    //col += pal(v, (0.5 + 0.4 * cos(3.25 * v)) * vec3(0,1,2)/3.);\n    //col = clamp(col, 0., 0.8);\n    //col *= 0.99;\n    col *= 0.96;\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 343]], "test": "untested"}
{"id": "ftGBzm", "name": "Morten Hex Grid Tiling", "author": "zalo", "description": "Code ported to GLSL from: https://www.jcgt.org/published/0011/03/05/\n\nEDIT: Using fixes from mmikk; thank you!", "tags": ["grid", "tiling", "hex", "morten"], "likes": 4, "viewed": 522, "published": 3, "date": "1664220461", "time_retrieved": "2024-07-30T16:29:34.187562", "image_code": "// Code from https://www.jcgt.org/published/0011/03/05/\n// Also: https://80.lv/articles/implementing-morten-mikkelsen-s-method-of-working-with-hex-tiles/\n\n#define M_PI 3.14159\n\nvoid TriangleGrid(out float w1, out float w2, out float w3,\n\tout ivec2 vertex1, out ivec2 vertex2, out ivec2 vertex3,\n\tvec2 st) {\n\t// Scaling of the input\n\tst *= 2.0 * sqrt(3.0);\n\t// Skew input space into simplex triangle grid.\n\tmat2 gridToSkewedGrid =\n\t\tmat2(1.0, -0.57735027, 0.0, 1.15470054);\n\tvec2 skewedCoord = (st * gridToSkewedGrid);\n\tivec2 baseId = ivec2(floor(skewedCoord));\n\tvec3 temp = vec3(fract(skewedCoord), 0.0);\n\ttemp.z = 1.0 - temp.x - temp.y;\n\tfloat s = step(0.0, -temp.z);\n\tfloat s2 = 2.0 * s - 1.0;\n\tw1 = -temp.z * s2;\n\tw2 = s - temp.y * s2;\n\tw3 = s - temp.x * s2;\n\tvertex1 = baseId + ivec2(s, s);\n\tvertex2 = baseId + ivec2(s, 1.0 - s);\n\tvertex3 = baseId + ivec2(1.0 - s, s);\n}\n\nvec2 hash(ivec2 p) {\n\tvec2 r = vec2(p) * mat2(127.1, 311.7, 269.5, 183.3);\n\treturn fract(sin(r) * 43758.5453);\n}\n\n//vec2 sampleDeriv(sampler2D nmap, vec2 st, vec2 dSTdx, vec2 dSTdy){\n//    // Sample\n//    vec4 vM = 2.0*textureGrad(nmap, st, dSTdx, dSTdy)-1.0;\n//    return TspaceNormalToDerivative(vM);\n//}\n\n// Input: vM is the tangent-space normal in [-1, 1]\n// Output: convert vM to a derivative\nvec2 TspaceNormalToDerivative(vec3 vM) {\n\tconst float scale = 1.0 / 128.0;\n\t// Ensure vM delivers a positive third component using abs() and\n\t// constrain vM.z so the range of the derivative is [-128, 128].\n\tvec3 vMa = abs(vM);\n\tfloat z_ma = max(vMa.z, scale * max(vMa.x, vMa.y));\n\t// Set to match positive vertical texture coordinate axis.\n\tconst bool gFlipVertDeriv = false;\n\tconst float s = gFlipVertDeriv ? -1.0 : 1.0;\n\treturn -vec2(vM.x, s * vM.y) / z_ma;\n}\n\nvec3 Gain3(vec3 x, float r) {\n\t// Increase contrast when r > 0.5 and\n\t// reduce contrast if less.\n\tfloat k = log(1.0 - r) / log(0.5);\n\tvec3 s = 2.0 * step(0.5, x);\n\tvec3 m = 2.0 * (1.0 - s);\n\tvec3 res = 0.5 * s + 0.25 * m * pow(max(vec3(0.0), s + x * m), vec3(k));\n\treturn res.xyz / (res.x + res.y + res.z);\n}\n\nvec3 ProduceHexWeights(vec3 W,\n\tivec2 vertex1, ivec2 vertex2, ivec2 vertex3) {\n\tvec3 res = vec3(0.0);\n\tint v1 = (vertex1.x - vertex1.y) % 3;\n\tif (v1 < 0) v1 += 3;\n\tint vh = v1 < 2 ? (v1 + 1) : 0;\n\tint vl = v1 > 0 ? (v1 - 1) : 2;\n\tint v2 = vertex1.x < vertex3.x ? vl : vh;\n\tint v3 = vertex1.x < vertex3.x ? vh : vl;\n\tres.x = v3 == 0 ? W.z : (v2 == 0 ? W.y : W.x);\n\tres.y = v3 == 1 ? W.z : (v2 == 1 ? W.y : W.x);\n\tres.z = v3 == 2 ? W.z : (v2 == 2 ? W.y : W.x);\n\treturn res;\n}\n\nmat2 LoadRot2x2(ivec2 idx, float rotStrength) {\n\tfloat angle = float(abs(idx.x * idx.y) + abs(idx.x + idx.y)) + M_PI;\n\t// Remap to +/-pi.\n\tangle = mod(angle, 2.0 * M_PI);\n\tif (angle < 0.0) angle += 2.0 * M_PI;\n\tif (angle > M_PI) angle -= 2.0 * M_PI;\n\tangle *= rotStrength;\n\tfloat cs = cos(angle), si = sin(angle);\n\treturn mat2(cs, -si, si, cs);\n}\n\n\nvec2 MakeCenST(ivec2 Vertex) {\n\tmat2 invSkewMat = mat2(1.0, 0.5, 0.0, 1.0 / 1.15470054);\n\treturn (vec2(Vertex) * invSkewMat) / (2.0 * sqrt(3.0));\n}\n\n\n// Input: tex is a texture with color\n// Input: r increase contrast when r > 0.5\n// Output: color is the blended result\n// Output: weights shows the weight of each hex tile\nvoid hex2colTex(out vec4 color, out vec3 weights,\n\tsampler2D tex, vec2 st,\n\tfloat rotStrength, float r) { // r = 0.5 by default\n\tvec2 dSTdx = dFdx(st), dSTdy = dFdy(st);\n\t// Get triangle info.\n\tfloat w1, w2, w3;\n\tivec2 vertex1, vertex2, vertex3;\n\tTriangleGrid(w1, w2, w3, vertex1, vertex2, vertex3, st);\n\tmat2 rot1 = LoadRot2x2(vertex1, rotStrength);\n\tmat2 rot2 = LoadRot2x2(vertex2, rotStrength);\n\tmat2 rot3 = LoadRot2x2(vertex3, rotStrength);\n\tvec2 cen1 = MakeCenST(vertex1);\n\tvec2 cen2 = MakeCenST(vertex2);\n\tvec2 cen3 = MakeCenST(vertex3);\n\tvec2 st1 = rot1 * (st - cen1) + cen1 + hash(vertex1);\n\tvec2 st2 = rot2 * (st - cen2) + cen2 + hash(vertex2);\n\tvec2 st3 = rot3 * (st - cen3) + cen3 + hash(vertex3);\n\t// Fetch input.\n\tvec4 c1 = textureGrad(tex, st1,\n\t\t(rot1 * dSTdx), (rot1 * dSTdy));\n\tvec4 c2 = textureGrad(tex, st2,\n\t\t(rot2 * dSTdx), (rot2 * dSTdy));\n\tvec4 c3 = textureGrad(tex, st3,\n\t\t(rot3 * dSTdx), (rot3 * dSTdy));\n\t// Use luminance as weight.\n\tvec3 Lw = vec3(0.299, 0.587, 0.114);\n\tvec3 Dw = vec3(dot(c1.xyz, Lw), dot(c2.xyz, Lw), dot(c3.xyz, Lw));\n\tDw = mix(vec3(1.0), Dw, 0.6); // g_fallOffContrast = 0.6\n\tvec3 W = Dw * pow(vec3(w1, w2, w3), vec3(7)); // g_exp = 7\n\tW /= (W.x + W.y + W.z);\n\tif (r != 0.5) W = Gain3(W, r);\n\tcolor = W.x * c1 + W.y * c2 + W.z * c3;\n\tweights = ProduceHexWeights(W.xyz, vertex1, vertex2, vertex3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 size = iResolution.xy;\n\tvec2 uv = (fragCoord.xy - 0.5 * size) / size.y;\n\n\t//uv *= repetitions;\n\n\tvec4 c = vec4(0.0);\n\tvec3 weights = vec3(0.0);\n\thex2colTex(c, weights, iChannel0, uv, iTime, 0.5);\n\n\t//vec3 c = texture(iChannel0, triangleSlice(hc.xy)).xyz;\n\n\tfragColor = c;\n} ", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 306, 331, 874], [876, 876, 896, 896, 988], [1184, 1274, 1314, 1314, 1736], [1738, 1738, 1767, 1835, 2047], [2049, 2049, 2127, 2127, 2522], [2524, 2524, 2571, 2571, 2870], [2873, 2873, 2903, 2903, 3020], [3023, 3196, 3301, 3323, 4542], [4544, 4544, 4599, 4599, 4879]], "test": "untested"}
{"id": "7tyBRW", "name": "Torus arc intersection", "author": "NinjaKoala", "description": "Analytic intersection with a torus arc.\n\nThe arc is defined by two points on the inner circle of the torus, and a boolean which decides long or short arc.\n\nThis shader is a simple modification of the original one (https://www.shadertoy.com/view/4sBGDy)", "tags": ["3d", "raytracing", "torus", "intersection", "analytical", "arc", "capped"], "likes": 11, "viewed": 233, "published": 3, "date": "1664194324", "time_retrieved": "2024-07-30T16:29:35.126052", "image_code": "/*\nFork of https://www.shadertoy.com/view/4sBGDy\n*/\n\n#define AA 2\n\nconst float pi = 3.1415925;\n\n/*\nMy changes to iq's original function:\n\n* Return all four roots\n\n* Apply a halley iteration step to each root\nto fix uncovered precision issues\n\n*/\n// f(x) = (|x|² + R² - r²)² - 4·R²·|xy|² = 0\nvec4 iTorus(vec3 ro, vec3 rd, vec2 tor)\n{\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n\tfloat h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n\tif( h<0.0 ) return vec4(-1.0);\n\t//float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return vec4(-1.0);\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return vec4(-1.0);\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    vec4 intersections = vec4(1e38);\n\tint i = 0;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        \n        float t1 = -d1 - h - k3;\n        \n        float f = (((t1/4.0 + k3) * t1 + k2) * t1 + 2.0*k1) * t1 + k0;\n        float f1 = ((t1 + 3.0 * k3) * t1 + 2.0 * k2) * t1 + 2.0*k1;\n        float f2 = (3.0 * t1 + 6.0 * k3) * t1 + 2.0 * k2;\n        //t1 -= f / f1; /* Newton iteration */\n        t1 -= (2.0*f*f1) / (2.0*f1*f1 - f*f2); /* Halley iteration */\n        \n        t1 = (po<0.0)?2.0/t1:t1;\n        \n        float t2 = -d1 + h - k3;\n        \n        f = (((t2/4.0 + k3) * t2 + k2) * t2 + 2.0*k1) * t2 + k0;\n        f1 = ((t2 + 3.0 * k3) * t2 + 2.0 * k2) * t2 + 2.0*k1;\n        f2 = (3.0 * t1 + 6.0 * k3) * t1 + 2.0 * k2;\n        //t2 -= f / f1; /* Newton iteration */\n        t2 -= (2.0*f*f1) / (2.0*f1*f1 - f*f2); /* Halley iteration */\n        \n        t2 = (po<0.0)?2.0/t2:t2;\n        \n        if( t1 > 0.0 ) intersections[i++] = t1; \n        if( t2 > 0.0 ) intersections[i++] = t2;\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;\n        \n        float f = (((t1/4.0 + k3) * t1 + k2) * t1 + 2.0*k1) * t1 + k0;\n        float f1 = ((t1 + 3.0 * k3) * t1 + 2.0 * k2) * t1 + 2.0*k1;\n        float f2 = (3.0 * t1 + 6.0 * k3) * t1 + 2.0 * k2;\n        //t1 -= f / f1; /* Newton iteration */\n        t1 -= (2.0*f*f1) / (2.0*f1*f1 - f*f2); /* Halley iteration */\n        \n        t1 = (po<0.0)?2.0/t1:t1;\n        \n        float t2 = d1 + h - k3;\n        \n        f = (((t2/4.0 + k3) * t2 + k2) * t2 + 2.0*k1) * t2 + k0;\n        f1 = ((t2 + 3.0 * k3) * t2 + 2.0 * k2) * t2 + 2.0*k1;\n        f2 = (3.0 * t1 + 6.0 * k3) * t1 + 2.0 * k2;\n        //t2 -= f / f1; /* Newton iteration */\n        t2 -= (2.0*f*f1) / (2.0*f1*f1 - f*f2); /* Halley iteration */\n        \n        t2 = (po<0.0)?2.0/t2:t2;\n        \n        if( t1 > 0.0 ) intersections[i++] = t1;\n        if( t2 > 0.0 ) intersections[i++] = t2;\n    }\n\n    return intersections;\n}\n\n// df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n// This function just clips the torus to an arc\nfloat iTorusArc(vec3 ro, vec3 rd, vec3 p0, vec3 p1, vec2 tor, bool long_arc){\n\n\tfloat nearest_intersection = 1e38;\n\n\tvec4 torus_intersections = iTorus(ro, rd, tor);\n\n\tfor(int i=0; i<4; i++){\n\t\tfloat t = torus_intersections[i];\n\t\tvec3 p = ro + t * rd;\n\n\t\tvec2 center = normalize((p0.xy+p1.xy) / 2.0);\n\t\tif(dot(center, normalize(p0.xy)) < dot(center, normalize(p.xy)) ^^ long_arc){\n\t\t\tnearest_intersection = min(nearest_intersection, t);\n\t\t}\n\t}\n\n\tif(nearest_intersection > 1e37){\n\t\treturn -1.0;\n\t}\n\n\treturn nearest_intersection;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.1, 0.0 );\n\n   // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n\t    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raytrace\n\t\n\t    // raytrace-plane\n        vec2 torus = vec2(1.0,0.5);\n        float ang = (0.5 + 0.5 * sin(iTime)) * pi;\n        float t = iTorusArc(ro, rd, vec3(cos(ang),sin(ang),0), vec3(cos(ang),-sin(ang),0), torus, ang > pi/2.);\n\t    //float t = iTorus( ro, rd, torus );\n\n        // shading/lighting\t\n\t    vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n\t    if( t>0.0 )\n\t    {\n            vec3 pos = ro + t*rd;\n\t\t    vec3 nor = nTorus( pos, torus );\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n\t\t    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\t    float amb = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n\n            const float fr = 3.14159*8.0;\n            vec2 uv = vec2(0.8*atan(pos.x,pos.y),atan(pos.z,length(pos.xy)-torus.y));\n            col = vec3(0.6);\n            col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*fr*0.5)*cos(uv.y*fr*0.5)); \n            float wi = smoothstep(-1.0,-0.98,cos(uv.x*fr))*smoothstep(-1.0,-0.98,cos(uv.y*fr));\n            col *= wi;\n\n\t\t    col *= vec3(0.15,0.25,0.35)*amb + 1.05*vec3(1.0,0.9,0.7)*dif;\n            col += wi*0.3*pow(clamp(dot(hal,nor),0.0,1.0),32.0)*dif;\n\t    }\n\t\n        col = sqrt( col );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\t// dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyBRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 299, 340, 340, 4068], [4070, 4082, 4120, 4120, 4208]], "test": "untested"}
{"id": "7tKfz1", "name": "Implicit Surface Renderer", "author": "fad", "description": "This shader uses interval arithmetic to draw implicit surfaces. Keyboard/mouse controls listed in Buffer A. ", "tags": ["3d", "interactive", "plotter", "arithmetic", "interval"], "likes": 49, "viewed": 1320, "published": 3, "date": "1664189080", "time_retrieved": "2024-07-30T16:29:36.372719", "image_code": "//-------------------------Implicit Surface Renderer--------------------------//\n\n// How It Works:\n// This shader raytraces implicit surfaces by recursively subdividing the ray,\n// calculating bounding boxes for sections of the ray and using interval\n// arithmetic to test for the possible presence of solutions to f(x,y,z)=0\n// within the bounding boxes.\n\n// Implicit Surface Equation:\n// This function uses interval types (defined in the Common tab).\niFloat f(iFloat x, iFloat y, iFloat z) {\n    // Heart \n    // Pulse from https://www.shadertoy.com/view/XsfGRn\n    // Implicit Equation from https://www.shadertoy.com/view/XtXGR8\n    float tt = mod(iTime, 1.5) / 1.5;\n    float ss = pow(tt, 0.2) * 0.5 + 0.5;\n    iFloat iss = iAdd(1.0, iMul(ss * 0.5 * exp(-tt * 4.0), iSin(iAdd(tt * 6.0 * PI, iMul(0.5, y)))));\n    x = iMul(x, iAdd(0.5, iMul(iss, 0.5)));\n    y = iMul(y, iSub(1.5, iMul(iss, 0.5)));\n    z = iMul(z, iAdd(0.5, iMul(iss, 0.5)));\n    iFloat xx = iSquare(x);\n    iFloat yy = iSquare(y);\n    iFloat zz = iSquare(z);\n    iFloat yyy = iMul(yy, y);\n    iFloat a = iSub(iAdd(iAdd(xx, iMul(2.25, zz)), yy), 1.0);\n    return iSub(iMul(iMul(a, a), a), iMul(iAdd(xx, iMul(0.1125, zz)), yyy));\n\n    // Genus 2\n    //iFloat x2 = iSquare(x);\n    //iFloat y2 = iSquare(y);\n    //iFloat z2 = iSquare(z);\n    //return iIf(\n    //    iAND(iLessThan(iAbs(x), 2.0), iLessThan(iAbs(z), 2.0)),\n    //    iAdd(\n    //        iAdd(\n    //            iMul(iMul(iMul(2.0, z), iSub(z2, iMul(3.0, x2))), iSub(1.0, y2)), \n    //            iSquare(iAdd(x2, z2))\n    //        ), \n    //        iMul(iSub(iMul(9.0, y2), 1.0), iSub(y2, 1.0))\n    //    ),\n    //    ifloat(1.0)\n    //);\n\n    // Sphere\n    //return iSub(iAdd(iAdd(iSquare(x), iSquare(y)), iSquare(z)), 2.0);\n}\n\n// Ray Domain:\nconst float tMin = 0.001;\nconst float tMax = 100.0;\n\n// Precision:\n// The amount of times to recursively subdivide the ray. \nconst int maxDepth = 20;\n// The depth of the quadtree used to search for grid lines.\nconst int maxGridLineDepth = 10;\n\n// Discontinuity Tolerance:\n// If the interval returned by the implicit function over a section of the ray\n// has a width bigger than or equal to discontinuityTolerance, that section is\n// counted as containing a discontinuity and is not counted as an intersection.\n// It can be set to INFINITY if the surface is known to be continous.\nconst float discontinuityTolerance = 1000.0 * (tMax - tMin) / pow(2.0, float(maxDepth - 1));\n\n// Display Settings:\nconst float fovY = 50.0;\nconst bool doVignette = true;\nconst bool useCubemapAsBackgroundForPBR = true;\n\nconst bool renderGridLines = true;\nconst float gridLineSpacing = 0.4;\nconst float gridLineWidth = 0.02;\n\n// Rendering Mode:\nconst int regular = 1;\nconst int pbr = 2;\nconst int normalMap = 3;\n\nconst int renderingMode = pbr;\n\n\n\n//============================================================================//\n\n\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\n// Main Intersection Function:\n// Performs a depth-first search of the ray's t domain, descending if the\n// current segment possibly contains an intersection. Once the max depth is\n// reached, if there's still an intersection in the segment and it is also \n// considered continous, then it is counted as an intersection and returned.\nfloat intersect(Ray r) {\n    if (maxDepth < 1) {\n        return -1.0;\n    }\n    \n    float tRange = tMax - tMin;\n    int depth = 0;\n    int pos = 0;\n    \n    while (true) {\n        // Calculate the current t domain at this location in the tree\n        float size = float(1 << depth);\n        iFloat ti = iFloat(\n            tMin + tRange * float(pos) / size,\n            tMin + tRange * float(pos + 1) / size\n        );\n        // Find the bounding box of the ray segment and use it to calculate an\n        // interval of possible values for f\n        iFloat fi = f(\n            iAdd(r.o.x, iMul(r.d.x, ti)),\n            iAdd(r.o.y, iMul(r.d.y, ti)),\n            iAdd(r.o.z, iMul(r.d.z, ti))\n        );\n        \n        if (fi.u < 0.0 || 0.0 <= fi.l || depth == maxDepth - 1) {\n            if (fi.l <= 0.0 && 0.0 <= fi.u && fi.u - fi.l < discontinuityTolerance) {\n                // We are at a leaf of the tree and there appears to be an\n                // intersection, so return it\n                return (ti.l + ti.u) / 2.0;\n            }\n\n            // The segment of the ray this node of the tree represents\n            // definitely does not contain any intersections, so don't descend\n            // into its children and instead move onto the next node in the DFS\n            while (pos % 2 == 1) {\n                --depth;\n                pos /= 2;\n            }\n            \n            ++pos;\n            \n            if (depth == 0 && pos == 1) {\n                // We are back at the root of the tree after having searched the\n                // entire tree, so break out of the loop\n                break;\n            }\n\n            continue;\n        }\n        \n        // Descend the tree to look for possible intersections\n        ++depth;\n        pos *= 2;\n    }\n    \n    // There were no intersections\n    return -1.0;\n}\n\n// Grid Line Intersection Function: \n// too lazy to explain ;)\n// why does it have to be so complicated to get constant width grid lines!?!?\n\nconst int xAxis = 0;\nconst int yAxis = 1;\nconst int zAxis = 2;\n\nbool intersectsGridLine(vec3 p, int axis) {\n    if (maxGridLineDepth < 1) {\n        return false;\n    }\n    \n    float t = p.x;\n    float u = p.y;\n    float v = p.z;\n    float w = gridLineWidth;\n    float s = gridLineSpacing;\n    float uMin = u - w / 2.0;\n    float vMin = v - w / 2.0;\n    int depth = 0;\n    int uPos = 0;\n    int vPos = 0;\n    \n    while (true) {\n        float size = float(1 << depth);\n        iFloat ui = iFloat(uMin + w * float(uPos) / size, uMin + w * float(uPos + 1) / size);\n        iFloat vi = iFloat(vMin + w * float(vPos) / size, vMin + w * float(vPos + 1) / size);\n        iFloat ti = ifloat(s * round(t / s));\n        iFloat di = iAdd(iAdd(iSquare(iSub(u, ui)), iSquare(iSub(v, vi))), (ti.l - t) * (ti.l - t));\n        iFloat fi;\n        \n        switch (axis) {\n            case xAxis: fi = f(ti, ui, vi); break;\n            case yAxis: fi = f(vi, ti, ui); break;\n            case zAxis: fi = f(ui, vi, ti); break;\n        }\n                          \n        if (depth == maxGridLineDepth - 1 && di.u <= w * w / 4.0 && fi.l <= 0.0 && 0.0 <= fi.u) {\n            return true;\n        }\n        \n        if (di.l > w * w / 4.0 || 0.0 < fi.l || fi.u < 0.0 || depth == maxGridLineDepth - 1) {\n            while (uPos % 2 == 1 && vPos % 2 == 1) {\n                --depth;\n                uPos /= 2;\n                vPos /= 2;\n            }\n            \n            if (vPos % 2 == 0) {\n                ++vPos;\n            } else {\n                ++uPos;\n                --vPos;\n            }\n            \n            if (depth == 0 && vPos == 1) {\n                break;\n            }\n            \n            continue;\n        }\n\n        ++depth;\n        uPos *= 2;\n        vPos *= 2;\n    }\n    \n    return false;\n}\n\nbool isPointInGridLine(vec3 p) {\n    return renderGridLines && (\n        intersectsGridLine(p.xyz, xAxis) ||\n        intersectsGridLine(p.yzx, yAxis) || \n        intersectsGridLine(p.zxy, zAxis)\n    );\n}\n\nvec3 normal(vec3 p) {\n    const float e = 1e-3;\n    return normalize(vec3(\n        f(ifloat(p.x + e), ifloat(p.y), ifloat(p.z)).l - f(ifloat(p.x - e), ifloat(p.y), ifloat(p.z)).l,\n        f(ifloat(p.x), ifloat(p.y + e), ifloat(p.z)).l - f(ifloat(p.x), ifloat(p.y - e), ifloat(p.z)).l,\n        f(ifloat(p.x), ifloat(p.y), ifloat(p.z + e)).l - f(ifloat(p.x), ifloat(p.y), ifloat(p.z - e)).l\n    ));\n}\n\nvec3 normal(vec3 rd, vec3 p) {\n    vec3 n = normal(p);\n    return faceforward(n, rd, n);\n    return n;\n}\n\n\n\n//============================================================================//\n\n// Start of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n\nfloat somestep(float t) {\n    return pow(t,4.0);\n}\n\nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\n// GGX code from https://www.shadertoy.com/view/MlB3DV\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}\n\nvec3 shade(vec3 ray, vec3 normal, vec3 materialColor) {\n    // material\n    float metallic = 0.07;\n    float roughness = 0.1;\n    float fresnel_pow = mix(5.0, 3.5, metallic);\n    vec3 color_mod = vec3(1.0);\n    vec3 light_color = pow(texture(iChannel1,vec3(1.0,0.0,0.0)).xyz * 1.2, vec3(2.2));\n\n\n    // IBL\n    vec3 ibl_diffuse = pow(textureBlured(iChannel1,normal), vec3(2.2));\n    vec3 ibl_reflection = pow(textureBlured(iChannel1,reflect(ray,normal)), vec3(2.2));\n\n    // fresnel\n    float fresnel = max(1.0 - dot(normal,-ray), 0.0);\n    fresnel = pow(fresnel,fresnel_pow);    \n\n    // reflection        \n    vec3 refl = pow(texture(iChannel1,reflect(ray,normal)).xyz, vec3(2.2));\n    refl = mix(refl,ibl_reflection,(1.0-fresnel)*roughness);\n    refl = mix(refl,ibl_reflection,roughness);\n\n    // specular\n    vec3 light = normalize(vec3(-0.5,1.0,0.0));\n    float power = 1.0 / max(roughness * 0.4,0.01);\n    vec3 spec = light_color * GGX(normal,-ray,light,roughness*0.7, 0.2);\n    refl -= spec;\n\n    // diffuse\n    vec3 diff = ibl_diffuse * pow(materialColor, vec3(2.2));\n    diff = mix(diff * color_mod,refl,fresnel);        \n\n    vec3 color = mix(diff,refl * color_mod,metallic) + spec;\n    return pow(color, vec3(1.0/2.2));\n}\n\n// End of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n\n//============================================================================//\n\nvec3 saturate(vec3 color, float amount) {\n    vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), color));\n    return clamp(mix(gray, color, 1.0 + amount), vec3(0.0), vec3(1.0));\n}\n\nvec3 calculateColor(Ray r) {\n    vec3 color;\n    float t = intersect(r);\n    \n    if (t > 0.0) {\n        vec3 p = r.o + r.d * t;\n        vec3 n = normal(r.d, p);\n        float gridLineColor = isPointInGridLine(p) ? 0.1 : 1.0;\n        \n        switch (renderingMode) {\n            case regular: {\n                vec3 lv = normalize(vec3(-1.0, 2.0, -3.0));\n                float ld = dot(lv, n);\n                float l = mix(max(ld, 0.0), mix(0.02, 1.0, ld * 0.5 + 0.5), 0.1);\n                vec3 c = vec3(1.0, 1.0, 1.0) * gridLineColor;\n                color = pow(c * l, vec3(1.0 / 2.2));\n                break;\n            }\n            case normalMap: {\n                color = (n * 0.5 + 0.5) * gridLineColor;\n                break;\n            }\n            case pbr: {\n                color = shade(r.d, n, saturate(n * 0.5 + 0.5, 0.7) * gridLineColor);\n                break;\n            }\n        }\n    }\n    \n    // If I make this an \"else\" for the above if statement then it bugs on macOS\n    if (t <= 0.0) {\n        switch (renderingMode) {\n            case regular: {\n                vec3 lv = normalize(vec3(-1.0, 2.0, -3.0));\n                float ld = dot(lv, r.d);\n                float l = pow(mix(0.4, 1.0, ld * 0.5 + 0.5), 5.0);\n                vec3 c = vec3(0.2);\n                color = pow(c * l, vec3(1.0 / 2.0));\n                break;\n            }\n            case normalMap: {\n                color = vec3(0.2);\n                break;\n            }\n            case pbr: {\n                if (useCubemapAsBackgroundForPBR) {\n                    color = texture(iChannel1, r.d).rgb;\n                } else {\n                    color = vec3(0.2);\n                }\n                break;\n            }\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Calculate camera configuration from keyboard & mouse input buffer\n    vec2 camRot = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 cr = cos(camRot);\n    vec2 sr = sin(camRot);\n    mat3 v2wRotMat = mat3(\n            cr.y,         0.0,  -sr.y,\n            sr.x * sr.y,  cr.x,  cr.y * sr.x,\n            cr.x * sr.y, -sr.x,  cr.x * cr.y);\n    vec4 camPosD = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec3 camPos = camPosD.xyz + v2wRotMat * vec3(0.0, 0.0, 1.0) * camPosD.w; \n    vec2 tanHalfFov = vec2(tan(radians(fovY) * 0.5)); \n    tanHalfFov.x *= iResolution.x / iResolution.y;\n    vec2 cCoord = fragCoord / iResolution.xy * 2.0 - 1.0;\n    vec3 vDir = normalize(vec3(cCoord * tanHalfFov, -1.0));\n    vec3 wDir = v2wRotMat * vDir;\n    Ray r = Ray(camPos, wDir);\n    \n    // Calculate color\n    fragColor = vec4(calculateColor(r), 1.0);\n    \n    if (doVignette) {\n        fragColor.rgb *= 1.0 - 0.8 * pow(distance(vec2(0.5, 0.5), fragCoord / iResolution.xy), 3.0);\n    }\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//------------------------Interval Arithmetic Library-------------------------//\n\n// Interval Types:\n// These types keep track of a lower and upper bound throughout computation, \n// giving definitive bounds for the end result.\n\nstruct iFloat {\n    float l;\n    float u;\n};\n\nstruct iVec3 {\n    iFloat x;\n    iFloat y;\n    iFloat z;\n};\n\nstruct iBool {\n    bool l;\n    bool u;\n};\n\n// Functions: \n// Most of these functions have the same domains as the native GLSL equivalents. \n// If the arguments are outside of the domain, an empty set is returned. To be \n// correct, these should be propagated like NaNs, however, it slows down the\n// shader a lot and isn't necessary most of the time so propagation is optional.\n// These functions are overloaded so they can be called without having to\n// convert floats to iFloats or bools to iBools when mixing them with non-\n// interval types.\n\n#define PROPAGATE_EMPTY_SETS 0\n\niFloat iAdd(iFloat x, iFloat y);\niFloat iSub(iFloat x, iFloat y);\niFloat iMul(iFloat x, iFloat y);\niFloat iDiv(iFloat x, iFloat y);\n\niFloat iNeg(iFloat x); // -x\niFloat iInv(iFloat x); // 1 / x\n\niFloat iSin(iFloat x);\niFloat iCos(iFloat x);\niFloat iTan(iFloat x);\n\niFloat iAsin(iFloat x);\niFloat iAcos(iFloat x);\niFloat iAtan(iFloat x);\niFloat iAtan(iFloat y, iFloat x); // never undefined\n\niFloat iSinh(iFloat x);\niFloat iCosh(iFloat x);\niFloat iTanh(iFloat x);\n\niFloat iAsinh(iFloat x);\niFloat iAcosh(iFloat x);\niFloat iAtanh(iFloat x);\n\niFloat iExp(iFloat x);\niFloat iExp2(iFloat x);\n\niFloat iLog(iFloat x);\niFloat iLog2(iFloat x);\n                                                                                \niFloat iPow(iFloat x, iFloat y); // defined for x >= 0.0 or when y is an integer\n\niFloat iSqrt(iFloat x);\niFloat iCbrt(iFloat x);\niFloat iSquare(iFloat x);\n\niFloat iSign(iFloat x);\niFloat iAbs(iFloat x);\niFloat iFloor(iFloat x);\niFloat iCeil(iFloat x);\niFloat iRound(iFloat x);\niFloat iTrunc(iFloat x);\niFloat iMod(iFloat x, iFloat y);\niFloat iFract(iFloat x);\n\niFloat iMin(iFloat x, iFloat y);\niFloat iMax(iFloat x, iFloat y);\niFloat iClamp(iFloat x, iFloat minVal, iFloat maxVal);\n\niFloat iMix(iFloat x, iFloat y, iFloat a);\niFloat iSmoothstep(iFloat edge0, iFloat edge1, iFloat x);\niFloat iStep(iFloat edge, iFloat x);\n\niFloat iIf(iBool P, iFloat x, iFloat y); // use this as the ternary operator\n\niBool iEqual(iFloat x, iFloat y);\niBool iGreaterThan(iFloat x, iFloat y);\niBool iGreaterThanEqual(iFloat x, iFloat y);\niBool iLessThan(iFloat x, iFloat y);\niBool iLessThanEqual(iFloat x, iFloat y);\n\niBool iNOT(iBool x);\niBool iAND(iBool x, iBool y);\niBool iOR(iBool x, iBool y);\niBool iXOR(iBool x, iBool y);\n\n// Constructors:\n// Aren't necessary most of the time since the functions are already overloaded.\niFloat ifloat(float x);\niBool ibool(bool x);\n\n// Constants:\nconst float INFINITY = uintBitsToFloat(0x7F800000u);\nconst float PI = 3.14159265;\n\n\n\n//============================================================================//\n\n\n\n// Overloads:\n#define MAKE_OVERLOADSB(fn) iBool fn(bool x,iBool y){return fn(ibool(x),y);}iBool fn(iBool x,bool y){return fn(x,ibool(y));}\n#define MAKE_OVERLOADSBF(fn) iBool fn(float x,iFloat y){return fn(ifloat(x),y);}iBool fn(iFloat x,float y){return fn(x,ifloat(y));}\n#define MAKE_OVERLOADS2(fn) iFloat fn(float x,iFloat y){return fn(ifloat(x),y);}iFloat fn(iFloat x,float y){return fn(x,ifloat(y));}\n#define MAKE_OVERLOADS3(fn) iFloat fn(float x,iFloat y,iFloat z){return fn(ifloat(x),y,z);}iFloat fn(iFloat x,float y,iFloat z){return fn(x,ifloat(y),z);}iFloat fn(iFloat x,iFloat y,float z){return fn(x,y,ifloat(z));}iFloat fn(float x,float y,iFloat z){return fn(ifloat(x),ifloat(y),z);}iFloat fn(float x,iFloat y,float z){return fn(ifloat(x),y,ifloat(z));}iFloat fn(iFloat x,float y,float z){return fn(x,ifloat(y),ifloat(z));}\n\nMAKE_OVERLOADS2(iAdd)\nMAKE_OVERLOADS2(iSub)\nMAKE_OVERLOADS2(iMul)\nMAKE_OVERLOADS2(iDiv)\nMAKE_OVERLOADS2(iPow)\n\nMAKE_OVERLOADS2(iMod)\n\nMAKE_OVERLOADS2(iMin)\nMAKE_OVERLOADS2(iMax)\nMAKE_OVERLOADS3(iClamp)\n\nMAKE_OVERLOADS3(iMix)\nMAKE_OVERLOADS3(iSmoothstep)\nMAKE_OVERLOADS2(iStep)\n\nMAKE_OVERLOADSBF(iEqual)\nMAKE_OVERLOADSBF(iGreaterThan)\nMAKE_OVERLOADSBF(iGreaterThanEqual)\nMAKE_OVERLOADSBF(iLessThan)\nMAKE_OVERLOADSBF(iLessThanEqual)\n\nMAKE_OVERLOADSB(iAND)\nMAKE_OVERLOADSB(iOR)\nMAKE_OVERLOADSB(iXOR)\n\n// Empty Sets:\nconst iFloat EMPTY_SET = iFloat(-INFINITY, -INFINITY);\nconst iBool EMPTY_BSET = iBool(true, false);\n\n#if PROPAGATE_EMPTY_SETS\n    #define CHECK_IF_EMPTY_SET_F(x) if ((x) == EMPTY_SET) return EMPTY_SET\n    #define CHECK_IF_EMPTY_SET_B(x) if ((x) == EMPTY_SET) return EMPTY_BSET\n    #define CHECK_IF_EMPTY_BSET_F(x) if ((x) == EMPTY_BSET) return EMPTY_SET\n    #define CHECK_IF_EMPTY_BSET_B(x) if ((x) == EMPTY_BSET) return EMPTY_BSET\n#else\n    #define CHECK_IF_EMPTY_SET_F(x)\n    #define CHECK_IF_EMPTY_SET_B(x)\n    #define CHECK_IF_EMPTY_BSET_F(x)\n    #define CHECK_IF_EMPTY_BSET_B(x)\n#endif\n\n// Constructors:\niFloat ifloat(float x) {\n    return iFloat(x, x);\n}\n\n\niBool ibool(bool x) {\n    return iBool(x, x);\n}\n\n// Helper Functions:\niFloat iMinMax(float x, float y, float z, float w) {\n    return iFloat(\n        min(x, min(y, min(z, w))),\n        max(x, max(y, max(z, w)))\n    );\n}\n\niBool iMinMax(bool x, bool y, bool z, bool w) {\n    return iBool(\n        x || y || z || w,\n        x && y && z && w\n    );\n}\n\n\n// Function Implementations:\n\niFloat iAdd(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(x.l + y.l, x.u + y.u);\n}\n\niFloat iSub(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(x.l - y.u, x.u - y.l);\n}\n\niFloat iMul(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iMinMax(x.l * y.l, x.l * y.u, x.u * y.l, x.u * y.u);\n}\n\niFloat iDiv(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iMul(x, iInv(y));\n}\n\n\niFloat iNeg(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(-x.u, -x.l);\n}\n\niFloat iInv(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x); \n    \n    if (x.l > 0.0 || x.u < 0.0) {\n        return iFloat(1.0 / x.u, 1.0 / x.l);\n    } else if (x.l < 0.0 && x.u > 0.0) {\n        return iFloat(-INFINITY, INFINITY);\n    } else if (x.u == 0.0) {\n        return iFloat(-INFINITY, 1.0 / x.l);\n    } else {\n        return iFloat(1.0 / x.u, INFINITY);\n    }\n}\n\n\niFloat iSin(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    float u = PI * round(x.l / PI) + PI * 1.5;\n    \n    if (u < x.u) {\n        return iFloat(-1.0, 1.0);\n    }\n    \n    u -= PI;\n    vec2 s = vec2(sin(x.l), sin(x.u));\n    vec2 r = vec2(min(s.x, s.y), max(s.x, s.y));\n    \n    if (u < x.u) {\n        float s = sin(u);\n        return iFloat(min(r.x, s), max(r.y, s));\n    }\n    \n    return iFloat(r.x, r.y);\n}\n\niFloat iCos(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iSin(iAdd(x, ifloat(PI / 2.0)));\n}\n\niFloat iTan(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iDiv(iSin(x), iCos(x));\n}\n\n\niFloat iAsin(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(-PI / 2.0, asin(x.u));\n        }\n        \n        return iFloat(-PI / 2.0, PI / 2.0);\n    }\n    \n    if (x.u < 1.0) {\n        return iFloat(asin(x.l), asin(x.u));\n    }\n    \n    if (x.l < 1.0) {\n        return iFloat(asin(x.l), PI / 2.0);\n    }\n    \n    if (x.l == 1.0) {\n        return ifloat(PI / 2.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iAcos(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(acos(x.u), PI);\n        }\n        \n        return iFloat(0.0, PI);\n    }\n    \n    if (x.u < 1.0) {\n        return iFloat(acos(x.u), acos(x.l));\n    }\n    \n    if (x.l < 1.0) {\n        return iFloat(0.0, acos(x.l));\n    }\n    \n    if (x.l == 1.0) {\n        return ifloat(0.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iAtan(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(atan(x.l), atan(x.u));\n}\n\niFloat iAtan(iFloat y, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(y);\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < 0.0) {\n        if (y.u < 0.0) {\n            return iFloat(atan(y.u, x.l), atan(y.l, x.u));\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI, PI);\n        }\n        \n        return iFloat(atan(y.u, x.u), atan(y.l, x.l));\n    }\n    \n    if (x.u == 0.0) {\n        if (x.l < 0.0) {\n            if (y.u < 0.0) {\n                return iFloat(atan(y.u, x.l), -PI / 2.0);\n            }\n            \n            if (y.l < 0.0) {\n                return iFloat(-PI, PI);\n            }\n            \n            if (y.l == 0.0) {\n                return iFloat(0.0, PI);\n            }\n            \n            return (iFloat(PI / 2.0, atan(y.l, x.l)));\n        }\n        \n        if (y.u < 0.0) {\n            return ifloat(-PI / 2.0);\n        }\n        \n        if (y.u == 0.0) {\n            if (y.l < 0.0) {\n                return iFloat(-PI / 2.0, 0.0);\n            }\n            \n            return ifloat(0.0);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI / 2.0, PI / 2.0);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI / 2.0);\n        }\n        \n        return ifloat(PI / 2.0);\n    }\n    \n    if (x.l < 0.0) {\n        if (y.u < 0.0) {\n            return iFloat(atan(y.u, x.l), atan(y.u, x.u));\n        }\n        \n        if (y.u == 0.0) {\n            if (y.l == 0.0) {\n                return iFloat(0.0, PI);\n            }\n            \n            return iFloat(-PI, PI);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI, PI);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI);\n        }\n        \n        return iFloat(atan(y.l, x.u), atan(y.l, x.l));\n    }\n    \n    if (x.l == 0.0) {\n        if (y.u <= 0.0) {\n            return iFloat(atan(y.u, x.u), -PI / 2.0);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI / 2.0, PI / 2.0);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI / 2.0);\n        }\n        \n        return iFloat(atan(y.l, x.u), PI / 2.0);\n    }\n    \n    return iAtan(iDiv(y, x));\n}\n\n\niFloat iSinh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(sinh(x.l), sinh(x.u));\n}\n\niFloat iCosh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u <= 0.0) {\n        return iFloat(cosh(x.u), cosh(x.l));\n    }\n    \n    if (x.l <= 0.0 && 0.0 < x.u) {\n        return iFloat(1.0, cosh(max(-x.l, x.u)));\n    }\n    \n    return iFloat(cosh(x.l), cosh(x.u));\n}\n\niFloat iTanh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(tanh(x.l), tanh(x.u));\n}\n\n\niFloat iAsinh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(asinh(x.l), asinh(x.u));\n}\n\niFloat iAcosh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < 1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.u == 1.0) {\n        return ifloat(0.0);\n    }\n    \n    if (x.l <= 1.0) {\n        return iFloat(0.0, acosh(x.u));\n    }\n    \n    return iFloat(acosh(x.l), acosh(x.u));\n}\n\niFloat iAtanh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u <= -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(-INFINITY, atanh(x.u));\n        }\n        \n        return iFloat(-INFINITY, INFINITY);\n    }\n    \n    if (x.l < 1.0) {\n        if (x.u < 1.0) {\n            return iFloat(atanh(x.l), atanh(x.u));\n        }\n        \n        return iFloat(atanh(x.l), INFINITY);\n    }\n    \n    return EMPTY_SET;\n}\n\n\niFloat iExp(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(exp(x.l), exp(x.u));\n}\n\niFloat iExp2(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(exp2(x.l), exp2(x.u));\n}\n\n\niFloat iLog(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(log(x.l), log(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(-INFINITY, log(x.u));\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iLog2(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(log2(x.l), log2(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(-INFINITY, log2(x.u));\n    }\n    \n    return EMPTY_SET;\n}\n\n\niFloat iPow(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    \n    if (x.l < 0.0 && y.l == y.u && fract(y.l) == 0.0) {\n        float y = y.l;\n        \n        if (y == 0.0) {\n            return ifloat(1.0);\n        }\n\n        if (y > 0.0) {\n            if (mod(y, 2.0) == 1.0) {\n                return iFloat(-pow(-x.l, y), pow(abs(x.u), y) * sign(x.u));\n            }\n\n            if (x.u > 0.0) {\n                return iFloat(0.0, pow(max(-x.l, x.u), y));\n            }        \n\n            return iFloat(pow(-x.u, y), pow(-x.l, y));;\n        }\n\n        if (mod(y, 2.0) == 1.0) {\n            if (x.u > 0.0) {\n                return iFloat(-INFINITY, INFINITY);\n            }\n\n            if (x.u == 0.0) {\n                return iFloat(-INFINITY, -pow(-x.l, y));\n            }\n\n            return iFloat(-pow(-x.u, y), -pow(-x.l, y));\n        }\n\n        if (x.u > 0.0) {\n            return iFloat(min(pow(-x.l, y), pow(x.u, y)), INFINITY);\n        }\n\n        if (x.u == 0.0) {\n            return iFloat(pow(-x.l, y), INFINITY);\n        }\n\n        return iFloat(pow(-x.l, y), pow(-x.u, y));\n    }\n    \n    if (x.u < 0.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.u == 0.0) {\n        if (y.l == 0.0 && y.u == 0.0) {\n            return EMPTY_SET;\n        }\n        \n        return ifloat(0.0);\n    }\n    \n    x.l = max(x.l, 0.0);\n    \n    if (x.l == 0.0) {\n        if (y.u <= 0.0) {\n            if (y.l == 0.0) {\n                return ifloat(1.0);\n            }\n            \n            if (x.u < 1.0) {\n                return iFloat(pow(x.u, y.u), INFINITY);\n            }\n            \n            return iFloat(pow(x.u, y.l), INFINITY);\n        }else\n        \n        if (y.l < 0.0) {\n            return iFloat(0.0, INFINITY);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, max(1.0, pow(x.u, y.u)));\n        }\n    }\n    \n    return iMinMax(pow(x.l, y.l), pow(x.l, y.u), pow(x.u, y.l), pow(x.u, y.u));\n}\n\n\niFloat iSqrt(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(sqrt(x.l), sqrt(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(0.0, sqrt(x.u));\n    }\n    \n    if (x.u == 0.0) {\n        return ifloat(0.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iCbrt(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(pow(abs(x.l), 1.0 / 3.0) * sign(x.l), pow(abs(x.u), 1.0 / 3.0) * sign(x.u));\n}\n\niFloat iSquare(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l <= 0.0 && 0.0 <= x.u) {\n        float t = max(-x.l, x.u);\n        return iFloat(0.0, t * t);\n    }\n    \n    if (x.u <= 0.0) {\n        return iFloat(x.u * x.u, x.l * x.l);\n    }\n    \n    return iFloat(x.l * x.l, x.u * x.u);\n}\n\n\niFloat iSign(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(sign(x.l), sign(x.u));\n}\n\niFloat iAbs(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l >= 0.0) {\n        return x;\n    }\n    \n    if (x.u <= 0.0) {\n        return iNeg(x);\n    }\n    \n    return iFloat(0.0, max(-x.l, x.u));\n}\n\niFloat iFloor(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(floor(x.l), floor(x.u));\n}\n\niFloat iCeil(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(ceil(x.l), ceil(x.u));\n}\n\niFloat iRound(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(round(x.l), round(x.u));\n}\n\niFloat iTrunc(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(trunc(x.l), trunc(x.u));\n}\n\niFloat iMod(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iSub(x, iMul(y, iFloor(iDiv(x, y))));\n}\n\niFloat iFract(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iSub(x, iFloor(x));\n}\n\n\niFloat iMin(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(min(x.l, y.l), min(x.u, y.u));\n}\n\niFloat iMax(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(max(x.l, y.l), max(x.u, y.u));\n}\n\niFloat iClamp(iFloat x, iFloat minVal, iFloat maxVal) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(minVal);\n    CHECK_IF_EMPTY_SET_F(maxVal);\n    return iFloat(clamp(x.l, minVal.l, maxVal.l), clamp(x.u, minVal.u, maxVal.u));\n}\n\n\niFloat iMix(iFloat x, iFloat y, iFloat a) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    CHECK_IF_EMPTY_SET_F(a);\n    return iAdd(x, iMul(iSub(y, x), a));\n}\n\niFloat iSmoothstep(iFloat edge0, iFloat edge1, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(edge0);\n    CHECK_IF_EMPTY_SET_F(edge1);\n    CHECK_IF_EMPTY_SET_F(x);\n    iFloat t = iClamp(iDiv(iSub(x, edge0), iSub(edge1, edge0)), 0.0, 1.0);\n    return iMul(iSquare(t), iSub(3.0, iMul(2.0, t)));\n}\n\niFloat iStep(iFloat edge, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(edge);\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (edge.u <= x.l) {\n        return ifloat(1.0);\n    }\n    \n    if (x.u < edge.l) {\n        return ifloat(0.0);\n    }\n    \n    return iFloat(0.0, 1.0);\n}\n\n\niFloat iIf(iBool P, iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_BSET_F(P);\n    \n    if (P.l) {\n        return x;\n    }\n    \n    if (!P.u) {\n        return y;\n    }\n    \n    if (x == EMPTY_SET) {\n        return y;\n    }\n    \n    if (y == EMPTY_SET) {\n        return x;\n    }\n    \n    return iFloat(min(x.l, y.l), max(x.u, y.u));\n}\n\niFloat iIf(bool P, iFloat x, iFloat y) {\n    return iIf(ibool(P), x, y);\n}\niFloat iIf(bool P, float x, iFloat y) {\n    return iIf(ibool(P), ifloat(x), y);\n}\niFloat iIf(bool P, iFloat x, float y) {\n    return iIf(ibool(P), x, ifloat(y));\n}\niFloat iIf(iBool P, float x, iFloat y) {\n    return iIf(P, ifloat(x), y);\n}\niFloat iIf(iBool P, float x, float y) {\n    return iIf(P, ifloat(x), ifloat(y));\n}\niFloat iIf(iBool P, iFloat x, float y) {\n    return iIf(P, x, ifloat(y));\n}\n\niBool iEqual(iFloat x, iFloat y) {\n    if (x == y) {\n        return ibool(true);\n    }\n    \n    if (x.l <= y.u && y.l <= x.l) {\n        return iBool(false, true);\n    }\n    \n    return ibool(false);\n}\n\niBool iGreaterThan(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.l > y.u) {\n        return ibool(true);\n    }\n    \n    if (x.u <= y.l) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iGreaterThanEqual(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.l >= y.u) {\n        return ibool(true);\n    }\n    \n    if (x.u < y.l) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iLessThan(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.u < y.l) {\n        return ibool(true);\n    }\n    \n    if (x.l >= y.u) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iLessThanEqual(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.u <= y.l) {\n        return ibool(true);\n    }\n    \n    if (x.l > y.u) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\n\niBool iNOT(iBool x) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    \n    if (x.l && x.u) {\n        return ibool(false);\n    }\n    \n    if (!x.l && !x.u) {\n        return ibool(true);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iAND(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l && y.l, x.l && y.u, x.u && y.l, x.u && y.u);\n}\n\niBool iOR(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l || y.l, x.l || y.u, x.u || y.l, x.u || y.u);\n}\n\niBool iXOR(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l ^^ y.l, x.l ^^ y.u, x.u ^^ y.l, x.u ^^ y.u);\n}", "buffer_a_code": "//-----------------------Keyboard & Mouse Input Handler-----------------------//\n\n// Settings: \nconst float MOUSE_SENSITIVITY = 5.0;  \nconst float MOVEMENT_SPEED = 4.0; // Units per second\n\n// Controls:\nconst float KEY_W = 87.0;     // forwards\nconst float KEY_A = 65.0;     // left\nconst float KEY_S = 83.0;     // backwards\nconst float KEY_D = 68.0;     // right\nconst float KEY_UP = 38.0;    // forwards\nconst float KEY_LEFT = 37.0;  // left\nconst float KEY_DOWN = 40.0;  // backwards\nconst float KEY_RIGHT = 39.0; // right\nconst float KEY_SPACE = 32.0; // up\nconst float KEY_SHIFT = 16.0; // down\nconst float KEY_J = 74.0;     // up\nconst float KEY_N = 78.0;     // down\nconst float KEY_K = 75.0;     // decrease orbit radius\nconst float KEY_M = 77.0;     // increase orbit radius\n\n\n\n//============================================================================//\n\n\n\nbool keyPressed(float keyCode) {\n    return texture(iChannel0, vec2((keyCode + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    if (fragCoord == vec2(0.5, 0.5)) {\n        if (iMouse.z > 0.0) {\n            vec2 oldCamRot = texelFetch(iChannel1, ivec2(0, 0), 0).zw;\n            float mouseSens = -MOUSE_SENSITIVITY / iResolution.x;\n            fragColor = vec4(clamp(oldCamRot.x - (iMouse.y - abs(iMouse.w)) * mouseSens, -PI * 0.5, PI * 0.5),\n                                   oldCamRot.y + (iMouse.x - abs(iMouse.z)) * mouseSens,\n                                   oldCamRot);\n        } else {\n            vec2 camRot = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n            fragColor = camRot.xyxy;\n        }\n        \n        if (iFrame == 0 || iMouse.x == 0.0 && iMouse.z == 0.0) {\n            fragColor.x = mix(-0.3, 0.1, 0.5 - 0.5 * cos(iTime * 0.5));\n            fragColor.y = -0.5 + iTime * 0.3;\n        }\n    } else if (fragCoord == vec2(1.5, 0.5)) {\n        fragColor = texelFetch(iChannel1, ivec2(1, 0), 0);\n        float camRotY = texelFetch(iChannel1, ivec2(0, 0), 0).y;\n        float c = cos(camRotY);\n        float s = sin(camRotY);\n        mat3 rotMat = mat3(\n                c,   0.0,  -s,\n                0.0, 1.0,  0.0,\n                s,   0.0,  c\n            ) * MOVEMENT_SPEED * iTimeDelta;\n        vec3 right = vec3(1.0, 0.0, 0.0);\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        vec3 forward = vec3(0.0, 0.0, -1.0);\n        \n        if (keyPressed(KEY_W) || keyPressed(KEY_UP)) {\n            fragColor.xyz += rotMat * forward;\n        }\n        if (keyPressed(KEY_S) || keyPressed(KEY_DOWN)) {\n            fragColor.xyz -= rotMat * forward;\n        }\n        \n        if (keyPressed(KEY_D) || keyPressed(KEY_RIGHT)) {\n            fragColor.xyz += rotMat * right;\n        }\n        if (keyPressed(KEY_A) || keyPressed(KEY_LEFT)) {\n            fragColor.xyz -= rotMat * right;\n        }\n        \n        if (keyPressed(KEY_SPACE) || keyPressed(KEY_J)) {\n            fragColor.xyz += rotMat * up;\n        }\n        if (keyPressed(KEY_SHIFT) || keyPressed(KEY_N)) {\n            fragColor.xyz -= rotMat * up;\n        }\n            \n        if (keyPressed(KEY_K)) {\n            fragColor.w   -= MOVEMENT_SPEED * iTimeDelta;\n        }\n        if (keyPressed(KEY_M)) {\n            fragColor.w   += MOVEMENT_SPEED * iTimeDelta;\n        }\n        \n        fragColor.w = iFrame == 0 ? 4.0 : max(fragColor.w, 0.0);\n    } else if (fragCoord == vec2(0.5, 1.5)) {\n        if (keyPressed(KEY_W)     || keyPressed(KEY_A)     || \n            keyPressed(KEY_S)     || keyPressed(KEY_D)     || \n            keyPressed(KEY_UP)    || keyPressed(KEY_LEFT)  || \n            keyPressed(KEY_DOWN)  || keyPressed(KEY_RIGHT) || \n            keyPressed(KEY_SPACE) || keyPressed(KEY_SHIFT) || \n            keyPressed(KEY_J)     || keyPressed(KEY_N)     || \n            keyPressed(KEY_K)     || keyPressed(KEY_M)     || \n            \n            iMouse.z > 0.0) {\n            fragColor.x = 1.0;\n        } else {\n            fragColor.x = texelFetch(iChannel1, ivec2(0, 1), 0).x + 1.0;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKfz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[357, 453, 493, 631, 1759], [2926, 3260, 3284, 3284, 5100], [5308, 5308, 5351, 5351, 7050], [7052, 7052, 7084, 7084, 7255], [7257, 7257, 7278, 7278, 7655], [7657, 7657, 7687, 7687, 7761], [7921, 7921, 7946, 7946, 7971], [7973, 7973, 8016, 8016, 8624], [8626, 8626, 8672, 8672, 9584], [9586, 9641, 9677, 9677, 9716], [9717, 9717, 9779, 9779, 10474], [10476, 10476, 10531, 10547, 11708], [11864, 11864, 11905, 11905, 12041], [12043, 12043, 12071, 12071, 13813], [13815, 13815, 13870, 13943, 14851]], "test": "untested"}
{"id": "NlVBzW", "name": "painting texture", "author": "FabriceNeyret2", "description": "Paint with mouse. SPACE to erase.\nAs often, painting a uv field rather than directly splatting texture elements gives a far better result.\nTry other textures ( lines #9-11).\nNB: the shader doesn't need to run to work, and indeed even better that way ;-)", "tags": ["paint", "viamapping"], "likes": 23, "viewed": 502, "published": 3, "date": "1664179155", "time_retrieved": "2024-07-30T16:29:37.334148", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n // O = texture(iChannel0,u/R,4.);                              // to simulate low uvGrid resolution\n \n    O /= (O.w + 1e-9);                                          // load and normalize texture coordinates\n // O *= step(1e-9,texture(iChannel0,u/R).w);                   // use with lowres uvGdrid ( cut mask bleeding )\n    \n    O = texture(iChannel1, 2.*O.xy);  O*=O*2.;                  // apply texture\n // O = texture(iChannel2, .5*O.xy);                            // try texture#2\n // O = sin(40.*O); O=clamp(O/fwidth(O),-1.,1.); O = .5+.5*O.x*O.yyyy; // checkers\n    \n // if (u.x<10. && u.y<10.*T(vec2(1)).x ) O++;                  // debug: cur layer\n // O += smoothstep(0.,-3./R.y, length(2.*u/R.y-T(0).xy)-.05 ); // debug: cur texture pos\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n", "buffer_a_code": "#define keyDown(a)    ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = iFrame<1 || keyDown(32)                  // init:\n          ? u==vec2(.5) ? vec4(.5*R/R.y,0,0)     //   pos in texture, prev mouse pos\n                        : O*0.                   //   reset drawing\n          :               T(u);                  // current drawing\n    \n    float i = T(vec2(1)).w,                      // current layer id\n          a = step(length(iMouse.wy),10.),       // demo mode\n          m = a==0. ? iMouse.z : 1.,             // mouse states\n          s = a==0. ? iMouse.w : ( iFrame%20==0 ? 1. : -1. ),\n          e = .03;\n    vec2  U = ( 2.*u - R ) / R.y,                // pixel position\n          M = a==0.\n                ? ( 2.* iMouse.xy - R ) / R.y    // mouse position\n                : .7*R/R.y*cos(iTime*vec2(1,2.71)+vec2(0,11)), // demo mode\n          D = M - T(0).zw,                       // mouse displacement       \n          d = normalize(D + 1e-9);               // normalize\n    mat2  r = mat2(d.x,d.y,-d.y,d.x);            // mouse frame related to displacement\n\n    \n    if (m>0.)\n        if (u==vec2(.5)) { O.xy += D*r; if(O.zw != M ) O.zw = M; } // current location in texture\n        else if (u==vec2(1.5) && s>0. )  O.w++;  // new paint layer\n        else if (s<0.) // && length(D)>0. )\n            if( length(U-M)<.1+e && O.z != i )   // layer overlap: replace\n                O = vec4( T(0).xy + (U-M)*r , i, 1);\n            else\n            O += smoothstep(e,-e,length(U-M)-.1) // splat new uv neighborhood\n              *  vec4( T(0).xy + (U-M)*r ,0,1);  // cumulates weight               \n           // *  texture(iChannel1, 2.*( T(0).xy + (U-M)*r ) ); // variant: directly splat texture\n}\n", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 805]], "test": "untested"}
{"id": "ftKBRW", "name": "Matrix(ByteDance)", "author": "Ernst", "description": "It's the logo of our team.", "tags": ["logo", "matrix", "bytedance"], "likes": 6, "viewed": 302, "published": 3, "date": "1664164727", "time_retrieved": "2024-07-30T16:29:38.533941", "image_code": "// Bloom \n// Created by Ernst\n\nfloat Square(int x)\n{ \n    return float(x * x); \n}\n\nvec4 Bloom(vec2 fragCoord)\n{\n\tconst int   blurRadius    = 5;\n    const float blurVariance  = 0.45 * float(blurRadius * blurRadius);    \n    vec2        invResolution = 1.0 / iResolution.xy;\n    \n    vec4 sum = vec4(texture(iChannel0, fragCoord.xy * invResolution).rgb * 13.0, 13.0);\n   \n    for (int dx = -blurRadius; dx < blurRadius; dx += 2)\n    {\n        for (int dy = -blurRadius; dy < blurRadius; dy += 2) \n        {\n\t        vec3 src = texture(iChannel0, (fragCoord.xy + vec2(dx, dy) + 0.5) * invResolution).rgb;\n            float weight = exp2(-(Square(dx) + Square(dy)) / blurVariance);\n            sum += vec4(src, 1.0) * weight * 4.0;\n        }\n    }\n    \n    return vec4(pow(sum.rgb / sum.a, vec3(0.35)), 1.0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = Bloom(fragCoord);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Common GLSL\n// Created by Ernst\n\n/* --------------------------------------------- */\n/* Control Macros */\n#define TIME (iTime + 100.0)\n#define _Time vec4((TIME / 20.0), TIME, (TIME * 2.0), (TIME * 3.0))\n\n#define PI2 6.28318530718\n#define PI 3.1416\n\n#define SCREEN_WIDTH iResolution.x\n#define SCREEN_HEIGHT iResolution.y\n#define RANDOM_SEED 10.0\n#define SPEED 200.0\n#define SIGN_WIDTH 15.0\n#define SIGN_HEIGHT (SIGN_WIDTH * 2.0)\n#define SIGN_SIZE vec2(SIGN_WIDTH, SIGN_HEIGHT)\n#define SIGN_HEIGHT_NUMBER (SCREEN_HEIGHT / SIGN_HEIGHT)\n\n#define Deg2Rad 0.01745329\n#define Rad2Deg 57.29578\n\n/* --------------------------------------------- */\n/* Common Function */\n\nfloat Random (vec2 st, float n) \n{\n \tst = floor(st * n);\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n/* --------------------------------------------- */\n/* Print Character */\n\n#define CHAR_SIZE vec2(3.0, 7.0)\n\n/*M\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n â–ˆ         010    \nâ–ˆ â–ˆ      101    \nâ–ˆ â–ˆ      101    \nâ–ˆâ–ˆâ–ˆ -> 111 -> 010 101 101 111 101 101 101 -> 712557\nâ–ˆ â–ˆ      101    \nâ–ˆ â–ˆ      101    \nâ–ˆ â–ˆ      101    \n*/\n\n//Automatically generated from a sprite sheet.\nint ch_sp = 0;\nint ch_a = 712557;\nint ch_b = 1760622;\nint ch_c = 706858;\nint ch_d = 1760110;\nint ch_e = 2018607;\nint ch_f = 2018596;\nint ch_g = 706922;\nint ch_h = 1498989;\nint ch_i = 1909911;\nint ch_j = 1872746;\nint ch_k = 1498477;\nint ch_l = 1198375;\nint ch_m = 1571693;\nint ch_n = 1760109;\nint ch_o = 711530;\nint ch_p = 711972;\nint ch_q = 711675;\nint ch_r = 1760621;\nint ch_s = 2018927;\nint ch_t = 1909906;\nint ch_u = 1497963;\nint ch_v = 1497938;\nint ch_w = 1498109;\nint ch_x = 1496429;\nint ch_y = 1496210;\nint ch_z = 2004271;\nint ch_1 = 730263;\nint ch_2 = 693543;\nint ch_3 = 693354;\nint ch_4 = 1496649;\nint ch_5 = 1985614;\nint ch_6 = 707946;\nint ch_7 = 1873042;\nint ch_8 = 709994;\nint ch_9 = 710250;\nint ch_0 = 711530;\nint ch_per = 2;\nint ch_que = 693378;\nint ch_exc = 599170;\nint ch_com = 10;\nint ch_scl = 65556;\nint ch_col = 65552;\nint ch_usc = 7;\nint ch_crs = 11904;\nint ch_dsh = 3584;\nint ch_ast = 21824;\nint ch_fsl = 304292;\nint ch_bsl = 1189001;\nint ch_lpr = 346385;\nint ch_rpr = 1118804;\nint ch_lba = 862355;\nint ch_rpa = 1647254;\n\n\n//Extracts bit b from the given number.\nfloat Extract_bit(int n, ivec2 bitSize, float b)\n{\n\t//return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n    int index = int(floor(b));\n    int size = bitSize.x * bitSize.y;\n    \n    return (n & ((1 << (size - 1)) >> index)) > 0 ? 1.0 : 0.0;\n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat Sprite(int spr, vec2 uv, vec2 bitSize)\n{\n    vec2 charSize = bitSize;\n    uv = 1.0 - uv;\n\tuv *= charSize;\n    uv = floor(uv);\n   \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (charSize.x - uv.x - 1.0) + uv.y * charSize.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,charSize));\n    \n    return bounds ? Extract_bit(spr, ivec2(bitSize), bit) : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat Char(int ch, vec2 uv, vec2 bitSize)\n{\n    float px = Sprite(ch, uv, bitSize);\n    return px;\n}", "buffer_a_code": "// Draw Background : The Rain Of Numbers\n// Created by Ernst\n\nfloat SignTex(int index, vec2 uv)\n{\n    const float border = 0.2;\n \tif (uv.x >= border && uv.x <= 1.0 - border && uv.y >= border && uv.y <= 1.0 - border)\n    {\n \t\tif (index == 0)\n        {\n        \tif (abs(uv.x - 0.5) > 0.2 || abs(uv.y - 0.5) > 0.25)\n            {\n                return 1.0;\n            }\n        }\n        else if (index == 1)\n        {\n            if (abs(uv.x - 0.5) < 0.08)\n            {\n                return 1.0;\n            }\n        }\n    }\n    return 0.0;\n}\n\n\nvec4 DrawBackground(vec2 fragCoord, float randSeed, float sizeScale)\n{\n    vec4 col = vec4(0);\n    vec2 curSignSize = vec2(SIGN_WIDTH * sizeScale, SIGN_HEIGHT * sizeScale);\n    \n    vec2 curFragCoord = fragCoord;\n    vec2 originIndex = vec2(floor(curFragCoord.x / curSignSize.x), floor(curFragCoord.y / curSignSize.y));\n\n    vec2 newIndex = originIndex;\n    //Rand A Speed\n    float rand = Random(vec2(newIndex.x, randSeed), RANDOM_SEED) ;\n    curFragCoord.y += SPEED * TIME * (rand + 0.3);\n\n    //Rand Zero Or One\n    newIndex.y = floor(curFragCoord.y / (curSignSize.y));\n    float signRand = Random(vec2(newIndex.y,newIndex.x), RANDOM_SEED);\n    \n    vec2 uv = (curFragCoord - newIndex * curSignSize) / curSignSize;\n\n    //Rand The Length\n    int screenHeightCount = int(curFragCoord.y / SCREEN_HEIGHT);\n    float relativeY = curFragCoord.y - float(screenHeightCount) * SCREEN_HEIGHT;\n    float signLength = SCREEN_HEIGHT * (rand + 0.1);\n    if (relativeY < signLength)\n    {\n        float change = (1.0 - relativeY / signLength);\n        float res = SignTex(int(signRand * 10.0) % 2, uv);\n        col.g = res * change * pow((change + 0.2), 2.0);\n        if (res > 0.0)\n        {\n            float whiteColor = abs(sin(_Time.y * rand)) * pow(change, 4.0);\n            col.rb = vec2(whiteColor);\n        }\n    }\n\n    return col * float(int(originIndex.x) % 2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    //Draw Background\n    vec4 backgroundColor = DrawBackground(fragCoord, 0.0, 0.5) * 0.2;\n    backgroundColor += DrawBackground(fragCoord + vec2(SIGN_WIDTH * 0.9, 0.0), 10.0, 1.5);\n    fragColor = backgroundColor;\n}", "buffer_a_inputs": [], "buffer_b_code": "// GlitchWaveJitter For Background\n// Draw Team Name : MATRIX\n// Draw Company Name : TECH CENTER\n// Created by Ernst\n\n#define _WaveJitterSpeed 0.6\n#define _WaveJitterDuration 1.0\n#define _WaveJitterDensity 0.001\n#define _WaveJitterRGBSplit 0.0\n#define _WaveJitterFading 0.5\n#define _GlitchEllipseData vec4(0.0, 1.0, 0.0, 1.0)\n#define _IsUseGlitchEllipseData 0.0\n#define _UseShake 1.0\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 ivec2(UI0, UI1)\n#define UI3 ivec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\n#define SS(a, b, x) (smoothstep(a, b, x) * smoothstep(b, a, x))\n\nfloat GetEllipseValue(vec2 uv, vec4 ellipseData)\n{\n    vec2 center = vec2(0.5f, 0.5f);\n    vec2 p2c = 2.0 * (uv - center);\n    float distance = length(p2c);\n\n    float insideValue = ellipseData.z;\n    float outsideValue = ellipseData.w;\n    float power = (distance - ellipseData.x) / (ellipseData.y - ellipseData.x);\n    return mix(insideValue, outsideValue, clamp(power, 0.0, 1.0));\n}\n\nfloat RandomNoise(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\nvec3 Hash33(vec3 p)\n{\n    ivec3 q = ivec3(ivec3(p)) * UI3;\n    q = (q.x ^ q.y ^ q.z) * UI3;\n    return -1. + 2. * vec3(q) * UIF;\n}\n\nfloat Gnoise(vec3 x)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    // gradients\n    vec3 ga = Hash33(p + vec3(0., 0., 0.));\n    vec3 gb = Hash33(p + vec3(1., 0., 0.));\n    vec3 gc = Hash33(p + vec3(0., 1., 0.));\n    vec3 gd = Hash33(p + vec3(1., 1., 0.));\n    vec3 ge = Hash33(p + vec3(0., 0., 1.));\n    vec3 gf = Hash33(p + vec3(1., 0., 1.));\n    vec3 gg = Hash33(p + vec3(0., 1., 1.));\n    vec3 gh = Hash33(p + vec3(1., 1., 1.));\n\n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\n    // interpolation\n    float Gnoise = va + u.x * (vb - va) +\n        u.y * (vc - va) +\n        u.z * (ve - va) +\n        u.x * u.y * (va - vb - vc + vd) +\n        u.y * u.z * (va - vc - ve + vg) +\n        u.z * u.x * (va - vb - ve + vf) +\n        u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n\n    return 2. * Gnoise;\n}\n\nvec2 uvR;\nvec2 uvG;\nvec2 uvB;\nvec2 uvDefault;\n\nvec4 CopyScreen(vec2 uv)\n{\n    uvDefault = uvR = uvB = uvG = uv;\n    return vec4(texture(iChannel0, uv).xyz, 1.0);\n}\n\nvec4 GlitchWaveJitter(in vec4 color, in vec2 uv)\n{\n    float time = _Time.y * _WaveJitterSpeed;\n    float distortionAmount = SS(_WaveJitterDuration * 0.001, _WaveJitterDuration * 0.5, mod(time, _WaveJitterDuration));\n\n\tfloat uvy = uvDefault.y * uv.y * _WaveJitterDensity;\n    float distortion = Gnoise(vec3(0.0, uvy * 1.0, time * 500.00)) * (distortionAmount * 3.0 + 0.05);\n    distortion *= Gnoise(vec3(0.0, uvy * 2.0, time * 250.0)) * (distortionAmount * 2.0 + 0.025) * _UseShake;\n    distortion += smoothstep(0.999, 1.0, sin((uvDefault.y + time * 1.6) * 2.)) * 0.02;\n    distortion -= smoothstep(0.999, 1.0, sin((uvDefault.y + time) * 2.0)) * 0.02;\n    distortion += smoothstep(0.999, 1.0, sin((uvDefault.y + time * 1.2) * 2.)) * 0.02;\n    distortion -= smoothstep(0.999, 1.0, sin((uvDefault.y + time) * 0.8)) * 0.02;\n    \n    vec2 uvShift = vec2(distortion, 0);\n\n    uvR += uvShift * (0.5 + _WaveJitterRGBSplit * uvShift * RandomNoise(vec2(5, _Time.x)));\n    uvG += uvShift * (0.5 + _WaveJitterRGBSplit * uvShift * RandomNoise(vec2(7, _Time.x)));\n    uvB += uvShift * (0.5 + _WaveJitterRGBSplit * uvShift * RandomNoise(vec2(13, _Time.x)));\n\n    vec4 colorR = vec4(texture(iChannel0, uvR).xyz, 1.0);\n    vec4 colorG = vec4(texture(iChannel0, uvG).xyz, 1.0);\n    vec4 colorB = vec4(texture(iChannel0, uvB).xyz, 1.0);\n\n    vec4 finalColor = vec4(vec3(colorR.x, colorG.y, colorB.z), 1);\n    float power = mix(_WaveJitterFading, _WaveJitterFading * GetEllipseValue(uv, _GlitchEllipseData), step(0.5, _IsUseGlitchEllipseData));\n\n    finalColor = mix(color, finalColor, power);\n\n    return finalColor;\n}\n\nvec4 DrawTeamName(float charWidth, float splitWidth, vec2 startCoord, vec2 fragCoord)\n{\n\tvec4 col = vec4(0);\n    vec2 charSize = vec2(charWidth + splitWidth, (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y);\n    vec2 uv = (fragCoord - startCoord) / charSize;\n    bool bounds = all(greaterThanEqual(uv, vec2(0)));\n    bounds = bounds && all(lessThan(uv, vec2(6.0, 1.0)));\n    if (bounds)\n    {\n        vec2 printCharSize = CHAR_SIZE;\n        highp int index = int(floor(uv.x));\n        int charCode = 0;\n        if (index == 0)\n        {\n        \t//charCode = ch_m;\n            charCode = 18732593;\n            printCharSize = vec2(5.0, 5.0);\n        }\n        else if (index == 1)\n        {\n        \tcharCode = ch_a;\n        }\n        else if (index == 2)\n        {\n        \tcharCode = ch_t;\n        }\n        else if (index == 3)\n        {\n        \tcharCode = ch_r;\n        }\n        else if (index == 4)\n        {\n        \tcharCode = ch_i;\n        }\n        else if (index == 5)\n        {\n        \tcharCode = ch_x;\n        }\n        uv = fract(uv);\n        uv.x *= 1.0 + splitWidth / charWidth;\n        col += Char(charCode, uv, printCharSize);\n    }\n    return col;\n}\n\nvec4 DrawDate(float charWidth, float splitWidth, vec2 startCoord, vec2 fragCoord)\n{\n\tvec4 col = vec4(0);\n    vec2 charSize = vec2(charWidth + splitWidth, (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y);\n    vec2 uv = (fragCoord - startCoord) / charSize;\n    bool bounds = all(greaterThanEqual(uv, vec2(0)));\n    bounds = bounds && all(lessThan(uv, vec2(8.0, 1.0)));\n    if (bounds)\n    {\n        highp int index = int(floor(uv.x));\n        int charCode = 0;\n        if (index == 0)\n        {\n        \tcharCode = ch_2;\n        }\n        else if (index == 1)\n        {\n        \tcharCode = ch_0;\n        }\n        else if (index == 2)\n        {\n        \tcharCode = ch_1;\n        }\n        else if (index == 3)\n        {\n        \tcharCode = ch_9;\n        }\n        else if (index == 4)\n        {\n        \tcharCode = ch_0;\n        }\n        else if (index == 5)\n        {\n        \tcharCode = ch_9;\n        }\n        else if (index == 6)\n        {\n        \tcharCode = ch_0;\n        }\n        else if (index == 7)\n        {\n        \tcharCode = ch_4;\n        }\n        uv = fract(uv);\n        uv.x *= 1.0 + splitWidth / charWidth;\n        col += Char(charCode, uv, CHAR_SIZE);\n    }\n    return col;\n}\n\nvec4 DrawCompany(float charWidth, float splitWidth, vec2 startCoord, vec2 fragCoord)\n{\n\tvec4 col = vec4(0);\n    vec2 charSize = vec2(charWidth + splitWidth, (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y);\n    vec2 uv = (fragCoord - startCoord) / charSize;\n    bool bounds = all(greaterThanEqual(uv, vec2(0)));\n    bounds = bounds && all(lessThan(uv, vec2(12.0, 1.0)));\n    if (bounds)\n    {\n        highp int index = int(floor(uv.x));\n        int charCode = 0;\n        if (index == 0)\n        {\n        \tcharCode = ch_b;\n        }\n        else if (index == 1)\n        {\n        \tcharCode = ch_y;\n        }\n        else if (index == 2)\n        {\n        \tcharCode = ch_t;\n        }\n        else if (index == 3)\n        {\n        \tcharCode = ch_e;\n        }\n        else if (index == 4)\n        {\n        \tcharCode = ch_d;\n        }\n        else if (index == 5)\n        {\n        \tcharCode = ch_a;\n        }\n        else if (index == 6)\n        {\n        \tcharCode = ch_n;\n        }\n        else if (index == 7)\n        {\n        \tcharCode = ch_c;\n        }\n        else if (index == 8)\n        {\n        \tcharCode = ch_e;\n        }\n\n        uv = fract(uv);\n        uv.x *= 1.0 + splitWidth / charWidth;\n        col += Char(charCode, uv, CHAR_SIZE);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = CopyScreen(uv);\n    color = GlitchWaveJitter(color, uv);   \n    fragColor = color;\n    \n    vec4 backgroundColor = color;\n    vec4 dampingGroundcolor = backgroundColor;\n    const float size = 0.35;\n    if (uv.x < 1.0 - size)\n   \t{\n      float damping = pow(uv.x / (1.0 - size), 12.0);\n      dampingGroundcolor *= damping;\n    }\n    \n    //Draw Team Name : MATRIX\n    float charWidth = SCREEN_WIDTH / 14.0;\n    float charHeight = (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y;\n    float charSplit = charWidth / 6.0;\n    vec4 teamNameColor = DrawTeamName(charWidth, charSplit, vec2(charWidth * 1.5, (SCREEN_HEIGHT - charHeight) / 2.0), fragCoord);\n    \n    //Draw Company Name : BYTEDANCE\n    charWidth = SCREEN_WIDTH / 50.0;\n    charHeight = (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y;\n    charSplit = charWidth / 6.0;\n    vec4 companyColor = DrawCompany(charWidth, charSplit, vec2(SCREEN_WIDTH - charWidth * (13.0), charHeight * 0.8), fragCoord);\n    \n    //Draw Date : 20190904\n    charWidth = SCREEN_WIDTH / 80.0;\n    charHeight = (charWidth / CHAR_SIZE.x) * CHAR_SIZE.y;\n    charSplit = charWidth / 6.0;\n    vec4 dateColor = DrawDate(charWidth, charSplit, vec2(charWidth * 4.0, charHeight * 1.0), fragCoord);\n    dateColor *= vec4(0.1, 0.2, 0.3, 1.0);\n    \n    uv = fragCoord.xy / iResolution.xy;\n\n    fragColor = dampingGroundcolor;\n    fragColor += vec4(0.8, 0.5, 0.1, 1) * teamNameColor * 0.35 + backgroundColor * teamNameColor;\n    fragColor += companyColor;\n    fragColor += dateColor;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Distort Effect\n// Created by Ernst\n\n#define Distortion_Center vec2(0.0, 0.0);\n#define Distortion_Multiplier vec2(1.0, 1.0);\n#define Distortion_Intensity 0.3\n#define Distortion_Scale 0.4\n\nfloat rcp(float value)\n{\n    return 1.0 / value;\n}\n\nvec2 DistortUV(vec2 uv)\n{\n    float amount = 1.6 * max(abs(Distortion_Intensity * 100.0), 1.0);\n    float theta = Deg2Rad * min(160.0, amount);\n    float sigma = 2.0 * tan(theta * 0.5);\n    \n    vec2 DistCenter = 2.0 * Distortion_Center - vec2(1.0, 1.0);\n    vec2 DistAxis = Distortion_Multiplier;\n    float DistTheta = Distortion_Intensity;\n    float DistSigma = sigma;\n    float DistScale = 1.0 / Distortion_Scale;\n    float DistIntensity = Distortion_Intensity * 100.0;\n    \n    uv = (uv - 0.5) * DistScale + 0.5;\n    vec2 ruv = DistAxis * (uv - 0.5 - DistCenter);\n    float ru = length(vec2(ruv));\n\n    if (DistIntensity > 0.0)\n    {\n        float wu = ru * DistTheta;\n        ru = tan(wu) * (rcp(ru * DistSigma));\n        uv = uv + ruv * (ru - 1.0);\n    }\n    else\n    {\n        ru = rcp(ru) * DistTheta * atan(ru * DistSigma);\n        uv = uv + ruv * (ru - 1.0);\n    }\n\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvDistorted = DistortUV(uv);\n    fragColor = vec4(texture(iChannel0, uvDistorted).xyz, 1.0); \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKBRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 52, 52, 81], [83, 83, 111, 111, 807], [809, 809, 866, 866, 903]], "test": "untested"}
{"id": "slGfRD", "name": "background - 4", "author": "mattwood", "description": "extended from - https://www.shadertoy.com/view/ws2fDD", "tags": ["gradient"], "likes": 1, "viewed": 143, "published": 3, "date": "1664148787", "time_retrieved": "2024-07-30T16:29:39.349759", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 6.0 * fragCoord/iResolution.xy;\n    \n    for (int n = 1; n < 5; n++) {\n        float i = float(n);\n        uv += vec2(1.0 / i * sin(i * uv.y + iTime / 10.0 * i * 2.0) + 0.8, 1.0 / i * sin(uv.x + iTime / 10.0 * i) + 1.6);\n    }\n     \n    \n    vec3 color = vec3(1, sin(uv.x + uv.y),1);\n    color *= vec3(0.475,0.678,0.984);\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGfRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 504]], "test": "untested"}
{"id": "7lyBzW", "name": "background - 3", "author": "mattwood", "description": "extended from - https://www.shadertoy.com/view/ws2fDD", "tags": ["gradient"], "likes": 0, "viewed": 145, "published": 3, "date": "1664142986", "time_retrieved": "2024-07-30T16:29:40.192506", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 6.0 * fragCoord/iResolution.xy;\n    \n    for (int n = 1; n <5; n++) {\n        float i = float(n);\n        uv += vec2(1.0 / i * sin(i * uv.y + iTime + 5.0 * i * 2.0) + 0.8, 1.0 / i * sin(uv.x + iTime + 1.0 * i) + 1.6);\n    }\n     \n    \n    vec3 color = vec3(1, sin(uv.x + uv.y),1);\n    color *= vec3(0.416,0.635,1);\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lyBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 497]], "test": "untested"}
{"id": "7tyBzW", "name": "background 2", "author": "mattwood", "description": "https://www.shadertoy.com/view/ws2fDD", "tags": ["gradient", "shader"], "likes": 0, "viewed": 141, "published": 3, "date": "1664142487", "time_retrieved": "2024-07-30T16:29:40.986383", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 6.0 * fragCoord/iResolution.xy;\n    \n    for (int n = 1; n <5; n++) {\n        float i = float(n);\n        uv += vec2(1.0 / i * sin(i * uv.y + iTime + 5.0 * i * 2.0) + 0.8, 1.0 / i * sin(uv.x + iTime + 1.0 * i) + 1.6);\n    }\n     \n    \n    vec3 color = vec3(1, sin(uv.x + uv.y),1);\n    color *= vec3(1,1, 1.0);\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 492]], "test": "untested"}
{"id": "slGBzW", "name": "background - 2", "author": "mattwood", "description": "a test to extend - https://www.shadertoy.com/view/ws2fDD", "tags": ["noise", "water", "gradient", "background", "trippy"], "likes": 2, "viewed": 187, "published": 3, "date": "1664142156", "time_retrieved": "2024-07-30T16:29:41.789237", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 6.0 * fragCoord/iResolution.xy;\n    \n    for (int n = 1; n < 20; n++) {\n        float i = float(n);\n        uv += vec2(1.0 / i * sin(i * uv.y + iTime / 10.0  * i ) + 0.8, 1.0 / i * sin(uv.x + iTime / 10.0 * i) + 1.6);\n    }\n    \n     \n    \n    vec3 color = vec3(cos(uv.x + uv.y),1,1);\n    color *= vec3(.73,.24,.5);\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 498]], "test": "untested"}
{"id": "flyBRD", "name": "shader bike track machine", "author": "yasuo", "description": "shader bike track machine", "tags": ["bike", "cineshader"], "likes": 30, "viewed": 2595, "published": 3, "date": "1664128299", "time_retrieved": "2024-07-30T16:29:42.551199", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define SPEED 200.\n#define ZERO (min(iFrame,0))\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat gear(vec2 p){\n    p.x+=0.2;\n    vec2 prevP = p;\n    p*=Rot(radians(90.));\n    float h = 0.4;\n    float d = abs(sdUnevenCapsule(p-vec2(0.0,-h*0.5),0.05,0.1,h))-0.003;\n\n    p = prevP;\n    p.x -=0.2;\n    float d2 = length(p)-0.075;\n    d = min(d,d2);\n    \n    p*=Rot(radians(iTime*SPEED));\n    p = DF(p,6.0);\n    p -= vec2(0.065);\n    d2 = Tri(p*Rot(radians(45.0)),vec2(0.01),radians(45.));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.x +=0.2;\n    d2 = length(p)-0.028;\n    d = min(d,d2);\n    \n    p*=Rot(radians(iTime*SPEED));\n    p = DF(p,3.0);\n    p -= vec2(0.03);\n    d2 = Tri(p*Rot(radians(45.0)),vec2(0.01),radians(45.));\n    d = min(d,d2);\n    \n    return d;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderX( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinderZ( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat frontFolk(vec3 p){\n    vec3 prevP = p;\n    p.xz*=Rot(radians(90.));\n    p.yz*=Rot(radians(5.));\n    float d = sdLink(p,0.2,0.04,0.01);\n    d = max(-p.y-0.15,d);\n    float d2 = sdCappedCylinder(p-vec3(0,0.3,0),0.01,0.062);\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    d2 = sdCappedCylinderZ(p-vec3(0.013,-0.14,0),0.05,0.013);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat frame(vec3 p){\n    vec3 prevP = p;\n    p.xy*=Rot(radians(45.));\n    float d = sdCappedCylinder(p-vec3(-0.04,0.23,0.),0.01,0.33);\n    p = prevP;\n    \n    p.xy*=Rot(radians(-10.));\n    float d2 = sdCappedCylinder(p-vec3(-0.08,0.22,0.),0.01,0.25);\n    d = min(d,d2);\n    p = prevP;\n    \n    p.xy*=Rot(radians(-7.));\n    d2 = sdCappedCylinderX(p-vec3(0.165,0.41,0.),0.01,0.26);\n    d = min(d,d2);\n    p = prevP;\n    \n    p.z = abs(p.z);\n    p.xz*=Rot(radians(7.5));\n    d2 = sdCappedCylinderX(p-vec3(-0.25,0.0,-0.005),0.01,0.235);\n    d = min(d,d2);\n    p = prevP;\n    \n    p.xz*=Rot(radians(90.));\n    p.yz*=Rot(radians(-40.));\n    p-=vec3(0.0,-0.16,-0.37);\n    d2 = sdLink(p,0.2,0.06,0.01);\n    d2 = max(-p.y-0.15,d2);\n    d = min(d,d2);\n    \n    \n    d2 = sdCappedCylinder(p-vec3(0,0.31,0),0.01,0.055);\n    d = min(d,d2);    \n    \n    p = prevP;\n    d2 = sdCappedCylinderZ(p-vec3(-0.48,0.,0),0.07,0.015);\n    d = min(d,d2);    \n    \n    return d;\n}\n\nfloat tyre(vec3 p, float startDeg){\n    p.xy*=Rot(radians(iTime*(SPEED+100.)+startDeg));\n    vec3 prevP = p;\n    \n    float size = 0.28;\n    \n    float d = sdCappedCylinderZ(p,0.005,size);\n    \n    p.y=abs(p.y);\n    float mask = abs(sdCappedCylinderZ(p,0.1,0.17))-0.03;\n    mask = max(-p.y+0.06,mask);\n    d = max(-mask,d);\n    \n    p = prevP;\n    p.yz*=Rot(radians(90.));\n    float d2 = sdTorus(p,vec2(size,0.01));\n    d = min(d,d2);\n    return d;\n}\n\nfloat sheet(vec3 p){\n    vec3 prevP = p;\n    p.xy*=Rot(radians(-7.));\n    float d = sdBox(p,vec3(0.07,0.001,0.01))-0.02;\n    return d;\n}\n\nfloat handleBar(vec3 p){\n    vec3 prevP = p;\n    p.xy*=Rot(radians(-7.));\n    float d = sdBox(p,vec3(0.04,0.02,0.02));\n    \n    p.z = abs(p.z);\n    p.z-=0.03;\n    float d2 = sdCappedCylinderZ(p-vec3(0.02,0.,0),0.03,0.013);\n    d = min(d,d2);\n    p.yz*=Rot(radians(12.));\n    d2 = sdCappedCylinderZ(p-vec3(0.02,-0.005,0.05),0.03,0.013);\n    d = smin(d,d2,0.008);\n    p.yz*=Rot(radians(-12.));\n    d2 = sdCappedCylinderZ(p-vec3(0.02,0.012,0.11),0.04,0.013);\n    d = smin(d,d2,0.008);   \n    \n    return d;\n}\n\nfloat gearAndPedal(vec3 p){\n    vec3 prevP = p;\n    \n    p.z+=0.04;\n    float d = gear(p.xy);\n    d = max((abs(p.z)-0.01),d);\n    \n    p = prevP;\n    float d2 = sdCappedCylinderZ(p,0.04,0.05);\n    d = min(d,d2);\n    \n    p.xy*=Rot(radians(iTime*SPEED));\n    vec3 pos = (p-vec3(-0.07,0.0,-0.06));\n    d2 = sdBox(pos,vec3(0.07,0.01,0.01));\n    d = min(d,d2);\n    \n    p = prevP;\n    float dist = 0.13;\n    float a = radians(iTime*SPEED);\n    float x = dist*cos(a)+p.x;\n    float y = dist*sin(a)-p.y;\n    pos.x = x;\n    pos.y = y;\n    pos.z = p.z+0.1;\n    d2 =  sdBox(pos,vec3(0.04,0.01,0.03));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.xy*=Rot(radians(iTime*SPEED+180.));\n    pos = (p-vec3(-0.07,0.0,0.05));\n    d2 = sdBox(pos,vec3(0.07,0.01,0.01));\n    d = min(d,d2);\n    \n    p = prevP;\n    dist = 0.13;\n    a = radians(iTime*SPEED+180.);\n    x = dist*cos(a)+p.x;\n    y = dist*sin(a)-p.y;\n    pos.x = x;\n    pos.y = y;\n    pos.z = p.z-0.09;\n    d2 =  sdBox(pos,vec3(0.04,0.01,0.03));\n    d = min(d,d2);\n    \n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    float d = gearAndPedal(p-vec3(-0.08,-0.15,0));\n    \n    float d2 = frontFolk(p-vec3(0.4,0.0,0));\n    d = min(d,d2);\n\n    d2 = tyre(p-vec3(0.41,-0.15,0),45.);\n    d = min(d,d2);\n    \n    d2 = tyre(p-vec3(-0.5,-0.15,0),60.);\n    d = min(d,d2);\n    \n    d2 = frame(p-vec3(0.0,-0.15,0.));\n    d = min(d,d2);\n    \n    d2 = sheet(p-vec3(-0.16,0.32,0.));\n    d = min(d,d2);\n    \n    d2 = handleBar(p-vec3(0.39,0.37,0.));\n    d = min(d,d2);\n    \n    return vec2(d,0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    col = diffuseMaterial(n,rd,p,vec3(1.8));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.35);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-5.0));\n        ro.xz *= Rot(radians(sin(iTime*0.3)*60.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyBRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 619, 662, 662, 762], [764, 824, 886, 886, 1125], [1127, 1127, 1146, 1146, 1798], [1800, 1858, 1910, 1910, 2021], [2023, 2023, 2076, 2076, 2187], [2189, 2189, 2242, 2242, 2353], [2355, 2413, 2446, 2446, 2515], [2517, 2575, 2606, 2606, 2697], [2699, 2757, 2811, 2811, 2917], [2919, 2919, 2943, 2943, 3292], [3294, 3294, 3314, 3314, 4247], [4249, 4249, 4284, 4284, 4699], [4701, 4701, 4721, 4721, 4837], [4839, 4839, 4863, 4863, 5344], [5346, 5346, 5373, 5373, 6372], [6374, 6374, 6396, 6396, 6887], [6889, 6889, 6947, 6947, 7214], [7216, 7216, 7240, 7240, 7441], [7443, 7443, 7485, 7485, 7680], [7682, 7723, 7772, 7772, 8066], [8068, 8068, 8125, 8125, 8746], [8748, 8748, 8807, 8807, 8870], [8872, 8872, 8929, 8929, 9707]], "test": "untested"}
{"id": "ftyBRD", "name": "simple mandelbrot fractal", "author": "9EED", "description": "simple mandelbrot fractal", "tags": ["fractal", "mandelbrot"], "likes": 1, "viewed": 148, "published": 3, "date": "1664128119", "time_retrieved": "2024-07-30T16:29:43.395941", "image_code": "int max_i = 500;\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float z = 5.0;\n    \n    float greater = iResolution.y;\n    if(iResolution.x > iResolution.y) greater = iResolution.x;\n    \n    float initial_real = ( (fragCoord.x / greater) - (iResolution.x/greater)/2.0 ) * z;\n    float initial_img = ( ( fragCoord.y / greater) - (iResolution.y/greater)/2.0 ) * z;\n    \n    float current_real = initial_real;\n    float current_img = initial_img;\n    \n    int i = 1;\n    while(i < max_i){\n        i++;\n        float next_real = (current_real * current_real) - (current_img * current_img);\n        float next_img = current_real * current_img * 2.0;\n        \n        current_real = next_real + initial_real;\n        current_img = next_img + initial_img;\n        \n        if(abs(current_real + current_img) > 10.0){\n            break;\n        }\n    }\n    if(i == max_i){\n        fragColor = vec4( .0, .0, .0, 1.0);\n    } else {\n        float v = float(i)/float(max_i) * 10.0;\n        fragColor = vec4( v, v, v, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftyBRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 179, 179, 1138]], "test": "untested"}
{"id": "7lVBz1", "name": "Shadow Test F", "author": "SnoopethDuckDuck", "description": "\"shadow\": refracts into shape and finds exit point, uses direction vector from first hit and exit point to raymarch away from shape and find \"reflected\" hit. i think.\n\neverything else is just random stuff", "tags": ["f"], "likes": 10, "viewed": 228, "published": 3, "date": "1664109476", "time_retrieved": "2024-07-30T16:29:44.230709", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// RayMarching from TheArtOfCode\n\n// From BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(in vec2 p, in vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nvec3 GetRayOrigin() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = 4.;\n    float a = 0.15 * iTime;\n    vec3 ro = vec3(r * cos(a), 1. + 1. * cos(0.4 * iTime), r * sin(a));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    p.xz *= rot(0.5 * iTime);\n    p.x -= 1.;\n    p.xz *= rot(-1.25 * iTime); \n    float r1 = 0.5;\n    float r2 = 0.2;\n    float td1 = length(p.xy) - r1;\n    float td2 = length(vec2(td1, p.z)) - r2;\n   \n    float sd1 = td2;//sdBox(p - vec3(0,0.25 * cos(iTime),0), vec3(.6,.5,.2)) - 0.1;\n    p.xz *= rot(1.25 * iTime);\n    p.x += 1.;\n    float sd2 = length(p + vec3(1,0.25 * sin(iTime),0)) - 0.5;\n    float d = p.y + 1. - 0.001 * dot(p.xz,p.xz);\n    d = min(d,sd1);\n    d = min(d,sd2);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = GetRayOrigin();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n    \n    vec3 p = ro + rd * d;\n    float IOR = 1.5;\n    if(d<MAX_DIST) {        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        if (p.y > -0.9)\n            r = reflect(rd, n * 50. * exp(-3. * length(p.xz)));\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        vec3 p2 = p + 4. * SURF_DIST * n;\n        vec3 cr = normalize(p - pExit);\n        float d2 = RayMarch(p2, cr, 1.);\n        vec3 p3 = p2 + d2 * cr;\n        vec3 n2 = GetNormal(p3);\n        \n\n        float dif = dot(n, normalize(vec3(.5*cos(iTime),1,.5*sin(iTime))))*.5+.5;\n        float dif2 = dot(n2, normalize(vec3(1,2,3)))*.5+.5;\n        //dif2 = pow(dif2, 5.);\n        col = vec3(1);\n        col *= dif;\n        float k = 0.35;\n       // col *= smoothstep(-k, k, dif2 - 0.8);\n        col *= 0.5 + 0.5 * thc(4., 2. * iTime - 0.5 * length(p.xz) + 50. * abs(dif));//* abs(2. * dif-dif2));\n        col *= exp(-0.5 * length(p));\n        col *= 2. * dif2;\n        float fres = pow(1. + dot(rd, n), 5.);\n        float fres2 = pow(1. + dot(rd, nExit), 4.);\n        float fog = 1.-exp(-length(p));\n\n        float spec = pow(dif, 15.);\n        float csh = 1. / cosh(0.2 * length(p.xz));\n        col = clamp(col, 0., 1.);\n        col = mix(col, vec3(abs(r)) * csh, fres);\n        if (p.y < -0.9) {\n            float tns = 1.;\n            col += 0.6 * thc(4., iTime + 6. * log(length(p.xz))) * csh;\n        }\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 207, 207, 283], [285, 285, 323, 323, 388], [390, 390, 409, 409, 492], [494, 494, 523, 523, 604], [606, 606, 640, 640, 716], [718, 718, 739, 739, 980], [982, 982, 1005, 1005, 1505], [1507, 1507, 1550, 1550, 1857], [1859, 1859, 1883, 1883, 2073], [2075, 2075, 2125, 2125, 2316], [2318, 2318, 2375, 2375, 4258]], "test": "untested"}
{"id": "styBR1", "name": "RT in One Weekend: Next", "author": "piyushslayer", "description": "Finally decided to give Ray Tracing In One Weekend book (Peter Shirley) a try. This shader performs the final render from Ch. 13 (Where Next?). Drag the mouse to rotate camera. ", "tags": ["raytracing", "ray", "illumination", "tracing", "diffuse", "montecarlo", "hash", "weekendmglobal"], "likes": 10, "viewed": 676, "published": 3, "date": "1664102779", "time_retrieved": "2024-07-30T16:29:45.427509", "image_code": "/**\n* Finally decided to give Ray Tracing In One Weekend (Peter Shirley) a try.\n* http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\n*\n* This shader performs the final render from Chapter 13 of the book. \n*\n* Most of the ray tracer logic lies in the common tab with some initialization and input handling\n* in Buffer A. Buffer B stores last frame's mouse location. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 outColor = textureLod(iChannel0, uv, 0.0);\n    fragColor = vec4(pow(outColor.xyz, vec3(1.0 / 2.2)), 1.0);\n    if (fragCoord.y < 1.0) fragColor = vec4(0.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI         3.1415926535\n#define TWO_PI     6.2831853071\n#define BIG_EPS    1e-3\n#define SMOL_EPS   1e-8\n\n#define Saturate(x) clamp(x, 0.0, 1.0)\n\n#define M_LAMBERTIAN 0\n#define M_METAL 1\n#define M_DIELECTRIC 2\n\nconst float cameraNear = BIG_EPS;\nconst float cameraFar  = 65535.0;\n\nstruct Camera\n{\n    vec3 origin, forward, left, up, lowerLeftCorner, horizontal, vertical;\n    float lensRadius;\n};\n\nstruct Ray\n{\n    vec3 origin, direction;\n};\n\nstruct Material\n{\n    int type;\n    vec3 albedo;\n    float extraParam; // This can be fuzz for metals, or IOR for dielectrics (nothing for lambert)\n};\n\nstruct HitResult\n{\n    float t;\n    vec3 position, normal;\n    Material material;\n    bool frontFace;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material material;\n};\n\n// Quality hashes collection by nimitz https://www.shadertoy.com/view/Xt3cDn\nfloat hashSeed = 0.0;\n\nuint BaseHash(uvec2 p) {\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y >> 3U));\n    return h32 ^ (h32 >> 16);\n}\n\nfloat Hash1(inout float seed)\n{\n    uint n = BaseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n\nvec2 Hash2(inout float seed) {\n    uint n = BaseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec2 rz = uvec2(n, n * 48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 Hash3(inout float seed) {\n    uint n = BaseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec2 RandomPointInUnitDisk(inout float seed)\n{\n    vec2 h = Hash2(seed) * vec2(1.0, TWO_PI);\n    return h.x * vec2(cos(h.y), sin(h.y));\n}\n\n// Source: Karthik Karanth's blog: \n// https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\nvec3 RandomPointInUnitSphere(inout float seed) {\n    vec3 h = Hash3(seed) * vec3(TWO_PI, 2.0, 1.0) - vec3(0.0, 1.0, 0.0);\n    float theta = h.x;\n    float sinPhi = sqrt(1.0 - h.y * h.y);\n    float r = pow(h.z, 0.3333333334);\n    \n    return r * vec3(cos(theta) * sinPhi, sin(theta) * sinPhi, h.y);\n}\n\nvec3 GetIntersectPoint(in Ray ray, in float t)\n{\n    return ray.origin + ray.direction * t;\n}\n\nvec3 GetBackgroundColor(in float y)\n{\n    // Get a nice skyblue-ish gradient background\n    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), y);\n}\n\nvoid FlipNormalAndIOR(in Ray incoming, inout HitResult result)\n{\n    float isFrontFace = float(dot(incoming.direction, result.normal) < 0.0);\n    result.material.extraParam = mix(result.material.extraParam,\n        1.0 / result.material.extraParam, isFrontFace);   \n    result.normal = mix(-result.normal, result.normal, isFrontFace);\n}\n\n// PBRT Book refract: \n// https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission#Refract\nbool RefractPBRT(in vec3 V, in vec3 N, in float etaRatio, inout float cosThetaI, inout vec3 transmitted)\n{\n    transmitted = vec3(SMOL_EPS); // Avoid NaNs\n    \n    cosThetaI = max(0.0, dot(-V, N));\n    float sin2ThetaI = 1.0 - cosThetaI * cosThetaI;\n    float cos2ThetaT = 1.0 - etaRatio * etaRatio * sin2ThetaI;\n    \n    if (cos2ThetaT < 0.0) return false;\n    \n    transmitted = etaRatio * V + (etaRatio * cosThetaI - sqrt(cos2ThetaT)) * N;\n    \n    return true;\n}\n\nfloat SchlickApprox(float cosine, float etaRatio) \n{\n    float r0 = (1.0 - etaRatio) / (1.0 + etaRatio);\n    r0 *= r0;\n    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\n\n// Scatter the incoming ray based on the bxdf\nbool ScatterRay(in Ray incoming, in HitResult hitInfo, inout vec3 attenuation, inout Ray scattered)\n{\n    if (hitInfo.material.type == M_LAMBERTIAN)\n    {\n        scattered = Ray(hitInfo.position, normalize(hitInfo.normal + RandomPointInUnitSphere(hashSeed)));\n        attenuation = hitInfo.material.albedo;\n        return true;\n    }\n    else if(hitInfo.material.type == M_METAL)\n    {\n        scattered = Ray(hitInfo.position, normalize(reflect(incoming.direction, hitInfo.normal) + \n            hitInfo.material.extraParam * RandomPointInUnitSphere(hashSeed)));\n        attenuation = hitInfo.material.albedo;\n        return dot(scattered.direction, hitInfo.normal) > 0.0;\n    }\n    else if (hitInfo.material.type == M_DIELECTRIC)\n    {\n        FlipNormalAndIOR(incoming, hitInfo);\n        vec3 transmitDirection;\n\n        float cosThetaI;\n        bool isRefracted = RefractPBRT(incoming.direction, hitInfo.normal, hitInfo.material.extraParam, \n            cosThetaI, transmitDirection);\n        float shouldReflect = mix(1.0, step(Hash1(hashSeed), SchlickApprox(cosThetaI, \n            hitInfo.material.extraParam)), float(isRefracted));\n        transmitDirection = mix(transmitDirection, reflect(incoming.direction, hitInfo.normal), shouldReflect);\n        \n        scattered = Ray(hitInfo.position, normalize(transmitDirection));\n        \n        attenuation = hitInfo.material.albedo;\n        \n        return true;\n    }\n    \n    return false;\n}\n\nbool IntersectSphere(in Ray ray, in Sphere sphere, inout HitResult result)\n{\n    vec3 oc = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n    float d = b * b - a * c;\n    \n    if (d < 0.0) return false;\n\n    float temp = (-b - sqrt(d)) / a; // Nearest hit\n    \n    if (temp < result.t && temp > cameraNear)\n    {\n        result.t = temp;\n        result.position = GetIntersectPoint(ray, temp);\n        result.normal = (result.position - sphere.center) * 1.0 / sphere.radius;\n        result.material = sphere.material;\n        return true;\n    }\n   \n    return false;\n}\n\n#define GRID_ROW_SIZE 10.0\n\nbool IntersectWorld(in Ray ray, inout HitResult worldResult)\n{\n    HitResult tempResult;\n    tempResult.t = cameraFar;\n    bool worldHit = false;\n    \n    // Floor\n    if (IntersectSphere(ray,\n        Sphere(vec3(0.0, -5000.0, 0.0), 5000.0, Material(M_LAMBERTIAN, vec3(0.5, 0.5, 0.5), 1.0)), tempResult))\n    {\n        worldResult = tempResult;\n        worldHit = true;\n    }\n    \n    // Big Glass\n    if (IntersectSphere(ray,\n        Sphere(vec3(0.0, 1.0, 0.0), 1.0, Material(M_DIELECTRIC, vec3(1.0), 1.5)), tempResult))\n    {\n        worldResult = tempResult;\n        worldHit = true;\n    }\n    \n    // Big Lamber\n    if (IntersectSphere(ray,\n        Sphere(vec3(-4.0, 1.0, 0.0), 1.0, Material(M_LAMBERTIAN, vec3(0.4, 0.2, 0.1), 1.0)), tempResult))\n    {\n        worldResult = tempResult;\n        worldHit = true;\n    }\n    \n    // Big Metal\n    if (IntersectSphere(ray,\n        Sphere(vec3(4.0, 1.0, 0.0), 1.0, Material(M_METAL, vec3(0.7, 0.6, 0.5), 0.0)), tempResult))\n    {\n        worldResult = tempResult;\n        worldHit = true;\n    }\n    \n    vec4 h; // w -> seed\n    vec4 center = vec4(0.0); // w -> material extra param, fuzz for metal and ior for dielectric\n    int randomMaterialType;\n    \n    for (float x = -GRID_ROW_SIZE; x < GRID_ROW_SIZE; ++x)\n    {\n        for(float y = -GRID_ROW_SIZE; y < GRID_ROW_SIZE; ++y)\n        {\n            h.w = x + y * 0.125;\n            h.xyz = Hash3(h.w);\n            center.xyz = vec3(x * 1.1 + 0.9 * h.x, 0.2, y * 1.1 + 0.9 * h.y);\n            randomMaterialType = int(mix(float(M_LAMBERTIAN), float(M_METAL), float(h.z > 0.75)));\n            randomMaterialType = int(mix(float(randomMaterialType), float(M_DIELECTRIC), float(h.z > 0.9)));\n            \n            if (length(center.xyz - vec3(4.0, 0.2, 0.0)) > 0.9 &&\n                length(center.xyz) > 0.9 &&\n                length(center.xyz - vec3(-4.0, 0.2, 0.0)) > 0.9)\n            {\n                center.w = mix(0.25, 1.5, float(randomMaterialType == M_DIELECTRIC));\n                center.w = mix(center.w, h.z * 0.25, float(randomMaterialType == M_METAL));\n                h.xyz = mix(h.xyz * h.xyz, sqrt(h.xyz), float(randomMaterialType == M_DIELECTRIC));\n\n                if (IntersectSphere(ray,\n                    Sphere(center.xyz, 0.2, Material(randomMaterialType, h.xyz, center.w)), tempResult))\n                {\n                    worldResult = tempResult;\n                    worldHit = true;\n                }\n            }\n        }\n    }\n    \n    return worldHit;\n}\n\n#define MAX_BOUNCES 4\n\nvec3 GetSceneColor(in Ray ray)\n{\n    HitResult worldResult;\n    vec3 sceneColor = vec3(1.0);\n    \n    for (int i = 0; i < MAX_BOUNCES; ++i)\n    {\n        if (IntersectWorld(ray, worldResult))\n        {\n            Ray scattered; \n            vec3 attenuation;\n            if (ScatterRay(ray, worldResult, attenuation, scattered))\n            {\n                sceneColor *= attenuation;\n                ray = scattered;\n            }\n            else\n            {\n                break;\n            }\n        }\n        else\n        {\n            return sceneColor * GetBackgroundColor(ray.direction.y * 0.5 + 0.5);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\nRay GetCameraRay(in Camera camera, in vec2 uv)\n{\n    vec2 randomInDisk = camera.lensRadius * RandomPointInUnitDisk(hashSeed);\n    vec3 offset = camera.left * randomInDisk.x + camera.up * randomInDisk.y;\n    return Ray(camera.origin + offset, normalize(camera.lowerLeftCorner + uv.x * camera.horizontal \\\n        + uv.y * camera.vertical - camera.origin - offset));\n}\n\nCamera GetCamera(in vec3 eye, in vec3 lookAt, in vec3 up, in vec2 camRot, in float fov, in float aspect, in float aperture)\n{\n    Camera camera;\n    \n    float theta = fov * PI * 0.0055555556; // 1.0 / 180.0\n    float h = tan(theta * 0.5);\n    float viewportHeight = 2.0 * h;\n    float viewportWidth = aspect * viewportHeight;\n\n    // Handle camera mouse rotation\n    vec3 eyeToFocus = eye - lookAt;\n    float eyeToFocusDistance = length(eyeToFocus);\n    \n    // Translate toward anchor point\n    eye -= lookAt;\n    \n    // Rotate using spherical coords\n    camRot.x = camRot.x * PI * 2.0;\n    camRot.y = mix(PI * 0.02, PI * 0.48, camRot.y);\n    \n    eye.x = eyeToFocusDistance * sin(camRot.x) * sin(camRot.y);\n    eye.y = eyeToFocusDistance * cos(camRot.y);\n    eye.z = eyeToFocusDistance * cos(camRot.x) * sin(camRot.y);\n    \n    // Translate rotated position back\n    eye += lookAt;\n    \n    // Construct orthonormal basis\n    camera.forward = normalize(eye - lookAt);\n    camera.left = normalize(cross(up, camera.forward));\n    camera.up = cross(camera.forward, camera.left);\n\n    // Set up camera\n    camera.origin = eye;\n    camera.horizontal = eyeToFocusDistance * viewportWidth * camera.left;\n    camera.vertical = eyeToFocusDistance * viewportHeight * camera.up;\n    camera.lowerLeftCorner = camera.origin - camera.horizontal * 0.5 \\\n        - camera.vertical * 0.5 - eyeToFocusDistance * camera.forward;\n        \n    camera.lensRadius = aperture * 0.5;\n    \n    return camera;\n}", "buffer_a_code": "/**\n* Buffer A initializes stuff for ray tracing (camera, rays, input handling etc) and initiates\n* the ray tracing process. At the end, it accumulates the ray traced result with the previously\n* accumulated history buffer. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    hashSeed = float(BaseHash(floatBitsToUint(fragCoord))) / float(0xffffffffU) + iTime;\n    \n    //vec2 uv = (2.0 * (floor(fragCoord) + Hash2(hashSeed)) - iResolution.xy) / iResolution.y;\n    vec2 uv = (floor(fragCoord) + Hash2(hashSeed)) / iResolution.xy;\n    \n    vec4 currentMouse = iMouse / iResolution.xyxy;\n    vec4 previousMouse = texelFetch(iChannel1, ivec2(fragCoord), 0); // last frame mouse coords\n    vec2 cameraRotationUVSpace = texelFetch(iChannel0, ivec2(0), 0).xy;\n    \n    vec4 historyColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float sampleCount = historyColor.w;\n    \n    // Add mouse drag velocity to camera so it only moves from its current position\n    if (currentMouse.z > 0.0 && previousMouse.z > 0.0)\n    {\n        cameraRotationUVSpace += currentMouse.xy - previousMouse.xy;\n        cameraRotationUVSpace.y = Saturate(cameraRotationUVSpace.y);\n        \n        // Reset history on mouse click\n        sampleCount = 1.0;\n        historyColor.xyz = vec3(0.0);\n    }\n    \n    // Reset history on resolution change\n    if (texelFetch(iChannel0, ivec2(0), 0).z != iResolution.x)\n    {\n        sampleCount = 1.0;\n        historyColor.xyz = vec3(0.0);\n    }\n    \n    vec3 outColor = vec3(0.);\n    \n    if (iFrame == 0) // Initial camera position\n    {\n        cameraRotationUVSpace = vec2(0.21, 0.95);\n        sampleCount = 1.0;\n    } \n    \n    outColor = GetSceneColor(\n        GetCameraRay(\n            GetCamera(vec3(13.0, 2.0, 3.0),\n                      vec3(0.0),\n                      vec3(0.0, 1.0, 0.0),\n                      cameraRotationUVSpace,\n                      30.0, iResolution.x / iResolution.y, 0.16), uv));\n    \n    outColor = mix(historyColor.xyz, outColor, 1.0 / sampleCount++);\n    \n    // Save the cameraPosition at [0, 0] coordinate of this buffer\n    if (all(lessThan(fragCoord, vec2(1.0))))\n    {\n        outColor = vec3(cameraRotationUVSpace, iResolution.x);\n    }\n    \n    fragColor = vec4(outColor, sampleCount);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/**\n* Buffer B just saves the current frame's mouse position for it to be used in the next frame.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = iMouse / iResolution.xyxy;\n    fragColor = mouse;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[390, 390, 447, 447, 656]], "test": "untested"}
{"id": "slVBRh", "name": "Amoeba Leopard", "author": "leon", "description": "deep sea vision", "tags": ["feedback"], "likes": 24, "viewed": 608, "published": 3, "date": "1664096966", "time_retrieved": "2024-07-30T16:29:46.308154", "image_code": "\n// Amoeba Leopard\n\n// i was playing with Conway's game of life cellular automaton\n// thinking i had an intuition for a smooth fading version\n// with a lifetime gradient and a neighbor ratio\n\n// found by accident that it can make reaction diffusion patterns\n// got overwhelmed but couldn't posted another turing pattern feedback\n// so i went a bit too far and now it's weird enough as i like it\n\n// iteration from Wasp Blanket https://www.shadertoy.com/view/NlVBz1\n// and Platic Cream https://www.shadertoy.com/view/stKBRh\n\n#define T(uv) abs(texture(iChannel0,uv).b)\n#define N(v) normalize(v)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 frame = texture(iChannel0, uv);\n    \n    // tint\n    vec3 tint = .5 + .5 * cos(vec3(1,2,3)*5. + frame.a*.4);\n    fragColor = vec4(tint * frame.r, 1);\n    \n    \n    // normal\n    float height = 1.;\n    vec3 unit = vec3(4./iResolution.xy, 0);\n    vec3 normal = normalize(vec3(T(uv+unit.xz)-T(uv-unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 T(uv) * height));\n                                 \n    // light\n    fragColor += vec4(.5) * clamp(dot(normal, N(vec3(-1,4,1))), 0., 1.);\n    fragColor += frame.g * vec4(.5) * (1.-pow(clamp(dot(normal, N(vec3(0,0,2))), 0., 1.), 100.));\n    \n    // shadows\n    fragColor -= vec4(0.5) * clamp(dot(normal, N(vec3(0,-4,1))), 0., 1.);\n    fragColor *= pow(max(abs(frame.b)-.02,.0), .5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float speed = 0.5;\nconst float turbulences = 1.5;\nconst float attraction = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 1)\n    {\n        fragColor = vec4(hash23(vec3(fragCoord, 0.)), 0, 0);\n        return;\n    }\n\n    // coordinates\n    vec2 uv = fragCoord/R;\n    vec2 mouse = (iMouse.xy - R.xy / 2.)/R.y;\n    vec2 p = (fragCoord.xy - R.xy / 2.)/R.y;\n    vec2 offset = vec2(0);\n    float dist = length(p);\n    \n    vec4 buffer = texture(iChannel0, uv);\n    \n    // turbulences\n    float noise = fbm(vec3(p, dist - iTime*.05*speed));\n    noise = sin(noise * 6.28 + iTime * .05*speed);\n    noise = pow(max(0., noise+.9), 0.5);\n    \n    // slide along normal\n    vec2 normal = texture(iChannel1, uv).xy;\n    normal.x *= -1.;\n    offset += normal;\n    \n    float dt = 30. * iTimeDelta;\n    \n    // displace frame buffer\n    vec4 frame = texture(iChannel0, uv + dt * offset * speed / R);\n    \n    // edge spawn\n    bool spawn = fragCoord.x < 1. || fragCoord.x > R.x-1.\n              || fragCoord.y < 1. || fragCoord.y > R.y-1.\n              || noise < .1\n              || (iMouse.z > .0 && length(p-mouse) < 50./R.y);\n    \n    // spawn from noise\n    vec2 rng = hash23(vec3(fragCoord, iFrame));\n    if (spawn) frame = vec4(step(0.5, rng.x),step(0.5, rng.y),0,0);\n    \n    // neighbor values\n    vec2 neighbors = vec2(0);\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for (float y = -1.; y <= 1.; ++y)\n        {\n            if (x == 0. && y == 0.) continue;\n            neighbors += texture(iChannel0, uv+vec2(x,y)/R).rg;\n        }\n    }\n    \n    // animation fade\n    frame.r += 2.0 * (neighbors.r > 4.0 ? 1. : -1.) * iTimeDelta;\n    frame.g += 1.0 * (neighbors.g > 4.0 ? 1. : -1.) * iTimeDelta;\n    \n    fragColor = vec4(clamp(frame.rg, 0., 1.), noise, frame.a + (neighbors.r + neighbors.g) * iTimeDelta * .1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}\n\nfloat fbm (vec3 seed)\n{\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 4; ++i) {\n        seed += result * .5;\n        result += gyroid(seed/a)*a;\n        a /= 2.;\n    }\n    return result;\n}", "buffer_b_code": "\n#define T(uv) abs(texture(iChannel0,uv).b)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // normal\n    float height = 1.;\n    vec3 unit = vec3(50./iResolution.xy, 0);\n    vec3 normal = normalize(vec3(T(uv+unit.xz)-T(uv-unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 T(uv) * height));\n                                 \n    fragColor = vec4(normal, 1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[594, 594, 651, 651, 1482]], "test": "untested"}
{"id": "stKBRh", "name": "Plastic Cream", "author": "leon", "description": "melting screen one pixel at a time", "tags": ["feedback"], "likes": 76, "viewed": 1237, "published": 3, "date": "1664096960", "time_retrieved": "2024-07-30T16:29:47.116992", "image_code": "\n// Plastic Cream\n\n// i was playing with Conway's game of life cellular automaton\n// thinking i had an intuition for a smooth fading version\n// with a lifetime gradient and a neighbor ratio\n\n// found by accident that it can make reaction diffusion patterns\n// got overwhelmed but couldn't posted another turing pattern feedback\n// so i went a bit too far and now it's weird enough as i like it\n\n// iteration from Wasp Blanket https://www.shadertoy.com/view/NlVBz1\n\n#define T(uv) abs(texture(iChannel0,uv).b)\n#define N(v) normalize(v)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 frame = texture(iChannel0, uv);\n    \n    // tints\n    vec3 tint = .5 + .5 * cos(vec3(1,2,3)*5. + length(uv-.5)*3.);\n    fragColor = vec4(frame.r * tint, 1);\n    tint = .5 + .5 * cos(vec3(1,2,3)*5. + length(uv-.5)*2. + 3.);\n    fragColor.rgb += frame.g * tint;\n    \n    // normal\n    float height = 1.;\n    vec3 unit = vec3(20./iResolution.xy, 0);\n    vec3 normal = normalize(vec3(T(uv+unit.xz)-T(uv-unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 T(uv) * height));\n    \n    // light\n    fragColor += vec4(.5) * clamp(dot(normal, N(vec3(-1,4,1))), 0., 1.);\n    fragColor += vec4(.5) * pow(clamp(dot(normal, N(vec3(-1,1,2))), 0., 1.), 20.);\n    \n    // shadows\n    fragColor -= vec4(0.5) * clamp(dot(normal, N(vec3(0,-4,1))), 0., 1.);\n    fragColor *= pow(max(abs(frame.b)-.02,.0), .5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float speed = 1.;\nconst float turbulences = 1.;\nconst float attraction = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 1)\n    {\n        fragColor = vec4(hash23(vec3(fragCoord, 0.)), 0, 0);\n        return;\n    }\n\n    // coordinates\n    vec2 uv = fragCoord/R;\n    vec2 mouse = (iMouse.xy - R.xy / 2.)/R.y;\n    vec2 p = (fragCoord.xy - R.xy / 2.)/R.y;\n    vec2 offset = vec2(0);\n    float dist = length(p);\n    \n    // turbulences\n    float noise = fbm(vec3(p * 3., dist-iTime*.1*speed));\n    noise = pow(abs(noise), 0.5);\n    float angle = noise * 6.28;\n    offset += turbulences * vec2(cos(angle), sin(angle));\n\n    // attraction\n    offset += attraction * normalize(p) * sin(dist * 9. + iTime);\n    \n    float dt = 30. * iTimeDelta;\n    \n    // displace frame buffer\n    vec4 frame = texture(iChannel0, uv + dt * offset * speed / R);\n    \n    // edge spawn\n    bool spawn = fragCoord.x < 1. || fragCoord.x > R.x-1.\n              || fragCoord.y < 1. || fragCoord.y > R.y-1.\n              || (iMouse.z > .0 && length(p-mouse) < 50./R.y);\n    \n    // spawn from noise\n    vec2 rng = hash23(vec3(fragCoord, iFrame));\n    if (spawn) frame = vec4(step(0.5, rng.x),step(0.5, rng.y),0,0);\n    \n    // neighbor values\n    vec2 neighbors = vec2(0);\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for (float y = -1.; y <= 1.; ++y)\n        {\n            if (x == 0. && y == 0.) continue;\n            neighbors += texture(iChannel0, uv+vec2(x,y)/R).rg;\n        }\n    }\n    \n    // animation fade\n    frame.r += 4.0 * (neighbors.r > 4.0 ? 1. : -1.) * iTimeDelta;\n    frame.g += 4.0 * (neighbors.g > 4.0 ? 1. : -1.) * iTimeDelta;\n    \n    fragColor = vec4(clamp(frame.rg, 0., 1.), noise, 1.);//, frame.a + (neighbors.r + neighbors.g) * iTimeDelta * .1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}\n\nfloat fbm (vec3 seed)\n{\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 3; ++i) {\n        seed += result / 2.;\n        result += gyroid(seed/a)*a;\n        a /= 2.;\n    }\n    return result;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[535, 535, 592, 592, 1485]], "test": "untested"}
{"id": "NlVBz1", "name": "Wasp Blanket", "author": "leon", "description": "happy accident design", "tags": ["feedback"], "likes": 27, "viewed": 483, "published": 3, "date": "1664096952", "time_retrieved": "2024-07-30T16:29:47.933808", "image_code": "\n// Wasp Blanket\n\n// i was playing with Conway's game of life cellular automaton\n// thinking i had an intuition for a smooth fading version\n// with a lifetime gradient and a neighbor ratio\n\n// found by accident that it can make reaction diffusion patterns\n// got overwhelmed but couldn't posted another turing pattern feedback\n// so i went a bit too far and now it's weird enough as i like it\n\n#define N(v) normalize(v)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 frame = texture(iChannel0, uv);\n    \n    vec3 normal = texture(iChannel1, uv).xyz;\n    \n    // tint\n    vec3 tint = .5 + .5 * cos(vec3(1,2,3)*5. + length(uv-.5)*2.);\n    fragColor = vec4(frame.r * tint, 1);\n    \n    // light\n    fragColor += vec4(0.5+1.*frame.r) * clamp(dot(normal, N(vec3(-1,4,1))), 0., 1.);\n    \n    // shadows\n    fragColor -= vec4(0.5) * clamp(dot(normal, N(vec3(0,-4,1))), 0., 1.);\n    fragColor *= pow(max(abs(frame.b),.0), .5);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nconst float speed = 1.0;\nconst float turbulences = 1.;\nconst float attraction = 2.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R;\n    vec2 mouse = (iMouse.xy - R.xy / 2.)/R.y;\n    vec2 p = (fragCoord.xy - R.xy / 2.)/R.y;\n    vec2 offset = vec2(0);\n    float dist = length(p);\n    \n    // noise\n    float noise = fbm(vec3(p * 4., dist-iTime*.1*speed));\n    \n    // slide along normals\n    vec3 normal = texture(iChannel1, uv).xyz;\n    normal.x *= -1.;\n    offset -= turbulences * normal.xy;\n\n    // attraction\n    offset += attraction * normalize(p) * sin(dist * 9. + iTime);\n    \n    float dt = 30. * iTimeDelta;\n    \n    // displace frame buffer\n    vec4 frame = texture(iChannel0, uv + dt * offset * speed / R);\n    \n    // edge spawn\n    bool spawn = fragCoord.x < 1. || fragCoord.x > R.x-1.\n              || fragCoord.y < 1. || fragCoord.y > R.y-1.\n              || (iMouse.z > .0 && length(p-mouse) < 50./R.y);\n    \n    // spawn from noise\n    float rng = hash13(vec3(fragCoord, iFrame));\n    if (spawn) frame = vec4(step(0.5, rng),0,0,0);\n    \n    // neighbor values\n    float neighbors = 0.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for (float y = -1.; y <= 1.; ++y)\n        {\n            if (x == 0. && y == 0.) continue;\n            neighbors += texture(iChannel0, uv+vec2(x,y)/R).r;\n        }\n    }\n    \n    // animation fade\n    float life = frame.r + 4.0 * (neighbors > 4.0 ? 1. : -1.) * iTimeDelta;\n    \n    fragColor = vec4(clamp(life, 0., 1.), 0., noise, 1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution.xy\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat gyroid (vec3 seed)\n{\n    return dot(sin(seed),cos(seed.yzx));\n}\n\nfloat fbm (vec3 seed)\n{\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 3; ++i) {\n        seed += result * .5;\n        result += gyroid(seed/a)*a;\n        a /= 2.;\n    }\n    return result;\n}", "buffer_b_code": "\n#define T(uv) abs(texture(iChannel0,uv).b)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // normal\n    float height = 2.;\n    vec3 unit = vec3(10./iResolution.xy, 0);\n    vec3 normal = normalize(vec3(T(uv+unit.xz)-T(uv-unit.xz),\n                                 T(uv-unit.zy)-T(uv+unit.zy),\n                                 T(uv) * height));\n                                 \n    fragColor = vec4(normal, 1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[421, 421, 478, 478, 981]], "test": "untested"}
{"id": "slVfzh", "name": "Path with max sum  - buffer 2", "author": "FabriceNeyret2", "description": "Press mouse to see sums.\nvariant of [url] https://shadertoy.com/view/7lKfzh [/url] : following 10 paths ", "tags": ["dynamic", "path", "max", "sum", "finding"], "likes": 11, "viewed": 226, "published": 3, "date": "1664093241", "time_retrieved": "2024-07-30T16:29:48.755611", "image_code": "// variant of https://shadertoy.com/view/7lKfzh\n// inspired by \"Path with max sum\" by Envy24. https://shadertoy.com/view/7lGfz1\n// redone with buffer (and thus progressive )\n\n#define n 10 // number of paths\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    U = floor(N*U/R.y);\n    vec2 P[n];\n    for (int i=0; i<n; i++) P[i][i%2] += float(i*5);\n    O-=O;\n    for (float i = 0.; i < N+N*R.x/R.y -2. ; i++ ) {\n        for (int i=0; i<n; i++) \n            P[i][ T(P[i]+vec2(1,0)).g < T(P[i]+vec2(0,1)).g ? 1 : 0 ] ++,\n            P[i]==U ?  O += .6 + .6 * cos( 6.3*float(i)/float(n) + vec4(0,23,21,0) ) : O;\n      }    \n   if (O!=O-O) return;\n   O = iMouse.z > 0. \n          ? .5+.5*sin(T(U).gggg) // T(U).gggg / (N*length(R)/R.y)\n          : T(U).rrrr;\n          \n// O.b *= float( max(U.x,U.y) < float(iFrame%60) );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 64.;\n\n#define R    iResolution.xy\n#define T(U) texelFetch(iChannel0, ivec2(U), 0 )\n", "buffer_a_code": "// precompute max sum field array ( opposite of distance field )\n// .r = randow value\n// .g = local max sum field\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( U.y > N || U.x > N*R.x/R.y ) return;  // only compute at resolution N\n    \n    U = floor(U);\n    if (iFrame%120 < 1 ) { O*=0.; O.r = fract(1e4*sin(dot(U,R-57.)-iTime)); return; } // init\n    \n    O = T(U);                        // previous state\n    O.g = O.r;\n    \n#if 0                                // purely local computations\n    float l = U.x>0. ? T(U-vec2(1,0)).g : 0., \n          b = U.y>0. ? T(U-vec2(0,1)).g : 0.;\n    O.g += U.x==0. ? b\n         : U.y==0. ? l\n         :           max(l,b);   \n#else                                // boost(?) progression by directly computing borders\n         if (U.x==0.) for (float y=0.; y < U.y; y++ ) O.g += T(U+vec2(0,y)).r;\n    else if (U.y==0.) for (float x=0.; x < U.x; x++ ) O.g += T(U+vec2(x,0)).r;\n    else O.g += max( T(U-vec2(1,0)).g, T(U-vec2(0,1)).g ); // progressively computing the max sum field\n#endif\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 208, 244, 244, 807]], "test": "untested"}
{"id": "7lKfzh", "name": "Path with max sum  - buffer", "author": "FabriceNeyret2", "description": "Press mouse to see sums.\n\nrecoding \"Path with max sum\" by Envy24. [url] https://shadertoy.com/view/7lGfz1 [/url]\nwith buffer (and thus progressive )", "tags": ["dynamic", "path", "max", "sum", "finding"], "likes": 10, "viewed": 202, "published": 3, "date": "1664091460", "time_retrieved": "2024-07-30T16:29:49.568438", "image_code": "// inspired by \"Path with max sum\" by Envy24. https://shadertoy.com/view/7lGfz1\n// redone with buffer (and thus progressive )\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    U = floor(N*U/R.y);\n    vec2 P = vec2(0);\n    for (float i = 0.; i < N+N*R.x/R.y -2. ; i++ )\n    {\n        P[ T(P+vec2(1,0)).g < T(P+vec2(0,1)).g ? 1 : 0 ] ++;\n     // P += T(P+vec2(1,0)).g < T(P+vec2(0,1)).g ? vec2(0,1) : vec2(1,0);\n        if ( P==U ) { O = vec4(0,1,0,1); return; }\n    }    \n\n   O = iMouse.z > 0. \n          ? .5+.5*sin(T(U).gggg) // T(U).gggg / (N*length(R)/R.y)\n          : T(U).rrrr;\n          \n// O.b *= float( max(U.x,U.y) < float(iFrame%60) );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float N = 64.;\n\n#define R    iResolution.xy\n#define T(U) texelFetch(iChannel0, ivec2(U), 0 )\n", "buffer_a_code": "// precompute max sum field array ( opposite of distance field )\n// .r = randow value\n// .g = local max sum field\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( U.y > N || U.x > N*R.x/R.y ) return;  // only compute at resolution N\n    \n    U = floor(U);\n    if (iFrame%120 < 1 ) { O*=0.; O.r = fract(1e4*sin(dot(U,R-57.)-iTime)); return; } // init\n    \n    O = T(U);                        // previous state\n    O.g = O.r;\n    \n#if 0                                // purely local computations\n    float l = U.x>0. ? T(U-vec2(1,0)).g : 0., \n          b = U.y>0. ? T(U-vec2(0,1)).g : 0.;\n    O.g += U.x==0. ? b\n         : U.y==0. ? l\n         :           max(l,b);   \n#else                                // boost(?) progression by directly computing borders\n         if (U.x==0.) for (float y=0.; y < U.y; y++ ) O.g += T(U+vec2(0,y)).r;\n    else if (U.y==0.) for (float x=0.; x < U.x; x++ ) O.g += T(U+vec2(x,0)).r;\n    else O.g += max( T(U-vec2(1,0)).g, T(U-vec2(0,1)).g ); // progressively computing the max sum field\n#endif\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 163, 163, 639]], "test": "untested"}
{"id": "7tKfzh", "name": "Changing Mondrian", "author": "IWBTShyGuy", "description": "Neoplasticism", "tags": ["mondrian"], "likes": 11, "viewed": 233, "published": 3, "date": "1664087825", "time_retrieved": "2024-07-30T16:29:50.332395", "image_code": "// Copyright © 2022 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise12(vec2 p) {\n    vec2 t = fract(p);\n    p = floor(p) + vec2(1.365, -0.593);\n    vec2 e = vec2(0, 1);\n    return mix(\n        mix(hash12(p + e.xx), hash12(p + e.yx), t.x),\n        mix(hash12(p + e.yx), hash12(p + e.yy), t.x),\n        t.y\n    );\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    O = vec4(0.95, 0.95, 0.9, 1);\n    vec2 r = iResolution.xy, m = vec2(0), M = r, p = m, k, l, e = vec2(0, 1);\n    float a;\n    for (int i = 0; i < int(log2(length(r))/1.2); i++) {\n        a = noise12(p + iTime * 0.1);\n        if (a > 0.1 * dot(r, e) / dot(r, e.yx)) e = 1.0 - e;\n        a = 0.35 + 0.3 * hash12(p + r * sign(U - p));\n        p += (m * (1.0 - a) + M * a - p) * e;\n        if (abs(dot(p - U, e)) < 2.0) {\n            O.xyz *= 0.0;\n            return;\n        }\n        k = clamp(sign(U - p), 0.0, 1.0);\n        l = clamp(sign(p - U), 0.0, 1.0);\n        m += (max(k * p, m) - m) * e;\n        M += (min(k * r + l * p, M) - M) * e;\n    }\n    a = noise12(p + sign(U - p) * r + iTime * 0.25);\n    if (0.3 <= a && a < 0.4) O = vec4(0.9, 0, 0.2, 1);\n    else if (0.4 <= a && a < 0.5) O = vec4(0.9, 0.9, 0, 1);\n    else if (0.5 <= a && a < 0.6) O = vec4(0, 0.2, 1, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKfzh.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[78, 137, 159, 159, 276], [278, 278, 301, 301, 534], [536, 536, 575, 575, 1454]], "test": "ok"}
{"id": "NlKfR1", "name": "Slug Fractal", "author": "SnoopethDuckDuck", "description": "its not a slug but idk how to describe this", "tags": ["f"], "likes": 11, "viewed": 248, "published": 3, "date": "1664069235", "time_retrieved": "2024-07-30T16:29:51.170155", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// RayMarching from TheArtOfCode\n\n// From BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(in vec2 p, in vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nvec3 GetRayOrigin() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = 4.;\n    float a = 0.125 * iTime;\n    vec3 ro = vec3(r * cos(a), 0, r * sin(a));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float sd = length(p) - 0.5;\n    for(int j=0; j<16; j++){\n        float io = 2. * pi * float(j) / 16.;\n        vec3 q =normalize(p.yzx);\n        //p.xy *= rot(p.z + 0.25 * iTime);\n        p.xz = abs(p.zx * rot(0.25 * iTime + io) - 0.25 * abs(p.z-p.x))-0.0;\n        p.yz = abs(p.yz * rot(0.25 * iTime + io) + .25 * abs(p.z - p.y))-0.01;\n      // p.y += 0.01;\n      // p.x -= 0.01;\n      // p.z -= 0.01;\n    }\n    return max(sd, 0.1 * abs(p.x + p.y + p.z) - 0.01);\n   // return max(0., length(p.yxz)/10. - 0.01);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = GetRayOrigin();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1. + 5. * tanh(0.25 * iTime));\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n    \n    vec3 p = ro + rd * d;\n    float IOR = 1.05;\n    if(d<MAX_DIST) {        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(p))*.5+.5;\n        float dif2 = dot(n, normalize(abs(r-p)))*.5+.5;\n        col = vec3(dif);\n       // col *= clamp(0.25 + p.y, 0., 1.);\n        float fres = pow(1. + dot(rd, n), 4.);\n        float fog = 1.-exp(-length(p));\n\n        float spec = pow(dif, 32.);\n        float spec2 = pow(dif2, 1.);\n        \n        col *= 0.5 + 0.5 * n;\n        col *= pal(n.y * 0.5 + 0.1 * iTime, vec3(0,1,2)/3.);\n        col *= 1. + 0.75 * n.y;\n        \n        \n        col += spec;\n        //col = vec3(spec);\n        col = pal(dif + p.y * 0.5 + 0.5 * iTime, 0.25 * vec3(2,1,1));\n        col += spec;\n        col += p.y -0.0;\n       \n        //col = sqrt(col);\n        float th = .6 + .4 * thc(8., 12. * log(length(p)) - 1.5 * pi * iTime);\n       \n       col *= th *exp(-12. * abs(fract(log(length(p))-1. * iTime)-0.5)) * abs(n.x + n.y + n.z);\n       //col *= exp(-4. * length(p)) * abs(n.y);\n        col *= abs(n.x + n.y + n.z) ;\n    }\n    \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 207, 207, 283], [285, 285, 323, 323, 388], [390, 390, 409, 409, 492], [494, 494, 523, 523, 604], [606, 606, 640, 640, 716], [718, 718, 739, 739, 956], [958, 958, 981, 981, 1497], [1499, 1499, 1542, 1542, 1849], [1851, 1851, 1875, 1875, 2065], [2067, 2067, 2117, 2117, 2308], [2310, 2310, 2367, 2367, 4040]], "test": "untested"}
{"id": "flKfzh", "name": "Windows Terminal Damask Rose", "author": "mrange", "description": "CC0: Windows Terminal Damask Rose\nBeen tinkering creating Windows Terminal shaders\nCreated this as a version of an earlier shader\nThought it turned out decent so sharing\n\nhttps://mrange.github.io/windows-terminal-shader-gallery/", "tags": ["2d", "windows", "terminal"], "likes": 62, "viewed": 952, "published": 3, "date": "1664050647", "time_retrieved": "2024-07-30T16:29:51.986971", "image_code": "// CC0: Windows Terminal Damask Rose\n//  Been tinkering creating Windows Terminal shaders\n//  Created this as a version of an earlier shader\n//  Thought it turned out decent so sharing\n\n// https://mrange.github.io/windows-terminal-shader-gallery/\n\n// Define to use a faster atan implementation\n//  Introduces slight assymmetries that don't look outright terrible at least\n//#define FASTATAN\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define PI_2        (0.5*PI)\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\n#if defined(FASTATAN)\n#define ATAN atan_approx\n#else\n#define ATAN atan\n#endif\n\nconst float hf = 0.015;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Pascal Gilcher, found: https://www.shadertoy.com/view/flSXRV\nfloat atan_approx(float y, float x) {\n  float cosatan2 = x / (abs(x) + abs(y));\n  float t = PI_2 - cosatan2 * PI_2;\n  return y < 0.0 ? -t : t;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat height(vec2 p) {\n//  float tm = TIME-2.*length(p);\n  float tm = TIME;\n  const float xm = 0.5*0.005123;\n  float ym = mix(0.125, 0.25, 0.5-0.5*cos(TAU*TIME/600.0));\n\n  p *= 0.4;\n  \n  float d = length(p);\n  float c = 1E6;\n  float x = pow(d, 0.1);\n  float y = (ATAN(p.x, p.y)+0.05*tm-2.0*d) / TAU;\n  \n  for (float i = 0.; i < 3.; ++i) {\n    float v = length(fract(vec2(x - tm*i*xm, fract(y + i*ym)*.5)*20.)*2.-1.);\n    c = pmin(c, v, 0.125);\n  }\n\n  float h =  (-hf+hf*(pabs(tanh_approx(5.5*d-80.*c*c*d*d*(.55-d))-0.25*d, 0.25)));\n  return h;\n}\n\nvec3 normal(vec2 p) {\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = -2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 color(vec2 p) {\n  const float ss = 1.25;\n  const float hh = 1.95; \n\n  const vec3 lp1 = -vec3(1.0 , hh, -1.0)*vec3(ss, 1.0, ss);\n  const vec3 lp2 = -vec3(-1.0, hh, -1.0)*vec3(ss, 1.0, ss);\n\n  const vec3 lcol1 = HSV2RGB(vec3(0.30, 0.35, 2.0));\n  const vec3 lcol2 = HSV2RGB(vec3(0.57, 0.6 , 2.0));\n  const vec3 mat   = HSV2RGB(vec3(0.55, 0.9, 0.05));\n  const float spe  = 16.0;\n\n  float h = height(p);\n  vec3  n = normal(p);\n\n  vec3 ro = vec3(0.0, 8.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, 0.0, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n\n  float dm = tanh_approx(abs(h)*120.0);\n  float rm = dm;\n  dm *= dm;\n\n  vec3 lpow1 = dm*mat*lcol1;\n  vec3 lpow2 = dm*mat*lcol2;\n\n  vec3 col = vec3(0.0);\n  col += diff1*diff1*lpow1;\n  col += diff2*diff2*lpow2;\n\n  col += rm*pow(ref1, spe)*lcol1;\n  col += rm*pow(ref2, spe)*lcol2;\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = color(p);\n\n  col = aces_approx(col);\n  col = sRGB(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKfzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[856, 856, 878, 878, 1024], [1319, 1419, 1438, 1438, 1525], [1527, 1634, 1660, 1660, 1844], [1846, 1906, 1934, 1954, 2030], [2032, 2118, 2155, 2155, 2262], [2264, 2364, 2403, 2403, 2488], [2490, 2490, 2520, 2520, 2548], [2550, 2550, 2572, 2606, 3095], [3097, 3097, 3118, 3118, 3305], [3307, 3307, 3327, 3327, 4447], [4449, 4449, 4506, 4506, 4707]], "test": "untested"}
{"id": "ftKBRh", "name": "toroidal gears 3", "author": "FabriceNeyret2", "description": "variant of [url] https://shadertoy.com/view/7lKfzR [/url]\nmouse controls camera", "tags": ["raymarching", "banding", "short"], "likes": 25, "viewed": 284, "published": 3, "date": "1664040312", "time_retrieved": "2024-07-30T16:29:52.793815", "image_code": "// variant of https://shadertoy.com/view/slyBR1\n// variant of https://shadertoy.com/view/7lKfzR\n\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))                      // rotation \n#define d(q,n,t,s)  .04* sin( n *atan(q.z,q.x)+ t* 10.*iTime + s )    // dents\n#define T(T,s)      t = min(t, max( max( length(r)-1., .9-length(r)) ,  max( r.y, -r.y + d(r,32.,T,s)) -.05 )) // ring\n//#define T(T,s)      t = min(t, max( max( length(r)-1., .9-length(r)) ,  abs(r.y) + d(r,32.,T,s) -.05 ))      // variant\n#define g(T,s) t = min(t, max( max( length(r.yz)-.38 -d(r.yxz,12.,T,s) , .3 - length(r.yz) ), abs(r.x+.95) -.03 ) ) // satellite gear     \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,T, s=1.57;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q,r,                           // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n    p += sqrt(R.y/18.) * texelFetch(iChannel0,ivec2(U)%1024,0).x * D; // jitter against pseudo-shading banding\n          \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p, // t = 9.,\n        q.yz *= rot(-M.y),                                 // rotations\n        q.xz *= rot(-M.x-1.57), \n        r = q,     r.y = abs(r.y)-1., T( sign(q.y), s),    // rings\n        r = q.yzx, r.y = abs(r.y)-1., T(-sign(q.z),-s),   \n        T = sign(q.x), q.x =  -abs(q.x),\n        r = q, r.y = abs(r.y)-.55,  g( T*sign(q.y), s),    // satellite gears  \n        r = q, r.z = abs(r.z)-.55,  g(-T*sign(q.z),-s),\n\n        p += .5*t*D;                                       // step forward = dist to obj          \n\n   O *= O*O*1.5;                                           // color scheme\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[640, 640, 676, 676, 1816]], "test": "untested"}
{"id": "slGfz1", "name": "2d Raymarching - very simple", "author": "SONENEIS", "description": "something", "tags": ["2d", "3d", "raymarching", "example", "simple", "ray", "marching"], "likes": 15, "viewed": 1138, "published": 3, "date": "1664036283", "time_retrieved": "2024-07-30T16:29:53.666480", "image_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat sdCirc(vec2 p,float r){\n  return length(p) - r;\n}\nfloat sdRect(vec2 p,float s){\n  return max(abs(p.x)-s,abs(p.y)-s);\n}\nfloat sdLine(vec2 p,vec2 p1,vec2 p2,float r){\n  vec2 a1 = p - p1; vec2 a2 = p2 - p1;\n  float h = clamp(dot(a1,a2)/dot(a2,a2),0.0,1.0);\n  return length(a1 - a2*h) - r;\n}\nfloat sdTri(vec2 p,vec2 p0,vec2 p1,vec2 p2){\n  vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n  vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n  vec2 pq0 = v0 - e0*clamp(dot(v0,e0)/dot(e0,e0),0.0,1.0);\n  vec2 pq1 = v1 - e1*clamp(dot(v1,e1)/dot(e1,e1),0.0,1.0);\n  vec2 pq2 = v2 - e2*clamp(dot(v2,e2)/dot(e2,e2),0.0,1.0);\n  float s = e0.x*e2.y - e0.y*e2.x;\n  vec2 f = min(min(\n    vec2(dot(pq0,pq0),s*(v0.x*e0.y-v0.y*e0.x)),\n    vec2(dot(pq1,pq1),s*(v1.x*e1.y-v1.y*e1.x))),\n    vec2(dot(pq2,pq2),s*(v2.x*e2.y-v2.y*e2.x))\n  );\n  return -sqrt(f.x)*sign(f.y);\n}\n\nfloat map(vec2 p){\n  float d = 1.0;\n\n  d = min(d,sdCirc(p - vec2(-0.4,0.6),0.1));\n  d = min(d,sdCirc(p - vec2(0.5,-0.3),0.2));\n\n  d = min(d,sdRect((p - vec2(-0.2,0.1))*rot(-iTime*0.8),0.1));\n  d = min(d,sdRect(p - vec2(0.9,0.5),0.1));\n\n  d = min(d,sdLine(p,vec2(-0.7,-0.2),vec2(-0.7,0.4),0.025));\n  \n  {\n  vec2 a = vec2(0.8,-0.2);\n  vec2 b = vec2(0.6,0.2);\n  vec2 m = (a + b) / 2.0;\n  d = min(d,sdLine((p-m)*rot(iTime*0.9)+m,a,b,0.01));\n  }\n  \n  {\n  vec2 a = vec2(-0.2,-0.5);\n  vec2 b = vec2(-0.3,-0.7);\n  vec2 c = vec2(0.0,-0.6);\n  vec2 m = (a+b+c) / 3.0;\n  vec2 q = (p-m) * rot(iTime) + m;\n  d = min(d,sdTri(q,a,b,c));\n  d = min(d,sdCirc(q - a,0.05));\n  d = min(d,sdCirc(q - b,0.05));\n  d = min(d,sdCirc(q - c,0.05));\n  }\n  \n  return d;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n  vec2 m = (2.0*iMouse.xy - iResolution.xy) / iResolution.y;\n  vec3 col = vec3(0.0);\n\n  uv *= 0.75;\n\n  col = mix(col,vec3(0,0,1),smoothstep(4.0/iResolution.y,0.0,map(uv)));\n  col += sin(200.0*map(uv))*0.2;\n  col = mix(col,vec3(0,1,1),smoothstep(4.0/iResolution.y,0.0,abs(map(uv))));\n  \n  {\n  \tvec2 ro = m;\n  \tvec2 rd = normalize(vec2(1.0)*rot(iTime*0.1));\n  \t\n    float d = 0.0;\n    for(float i=0.0;i<50.0;i++){\n      vec2 p = ro + rd * d;\n      float hit = map(p);\n    \t\n      if(abs(hit) < 0.01 || d > 10.0) break;\n      \n      d += hit;\n    \t\n      col = mix(col,vec3(1),smoothstep(4.0/iResolution.y,0.0,\n        abs(length(uv - p) - abs(hit))\n      ));\n      col = mix(col,vec3(0,1,0),smoothstep(4.0/iResolution.y,0.0,\n        length(uv - p) - 0.01\n      ));\n    }\n    \n    vec2 p = ro + rd * d;\n    \n    col = mix(col,vec3(1,0,0),smoothstep(4.0/iResolution.y,0.0,\n      sdLine(uv,ro,ro+rd*d,0.0025)\n    ));\n  }\n    \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGfz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 80, 80, 106], [107, 107, 136, 136, 175], [176, 176, 221, 221, 344], [345, 345, 389, 389, 898], [900, 900, 918, 918, 1640], [1642, 1642, 1692, 1692, 2710]], "test": "untested"}
{"id": "slyBR1", "name": "toroidal gears 2", "author": "FabriceNeyret2", "description": "variant of [url] https://shadertoy.com/view/7lKfzR [/url]\nmouse controls camera\n\nrotational-symmetry variant of [url]https://shadertoy.com/view/7tKBRz[/url]\n→ faster but longer code.", "tags": ["raymarching", "banding", "short", "reproduction"], "likes": 27, "viewed": 266, "published": 3, "date": "1664029898", "time_retrieved": "2024-07-30T16:29:55.334023", "image_code": "// rotational-symmetry variant of https://shadertoy.com/view/7tKBRz ( 727 )\n// variant of https://shadertoy.com/view/7lKfzR\n\n#define rot(a)     mat2(cos(a+vec4(0,11,33,0)))                      // rotation \n#define R(a)       q.x-=1.2, q.xy*=rot(a), q.x+=1.2                  // out-of-axe rotation\n#define d(q,n,s)   .04* sin( n *atan(q.z,q.x)+ 10.*iTime + s )       // dents\n#define T(s)       t = min(t, max( max( length(q)-1., .9-length(q)) ,  abs(q.y) + d(q,32.,s) -.05 )) // ring\n#define g(s)   t = min(t, max( length(q.yz)-.3 -d(q.yxz,12.,s), abs(q.x+.95) -.03 ) ) // satellite gear     \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,s,a;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q,                             // marching point along ray \n          M = iMouse.z > 0. ? 6.*iMouse.xyz/R -3.\n              :  vec3( 1,.5,0) * cos(.3*iTime + vec3(0,11,0)); \n    p += sqrt(R.y/18.) * texelFetch(iChannel0,ivec2(U)%1024,0).x * D; // jitter against pseudo-shading banding\n          \n    for ( O=vec4(1); O.x > 0. && t > .01; O-=.01 )         // march scene\n        q = p,\n        q.yz *= rot(-M.y),                                 // rotations\n        q.xz *= rot(-M.x-1.57), q.x += 1., \n        q.x-=1.2,\n        a = atan(q.y,q.x),\n        q.xy = -length(q.xy)*cos( mod( a, 6.28/10. ) + vec2(0,-1.57 ) ), // 10-rotational symmetry\n        q.x+=1.2, \n        t=9., s = 1.57 *sign( mod(10.*a/6.28,2.) -1. ),\n                T(-s),                                     // ring + its mirror    \n        R(.63),  T(s),                                            \n        R(-.18), g(s), R(-.3), q.y = -q.y, g(-s),          // satellite gears  \n\n        p += .5*t*D;                                       // step forward = dist to obj          \n\n   O *= O*O*1.5;                                           // color scheme\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[596, 596, 632, 632, 1912]], "test": "untested"}
{"id": "slGBRh", "name": "PlayStation One Tunnel", "author": "SONENEIS", "description": "a PS1 fps gaming style shader", "tags": ["2d", "3d", "tunnel", "game", "retro", "texture", "uv", "deformation", "metal", "neon", "pseudo", "playstation", "crosshair", "32bit"], "likes": 13, "viewed": 533, "published": 3, "date": "1664005934", "time_retrieved": "2024-07-30T16:29:56.111942", "image_code": "#define pi 3.141592\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n  vec2 uv = (2.0 * fragCoord-iResolution.xy) / iResolution.y;\n  vec3 col = vec3(0.0);\n  \n  float sz = 120.0;\n  uv = floor(uv * sz) / sz;\n  \n  float m = sin(iTime*3.0)*0.05;\n  vec2 tp = uv - vec2(sin(iTime*2.0)*0.05,cos(iTime*10.0)*0.025);\n  tp *= mat2(cos(m),-sin(m),sin(m),cos(m));\n  float s = 0.1;\n  float sdf = max(abs(tp.x*2.0),abs(tp.y));\n  vec2 p = vec2(atan(tp.y,tp.x)/pi,1.0/sdf);\n  float fog = clamp(0.5/p.y,0.0,1.0);\n  p.y += iTime;\n  \n  col += textureLod(iChannel1,p,0.0).rgb;\n  if(p.x < 0.65 && p.x > 0.35)\n    col += textureLod(iChannel2,p,0.0).rgb;\n  if(p.x < -0.3 && p.x > -0.7)\n    col += textureLod(iChannel0,p,0.0).rgb;\n\n  col *= fog;\n  \n  {\n  vec2 p = abs(tp);\n  vec2 p1 = vec2(0.0);\n  vec2 p2 = vec2(1.0,2.0);\n  float a = length(p1 - p2);\n  float b = length(p1 - p);\n  float line = length(mix(p1,p2,clamp(b/a,0.0,1.0)) - p);\n  col *= clamp(line*5.0+0.5,0.0,1.0);\n  }\n\n  {\n  vec2 p = tp; p.x = abs(p.x);\n  vec2 p1 = vec2(0.0);\n  vec2 p2 = vec2(1.0,-1.45);\n  float a = length(p1 - p2);\n  float b = length(p1 - p);\n  float line = length(mix(p1,p2,clamp(b/a,0.0,1.0)) - p);\n  col *= clamp(line*5.0+0.5,0.0,1.0);\n  }\n  \n  {\n    vec2 p = abs(uv) * 2.5;\n    p.xy = p.y>p.x ? p.yx : p.xy;\n    float d = length(max(abs(p)-vec2(0.04,0.0),0.0));\n    col += vec3(0,1,0) * (0.015 / d);\n  }\n    \n  col += vec3(0,1,0) * 0.045;\n  col *= 1.0 - length((fragCoord / iResolution.xy) - 0.5);\n  \n  col = floor(col * 32.0) / 32.0;\n    \n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slGBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 74, 74, 1538]], "test": "untested"}
{"id": "7tKBRz", "name": "toroidal gears", "author": "FabriceNeyret2", "description": "variant of [url] https://shadertoy.com/view/7lKfzR [/url]\nmouse controls camera\n\nFaster version here: [url]  https://www.shadertoy.com/view/slyBR1  [/url]", "tags": ["raymarching", "banding", "short", "reproduction"], "likes": 17, "viewed": 244, "published": 3, "date": "1664004791", "time_retrieved": "2024-07-30T16:29:57.244913", "image_code": "// variant of https://shadertoy.com/view/7lKfzR\n\n#define rot(a)     mat2(cos(a+vec4(0,11,33,0)))                      // rotation \n#define R(a)       r.x-=1.2, r.xy*=rot(a), r.x+=1.2                  // out-of-axe rotation\n#define d(r,n,s)   .04* sin( n *atan(r.z,r.x)+ 10.*iTime + s )       // dents\n#define g(s)   t = min(t, max( length(r.yz)-.3 -d(r.yxz,12.,s), abs(r.x+.95) -.03 ) ) // satellite gear     \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,i,s;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q, r,                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5\n              :  vec3( .15,.07,0) * cos(.3*iTime + vec3(0,11,0)); \n    p += sqrt(R.y/18.) * texelFetch(iChannel0,ivec2(U)%1024,0).x * D; // jitter against pseudo-shading banding\n          \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01) {         // march scene\n        q = p,\n        q.yz *= rot(-6.*M.y),                              // rotations\n        q.xz *= rot(-6.*M.x-1.57); q.x += 1.; \n        for (t=9.,s=1.57,i=0.; i++ < 10.; s=-s ) \n            r = q, \n            R(.63*i),                                      // ring         \n            t = min(t, max( max( length(r)-1., .9-length(r)) ,  abs(r.y) + d(r,32.,s) -.05 )),\n            R(-.18), g(s), R(-.3), r.y = -r.y, g(-s);      // satellite gears       \n \n        p += .5*t*D;                                       // step forward = dist to obj          \n   }\n   O *= O * 1.3;                                           // color scheme\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKBRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[411, 411, 447, 447, 1611]], "test": "untested"}
{"id": "slVfzz", "name": "Parametric Surface Renderer", "author": "fad", "description": "This shader uses interval arithmetic to draw parametric surfaces. Keyboard/mouse controls listed in Buffer A.", "tags": ["3d", "interactive", "plotter", "arithmetic", "interval"], "likes": 26, "viewed": 643, "published": 3, "date": "1663964715", "time_retrieved": "2024-07-30T16:29:58.189388", "image_code": "//------------------------Parametric Surface Renderer-------------------------//\n\n// How It Works:\n// This shader raytraces parametric surfaces by recursively subdividing the u-v\n// domain of the surface, using interval arithmetic to calculate bounding boxes\n// for the subdivisions of the surface to test for the possible presence of ray\n// intersections.\n\n// Drawing Domain:\nconst float uMin = 0.0;\nconst float uMax = 2.0 * PI;\nconst float vMin = 0.0;\nconst float vMax = 2.0 * PI;\n\n// Parametric Surface Equation:\n// This function uses interval types (defined in the Common tab).\niVec3 f(iFloat u, iFloat v) {\n    iFloat cosU = iCos(u);\n    iFloat sinU = iSin(u);\n    iFloat cosV = iCos(v);\n    iFloat sinV = iSin(v);\n    \n    // Trefoil Knot\n    // https://commons.wikimedia.org/wiki/File:Parametric_surface_illustration_(trefoil_knot).png\n    float r = 1.5;\n    iFloat a = iAdd(2.0, iCos(iAdd(v, PI * 2.0 / 3.0)));\n    iFloat u2 = iMul(2.0, u);\n    return iVec3(\n        iDiv(iMul(r, iSin(iMul(3.0, u))), iAdd(2.0, cosV)),\n        iDiv(iMul(r, iAdd(sinU, iMul(2.0, iSin(u2)))), a),\n        iMul(iMul(iMul(r / 8.0, iSub(cosU, iMul(2.0, iCos(u2)))), iAdd(2.0, cosV)), a)\n    );\n    \n    // Klein Bottle\n    // https://www.shadertoy.com/view/XttSW8\n    //iFloat r = iSub(2.0, cosU);\n    //return iVec3(\n    //    iMul(0.6, iAdd(iMul(iMul(2.0, iSub(1.0, sinU)), cosU), iMul(iMul(r, cosV), iSub(iMul(2.0, iExp(iNeg(iPow(iSub(iDiv(u, 2.0), PI), 2.0)))), 1.0)))),\n    //    iMul(0.6, iAdd(iMul(6.0, sinU), iMul(iMul(iMul(iMul(0.5, r), sinU), cosV), iExp(iNeg(iPow(iSub(u, 1.5 * PI), 2.0)))))),\n    //    iMul(0.6, iMul(r, sinV))\n    //);\n\n    // Torus\n    //return iVec3(\n    //    iMul(iAdd(2.0, cosU), cosV),\n    //    sinU,\n    //    iMul(iAdd(2.0, cosU), sinV)\n    //);\n    \n    // Sphere\n    //return iVec3(\n    //    iMul(3.0, iMul(sinU, cosV)),\n    //    iMul(3.0, iMul(sinU, sinV)),\n    //    iMul(3.0, cosU)\n    //);\n}\n\n// Resolution:\n// The amount of times to recursively subdivide the u-v domain. \nconst int maxDepth = 16;\n\n// Discontinuity Tolerance:\n// If the bounding box for a leaf surface patch has a side length bigger than or\n// equal to discontinuityTolerance, that surface patch is counted as containing\n// a discontinuity and is not counted as an intersection. It can be set to\n// INFINITY if the surface is known to be continous.\nconst float discontinuityTolerance = 1000.0 * max(vMax - vMin, uMax - uMin) / pow(2.0, float(maxDepth - 1));\n\n// Display Settings:\nconst float fovY = 50.0;\n#define VIGNETTE 1\n#define USE_CUBEMAP_BACKGROUND_FOR_PBR 1\n\n// Rendering Mode:\n#define REGULAR 1\n#define PBR 2\n#define NORMAL_MAP 3\n\n#define RENDERING_MODE PBR\n\n\n\n//============================================================================//\n\n\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\niFloat intersect(Ray r, iVec3 a) {\n    // Basically a ray-AABB intersection test but returns both the min and max\n    // intersection t-values.\n    vec3  t0 = (vec3(a.x.l, a.y.l, a.z.l) - r.o) / r.d;\n    vec3  t1 = (vec3(a.x.u, a.y.u, a.z.u) - r.o) / r.d;\n    float t;\n    \n    if (t0.x > t1.x) {\n        t    = t0.x;\n        t0.x = t1.x;\n        t1.x = t;\n    }\n    \n    if (t0.y > t1.y) {\n        t    = t0.y;\n        t0.y = t1.y;\n        t1.y = t;\n    }\n    \n    if (t0.z > t1.z) {\n        t    = t0.z;\n        t0.z = t1.z;\n        t1.z = t;\n    }\n    \n    float h0 = max(t0.x, max(t0.y, t0.z));\n    float h1 = min(t1.x, min(t1.y, t1.z));\n    \n    if (h0 > h1) {\n        return EMPTY_SET;\n    }\n    \n    return iFloat(h0, h1);\n}\n\n// Main Intersection Function:\n// Performs a depth-first search of the u-v domain treating it as a quadtree,\n// keeping track of the closest intersection found so far and only descending\n// the quadtree if it possibly contains a closer intersection. Every time a leaf\n// patch is reached and there might be an intersection within it, it is counted\n// as an intersection.\nbool intersect(Ray r, out float t, out float u, out float v) {\n    if (maxDepth < 1) {\n        return false;\n    }\n    \n    float uRange = uMax - uMin;\n    float vRange = vMax - vMin;\n    int depth = 0;\n    int uPos = 0;\n    int vPos = 0;\n    t = INFINITY;\n    \n    while (true) {\n        // Calculate the current u-v domain at this location in the quadtree\n        float size = float(1 << depth);\n        iFloat ui = iFloat(uMin + uRange * float(uPos) / size, uMin + uRange * float(uPos + 1) / size);\n        iFloat vi = iFloat(vMin + vRange * float(vPos) / size, vMin + vRange * float(vPos + 1) / size);\n        // Calculate a bounding box for the surface patch\n        iVec3 fi = f(ui, vi);\n        // Intersect the bounding box\n        iFloat ti = intersect(r, fi);\n        \n        // If the ray has intersected the bounding box and currently at a leaf\n        // patch which doesn't contain a discontinuity, check if this\n        // intersection value is closer than the current best intersection and\n        // update it if so.\n        if (depth == maxDepth - 1 && 0.0 < ti.l && ti.u < t\n            && fi.x.u - fi.x.l < discontinuityTolerance\n            && fi.y.u - fi.y.l < discontinuityTolerance\n            && fi.z.u - fi.z.l < discontinuityTolerance) {\n            t = ti.u;\n            u = (ui.l + ui.u) / 2.0;\n            v = (vi.l + vi.u) / 2.0;\n        }\n        \n        // If the ray didn't intersect the patch or currently at a leaf patch,\n        // don't descend the quadtree any further, instead go to the next patch \n        // in the depth-first search and continue on to the next iteration.\n        if (ti.u <= 0.0 || t <= ti.l || depth == maxDepth - 1) {\n            while (uPos % 2 == 1 && vPos % 2 == 1) {\n                --depth;\n                uPos /= 2;\n                vPos /= 2;\n            }\n            \n            if (vPos % 2 == 0) {\n                ++vPos;\n            } else {\n                ++uPos;\n                --vPos;\n            }\n            \n            // Exit the loop if back at root node\n            if (depth == 0 && vPos == 1) {\n                break;\n            }\n            \n            continue;\n        }\n\n        // There is a potential intersection in this surface patch, so descend\n        // and check its children for intersections.\n        ++depth;\n        uPos *= 2;\n        vPos *= 2;\n    }\n    \n    return t != INFINITY;\n}\n\nvec3 normal(float u, float v) {\n    const float e = 1e-3;\n    iVec3 fup = f(ifloat(u + e), ifloat(v));\n    iVec3 fun = f(ifloat(u - e), ifloat(v));\n    iVec3 fvp = f(ifloat(u), ifloat(v + e));\n    iVec3 fvn = f(ifloat(u), ifloat(v - e));\n    \n    return normalize(cross(\n        vec3(fup.x.l - fun.x.l, fup.y.l - fun.y.l, fup.z.l - fun.z.l),\n        vec3(fvp.x.l - fvn.x.l, fvp.y.l - fvn.y.l, fvp.z.l - fvn.z.l)\n    ));\n}\n\nvec3 normal(Ray r, float u, float v) {\n    vec3 n = normal(u, v);\n    return faceforward(n, r.d, n);\n    return n;\n}\n\n\n\n//============================================================================//\n\n// Start of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n\nfloat somestep(float t) {\n    return pow(t,4.0);\n}\n\nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\n// GGX code from https://www.shadertoy.com/view/MlB3DV\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}\n\nvec3 shade(vec3 ray, vec3 normal, vec3 materialColor) {\n    // material\n    float metallic = 0.07;\n    float roughness = 0.1;\n    float fresnel_pow = mix(5.0, 3.5,metallic);\n    vec3 color_mod = vec3(1.0);\n    vec3 light_color = pow(texture(iChannel1,vec3(1.0,0.0,0.0)).xyz * 1.2, vec3(2.2));\n\n\n    // IBL\n    vec3 ibl_diffuse = pow(textureBlured(iChannel1,normal), vec3(2.2));\n    vec3 ibl_reflection = pow(textureBlured(iChannel1,reflect(ray,normal)), vec3(2.2));\n\n    // fresnel\n    float fresnel = max(1.0 - dot(normal,-ray), 0.0);\n    fresnel = pow(fresnel,fresnel_pow);    \n\n    // reflection        \n    vec3 refl = pow(texture(iChannel1,reflect(ray,normal)).xyz, vec3(2.2));\n    refl = mix(refl,ibl_reflection,(1.0-fresnel)*roughness);\n    refl = mix(refl,ibl_reflection,roughness);\n\n    // specular\n    vec3 light = normalize(vec3(-0.5,1.0,0.0));\n    float power = 1.0 / max(roughness * 0.4,0.01);\n    vec3 spec = light_color * GGX(normal,-ray,light,roughness*0.7, 0.2);\n    refl -= spec;\n\n    // diffuse\n    vec3 diff = ibl_diffuse * pow(materialColor, vec3(2.2));\n    diff = mix(diff * color_mod,refl,fresnel);        \n\n    vec3 color = mix(diff,refl * color_mod,metallic) + spec;\n    return pow(color, vec3(1.0/2.2));\n}\n\n// End of modified PBR code from https://www.shadertoy.com/view/XsfXWX\n\n//============================================================================//\n\n\n\nvec3 saturate(vec3 color, float amount) {\n    vec3 gray = vec3(dot(vec3(0.2126,0.7152,0.0722), color));\n    return clamp(mix(gray, color, 1.0 + amount), vec3(0.0), vec3(1.0));\n}\n\nvec3 calculateColor(Ray r) {\n    float t, u, v;\n    \n    if (intersect(r, t, u, v)) {\n        vec3 n = normal(r, u, v);\n        \n#if RENDERING_MODE == REGULAR\n        vec3 lv = normalize(vec3(-1.0, 2.0, -3.0));\n        float ld = dot(lv, n);\n        float l = mix(max(ld, 0.0), mix(0.02, 1.0, ld * 0.5 + 0.5), 0.1);\n        vec3 c = vec3(1.0);\n        return pow(c * l, vec3(1.0 / 2.2));\n#elif RENDERING_MODE == NORMAL_MAP\n        return n * 0.5 + 0.5;\n#elif RENDERING_MODE == PBR\n        return shade(r.d, n, saturate(n * 0.5 + 0.5, 0.7));\n#endif\n    } else {\n#if RENDERING_MODE == REGULAR\n        vec3 lv = normalize(vec3(-1.0, 2.0, -3.0));\n        float ld = dot(lv, r.d);\n        float l = pow(mix(0.4, 1.0, ld * 0.5 + 0.5), 5.0);\n        vec3 c = vec3(0.2);\n        return pow(c * l, vec3(1.0 / 2.0));\n#elif RENDERING_MODE == NORMAL_MAP\n        return vec3(0.2);\n#elif RENDERING_MODE == PBR\n    #if USE_CUBEMAP_BACKGROUND_FOR_PBR\n        return texture(iChannel1, r.d).rgb;\n    #else\n        return vec3(0.2);\n    #endif\n#endif\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Calculate camera configuration from keyboard & mouse input buffer\n    vec2 camRot = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec2 cr = cos(camRot);\n    vec2 sr = sin(camRot);\n    mat3 v2wRotMat = mat3(\n            cr.y,         0.0,  -sr.y,\n            sr.x * sr.y,  cr.x,  cr.y * sr.x,\n            cr.x * sr.y, -sr.x,  cr.x * cr.y);\n    vec4 camPosD = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec3 camPos = camPosD.xyz + v2wRotMat * vec3(0.0, 0.0, 1.0) * camPosD.w; \n    vec2 tanHalfFov = vec2(tan(radians(fovY) * 0.5)); \n    tanHalfFov.x *= iResolution.x / iResolution.y;\n    vec2 cCoord = fragCoord / iResolution.xy * 2.0 - 1.0;\n    vec3 vDir = normalize(vec3(cCoord * tanHalfFov, -1.0));\n    vec3 wDir = v2wRotMat * vDir;\n    Ray r = Ray(camPos, wDir);\n    \n    // Calculate color\n    fragColor = vec4(calculateColor(r), 1.0);\n    \n#if VIGNETTE\n    fragColor.rgb *= 1.0 - 0.8 * pow(distance(vec2(0.5, 0.5), fragCoord / iResolution.xy), 3.0);\n#endif\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//------------------------Interval Arithmetic Library-------------------------//\n\n// Interval Types:\n// These types keep track of a lower and upper bound throughout computation, \n// giving definitive bounds for the end result.\n\nstruct iFloat {\n    float l;\n    float u;\n};\n\nstruct iVec3 {\n    iFloat x;\n    iFloat y;\n    iFloat z;\n};\n\nstruct iBool {\n    bool l;\n    bool u;\n};\n\n// Functions: \n// Most of these functions have the same domains as the native GLSL equivalents. \n// If the arguments are outside of the domain, an empty set is returned. To be \n// correct, these should be propagated like NaNs, however, it slows down the\n// shader a lot and isn't necessary most of the time so propagation is optional.\n// These functions are overloaded so they can be called without having to\n// convert floats to iFloats or bools to iBools when mixing them with non-\n// interval types.\n\n#define PROPAGATE_EMPTY_SETS 0\n\niFloat iAdd(iFloat x, iFloat y);\niFloat iSub(iFloat x, iFloat y);\niFloat iMul(iFloat x, iFloat y);\niFloat iDiv(iFloat x, iFloat y);\n\niFloat iNeg(iFloat x); // -x\niFloat iInv(iFloat x); // 1 / x\n\niFloat iSin(iFloat x);\niFloat iCos(iFloat x);\niFloat iTan(iFloat x);\n\niFloat iAsin(iFloat x);\niFloat iAcos(iFloat x);\niFloat iAtan(iFloat x);\niFloat iAtan(iFloat y, iFloat x); // never undefined\n\niFloat iSinh(iFloat x);\niFloat iCosh(iFloat x);\niFloat iTanh(iFloat x);\n\niFloat iAsinh(iFloat x);\niFloat iAcosh(iFloat x);\niFloat iAtanh(iFloat x);\n\niFloat iExp(iFloat x);\niFloat iExp2(iFloat x);\n\niFloat iLog(iFloat x);\niFloat iLog2(iFloat x);\n                                                                                \niFloat iPow(iFloat x, iFloat y); // defined for x >= 0.0 or when y is an integer\n\niFloat iSqrt(iFloat x);\niFloat iCbrt(iFloat x);\niFloat iSquare(iFloat x);\n\niFloat iSign(iFloat x);\niFloat iAbs(iFloat x);\niFloat iFloor(iFloat x);\niFloat iCeil(iFloat x);\niFloat iRound(iFloat x);\niFloat iTrunc(iFloat x);\niFloat iMod(iFloat x, iFloat y);\niFloat iFract(iFloat x);\n\niFloat iMin(iFloat x, iFloat y);\niFloat iMax(iFloat x, iFloat y);\niFloat iClamp(iFloat x, iFloat minVal, iFloat maxVal);\n\niFloat iMix(iFloat x, iFloat y, iFloat a);\niFloat iSmoothstep(iFloat edge0, iFloat edge1, iFloat x);\niFloat iStep(iFloat edge, iFloat x);\n\niFloat iIf(iBool P, iFloat x, iFloat y); // use this as the ternary operator\n\niBool iEqual(iFloat x, iFloat y);\niBool iGreaterThan(iFloat x, iFloat y);\niBool iGreaterThanEqual(iFloat x, iFloat y);\niBool iLessThan(iFloat x, iFloat y);\niBool iLessThanEqual(iFloat x, iFloat y);\n\niBool iNOT(iBool x);\niBool iAND(iBool x, iBool y);\niBool iOR(iBool x, iBool y);\niBool iXOR(iBool x, iBool y);\n\n// Constructors:\n// Aren't necessary most of the time since the functions are already overloaded.\niFloat ifloat(float x);\niBool ibool(bool x);\n\n// Constants:\nconst float INFINITY = uintBitsToFloat(0x7F800000u);\nconst float PI = 3.14159265;\n\n\n\n//============================================================================//\n\n\n\n// Overloads:\n#define MAKE_OVERLOADSB(fn) iBool fn(bool x,iBool y){return fn(ibool(x),y);}iBool fn(iBool x,bool y){return fn(x,ibool(y));}\n#define MAKE_OVERLOADSBF(fn) iBool fn(float x,iFloat y){return fn(ifloat(x),y);}iBool fn(iFloat x,float y){return fn(x,ifloat(y));}\n#define MAKE_OVERLOADS2(fn) iFloat fn(float x,iFloat y){return fn(ifloat(x),y);}iFloat fn(iFloat x,float y){return fn(x,ifloat(y));}\n#define MAKE_OVERLOADS3(fn) iFloat fn(float x,iFloat y,iFloat z){return fn(ifloat(x),y,z);}iFloat fn(iFloat x,float y,iFloat z){return fn(x,ifloat(y),z);}iFloat fn(iFloat x,iFloat y,float z){return fn(x,y,ifloat(z));}iFloat fn(float x,float y,iFloat z){return fn(ifloat(x),ifloat(y),z);}iFloat fn(float x,iFloat y,float z){return fn(ifloat(x),y,ifloat(z));}iFloat fn(iFloat x,float y,float z){return fn(x,ifloat(y),ifloat(z));}\n\nMAKE_OVERLOADS2(iAdd)\nMAKE_OVERLOADS2(iSub)\nMAKE_OVERLOADS2(iMul)\nMAKE_OVERLOADS2(iDiv)\nMAKE_OVERLOADS2(iPow)\n\nMAKE_OVERLOADS2(iMod)\n\nMAKE_OVERLOADS2(iMin)\nMAKE_OVERLOADS2(iMax)\nMAKE_OVERLOADS3(iClamp)\n\nMAKE_OVERLOADS3(iMix)\nMAKE_OVERLOADS3(iSmoothstep)\nMAKE_OVERLOADS2(iStep)\n\nMAKE_OVERLOADSBF(iEqual)\nMAKE_OVERLOADSBF(iGreaterThan)\nMAKE_OVERLOADSBF(iGreaterThanEqual)\nMAKE_OVERLOADSBF(iLessThan)\nMAKE_OVERLOADSBF(iLessThanEqual)\n\nMAKE_OVERLOADSB(iAND)\nMAKE_OVERLOADSB(iOR)\nMAKE_OVERLOADSB(iXOR)\n\n// Empty Sets:\nconst iFloat EMPTY_SET = iFloat(-INFINITY, -INFINITY);\nconst iBool EMPTY_BSET = iBool(true, false);\n\n#if PROPAGATE_EMPTY_SETS\n    #define CHECK_IF_EMPTY_SET_F(x) if ((x) == EMPTY_SET) return EMPTY_SET\n    #define CHECK_IF_EMPTY_SET_B(x) if ((x) == EMPTY_SET) return EMPTY_BSET\n    #define CHECK_IF_EMPTY_BSET_F(x) if ((x) == EMPTY_BSET) return EMPTY_SET\n    #define CHECK_IF_EMPTY_BSET_B(x) if ((x) == EMPTY_BSET) return EMPTY_BSET\n#else\n    #define CHECK_IF_EMPTY_SET_F(x)\n    #define CHECK_IF_EMPTY_SET_B(x)\n    #define CHECK_IF_EMPTY_BSET_F(x)\n    #define CHECK_IF_EMPTY_BSET_B(x)\n#endif\n\n// Constructors:\niFloat ifloat(float x) {\n    return iFloat(x, x);\n}\n\n\niBool ibool(bool x) {\n    return iBool(x, x);\n}\n\n// Helper Functions:\niFloat iMinMax(float x, float y, float z, float w) {\n    return iFloat(\n        min(x, min(y, min(z, w))),\n        max(x, max(y, max(z, w)))\n    );\n}\n\niBool iMinMax(bool x, bool y, bool z, bool w) {\n    return iBool(\n        x || y || z || w,\n        x && y && z && w\n    );\n}\n\n\n// Function Implementations:\n\niFloat iAdd(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(x.l + y.l, x.u + y.u);\n}\n\niFloat iSub(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(x.l - y.u, x.u - y.l);\n}\n\niFloat iMul(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x); \n    CHECK_IF_EMPTY_SET_F(y);\n    return iMinMax(x.l * y.l, x.l * y.u, x.u * y.l, x.u * y.u);\n}\n\niFloat iDiv(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iMul(x, iInv(y));\n}\n\n\niFloat iNeg(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(-x.u, -x.l);\n}\n\niFloat iInv(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x); \n    \n    if (x.l > 0.0 || x.u < 0.0) {\n        return iFloat(1.0 / x.u, 1.0 / x.l);\n    } else if (x.l < 0.0 && x.u > 0.0) {\n        return iFloat(-INFINITY, INFINITY);\n    } else if (x.u == 0.0) {\n        return iFloat(-INFINITY, 1.0 / x.l);\n    } else {\n        return iFloat(1.0 / x.u, INFINITY);\n    }\n}\n\n\niFloat iSin(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    float u = PI * round(x.l / PI) + PI * 1.5;\n    \n    if (u < x.u) {\n        return iFloat(-1.0, 1.0);\n    }\n    \n    u -= PI;\n    vec2 s = vec2(sin(x.l), sin(x.u));\n    vec2 r = vec2(min(s.x, s.y), max(s.x, s.y));\n    \n    if (u < x.u) {\n        float s = sin(u);\n        return iFloat(min(r.x, s), max(r.y, s));\n    }\n    \n    return iFloat(r.x, r.y);\n}\n\niFloat iCos(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iSin(iAdd(x, ifloat(PI / 2.0)));\n}\n\niFloat iTan(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iDiv(iSin(x), iCos(x));\n}\n\n\niFloat iAsin(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(-PI / 2.0, asin(x.u));\n        }\n        \n        return iFloat(-PI / 2.0, PI / 2.0);\n    }\n    \n    if (x.u < 1.0) {\n        return iFloat(asin(x.l), asin(x.u));\n    }\n    \n    if (x.l < 1.0) {\n        return iFloat(asin(x.l), PI / 2.0);\n    }\n    \n    if (x.l == 1.0) {\n        return ifloat(PI / 2.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iAcos(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(acos(x.u), PI);\n        }\n        \n        return iFloat(0.0, PI);\n    }\n    \n    if (x.u < 1.0) {\n        return iFloat(acos(x.u), acos(x.l));\n    }\n    \n    if (x.l < 1.0) {\n        return iFloat(0.0, acos(x.l));\n    }\n    \n    if (x.l == 1.0) {\n        return ifloat(0.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iAtan(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(atan(x.l), atan(x.u));\n}\n\niFloat iAtan(iFloat y, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(y);\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < 0.0) {\n        if (y.u < 0.0) {\n            return iFloat(atan(y.u, x.l), atan(y.l, x.u));\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI, PI);\n        }\n        \n        return iFloat(atan(y.u, x.u), atan(y.l, x.l));\n    }\n    \n    if (x.u == 0.0) {\n        if (x.l < 0.0) {\n            if (y.u < 0.0) {\n                return iFloat(atan(y.u, x.l), -PI / 2.0);\n            }\n            \n            if (y.l < 0.0) {\n                return iFloat(-PI, PI);\n            }\n            \n            if (y.l == 0.0) {\n                return iFloat(0.0, PI);\n            }\n            \n            return (iFloat(PI / 2.0, atan(y.l, x.l)));\n        }\n        \n        if (y.u < 0.0) {\n            return ifloat(-PI / 2.0);\n        }\n        \n        if (y.u == 0.0) {\n            if (y.l < 0.0) {\n                return iFloat(-PI / 2.0, 0.0);\n            }\n            \n            return ifloat(0.0);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI / 2.0, PI / 2.0);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI / 2.0);\n        }\n        \n        return ifloat(PI / 2.0);\n    }\n    \n    if (x.l < 0.0) {\n        if (y.u < 0.0) {\n            return iFloat(atan(y.u, x.l), atan(y.u, x.u));\n        }\n        \n        if (y.u == 0.0) {\n            if (y.l == 0.0) {\n                return iFloat(0.0, PI);\n            }\n            \n            return iFloat(-PI, PI);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI, PI);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI);\n        }\n        \n        return iFloat(atan(y.l, x.u), atan(y.l, x.l));\n    }\n    \n    if (x.l == 0.0) {\n        if (y.u <= 0.0) {\n            return iFloat(atan(y.u, x.u), -PI / 2.0);\n        }\n        \n        if (y.l < 0.0) {\n            return iFloat(-PI / 2.0, PI / 2.0);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, PI / 2.0);\n        }\n        \n        return iFloat(atan(y.l, x.u), PI / 2.0);\n    }\n    \n    return iAtan(iDiv(y, x));\n}\n\n\niFloat iSinh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(sinh(x.l), sinh(x.u));\n}\n\niFloat iCosh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u <= 0.0) {\n        return iFloat(cosh(x.u), cosh(x.l));\n    }\n    \n    if (x.l <= 0.0 && 0.0 < x.u) {\n        return iFloat(1.0, cosh(max(-x.l, x.u)));\n    }\n    \n    return iFloat(cosh(x.l), cosh(x.u));\n}\n\niFloat iTanh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(tanh(x.l), tanh(x.u));\n}\n\n\niFloat iAsinh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(asinh(x.l), asinh(x.u));\n}\n\niFloat iAcosh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u < 1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.u == 1.0) {\n        return ifloat(0.0);\n    }\n    \n    if (x.l <= 1.0) {\n        return iFloat(0.0, acosh(x.u));\n    }\n    \n    return iFloat(acosh(x.l), acosh(x.u));\n}\n\niFloat iAtanh(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.u <= -1.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.l <= -1.0) {\n        if (x.u < 1.0) {\n            return iFloat(-INFINITY, atanh(x.u));\n        }\n        \n        return iFloat(-INFINITY, INFINITY);\n    }\n    \n    if (x.l < 1.0) {\n        if (x.u < 1.0) {\n            return iFloat(atanh(x.l), atanh(x.u));\n        }\n        \n        return iFloat(atanh(x.l), INFINITY);\n    }\n    \n    return EMPTY_SET;\n}\n\n\niFloat iExp(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(exp(x.l), exp(x.u));\n}\n\niFloat iExp2(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(exp2(x.l), exp2(x.u));\n}\n\n\niFloat iLog(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(log(x.l), log(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(-INFINITY, log(x.u));\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iLog2(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(log2(x.l), log2(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(-INFINITY, log2(x.u));\n    }\n    \n    return EMPTY_SET;\n}\n\n\niFloat iPow(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    \n    if (x.l < 0.0 && y.l == y.u && fract(y.l) == 0.0) {\n        float y = y.l;\n        \n        if (y == 0.0) {\n            return ifloat(1.0);\n        }\n\n        if (y > 0.0) {\n            if (mod(y, 2.0) == 1.0) {\n                return iFloat(-pow(-x.l, y), pow(abs(x.u), y) * sign(x.u));\n            }\n\n            if (x.u > 0.0) {\n                return iFloat(0.0, pow(max(-x.l, x.u), y));\n            }        \n\n            return iFloat(pow(-x.u, y), pow(-x.l, y));;\n        }\n\n        if (mod(y, 2.0) == 1.0) {\n            if (x.u > 0.0) {\n                return iFloat(-INFINITY, INFINITY);\n            }\n\n            if (x.u == 0.0) {\n                return iFloat(-INFINITY, -pow(-x.l, y));\n            }\n\n            return iFloat(-pow(-x.u, y), -pow(-x.l, y));\n        }\n\n        if (x.u > 0.0) {\n            return iFloat(min(pow(-x.l, y), pow(x.u, y)), INFINITY);\n        }\n\n        if (x.u == 0.0) {\n            return iFloat(pow(-x.l, y), INFINITY);\n        }\n\n        return iFloat(pow(-x.l, y), pow(-x.u, y));\n    }\n    \n    if (x.u < 0.0) {\n        return EMPTY_SET;\n    }\n    \n    if (x.u == 0.0) {\n        if (y.l == 0.0 && y.u == 0.0) {\n            return EMPTY_SET;\n        }\n        \n        return ifloat(0.0);\n    }\n    \n    x.l = max(x.l, 0.0);\n    \n    if (x.l == 0.0) {\n        if (y.u <= 0.0) {\n            if (y.l == 0.0) {\n                return ifloat(1.0);\n            }\n            \n            if (x.u < 1.0) {\n                return iFloat(pow(x.u, y.u), INFINITY);\n            }\n            \n            return iFloat(pow(x.u, y.l), INFINITY);\n        }else\n        \n        if (y.l < 0.0) {\n            return iFloat(0.0, INFINITY);\n        }\n        \n        if (y.l == 0.0) {\n            return iFloat(0.0, max(1.0, pow(x.u, y.u)));\n        }\n    }\n    \n    return iMinMax(pow(x.l, y.l), pow(x.l, y.u), pow(x.u, y.l), pow(x.u, y.u));\n}\n\n\niFloat iSqrt(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l > 0.0) {\n        return iFloat(sqrt(x.l), sqrt(x.u));\n    }\n    \n    if (x.u > 0.0) {\n        return iFloat(0.0, sqrt(x.u));\n    }\n    \n    if (x.u == 0.0) {\n        return ifloat(0.0);\n    }\n    \n    return EMPTY_SET;\n}\n\niFloat iCbrt(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(pow(abs(x.l), 1.0 / 3.0) * sign(x.l), pow(abs(x.u), 1.0 / 3.0) * sign(x.u));\n}\n\niFloat iSquare(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l <= 0.0 && 0.0 <= x.u) {\n        float t = max(-x.l, x.u);\n        return iFloat(0.0, t * t);\n    }\n    \n    if (x.u <= 0.0) {\n        return iFloat(x.u * x.u, x.l * x.l);\n    }\n    \n    return iFloat(x.l * x.l, x.u * x.u);\n}\n\n\niFloat iSign(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(sign(x.l), sign(x.u));\n}\n\niFloat iAbs(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (x.l >= 0.0) {\n        return x;\n    }\n    \n    if (x.u <= 0.0) {\n        return iNeg(x);\n    }\n    \n    return iFloat(0.0, max(-x.l, x.u));\n}\n\niFloat iFloor(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(floor(x.l), floor(x.u));\n}\n\niFloat iCeil(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(ceil(x.l), ceil(x.u));\n}\n\niFloat iRound(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(round(x.l), round(x.u));\n}\n\niFloat iTrunc(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iFloat(trunc(x.l), trunc(x.u));\n}\n\niFloat iMod(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iSub(x, iMul(y, iFloor(iDiv(x, y))));\n}\n\niFloat iFract(iFloat x) {\n    CHECK_IF_EMPTY_SET_F(x);\n    return iSub(x, iFloor(x));\n}\n\n\niFloat iMin(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(min(x.l, y.l), min(x.u, y.u));\n}\n\niFloat iMax(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    return iFloat(max(x.l, y.l), max(x.u, y.u));\n}\n\niFloat iClamp(iFloat x, iFloat minVal, iFloat maxVal) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(minVal);\n    CHECK_IF_EMPTY_SET_F(maxVal);\n    return iFloat(clamp(x.l, minVal.l, maxVal.l), clamp(x.u, minVal.u, maxVal.u));\n}\n\n\niFloat iMix(iFloat x, iFloat y, iFloat a) {\n    CHECK_IF_EMPTY_SET_F(x);\n    CHECK_IF_EMPTY_SET_F(y);\n    CHECK_IF_EMPTY_SET_F(a);\n    return iAdd(x, iMul(iSub(y, x), a));\n}\n\niFloat iSmoothstep(iFloat edge0, iFloat edge1, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(edge0);\n    CHECK_IF_EMPTY_SET_F(edge1);\n    CHECK_IF_EMPTY_SET_F(x);\n    iFloat t = iClamp(iDiv(iSub(x, edge0), iSub(edge1, edge0)), 0.0, 1.0);\n    return iMul(iSquare(t), iSub(3.0, iMul(2.0, t)));\n}\n\niFloat iStep(iFloat edge, iFloat x) {\n    CHECK_IF_EMPTY_SET_F(edge);\n    CHECK_IF_EMPTY_SET_F(x);\n    \n    if (edge.u <= x.l) {\n        return ifloat(1.0);\n    }\n    \n    if (x.u < edge.l) {\n        return ifloat(0.0);\n    }\n    \n    return iFloat(0.0, 1.0);\n}\n\n\niFloat iIf(iBool P, iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_BSET_F(P);\n    \n    if (P.l) {\n        return x;\n    }\n    \n    if (!P.u) {\n        return y;\n    }\n    \n    if (x == EMPTY_SET) {\n        return y;\n    }\n    \n    if (y == EMPTY_SET) {\n        return x;\n    }\n    \n    return iFloat(min(x.l, y.l), max(x.u, y.u));\n}\n\niFloat iIf(bool P, iFloat x, iFloat y) {\n    return iIf(ibool(P), x, y);\n}\niFloat iIf(bool P, float x, iFloat y) {\n    return iIf(ibool(P), ifloat(x), y);\n}\niFloat iIf(bool P, iFloat x, float y) {\n    return iIf(ibool(P), x, ifloat(y));\n}\niFloat iIf(iBool P, float x, iFloat y) {\n    return iIf(P, ifloat(x), y);\n}\niFloat iIf(iBool P, float x, float y) {\n    return iIf(P, ifloat(x), ifloat(y));\n}\niFloat iIf(iBool P, iFloat x, float y) {\n    return iIf(P, x, ifloat(y));\n}\n\niBool iEqual(iFloat x, iFloat y) {\n    if (x == y) {\n        return ibool(true);\n    }\n    \n    if (x.l <= y.u && y.l <= x.l) {\n        return iBool(false, true);\n    }\n    \n    return ibool(false);\n}\n\niBool iGreaterThan(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.l > y.u) {\n        return ibool(true);\n    }\n    \n    if (x.u <= y.l) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iGreaterThanEqual(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.l >= y.u) {\n        return ibool(true);\n    }\n    \n    if (x.u < y.l) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iLessThan(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.u < y.l) {\n        return ibool(true);\n    }\n    \n    if (x.l >= y.u) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iLessThanEqual(iFloat x, iFloat y) {\n    CHECK_IF_EMPTY_SET_B(x);\n    CHECK_IF_EMPTY_SET_B(y);\n    \n    if (x.u <= y.l) {\n        return ibool(true);\n    }\n    \n    if (x.l > y.u) {\n        return ibool(false);\n    }\n    \n    return iBool(false, true);\n}\n\n\niBool iNOT(iBool x) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    \n    if (x.l && x.u) {\n        return ibool(false);\n    }\n    \n    if (!x.l && !x.u) {\n        return ibool(true);\n    }\n    \n    return iBool(false, true);\n}\n\niBool iAND(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l && y.l, x.l && y.u, x.u && y.l, x.u && y.u);\n}\n\niBool iOR(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l || y.l, x.l || y.u, x.u || y.l, x.u || y.u);\n}\n\niBool iXOR(iBool x, iBool y) {\n    CHECK_IF_EMPTY_BSET_B(x);\n    CHECK_IF_EMPTY_BSET_B(y);\n    \n    return iMinMax(x.l ^^ y.l, x.l ^^ y.u, x.u ^^ y.l, x.u ^^ y.u);\n}", "buffer_a_code": "//-----------------------Keyboard & Mouse Input Handler-----------------------//\n\n// Settings: \nconst float MOUSE_SENSITIVITY = 5.0;  \nconst float MOVEMENT_SPEED = 10.0; // Units per second\n\n// Controls:\nconst float KEY_W = 87.0;     // forwards\nconst float KEY_A = 65.0;     // left\nconst float KEY_S = 83.0;     // backwards\nconst float KEY_D = 68.0;     // right\nconst float KEY_UP = 38.0;    // forwards\nconst float KEY_LEFT = 37.0;  // left\nconst float KEY_DOWN = 40.0;  // backwards\nconst float KEY_RIGHT = 39.0; // right\nconst float KEY_SPACE = 32.0; // up\nconst float KEY_SHIFT = 16.0; // down\nconst float KEY_J = 74.0;     // up\nconst float KEY_N = 78.0;     // down\nconst float KEY_K = 75.0;     // decrease orbit radius\nconst float KEY_M = 77.0;     // increase orbit radius\n\n\n\n//============================================================================//\n\n\n\nbool keyPressed(float keyCode) {\n    return texture(iChannel0, vec2((keyCode + 0.5) / 256.0, 0.5 / 3.0)).r > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    if (fragCoord == vec2(0.5, 0.5)) {\n        if (iMouse.z > 0.0) {\n            vec2 oldCamRot = texelFetch(iChannel1, ivec2(0, 0), 0).zw;\n            float mouseSens = -MOUSE_SENSITIVITY / iResolution.x;\n            fragColor = vec4(clamp(oldCamRot.x - (iMouse.y - abs(iMouse.w)) * mouseSens, -PI * 0.5, PI * 0.5),\n                                   oldCamRot.y + (iMouse.x - abs(iMouse.z)) * mouseSens,\n                                   oldCamRot);\n        } else {\n            vec2 camRot = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n            fragColor = camRot.xyxy;\n        }\n        \n        if (iFrame == 0 || iMouse.x == 0.0 && iMouse.z == 0.0) {\n            fragColor.x = mix(0.1, -0.1, 0.5 - 0.5 * cos(iTime * 0.5));\n            fragColor.y = -1.9 + iTime * 0.3;\n        }\n    } else if (fragCoord == vec2(1.5, 0.5)) {\n        fragColor = texelFetch(iChannel1, ivec2(1, 0), 0);\n        float camRotY = texelFetch(iChannel1, ivec2(0, 0), 0).y;\n        float c = cos(camRotY);\n        float s = sin(camRotY);\n        mat3 rotMat = mat3(\n                c,   0.0,  -s,\n                0.0, 1.0,  0.0,\n                s,   0.0,  c\n            ) * MOVEMENT_SPEED * iTimeDelta;\n        vec3 right = vec3(1.0, 0.0, 0.0);\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        vec3 forward = vec3(0.0, 0.0, -1.0);\n        \n        if (keyPressed(KEY_W) || keyPressed(KEY_UP)) {\n            fragColor.xyz += rotMat * forward;\n        }\n        if (keyPressed(KEY_S) || keyPressed(KEY_DOWN)) {\n            fragColor.xyz -= rotMat * forward;\n        }\n        \n        if (keyPressed(KEY_D) || keyPressed(KEY_RIGHT)) {\n            fragColor.xyz += rotMat * right;\n        }\n        if (keyPressed(KEY_A) || keyPressed(KEY_LEFT)) {\n            fragColor.xyz -= rotMat * right;\n        }\n        \n        if (keyPressed(KEY_SPACE) || keyPressed(KEY_J)) {\n            fragColor.xyz += rotMat * up;\n        }\n        if (keyPressed(KEY_SHIFT) || keyPressed(KEY_N)) {\n            fragColor.xyz -= rotMat * up;\n        }\n            \n        if (keyPressed(KEY_K)) {\n            fragColor.w   -= MOVEMENT_SPEED * iTimeDelta;\n        }\n        if (keyPressed(KEY_M)) {\n            fragColor.w   += MOVEMENT_SPEED * iTimeDelta;\n        }\n        \n        fragColor.w = iFrame == 0 ? 11.0 : max(fragColor.w, 0.0);\n    } else if (fragCoord == vec2(0.5, 1.5)) {\n        if (keyPressed(KEY_W)     || keyPressed(KEY_A)     || \n            keyPressed(KEY_S)     || keyPressed(KEY_D)     || \n            keyPressed(KEY_UP)    || keyPressed(KEY_LEFT)  || \n            keyPressed(KEY_DOWN)  || keyPressed(KEY_RIGHT) || \n            keyPressed(KEY_SPACE) || keyPressed(KEY_SHIFT) || \n            keyPressed(KEY_J)     || keyPressed(KEY_N)     || \n            keyPressed(KEY_K)     || keyPressed(KEY_M)     || \n            \n            iMouse.z > 0.0) {\n            fragColor.x = 1.0;\n        } else {\n            fragColor.x = texelFetch(iChannel1, ivec2(0, 1), 0).x + 1.0;\n        }\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[484, 582, 611, 611, 1924], [2794, 2794, 2828, 2937, 3525], [3527, 3898, 3960, 3960, 6293], [6295, 6295, 6326, 6326, 6716], [6718, 6718, 6756, 6756, 6834], [6994, 6994, 7019, 7019, 7044], [7046, 7046, 7089, 7089, 7697], [7699, 7699, 7745, 7745, 8657], [8659, 8714, 8750, 8750, 8789], [8790, 8790, 8852, 8852, 9547], [9549, 9549, 9604, 9620, 10780], [10938, 10938, 10979, 10979, 11115], [11117, 11117, 11145, 11145, 12157], [12159, 12159, 12214, 12287, 13183]], "test": "untested"}
{"id": "7tKBzR", "name": "RT in One Weekend: Defocus Blur", "author": "piyushslayer", "description": "Finally decided to give Ray Tracing In One Weekend book (Peter Shirley) a try. Covers until Ch. 12 (Defocus Blur). Drag the mouse to rotate camera. ", "tags": ["raytracing", "ray", "illumination", "tracing", "diffuse", "montecarlo", "hash", "weekendmglobal"], "likes": 7, "viewed": 292, "published": 3, "date": "1663953112", "time_retrieved": "2024-07-30T16:29:59.426081", "image_code": "/**\n* Finally decided to give Ray Tracing In One Weekend (Peter Shirley) a try.\n* http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\n*\n* This shader covers defocus blur (Ch. 12) of the book. \n*\n* Most of the ray tracer logic lies in the common tab with some initialization and input handling\n* in Buffer A. Buffer B stores last frame's mouse location. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 outColor = textureLod(iChannel0, uv, 0.0);\n    fragColor = vec4(pow(outColor.xyz, vec3(1.0 / 2.2)), 1.0);\n    if (fragCoord.x < 1.0) fragColor = vec4(0.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI         3.1415926535\n#define TWO_PI     6.2831853071\n#define BIG_EPS    1e-3\n#define SMOL_EPS   1e-8\n\n#define Saturate(x) clamp(x, 0.0, 1.0)\n\n#define M_LAMBERTIAN 0\n#define M_METAL 1\n#define M_DIELECTRIC 2\n\nconst float cameraNear = 0.001;\nconst float cameraFar  = 65535.0;\n\nstruct Camera\n{\n    vec3 origin, forward, left, up, lowerLeftCorner, horizontal, vertical;\n    float lensRadius;\n};\n\nstruct Ray\n{\n    vec3 origin, direction;\n};\n\nstruct Material\n{\n    int type;\n    vec3 albedo;\n    float extraParam; // This can be fuzz for metals, or IOR for dielectrics (nothing for lambert)\n};\n\nstruct HitResult\n{\n    float t;\n    vec3 position, normal;\n    Material material;\n    bool frontFace;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material material;\n};\n\nconst int numberOfSpheres = 5;\n\nconst Sphere sphereList[numberOfSpheres] = Sphere[](\n    Sphere(vec3(0.0, -5000.5, 0.0), 5000.0, Material(M_LAMBERTIAN, vec3(0.8, 0.8, 0.0), 0.0)), // floor\n    Sphere(vec3(0.0, 0.0, -1.0), 0.5, Material(M_LAMBERTIAN, vec3(0.1, 0.2, 0.5), 0.0)), // center\n    Sphere(vec3(-1.0-BIG_EPS, 0.0+BIG_EPS, -1.0), 0.5, Material(M_DIELECTRIC, vec3(1.0), 1.5)), // outer left\n    Sphere(vec3(-1.0, 0.0, -1.0), -0.495, Material(M_DIELECTRIC, vec3(1.0), 1.5)), // inner left\n    Sphere(vec3(1.0, 0.0, -1.0), 0.5, Material(M_METAL, vec3(0.8, 0.6, 0.2), 0.15)) // right   \n);\n\n// Quality hashes collection by nimitz https://www.shadertoy.com/view/Xt3cDn\nfloat hashSeed = 0.0;\n\nuint BaseHash(uvec2 p) {\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y >> 3U));\n    return h32 ^ (h32 >> 16);\n}\n\nfloat Hash1(inout float seed)\n{\n    uint n = BaseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 Hash2(inout float seed) {\n    uint n = BaseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec2 rz = uvec2(n, n * 48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 Hash3(inout float seed) {\n    uint n = BaseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec2 RandomPointInUnitDisk(inout float seed)\n{\n    vec2 h = Hash2(seed) * vec2(1.0, TWO_PI);\n    return h.x * vec2(cos(h.y), sin(h.y));\n}\n\n// Source: Karthik Karanth's blog: \n// https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\nvec3 RandomPointInUnitSphere(inout float seed) {\n    vec3 h = Hash3(seed) * vec3(TWO_PI, 2.0, 1.0) - vec3(0.0, 1.0, 0.0);\n    float theta = h.x;\n    float sinPhi = sqrt(1.0 - h.y * h.y);\n    float r = pow(h.z, 1.0 / 3.0);\n    \n    return r * vec3(cos(theta) * sinPhi, sin(theta) * sinPhi, h.y);\n}\n\nvec3 GetIntersectPoint(in Ray ray, in float t)\n{\n    return ray.origin + ray.direction * t;\n}\n\nvec3 GetBackgroundColor(in float y)\n{\n    // Get a nice skyblue-ish gradient background\n    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), y);\n}\n\nvoid FlipNormalAndIOR(in Ray incoming, inout HitResult result)\n{\n    bool isFrontFace = dot(incoming.direction, result.normal) < 0.0;\n    \n    if (isFrontFace)\n    {\n        result.material.extraParam  = 1.0 / result.material.extraParam;\n    }\n    else\n    {\n        result.normal = -result.normal;\n    }\n}\n\n// PBRT Book refract: \n// https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission#Refract\nbool RefractPBRT(in vec3 V, in vec3 N, in float etaRatio, inout float cosThetaI, inout vec3 transmitted)\n{\n    transmitted = vec3(SMOL_EPS); // Avoid NaNs\n    \n    cosThetaI = max(0.0, dot(-V, N));\n    float sin2ThetaI = 1.0 - cosThetaI * cosThetaI;\n    float cos2ThetaT = 1.0 - etaRatio * etaRatio * sin2ThetaI;\n    \n    if (cos2ThetaT < 0.0) return false;\n    \n    transmitted = etaRatio * V + (etaRatio * cosThetaI - sqrt(cos2ThetaT)) * N;\n    \n    return true;\n}\n\nfloat SchlickApprox(float cosine, float etaRatio) \n{\n    float r0 = (1.0 - etaRatio) / (1.0 + etaRatio);\n    r0 *= r0;\n    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\n\n// Scatter the incoming ray based on the bxdf\nbool ScatterRay(in Ray incoming, in HitResult hitInfo, inout vec3 attenuation, inout Ray scattered)\n{\n    if (hitInfo.material.type == M_LAMBERTIAN)\n    {\n        scattered = Ray(hitInfo.position, normalize(hitInfo.normal + RandomPointInUnitSphere(hashSeed)));\n        attenuation = hitInfo.material.albedo;\n        return true;\n    }\n    else if(hitInfo.material.type == M_METAL)\n    {\n        scattered = Ray(hitInfo.position, normalize(reflect(incoming.direction, hitInfo.normal) + \n            hitInfo.material.extraParam * RandomPointInUnitSphere(hashSeed)));\n        attenuation = hitInfo.material.albedo;\n        return dot(scattered.direction, hitInfo.normal) > 0.0;\n    }\n    else if (hitInfo.material.type == M_DIELECTRIC)\n    {\n        FlipNormalAndIOR(incoming, hitInfo);\n        vec3 transmitDirection;\n\n        float cosThetaI;\n        bool isRefracted = RefractPBRT(incoming.direction, hitInfo.normal, hitInfo.material.extraParam, \n            cosThetaI, transmitDirection);\n        float shouldReflect = isRefracted ? step(Hash1(hashSeed), \n            SchlickApprox(cosThetaI, hitInfo.material.extraParam)) : 1.0;\n        transmitDirection = mix(transmitDirection, reflect(incoming.direction, hitInfo.normal), shouldReflect);\n        \n        scattered = Ray(hitInfo.position, normalize(transmitDirection));\n        \n        attenuation = hitInfo.material.albedo;\n        \n        return true;\n    }\n    \n    return false;\n}\n\nbool IntersectSphere(in Ray ray, in Sphere sphere, in float tMin, in float tMax, inout HitResult result)\n{\n    vec3 oc = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n    float d = b * b - a * c;\n    \n    if (d < 0.0) return false;\n\n    float temp = (-b - sqrt(d)) / a; // Nearest hit\n    \n    if (temp < tMax && temp > tMin)\n    {\n        result.t = temp;\n        result.position = GetIntersectPoint(ray, temp);\n        result.normal = (result.position - sphere.center) * 1.0 / sphere.radius;\n        result.material = sphere.material;\n        return true;\n    }\n   \n    return false;\n}\n\nbool IntersectWorld(in Ray ray, inout HitResult worldResult)\n{\n    float closestHit = cameraFar;\n    HitResult tempResult;\n    bool worldHit = false;\n\n    for (int i = 0; i < numberOfSpheres; ++i)\n    {\n        if (IntersectSphere(ray, sphereList[i], cameraNear, closestHit, tempResult))\n        {\n            closestHit = tempResult.t;\n            worldResult = tempResult;\n            worldHit = true;\n        }\n    }\n    \n    return worldHit;\n}\n\n#define MAX_BOUNCES 8\n\nvec3 GetSceneColor(in Ray ray)\n{\n    HitResult worldResult;\n    vec3 sceneColor = vec3(1.0);\n    \n    for (int i = 0; i < MAX_BOUNCES; ++i)\n    {\n        if (IntersectWorld(ray, worldResult))\n        {\n            Ray scattered; \n            vec3 attenuation;\n            if (ScatterRay(ray, worldResult, attenuation, scattered))\n            {\n                sceneColor *= attenuation;\n                ray = scattered;\n            }\n            else\n            {\n                break;\n            }\n        }\n        else\n        {\n            return sceneColor * GetBackgroundColor(ray.direction.y * 0.5 + 0.5);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\nRay GetCameraRay(in Camera camera, in vec2 uv)\n{\n    vec2 randomInDisk = camera.lensRadius * RandomPointInUnitDisk(hashSeed);\n    vec3 offset = camera.left * randomInDisk.x + camera.up * randomInDisk.y;\n    return Ray(camera.origin + offset, normalize(camera.lowerLeftCorner + uv.x * camera.horizontal \\\n        + uv.y * camera.vertical - camera.origin - offset));\n}\n\nCamera GetCamera(in vec3 eye, in vec3 lookAt, in vec3 up, in vec2 camRot, in float fov, in float aspect, in float aperture)\n{\n    Camera camera;\n    \n    float theta = fov * PI / 180.0;\n    float h = tan(theta * 0.5);\n    float viewportHeight = 2.0 * h;\n    float viewportWidth = aspect * viewportHeight;\n\n    // Handle camera mouse rotation\n    vec3 eyeToFocus = eye - lookAt;\n    float eyeToFocusDistance = length(eyeToFocus);\n    \n    // Translate toward anchor point\n    eye -= lookAt;\n    \n    // Rotate using spherical coords\n    camRot.x = camRot.x * PI * 2.0;\n    camRot.y = mix(PI * 0.04, PI * 0.54, camRot.y);\n    \n    eye.x = eyeToFocusDistance * sin(camRot.x) * sin(camRot.y);\n    eye.y = eyeToFocusDistance * cos(camRot.y);\n    eye.z = eyeToFocusDistance * cos(camRot.x) * sin(camRot.y);\n    \n    // Translate rotated position back\n    eye += lookAt;\n    \n    // Construct orthonormal basis\n    camera.forward = normalize(eye - lookAt);\n    camera.left = normalize(cross(up, camera.forward));\n    camera.up = cross(camera.forward, camera.left);\n\n    camera.origin = eye;\n    camera.horizontal = eyeToFocusDistance * viewportWidth * camera.left;\n    camera.vertical = eyeToFocusDistance * viewportHeight * camera.up;\n    camera.lowerLeftCorner = camera.origin - camera.horizontal * 0.5 \\\n        - camera.vertical * 0.5 - eyeToFocusDistance * camera.forward;\n        \n    camera.lensRadius = aperture * 0.5;\n    \n    return camera;\n}", "buffer_a_code": "/**\n* Buffer A initializes stuff for ray tracing (camera, rays, input handling etc) and initiates\n* the ray tracing process. At the end, it accumulates the ray traced result with the previously\n* accumulated history buffer. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    hashSeed = float(BaseHash(floatBitsToUint(fragCoord))) / float(0xffffffffU) + iTime;\n    \n    //vec2 uv = (2.0 * (floor(fragCoord) + Hash2(hashSeed)) - iResolution.xy) / iResolution.y;\n    vec2 uv = (floor(fragCoord) + Hash2(hashSeed)) / iResolution.xy;\n    \n    vec4 currentMouse = iMouse / iResolution.xyxy;\n    vec4 previousMouse = texelFetch(iChannel1, ivec2(fragCoord), 0); // last frame mouse coords\n    vec2 cameraRotationUVSpace = texelFetch(iChannel0, ivec2(0), 0).xy;\n    \n    vec4 historyColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float sampleCount = historyColor.w;\n    \n    // Add mouse drag velocity to camera so it only moves from its current position\n    if (currentMouse.z > 0.0 && previousMouse.z > 0.0)\n    {\n        cameraRotationUVSpace += currentMouse.xy - previousMouse.xy;\n        cameraRotationUVSpace.y = Saturate(cameraRotationUVSpace.y);\n        \n        // Reset history on mouse click\n        sampleCount = 1.0;\n        historyColor.xyz = vec3(0.0);\n    }\n    \n    // Reset history on resolution change\n    if (texelFetch(iChannel0, ivec2(0), 0).z != iResolution.x)\n    {\n        sampleCount = 1.0;\n        historyColor.xyz = vec3(0.0);\n    }\n    \n    vec3 outColor = vec3(0.);\n    \n    if (iFrame == 0) // Initial camera position\n    {\n        cameraRotationUVSpace = vec2(-0.18, 0.9);\n        sampleCount = 1.0;\n    } \n    \n    outColor = GetSceneColor(\n        GetCameraRay(\n            GetCamera(vec3(-2.0, 2.0, 1.0),\n                      vec3(0.0, 0.0, -1.0),\n                      vec3(0.0, 1.0, 0.0),\n                      cameraRotationUVSpace,\n                      32.0, iResolution.x / iResolution.y, 0.32), uv));\n    \n    outColor = mix(historyColor.xyz, outColor, 1.0 / sampleCount++);\n    \n    // Save the cameraPosition at [0, 0] coordinate of this buffer\n    if (all(lessThan(fragCoord, vec2(1.0))))\n    {\n        outColor = vec3(cameraRotationUVSpace, iResolution.x);\n    }\n    \n    fragColor = vec4(outColor, sampleCount);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/**\n* Buffer B just saves the current frame's mouse position for it to be used in the next frame.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = iMouse / iResolution.xyxy;\n    fragColor = mouse;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[377, 377, 434, 434, 643]], "test": "untested"}
{"id": "7lKfzR", "name": "sphere gears", "author": "FabriceNeyret2", "description": "inspired by reference:  [url] https://twitter.com/Yugemaku/status/1571173869993750530 [/url]\nmouse controls camera\n", "tags": ["raymarching", "banding", "short", "reproduction"], "likes": 37, "viewed": 329, "published": 3, "date": "1663952021", "time_retrieved": "2024-07-30T16:30:00.295756", "image_code": "\n#define rot(a)        mat2(cos(a+vec4(0,11,33,0)))                      // rotation \n#define d(r,n,s)      .04* sin( n *atan(r.z,r.x)+ 10.*iTime + s 1.57 )  // dents\n//#define d(r,n,s)    .04* atan(3.*sin( n *atan(r.z,r.x)+ 10.*iTime + s 1.57 ))  // variant\n\n#define half(s) r = q, \\\n        r.x-=.9, r.xy*=rot(.3), r.x+=.9,                     /* hemisphere */      \\\n        t = min(t, max( max( length(r)-1., .9-length(r)) , r.y + d(r,32.,s) )),    \\\n                                                   /*  max(r.y + d(r,32.,s), -r.y-.1 ))) /* variant */ \\\n        r.x-=.9, r.xy*=rot( -.17), r.x+=.9,              /* satellite gear */      \\\n        t = min(t, max( length(r.yz)-.28 -d(r.yxz,12.,s), abs(r.x+.95) -.03 ) ) \n\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,20), q, r,                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5\n              :  vec3( .15,.07,0) * cos(.3*iTime + vec3(0,11,0)); \n    p += sqrt(R.y/18.) * texelFetch(iChannel0,ivec2(U)%1024,0).x * D; // jitter against pseudo-shading banding\n          \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)           // march scene\n        q = p,\n        q.yz *= rot(-6.*M.y),                              // rotations\n        q.xz *= rot(-6.*M.x-1.57), \n        t = 9., half(), q.y = -q.y, half(-),               // full 3D shape,\n \n        p += .5*t*D;                                       // step forward = dist to obj          \n\n   O *= O * 1.3;                                           // color scheme\n}\n\n", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7tVfRR", "name": "Acoustic Pipes 2 (Fast)", "author": "pyBlob", "description": "Stable pressure wave through pipes at max speed (c=1 for pipe without slope). This approximation is for subsonic flow velocity and small sound pressure levels.", "tags": ["wave", "simulation", "acoustic"], "likes": 15, "viewed": 278, "published": 3, "date": "1663947963", "time_retrieved": "2024-07-30T16:30:01.686039", "image_code": "/*\nThings to try out (need recompile and reset):\n    - Input waveforms (cw-pulse, cw, pulse)\n    - Switch visualized field (v variable in mainImage)\n    - Wavelengths (f variable in _step)\n    - Pipe shapes (initialization in update)\n\nInteresting:\n    - Sign-flip of mass density for reflection in narrow pipe\n    - Sign-flip of flux density for reflection in wide pipe\n*/\n\nvoid mainImage(out vec4 C, vec2 O)\n{\n    ivec2 I = ivec2(O);\n    int y = int(O.y / iResolution.y * float(npipes));\n    float Oy = O.y - (float(y) + .5) * iResolution.y / float(npipes);\n    \n    vec4 h0 = texelFetch(iChannel0, ivec2(I.x + -1, y), 0);\n    vec4 h1 = texelFetch(iChannel0, ivec2(I.x + -0, y), 0);\n\n    C = vec4(0);\n    float mr =           h1.x     ;\n    float fr = mix(h0.x, h1.x, .5);\n    float vr = mr * iResolution.y/2./float(npipes)*.8 - abs(Oy);\n\n    float mA = mr*mr;\n    float fA = fr*fr;\n\n    float v = h1.y / mA; // mass density\n    //v = h1.z / c / fA; // flux density\n    if (vr > 0.)\n    {\n        C = mix(C, vec4(0, .1, 1, 1), clamp(-v, 0., 1.));\n        C = mix(C, vec4(1, .2, 0, 1), clamp(+v, 0., 1.));\n    }\n    \n    // pipe\n    C = mix(C, vec4(1), clamp((1. + .3 * abs(dFdx(vr))) - abs(vr), 0., 1.));\n    C = sqrt(C);\n    \n    // tip of the wave\n    float t = float(iFrame * nbuffers);\n    float w = iResolution.x;\n    float x = abs(mod(t * c + w, 2. * w) - w);\n    C = mix(C, vec4(1, 0, 0, 1), clamp(1. - abs(O.x - .5 - x), 0., 1.));\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "buffer(0)", "buffer_a_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int   npipes  = 5;\nconst int  nbuffers = 4;\nconst float c       = 1. / 2.; // speed of sound [px/step]\nconst float damping = 0e-5;\n\nconst float pi = radians(180.);\nconst float tau = pi * 2.;\n\nvec3 resolution;\nint frame;\n\nfloat constriction(float x, float w, float s);\nfloat narrowing(float x, float w, float s);\nfloat profile(int pipe, float x)\n{\n    //return x = .9 - .8 * step(0.4, x);\n    if (pipe == 4)\n        return constriction(x, .1, 10.);\n    if (pipe == 3)\n        return constriction(x, .1, 100.);\n    if (pipe == 1)\n        return narrowing(-x, -.4, 10.);\n    if (pipe == 0)\n        return narrowing(x, .4, 10.);\n    return 1.;\n}\n\nvec2 boundary(float t)\n{\n    float f, xt, z;\n    \n    //f = c / 10.;\n    //f = c / 50.;\n    f = c / (resolution.x * .2);\n    \n    z = sin(t*tau*f) * .3*c * float(t*f < 1.); // short cw-pulse\n    //z = sin(t*tau*f) * .3*c * float(t*f < 2.); // long cw-pulse\n    //z = sin(t*tau*f) * .1*c;                   // cw\n    //xt=t*tau*f-3., z = exp(-xt*xt)*1.*c;       // pulse\n\n    return vec2(z, 0);\n    //return vec2(0, z);\n}\n\nfloat dm(float lf, float rf)\n{\n    return lf - rf;\n}\n\nfloat df(float lr, float rr, float lm, float rm, float f)\n{\n    float cr = mix(lr, rr, .5);\n    \n    float lA = lr*lr;\n    float cA = cr*cr;\n    float rA = rr*rr;\n    float p = (lm/lA - rm/rA) * cA;\n\n    return p*c*c - f*damping;\n}\n\nvoid update(out vec4 C, vec2 O, sampler2D iChannel0)\n{\n    ivec2 I = ivec2(O);\n    \n    if (I.y >= npipes)\n    {\n        C = vec4(1,2,3,4);\n        return;\n    }\n\n    //if (frame == -1) // doesn't work with preview in firefox\n    if (texelFetch(iChannel0, ivec2(0, npipes), 0) != vec4(1,2,3,4))\n    {\n        C = vec4(0);\n        C.x = profile(I.y, O.x / resolution.x);\n        return;\n    }\n    \n    vec4 I0 = texelFetch(iChannel0, ivec2(I.x + -1, I.y), 0);\n    vec4 I1 = texelFetch(iChannel0, ivec2(I.x + -0, I.y), 0);\n    vec4 I2 = texelFetch(iChannel0, ivec2(I.x + +1, I.y), 0);\n\n    // Leap frog integration\n    // 1a. Update flux\n    I1.z += df(I0.x, I1.x, I0.y, I1.y, I1.z);\n    I2.z += df(I1.x, I2.x, I1.y, I2.y, I2.z);\n\n    // 1b. Override flux at boundary\n    vec2 b = boundary(float(frame));\n    if (I.x == 0)\n        I1.z = b.x;\n    if (I.x == int(resolution.x) - 1)\n        I2.z = b.y;\n\n    // 2. Update mass\n    I1.y += dm(I1.z, I2.z);\n\n    C = I1;\n}\n\nfloat constriction(float x, float w, float s)\n{\n    s /= resolution.x;\n    float a = .5-w;\n    float b = .5+w;\n    return mix(1., .1, smoothstep(a-s, a, x) - smoothstep(b, b+s, x));\n}\n\nfloat narrowing(float x, float w, float s)\n{\n    s /= resolution.x;\n    s /= 2.;\n    return mix(1., .4, smoothstep(w-s, w+s, x));\n}\n\n#define buffer(i) \\\nvoid mainImage(out vec4 C, vec2 O) \\\n{ \\\n    resolution = iResolution; \\\n    frame = iFrame * nbuffers + i; \\\n    update(C, O, iChannel0); \\\n} \\\n", "buffer_b_code": "buffer(1)", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "buffer(2)", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "buffer(3)", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "stVfRR", "name": "Julia Hilbert 3D", "author": "xacer", "description": "show different julia sets along hilbert curve", "tags": ["fractal", "curve"], "likes": 15, "viewed": 365, "published": 3, "date": "1663945144", "time_retrieved": "2024-07-30T16:30:02.639490", "image_code": "// \"Hilbert 3D\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// 3D Hilbert curves (algorithm derived from al13n's \"Space Filling Curve\")\n\n#define AA 0\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat JuliaDf (vec3 p, vec3 p_orig);\nfloat PrCylDf (vec3 p, float r, float h);\nvec3 HsvToRgb (vec3 c);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nvec3 ltPos, qHilb;\nfloat dstFar, tCur, szFac, cFac, vShift, zDisp;\nint idObj, nIter;\nbool doSh;\nconst int maxIter = 5;\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\nvec3 HilbCrv (vec3 p)\n{\n  vec3 s;\n  vec2 cv;\n  float lLen, cLen, dp, xRev, zRev, zAdd;\n  cLen = 1. / (2. * cFac - 1.);\n  lLen = cFac * cFac * (1. - ((1. - 0.25 * pi) * cFac - 1.) * cLen);\n  dp = 1. + cLen;\n  xRev = 1.;\n  zRev = 1.;\n  zAdd = 0.;\n  for (int j = 0; j < maxIter; j ++) {\n    lLen *= 0.125;\n    dp *= 0.5;\n    s = sign (p);\n    zAdd += lLen * zRev * s.z * (4. - s.y * (2. - s.x));\n    if (s.x > 0.) p = p.zxy * vec3 (- s.z, 1., - s.y);\n    else if (s.y > 0.) p = p.yxz * vec3 (-1., -1., - s.z);\n    else if (s.z > 0.) p = p.yzx * vec3 (1., -1., 1.);\n    else p = p.zyx;\n    p += dp * vec3 (1., ((s.x + s.y < 0.) ? 1. : -1.), 1.);\n    if (s.x + s.z < 0.) xRev = - xRev;\n    else if (s.x > 0.) {\n      if (s.y != s.z) zRev = - zRev;\n    } else zRev = - zRev;\n    if (j == nIter - 1) break;\n  }\n  cv = vec2 (p.y, - p.z) + cLen;\n  if (min (cv.x, cv.y) > 0.) p.yz = vec2 (length (cv) - cLen, (atan (cv.x, cv.y) - 0.25 * pi) * cLen);\n  else if (p.y + p.z < 0.) p.yz = p.zy * vec2 ( -1., 1.) + vec2 (0., (1. - 0.25 * pi) * cLen);\n  else p.z -= (1. - 0.25 * pi) * cLen;\n  p.xz *= vec2 (xRev, zRev);\n  p.z += zAdd;\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, w;\n  q = p / szFac;\n  q.y -= vShift;\n  q.xz = Rot2D (q.xz, pi + 0.25 * pi * sin (0.03 * 2. * pi * tCur));\n  q = RotToDir (vec3 (-1., 1., 1.) / sqrt3, vec3 (0., 1., 0.), q);\n  w = 0.5 / cFac;\n  d = PrRoundBoxDf (q, vec3 (1. - 0.26 * w), 0.01);\n  if (doSh || d < 0.1) {\n    qHilb = HilbCrv (q);\n    q = qHilb;\n    q.z = mod (q.z + zDisp, w) - 0.5 * w;\n    // if (true) { return length(q.xy) - 0.01; }\n    float jdf = JuliaDf(q.xyz, p.xyz);\n    d = max (d, min (PrRoundBox2Df (q.xy, vec2 (0.1 * w), 0.05 * w), jdf));\n    idObj = 1;\n  }\n  dMin = 0.7 * szFac * d;\n  q = p;\n  q.y -= 0.02;\n  d = PrCylDf (q.xzy, 0.8, 0.02);\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  doSh = true;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltDir;\n  float dstObj, dstGrnd, vdl, sh, att, h;\n  cFac = pow (2., float (nIter));\n  zDisp = 1. * tCur / cFac;\n  szFac = 1. + 0.8 / cFac;\n  vShift = (sqrt3 - 1.3 / cFac) + 0.04;\n  doSh = false;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = (rd.y < 0.) ? - ro.y / rd.y : dstFar;\n  if (min (dstObj, dstGrnd) < dstFar) {\n    ltDir = normalize (ltPos);\n    if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      vdl = max (dot (vn, ltDir), 0.);\n      h = 0.05 * zDisp * cFac;\n      if (idObj == 1) h += 0.5 + 0.5 * qHilb.z / (cFac * cFac);\n      if (idObj == 1 || length (ro.xz) < 0.6) {\n        col = HsvToRgb (vec3 (mod (h, 1.), 1., 1.));\n        vdl *= vdl * vdl;\n      } else col = vec3 (0.5);\n    } else {\n      ro += dstGrnd * rd;\n      vn = vec3 (0., 1., 0.);\n      col = vec3 (0.4) * (0.7 + 0.3 * Fbm2 (4. * ro.xz));\n      vdl = max (dot (vn, ltDir), 0.);\n    }\n    att = smoothstep (0.9, 0.95, dot (normalize (ltPos - ro), ltDir));\n    sh = ObjSShadow (ro, ltDir);\n    col = att * (col * (0.2 + 0.8 * sh * vdl) +\n       0.2 * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.));\n  } else col = vec3 (0.);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, ltEl, ltAz, ns;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.25 * pi, 0.05 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., sqrt3, -10.);\n  zmFac = 5. + 10. * abs (az) / pi;\n  ltEl = -0.2 * pi * (1. + 0.2 * sin (0.2 * 2. * pi * tCur));\n  ltAz = pi + 0.2 * pi * cos (0.25 * 2. * pi * tCur);\n  ltPos = vec3 (0., 0., 20.);\n  ltPos.yz = Rot2D (ltPos.yz, ltEl);\n  ltPos.xz = Rot2D (ltPos.xz, ltAz);\n  dstFar = 100.;\n  ns = mod (0.25 * tCur, float (2 * (maxIter - 1) - 1));\n  nIter = 2;// + int (min (ns, 2. * float (maxIter - 1) - ns));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\n\n//--------------------------------------------------------------------------------\n// quaternion manipulation\n//--------------------------------------------------------------------------------\n\nvec4 qSquare( vec4 a )\n{\n    return vec4( a.x*a.x - dot(a.yzw,a.yzw), 2.0*a.x*(a.yzw) );\n}\n\nvec4 qCube( vec4 a )\n{\n\treturn a * ( 4.0*a.x*a.x - dot(a,a)*vec4(3.0,1.0,1.0,1.0) );\n}\n\n//--------------------------------------------------------------------------------\n\nfloat lengthSquared( vec4 z ) { return dot(z,z); }\n\n// animation\nfloat JuliaDf (vec3 p, vec3 p_orig) {\n    float r = 12.0;\n    p *= r;\n    p_orig.y -= 2.0;\n    vec4 z = vec4( p, 0.2 );\n    vec4 c = vec4(p_orig, 0.0) / 2.0;\n\n    float m2 = 0.0;\n    vec2  t = vec2( 1e10 );\n\n    float dz2 = 1.0;\n    for( int i=0; i<10; i++ ) \n    {\n        // |dz|² = |3z²|²\n        dz2 *= 9.0*lengthSquared(qSquare(z));\n\n        // z = z^3 + c\t\t\n        z = qCube( z ) + c;\n\n        // stop under divergence\t\t\n        m2 = dot(z, z);\t\t\n        if( m2>10000.0 ) break;\n    }\n\n    // distance estimator: d(z) = 0.5·log|z|·|z|/|dz|   (see https://iquilezles.org/articles/distancefractals)\n    float d = 0.25 * log(m2) * sqrt(m2/dz2 );\n    // replace with julia set\n \n    return d / r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVfRR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[695, 695, 718, 718, 1826], [1828, 1828, 1850, 1850, 2553], [2555, 2555, 2588, 2588, 2765], [2767, 2767, 2788, 2788, 2988], [2990, 2990, 3027, 3027, 3264], [3266, 3266, 3301, 3301, 4484], [4486, 4486, 4542, 4542, 5932], [5934, 5934, 5980, 5980, 6027], [6029, 6029, 6076, 6076, 6123], [6320, 6320, 6344, 6344, 6410], [6412, 6412, 6434, 6434, 6498], [6584, 6584, 6615, 6615, 6634], [6636, 6649, 6686, 6686, 7355], [7357, 7357, 7399, 7399, 7450], [7453, 7453, 7477, 7477, 7599], [7601, 7601, 7643, 7643, 7799], [7801, 7801, 7831, 7831, 7944], [7978, 7978, 8002, 8002, 8132], [8134, 8134, 8159, 8159, 8345], [8347, 8347, 8368, 8368, 8523]], "test": "untested"}
{"id": "slVBRR", "name": "Lighter flame", "author": "DrTone", "description": "Procedural flame doodle. ", "tags": ["flame", "fire"], "likes": 7, "viewed": 307, "published": 3, "date": "1663944534", "time_retrieved": "2024-07-30T16:30:03.461292", "image_code": "\nmat2 rotz(float angle)\n{\n    mat2 m;\n    m[0][0] = cos(angle); m[0][1] = -sin(angle);\n    m[1][0] = sin(angle); m[1][1] = cos(angle);\n    return m;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat fbm(vec2 uv)\n{\n    float n = (texture(iChannel1, uv).r - 0.5) * 0.5;\n    n += (texture(iChannel1, uv * 2.0).r - 0.5) * 0.5 * 0.5;\n    n += (texture(iChannel1, uv * 3.0).r - 0.5) * 0.5 * 0.5 * 0.5;\n    \n\treturn n + 0.5;\n}\n\n\n// -----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 _uv = uv;\n    uv -= vec2(0.5);\n    vec2 centerUV = uv;\n    \n    // height variation from fbm\n    float heightScale = 0.85;\n    float variationH = fbm(vec2(iTime * .3)) * heightScale;\n    \n    // flame \"speed\"\n    float speedScale = 0.05;\n    vec2 offset = vec2(1.9, -iTime * speedScale);\n    \n    // flame turbulence\n    float f = fbm(uv * 0.02 + offset); // rotation from fbm\n    float l = max(0.07, length(uv)); // rotation amount normalized over distance\n\tuv += rotz( ((f - 0.5) / l) * smoothstep(-0.3, .9, _uv.y) * 0.18) * uv;    \n    \n    // flame thickness\n    float thickNess = 1.9;\n    float flame = thickNess - length(uv.x) * 9.0;\n    \n    // bottom of flame \n    float blueHeight = 0.10;\n    float blueflame = pow(flame * .9, 15.0);\n    blueflame *= smoothstep(blueHeight, -1.0, _uv.y);\n    blueflame /= abs(uv.x * 2.0);\n    blueflame = clamp(blueflame, 0.0, 1.0);\n    \n    // flame\n    flame *= smoothstep(1., variationH * 0.5, _uv.y);\n\tflame = clamp(flame, 0.0, 1.0);\n    flame = pow(flame, 3.);\n    flame /= smoothstep(1.1, -0.1, _uv.y);    \n\t\n    // colors\n    vec4 col = mix(vec4(1.0, 1., 0.0, 0.0), vec4(1.0, 1.0, .6, 0.0), flame);\n    col = mix(vec4(1.0, .0, 0.0, 0.0), col, smoothstep(0.0, 1.6, flame));\n    fragColor = col;\n    \n\t// a bit blueness on the bottom\n    float blueOpacity = 0.75;\n    vec4 bluecolor = mix(vec4(0.0, 0.0, 0.19, 0.0), fragColor, blueOpacity);\n    fragColor = mix(fragColor, bluecolor, blueflame);\n    \n    // clear bg outside of the flame\n    fragColor *= flame;\n    fragColor.a = flame;\n    \n    // bg halo\n    float haloSize = 0.5;\n    float centerL = 1.0 - (length(centerUV + vec2(0.0, 0.1)) / haloSize);\n    vec4 halo = vec4(.8, .3, .3, 0.0) * 1.0 * fbm(vec2(iTime * 0.035)) * centerL + 0.02;\n    vec4 finalCol = mix(halo, fragColor, fragColor.a);\n    fragColor = finalCol;\n\n    // just a hint of noise\n    fragColor *= mix(rand(uv) + rand(uv * .45), 1.0, 0.9);\n    fragColor = clamp(fragColor, 0.0, 1.0);\n    \n    \n}\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVBRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 150], [152, 152, 172, 172, 244], [247, 247, 267, 267, 473], [476, 527, 584, 584, 2610]], "test": "untested"}
{"id": "sldfDS", "name": "RT in One Weekend: Scattering", "author": "piyushslayer", "description": "Finally decided to give Ray Tracing In One Weekend book (Peter Shirley) a try. Covers until Ch. 11 (Positionable Camera). Drag the mouse to rotate camera. ", "tags": ["raytracing", "ray", "illumination", "tracing", "diffuse", "montecarlo", "hash", "weekendmglobal"], "likes": 2, "viewed": 249, "published": 3, "date": "1663941836", "time_retrieved": "2024-07-30T16:30:04.705964", "image_code": "/**\n* Finally decided to give Ray Tracing In One Weekend (Peter Shirley) a try.\n* http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\n*\n* This shader covers mostly reflection & refraction, but I also moved to the camera from the book which makes\n* the shader cover until chapter 11 of the book.\n*\n* Most of the ray tracer logic lies in the common tab with some initialization and input handling\n* in Buffer A. Buffer B stores last frame's mouse location. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 outColor = textureLod(iChannel0, uv, 0.0);\n    fragColor = vec4(pow(outColor.xyz, vec3(1.0 / 2.2)), 1.0);\n    if (fragCoord.x < 1.0) fragColor = vec4(0.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI         3.1415926535\n#define TWO_PI     6.2831853071\n#define BIG_EPS    1e-3\n#define SMOL_EPS   1e-8\n\n#define Saturate(x) clamp(x, 0.0, 1.0)\n\n#define M_LAMBERTIAN 0\n#define M_METAL 1\n#define M_DIELECTRIC 2\n\nconst float cameraNear = 0.001;\nconst float cameraFar  = 65535.0;\n\nstruct Camera\n{\n    vec3 origin, lowerLeftCorner, horizontal, vertical;\n};\n\nstruct Ray\n{\n    vec3 origin, direction;\n};\n\nstruct Material\n{\n    int type;\n    vec3 albedo;\n    float extraParam; // This can be fuzz for metals, or IOR for dielectrics (nothing for lambert)\n};\n\nstruct HitResult\n{\n    float t;\n    vec3 position, normal;\n    Material material;\n    bool frontFace;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material material;\n};\n\nconst int numberOfSpheres = 5;\n\nconst Sphere sphereList[numberOfSpheres] = Sphere[](\n    Sphere(vec3(0.0, -5000.5, 0.0), 5000.0, Material(M_LAMBERTIAN, vec3(0.8, 0.8, 0.0), 0.0)), // floor\n    Sphere(vec3(0.0, 0.0, -1.0), 0.5, Material(M_LAMBERTIAN, vec3(0.1, 0.2, 0.5), 0.0)), // center\n    Sphere(vec3(-1.0-BIG_EPS, 0.0+BIG_EPS, -1.0), 0.5, Material(M_DIELECTRIC, vec3(1.0), 1.5)), // outer left\n    Sphere(vec3(-1.0, 0.0, -1.0), -0.495, Material(M_DIELECTRIC, vec3(1.0), 1.5)), // inner left\n    Sphere(vec3(1.0, 0.0, -1.0), 0.5, Material(M_METAL, vec3(0.8, 0.6, 0.2), 0.15)) // right   \n);\n\n// Quality hashes collection by nimitz https://www.shadertoy.com/view/Xt3cDn\nfloat hashSeed = 0.0;\n\nuint BaseHash(uvec2 p) {\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y >> 3U));\n    return h32 ^ (h32 >> 16);\n}\n\nfloat Hash1(inout float seed)\n{\n    uint n = BaseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 Hash2(inout float seed) {\n    uint n = BaseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec2 rz = uvec2(n, n * 48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 Hash3(inout float seed) {\n    uint n = BaseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\n// Source: Karthik Karanth's blog: \n// https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\nvec3 RandomPointInUnitSphere(inout float seed) {\n    vec3 h = Hash3(seed) * vec3(TWO_PI, 2.0, 1.0) - vec3(0.0, 1.0, 0.0);\n    float theta = h.x;\n    float sinPhi = sqrt(1.0 - h.y * h.y);\n    float r = pow(h.z, 1.0 / 3.0);\n    \n    return r * vec3(cos(theta) * sinPhi, sin(theta) * sinPhi, h.y);\n}\n\nvec3 GetIntersectPoint(in Ray ray, in float t)\n{\n    return ray.origin + ray.direction * t;\n}\n\nvec3 GetBackgroundColor(in float y)\n{\n    // Get a nice skyblue-ish gradient background\n    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), y);\n}\n\nvoid FlipNormalAndIOR(in Ray incoming, inout HitResult result)\n{\n    bool isFrontFace = dot(incoming.direction, result.normal) < 0.0;\n    \n    if (isFrontFace)\n    {\n        result.material.extraParam  = 1.0 / result.material.extraParam;\n    }\n    else\n    {\n        result.normal = -result.normal;\n    }\n}\n\n// PBRT Book refract: \n// https://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission#Refract\nbool RefractPBRT(in vec3 V, in vec3 N, in float etaRatio, inout float cosThetaI, inout vec3 transmitted)\n{\n    transmitted = vec3(SMOL_EPS); // Avoid NaNs\n    \n    cosThetaI = max(0.0, dot(-V, N));\n    float sin2ThetaI = 1.0 - cosThetaI * cosThetaI;\n    float cos2ThetaT = 1.0 - etaRatio * etaRatio * sin2ThetaI;\n    \n    if (cos2ThetaT < 0.0) return false;\n    \n    transmitted = etaRatio * V + (etaRatio * cosThetaI - sqrt(cos2ThetaT)) * N;\n    \n    return true;\n}\n\nfloat SchlickApprox(float cosine, float etaRatio) \n{\n    float r0 = (1.0 - etaRatio) / (1.0 + etaRatio);\n    r0 *= r0;\n    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\n\n// Scatter the incoming ray based on the bxdf\nbool ScatterRay(in Ray incoming, in HitResult hitInfo, inout vec3 attenuation, inout Ray scattered)\n{\n    if (hitInfo.material.type == M_LAMBERTIAN)\n    {\n        scattered = Ray(hitInfo.position, normalize(hitInfo.normal + RandomPointInUnitSphere(hashSeed)));\n        attenuation = hitInfo.material.albedo;\n        return true;\n    }\n    else if(hitInfo.material.type == M_METAL)\n    {\n        scattered = Ray(hitInfo.position, normalize(reflect(incoming.direction, hitInfo.normal) + \n            hitInfo.material.extraParam * RandomPointInUnitSphere(hashSeed)));\n        attenuation = hitInfo.material.albedo;\n        return dot(scattered.direction, hitInfo.normal) > 0.0;\n    }\n    else if (hitInfo.material.type == M_DIELECTRIC)\n    {\n        FlipNormalAndIOR(incoming, hitInfo);\n        vec3 transmitDirection;\n\n        float cosThetaI;\n        bool isRefracted = RefractPBRT(incoming.direction, hitInfo.normal, hitInfo.material.extraParam, \n            cosThetaI, transmitDirection);\n        float shouldReflect = isRefracted ? step(Hash1(hashSeed), \n            SchlickApprox(cosThetaI, hitInfo.material.extraParam)) : 1.0;\n        transmitDirection = mix(transmitDirection, reflect(incoming.direction, hitInfo.normal), shouldReflect);\n        \n        scattered = Ray(hitInfo.position, normalize(transmitDirection));\n        \n        attenuation = hitInfo.material.albedo;\n        \n        return true;\n    }\n    \n    return false;\n}\n\nbool IntersectSphere(in Ray ray, in Sphere sphere, in float tMin, in float tMax, inout HitResult result)\n{\n    vec3 oc = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n    float d = b * b - a * c;\n    \n    if (d < 0.0) return false;\n\n    float temp = (-b - sqrt(d)) / a; // Nearest hit\n    \n    if (temp < tMax && temp > tMin)\n    {\n        result.t = temp;\n        result.position = GetIntersectPoint(ray, temp);\n        result.normal = (result.position - sphere.center) * 1.0 / sphere.radius;\n        result.material = sphere.material;\n        return true;\n    }\n   \n    return false;\n}\n\nbool IntersectWorld(in Ray ray, inout HitResult worldResult)\n{\n    float closestHit = cameraFar;\n    HitResult tempResult;\n    bool worldHit = false;\n\n    for (int i = 0; i < numberOfSpheres; ++i)\n    {\n        if (IntersectSphere(ray, sphereList[i], cameraNear, closestHit, tempResult))\n        {\n            closestHit = tempResult.t;\n            worldResult = tempResult;\n            worldHit = true;\n        }\n    }\n    \n    return worldHit;\n}\n\n#define MAX_BOUNCES 8\n\nvec3 GetSceneColor(in Ray ray)\n{\n    HitResult worldResult;\n    vec3 sceneColor = vec3(1.0);\n    \n    for (int i = 0; i < MAX_BOUNCES; ++i)\n    {\n        if (IntersectWorld(ray, worldResult))\n        {\n            Ray scattered; \n            vec3 attenuation;\n            if (ScatterRay(ray, worldResult, attenuation, scattered))\n            {\n                sceneColor *= attenuation;\n                ray = scattered;\n            }\n            else\n            {\n                break;\n            }\n        }\n        else\n        {\n            return sceneColor * GetBackgroundColor(ray.direction.y * 0.5 + 0.5);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\nRay GetCameraRay(in Camera camera, in vec2 uv)\n{\n    return Ray(camera.origin, normalize(camera.lowerLeftCorner + uv.x * camera.horizontal \\\n        + uv.y * camera.vertical - camera.origin));\n}\n\nCamera GetCamera(in vec3 eye, in vec3 lookAt, in vec3 up, in vec2 camRot, in float fov, in float aspect)\n{\n    Camera camera;\n    \n    float theta = fov * PI / 180.0;\n    float h = tan(theta * 0.5);\n    float viewportHeight = 2.0 * h;\n    float viewportWidth = aspect * viewportHeight;\n\n    // Handle camera mouse rotation\n    float camRadius = length(eye - lookAt);\n    \n    // Translate toward anchor point\n    eye -= lookAt;\n    \n    // Rotate using spherical coords\n    camRot.x = camRot.x * PI * 2.0;\n    camRot.y = mix(PI * 0.04, PI * 0.54, camRot.y);\n    \n    eye.x = camRadius * sin(camRot.x) * sin(camRot.y);\n    eye.y = camRadius * cos(camRot.y);\n    eye.z = camRadius * cos(camRot.x) * sin(camRot.y);\n    \n    // Translate rotated position back\n    eye += lookAt;\n    \n    // Construct orthonormal basis\n    vec3 camForward = normalize(eye - lookAt);\n    vec3 camLeft = normalize(cross(up, camForward));\n    vec3 camUp = cross(camForward, camLeft);\n\n    camera.origin = eye;\n    camera.horizontal = viewportWidth * camLeft;\n    camera.vertical = viewportHeight * camUp;\n    camera.lowerLeftCorner = camera.origin - camera.horizontal * 0.5 \\\n        - camera.vertical * 0.5 - camForward;\n    \n    return camera;\n}", "buffer_a_code": "/**\n* Buffer A initializes stuff for ray tracing (camera, rays, input handling etc) and initiates\n* the ray tracing process. At the end, it accumulates the ray traced result with the previously\n* accumulated history buffer. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    hashSeed = float(BaseHash(floatBitsToUint(fragCoord))) / float(0xffffffffU) + iTime;\n    \n    //vec2 uv = (2.0 * (floor(fragCoord) + Hash2(hashSeed)) - iResolution.xy) / iResolution.y;\n    vec2 uv = (floor(fragCoord) + Hash2(hashSeed)) / iResolution.xy;\n    \n    vec4 currentMouse = iMouse / iResolution.xyxy;\n    vec4 previousMouse = texelFetch(iChannel1, ivec2(fragCoord), 0); // last frame mouse coords\n    vec2 cameraRotationUVSpace = texelFetch(iChannel0, ivec2(0), 0).xy;\n    \n    vec4 historyColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float sampleCount = historyColor.w;\n    \n    // Add mouse drag velocity to camera so it only moves from its current position\n    if (currentMouse.z > 0.0 && previousMouse.z > 0.0)\n    {\n        cameraRotationUVSpace += currentMouse.xy - previousMouse.xy;\n        cameraRotationUVSpace.y = Saturate(cameraRotationUVSpace.y);\n        \n        // Reset history on mouse click\n        sampleCount = 1.0;\n        historyColor.xyz = vec3(0.0);\n    }\n    \n    // Reset history on resolution change\n    if (texelFetch(iChannel0, ivec2(0), 0).z != iResolution.x)\n    {\n        sampleCount = 1.0;\n        historyColor.xyz = vec3(0.0);\n    }\n    \n    vec3 outColor = vec3(0.);\n    \n    if (iFrame == 0) // Initial camera position\n    {\n        cameraRotationUVSpace = vec2(-0.12, 0.84);\n        sampleCount = 1.0;\n    } \n    \n    outColor = GetSceneColor(\n        GetCameraRay(\n            GetCamera(vec3(-2.0, 2.0, 1.0),\n                      vec3(0.0, 0.0, -1.0),\n                      vec3(0.0, 1.0, 0.0),\n                      cameraRotationUVSpace,\n                      32.0, iResolution.x / iResolution.y), uv));\n    \n    outColor = mix(historyColor.xyz, outColor, 1.0 / sampleCount++);\n    \n    // Save the cameraPosition at [0, 0] coordinate of this buffer\n    if (all(lessThan(fragCoord, vec2(1.0))))\n    {\n        outColor = vec3(cameraRotationUVSpace, iResolution.x);\n    }\n    \n    fragColor = vec4(outColor, sampleCount);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/**\n* Buffer B just saves the current frame's mouse position for it to be used in the next frame.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = iMouse / iResolution.xyxy;\n    fragColor = mouse;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 536, 536, 745]], "test": "untested"}
{"id": "NlVBzz", "name": "delayed video 4 slit scan effect", "author": "FabriceNeyret2", "description": "stores 96 video frames in the cubeMap ( 4x4 per face ). ref: https://shadertoy.com/view/fdyfDd .\nIn black & white we could store 384 frames ( = 6.4 \" )\n\nHere, the window tiles are accessed with delays = y.", "tags": ["video", "cubemap", "slitscan", "rollingshutter", "storage"], "likes": 13, "viewed": 366, "published": 3, "date": "1663937792", "time_retrieved": "2024-07-30T16:30:05.561676", "image_code": "// variant of https://shadertoy.com/view/sdyBWt\n// variant of https://shadertoy.com/view/fdyfDd\n// cubeMap utils inspired from https://www.shadertoy.com/view/3tGBDz\n\n#define T2(n)  T( ( U + vec2((n)%4, ((n)%16)/4) ) /4., (n)/16 ) // access image with delay(=tile) n\n\nvoid mainImage( out vec4 O, vec2 u ) \n{ \n    vec2 R = iResolution.xy, \n         U = u/R;                         // tileCoord\n     float y = 96.*U.y;\n  // y = 96.-y;                           // try reversing :-)\n     int n = int(y);                      // tileId\n  // O = mix( T2(n), T2(n+1), fract(y) ); // convert to faceCoord & faceId + image interpolation\n     O = T2(n); O = mix( O, T2(n+1), fract(y) ); // because of Windows.\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": " void mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    vec3 A = abs(D);\n    int n = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2; // faceID\n    if (D[n]<0.) n += 3;\n      \n    vec2 I = floor(U/=256.);\n    if ( n==5 && I==vec2(3) ) O = texture(iChannel1, fract(U) );\n    else if    ( I!=vec2(3) ) O = T((I.x<3.? U+vec2(1,0) : U+vec2(-3,1))/4., n);\n    else                      O = T((U-3.)/4., n+1);\n    \n/*   // --- doesn't compile correctly on Windows Angle !\n    O = n==5 && I==vec2(3) ? texture(iChannel1, fract(U) )\n        :       I!=vec2(3) ? T((I.x<3.? U+vec2(1,0) : U+vec2(-3,1))/4., n)\n        :                    T((U-3.)/4., n+1);\n*/\n}\n\n", "cube_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 E; // mimic access to a set on n textures.\n#define T(U,n) ( E = vec3( 2.*fract(U) -1., 1 )                                 \\\n                   * vec3( n==0||n==5 ?-1:1 , n!=1 ?-1:1 , n>2 ?-1:1 ),         \\\n                 E = (n)%3 != 2 ? E.yzx : E.xzy,                                \\\n                 texture( iChannel0, vec3( E[(n+1)%3], E[(n)%3], E[(n+2)%3] ) ) \\\n               )\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVBzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 267, 306, 306, 702]], "test": "untested"}
{"id": "NlKBRz", "name": "Random position Cubes", "author": "hatoo", "description": "Trying repeat objects with random position in raymarching", "tags": ["3d", "raymarching"], "likes": 5, "viewed": 313, "published": 3, "date": "1663929533", "time_retrieved": "2024-07-30T16:30:06.373513", "image_code": "vec2 rot2(vec2 p, float t) {\n    return vec2(cos(t) * p.x - sin(t) * p.y, sin(t) * p.x + cos(t) * p.y);\n}\nvec3 rotX(vec3 p, float t) {\n    return vec3(p.x, rot2(p.yz, t));\n}\nvec3 rotY(vec3 p, float t) {\n    return vec3(p.y, rot2(p.zx, t)).zxy;\n}\nvec3 rotZ(vec3 p, float t) {\n    return vec3(rot2(p.xy, t), p.z);\n}\nvec3 euler(vec3 p, vec3 t) {\n    return rotZ(rotY(rotX(p, t.x), t.y), t.z);\n}\n//end rot\n//start hash\nuvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u);\nuvec3 u = uvec3(1, 2, 3);\nconst uint UINT_MAX = 0xffffffffu;\nuint uhash11(uint n) {\n    n ^= (n << u.x);\n    n ^= (n >> u.x);\n    n *= k.x;\n    n ^= (n << u.x);\n    return n * k.x;\n}\nuvec2 uhash22(uvec2 n) {\n    n ^= (n.yx << u.xy);\n    n ^= (n.yx >> u.xy);\n    n *= k.xy;\n    n ^= (n.yx << u.xy);\n    return n * k.xy;\n}\nuvec3 uhash33(uvec3 n) {\n    n ^= (n.yzx << u);\n    n ^= (n.yzx >> u);\n    n *= k;\n    n ^= (n.yzx << u);\n    return n * k;\n}\nfloat hash11(float p) {\n    uint n = floatBitsToUint(p);\n    return float(uhash11(n)) / float(UINT_MAX);\n}\nfloat hash21(vec2 p) {\n    uvec2 n = floatBitsToUint(p);\n    return float(uhash22(n).x) / float(UINT_MAX);\n}\nfloat hash31(vec3 p) {\n    uvec3 n = floatBitsToUint(p);\n    return float(uhash33(n).x) / float(UINT_MAX);\n}\nvec2 hash22(vec2 p) {\n    uvec2 n = floatBitsToUint(p);\n    return vec2(uhash22(n)) / vec2(UINT_MAX);\n}\nvec3 hash33(vec3 p) {\n    uvec3 n = floatBitsToUint(p);\n    return vec3(uhash33(n)) / vec3(UINT_MAX);\n}\n//end hash\n//start pnoise\nfloat gtable2(vec2 lattice, vec2 p) {\n    uvec2 n = floatBitsToUint(lattice);\n    uint ind = uhash22(n).x >> 29;\n    float u = 0.92387953 * (ind < 4u ? p.x : p.y);  //0.92387953 = cos(pi/8)\n    float v = 0.38268343 * (ind < 4u ? p.y : p.x);  //0.38268343 = sin(pi/8)\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u ? v : -v);\n}\nfloat pnoise21(vec2 p) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float[4] v;\n    for(int j = 0; j < 2; j++) {\n        for(int i = 0; i < 2; i++) {\n            v[i + 2 * j] = gtable2(n + vec2(i, j), f - vec2(i, j));\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    return 0.5 * mix(mix(v[0], v[1], f[0]), mix(v[2], v[3], f[0]), f[1]) + 0.5;\n}\nfloat gtable3(vec3 lattice, vec3 p) {\n    uvec3 n = floatBitsToUint(lattice);\n    uint ind = uhash33(n).x >> 28;\n    float u = ind < 8u ? p.x : p.y;\n    float v = ind < 4u ? p.y : ind == 12u || ind == 14u ? p.x : p.z;\n    return ((ind & 1u) == 0u ? u : -u) + ((ind & 2u) == 0u ? v : -v);\n}\nfloat pnoise31(vec3 p) {\n    vec3 n = floor(p);\n    vec3 f = fract(p);\n    float[8] v;\n    for(int k = 0; k < 2; k++) {\n        for(int j = 0; j < 2; j++) {\n            for(int i = 0; i < 2; i++) {\n                v[i + 2 * j + 4 * k] = gtable3(n + vec3(i, j, k), f - vec3(i, j, k)) * 0.70710678;\n            }\n\n        }\n    }\n    f = f * f * f * (10.0 - 15.0 * f + 6.0 * f * f);\n    float[2] w;\n    for(int i = 0; i < 2; i++) {\n        w[i] = mix(mix(v[4 * i], v[4 * i + 1], f[0]), mix(v[4 * i + 2], v[4 * i + 3], f[0]), f[1]);\n    }\n    return 0.5 * mix(w[0], w[1], f[2]) + 0.5;\n}\n//end pnoise\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec3 opRepRnd(in vec3 p, in vec3 c) {\n    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;\n    vec3 g = floor((p + 0.5 * c) / c);\n\n    return q - 0.5 * c * (2.0 * hash33(g) - 1.0);\n}\n\nfloat map(vec3 pos, vec3 cPos) {\n    vec3 c = vec3(4.0);\n    float d = max(sdBox(opRepRnd(pos, c), vec3(0.5)) - 0.01, -sdSphere(pos - cPos, 50.0));\n    return d;\n}\n\nvec3 gradMap(vec3 p, vec3 cPos) {\n    float eps = 0.001;\n    return normalize(vec3(map(p + vec3(eps, 0.0, 0.0), cPos) - map(p - vec3(eps, 0.0, 0.0), cPos), map(p + vec3(0.0, eps, 0.0), cPos) - map(p - vec3(0.0, eps, 0.0), cPos), map(p + vec3(0.0, 0.0, eps), cPos) - map(p - vec3(0.0, 0.0, eps), cPos)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float t = iTime * 0.3;\n    vec3 cPos = vec3(0.0, 0.0, t * 100.0);\n    vec3 cDir = vec3(0.0, 0.1, 1.0);\n    vec3 cUp = rotZ(vec3(0.0, 1.0, 0.0), t);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n\n    vec3 lDir = vec3(1.0);\n\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    vec3 rPos = ray + cPos;\n    ray = normalize(ray);\n    for(int i = 0; i < 64; i++) {\n        if(map(rPos, cPos) > 0.001) {\n            rPos += map(rPos, cPos) * ray;\n        } else {\n            float amb = 0.3;\n            float diff = 0.7 * max(dot(normalize(lDir), gradMap(rPos, cPos)), 0.0);\n            vec3 col = vec3(1.0);\n            fragColor.rgb = col * (diff + amb);\n            break;\n        }\n    }\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKBRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 105], [106, 106, 134, 134, 173], [174, 174, 202, 202, 245], [246, 246, 274, 274, 313], [314, 314, 342, 342, 391], [532, 532, 554, 554, 653], [654, 654, 678, 678, 791], [792, 792, 816, 816, 917], [918, 918, 941, 941, 1024], [1025, 1025, 1047, 1047, 1133], [1134, 1134, 1156, 1156, 1242], [1243, 1243, 1264, 1264, 1346], [1347, 1347, 1368, 1368, 1450], [1451, 1477, 1514, 1514, 1815], [2192, 2192, 2229, 2229, 2481], [3080, 3080, 3113, 3113, 3141], [3143, 3143, 3172, 3172, 3267], [3269, 3269, 3306, 3306, 3442], [3444, 3444, 3476, 3476, 3607], [3609, 3609, 3642, 3642, 3914], [3916, 3916, 3971, 3971, 4807]], "test": "untested"}
{"id": "7ttBWM", "name": "sea creatures (207 chars)", "author": "hnh", "description": "Inspired by \"unsaturating post-image Bokeh\" by FabriceNeyret2 [url]https://www.shadertoy.com/view/ft3fDM[/url].\nLooks best in full screen.\n", "tags": ["2d", "sea", "screensaver", "nature", "short", "tweet", "golf"], "likes": 20, "viewed": 726, "published": 3, "date": "1663926165", "time_retrieved": "2024-07-30T16:30:07.135468", "image_code": "\n// Inspired by \"unsaturating post-image Bokeh\" by FabriceNeyret2 ( https://www.shadertoy.com/view/ft3fDM ).\n// When replacing the increment of 1.39 in the code by 1.0 you get a dense spiral that samples a disk.\n// Below is the un-golfed version.\n\n//*\n\n#define T(x,y) texture(iChannel0, (x)/r + iTime*y)\n\nvoid mainImage( out vec4 O, vec2 I) {    \n    vec2 r = iResolution.xy, i = vec2(0,11);\n    for(O-=O; i.x<2e2;)\n        O = max(O, T(I + r.x/6e3*(.5 + T(I*.1,-.005).r)\n            * sin(i+=1.39)*i, .01).bgra);\n    O *= O;\n}\n\n/*/\n\nvoid mainImage( out vec4 O, vec2 I) {\n    vec2 r = iResolution.xy;\n    float d = texture(iChannel0, I/r*.1 - iTime*.005).r;\n    d = r.x/6e3*(.5 + d);  // creature size distorted by texture\n    O = vec4(0);\n    for(float i; i<2e2; i+=1.39) {\n        vec2 s =  i*vec2(sin(-i),cos(i));  // point sampling\n        //vec2 s =  i*sin(i+vec2(0,11));\n        vec4 C = texture(iChannel0, (I + d*s)/r + iTime*.01);\n        O = max(O,C);  // depth layering\n    }\n    O = O.bgra; O *= O;  // better colors\n}\n\n/**/\n\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttBWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 305, 342, 342, 527]], "test": "untested"}
{"id": "7ldBDj", "name": "Anaglyph XOR-City", "author": "derSchamane", "description": "Put your red/cyan-glasses on and drag mouse for cam rotation.", "tags": ["anaglyph", "xor", "city", "desert"], "likes": 26, "viewed": 469, "published": 3, "date": "1663895497", "time_retrieved": "2024-07-30T16:30:07.898429", "image_code": "//                    = Anaglyph XOR-City =         \n//                by Maximilian Knape ·∑>| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n#define GAMMA vec3(.4545)\n\n#define MAX_STEPS 140\n#define STEP_FAC 0.13\n#define MAX_DIST 200.\n#define MIN_DIST 5.\n\n#define SURF_DIST .0001\n#define SURF_MUL 10000.\n#define SURF_EXP 1.2\n\n#define GLOW_INT 0.8\n#define PP_CONT 1.2\n#define PP_VIGN 2.0\n\n#define EYE_DIS 0.4\n#define FIL_COR 1.1\n\n\n#define XOR_SEED 10000\n\n\n#define iTime iTime*1.\n#define pi 3.14159265358979\n#define S(x,y,t) smoothstep(x,y,t)\n\nmat2 Rot(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat SdBox(vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)),0.) + length(max(d, 0.));\n}\n\nfloat SdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec2 Dist(vec3 p) \n{   \n\n    float col;\n    \n    //cam movement\n    float cmt = pi / 160.; \n    float pos = pow(cos(iTime*cmt), 3.) * 800.;\n    float x = (p.x + mix(pos, -pos, step(0., cos(iTime*cmt*.5-pi*.25))));\n    float y = (p.z + mix(0., pos, step(0., cos(iTime*cmt))));\n    \n    int r = int(x+y)^(int(x-y)); //XOR \n    float d = float(abs((r*r*r)/int(x+y)) % (XOR_SEED)) / float(XOR_SEED)*1.0; //small buildings\n    \n    float w = S(-0.1, 1., sin(((x+sin(y/4.)-cos(y/8.))*6.)*1.)*0.03 + //small sand waves\n                dot(sin(vec2(x+10., y)/16.), cos(vec2(x, y+10.)/21.)))*0.5; //displacement\n                \n    w = sin((x+y)/50.)*dot(sin(vec2(x+100., y)/42.), cos(vec2(x, y+100.)/64.))*8. - w; //sand hills\n    float dis = sqrt(x*x + y*y);\n    w *= S(50.,100., dis);\n    \n    col = d > w ? .6 : -0.2; //material\n    d = max(w, d);\n    d = (p.y - d); //heightmap\n\n    //ancient temple buildings\n    float size = 21.6;\n    float th = 0.5 + S(20., 50., dis)*3. - S(400., 1000., dis)*3.4;\n    p.xz = vec2(x,y)/1.24;\n    p.xz *= Rot(pi*(.5 - S(10., 20., dis) * .25));\n    p.xz = mod(abs(-mod(p.xz + vec2(0,.5), 4.*size) + 2.*size), 4.*size);\n    p.yx *= Rot(.02 * step(500., dis));\n    float c = SdBox(p - vec3(1,0,1)*(1.-pow(S(0., 800., dis), 0.6)) * 42.2,\n        vec3(th, 1.2 + (pow(S(700., 50., dis), 5.)+step(850., dis)) * 7. + step(-50., -dis)*100., th));    \n        \n    col = d > c ? mix(-.2+S(.9, 1., sin(iTime*3.-sqrt(p.y/3.)))*0.5, .55, step(20., dis)) : col;\n    d = min(c, d);\n    \n    return vec2(d, col);\n}\n\nvec3 Normal(vec3 p) \n{\n    vec2 e = vec2(.001, 0.);\n    return normalize(Dist(p).x - vec3(Dist(p-e.xyy).x, Dist(p-e.yxy).x,Dist(p-e.yyx).x));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) \n{\n    float col = 0.;\n\tfloat dO = MIN_DIST;\n    int steps = 0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {\n        steps = i;\n        \n    \tvec3 p = ro + rd*dO;\n        vec2 dS = Dist(p);\n        col = dS.y;\n        \n        float dis = pow(dO/MAX_DIST, SURF_EXP);\n        dO += dS.x * mix(STEP_FAC, 0.8, min(1., dis + S(1.2, 3., p.y)));//dS.x * mix(STEP_FAC, 1., dis);//min(dS.x * STEP_FAC, max(1. + p.y - XORMap(p.xz, 5.)*10., SURF_DIST));\n        \n        if (dO > MAX_DIST || dS.x < (SURF_DIST * (dis*SURF_MUL+1.))) break;\n    }\n    \n    return vec3(dO, steps, col);\n}\n\nfloat SoftShadow(vec3 ro, vec3 lp, float k) //Shane\n{\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    for (int i = 0; i<maxIterationsShad; i++)\n    {\n\n        float h = Dist(ro + rd*dist).x;\n        shade = min(shade, S(0., 1., k*h/dist));\n        dist += clamp(h, .02, .25);\n        \n        if (h < .0 || dist > end) break;\n    }\n\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n\nfloat GetLight(vec3 p, vec3 n, vec3 lP, vec3 rd , float shine) \n{\n\n    vec3 l = normalize(lP - p);\n    float dif = S(-0., 1., dot(n, l)*.5+.5) * max(1.-max(-shine, 0.), 0.);\n    if (shine > 0.) dif = mix(dif, dif*.1 + pow(max(dot(l, reflect(rd, n)), 0.), shine*20.), shine);\n    return dif;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) //BigWings\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) <= 0.) m = vec2(.3,.7);\n\n    float offset = S(15., 0., iTime) * 20.;\n    vec3 ro = vec3(0., 10. + offset, -50. + m.y*30. - offset*2.);\n    ro.yz *= Rot((1.0-m.y) * .2*pi);\n    ro.xz *= Rot(-m.x * 2.*pi);\n    vec3 rd = R(uv, ro, vec3(0., 10., 0.), 0.9);\n    ro += cross(rd, vec3(0., -1., 0.)) * EYE_DIS * -.5;\n    \n    vec3 n, lPos = vec3(3,1.3,-1)*1000.;\n    lPos.xz *= Rot(2.*pi*iTime/300.);\n    float bg = pow(S(-1., 1., dot(rd, normalize(lPos))), 2.5)*.5+.4;\n    \n    //left eye\n    float colL = bg;\n    vec3 p1 = vec3(0.);\n    vec3 rmd = RayMarch(ro, rd);\n\n    if(rmd.x < MAX_DIST) \n    {\n        p1 = ro + rd * rmd.x;\n        n = Normal(p1);\n        \n        colL = GetLight(p1, n, lPos, rd, rmd.z);\n        colL *= SoftShadow(p1 + n*.015, lPos, 1.5);\n        colL += rmd.y / float(MAX_STEPS) * GLOW_INT;\n        colL = mix(colL, bg, rmd.x / MAX_DIST);\n    }\n    \n    //eye distance\n    ro += cross(rd, vec3(0., -1., 0.)) * EYE_DIS;\n    \n    //right eye\n    float colR = bg;\n    vec3 p2 = vec3(0.);\n    rmd = RayMarch(ro, rd);\n\n    if(rmd.x < MAX_DIST) \n    {\n        p2 = ro + rd * rmd.x;\n        n = Normal(p2);\n        \n        colR = GetLight(p2, n, lPos, rd, rmd.z);\n        colR *= SoftShadow(p2 + n*.015, lPos, 1.5);\n        colR += rmd.y / float(MAX_STEPS) * GLOW_INT;\n        colR = mix(colR, bg, rmd.x / MAX_DIST);\n    }\n    \n    //filter correction\n    colL *= FIL_COR; \n    colR /= FIL_COR;\n    \n    //contrast\n    vec3 colS = mix(vec3(colL, colR, colR), S(vec3(0.), vec3(1.), vec3(colL, colR, colR)), PP_CONT);\n    \n    //ACES color\n    //colS =  clamp((colS * (2.51f * colS + 0.03f)) / (colS * (2.43f * colS + 0.59f) + 0.14f), 0.0f, 1.0f);\n    \n    //gamma correction\n    colS = pow(colS, GAMMA);\n    \n    //Vignette\n    colS *= S(PP_VIGN,-PP_VIGN/5., dot(uv,uv)); \n    \n    fragColor = vec4(colS,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldBDj.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[699, 699, 719, 719, 795], [797, 797, 827, 827, 919], [921, 921, 966, 966, 1254], [2788, 2788, 2810, 2810, 2931], [2933, 2933, 2967, 2967, 3545], [3547, 3547, 3600, 3600, 4107], [4110, 4110, 4175, 4175, 4402], [4405, 4405, 4458, 4458, 4653], [4655, 4655, 4712, 4712, 6653]], "test": "untested"}
{"id": "flyBzR", "name": "P-Norm infinity 160x90", "author": "sedcore", "description": "same as https://www.shadertoy.com/view/flcBDs but only computes 160x90 as desired.", "tags": ["raymarching", "repetition", "pnorm"], "likes": 4, "viewed": 208, "published": 3, "date": "1663877166", "time_retrieved": "2024-07-30T16:30:08.843901", "image_code": "#define P3(x, x0, x1, y0, y1) ((y0) + ((x)-(x0)) / ((x1)-(x0)) * ((y1)-(y0)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  vec2 f = vec2(P3(fragCoord.x, 0., iResolution.x-1., 0., 159.),\n                P3(fragCoord.y, 0., iResolution.y-1., 0., 89.));\n\tvec2 uv = f.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Sed - P-Norm infinity - 2022 */\n\n/* GLSL adaptation of http://sedcore.eu.org/small/norm_infinity.c */\n/* comments were kept as is - useless c code removed */\n/* released in the public domain */\n/* not super efficient I guess */\n\n/* 16/9 aspect ratio expected - me too lazy to handle generic case */\n\n/* 2022-09-07 */\n\n/* inspired by https://twitter.com/Marina_Costant/status/1560219380482539522 */\n\n/* gcc -Wall -o norm_infinity norm_infinity.c -lm -O3 -ffast-math -fomit-frame-pointer -march=native -fopenmp\n * ./norm_infinity > XX\n * ffmpeg -f rawvideo -s 640x360 -r 25 -pix_fmt bgra -i XX -vf palettegen palette.png\n * ffmpeg -f rawvideo -s 640x360 -r 25 -pix_fmt bgra -i XX -i palette.png -filter_complex paletteuse movie.gif\n *\n * or:\n * ffmpeg -f rawvideo -s 640x360 -r 25 -pix_fmt bgra -i XX -plays 0 movie.apng\n */\n\n/* not realtime at all, set delta = 0.05 or higher for faster but uglier */\n/* or improve dig_t(): we look for the smallest t>1 for which pnorm() = 1,\n * if it exists of course\n * also classic lookup tables, caching, and so on, can be done\n */\n\n/* linear interpolation, x is in [x0..x1] we want y in [y0..y1] such that\n * when x is x0 then y is y0 and when x is x1 then y is y1\n */\n/* x0   y0\n * x    y\n * x1   y1\n * (x-x0) / (x1-x0) = (y-y0) / (y1-y0)\n * y = y0 + (x-x0) / (x1-x0) * (y1-y0)\n */\n#define P3(x, x0, x1, y0, y1) ((y0) + ((x)-(x0)) / ((x1)-(x0)) * ((y1)-(y0)))\n\n#define rotate_x(x, y, z, angle)    {          \\\n  float y2 = y * cos(angle) - z * sin(angle); \\\n  float z2 = z * cos(angle) + y * sin(angle); \\\n  y = y2;                                      \\\n  z = z2;                                      \\\n}\n\n#define rotate_y(x, y, z, angle)    {          \\\n  float z2 = z * cos(angle) - x * sin(angle); \\\n  float x2 = x * cos(angle) + z * sin(angle); \\\n  x = x2;                                      \\\n  z = z2;                                      \\\n}\n\n#define rotate_z(x, y, z, angle)    {          \\\n  float x2 = x * cos(angle) - y * sin(angle); \\\n  float y2 = y * cos(angle) + x * sin(angle); \\\n  x = x2;                                      \\\n  y = y2;                                      \\\n}\n\nconst float M_PI = radians(180.);\n\n/****************************************************************************/\n/* bezier curve begin                                                       */\n/****************************************************************************/\n\n/* bezier curves are super nice for trajectories */\n\n#if 0\n\ntypedef struct {\n  float x;\n  float y;\n  float z;\n} point_t;\n\ntypedef struct {\n  point_t p0;\n  point_t p1;\n  point_t p2;\n  point_t p3;\n} bezier_t;\n\n#endif\n\n/* cubic bezier (4 control points) */\nvec3 bezier(in vec3 b[4], in float t)\n{\n  float _1_t = 1. - t;\n  float _1_t_2 = _1_t * _1_t;\n  float _1_t_3 = _1_t_2 * _1_t;\n  float t_2 = t * t;\n  float t_3 = t * t_2;\n  return vec3(\n    _1_t_3 * b[0].x + 3. * _1_t_2 * t * b[1].x + 3. * _1_t * t_2 * b[2].x + t_3 * b[3].x,\n    _1_t_3 * b[0].y + 3. * _1_t_2 * t * b[1].y + 3. * _1_t * t_2 * b[2].y + t_3 * b[3].y,\n    _1_t_3 * b[0].z + 3. * _1_t_2 * t * b[1].z + 3. * _1_t * t_2 * b[2].z + t_3 * b[3].z\n  );\n}\n\n/****************************************************************************/\n/* bezier curve end                                                         */\n/****************************************************************************/\n\n/****************************************************************************/\n/* camera management begin                                                  */\n/****************************************************************************/\n\n#define eye    camera[0]\n#define center camera[1]\n#define vx     camera[2]\n#define vy     camera[3]\n\n#if 0\n\n/* the 4 component of the camera array are defined as below */\ntypedef struct {\n  point_t eye;           /* position of the eye */\n  point_t center;        /* center of screen of camera */\n  point_t vx, vy;        /* unit vectors on screen */\n} camera_t;\n\n#endif\n\nvoid compute_camera(out vec3 camera[4], in float frame)\n{\n  float d;\n  float t;\n  float angle;\n\n  frame = mod(frame, 400.);\n\n  /* basic idea is to start the camera in front of cube (0,0,0) then move\n   * forward with some rotations for nice visual effect and end in front\n   * of cube (0,0,-24) so that we can loop the animation (the cube (0,0,-24)\n   * has the same neighbors as the cube (0,0,0), so we can loop)\n   */\n\n  /* position the eye */\n  /* eye movement is snakish, we start in front of cube (0,0,0) and end\n   * in front of cube (0,0,-24) turning around center of each cube on the path\n   */\n\n  if (frame < 100.) {\n    /* turn on the left */\n    angle = P3(frame, 0., 100., -M_PI/2., -3.*M_PI/2.);\n  } else if (frame < 200.) {\n    /* right */\n    angle = P3(frame, 100., 200., -M_PI/2., M_PI/2.);\n  } else if (frame < 300.) {\n    /* left */\n    angle = P3(frame, 200., 300., -M_PI/2., -3.*M_PI/2.);\n  } else {\n    /* right */\n    angle = P3(frame, 300., 400., -M_PI/2., M_PI/2.);\n  }\n  /* we start with a point pointing to the right: (3,0,0) */\n  vec3 p0 = vec3(3,0,0);\n  rotate_y(p0.x, p0.y, p0.z, angle);\n  /* we force z to move forward, the rotation-based stuff is ugly for z */\n  p0.z = P3(frame, 0., 100., 3., -3.);\n  /* move a bit closer to the shape */\n  p0.z += - .5;\n  /* tilt trajectory */\n  rotate_z(p0.x, p0.y, p0.z, M_PI/6.);\n\n  eye = p0;\n\n  /* position p1 (direction of camera from the eye) */\n  /* more or less going forward but some backward for not too much boring */\n  vec3 p1b[4];\n  p1b[0] = vec3(0, 0, 0);     /* start point */\n  p1b[1] = vec3(5, 3, 2);\n  p1b[2] = vec3(-5,-3, -46);\n  p1b[3] = vec3(0, 0, -24);   /* end point */\n  vec3 p1 = bezier(p1b, P3(frame, 0., 400., 0., 1.));\n\n  /* center is on vector (p1-p0) at right distance of the eye */\n  d = length(p1-p0); //sqrt((p1.x-p0.x)*(p1.x-p0.x) + (p1.y-p0.y)*(p1.y-p0.y) + (p1.z-p0.z)*(p1.z-p0.z));\n  /* right distance is 0.5 in front of eye (quite close, wide camera angle) */\n  t = 0.5 / d;\n  center = p0 + t * (p1 - p0);\n\n  p1 = center;\n\n  /* position p2 (anchor for angle of camera) (not sure if that means\n   * something, but it's clear in my head: 'eye' is where is the eye, 'center',\n   * is where the eye looks at, but then the camera can rotate around this\n   * center, so we need a third point to define this rotation, this is p2)\n   */\n  /* rotate a bit, not too much, more or less randomly chosen */\n  vec3 p2b[4];\n  p2b[0] = vec3(10, 0, 0);      /* start: no rotation, horizontal cam */\n  p2b[1] = vec3(-10, -10, 0);\n  p2b[2] = vec3(10, 10, -20);\n  p2b[3] = vec3(10, 0, -24);    /* end: no rotation, horizontal cam */\n  vec3 p2 = bezier(p2b, P3(frame, 0., 400., 0., 1.));\n\n  /* project p2 on plane perpendicular to vector (p1-p0) containing p1 */\n  /* vector (p2p-p2) and (p1-p0) are parallel: (p2p-p2) = t * (p1-p0)\n   * and scalar product (p2p-p1) x (p1-p0) = 0\n   * (p2 + t * (p1-p0) - p1) x (p1-p0) = 0\n   * (p2.x + t * (p1.x-p0.x) - p1.x) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = 0\n   * ((p2.x - p1.x) + t * (p1.x-p0.x)) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = 0\n   * (p2.x - p1.x) * (p1.x - p0.x) + t * (p1.x-p0.x) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = 0\n   * t * (p1.x-p0.x) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = -(p2.x - p1.x) * (p1.x - p0.x)\n   * t = (-(p2.x - p1.x) * (p1.x - p0.x) -(p2.y - p1.y) * (p1.y - p0.y) -(p2.z - p1.z) * (p1.z - p0.z)) /\n   *     ((p1.x-p0.x) * (p1.x - p0.x) + (p1.y-p0.y) * (p1.y - p0.y) + (p1.z-p0.z) * (p1.z - p0.z))\n   */\n  vec3 p2p;\n  t = (-(p2.x - p1.x) * (p1.x - p0.x) -(p2.y - p1.y) * (p1.y - p0.y) -(p2.z - p1.z) * (p1.z - p0.z)) /\n      ((p1.x-p0.x) * (p1.x - p0.x) + (p1.y-p0.y) * (p1.y - p0.y) + (p1.z-p0.z) * (p1.z - p0.z));\n  p2p = p2 + t * (p1 - p0);\n\n  /* vx is vector (p2p-p1) at right distance */\n  d = length(p2p - p1); //sqrt((p2p.x-p1.x)*(p2p.x-p1.x) + (p2p.y-p1.y)*(p2p.y-p1.y) + (p2p.z-p1.z)*(p2p.z-p1.z));\n  /* length (right distance) is 1/150 */\n  t = 1./150. / d;\n  vx = t * (p2p - p1);\n\n  /* vy is vectorial product of vx and vector (center-p0) */\n  vy = cross(vx, center - p0);\n  /* at the right length (also 1/150, as for vx) */\n  d = length(vy); //sqrt(ret.vy.x*ret.vy.x + ret.vy.y*ret.vy.y + ret.vy.z*ret.vy.z);\n  t = 1./150. / d;\n  vy *= t;\n}\n\n/****************************************************************************/\n/* camera management end                                                    */\n/****************************************************************************/\n\nfloat pnorm(float p, float t, float x0, float y0, float z0, float x1, float y1, float z1,\n             float frame,\n             float p2, float p3, float p4)\n{\n  /* the space is covered by cubes of size 6x6x6, repeating in all directions,\n   * each one containing a shape.\n   * We want 4 different shapes on screen for less boring, so each cube is\n   * numbered in [0, 1, 2, 3] and the numbering repeats like this in all\n   * directions, each numbering receives a shape (different shapes have\n   * different p for a given frame)\n   */\n\n  /* (x,y,z) is the point to test */\n  float x = x0 + t * (x1 - x0);\n  float y = y0 + t * (y1 - y0);\n  float z = z0 + t * (z1 - z0);\n\n  /* find in which cube we are */\n  int px = int(round(x / 6.)); px = (px % 4 + 4) % 4;\n  int py = int(round(y / 6.)); py = (py % 4 + 4) % 4;\n  int pz = int(round(z / 6.)); pz = (pz % 4 + 4) % 4;\n\n  /* put (x,y,z) in the cube (0,0,0) for processing */\n  x = mod(mod(x-3.,6.) + 6., 6.)-3.;\n  y = mod(mod(y-3.,6.) + 6., 6.)-3.;\n  z = mod(mod(z-3.,6.) + 6., 6.)-3.;\n\n  /* rotate the shape */\n  float angle = 2. * M_PI * frame / 100.;\n  rotate_y(x, y, z, angle);\n\n  /* select p depending on the cube we're in */\n  if ((px+py+pz) % 4 == 1) p = p2;\n  else if ((px+py+pz) % 4 == 2) p = p3;\n  else if ((px+py+pz) % 4 == 3) p = p4;\n\n  /* no need for final pow(1/p), we care about distance = 1 */\n  return   pow(abs(x), p)\n         + pow(abs(y), p)\n         + pow(abs(z), p);\n}\n\nfloat get_p(float frame)\n{\n  float p;\n  frame = mod(frame, 200.);\n  /* we get p from [1/2 .. 4], linear choice is ugly, so we use several\n   * linear ranges, looks more or less nice, there may be better choices\n   */\n  /* 1/2   1   2    4 */\n  if (frame < 50.)       p = P3(frame, 0., 50., 1./2., 1.);\n  else if (frame < 75.)  p = P3(frame, 50., 75., 1., 2.);\n  else if (frame < 100.) p = P3(frame, 75., 100., 2., 4.);\n  else if (frame < 125.) p = P3(frame, 100., 125., 4., 2.);\n  else if (frame < 150.) p = P3(frame, 125., 150., 2., 1.);\n  else                   p = P3(frame, 150., 200., 1., 1./2.);\n  return p;\n}\n\nfloat dig_t(float p, float x0, float y0, float z0, float x1, float y1, float z1, float frame, float p2, float p3, float p4)\n{\n  float t0, t1;\n  float n0, n1;\n  /* delta = .01 for nice result but very very slow, bigger value for faster\n   * computation but uglier on screen\n   */\n  float delta = .01;\n\n  /* norm is abs(x)^p + abs(y)^p + abs(z)^p (we omit final ^1/p)\n   * we want norm = 1 (we want to be on the \"unit sphere\" of the norm)\n   * current ray is from (x0, y0, z0) to (x1,y1,z1)\n   * a point (x,y,z) is on the ray if there is t such that:\n   * (x,y,z) = t * ray\n   * for t=0 we decide to be at (x0,y0,z0)\n   * for t=1 we decide to be at (x1,y1,z1)\n   * so for generic point (x,y,z), we have:\n   * 0 x0  y0  z0\n   * 1 x1  y1  z1\n   * t x   y   z\n   * so:\n   * t = (x - x0) / (x1 - x0)\n   * same for y and z\n   * and so:\n   * x = x0 + t * (x1 - x0)\n   * y = y0 + t * (y1 - y0)\n   * z = z0 + t * (z1 - z0)\n   */\n\n  /* start from t = 1 to t = 70, step is delta (this is very slow) */\n  t0 = 1.;\n  n0 = pnorm(p, t0, x0, y0, z0, x1, y1, z1, frame, p2, p3, p4);\n  //if (n0 <= 1) { fprintf(stderr, \"bad start\\n\"); exit(1); }\n  t1 = t0 + delta;\n  n1 = pnorm(p, t1, x0, y0, z0, x1, y1, z1, frame, p2, p3, p4);\n  /* we stop if we find a point with n = 1 or if we go too far */\n  while ((   (n0 > 1. && n1 > 1.)\n          || (n0 < 1. && n1 < 1.))\n         && t1 < 70.) {\n    n0 = n1;\n    t0 = t1;\n    t1 += delta;\n    n1 = pnorm(p, t1, x0, y0, z0, x1, y1, z1, frame, p2, p3, p4);\n  }\n  if (t1 >= 70.) return 1000.;\n  /* this is not correct, t for which distance = 1 is not necessarily t1\n   * but it looks ok on screen, so no big deal at this point\n   */\n  return t1;\n}\n\nvec4 raytrace_pnorm(float x, float y, float frame)\n{\n  vec3 camera[4];\n  compute_camera(camera, frame);\n  float x0, y0, z0, x1, y1, z1;\n  float p;\n  float t;\n\n  /* ray is from eye to (x,y) on screen (center of screen is (0,0)) */\n  /* start of ray: eye */\n  x0 = eye.x;\n  y0 = eye.y;\n  z0 = eye.z;\n\n  /* end of ray */\n  /* (x,y) of screen is vector (x*vx + y*vx) starting at point center in\n   * our 3d space\n   */\n  x1 = center.x + x * vx.x + y * vy.x;\n  y1 = center.y + x * vx.y + y * vy.y;\n  z1 = center.z + x * vx.z + y * vy.z;\n\n  /* get the p in [1/2 .. 4], four of them for more diversity on screen */\n  p = get_p(frame);\n  float p2 = get_p(frame + 100.);\n  float p3 = get_p(frame + 50.);\n  float p4 = get_p(frame + 150.);\n\n  /* blue is actually black, looks better ('blue' name kept, lazy me) */\n  vec4 blue = vec4(0, 0, 0, 0);\n  t = dig_t(p, x0, y0, z0, x1, y1, z1, frame, p2, p3, p4);\n  if (t == 1000.) return blue;\n\n  /* a palette based on euclidian distance from (0,0,0) to the point */\n  /* close is yellow, farther is red, far is white */\n  float d = pnorm(2., t, x0, y0, z0, x1, y1, z1, frame, 2., 2., 2.);\n  /* g+rb define yellow */\n  float g = P3(d, 0., 0.6, 125., 10.);\n  float rb = P3(d, 0., 0.6, 125., 10.);\n  /* ra defines red */\n  float ra = P3(d, 0., 2., 0., 255.);\n  g = clamp(g, 0., 255.);\n  rb = clamp(rb, 0., 255.);\n  /* w defines white */\n  float w = clamp(P3(d, 1., 1.4, 0., 120.), 0., 255.);\n  /* alpha is used to fade to 'blue' when very far away, looks nice */\n  float alpha = clamp(P3(t, 10., 70., 1., 0.), 0., 1.);\n  return vec4(\n    alpha * max(clamp(ra+rb, 0., 255.), w) + (1.-alpha) * blue.r,\n    alpha * max(g, w) + (1.-alpha) * blue.g,\n    alpha * max(20., w) + (1.-alpha) * blue.b,\n    0\n  ) / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  if (fragCoord.x > 160. || fragCoord.y > 90.) { fragColor = vec4(0,0,0,0); return; }\n\n  float x = fragCoord.x-80.;\n  float y = fragCoord.y-45.;\n  x = floor(x);\n  y = floor(y);\n  float frame = iTime * 25.;\n  fragColor = raytrace_pnorm(x, y, frame);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 136, 136, 378]], "test": "untested"}
{"id": "NtyBzR", "name": "P-Norm 160x90", "author": "sedcore", "description": "same as https://www.shadertoy.com/view/Nl3BDs but only computes 160x90 as desired.", "tags": ["raymarching", "pnorm"], "likes": 0, "viewed": 146, "published": 3, "date": "1663876976", "time_retrieved": "2024-07-30T16:30:09.640770", "image_code": "#define P3(x, x0, x1, y0, y1) ((y0) + ((x)-(x0)) / ((x1)-(x0)) * ((y1)-(y0)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  vec2 f = vec2(P3(fragCoord.x, 0., iResolution.x-1., 0., 159.),\n                P3(fragCoord.y, 0., iResolution.y-1., 0., 89.));\n\tvec2 uv = f.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* Sed - P-Norm - 2022 */\n\n/* GLSL adaptation of http://sedcore.eu.org/small/norm.c */\n/* comments were kept as is - useless c code removed */\n/* released in the public domain */\n/* not super efficient I guess */\n\n/* 16/9 aspect ratio expected - me too lazy to handle generic case */\n\n/* 2022-09-07 */\n\n/* inspired by https://twitter.com/Marina_Costant/status/1560219380482539522 */\n\n/* gcc -Wall -o norm norm.c -lm -O3 -ffast-math -fomit-frame-pointer -march=native\n * ./norm > XX\n * ffmpeg -f rawvideo -s 640x360 -r 25 -pix_fmt bgra -i XX -vf palettegen palette.png\n * ffmpeg -f rawvideo -s 640x360 -r 25 -pix_fmt bgra -i XX -i palette.png -filter_complex paletteuse movie.gif\n */\n\n/* not realtime at all, set delta = 0.05 or higher for faster but uglier */\n/* or improve dig_t(): we look for the smallest t>1 for which norm() = 1,\n * if it exists of course\n */\n\n/* not super good comments, see norm_infinity.c for better */\n\nconst float M_PI = radians(180.);\n\nfloat norm(float p, float t, float x0, float y0, float z0, float x1, float y1, float z1)\n{\n  float x = x0 + t * (x1 - x0);\n  float y = y0 + t * (y1 - y0);\n  float z = z0 + t * (z1 - z0);\n  return   pow(abs(x), p)\n         + pow(abs(y), p)\n         + pow(abs(z), p);\n}\n\nfloat euclid(float t, float x0, float y0, float z0, float x1, float y1, float z1)\n{\n  float x = x0 + t * (x1 - x0);\n  float y = y0 + t * (y1 - y0);\n  float z = z0 + t * (z1 - z0);\n  return sqrt(x*x + y*y + z*z);\n}\n\nfloat dig_t(float p, float x0, float y0, float z0, float x1, float y1, float z1)\n{\n  float t0, t1;\n  float n0, n1;\n  float delta = .01;\n\n  /* norm is abs(x)^p + abs(y)^p + abs(z)^p\n   * we want norm = 1 (we want to be on the \"unit sphere\" of the norm)\n   * current ray is from (x0, y0, z0) to (x1,y1,z1)\n   * a point (x,y,z) is on the ray if there is t such that:\n   * (x,y,z) = t * ray\n   * for t=0 we decide to be at (x0,y0,z0)\n   * for t=1 we decide to be at (x1,y1,z1)\n   * so for generic point (x,y,z), we have:\n   * 0 x0  y0  z0\n   * 1 x1  y1  z1\n   * t x   y   z\n   * so:\n   * t = (x - x0) / (x1 - x0)\n   * same for y and z\n   * and so:\n   * x = x0 + t * (x1 - x0)\n   * y = y0 + t * (y1 - y0)\n   * z = z0 + t * (z1 - z0)\n   */\n\n  /* start at t = 1 and end at t = 1 + delta */\n  t0 = 1.;\n  n0 = norm(p, t0, x0, y0, z0, x1, y1, z1);\n  //if (n0 <= 1) { fprintf(stderr, \"bad start\\n\"); exit(1); }\n  t1 = t0 + delta;\n  n1 = norm(p, t1, x0, y0, z0, x1, y1, z1);\n  while ((   (n0 > 1. && n1 > 1.)\n          || (n0 < 1. && n1 < 1.))\n         && t1 < 5.) {\n    n0 = n1;\n    t0 = t1;\n    t1 += delta;\n    n1 = norm(p, t1, x0, y0, z0, x1, y1, z1);\n  }\n  if (t1 >= 5.) return 1000.;\n  return t1;\n}\n\n#define rotate_x(x, y, z, angle)    {          \\\n  float y2 = y * cos(angle) - z * sin(angle); \\\n  float z2 = z * cos(angle) + y * sin(angle); \\\n  y = y2;                                      \\\n  z = z2;                                      \\\n}\n\n#define rotate_y(x, y, z, angle)    {          \\\n  float x2 = x * cos(angle) - z * sin(angle); \\\n  float z2 = z * cos(angle) + x * sin(angle); \\\n  x = x2;                                      \\\n  z = z2;                                      \\\n}\n\nvec4 raytrace_norm(float x, float y, float frame)\n{\n  float x0 = 0., y0 = 0., z0 = 3., x1 = x, y1 = y, z1 = 2.;\n  float p;\n  float t;\n\n  /* rotate (x0,y0,z0) and (x1,y1,z1) */\n  float angle = 2. * M_PI * frame / 100.;\n\n  rotate_x(x0, y0, z0, -M_PI/7. * cos(2. * M_PI * frame / 80.));\n  rotate_x(x1, y1, z1, -M_PI/7. * cos(2. * M_PI * frame / 80.));\n\n  rotate_y(x0, y0, z0, angle);\n  rotate_y(x1, y1, z1, angle);\n\n  /* x0   y0\n   * x    y\n   * x1   y1\n   * (x-x0) / (x1-x0) = (y-y0) / (y1-y0)\n   * y = y0 + (x-x0) / (x1-x0) * (y1-y0)\n   */\n#define P3(x, x0, x1, y0, y1) ((y0) + ((x)-(x0)) / ((x1)-(x0)) * ((y1)-(y0)))\n  /* p in [1/2 .. 4] */\n  frame = mod(frame, 200.);\n  /* 1/2   1   2    4 */\n  if (frame < 50.)       p = P3(frame, 0., 50., 1./2., 1.);\n  else if (frame < 75.)  p = P3(frame, 50., 75., 1., 2.);\n  else if (frame < 100.) p = P3(frame, 75., 100., 2., 4.);\n  else if (frame < 125.) p = P3(frame, 100., 125., 4., 2.);\n  else if (frame < 150.) p = P3(frame, 125., 150., 2., 1.);\n  else                   p = P3(frame, 150., 200., 1., 1./2.);\n\n  vec4 blue = vec4(15, 17, 23, 0)/255.;\n  t = dig_t(p, x0, y0, z0, x1, y1, z1);\n  if (t == 1000.) return blue;\n\n  /* a palette based on distance from (0,0,0) to the point */\n  float d = euclid(t, x0, y0, z0, x1, y1, z1);\n  float g = P3(d, 0., 0.6, 125., 10.);\n  float rb = P3(d, 0., 0.6, 125., 10.);\n  float ra = P3(d, 0., 2., 0., 255.);\n  g = clamp(g, 0., 255.);\n  rb = clamp(rb, 0., 255.);\n  float w = clamp(P3(d, 1., 1.4, 0., 120.), 0., 255.);\n  return vec4(\n    max(clamp(ra+rb, 0., 255.), w),\n    max(g, w),\n    max(20., w),\n    0) / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  if (fragCoord.x > 160. || fragCoord.y > 90.) { fragColor = vec4(0,0,0,0); return; }\n\n  float x = fragCoord.x-80.;\n  float y = fragCoord.y-45.;\n  x = floor(x);\n  y = floor(y);\n  float frame = iTime * 25.;\n  float scale = 1./100.;\n  float x0 = x * scale;\n  float y0 = y * scale;\n  fragColor = raytrace_norm(x0, y0, frame);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtyBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 136, 136, 378]], "test": "untested"}
{"id": "NlGBzR", "name": "Anim Background 01 - by hugolnx", "author": "hugolnx", "description": "Abstract animated procedural background using a bit of geometry.", "tags": ["procedural", "animated", "abstract", "background", "geometry", "hugolnx"], "likes": 3, "viewed": 168, "published": 3, "date": "1663875723", "time_retrieved": "2024-07-30T16:30:10.403730", "image_code": "#define SHADERTOY 1\n// GITHUB: https://github.com/HugoLnx/shaders-laboratory/tree/master/shaders/pattern-background-01\n\n//#define SEEDROLL 1\n\n// Aux simple functions\n#define TWO_PI 6.283185\n#define PI 3.14159\nfloat norm(float x) { return x*.5 + .5; }\nfloat denorm(float x) { return x*2. - 1.; }\nfloat xstep(float b, float e, float v) {\n    return step(b, v) - step(e, v);\n}\nfloat xsmoothstep(float b, float e, float v) {\n    return smoothstep(b, e, v) - step(e, v);\n}\nfloat flatten(float v, float layers) {\n  return floor(v*layers) * (1./layers);\n}\nfloat flattenfull(float v, float layers) {\n  return floor(v*layers)/(layers-1.);\n}\nfloat nsin(float t) {return norm(sin(t * TWO_PI));}\nfloat ncos(float t) {return norm(cos(t * TWO_PI));}\nfloat ntan(float t) {return norm(tan(t * TWO_PI));}\nfloat sat(float t) {return clamp(t, 0., 1.);}\nfloat rsat(float t) {return mod(t+10000.0, 1.);}\nfloat xclamp(float v, float minV, float maxV) {\n  return clamp(v, minV, maxV) * xstep(minV, maxV, v);\n}\nfloat xclampnorm(float v, float minV, float maxV) {\n  return (xclamp(v, minV, maxV) - minV) / (maxV-minV);\n}\nvec3 togrey(vec3 c) {\n  return vec3((c.r+c.g+c.b)/3.);\n}\nfloat normrange(float v, float minV, float maxV) { return sat((v-minV)/(maxV-minV)); }\nfloat xnormrange(float v, float minV, float maxV) { return normrange(v, minV, maxV) * xstep(minV, maxV, v); }\nvec3 mix3(vec3 cMin, vec3 cMid, vec3 cMax, float t) {\n  float t1 = normrange(t, -1., 0.);\n  float t2 = normrange(t, 0., 1.);\n  vec3 c = mix(cMin, cMid, t1);\n  c = mix(c, cMax, t2);\n  return c;\n}\n\nvec2 rotate(vec2 v, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c) * v;\n}\n\nvec3 compose(vec3 ocolor, float intensity, vec3 color) {\n  intensity = sat(intensity);\n  return mix(ocolor, color, intensity);\n}\n\nfloat stepang(vec2 uv, vec2 center,\nfloat minang, float maxang, float rot) {\n  uv -= center;\n  float angle = atan(uv.y, uv.x);\n  angle = mod(angle + TWO_PI*10., TWO_PI);\n  minang = mod(minang + rot + TWO_PI*10., TWO_PI);\n  maxang = mod(maxang + rot + TWO_PI*10., TWO_PI);\n  float iss1 = step(minang, maxang);\n  float niss1 = 1. - iss1;\n  float s1 = iss1*xstep(minang, maxang, angle);\n  float s2 = niss1*xstep(minang, TWO_PI, angle);\n  float s3 = niss1*xstep(0., maxang, angle);\n  float s4 = xstep(.0, .0001, abs(minang-maxang));\n  return sat(s1+s2+s3+s4);\n}\n\n#define RED vec3(1., 0., 0.)\n#define GRE vec3(0., 1., 0.)\n#define BLU vec3(0., 0., 1.)\n#define WRED vec3(1., .8, .8)\n#define WGRE vec3(.8, 1., .8)\n#define WBLU vec3(.8, .8, 1.)\n#define BLU2 vec3(0.35, 0.5, 1.)\n#define PUR vec3(1., 0., 1.)\n#define YEL vec3(1., 1., 0.)\n#define CYA vec3(0., 1., 1.)\n#define WHI vec3(1.)\n#define BLA vec3(0.)\n#define BLANK vec3(0.35, 0., 0.35)\n\n#ifndef SHADERTOY\nuniform sampler2D iChannel0;\nuniform float iTime;\nuniform vec2 iResolution2D;\n#define iResolution vec4(iResolution2D, 0., 0.)\nout vec4 outColor;\n#endif\n\nfloat rand(vec2 uv, float seed, float seedModifier){\n  seed += seedModifier;\n  uv *= seed+1937.71;\n  return fract(sin(\n    dot(uv, vec2(12.9898, 78.233)) + seed\n  ) * 43758.5453);\n}\nfloat rand(float x, float seed, float seedModifier) {\n  return rand(vec2(x, x+197.937), seed, seedModifier);\n}\nfloat circle(vec2 uv, vec2 center, float radius) {\n  uv -= center;\n  float dist = length(uv);\n  return step(dist, radius);\n}\n\nfloat doline(vec2 uv, vec2 pt1, vec2 pt2, float linewidth) {\n  vec2 v = pt2 - pt1;\n  uv -= pt1;\n  float vlen = length(v);\n  vec2 vhead = v / vlen;\n  float proj = dot(vhead, uv);\n  vec2 vproj = vhead * proj;\n  float toLine = length(uv - vproj);\n  return (1.-step(linewidth, toLine)) * xstep(0., vlen, proj);\n}\n\n#define PIECOLORCOUNT 3\n#define STRIPECOLORCOUNT 3\n//#define ZOOMGRID 1\n//#define MOBILE_SHADER_EDITOR 1\n\n#ifdef MOBILE_SHADER_EDITOR\n#define iResolution resolution\n#define iTime time\n#endif\n\nvec3 composeLine(vec3 ocolor, vec2 uv, vec2 guv, float t, float appearRate, float lineSeedMod,\nfloat seedModifier, vec3[STRIPECOLORCOUNT] stripecolors, vec2 linePt1, vec2 linePt2) {\n  float lineWidth = 0.075;\n  float maxTimeOffset = 100.;\n  float frameDuration = 2.;\n  float tRand = rand(guv, 771.339*lineSeedMod, seedModifier);\n  float tOffset = (tRand-.5)*2. * maxTimeOffset;\n  t += tOffset;\n  float frameInx = floor(t / frameDuration);\n  float frameTime = mod(t, frameDuration);\n  float frameStart = normrange(frameTime, 0., 1.);\n  float nFrameTime = normrange(frameTime, 0., frameDuration);\n  float frameEnd = 1.-normrange(frameTime, frameDuration-1., frameDuration);\n  float frameMod = frameInx * 372.297;\n\n  float invRand = step(.5, rand(guv, 771.339*lineSeedMod, seedModifier+frameMod));\n  vec2 pt1 = invRand == 1. ? linePt1 : linePt2;\n  vec2 pt2 = invRand == 1. ? linePt2 : linePt1;\n  float line = doline(uv, pt1, pt1+(pt2-pt1)*nFrameTime, lineWidth);\n\n  float dRand = rand(guv/17.73, 117.994*lineSeedMod, seedModifier+frameMod);\n  line *= step(1.-appearRate, dRand);\n  line *= frameStart * frameEnd * .5;\n\n  float colorRand = rand(guv, 171.274*lineSeedMod, seedModifier+frameMod);\n  int colorInx = int(floor(colorRand*float(STRIPECOLORCOUNT)));\n  vec3 stripecolor = stripecolors[colorInx];\n  vec3 color = compose(ocolor, line, stripecolor);\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float mx = max(iResolution.x, iResolution.y);\n  vec2 ct = iResolution.xy / mx / 2.0;\n  vec2 uv = fragCoord/mx - ct;\n#ifndef MOBILE_SHADER_EDITOR\n  uv /= 2.5;\n#endif\n  vec2 ouv = uv;\n  float t = iTime;\n#ifdef SEEDROLL\n  float seedModifier = floor(t*.33);\n#else\n  float seedModifier = 0.;\n#endif\n\n#ifdef MOBILE_SHADER_EDITOR\n  float radius = .35;\n  float minRadiusVar = .35;\n#else\n  float radius = .45;\n  float minRadiusVar = .5;\n#endif\n  float maxCentervar = (.5-radius)*.5*0.95;\n#ifdef ZOOMGRID\n  float gridScale = 15.;\n#else\n  float gridScale = 40.;\n#endif\n  vec3[PIECOLORCOUNT] piecolors;\n  piecolors[0] = vec3(1., .4, .4);\n  piecolors[1] = vec3(1., .4, .7);\n  piecolors[2] = vec3(1., .7, .4);\n\n  vec3[STRIPECOLORCOUNT] stripecolors;\n  float lo = 0.75;\n  stripecolors[0] = vec3(lo, lo, 1.);\n  stripecolors[1] = vec3(1., lo, lo);\n  stripecolors[2] = vec3(lo, 1., lo);\n\n  uv *= gridScale;\n  vec2 guv = floor(uv);\n  uv = fract(uv);\n  uv -= .5;\n  vec2 center = vec2(.0);\n\n  float angsize = flattenfull(rand(guv, 137.791, seedModifier), 3.);\n  angsize = mix(PI/4.*3., PI/4.*7., angsize);\n  float rotlayers = 5.;\n  float pierot = flattenfull(rand(guv, 737.197, seedModifier), 4.);\n  pierot = mix(PI/2., TWO_PI, pierot);\n\n  int piecolorinx = int(floor(\n    rand(guv, 397.917, seedModifier)*float(PIECOLORCOUNT)\n  ));\n\n  float radiusvar = flattenfull(rand(guv, 587.173, seedModifier), 3.);\n  radiusvar = mix(minRadiusVar, 1., radiusvar);\n  //radiusvar = 1.;\n\n  vec2 centervar = vec2(\n    flattenfull(rand(guv.xy, 345.123, seedModifier), 3.),\n    flattenfull(rand(guv.yx, 354.132, seedModifier), 3.)\n  );\n  centervar = (centervar-.5)*2.;\n  centervar *= maxCentervar;\n  //center += centervar; \n\n  float pie = circle(uv, center, radius*radiusvar);\n  pie *= stepang(uv, center, 0., angsize, pierot);\n\n  float dotradius = flattenfull(rand(guv, 897.217, seedModifier), 3.);\n  dotradius = mix(.03, .15, dotradius);\n  float hasdot = step(.96, rand(guv, 227.994, seedModifier));\n  float dotted = hasdot*circle(uv, center, dotradius);\n\n\n  float npie = 1.-pie;\n  float ndotted = 1.-dotted;\n\n  vec3 color = vec3(0.);\n\n\n  vec2 diaguv = ouv;\n  diaguv *= gridScale;\n  diaguv -= .5;\n  vec2 diagGuv = floor(diaguv);\n  diaguv = fract(diaguv);\n  diaguv -= .5;\n\n  vec2 xuv = ouv;\n  xuv *= gridScale;\n  xuv.x -= .5;\n  vec2 xGuv = floor(xuv);\n  xuv = fract(xuv);\n  xuv -= .5;\n\n  vec2 yuv = ouv;\n  yuv *= gridScale;\n  yuv.y -= .5;\n  vec2 yGuv = floor(yuv);\n  yuv = fract(yuv);\n  yuv -= .5;\n  float diagAppearRate = .4;\n  float axisAppearRate = .3;\n  color = composeLine(color, diaguv, diagGuv, t, diagAppearRate, 0.  , seedModifier, stripecolors, vec2(-.5), vec2(.5));\n  color = composeLine(color, diaguv, diagGuv, t, diagAppearRate, 132., seedModifier, stripecolors, vec2(-.5, .5), vec2(.5, -.5));\n  color = composeLine(color, xuv, xGuv, t, axisAppearRate, 212., seedModifier, stripecolors, vec2(-.5, .0), vec2(.5, .0) );\n  color = composeLine(color, yuv, yGuv, t, axisAppearRate, 398., seedModifier, stripecolors, vec2(.0, .5), vec2(.0, -.5) );\n\n  color = compose(color, ndotted*pie, piecolors[piecolorinx]);\n\n  fragColor = vec4(color, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n  mainImage(outColor, gl_FragCoord.xy);\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 230, 230, 250], [251, 251, 274, 274, 294], [295, 295, 335, 335, 373], [374, 374, 420, 420, 467], [468, 468, 506, 506, 548], [549, 549, 591, 591, 631], [632, 632, 653, 653, 683], [684, 684, 705, 705, 735], [736, 736, 757, 757, 787], [788, 788, 808, 808, 833], [834, 834, 855, 855, 882], [883, 883, 930, 930, 986], [987, 987, 1038, 1038, 1095], [1096, 1096, 1117, 1117, 1152], [1153, 1153, 1203, 1203, 1239], [1240, 1240, 1291, 1291, 1349], [1350, 1350, 1403, 1403, 1544], [1546, 1546, 1580, 1580, 1662], [1664, 1664, 1720, 1720, 1792], [1794, 1794, 1870, 1870, 2351], [2899, 2899, 2951, 2951, 3080], [3081, 3081, 3134, 3134, 3191], [3192, 3192, 3242, 3242, 3316], [3318, 3318, 3378, 3378, 3626]], "test": "untested"}
{"id": "NltfDs", "name": "Biarc cubic Bezier approx expl.", "author": "NinjaKoala", "description": "This shader is visualizing the construction used in https://www.shadertoy.com/view/NldBDs\nSee top comment for explanation.\n\nMove control point with mouse.", "tags": ["2d", "bezier", "beziercurve", "spline", "curve", "cubic", "arc", "biarc"], "likes": 6, "viewed": 213, "published": 3, "date": "1663849761", "time_retrieved": "2024-07-30T16:30:11.344215", "image_code": "/*\nThe idea is the same as in https://www.shadertoy.com/view/sl3BWs\nThe difference is that now the intersection of both\ngreen circles with the cubic bezier curve is computed.\n\nIn the quadratic bezier case, one always has an\nintersection with the green circle where the incenter lies on.\n\nIn the cubic bezier case, one has to check both green circles\nfor intersections.\n\nAlso, the polynomial equation one has to solve is quartic\ninstead of quadratic now, so this is much more involved computationally.\n\nThere should always be exactly one intersection.\n(I've read this somewhere, not sure how to prove this)\n*/\n\n//#define MOVE_NODE /* Move the node with the mouse instead */\n\nconst vec3 dot_col=vec3(0);\nconst vec3 line_col=vec3(0);\nconst vec3 bezier_col=vec3(0,0,1);\nconst vec3 arc_col=vec3(1,0,0);\nconst vec3 bg_col=vec3(1);\n\nconst float dot_size=.004;\nconst float line_width=.001;\n\nconst float zoom=1.;\n\nconst float pi=3.1415925;\n\nconst float eps = .000005;\n\nvec2 parametric_cubic_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a1 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a2 = (-3. * p0 + 3. * p1);\n\tvec2 a3 = p0;\n\n\treturn (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tvec4 t0=vec4(0.,.25,.75,1.);\n\tfloat t;\n\n\tfor(int i=0;i<3;i++){\n\t\tt=t0[i];\n\t\tfor(int j=0;j<3;j++){\n\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat cubic_bezier_dis_approx(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\treturn sqrt(cubic_bezier_dis_approx_sq(uv,p0,p1,p2,p3));\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\n\tfloat f,f1;\n\tr[0] = offset + u * (m + m);\n\n\tf = ((r[0] + a) * r[0] + b) * r[0] + c;\n\tf1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\tr[0] -= f / f1;\n\n\tr[1] = offset - u * (n + m);\n\n\tf = ((r[1] + a) * r[1] + b) * r[1] + c;\n\tf1=(3. * r[1] + 2. * a) * r[1] + b;\n\n\tr[1] -= f / f1;\n\n\tr[2] = offset + u * (n - m);\n\n\tf = ((r[2] + a) * r[2] + b) * r[2] + c;\n\tf1 = (3. * r[2] + 2. * a) * r[2] + b;\n\n\tr[2] -= f / f1;\n\n\treturn 3;\n}\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    /*  substitute x = y - A/4 to eliminate cubic term:\n\tx^4 + px^2 + qx + r = 0 */\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t/* doesn't seem to happen for me */\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0]= z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp=vec2(1e38);\n\t\tint old_num=num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n\n\t\t//s[old_num] = tmp[0];\n\t\t//s[old_num+1] = tmp[1];\n\n\t\tif(old_num == 0){\n            s[0] = tmp[0];\n            s[1] = tmp[1];\n        }\n        else{//old_num == 2\n            s[2] = tmp[0];\n            s[3] = tmp[1];\n        }\n\n    }\n\n    /* resubstitute */\n\n    float sub = 1./4. * a;\n\n\t/* single halley iteration to fix cancellation */\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n\n    return num;\n}\n\nfloat segment_dis( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec2 incenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec2 v1=normalize(p1-p0);\n\tvec2 v2=normalize(p2-p0);\n\n\tvec2 v3=normalize(p2-p1);\n\tvec2 v4=normalize(p0-p1);\n\n\tvec3 line1, line2;\n\tline1.xy=(v1+v2)/2.;\n\tline1.xy=vec2(-line1.y,line1.x);\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=(v3+v4)/2.;\n\tline2.xy=vec2(-line2.y,line2.x);\n\tline2.z=-dot(line2.xy,p1);\n\n\tvec3 l12=cross(line1,line2);\n\n\treturn l12.xy/l12.z;\n}\n\nvec2 circumcenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec3 line1, line2;\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,(p0+p1)/2.);\n\n\tline2.xy=p2-p1;\n\tline2.z=-dot(line2.xy,(p1+p2)/2.);\n\n\tvec3 m1=cross(line1,line2);\n\tm1/=m1.z;\n\n\treturn m1.xy;\n}\n\nvec2 compute_best_node(vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec3 line1, line2, line3, line4;\n\n\tline1.xy=p1-p0;\n\tline1.xy=vec2(line1.y,-line1.x);\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=p3-p2;\n\tline2.xy=vec2(line2.y,-line2.x);\n\tline2.z=-dot(line2.xy,p2);\n\n\tvec3 l12=cross(line1,line2);\n\n\tvec2 m0=l12.xy/l12.z;\n\tvec2 m1=incenter(p0,m0,p3);\n\tvec2 m2=circumcenter(p0,m1,p3);\n\n\tline3.xy=m2-p0;\n\tline3.z=-dot(line3.xy,p0);\n\n\tline4.xy=p3-p0;\n\tline4.z=-dot(line4.xy,(p0+p3)/2.);\n\n\tvec3 l34=cross(line3,line4);\n\tvec2 m3=l34.xy/l34.z;\n\n\tvec2 a3=(-p0+3.* p1-3.*p2+p3);\n\tvec2 a2=(3.*p0-6.*p1+3.*p2);\n\tvec2 a1=(-3.*p0+3.*p1);\n\n\tvec2 a0_1=p0-m2;\n\tvec2 a0_2=p0-m3;\n\n\tfloat b5=dot(a3,a3);\n\tfloat b4=2.*dot(a3,a2);\n\tfloat b3=dot(a2,a2) + 2.*dot(a1,a3);\n\n\tfloat b2_1=2.*(dot(a1,a2) + dot(a0_1,a3));\n\tfloat b2_2=2.*(dot(a1,a2) + dot(a0_2,a3));\n\n\tfloat b1_1=dot(a1,a1) + 2.*dot(a0_1,a2);\n\tfloat b1_2=dot(a1,a1) + 2.*dot(a0_2,a2);\n\n\tfloat c4=b5;\n\tfloat c3=b4+c4;\n\tfloat c2=b3+c3;\n\n\tfloat c1_1=b2_1+c2;\n\tfloat c1_2=b2_2+c2;\n\n\tfloat c0_1=b1_1+c1_1;\n\tfloat c0_2=b1_2+c1_2;\n\n\tvec4 roots_1 = vec4(1e38);\n\tint num_roots_1 = solve_quartic(vec4(c0_1,c1_1,c2,c3)/c4,roots_1);\n\n\tfor(int i=0;i<num_roots_1;i++){\n\t\tif(roots_1[i] > 0. && roots_1[i] < 1.){\n\t\t\treturn parametric_cubic_bezier(roots_1[i],p0,p1,p2,p3);\n\t\t}\n\t}\n\n\tvec4 roots_2 = vec4(1e38);\n\tint num_roots_2 = solve_quartic(vec4(c0_2,c1_2,c2,c3)/c4,roots_2);\n\n\tfor(int i=0;i<num_roots_2;i++){\n\t\tif(roots_2[i] > 0. && roots_2[i] < 1.){\n\t\t\treturn parametric_cubic_bezier(roots_2[i],p0,p1,p2,p3);\n\t\t}\n\t}\n\n\treturn m1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n\tmouse*=zoom;\n\n\tvec2 p0=vec2(-.3,-.1);\n\t#ifdef MOVE_NODE\n\tvec2 p1=vec2(-.4,.2);\n\t#else\n\tvec2 p1=mouse;\n    // Animate if mouse is in left bottom corner\n    if(max(iMouse.x, iMouse.y) < 20.){\n        p1=vec2(-.2,.0)+vec2(.1*sin(iTime),.2*cos(iTime));\n    }\n\t#endif\n\tvec2 p2=vec2(.1,-.2);\n\tvec2 p3=vec2(.2,.15);\n\n\tvec3 line0, line1, line2, line3, line4, line5, line6, line7;\n\n\t// Tangent in p0\n\n\tline0.xy=p0-p1;\n\tline0.xy=normalize(vec2(line0.y,-line0.x));\n\tline0.z=-dot(line0.xy,p0);\n\n\t// Tangent in p3\n\n\tline1.xy=p2-p3;\n\tline1.xy=normalize(vec2(line1.y,-line1.x));\n\tline1.z=-dot(line1.xy,p3);\n\n\t// Tangent intersection point\n\tvec3 l01=cross(line0,line1);\n\tvec2 p4=l01.xy/l01.z;\n\n\t#ifdef MOVE_NODE\n\tvec2 node=mouse;\n\t#else\n\tvec2 node=compute_best_node(p0,p1,p2,p3);\n\t#endif\n\n\tvec3 color=bg_col;\n\n\t// Show segments\n\tfloat dis=segment_dis(uv,p0,p1)-line_width;\n\tdis=min(dis,segment_dis(uv,p1,p2)-line_width);\n\tdis=min(dis,segment_dis(uv,p2,p3)-line_width);\n\tcolor=mix(line_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show cubic bezier curve\n\tdis=cubic_bezier_dis_approx(uv,p0,p1,p2,p3)-line_width;\n\tcolor=mix(bezier_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Line at p0 perpendicular to the segment between p0 and p1\n\tline2.xy=p4-p0;\n\tline2.z=-dot(line2.xy,p0);\n\n\t// Perpendicular bisector of segment between p0 and node\n\tline3.xy=node-p0;\n\tline3.z=-dot(line3.xy,(p0+node)/2.);\n\n\t// Line at p3 perpendicular to the segment between p2 and p3\n\tline4.xy=p3-p4;\n\tline4.z=-dot(line4.xy,p3);\n\n\t// Perpendicular bisector of segment between p3 and node\n\tline5.xy=node-p3;\n\tline5.z=-dot(line5.xy,(p3+node)/2.);\n\n\t// The midpoint of the first arc\n\tvec3 l23=cross(line2,line3);\n\tvec2 m1=l23.xy/l23.z;\n\tfloat r1=distance(m1,p0);\n\n\t// The midpoint of the second arc\n\tvec3 l45=cross(line4,line5);\n\tvec2 m2=l45.xy/l45.z;\n\tfloat r2=distance(m2,p3);\n\n\tvec2 m3=incenter(p0,p4,p3);\n\n\t// The midpoint of the first green circle\n\tvec2 m4=circumcenter(p0,m3,p3);\n\tfloat r4=distance(p0,m4);\n\n\t// Line at p0 perpendicular to the first green circle\n\tline6.xy=m4-p0;\n\tline6.z=-dot(line6.xy,p0);\n\n\t// Perpendicular bisector of segment between p0 and p3\n\tline7.xy=p3-p0;\n\tline7.z=-dot(line7.xy,(p0+p3)/2.);\n\n\t// The midpoint of the second green circle\n\tvec3 l67=cross(line6,line7);\n\tvec2 m5=l67.xy/l67.z;\n\tfloat r5=distance(p0,m5);\n\n\t// Show red circles (arcs)\n\tdis=abs(distance(m1,uv)-r1)-line_width;\n\tdis=min(dis,abs(distance(m2,uv)-r2)-line_width);\n\tcolor=mix(arc_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show green circles\n\tdis=abs(distance(m4,uv)-r4)-line_width;\n\tdis=min(dis,abs(distance(m5,uv)-r5)-line_width);\n\tcolor=mix(vec3(0,1,0),color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show dots\n\tdis=distance(p0,uv)-dot_size;\n\tdis=min(dis,distance(uv,p1)-dot_size);\n\tdis=min(dis,distance(uv,p2)-dot_size);\n\tdis=min(dis,distance(uv,p3)-dot_size);\n\tdis=min(dis,distance(uv,p4)-dot_size);\n\tdis=min(dis,distance(uv,node)-dot_size);\n\tdis=min(dis,distance(m1,uv)-dot_size);\n\tdis=min(dis,distance(m2,uv)-dot_size);\n\tdis=min(dis,distance(m3,uv)-dot_size);\n\tdis=min(dis,distance(m4,uv)-dot_size);\n\tdis=min(dis,distance(m5,uv)-dot_size);\n\tcolor=mix(dot_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tfragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltfDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[960, 960, 1034, 1034, 1215], [1217, 1217, 1298, 1317, 1492], [1494, 1494, 1572, 1572, 1995], [1997, 1997, 2072, 2072, 2132], [2134, 2255, 2304, 2342, 2555], [2557, 2642, 2685, 2685, 3914], [3916, 3916, 3962, 3962, 4238], [4240, 4361, 4406, 4406, 6373], [6375, 6375, 6419, 6419, 6529], [6531, 6531, 6572, 6572, 6927], [6929, 6929, 6974, 6974, 7160], [7162, 7162, 7221, 7221, 8703], [8705, 8705, 8759, 8759, 12227]], "test": "untested"}
{"id": "NldBDs", "name": "Biarc cubic Bezier approx", "author": "NinjaKoala", "description": "Approximating a cubic bezier curve with a biarc.\nTechnique is similar to the one in https://www.shadertoy.com/view/7tcBDl\nbut for cubic bezier curves this time.\n\nRed: Biarc\nGreen: Bezier\n\nMove control point with mouse", "tags": ["2d", "distancefield", "bezier", "beziercurve", "spline", "curve", "cubic", "arc", "biarc"], "likes": 5, "viewed": 249, "published": 3, "date": "1663848458", "time_retrieved": "2024-07-30T16:30:12.109170", "image_code": "/*\nSee https://www.shadertoy.com/view/NltfDs for some explanation.\n*/\n\n//#define DISTANCE_FIELD /* Show distance field */\n\nconst vec3 dot_col=vec3(0,0,1);\nconst vec3 line_col=vec3(0,0,1);\nconst vec3 bezier_col=vec3(0,1,0);\nconst vec3 arc_col=vec3(1,0,0);\nconst vec3 bg_col=vec3(1);\n\nconst float dot_size=.004;\nconst float line_width=.001;\n\nconst float zoom=1.;\n\nconst float pi=3.1415925;\n\nconst float eps = .000005;\n\nvec2 parametric_cubic_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a1 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a2 = (-3. * p0 + 3. * p1);\n\tvec2 a3 = p0;\n\n\treturn (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tvec4 t0=vec4(0.,.25,.75,1.);\n\tfloat t;\n\n\tfor(int i=0;i<4;i++){\n\t\tt=t0[i];\n\t\tfor(int j=0;j<3;j++){\n\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat cubic_bezier_dis_approx(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\treturn sqrt(cubic_bezier_dis_approx_sq(uv,p0,p1,p2,p3));\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\n\tfloat f,f1;\n\tr[0] = offset + u * (m + m);\n\n\tf = ((r[0] + a) * r[0] + b) * r[0] + c;\n\tf1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\tr[0] -= f / f1;\n\n\tr[1] = offset - u * (n + m);\n\n\tf = ((r[1] + a) * r[1] + b) * r[1] + c;\n\tf1=(3. * r[1] + 2. * a) * r[1] + b;\n\n\tr[1] -= f / f1;\n\n\tr[2] = offset + u * (n - m);\n\n\tf = ((r[2] + a) * r[2] + b) * r[2] + c;\n\tf1 = (3. * r[2] + 2. * a) * r[2] + b;\n\n\tr[2] -= f / f1;\n\n\treturn 3;\n}\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    /*  substitute x = y - A/4 to eliminate cubic term:\n\tx^4 + px^2 + qx + r = 0 */\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t/* doesn't seem to happen for me */\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0]= z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp=vec2(1e38);\n\t\tint old_num=num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n\n\t\t//s[old_num] = tmp[0];\n\t\t//s[old_num+1] = tmp[1];\n\n\t\tif(old_num == 0){\n            s[0] = tmp[0];\n            s[1] = tmp[1];\n        }\n        else{//old_num == 2\n            s[2] = tmp[0];\n            s[3] = tmp[1];\n        }\n\n    }\n\n    /* resubstitute */\n\n    float sub = 1./4. * a;\n\n\t/* single halley iteration to fix cancellation */\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n\n    return num;\n}\n\nfloat segment_dis( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvec2 incenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec2 v1=normalize(p1-p0);\n\tvec2 v2=normalize(p2-p0);\n\n\tvec2 v3=normalize(p2-p1);\n\tvec2 v4=normalize(p0-p1);\n\n\tvec3 line1, line2;\n\tline1.xy=(v1+v2)/2.;\n\tline1.xy=vec2(-line1.y,line1.x);\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=(v3+v4)/2.;\n\tline2.xy=vec2(-line2.y,line2.x);\n\tline2.z=-dot(line2.xy,p1);\n\n\tvec3 l12=cross(line1,line2);\n\n\treturn l12.xy/l12.z;\n}\n\nvec2 circumcenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec3 line1, line2;\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,(p0+p1)/2.);\n\n\tline2.xy=p2-p1;\n\tline2.z=-dot(line2.xy,(p1+p2)/2.);\n\n\tvec3 m1=cross(line1,line2);\n\tm1/=m1.z;\n\n\treturn m1.xy;\n}\n\nvec2 compute_best_node(vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec3 line1, line2, line3, line4;\n\n\tline1.xy=p1-p0;\n\tline1.xy=vec2(line1.y,-line1.x);\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=p3-p2;\n\tline2.xy=vec2(line2.y,-line2.x);\n\tline2.z=-dot(line2.xy,p2);\n\n\tvec3 l12=cross(line1,line2);\n\n\tvec2 m0=l12.xy/l12.z;\n\tvec2 m1=incenter(p0,m0,p3);\n\tvec2 m2=circumcenter(p0,m1,p3);\n\n\tline3.xy=m2-p0;\n\tline3.z=-dot(line3.xy,p0);\n\n\tline4.xy=p3-p0;\n\tline4.z=-dot(line4.xy,(p0+p3)/2.);\n\n\tvec3 l34=cross(line3,line4);\n\tvec2 m3=l34.xy/l34.z;\n\n\tvec2 a3=(-p0+3.* p1-3.*p2+p3);\n\tvec2 a2=(3.*p0-6.*p1+3.*p2);\n\tvec2 a1=(-3.*p0+3.*p1);\n\n\tvec2 a0_1=p0-m2;\n\tvec2 a0_2=p0-m3;\n\n\tfloat b5=dot(a3,a3);\n\tfloat b4=2.*dot(a3,a2);\n\tfloat b3=dot(a2,a2) + 2.*dot(a1,a3);\n\n\tfloat b2_1=2.*(dot(a1,a2) + dot(a0_1,a3));\n\tfloat b2_2=2.*(dot(a1,a2) + dot(a0_2,a3));\n\n\tfloat b1_1=dot(a1,a1) + 2.*dot(a0_1,a2);\n\tfloat b1_2=dot(a1,a1) + 2.*dot(a0_2,a2);\n\n\tfloat c4=b5;\n\tfloat c3=b4+c4;\n\tfloat c2=b3+c3;\n\n\tfloat c1_1=b2_1+c2;\n\tfloat c1_2=b2_2+c2;\n\n\tfloat c0_1=b1_1+c1_1;\n\tfloat c0_2=b1_2+c1_2;\n\n\tvec4 roots_1 = vec4(1e38);\n\tint num_roots_1 = solve_quartic(vec4(c0_1,c1_1,c2,c3)/c4,roots_1);\n\n\tfor(int i=0;i<num_roots_1;i++){\n\t\tif(roots_1[i] > 0. && roots_1[i] < 1.){\n\t\t\treturn parametric_cubic_bezier(roots_1[i],p0,p1,p2,p3);\n\t\t}\n\t}\n\n\tvec4 roots_2 = vec4(1e38);\n\tint num_roots_2 = solve_quartic(vec4(c0_2,c1_2,c2,c3)/c4,roots_2);\n\n\tfor(int i=0;i<num_roots_2;i++){\n\t\tif(roots_2[i] > 0. && roots_2[i] < 1.){\n\t\t\treturn parametric_cubic_bezier(roots_2[i],p0,p1,p2,p3);\n\t\t}\n\t}\n\n\treturn m1;\n}\n\nvec2 compute_arc_midpoint(vec2 p0, vec2 p1, vec2 p2){\n\tvec3 line1, line2;\n\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=p2-p0;\n\tline2.z=-dot(line2.xy,(p0+p2)/2.);\n\n\tvec3 l12=cross(line1,line2);\n\n\treturn l12.xy/l12.z;\n}\n\nfloat arc_dis(vec2 uv, vec2 p0, vec2 p1, vec2 m0, float r0){\n\tvec2 m1=normalize((p0+p1)/2.-m0);\n\t\n\tif(dot(m1,normalize(uv-m0))>dot(m1,normalize(p0-m0))){\n\t\treturn abs(distance(uv,m0)-r0);\n\t}\n\telse{\n\t\treturn min(distance(uv,p0),distance(uv,p1));\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n\tmouse*=zoom;\n\n\tvec2 p0=vec2(-.3,-.1);\n\tvec2 p1=mouse;\n\tvec2 p2=vec2(.1,-.2);\n\tvec2 p3=vec2(.2,.15);\n    \n    // Animate if mouse is in left bottom corner\n    if(max(iMouse.x, iMouse.y) < 20.){\n        p1=vec2(-.2,.0)+vec2(.1*sin(iTime),.2*cos(iTime));\n    }\n\n\tvec2 node=compute_best_node(p0,p1,p2,p3);\n\n\tvec2 m1=compute_arc_midpoint(p0,p1,node);\n\tfloat r1=distance(m1,p0);\n\n\tvec2 m2=compute_arc_midpoint(p3,p2,node);\n\tfloat r2=distance(m2,p3);\n\n\tvec3 color=bg_col;\n\tfloat dis=1e38;\n\n\t#ifdef DISTANCE_FIELD\n\tfloat sgn=1.;\n\n\tdis=arc_dis(uv,p0,node,m1,r1);\n\tdis=min(dis,arc_dis(uv,p3,node,m2,r2));\n\n\t//iq's sd color scheme\n\tcolor = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0 * abs(dis));\n\tcolor *= 0.8 + 0.2*cos(480.0*abs(dis));\n\tcolor = mix(color, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(dis)));\n\t#endif\n\n\tdis=segment_dis(uv,p0,p1)-line_width;\n\tdis=min(dis,segment_dis(uv,p1,p2)-line_width);\n\tdis=min(dis,segment_dis(uv,p2,p3)-line_width);\n\tcolor=mix(line_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tdis=cubic_bezier_dis_approx(uv,p0,p1,p2,p3)-line_width;\n\tcolor=mix(bezier_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t#ifndef DISTANCE_FIELD\n\tdis=arc_dis(uv,p0,node,m1,r1)-line_width;\n\tdis=min(dis,arc_dis(uv,p3,node,m2,r2)-line_width);\n\tcolor=mix(arc_col,color,smoothstep(-border/2.,border/2.,dis));\n\t#endif\n\n\tdis=distance(p0,uv)-dot_size;\n\tdis=min(dis,distance(uv,p1)-dot_size);\n\tdis=min(dis,distance(uv,p2)-dot_size);\n\tdis=min(dis,distance(uv,p3)-dot_size);\n\tcolor=mix(dot_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tfragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[417, 417, 491, 491, 672], [674, 674, 755, 774, 949], [951, 951, 1029, 1029, 1452], [1454, 1454, 1529, 1529, 1589], [1591, 1712, 1761, 1799, 2012], [2014, 2099, 2142, 2142, 3371], [3373, 3373, 3419, 3419, 3695], [3697, 3818, 3863, 3863, 5830], [5832, 5832, 5876, 5876, 5986], [5988, 5988, 6029, 6029, 6384], [6386, 6386, 6431, 6431, 6617], [6619, 6619, 6678, 6678, 8160], [8162, 8162, 8215, 8215, 8391], [8393, 8393, 8453, 8453, 8642], [8644, 8644, 8698, 8698, 10520]], "test": "untested"}
{"id": "sl3fDs", "name": "Something in the Stars!", "author": "tehsauce", "description": "sphere analytical grad test", "tags": ["test", "sphere", "grad"], "likes": 1, "viewed": 211, "published": 3, "date": "1663817234", "time_retrieved": "2024-07-30T16:30:12.867144", "image_code": "\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nvec3 sdgSMin( in vec3 a, in vec3 b, in float k )\n{\n    float h = max(k-abs(a.x-b.x),0.0);\n    float m = 0.25*h*h/k; // [0 - k/4] for [|a-b|=k - |a-b|=0]\n    float n = 0.50*  h/k; // [0 - 1/2] for [|a-b|=k - |a-b|=0]\n    return vec3( min(a.x,  b.x) - m, \n                 mix(a.yz, b.yz, (a.x<b.x)?n:1.0-n) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ouv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float d = 1000.0;\n    \n    vec3 dg = vec3(0.0);\n    \n    for (int i=0; i<15; i++) {\n        float v = float(i);\n        vec2 p = 0.2*vec2(sin(45.2*v+1.1*iTime), cos(61.1*v+iTime));\n            float ds = distance(p, uv) - 0.1;\n        vec3 sg = vec3(ds, normalize(p-uv));\n        d = smin(d, ds, 0.3);\n        dg = sdgSMin(sg, dg, 0.3);\n    }\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.5*sin(74.0*length(dg))+0.5);\n    //vec3(smoothstep(0.04, 0.0, d), dg);\n    //col = vec3(dg.yz, 0.0);\n    float mag = 1.0;//smoothstep(-0.1,0.1, d);\n    vec4 tex = texture(iChannel0, ouv+mag*0.35*dg.yz);\n    // Output to screen\n    fragColor = tex;\n    //fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3fDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 42, 42, 126], [128, 128, 178, 178, 438], [440, 440, 497, 547, 1374]], "test": "untested"}
{"id": "7lcfWs", "name": "Broken Text", "author": "SnoopethDuckDuck", "description": "i typed random things and stuff happened", "tags": ["e"], "likes": 3, "viewed": 206, "published": 3, "date": "1663812158", "time_retrieved": "2024-07-30T16:30:13.634093", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nvec3 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\nvec3 cell2(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel1, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel1, p, 0 ).rgb;\n}\n\nfloat h21 (float a, float b, float r) {\n    a = mod(a, r); b = mod(b, r);\n    return fract(sin(dot(vec2(a, b), vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragCoord += 10. * iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float sc = 8.;\n    vec2 ipos = floor(sc * uv);\n    vec2 fpos = fract(sc * uv);\n\n    float h = h21(ipos.x, ipos.y, 301.);\n    vec3 col = cell(ivec2(fpos * 64. + vec2(13, 17) * floor(iTime + 64. * h) * 64.));\n   // float v = length(col.gb);   \n    vec2 uv2 = col.bg - 0.5;\n    float d = length(uv2);\n    float k = sc * 2. / iResolution.y;\n    float s = step(0.9 + 0.1 * cos(2. * pi * h + iTime), abs(col.r-col.b));\n    s += smoothstep(-k, k, -d + 0.45);\n    col *= vec3(s);\n    col += 0.01;\n    fragCoord *= 2. * col.r * 3.;\n    vec3 col3 = 4. * cell2(ivec2(fragCoord));\n    // forgot uv=col.bg-0.5 when I wrote this (but looks cool)\n    col += exp(-2. * length(uv2 - 0.5));\n    col /= col3;\n\n    col = clamp(col, 0., 1.);\n    float mx = (0.75 + 0.25 * thc(2., iResolution.y * 0.5 * ouv.y+ 0.5 * iTime)) / cosh(2. * length(ouv));\n    col = mix(col, 0.7 * col3 * col.r , 1.-mx);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcfWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 83, 83, 197], [199, 199, 223, 223, 337], [339, 339, 378, 378, 491], [493, 493, 550, 550, 1605]], "test": "untested"}
{"id": "slcfWs", "name": "Simple truchet pattern", "author": "fishy", "description": "Turns out this effect is easier than I thought. Mouse controls how many tiles are flipped", "tags": ["sdf", "truchet"], "likes": 2, "viewed": 186, "published": 3, "date": "1663811492", "time_retrieved": "2024-07-30T16:30:14.400045", "image_code": "#define tiles 10.0\n\nfloat hash21(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat sdfTile(in vec2 p, float r, float t, bool rot)\n{\n    p.x = rot? 1.0 - p.x : p.x;\n    return abs(min(length(p), length(p - vec2(1.0))) - r) - t;\n}\n\nvec2 stepPoint(vec2 p, float c)\n{\n    return floor(p * c) / c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv += 0.5;\n    uv.x += iTime*0.3;\n    uv.y += sin(iTime)*0.2;\n    float px = tiles/iResolution.y;\n    \n    vec2 tileUv = fract(uv * tiles);\n    float tile = hash21(stepPoint(uv, tiles));\n    \n    \n    float col = smoothstep(0.0, px, sdfTile(tileUv, 0.5, 0.05, tile < (iMouse.z > 0.0? iMouse.y/iResolution.y : 0.5)));\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcfWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 46, 46, 163], [165, 165, 219, 219, 316], [318, 318, 351, 351, 382], [384, 384, 441, 441, 899]], "test": "untested"}
{"id": "sl3BWs", "name": "Biarc quad Bezier approx expl.", "author": "NinjaKoala", "description": "This shader is visualizing the construction used in https://www.shadertoy.com/view/7tcBDl.\nSee top comment for explanation.\n\nMove control point with mouse.", "tags": ["2d", "bezier", "beziercurve", "spline", "curve", "quadratic", "arc", "biarc"], "likes": 6, "viewed": 188, "published": 3, "date": "1663806699", "time_retrieved": "2024-07-30T16:30:15.155028", "image_code": "/*\nA circle can be defined by three points.\nAlternatively, one can use two points and one tangent.\n(This is the limit case when one point tends to another point).\n\nYou often want to have a curve (spline) connecting\ntwo points with a certain tangent at both points.\n\nFor this, you can use a biarc, where two arcs\nconnect two points with a predetermined tangent\nat both points. You have some freedom to choose\nthe point at which you connect both arcs.\n(I'm calling that the node)\n\nYou want the arcs to connect smoothly,\nwhich restricts the possible nodes to\nthe points lying on two circles\n(Shown in green)\n\nThe incenter of the black triangle is always\non one of the two green circles.\n(This is used to construct it)\n\nThe second green circle also goes through the endpoints,\nand intersects the first circle perpendicularly in the endpoints.\n\nOne heuristic is to just use the incenter as node.\n\nAnother is to compute the intersection point of the quadratic bezier\ncurve and the green circle going through the incenter.\n\nThis follows the quadratic bezier curve more closely,\nbut is a bit more difficult to compute.\n*/\n\n//#define INCENTER /* Use the incenter heuristic instead */\n//#define MOVE_NODE /* Move the node with the mouse instead */\n\nconst vec3 dot_col=vec3(0);\nconst vec3 line_col=vec3(0);\nconst vec3 bezier_col=vec3(0,0,1);\nconst vec3 arc_col=vec3(1,0,0);\nconst vec3 bg_col=vec3(1);\n\nconst float dot_size=.004;\nconst float line_width=.001;\n\nconst float zoom=1.;\n\nconst float pi=3.1415925;\n\nvec2 parametric_quadratic_bezier(float t, vec2 p0, vec2 p1, vec2 p2){\n\treturn mix(mix(p0,p1,t),mix(p1,p2,t),t);\n}\n\nfloat quadratic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2){\n\tvec2 a_1=a1+t*a2;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*a2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat quadratic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\tvec2 a2 = p0 - 2. * p1 + p2;\n\tvec2 a1 = -2. * p0 + 2. * p1;\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tvec3 t0=vec3(0.,.5,1.);\n\tfloat t;\n\n\tfor(int i=0;i<3;i++){\n\t\tt=t0[i];\n\t\tfor(int j=0;j<3;j++){\n\t\t\tt=quadratic_bezier_normal_iteration(t,a0,a1,a2);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=(a2*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat quadratic_bezier_dis_approx(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\treturn sqrt(quadratic_bezier_dis_approx_sq(uv,p0,p1,p2));\n}\n\nfloat segment_dis(vec2 p, vec2 a, vec2 b){\n\tvec2 pa=p-a, ba=b-a;\n\tfloat h=clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa-ba*h);\n}\n\n// Compute the incenter of the triangle given by p0, p1, p2\nvec2 incenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec2 v1=normalize(p1-p0);\n\tvec2 v2=normalize(p2-p0);\n\n\tvec2 v3=normalize(p2-p1);\n\tvec2 v4=normalize(p0-p1);\n\n\tvec3 line1, line2;\n\tline1.xy=(v1+v2)/2.;\n\tline1.xy=vec2(-line1.y,line1.x);\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=(v3+v4)/2.;\n\tline2.xy=vec2(-line2.y,line2.x);\n\tline2.z=-dot(line2.xy,p1);\n\n\tvec3 l12=cross(line1,line2);\n\n\treturn l12.xy/l12.z;\n}\n\n// Compute the circumcenter of the triangle given by p0, p1, p2\nvec2 circumcenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec3 line1, line2;\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,(p0+p1)/2.);\n\n\tline2.xy=p2-p1;\n\tline2.z=-dot(line2.xy,(p1+p2)/2.);\n\n\n\tvec3 m1=cross(line1,line2);\n\tm1/=m1.z;\n\n\treturn m1.xy;\n}\n\n// Compute the point at which the two arcs should be connected\n// in order to best approximate a quadratic bezier curve.\nvec2 compute_best_node(vec2 p0, vec2 p1, vec2 p2){\n\tvec2 m1=incenter(p0,p1,p2);\n\tvec2 m2=circumcenter(p0,m1,p2);\n\n\tvec2 a2=p0-2.*p1+p2;\n\tvec2 a1=2.*(p1-p0);\n\tvec2 a0=p0-m2;\n\n\tfloat b3=dot(a2,a2);\n\tfloat b2=2.*dot(a2,a1);\n\tfloat b1=2.*dot(a2,a0)+dot(a1,a1);\n\n\tfloat c2=b3;\n\tfloat c1=b2+b3;\n\tfloat c0=b1+b2+b3;\n\n\tfloat discriminant=c1*c1-4.*c2*c0;\n\n\tif(discriminant < 0.){\n\t\treturn m1;\n\t}\n\n\tfloat disc_sq=sqrt(discriminant);\n\n\tfloat root1=(-c1-disc_sq)/(2.*c2);\n\tfloat root2=(-c1+disc_sq)/(2.*c2);\n\n\tif(root1 > 0. && root1 < 1.){\n\t\treturn parametric_quadratic_bezier(root1,p0,p1,p2);\n\t}\n\telse if(root2 > 0. && root2 < 1.){\n\t\treturn parametric_quadratic_bezier(root2,p0,p1,p2);\n\t}\n\telse{\n\t\treturn m1;\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n\tmouse*=zoom;\n    \n    // Quadratic bezier control points\n\n\tvec2 p0=vec2(-.2,-.2);\n    #ifndef MOVE_NODE\n\tvec2 p1=mouse;\n    // Animate if mouse is in left bottom corner\n    if(max(iMouse.x, iMouse.y) < 20.){\n        p1=vec2(-.26,.1)+vec2(.2*sin(iTime),.08*cos(iTime));\n    }\n    #else\n    vec2 p1=vec2(-.26,.1);\n    #endif\n\tvec2 p2=vec2(.2,-.2);\n\n    // Node (The point where the two arcs connect)\n\n    #ifdef MOVE_NODE\n\tvec2 p3=mouse;\n    #else\n    #ifdef INCENTER\n    vec2 p3=incenter(p0,p1,p2);\n    #else\n\tvec2 p3=compute_best_node(p0,p1,p2);\n    #endif\n    #endif\n\n\tvec3 color=bg_col;\n\n\t// Show segments\n\tfloat dis=segment_dis(uv,p0,p1)-line_width;\n\tdis=min(dis,segment_dis(uv,p1,p2)-line_width);\n\tcolor=mix(line_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show quadratic bezier curve\n\tdis=quadratic_bezier_dis_approx(uv,p0,p1,p2)-line_width;\n\tcolor=mix(bezier_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tvec3 line1, line2, line3, line4, line5, line6;\n\n\t// Line at p0 perpendicular to the segment between p0 and p1\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,p0);\n\n\t// Perpendicular bisector of segment between p0 and p3\n\tline2.xy=p3-p0;\n\tline2.z=-dot(line2.xy,(p0+p3)/2.);\n\n\tvec3 l12=cross(line1,line2);\n\n\t// Intersection of line1 and line2, the midpoint of the first arc\n\tvec2 m1=l12.xy/l12.z;\n\tfloat r1=distance(m1,p0);\n\n\t// Line at p0 perpendicular to the segment between p2 and p1\n\tline3.xy=p2-p1;\n\tline3.z=-dot(line3.xy,p2);\n\n\t// Perpendicular bisector of segment between p2 and p3\n\tline4.xy=p3-p2;\n\tline4.z=-dot(line4.xy,(p2+p3)/2.);\n\n\tvec3 l34=cross(line3,line4);\n\n\t// Intersection of line2 and line3, the midpoint of the second arc\n\tvec2 m2=l34.xy/l34.z;\n\tfloat r2=distance(m2,p2);\n\n\tvec2 m3=incenter(p0,p1,p2);\n\n\t// The midpoint of the first green circle\n\tvec2 m4=circumcenter(p0,m3,p2);\n\tfloat r4=distance(p0,m4);\n\n\t// Line at p0 perpendicular to the first green circle\n\tline5.xy=m4-p0;\n\tline5.z=-dot(line5.xy,p0);\n\n\t// Perpendicular bisector of segment between p0 and p2\n\tline6.xy=p2-p0;\n\tline6.z=-dot(line6.xy,(p0+p2)/2.);\n\n\tvec3 l56=cross(line5,line6);\n\n\t// The midpoint of the second green circle\n\tvec2 m5=l56.xy/l56.z;\n\tfloat r5=distance(p0,m5);\n\n\t// Show dots\n\tdis=distance(m1,uv)-dot_size;\n\tdis=min(dis,distance(m2,uv)-dot_size);\n\tdis=min(dis,distance(m3,uv)-dot_size);\n\tdis=min(dis,distance(m4,uv)-dot_size);\n\tdis=min(dis,distance(m5,uv)-dot_size);\n\tcolor=mix(dot_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show red circles (arcs)\n\tdis=abs(distance(m1,uv)-r1)-line_width;\n\tdis=min(dis,abs(distance(m2,uv)-r2)-line_width);\n\tcolor=mix(arc_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t// Show green circles\n\tdis=abs(distance(m4,uv)-r4)-line_width;\n\tdis=min(dis,abs(distance(m5,uv)-r5)-line_width);\n\tcolor=mix(vec3(0,1,0),color,smoothstep(-border/2.,border/2.,dis));\n\n\tdis=distance(uv,p0)-dot_size;\n\tdis=min(dis,distance(uv,p1)-dot_size);\n\tdis=min(dis,distance(uv,p2)-dot_size);\n\tdis=min(dis,distance(uv,p3)-dot_size);\n\tcolor=mix(dot_col,color,smoothstep(-border/2.,border/2.,dis));\n\t\n\n\tfragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3BWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1497, 1497, 1566, 1566, 1610], [1612, 1612, 1688, 1688, 1822], [1824, 1824, 1897, 1897, 2252], [2254, 2254, 2324, 2324, 2385], [2387, 2387, 2429, 2429, 2525], [2527, 2587, 2628, 2628, 2983], [2985, 3049, 3094, 3094, 3281], [3283, 3404, 3454, 3454, 4106], [4108, 4108, 4162, 4162, 7465]], "test": "untested"}
{"id": "7tcBDl", "name": "Biarc quadratic Bezier approx", "author": "NinjaKoala", "description": "Approximating a quadratic bezier curve with a biarc.\nInspired by https://www.shadertoy.com/view/sldXWl but using a different heuristic,\nwhich follows the quadratic bezier curve a bit more tightly.\n\nRed: Biarc\nGreen: Bezier\n\nMove control point with mouse", "tags": ["2d", "distancefield", "bezier", "beziercurve", "spline", "curve", "quadratic", "arc", "biarc"], "likes": 6, "viewed": 224, "published": 3, "date": "1663800492", "time_retrieved": "2024-07-30T16:30:15.915992", "image_code": "/*\nSee https://www.shadertoy.com/view/sl3BWs for some explanation.\n*/\n\n//#define INCENTER /* Use the incenter heuristic instead */\n//#define DISTANCE_FIELD /* Show distance field */\n\nconst vec3 dot_col=vec3(0,0,1);\nconst vec3 line_col=vec3(0,0,1);\nconst vec3 bezier_col=vec3(0,1,0);\nconst vec3 arc_col=vec3(1,0,0);\nconst vec3 bg_col=vec3(1);\n\nconst float dot_size=.004;\nconst float line_width=.001;\n\nconst float zoom=1.;\n\nconst float pi=3.1415925;\n\nvec2 parametric_quadratic_bezier(float t, vec2 p0, vec2 p1, vec2 p2){\n\treturn mix(mix(p0,p1,t),mix(p1,p2,t),t);\n}\n\nfloat quadratic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2){\n\tvec2 a_1=a1+t*a2;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*a2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat quadratic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\tvec2 a2=p0-2.*p1+p2;\n\tvec2 a1=-2.*p0 +2.*p1;\n\tvec2 a0=p0-uv;\n\n\tfloat d0=1e38;\n\n\tvec3 t0=vec3(0.,.5,1.);\n\tfloat t;\n\n\tfor(int i=0;i<3;i++){\n\t\tt=t0[i];\n\t\tfor(int j=0;j<3;j++){\n\t\t\tt=quadratic_bezier_normal_iteration(t,a0,a1,a2);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=(a2*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat quadratic_bezier_dis_approx(vec2 uv, vec2 p0, vec2 p1, vec2 p2){\n\treturn sqrt(quadratic_bezier_dis_approx_sq(uv,p0,p1,p2));\n}\n\nfloat segment_dis(vec2 p, vec2 a, vec2 b){\n\tvec2 pa=p-a, ba=b-a;\n\tfloat h=clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa-ba*h);\n}\n\nvec2 incenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec2 v1=normalize(p1-p0);\n\tvec2 v2=normalize(p2-p0);\n\n\tvec2 v3=normalize(p2-p1);\n\tvec2 v4=normalize(p0-p1);\n\n\tvec3 line1, line2;\n\tline1.xy=(v1+v2)/2.;\n\tline1.xy=vec2(-line1.y,line1.x);\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=(v3+v4)/2.;\n\tline2.xy=vec2(-line2.y,line2.x);\n\tline2.z=-dot(line2.xy,p1);\n\n\tvec3 l12=cross(line1,line2);\n\n\treturn l12.xy/l12.z;\n}\n\nvec2 circumcenter(vec2 p0, vec2 p1, vec2 p2){\n\tvec3 line1, line2;\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,(p0+p1)/2.);\n\n\tline2.xy=p2-p1;\n\tline2.z=-dot(line2.xy,(p1+p2)/2.);\n\n\tvec3 m1=cross(line1,line2);\n\tm1/=m1.z;\n\n\treturn m1.xy;\n}\n\nvec2 compute_best_node(vec2 p0, vec2 p1, vec2 p2){\n\tvec2 m1=incenter(p0,p1,p2);\n\tvec2 m2=circumcenter(p0,m1,p2);\n\n\tvec2 a2=p0-2.*p1+p2;\n\tvec2 a1=2.*(p1-p0);\n\tvec2 a0=p0-m2;\n\n\tfloat b3=dot(a2,a2);\n\tfloat b2=2.*dot(a2,a1);\n\tfloat b1=2.*dot(a2,a0)+dot(a1,a1);\n\n\tfloat c2=b3;\n\tfloat c1=b2+b3;\n\tfloat c0=b1+b2+b3;\n\n\tfloat discriminant=c1*c1-4.*c2*c0;\n\n\tif(discriminant < 0.){\n\t\treturn m1;\n\t}\n\n\tfloat disc_sq=sqrt(discriminant);\n\n\tfloat root1=(-c1-disc_sq)/(2.*c2);\n\tfloat root2=(-c1+disc_sq)/(2.*c2);\n\n\tif(root1 > 0. && root1 < 1.){\n\t\treturn parametric_quadratic_bezier(root1,p0,p1,p2);\n\t}\n\telse if(root2 > 0. && root2 < 1.){\n\t\treturn parametric_quadratic_bezier(root2,p0,p1,p2);\n\t}\n\telse{\n\t\treturn m1;\n\t}\n}\n\nvec2 compute_arc_midpoint(vec2 p0, vec2 p1, vec2 p2){\n\tvec3 line1, line2;\n\n\tline1.xy=p1-p0;\n\tline1.z=-dot(line1.xy,p0);\n\n\tline2.xy=p2-p0;\n\tline2.z=-dot(line2.xy,(p0+p2)/2.);\n\n\tvec3 l12=cross(line1,line2);\n\n\treturn l12.xy/l12.z;\n}\n\nfloat arc_dis(vec2 uv, vec2 p0, vec2 p1, vec2 m0, float r0){\n\tvec2 m1=normalize((p0+p1)/2.-m0);\n\t\n\tif(dot(m1,normalize(uv-m0))>dot(m1,normalize(p0-m0))){\n\t\treturn abs(distance(uv,m0)-r0);\n\t}\n\telse{\n\t\treturn min(distance(uv,p0),distance(uv,p1));\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat border=2./iResolution.x;\n\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n    uv.y*=iResolution.y/iResolution.x;\n\n\tvec2 mouse=iMouse.xy/iResolution.xy;\n\tmouse-=.5;\n    mouse.y*=iResolution.y/iResolution.x;\n\n\tborder*=zoom;\n\tuv*=zoom;\n\tmouse*=zoom;\n\n\tvec2 p0=vec2(-.2,-.2);\n\tvec2 p1=mouse;\n\tvec2 p2=vec2(.2,-.2);\n    \n    // Animate if mouse is in left bottom corner\n    if(max(iMouse.x, iMouse.y) < 20.){\n        p1=vec2(-.26,.1)+vec2(.2*sin(iTime),.08*cos(iTime));\n    }\n\n\t#ifdef INCENTER\n\tvec2 p3=incenter(p0,p1,p2);\n\t#else\n\tvec2 p3=compute_best_node(p0,p1,p2);\n\t#endif\n\n\tvec2 m1=compute_arc_midpoint(p0,p1,p3);\n\tfloat r1=distance(m1,p0);\n\n\tvec2 m2=compute_arc_midpoint(p2,p1,p3);\n\tfloat r2=distance(m2,p2);\n\n\tvec3 color=bg_col;\n\n\tfloat dis=1e38;\n\n\t#ifdef DISTANCE_FIELD\n\tfloat sgn=1.;\n\n\tdis=min(dis,arc_dis(uv,p0,p3,m1,r1));\n\tdis=min(dis,arc_dis(uv,p2,p3,m2,r2));\n\n\t//iq's sd color scheme\n\tcolor = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0 * abs(dis));\n\tcolor *= 0.8 + 0.2*cos(480.0*abs(dis));\n\tcolor = mix(color, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(dis)));\n\t#endif\n\n\tdis=segment_dis(uv,p0,p1)-line_width;\n\tdis=min(dis,segment_dis(uv,p1,p2)-line_width);\n\tcolor=mix(line_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tdis=quadratic_bezier_dis_approx(uv,p0,p1,p2)-line_width;\n\tcolor=mix(bezier_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\t#ifndef DISTANCE_FIELD\n\tdis=arc_dis(uv,p0,p3,m1,r1)-line_width;\n\tdis=min(dis,arc_dis(uv,p2,p3,m2,r2)-line_width);\n\tcolor=mix(arc_col,color,smoothstep(-border/2.,border/2.,dis));\n\t#endif\n    \n    dis=distance(uv,p0)-dot_size;\n\tdis=min(dis,distance(uv,p1)-dot_size);\n\tdis=min(dis,distance(uv,p2)-dot_size);\n\tcolor=mix(dot_col,color,smoothstep(-border/2.,border/2.,dis));\n\n\tfragColor=vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 449, 518, 518, 562], [564, 564, 640, 640, 774], [776, 776, 849, 849, 1183], [1185, 1185, 1255, 1255, 1316], [1318, 1318, 1360, 1360, 1456], [1458, 1458, 1499, 1499, 1854], [1856, 1856, 1901, 1901, 2087], [2089, 2089, 2139, 2139, 2791], [2793, 2793, 2846, 2846, 3022], [3024, 3024, 3084, 3084, 3273], [3275, 3275, 3329, 3329, 5104]], "test": "untested"}
{"id": "flcBDs", "name": "P-Norm infinity", "author": "sedcore", "description": "Raymarching 3D p-norm for varying p in [-1/2 .. 4]. Loops every 400 frames. Has some repetition in the 3d space.", "tags": ["raymarching", "repetition", "pnorm"], "likes": 2, "viewed": 200, "published": 3, "date": "1663790830", "time_retrieved": "2024-07-30T16:30:16.885400", "image_code": "/* Sed - P-Norm infinity - 2022 */\n\n/* GLSL adaptation of http://sedcore.eu.org/small/norm_infinity.c */\n/* comments were kept as is - useless c code removed */\n/* released in the public domain */\n/* not super efficient I guess */\n\n/* 16/9 aspect ratio expected - me too lazy to handle generic case */\n\n/* set this for full resolution (personally I like big pixels)\n * note that the computation time is the same in any case\n */\n//#define FULL_RESOLUTION\n\n/* 2022-09-07 */\n\n/* inspired by https://twitter.com/Marina_Costant/status/1560219380482539522 */\n\n/* gcc -Wall -o norm_infinity norm_infinity.c -lm -O3 -ffast-math -fomit-frame-pointer -march=native -fopenmp\n * ./norm_infinity > XX\n * ffmpeg -f rawvideo -s 640x360 -r 25 -pix_fmt bgra -i XX -vf palettegen palette.png\n * ffmpeg -f rawvideo -s 640x360 -r 25 -pix_fmt bgra -i XX -i palette.png -filter_complex paletteuse movie.gif\n *\n * or:\n * ffmpeg -f rawvideo -s 640x360 -r 25 -pix_fmt bgra -i XX -plays 0 movie.apng\n */\n\n/* not realtime at all, set delta = 0.05 or higher for faster but uglier */\n/* or improve dig_t(): we look for the smallest t>1 for which pnorm() = 1,\n * if it exists of course\n * also classic lookup tables, caching, and so on, can be done\n */\n\n/* linear interpolation, x is in [x0..x1] we want y in [y0..y1] such that\n * when x is x0 then y is y0 and when x is x1 then y is y1\n */\n/* x0   y0\n * x    y\n * x1   y1\n * (x-x0) / (x1-x0) = (y-y0) / (y1-y0)\n * y = y0 + (x-x0) / (x1-x0) * (y1-y0)\n */\n#define P3(x, x0, x1, y0, y1) ((y0) + ((x)-(x0)) / ((x1)-(x0)) * ((y1)-(y0)))\n\n#define rotate_x(x, y, z, angle)    {          \\\n  float y2 = y * cos(angle) - z * sin(angle); \\\n  float z2 = z * cos(angle) + y * sin(angle); \\\n  y = y2;                                      \\\n  z = z2;                                      \\\n}\n\n#define rotate_y(x, y, z, angle)    {          \\\n  float z2 = z * cos(angle) - x * sin(angle); \\\n  float x2 = x * cos(angle) + z * sin(angle); \\\n  x = x2;                                      \\\n  z = z2;                                      \\\n}\n\n#define rotate_z(x, y, z, angle)    {          \\\n  float x2 = x * cos(angle) - y * sin(angle); \\\n  float y2 = y * cos(angle) + x * sin(angle); \\\n  x = x2;                                      \\\n  y = y2;                                      \\\n}\n\nconst float M_PI = radians(180.);\n\n/****************************************************************************/\n/* bezier curve begin                                                       */\n/****************************************************************************/\n\n/* bezier curves are super nice for trajectories */\n\n#if 0\n\ntypedef struct {\n  float x;\n  float y;\n  float z;\n} point_t;\n\ntypedef struct {\n  point_t p0;\n  point_t p1;\n  point_t p2;\n  point_t p3;\n} bezier_t;\n\n#endif\n\n/* cubic bezier (4 control points) */\nvec3 bezier(in vec3 b[4], in float t)\n{\n  float _1_t = 1. - t;\n  float _1_t_2 = _1_t * _1_t;\n  float _1_t_3 = _1_t_2 * _1_t;\n  float t_2 = t * t;\n  float t_3 = t * t_2;\n  return vec3(\n    _1_t_3 * b[0].x + 3. * _1_t_2 * t * b[1].x + 3. * _1_t * t_2 * b[2].x + t_3 * b[3].x,\n    _1_t_3 * b[0].y + 3. * _1_t_2 * t * b[1].y + 3. * _1_t * t_2 * b[2].y + t_3 * b[3].y,\n    _1_t_3 * b[0].z + 3. * _1_t_2 * t * b[1].z + 3. * _1_t * t_2 * b[2].z + t_3 * b[3].z\n  );\n}\n\n/****************************************************************************/\n/* bezier curve end                                                         */\n/****************************************************************************/\n\n/****************************************************************************/\n/* camera management begin                                                  */\n/****************************************************************************/\n\n#define eye    camera[0]\n#define center camera[1]\n#define vx     camera[2]\n#define vy     camera[3]\n\n#if 0\n\n/* the 4 component of the camera array are defined as below */\ntypedef struct {\n  point_t eye;           /* position of the eye */\n  point_t center;        /* center of screen of camera */\n  point_t vx, vy;        /* unit vectors on screen */\n} camera_t;\n\n#endif\n\nvoid compute_camera(out vec3 camera[4], in float frame)\n{\n  float d;\n  float t;\n  float angle;\n\n  frame = mod(frame, 400.);\n\n  /* basic idea is to start the camera in front of cube (0,0,0) then move\n   * forward with some rotations for nice visual effect and end in front\n   * of cube (0,0,-24) so that we can loop the animation (the cube (0,0,-24)\n   * has the same neighbors as the cube (0,0,0), so we can loop)\n   */\n\n  /* position the eye */\n  /* eye movement is snakish, we start in front of cube (0,0,0) and end\n   * in front of cube (0,0,-24) turning around center of each cube on the path\n   */\n\n  if (frame < 100.) {\n    /* turn on the left */\n    angle = P3(frame, 0., 100., -M_PI/2., -3.*M_PI/2.);\n  } else if (frame < 200.) {\n    /* right */\n    angle = P3(frame, 100., 200., -M_PI/2., M_PI/2.);\n  } else if (frame < 300.) {\n    /* left */\n    angle = P3(frame, 200., 300., -M_PI/2., -3.*M_PI/2.);\n  } else {\n    /* right */\n    angle = P3(frame, 300., 400., -M_PI/2., M_PI/2.);\n  }\n  /* we start with a point pointing to the right: (3,0,0) */\n  vec3 p0 = vec3(3,0,0);\n  rotate_y(p0.x, p0.y, p0.z, angle);\n  /* we force z to move forward, the rotation-based stuff is ugly for z */\n  p0.z = P3(frame, 0., 100., 3., -3.);\n  /* move a bit closer to the shape */\n  p0.z += - .5;\n  /* tilt trajectory */\n  rotate_z(p0.x, p0.y, p0.z, M_PI/6.);\n\n  eye = p0;\n\n  /* position p1 (direction of camera from the eye) */\n  /* more or less going forward but some backward for not too much boring */\n  vec3 p1b[4];\n  p1b[0] = vec3(0, 0, 0);     /* start point */\n  p1b[1] = vec3(5, 3, 2);\n  p1b[2] = vec3(-5,-3, -46);\n  p1b[3] = vec3(0, 0, -24);   /* end point */\n  vec3 p1 = bezier(p1b, P3(frame, 0., 400., 0., 1.));\n\n  /* center is on vector (p1-p0) at right distance of the eye */\n  d = length(p1-p0); //sqrt((p1.x-p0.x)*(p1.x-p0.x) + (p1.y-p0.y)*(p1.y-p0.y) + (p1.z-p0.z)*(p1.z-p0.z));\n  /* right distance is 0.5 in front of eye (quite close, wide camera angle) */\n  t = 0.5 / d;\n  center = p0 + t * (p1 - p0);\n\n  p1 = center;\n\n  /* position p2 (anchor for angle of camera) (not sure if that means\n   * something, but it's clear in my head: 'eye' is where is the eye, 'center',\n   * is where the eye looks at, but then the camera can rotate around this\n   * center, so we need a third point to define this rotation, this is p2)\n   */\n  /* rotate a bit, not too much, more or less randomly chosen */\n  vec3 p2b[4];\n  p2b[0] = vec3(10, 0, 0);      /* start: no rotation, horizontal cam */\n  p2b[1] = vec3(-10, -10, 0);\n  p2b[2] = vec3(10, 10, -20);\n  p2b[3] = vec3(10, 0, -24);    /* end: no rotation, horizontal cam */\n  vec3 p2 = bezier(p2b, P3(frame, 0., 400., 0., 1.));\n\n  /* project p2 on plane perpendicular to vector (p1-p0) containing p1 */\n  /* vector (p2p-p2) and (p1-p0) are parallel: (p2p-p2) = t * (p1-p0)\n   * and scalar product (p2p-p1) x (p1-p0) = 0\n   * (p2 + t * (p1-p0) - p1) x (p1-p0) = 0\n   * (p2.x + t * (p1.x-p0.x) - p1.x) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = 0\n   * ((p2.x - p1.x) + t * (p1.x-p0.x)) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = 0\n   * (p2.x - p1.x) * (p1.x - p0.x) + t * (p1.x-p0.x) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = 0\n   * t * (p1.x-p0.x) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = -(p2.x - p1.x) * (p1.x - p0.x)\n   * t = (-(p2.x - p1.x) * (p1.x - p0.x) -(p2.y - p1.y) * (p1.y - p0.y) -(p2.z - p1.z) * (p1.z - p0.z)) /\n   *     ((p1.x-p0.x) * (p1.x - p0.x) + (p1.y-p0.y) * (p1.y - p0.y) + (p1.z-p0.z) * (p1.z - p0.z))\n   */\n  vec3 p2p;\n  t = (-(p2.x - p1.x) * (p1.x - p0.x) -(p2.y - p1.y) * (p1.y - p0.y) -(p2.z - p1.z) * (p1.z - p0.z)) /\n      ((p1.x-p0.x) * (p1.x - p0.x) + (p1.y-p0.y) * (p1.y - p0.y) + (p1.z-p0.z) * (p1.z - p0.z));\n  p2p = p2 + t * (p1 - p0);\n\n  /* vx is vector (p2p-p1) at right distance */\n  d = length(p2p - p1); //sqrt((p2p.x-p1.x)*(p2p.x-p1.x) + (p2p.y-p1.y)*(p2p.y-p1.y) + (p2p.z-p1.z)*(p2p.z-p1.z));\n  /* length (right distance) is 1/150 */\n  t = 1./150. / d;\n  vx = t * (p2p - p1);\n\n  /* vy is vectorial product of vx and vector (center-p0) */\n  vy = cross(vx, center - p0);\n  /* at the right length (also 1/150, as for vx) */\n  d = length(vy); //sqrt(ret.vy.x*ret.vy.x + ret.vy.y*ret.vy.y + ret.vy.z*ret.vy.z);\n  t = 1./150. / d;\n  vy *= t;\n}\n\n/****************************************************************************/\n/* camera management end                                                    */\n/****************************************************************************/\n\nfloat pnorm(float p, float t, float x0, float y0, float z0, float x1, float y1, float z1,\n             float frame,\n             float p2, float p3, float p4)\n{\n  /* the space is covered by cubes of size 6x6x6, repeating in all directions,\n   * each one containing a shape.\n   * We want 4 different shapes on screen for less boring, so each cube is\n   * numbered in [0, 1, 2, 3] and the numbering repeats like this in all\n   * directions, each numbering receives a shape (different shapes have\n   * different p for a given frame)\n   */\n\n  /* (x,y,z) is the point to test */\n  float x = x0 + t * (x1 - x0);\n  float y = y0 + t * (y1 - y0);\n  float z = z0 + t * (z1 - z0);\n\n  /* find in which cube we are */\n  int px = int(round(x / 6.)); px = (px % 4 + 4) % 4;\n  int py = int(round(y / 6.)); py = (py % 4 + 4) % 4;\n  int pz = int(round(z / 6.)); pz = (pz % 4 + 4) % 4;\n\n  /* put (x,y,z) in the cube (0,0,0) for processing */\n  x = mod(mod(x-3.,6.) + 6., 6.)-3.;\n  y = mod(mod(y-3.,6.) + 6., 6.)-3.;\n  z = mod(mod(z-3.,6.) + 6., 6.)-3.;\n\n  /* rotate the shape */\n  float angle = 2. * M_PI * frame / 100.;\n  rotate_y(x, y, z, angle);\n\n  /* select p depending on the cube we're in */\n  if ((px+py+pz) % 4 == 1) p = p2;\n  else if ((px+py+pz) % 4 == 2) p = p3;\n  else if ((px+py+pz) % 4 == 3) p = p4;\n\n  /* no need for final pow(1/p), we care about distance = 1 */\n  return   pow(abs(x), p)\n         + pow(abs(y), p)\n         + pow(abs(z), p);\n}\n\nfloat get_p(float frame)\n{\n  float p;\n  frame = mod(frame, 200.);\n  /* we get p from [1/2 .. 4], linear choice is ugly, so we use several\n   * linear ranges, looks more or less nice, there may be better choices\n   */\n  /* 1/2   1   2    4 */\n  if (frame < 50.)       p = P3(frame, 0., 50., 1./2., 1.);\n  else if (frame < 75.)  p = P3(frame, 50., 75., 1., 2.);\n  else if (frame < 100.) p = P3(frame, 75., 100., 2., 4.);\n  else if (frame < 125.) p = P3(frame, 100., 125., 4., 2.);\n  else if (frame < 150.) p = P3(frame, 125., 150., 2., 1.);\n  else                   p = P3(frame, 150., 200., 1., 1./2.);\n  return p;\n}\n\nfloat dig_t(float p, float x0, float y0, float z0, float x1, float y1, float z1, float frame, float p2, float p3, float p4)\n{\n  float t0, t1;\n  float n0, n1;\n  /* delta = .01 for nice result but very very slow, bigger value for faster\n   * computation but uglier on screen\n   */\n  float delta = .01;\n\n  /* norm is abs(x)^p + abs(y)^p + abs(z)^p (we omit final ^1/p)\n   * we want norm = 1 (we want to be on the \"unit sphere\" of the norm)\n   * current ray is from (x0, y0, z0) to (x1,y1,z1)\n   * a point (x,y,z) is on the ray if there is t such that:\n   * (x,y,z) = t * ray\n   * for t=0 we decide to be at (x0,y0,z0)\n   * for t=1 we decide to be at (x1,y1,z1)\n   * so for generic point (x,y,z), we have:\n   * 0 x0  y0  z0\n   * 1 x1  y1  z1\n   * t x   y   z\n   * so:\n   * t = (x - x0) / (x1 - x0)\n   * same for y and z\n   * and so:\n   * x = x0 + t * (x1 - x0)\n   * y = y0 + t * (y1 - y0)\n   * z = z0 + t * (z1 - z0)\n   */\n\n  /* start from t = 1 to t = 70, step is delta (this is very slow) */\n  t0 = 1.;\n  n0 = pnorm(p, t0, x0, y0, z0, x1, y1, z1, frame, p2, p3, p4);\n  //if (n0 <= 1) { fprintf(stderr, \"bad start\\n\"); exit(1); }\n  t1 = t0 + delta;\n  n1 = pnorm(p, t1, x0, y0, z0, x1, y1, z1, frame, p2, p3, p4);\n  /* we stop if we find a point with n = 1 or if we go too far */\n  while ((   (n0 > 1. && n1 > 1.)\n          || (n0 < 1. && n1 < 1.))\n         && t1 < 70.) {\n    n0 = n1;\n    t0 = t1;\n    t1 += delta;\n    n1 = pnorm(p, t1, x0, y0, z0, x1, y1, z1, frame, p2, p3, p4);\n  }\n  if (t1 >= 70.) return 1000.;\n  /* this is not correct, t for which distance = 1 is not necessarily t1\n   * but it looks ok on screen, so no big deal at this point\n   */\n  return t1;\n}\n\nvec4 raytrace_pnorm(float x, float y, float frame)\n{\n  vec3 camera[4];\n  compute_camera(camera, frame);\n  float x0, y0, z0, x1, y1, z1;\n  float p;\n  float t;\n\n  /* ray is from eye to (x,y) on screen (center of screen is (0,0)) */\n  /* start of ray: eye */\n  x0 = eye.x;\n  y0 = eye.y;\n  z0 = eye.z;\n\n  /* end of ray */\n  /* (x,y) of screen is vector (x*vx + y*vx) starting at point center in\n   * our 3d space\n   */\n  x1 = center.x + x * vx.x + y * vy.x;\n  y1 = center.y + x * vx.y + y * vy.y;\n  z1 = center.z + x * vx.z + y * vy.z;\n\n  /* get the p in [1/2 .. 4], four of them for more diversity on screen */\n  p = get_p(frame);\n  float p2 = get_p(frame + 100.);\n  float p3 = get_p(frame + 50.);\n  float p4 = get_p(frame + 150.);\n\n  /* blue is actually black, looks better ('blue' name kept, lazy me) */\n  vec4 blue = vec4(0, 0, 0, 0);\n  t = dig_t(p, x0, y0, z0, x1, y1, z1, frame, p2, p3, p4);\n  if (t == 1000.) return blue;\n\n  /* a palette based on euclidian distance from (0,0,0) to the point */\n  /* close is yellow, farther is red, far is white */\n  float d = pnorm(2., t, x0, y0, z0, x1, y1, z1, frame, 2., 2., 2.);\n  /* g+rb define yellow */\n  float g = P3(d, 0., 0.6, 125., 10.);\n  float rb = P3(d, 0., 0.6, 125., 10.);\n  /* ra defines red */\n  float ra = P3(d, 0., 2., 0., 255.);\n  g = clamp(g, 0., 255.);\n  rb = clamp(rb, 0., 255.);\n  /* w defines white */\n  float w = clamp(P3(d, 1., 1.4, 0., 120.), 0., 255.);\n  /* alpha is used to fade to 'blue' when very far away, looks nice */\n  float alpha = clamp(P3(t, 10., 70., 1., 0.), 0., 1.);\n  return vec4(\n    alpha * max(clamp(ra+rb, 0., 255.), w) + (1.-alpha) * blue.r,\n    alpha * max(g, w) + (1.-alpha) * blue.g,\n    alpha * max(20., w) + (1.-alpha) * blue.b,\n    0\n  ) / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float x = P3(fragCoord.x, 0., iResolution.x, -80., 80.);\n  float y = P3(fragCoord.y, 0., iResolution.y, -45., 45.);\n#ifndef FULL_RESOLUTION\n  x = floor(x);\n  y = floor(y);\n#endif\n  float frame = iTime * 25.;\n  fragColor = raytrace_pnorm(x, y, frame);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcBDs.jpg", "access": "api", "license": "public-domain", "functions": [[2781, 2819, 2858, 2858, 3278], [4128, 4128, 4185, 4185, 8381], [8621, 8621, 8781, 9194, 10059], [10061, 10061, 10087, 10087, 10676], [10678, 10678, 10803, 10803, 12345], [12347, 12347, 12399, 12399, 14087], [14089, 14089, 14146, 14146, 14401]], "test": "untested"}
{"id": "Nl3BDs", "name": "P-Norm", "author": "sedcore", "description": "Raymarching 3D p-norm for varying p in [-1/2 .. 4]. Loops every 400 frames.", "tags": ["raymarching", "pnorm"], "likes": 4, "viewed": 168, "published": 3, "date": "1663789837", "time_retrieved": "2024-07-30T16:30:17.642376", "image_code": "/* Sed - P-Norm - 2022 */\n\n/* GLSL adaptation of http://sedcore.eu.org/small/norm.c */\n/* comments were kept as is - useless c code removed */\n/* released in the public domain */\n/* not super efficient I guess */\n\n/* 16/9 aspect ratio expected - me too lazy to handle generic case */\n\n/* set this for full resolution (personally I like big pixels)\n * note that the computation time is the same in any case\n */\n//#define FULL_RESOLUTION\n\n/* 2022-09-07 */\n\n/* inspired by https://twitter.com/Marina_Costant/status/1560219380482539522 */\n\n/* gcc -Wall -o norm norm.c -lm -O3 -ffast-math -fomit-frame-pointer -march=native\n * ./norm > XX\n * ffmpeg -f rawvideo -s 640x360 -r 25 -pix_fmt bgra -i XX -vf palettegen palette.png\n * ffmpeg -f rawvideo -s 640x360 -r 25 -pix_fmt bgra -i XX -i palette.png -filter_complex paletteuse movie.gif\n */\n\n/* not realtime at all, set delta = 0.05 or higher for faster but uglier */\n/* or improve dig_t(): we look for the smallest t>1 for which norm() = 1,\n * if it exists of course\n */\n\n/* not super good comments, see norm_infinity.c for better */\n\nconst float M_PI = radians(180.);\n\nfloat norm(float p, float t, float x0, float y0, float z0, float x1, float y1, float z1)\n{\n  float x = x0 + t * (x1 - x0);\n  float y = y0 + t * (y1 - y0);\n  float z = z0 + t * (z1 - z0);\n  return   pow(abs(x), p)\n         + pow(abs(y), p)\n         + pow(abs(z), p);\n}\n\nfloat euclid(float t, float x0, float y0, float z0, float x1, float y1, float z1)\n{\n  float x = x0 + t * (x1 - x0);\n  float y = y0 + t * (y1 - y0);\n  float z = z0 + t * (z1 - z0);\n  return sqrt(x*x + y*y + z*z);\n}\n\nfloat dig_t(float p, float x0, float y0, float z0, float x1, float y1, float z1)\n{\n  float t0, t1;\n  float n0, n1;\n  float delta = .01;\n\n  /* norm is abs(x)^p + abs(y)^p + abs(z)^p\n   * we want norm = 1 (we want to be on the \"unit sphere\" of the norm)\n   * current ray is from (x0, y0, z0) to (x1,y1,z1)\n   * a point (x,y,z) is on the ray if there is t such that:\n   * (x,y,z) = t * ray\n   * for t=0 we decide to be at (x0,y0,z0)\n   * for t=1 we decide to be at (x1,y1,z1)\n   * so for generic point (x,y,z), we have:\n   * 0 x0  y0  z0\n   * 1 x1  y1  z1\n   * t x   y   z\n   * so:\n   * t = (x - x0) / (x1 - x0)\n   * same for y and z\n   * and so:\n   * x = x0 + t * (x1 - x0)\n   * y = y0 + t * (y1 - y0)\n   * z = z0 + t * (z1 - z0)\n   */\n\n  /* start at t = 1 and end at t = 1 + delta */\n  t0 = 1.;\n  n0 = norm(p, t0, x0, y0, z0, x1, y1, z1);\n  //if (n0 <= 1) { fprintf(stderr, \"bad start\\n\"); exit(1); }\n  t1 = t0 + delta;\n  n1 = norm(p, t1, x0, y0, z0, x1, y1, z1);\n  while ((   (n0 > 1. && n1 > 1.)\n          || (n0 < 1. && n1 < 1.))\n         && t1 < 5.) {\n    n0 = n1;\n    t0 = t1;\n    t1 += delta;\n    n1 = norm(p, t1, x0, y0, z0, x1, y1, z1);\n  }\n  if (t1 >= 5.) return 1000.;\n  return t1;\n}\n\n#define rotate_x(x, y, z, angle)    {          \\\n  float y2 = y * cos(angle) - z * sin(angle); \\\n  float z2 = z * cos(angle) + y * sin(angle); \\\n  y = y2;                                      \\\n  z = z2;                                      \\\n}\n\n#define rotate_y(x, y, z, angle)    {          \\\n  float x2 = x * cos(angle) - z * sin(angle); \\\n  float z2 = z * cos(angle) + x * sin(angle); \\\n  x = x2;                                      \\\n  z = z2;                                      \\\n}\n\nvec4 raytrace_norm(float x, float y, float frame)\n{\n  float x0 = 0., y0 = 0., z0 = 3., x1 = x, y1 = y, z1 = 2.;\n  float p;\n  float t;\n\n  /* rotate (x0,y0,z0) and (x1,y1,z1) */\n  float angle = 2. * M_PI * frame / 100.;\n\n  rotate_x(x0, y0, z0, -M_PI/7. * cos(2. * M_PI * frame / 80.));\n  rotate_x(x1, y1, z1, -M_PI/7. * cos(2. * M_PI * frame / 80.));\n\n  rotate_y(x0, y0, z0, angle);\n  rotate_y(x1, y1, z1, angle);\n\n  /* x0   y0\n   * x    y\n   * x1   y1\n   * (x-x0) / (x1-x0) = (y-y0) / (y1-y0)\n   * y = y0 + (x-x0) / (x1-x0) * (y1-y0)\n   */\n#define P3(x, x0, x1, y0, y1) ((y0) + ((x)-(x0)) / ((x1)-(x0)) * ((y1)-(y0)))\n  /* p in [1/2 .. 4] */\n  frame = mod(frame, 200.);\n  /* 1/2   1   2    4 */\n  if (frame < 50.)       p = P3(frame, 0., 50., 1./2., 1.);\n  else if (frame < 75.)  p = P3(frame, 50., 75., 1., 2.);\n  else if (frame < 100.) p = P3(frame, 75., 100., 2., 4.);\n  else if (frame < 125.) p = P3(frame, 100., 125., 4., 2.);\n  else if (frame < 150.) p = P3(frame, 125., 150., 2., 1.);\n  else                   p = P3(frame, 150., 200., 1., 1./2.);\n\n  vec4 blue = vec4(15, 17, 23, 0)/255.;\n  t = dig_t(p, x0, y0, z0, x1, y1, z1);\n  if (t == 1000.) return blue;\n\n  /* a palette based on distance from (0,0,0) to the point */\n  float d = euclid(t, x0, y0, z0, x1, y1, z1);\n  float g = P3(d, 0., 0.6, 125., 10.);\n  float rb = P3(d, 0., 0.6, 125., 10.);\n  float ra = P3(d, 0., 2., 0., 255.);\n  g = clamp(g, 0., 255.);\n  rb = clamp(rb, 0., 255.);\n  float w = clamp(P3(d, 1., 1.4, 0., 120.), 0., 255.);\n  return vec4(\n    max(clamp(ra+rb, 0., 255.), w),\n    max(g, w),\n    max(20., w),\n    0) / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef FULL_RESOLUTION\n  float x = fragCoord.x;\n  float y = fragCoord.y;\n  x -= iResolution.x / 2.;\n  y = iResolution.y / 2. - y;\n  x /= (iResolution.x / 160.);\n  y /= (iResolution.y / 90.);\n  float frame = iTime * 25.;\n  float scale = 1./100.;\n  float x0 = x * scale;\n  float y0 = y * scale;\n  fragColor = raytrace_norm(x0, y0, frame);\n#else\n  float x = P3(fragCoord.x, 0., iResolution.x, -80., 80.);\n  float y = P3(fragCoord.y, 0., iResolution.y, -45., 45.);\n  x = floor(x);\n  y = floor(y);\n  float frame = iTime * 25.;\n  float scale = 1./100.;\n  float x0 = x * scale;\n  float y0 = y * scale;\n  fragColor = raytrace_norm(x0, y0, frame);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3BDs.jpg", "access": "api", "license": "public-domain", "functions": [[1115, 1115, 1205, 1205, 1382], [1384, 1384, 1467, 1467, 1597], [1599, 1599, 1681, 1681, 2791], [3285, 3285, 3336, 3336, 4886], [4888, 4888, 4945, 4945, 5593]], "test": "untested"}
{"id": "Nl3fWl", "name": "Four-Phase Fluid Mixer", "author": "fenix", "description": "I've no idea what these four fluids would have to be to act like this in the real world, but I thought the Salad Dressing Mixer needed color.\n*click mouse to start/stop the mixer*\n*mouse to grab/spin the mixer*\n*space to reset and resume attract mode* ", "tags": ["2d", "voronoi", "simulation", "water", "fluid", "particles", "oil", "dynamics"], "likes": 8, "viewed": 342, "published": 3, "date": "1663776988", "time_retrieved": "2024-07-30T16:30:18.612782", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  I've no idea what these four fluids would have to be to act like this in the real\n//  world, but I wanted to bring more color and visual interest to the Two-Phase Salad\n//  Dressing Mixer. https://www.shadertoy.com/view/fldBRs\n//\n//  The rendering effect is achieved by rendering the fluids into separate channels,\n//  and blurring them separately as well. To skip the effect of the blurring, you could\n//  switch iChannel0 on the Image tab to Buffer C.\n//\n//  There's an attract mode if you don't click, that turns the mixer on and\n//  off once per 1000 frames. If you start clicking, you gain control over\n//  the mixer motor: click to enable or disable. You can also drag the mixer\n//  wheel and impart a velocity by letting go while it spins.\n//\n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a voronoi search to help out building neighborhoods\n//  Buffer C renders the particles\n//  Buffer D blurs buffer C\n//\n// ---------------------------------------------------------------------------------------\n\n\nvoid gradient4(vec2 fragCoord, out vec4 xGrad, out vec4 yGrad)\n{\n    vec2 delta = vec2(0.1, 0);\n    xGrad = texture(iChannel0, (fragCoord + delta.xy) / iResolution.xy) - \n        texture(iChannel0, (fragCoord - delta.xy) / iResolution.xy);\n        \n    yGrad = texture(iChannel0, (fragCoord + delta.yx) / iResolution.xy) - \n        texture(iChannel0, (fragCoord - delta.yx) / iResolution.xy);\n        \n    xGrad = normalize(xGrad);\n    yGrad = normalize(yGrad);\n}\n\nfloat computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular;\n}\n\nconst vec4[4] FLUID_COLORS = vec4[](vec4(0.0, 0.0, 1.0, 1.0),\n                                    vec4(1.0, 0.7, 0.0, 1.0),\n                                    vec4(1.0, 0.0, 0.0, 1.0),\n                                    vec4(0.7, 0.0, 1.0, 1.0));\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{   \n    //vec3 norm = normalize(vec3(grad(fragCoord), 1));\n    vec4 xGrad, yGrad;\n    gradient4(fragCoord, xGrad, yGrad);\n    vec4 fluid = texture(iChannel0, fragCoord/iResolution.xy);\n    //vec2 grad = mix(bothGrads.xz, bothGrads.yw,smoothstep(0.0, 1., fluid.y));\n    vec2 grad = vec2(xGrad[0], yGrad[0]);\n    for (int i = 1; i < 4; ++i)\n    {\n        grad = mix(grad, vec2(xGrad[i], yGrad[i]), fluid[i]);\n    }\n    \n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec4 background = textureLod(iChannel3, p, 5.0);\n    float density = max(max(max(fluid.x, fluid.y), fluid.z), fluid.w) *4.;\n    vec4 color = vec4(0);\n    for (int i = 0; i < 4; ++i)\n    {\n        color = mix(color, FLUID_COLORS[i], smoothstep(0.0, 0.5, fluid[i]));\n    }\n    vec4 water = texture(iChannel3, p + grad * 0.2) * color; // Refract :)\n    fragColor = mix(background, water, smoothstep(0.5, 1.0, density)); // Blur water edges\n\n    fxState state = fxGetState();\n    vec2 steelCoord = vec2(fragCoord.x * 2.0, (fragCoord.y) * 0.004);\n    vec2 adjusted = (p - 0.5) * vec2(iResolution.x / iResolution.y, 1.);\n    if (length(adjusted) < 0.5/1.2 + 0.02) // Radial pattern in the center circle\n    {\n        float a = atan(adjusted.y, adjusted.x) + state.rotation;\n        steelCoord = vec2(a*400., length(adjusted)*20.);\n    }\n    float wallDist = distanceFromWalls(p * vec2(iResolution.x / iResolution.y, 1.), iResolution, state.rotation);\n    \n    vec3 steelNorm = texture(iChannel2, steelCoord/iResolution.xy).xyz;\n    steelNorm.xz += getNormalFromWalls(p * vec2(iResolution.x / iResolution.y, 1.), iResolution, state.rotation) * (1.0 - smoothstep(0.007, 0.01, -wallDist));\n\n    steelNorm = normalize(steelNorm);\n    vec3 lightDir = normalize(vec3(1,-1,1));\n    float steelSpec = computeSpecular(0.8, 15.0, steelNorm, lightDir, vec3(0.0, 1.75-p.x, 0.5 - p.y));\n    vec4 steel = vec4(vec3(steelSpec), 1.0) * 0.5 + 0.3;\n\n    fragColor = mix(fragColor, steel, vec4(clamp(-wallDist*iResolution.y, 0.0, 1.0)));\n    //fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).bgra);\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 1500; \nconst float PARTICLE_REPEL_SIZE = 0.01;\n\nconst float PI = 3.141592653589793;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return p * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution);\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 1e-10)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.x, sc.y, sc.y, -sc.x);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    vec2 c = (point - vec2(.5*resolution.x/resolution.y,  .5))*1.2;\n    float minDist = 1e30;\n    minDist = min(minDist, .5 - length(c));\n    const int NUM_PADDLES = 10;\n    for (int i = 0; i < NUM_PADDLES; ++i)\n    {\n        minDist = min(minDist, sdBox((rot2(time + float(i) *2.* PI / float(NUM_PADDLES))*c + vec2(0.0, 0.5)), vec2(0.01, 0.2)));\n    }\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 delta = vec2( 0.001, 0.0 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + delta.xy, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - delta.xy, resolution, time ); \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    float upTinyChangeInY   = distanceFromWalls( point + delta.yx, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - delta.yx, resolution, time ); \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n\tvec2 normal = vec2(tinyChangeInX, tinyChangeInY);\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define SIZE 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    float size;\n    float closestDist;\n    int material;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, SIZE), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.size = particleData5.x;\n    particle.closestDist = particleData5.y;\n    particle.material = int(particleData5.z);\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case SIZE:\n        return vec4(p.size, p.closestDist, float(p.material), 0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nstruct fxState\n{\n    float resolution;\n    float rotation;\n    float velocity;\n    float mouse;\n    bool motor;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    fxState state;\n    state.resolution = data.x;\n    state.rotation = data.y;\n    state.velocity = data.z;\n    state.mouse = abs(data.w);\n    state.motor = data.w < 0.;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state)\n{\n    return vec4(state.resolution, state.rotation, state.velocity, state.mouse * (state.motor ? -1. : 1.));\n}\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_P 80\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n", "buffer_a_code": "const vec2 GRAVITY = vec2(0.0000, -0.00003);\nconst float PARTICLE_REPEL = 0.00001;\nconst float VISCOSITY = 0.0000000005;\nconst float OIL_SEP = 4e-7;\nconst float COLLISION_BOUNCE = 0.6;\nconst float WALL_BOUNCE = 1.5;\nconst float WALL_REPEL = 0.0005;\nconst float POSITION_CORRECTION = 0.02;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\n#define RGB(R, G, B) vec3(float(R), float(G), float(B)) / 255.0\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate MAX_PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    if (id == 0) return;\n    \n    fxParticle data = fxGetParticle(id);\n    fxState state = fxGetState();\n    \n    if (dataType >= POS_VEL)\n    {\n        if (iFrame == 0 || state.resolution < 0.)\n        {\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = (vec2((i + 0.5*(mod(j, 2.0))) / particlesPerRow, j / particlesPerRow) * vec2(0.35, 0.5) + vec2(0.325, 0.25)) * vec2(iResolution.x / iResolution.y, 1.0);\n            data.vel = vec2(0);\n            data.size = 1e6;\n            data.material = 3 - int(4.* j / particlesPerRow);\n        }\n        else\n        {\n            vec2 force = GRAVITY;\n            // I tried making gravity stronger on the water, but then they\n            // fell at different speeds which bothered me. Here's how I did\n            // it, for reference.\n            //if (data.color != vec3(1)) force /= 5.5;\n            float minDist = 1e6;\n            float minCirc = 1e6;\n            \n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    fxParticle n = fxGetParticle(cid);\n                    \n                    vec2 deltaPos = data.pos - n.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    vec2 dir = deltaPos / dist;\n \n                    // Absorb some velocity from nearby particles\n                    force += VISCOSITY * n.vel / square(dist);\n\n                    // Apply SPH attract/repel force\n                    force -= PARTICLE_REPEL * dir * SPHgradKernel(dist / (0.1*PARTICLE_REPEL_SIZE));\n\n                    // Repel small neighbors (restores density)\n                    if (data.size < PARTICLE_REPEL_SIZE*.8 && n.size < data.size && n.size > 1e-6 && data.size > 1e-6 && iFrame > 10)\n                    {\n                        force += 9.*(PARTICLE_REPEL_SIZE - data.size) * dir * (data.size - n.size);\n                    }\n                    \n                    // \"Buoyancy\" force due to oil/water density difference\n                    if (data.material != n.material)\n                    {\n                        if (data.material > n.material)\n                        {\n                            force.y -= OIL_SEP / dist;\n                        }\n                        else\n                        {\n                            force.y += OIL_SEP / dist;\n                        }\n                    }\n                    \n                    // Collide with neighbor\n                    if (dist < PARTICLE_REPEL_SIZE * 2.)\n                    {\n                        data.pos -= dir * (dist - PARTICLE_REPEL_SIZE * 2.) * POSITION_CORRECTION;\n                        float normalVel = dot(dir, data.vel - n.vel);\n                        if (normalVel < 0.)\n                        {\n                            data.vel -= COLLISION_BOUNCE * dir * normalVel;\n                        }\n                    }\n\n                    // Record some data for size computation\n                    minDist = min(minDist, dist*0.5);\n                    minCirc = min(minCirc, max(dist*0.5, 0.5*(dist - n.size)));\n                }\n            }       \n            \n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Record computed size\n            data.closestDist = minDist;\n            data.size = minCirc;\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, state.rotation);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, state.rotation - state.velocity);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, state.rotation);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= WALL_BOUNCE * distNormal * min(0., dot(distNormal, data.vel));\n                data.vel += WALL_REPEL * distNormal;\n            }\n            \n            // Damping\n            data.vel -= data.vel * (length(data.vel) + 0.02);\n\n            // Clamping\n            float maxSpeed = 0.003; // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos * vec2(iResolution.y / iResolution.x, 1.0))));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(data.neighbors[0][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[1][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[2][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[3][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            //pick random id of particle\n            int p = int(mod(h*34534.0, float(MAX_PARTICLES)));\n            sort0(bestIds, bestDists, id, int(p), dataType, data.pos);  //sort this\n        }\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 || id >= MAX_PARTICLES ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    if (iFragCoord == ivec2(0))\n    {\n        fxState state = fxGetState();\n        \n        if (iFrame == 0 || iResolution.x * iResolution.y != abs(state.resolution) || keyDown(KEY_SPACE))\n        {\n            state.resolution = -iResolution.x * iResolution.y;\n            state.mouse = 1.;\n            state.velocity = state.rotation = 0.0;\n            state.motor = true;\n        }\n        else\n        {\n            state.resolution = abs(state.resolution);\n            \n            if (state.mouse == 1. && (iFrame % 1000) == 0) state.motor = !state.motor;\n            \n            // Apply acceleration and damping\n            state.velocity += state.motor ? 0.00006 : 0.;\n            state.velocity *= 0.99;\n            \n            // Handle mouse input\n            if (iMouse.z > 0.)\n            {\n                if (iMouse.w > 0.)\n                {\n                    state.velocity = 0.;\n                    state.motor = !state.motor;\n                }\n                else\n                {\n                    state.velocity = clamp((abs(state.mouse) - iMouse.x - iMouse.y) / iResolution.x, -0.1, 0.1);\n                }\n\n                state.mouse = iMouse.x + iMouse.y;\n            }\n            \n            // Integrate rotation\n            state.rotation += state.velocity;\n        }\n        \n        fragColor = fxPutState(state);\n        return;\n    }\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n    \n    ivec4 old   = fxGetClosest( iFragCoord );      \n\n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, screen2world(fragCoord));\n        insertion_sort( new, dis, id, dis2 );\n    }\n    \n    // Search randomly in the nearest 15x15 neighbors instead of just\n    // the next-door neighbors. Seems to allow faster particle movement\n    uint searchRange = 15u;\n    uint searchCount = 16u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, screen2world(fragCoord));\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++)\n    {\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nconst vec3 lightDir = normalize(vec3(1,-1,1));\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = sqrt(linePointDist2(p.pos, p.pos - p.vel, fragCoord, iResolution, closest));\n   \n    float drawSize = min(p.size,PARTICLE_REPEL_SIZE)*1.0;\n    fragColor[p.material] = max(fragColor[p.material], mix(fragColor[p.material], 1., 1.-smoothstep(drawSize*0.2, drawSize * 2.5, dist)));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    fragColor = vec4(0);\n    \n  \tvec2 p = fragCoord/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n\n    //draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N =  15;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  w = .0125; \\\n              z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec4 convol2D(vec2 U) {                                                     \n    vec4  O = vec4(0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z );  \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init\n    vec2 p = (u - iResolution.xy * 0.5) / iResolution.y;\n    if (length(p) < 0.5) // restrict blur to circle to improve speed\n    {\n        vec2 U = u / R.y;  \n        O = convol2D(U);\n    }\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3fWl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1251, 1251, 1315, 1315, 1714], [1716, 1716, 1879, 1879, 2084], [2336, 2336, 2390, 2448, 4465]], "test": "untested"}
{"id": "sldfDX", "name": "Grand Sea of Cube", "author": "Varyemez", "description": "ğ", "tags": ["sea"], "likes": 2, "viewed": 185, "published": 3, "date": "1663765251", "time_retrieved": "2024-07-30T16:30:19.370755", "image_code": "const int MAX_ITER = 550;\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 40.0;\nconst float PI = radians(180.);\n\nfloat brightness = 0.;\n\nmat2 rot2d(float r)\n{\n    return mat2(cos(r), -sin(r), sin(r), cos(r));\n}\nfloat random(vec2 seed)\n{\n    return fract(sin(dot(seed.xy, vec2(22.9,48.6)))*2356.);\n}\n\nfloat rect(vec3 p, vec3 dimensions)\n{\n    return length(max(abs(p) - dimensions/2., vec3(0.)));\n}\nfloat sea(vec3 p)\n{\n    float r = random(floor(p.xz)*2.);\n    if (p.y < 1.5)\n        brightness = (r*.5+.5);\n    return (p.y + random(floor(p.xz)) + r*sin(r*50.+iTime))*0.03;\n}\n\nfloat scene_dist(vec3 p)\n{\n    return sea(p);\n}\nfloat raymarch(vec3 p, vec3 dir)\n{\n    float dist = 0.;\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        float d = scene_dist(p + dist*dir);\n        dist += d;\n        \n        if (dist >= MAX_DIST || d <= MIN_DIST) break;\n    }\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    vec3 ray_dir = normalize(vec3(uv.xy, 1.));\n    ray_dir.xz *= rot2d(radians(-35.));\n    float d = raymarch(normalize(vec3(1,0,1))*iTime + vec3(0, 2, 0), ray_dir);\n    \n    vec3 color = vec3(0.45, 0.2,0.9);\n    fragColor = vec4(color.rgb*brightness, 1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[141, 141, 162, 162, 214], [215, 215, 240, 240, 302], [304, 304, 341, 341, 401], [402, 402, 421, 421, 578], [580, 580, 606, 606, 627], [628, 628, 662, 662, 884], [886, 886, 943, 943, 1271]], "test": "untested"}
{"id": "ftdfDX", "name": "With Palette!", "author": "SONENEIS", "description": "only 16 colors, nothing more.", "tags": ["raymarching", "simple", "ray", "raymarch", "colorful", "marching", "palette", "march", "8bit", "render", "16bit"], "likes": 27, "viewed": 448, "published": 3, "date": "1663744356", "time_retrieved": "2024-07-30T16:30:20.136707", "image_code": "void render(inout float col,vec2 uv){\n\tvec3 ro = vec3(0.0,0.0,3.0);\n\tvec3 rd = normalize(vec3(uv,-2.0));\n\t\n\tfloat d = 0.0;\n\tfor(float i=0.0;i<256.0;i++){\n\t\tvec3 p = ro + rd*d, cp = p;\n\t\tcp.xy *= mat2(cos(time),-sin(time),sin(time),cos(time));\n\t\tcp.yz *= mat2(cos(time),-sin(time),sin(time),cos(time));\n\t\tcp.zx *= mat2(cos(time),-sin(time),sin(time),cos(time));\n\t\tfloat h = smin(p.y + 0.5,length(max(abs(cp)-0.4,0.0)) - 0.4,0.25);\n\t\tif(h < 0.001 || d > 20.0) break;\n\t\td += h;\n\t}\n  \n  if(d < 20.0){\n  \tvec3 p = ro + rd*d;\n  \tcol += p08*dot(vec3(0.8),p);\n  }\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-res.xy)/res.y;\n  vec3 col = vec3(0.0);\n  float colp = 0.0;\n\n  render(colp,uv);\n  \n  colp = mod(floor(colp * 36.0),16.0);\n  \n  switch(int(colp)){\n  \tcase 0: col = A; break;\n  \tcase 1: col = B; break;\n  \tcase 2: col = C; break;\n  \tcase 3: col = D; break;\n  \tcase 4: col = E; break;\n  \tcase 5: col = F; break;\n  \tcase 6: col = G; break;\n  \tcase 7: col = H; break;\n  \tcase 8: col = I; break;\n  \tcase 9: col = J; break;\n  \tcase 10: col = K; break;\n  \tcase 11: col = L; break;\n  \tcase 12: col = M; break;\n  \tcase 13: col = N; break;\n  \tcase 14: col = O; break;\n  \tcase 15: col = P; break;\n  }\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "#define pi 3.141592\n#define tau pi*2.0\n\n#define time iTime\n#define res iResolution\n\n//sweetie-16 palette//\n#define A vec3(0x1a,0x1c,0x2c) / 255.0\n#define B vec3(0x5d,0x27,0x5d) / 255.0\n#define C vec3(0xb1,0x3e,0x53) / 255.0\n#define D vec3(0xef,0x7d,0x57) / 255.0\n#define E vec3(0xff,0xcd,0x75) / 255.0\n#define F vec3(0xa7,0xf0,0x70) / 255.0\n#define G vec3(0x38,0xb7,0x64) / 255.0\n#define H vec3(0x25,0x71,0x79) / 255.0\n#define I vec3(0x29,0x36,0x6f) / 255.0\n#define J vec3(0x3b,0x5d,0xc9) / 255.0\n#define K vec3(0x41,0xa6,0xf6) / 255.0\n#define L vec3(0x73,0xef,0xf7) / 255.0\n#define M vec3(0xf4,0xf4,0xf4) / 255.0\n#define N vec3(0x94,0xb0,0xc2) / 255.0\n#define O vec3(0x56,0x6c,0x86) / 255.0\n#define P vec3(0x33,0x36,0x57) / 255.0\n\n#define p00 0.025 * 0.0\n#define p01 0.025 * 1.0\n#define p02 0.025 * 2.0\n#define p03 0.025 * 3.0\n#define p04 0.025 * 4.0\n#define p05 0.025 * 5.0\n#define p06 0.025 * 6.0\n#define p07 0.025 * 7.0\n#define p08 0.025 * 8.0\n#define p09 0.025 * 9.0\n#define p10 0.025 * 10.0\n#define p11 0.025 * 11.0\n#define p12 0.025 * 12.0\n#define p13 0.025 * 13.0\n#define p14 0.025 * 14.0\n#define p15 0.025 * 15.0\n\nfloat smin(float a,float b,float k){\n  float h = clamp(0.5 + 0.5*(b-a)/k,0.0,1.0);\n  return mix(b,a,h) - k*h*(1.0-h);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 557], [559, 559, 609, 609, 1255]], "test": "untested"}
{"id": "sl3fDX", "name": "Specular highlights and color!", "author": "fishy", "description": "Fun! Phong distribution for the specular highlights. Now with ACES tonemapping from https://www.shadertoy.com/view/XsGfWV", "tags": ["shadow", "raymarcher", "penumbra", "diffuse"], "likes": 0, "viewed": 184, "published": 3, "date": "1663719692", "time_retrieved": "2024-07-30T16:30:20.899667", "image_code": "struct material\n{\n    vec3 baseColor;\n    float roughness;\n};\n\nvec3 aces_tonemap(vec3 color) // https://www.shadertoy.com/view/XsGfWV\n{\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nfloat calcSpecular(vec3 e, vec3 n, vec3 l, float p)\n{\n    return pow(clamp(dot(l, reflect(e, n)), 0.0, 1.0), p);\n}\n\nfloat join(inout float a, float b, material bm, inout material m)\n{\n    if(a < b)\n    {\n        return a;\n    }\n    else\n    {\n        m = bm;\n        return b;\n    }\n    \n}\n\nfloat sdPlane(vec3 p, float y)\n{\n    return p.y - y;\n}\n\nfloat sdSphere(vec3 p, vec3 pos, float r)\n{\n    return length(p - pos) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec3 p, vec3 b, vec3 bPos )\n{\n    return sdBox(p - bPos, b);\n}\n\nfloat sceneDist(vec3 p, out material m)\n{\n    m = material(vec3(0.0, 0.0, 1.0), 1.0);\n    float dist = sdSphere(p, vec3(0.3, 0.0, 2.0), 0.2);\n    dist = join(dist, sdSphere(p, vec3(-0.3, 0.0, 2.0), 0.2), material(vec3(0.0, 0.5, 1.0), 8.0), m);\n    dist = join(dist, sdBox(p, vec3(0.5, 0.1, 0.5), vec3(0.0,-0.3, 2.0)), material(vec3(1.0, 0.0, 0.0), 8.0), m);\n    dist = join(dist, sdPlane(p, -0.3), material(vec3(0.0, 1.0, 0.0), 8.0), m);\n    return dist;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    material m;\n    return normalize( k.xyy*sceneDist( p + k.xyy*h, m) + \n                      k.yyx*sceneDist( p + k.yyx*h, m) + \n                      k.yxy*sceneDist( p + k.yxy*h, m) + \n                      k.xxx*sceneDist( p + k.xxx*h, m) );\n}\n\nvoid march(vec3 dir, inout vec3 p, int maxSteps, float minDist, out bool hit, out float depth, out vec3 normal, out material m)\n{\n    vec3 oldP = p;\n    depth = 0.0;\n    for(int i = 0; i < maxSteps; i++)\n    {\n        depth = sceneDist(p, m);\n        p += depth*dir;\n        hit = depth < minDist;\n        if(hit)\n        {\n            normal = calcNormal(p);\n            depth = distance(oldP, p);\n            return;\n        }\n    }\n    normal = calcNormal(p);\n}\n\nvoid marchShadow(vec3 dir, vec3 p, int maxSteps, float minDist, out float inShadow, float k)\n{\n    vec3 oldP = p;\n    float dist = 0.002;\n    float totalDist = dist;\n\n    p += dist*dir;\n    inShadow = 1.0;\n    material m = material(vec3(0.0, 0.0, 0.0), 0.0);\n    for(int i = 0; i < maxSteps; i++)\n    {\n        dist = sceneDist(p, m);\n        totalDist += dist;\n\n        if(dist < minDist)\n        {\n            inShadow = 1.0;\n            return;\n        }\n        \n        p += dist*dir;\n        inShadow = min(inShadow, k*dist/totalDist);\n    }\n    inShadow = 1.0-inShadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n\n    vec3 eyeDir = normalize(vec3(uv * vec2(1.0, 1.0), 1.0));\n    vec3 eyePos = vec3(0.0, 0.0, 0.0);\n    vec2 mouse = iMouse.z > 0.0?iMouse.xy/iResolution.xy - 0.5 : vec2(sin(iTime), cos(iTime) + 2.0);\n    vec3 lightingDir = normalize(vec3((mouse) * vec2(1.0, iResolution.y/iResolution.x) * 10.0, -1.0));\n    \n    bool hit = false;\n    float depth = 0.0;\n    vec3 normal = vec3(0.0);\n    material hitMat;\n    march(eyeDir, eyePos, 512, 0.0001, hit, depth, normal, hitMat);\n    \n    float inShadow = 0.0;\n    marchShadow(lightingDir, eyePos, 64, 0.00001, inShadow, 4.0);\n    \n    //lightingDir = vec3(0.0, 1.0, 0.0);\n    float lighting = max(0.0, dot(normal, lightingDir));\n    float specular = calcSpecular(eyeDir, normal, lightingDir, 8.0 * hitMat.roughness);\n    specular = clamp(specular, 0.0, 1.0);\n    inShadow *= float(hit);\n    //lighting *= (1.0-inShadow) + 0.5;\n    //lighting /= 1.5;\n    \n    vec3 color = (vec3(lighting + specular) * hitMat.baseColor) * (1.0-inShadow);\n    color = aces_tonemap(color);\n\n    //fragColor = vec4(vec3(specular),1.0);\n    fragColor = vec4(hit? color : vec3(0.0),1.0);\n    //fragColor = vec4(eyeDir.xy,0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3fDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 135, 135, 582], [584, 584, 637, 637, 698], [700, 700, 767, 767, 873], [875, 875, 907, 907, 929], [931, 931, 974, 974, 1008], [1010, 1010, 1041, 1041, 1132], [1134, 1134, 1176, 1176, 1209], [1211, 1211, 1252, 1252, 1667], [1669, 1669, 1720, 1720, 2064], [2066, 2066, 2195, 2195, 2530], [2532, 2532, 2626, 2626, 3110], [3112, 3112, 3169, 3219, 4470]], "test": "untested"}
{"id": "fldBRs", "name": "Two-Phase Salad Dressing Mixer", "author": "fenix", "description": "Borrowing the rendering idea from my much earlier Flowing Water shader, this shader attempts to simulate an oil-water two-phase liquid. \n*click mouse to start/stop the mixer*\n*mouse to grab/spin the mixer*\n*space to reset and resume attract mode* ", "tags": ["2d", "voronoi", "simulation", "water", "particles", "oil", "dynamics", "salad"], "likes": 11, "viewed": 350, "published": 3, "date": "1663711325", "time_retrieved": "2024-07-30T16:30:21.847134", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  After that sickly sweet Candy Mixer https://www.shadertoy.com/view/NtcBzX\n//  I think we need some healthy salad to balance our diet. So I ran with\n//  elenzil's idea of making a heterogenous fluid, and decided to try to make\n//  an oil/water mixture, using the rendering style from my still-most popular\n//  shader, Flowing Water https://www.shadertoy.com/view/7s3Bz2\n//\n//  To differentiate them physically, the oil phase is more viscous, and\n//  there is a pretty fake lifting force that sorts the oil to the top.\n//\n//  The rendering effect is achieved by rendering the water and oil into\n//  separate buffers, and blurring them separately as well. Then when\n//  rendering, the oil's gradient is preferred based on the oil density.\n//  The oil droplets are also rendered larger. I was attempting to approximate\n//  the bubble-like appearance of oil droplets in water.\n//\n//  To skip the effect of the blurring, you could switch iChannel0 on the\n//  Image tab to Buffer C.\n//\n//  There's an attract mode if you don't click, that turns the mixer on and\n//  off once per 1000 frames. If you start clicking, you gain control over\n//  the mixer motor: click to enable or disable. You can also drag the mixer\n//  wheel and impart a velocity by letting go while it spins.\n//\n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a voronoi search to help out building neighborhoods\n//  Buffer C renders the particles\n//  Buffer D blurs buffer C\n//\n// ---------------------------------------------------------------------------------------\n\n\nvec4 gradient(vec2 fragCoord)\n{\n    vec2 delta = vec2(0.1, 0);\n    vec4 result = vec4(texture(iChannel0, (fragCoord + delta.xy) / iResolution.xy).xy - \n        texture(iChannel0, (fragCoord - delta.xy) / iResolution.xy).xy,\n        texture(iChannel0, (fragCoord + delta.yx) / iResolution.xy).xy - \n        texture(iChannel0, (fragCoord - delta.yx) / iResolution.xy).xy);\n        \n    result.xz = normalize(result.xz);\n    result.yw = normalize(result.yw);\n    \n    return result;\n}\n\nfloat computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular;\n}\n\nconst vec4 OIL_COLOR = vec4(0.85, 0.8, 0.0, 1.0);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{   \n    //vec3 norm = normalize(vec3(grad(fragCoord), 1));\n    vec4 bothGrads = gradient(fragCoord);\n    vec2 fluid = texture(iChannel0, fragCoord/iResolution.xy).xy;\n    vec2 grad = mix(bothGrads.xz, bothGrads.yw,smoothstep(0.0, 1., fluid.y));\n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec4 background = textureLod(iChannel3, p, 5.0);\n    float density = max(fluid.x, fluid.y) *4.;\n    vec4 color = mix(vec4(1), OIL_COLOR, smoothstep(0.0, 1., fluid.y));\n    vec4 water = texture(iChannel3, p + grad * 0.2) * color; // Refract :)\n    fragColor = mix(background, water, smoothstep(0.5, 1.0, density)); // Blur water edges\n\n    fxState state = fxGetState();\n    vec2 steelCoord = vec2(fragCoord.x * 2.0, (fragCoord.y) * 0.004);\n    vec2 adjusted = (p - 0.5) * vec2(iResolution.x / iResolution.y, 1.);\n    if (length(adjusted) < 0.5/1.2 + 0.02) // Radial pattern in the center circle\n    {\n        float a = atan(adjusted.y, adjusted.x) + state.rotation;\n        steelCoord = vec2(a*400., length(adjusted)*20.);\n    }\n    float wallDist = distanceFromWalls(p * vec2(iResolution.x / iResolution.y, 1.), iResolution, state.rotation);\n    \n    vec3 steelNorm = texture(iChannel2, steelCoord/iResolution.xy).xyz;\n    steelNorm.xz += getNormalFromWalls(p * vec2(iResolution.x / iResolution.y, 1.), iResolution, state.rotation) * (1.0 - smoothstep(0.007, 0.01, -wallDist));\n\n    steelNorm = normalize(steelNorm);\n    vec3 lightDir = normalize(vec3(1,-1,1));\n    float steelSpec = computeSpecular(0.8, 15.0, steelNorm, lightDir, vec3(0.0, 1.75-p.x, 0.5 - p.y));\n    vec4 steel = vec4(vec3(steelSpec), 1.0) * 0.5 + 0.3;\n\n    fragColor = mix(fragColor, steel, vec4(clamp(-wallDist*iResolution.y, 0.0, 1.0)));\n    //fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).xy,0,0);\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 1500; \nconst float PARTICLE_REPEL_SIZE = 0.01;\n\nconst float PI = 3.141592653589793;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return p * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution);\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 1e-10)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.x, sc.y, sc.y, -sc.x);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    vec2 c = (point - vec2(.5*resolution.x/resolution.y,  .5))*1.2;\n    float minDist = 1e30;\n    minDist = min(minDist, .5 - length(c));\n    const int NUM_PADDLES = 10;\n    for (int i = 0; i < NUM_PADDLES; ++i)\n    {\n        minDist = min(minDist, sdBox((rot2(time + float(i) *2.* PI / float(NUM_PADDLES))*c + vec2(0.0, 0.5)), vec2(0.01, 0.2)));\n    }\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 delta = vec2( 0.001, 0.0 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + delta.xy, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - delta.xy, resolution, time ); \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    float upTinyChangeInY   = distanceFromWalls( point + delta.yx, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - delta.yx, resolution, time ); \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n\tvec2 normal = vec2(tinyChangeInX, tinyChangeInY);\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define SIZE 5\n#define COLOR 6\n#define NUM_PARTICLE_DATA_TYPES 7\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    float size;\n    float closestDist;\n    vec3 color;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, SIZE), 0);\n    vec4 particleData6 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, COLOR), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.size = particleData5.x;\n    particle.closestDist = particleData5.y;\n    particle.color = particleData6.xyz;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case SIZE:\n        return vec4(p.size, p.closestDist, 0, 0);\n    case COLOR:\n        return vec4(p.color, 0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nstruct fxState\n{\n    float resolution;\n    float rotation;\n    float velocity;\n    float mouse;\n    bool motor;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    fxState state;\n    state.resolution = data.x;\n    state.rotation = data.y;\n    state.velocity = data.z;\n    state.mouse = abs(data.w);\n    state.motor = data.w < 0.;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state)\n{\n    return vec4(state.resolution, state.rotation, state.velocity, state.mouse * (state.motor ? -1. : 1.));\n}\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_P 80\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n", "buffer_a_code": "const vec2 GRAVITY = vec2(0.0000, -0.00003);\nconst float PARTICLE_REPEL = 0.001;\nconst float WATER_VISCOSITY = 0.0000000005;\nconst float OIL_VISCOSITY = 0.0000000025;\nconst float OIL_SEP = 4e-7;\nconst float COLLISION_BOUNCE = 0.6;\nconst float WALL_BOUNCE = 1.5;\nconst float WALL_REPEL = 0.0005;\nconst float POSITION_CORRECTION = 0.025;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\n#define RGB(R, G, B) vec3(float(R), float(G), float(B)) / 255.0\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate MAX_PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    if (id == 0) return;\n    \n    fxParticle data = fxGetParticle(id);\n    fxState state = fxGetState();\n    \n    if (dataType >= POS_VEL)\n    {\n        if (iFrame == 0 || state.resolution < 0.)\n        {\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = (vec2((i + 0.5*(mod(j, 2.0))) / particlesPerRow, j / particlesPerRow) * vec2(1., 1.) + vec2(0., -0.3)) * vec2(iResolution.x / iResolution.y, 1.0);\n            data.vel = vec2(0);\n            data.size = 1e6;\n                        \n            switch(int(4.* j / particlesPerRow))\n            {\n                // Top quarter of the particles are oil\n                case 3:  data.color = RGB(241,190,2); break;\n                default:data.color = RGB(255,255,255); break;\n            }\n         }\n        else\n        {\n            vec2 force = GRAVITY;\n            // I tried making gravity stronger on the water, but then they\n            // fell at different speeds which bothered me. Here's how I did\n            // it, for reference.\n            //if (data.color != vec3(1)) force /= 5.5;\n            float minDist = 1e6;\n            float minCirc = 1e6;\n            \n            float visc = WATER_VISCOSITY;\n            if (data.color != vec3(1))\n            {\n                visc = OIL_VISCOSITY;\n            }\n\n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    fxParticle n = fxGetParticle(cid);\n                    \n                    vec2 deltaPos = data.pos - n.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    vec2 dir = deltaPos / dist;\n \n                    // Absorb some velocity from nearby particles\n                    force += visc * n.vel / square(dist);\n\n                    // Apply SPH attract/repel force\n                    force -= PARTICLE_REPEL * dir * SPHgradKernel(dist / (0.1*PARTICLE_REPEL_SIZE));\n\n                    // Repel small neighbors (restores density)\n                    if (data.size < PARTICLE_REPEL_SIZE*.8 && n.size < data.size && n.size > 1e-6 && data.size > 1e-6 && iFrame > 10)\n                    {\n                        force += 9.*(PARTICLE_REPEL_SIZE - data.size) * dir * (data.size - n.size);\n                    }\n                    \n                    // \"Buoyancy\" force due to oil/water density difference\n                    if (data.color != n.color)\n                    {\n                        if (data.color == vec3(1))\n                        {\n                            force.y -= OIL_SEP / dist;\n                        }\n                        else\n                        {\n                            force.y += OIL_SEP / dist;\n                        }\n                    }\n                    \n                    // Collide with neighbor\n                    if (dist < PARTICLE_REPEL_SIZE * 2.)\n                    {\n                        data.pos -= dir * (dist - PARTICLE_REPEL_SIZE * 2.) * POSITION_CORRECTION;\n                        float normalVel = dot(dir, data.vel - n.vel);\n                        if (normalVel < 0.)\n                        {\n                            data.vel -= COLLISION_BOUNCE * dir * normalVel;\n                        }\n                    }\n\n                    // Record some data for size computation\n                    minDist = min(minDist, dist*0.5);\n                    minCirc = min(minCirc, max(dist*0.5, 0.5*(dist - n.size)));\n                }\n            }       \n            \n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Record computed size\n            data.closestDist = minDist;\n            data.size = minCirc;\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, state.rotation);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, state.rotation - state.velocity);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, state.rotation);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= WALL_BOUNCE * distNormal * min(0., dot(distNormal, data.vel));\n                data.vel += WALL_REPEL * distNormal;\n            }\n            \n            // Damping\n            data.vel -= data.vel * (length(data.vel) + 0.01);\n\n            // Clamping\n            float maxSpeed = 0.003; // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos * vec2(iResolution.y / iResolution.x, 1.0))));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(data.neighbors[0][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[1][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[2][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[3][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            //pick random id of particle\n            int p = int(mod(h*34534.0, float(MAX_PARTICLES)));\n            sort0(bestIds, bestDists, id, int(p), dataType, data.pos);  //sort this\n        }\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 || id >= MAX_PARTICLES ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    if (iFragCoord == ivec2(0))\n    {\n        fxState state = fxGetState();\n        \n        if (iFrame == 0 || iResolution.x * iResolution.y != abs(state.resolution) || keyDown(KEY_SPACE))\n        {\n            state.resolution = -iResolution.x * iResolution.y;\n            state.mouse = 1.;\n            state.velocity = state.rotation = 0.0;\n            state.motor = true;\n        }\n        else\n        {\n            state.resolution = abs(state.resolution);\n            \n            if (state.mouse == 1. && (iFrame % 1000) == 0) state.motor = !state.motor;\n            \n            // Apply acceleration and damping\n            state.velocity += state.motor ? 0.00004 : 0.;\n            state.velocity *= 0.99;\n            \n            // Handle mouse input\n            if (iMouse.z > 0.)\n            {\n                if (iMouse.w > 0.)\n                {\n                    state.velocity = 0.;\n                    state.motor = !state.motor;\n                }\n                else\n                {\n                    state.velocity = clamp((abs(state.mouse) - iMouse.x - iMouse.y) / iResolution.x, -0.1, 0.1);\n                }\n\n                state.mouse = iMouse.x + iMouse.y;\n            }\n            \n            // Integrate rotation\n            state.rotation += state.velocity;\n        }\n        \n        fragColor = fxPutState(state);\n        return;\n    }\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n    \n    ivec4 old   = fxGetClosest( iFragCoord );      \n\n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, screen2world(fragCoord));\n        insertion_sort( new, dis, id, dis2 );\n    }\n    \n    // Search randomly in the nearest 15x15 neighbors instead of just\n    // the next-door neighbors. Seems to allow faster particle movement\n    uint searchRange = 15u;\n    uint searchCount = 16u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, screen2world(fragCoord));\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++)\n    {\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "\nconst vec3 lightDir = normalize(vec3(1,-1,1));\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = sqrt(linePointDist2(p.pos, p.pos - p.vel, fragCoord, iResolution, closest));\n   \n    if (p.color == vec3(1))\n    {\n        // water\n        float drawSize = min(p.size,PARTICLE_REPEL_SIZE)*1.5;\n        fragColor.x = max(fragColor.x, mix(fragColor.x, 1., 1.-smoothstep(drawSize*0.2, drawSize * 2.5, dist)));\n    }\n    else\n    {\n        // oil\n        float drawSize = PARTICLE_REPEL_SIZE * 2.;//min(p.size,PARTICLE_REPEL_SIZE)*2.;\n        fragColor.y = max(fragColor.y, mix(fragColor.y, 1., 1.-smoothstep(drawSize*0.25, drawSize * 1.5, dist)));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    fragColor = vec4(0);\n    \n  \tvec2 p = fragCoord/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n\n    //draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N =  15;                              // target sampling rate\nfloat         w,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  w = .0125; \\\n              z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nvec2 convol2D(vec2 U) {                                                     \n    vec2  O = vec2(0.0);  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z ).xy;  \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init\n    vec2 p = (u - iResolution.xy * 0.5) / iResolution.y;\n    if (length(p) < 0.5) // restrict blur to circle to improve speed\n    {\n        vec2 U = u / R.y;  \n        O.xy = convol2D(U);\n    }\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldBRs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1773, 1773, 1804, 1804, 2254], [2256, 2256, 2419, 2419, 2624], [2677, 2677, 2731, 2789, 4532]], "test": "untested"}
{"id": "NtcfDf", "name": "just a humble spiral or smth", "author": "Varyemez", "description": "lorem ipsum", "tags": ["spiral"], "likes": 3, "viewed": 194, "published": 3, "date": "1663708058", "time_retrieved": "2024-07-30T16:30:22.610094", "image_code": "const int MAX_ITER = 100;\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 100.0;\nconst float PI = radians(180.);\n\nmat2 rot2d(float r)\n{\n    return mat2(cos(r), -sin(r), sin(r), cos(r));\n}\n\nfloat rect(vec3 p, vec3 dimensions)\n{\n    return length(max(abs(p) - dimensions/2., vec3(0.)));\n    //return length(p.xz) - 0.15;\n}\n\nfloat scene_dist(vec3 p)\n{\n    p.xy *= rot2d(length(p));\n    p.xy = abs(p.xy);\n    p.z = fract(p.z);\n    p -= vec3(0.5,.5,0.5);\n    p.yz *= rot2d(PI/2.);\n    p.xz *= rot2d(iTime);\n    return rect(p, vec3(.25,1.,.25));\n}\nfloat raymarch(vec3 p, vec3 dir)\n{\n    float dist = 0.;\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        float d = scene_dist(p + dist*dir);\n        dist += d;\n        \n        if (dist >= MAX_DIST || d <= MIN_DIST) break;\n    }\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    vec3 ray_dir = normalize(vec3(uv.xy, 1.));\n    float d = raymarch(vec3(0, 0, iTime), ray_dir);\n    \n    vec3 color = vec3(0.9, 0.,0.8);\n    fragColor = vec4(color.rgb/max(d*.4, 1.), 1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 139, 139, 191], [193, 193, 230, 230, 324], [326, 326, 352, 352, 545], [546, 546, 580, 580, 802], [804, 804, 861, 861, 1123]], "test": "untested"}
{"id": "sltBD2", "name": "Smoll Ray Tracer", "author": "GetItemFromBlock", "description": "A base implementation of a ray tracer, use WASDQE to move, hold clic to rotate the camera\nYou can change the FOV with the up and down arrow keys\nTo switch to AZERTY controls, comment the first line in \"Common\".", "tags": ["raytracing", "rtx"], "likes": 3, "viewed": 199, "published": 3, "date": "1663706569", "time_retrieved": "2024-07-30T16:30:23.619396", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 factor = fragCoord / iResolution.xy * 2. - vec2(1,1);\n    float fov = 70. + texture(iChannel0, vec2(2.5/iResolution.x,0)).x;\n    vec3 pos = texture(iChannel0, vec2(0,0)).xyz;\n    vec2 rot = texture(iChannel0, vec2(1.5/iResolution.x,0)).zw;\n    Ray r = Ray(pos, normalize(vec3(1., factor.y * fov / 100., factor.x * fov / 100. * iResolution.x / iResolution.y)) );\n    r.dir = vec3(\n    r.dir.x * cos(radians(rot.y)) - r.dir.y * sin(radians(rot.y)),\n    r.dir.y * cos(radians(rot.y)) + r.dir.x * sin(radians(rot.y)),\n    r.dir.z);\n    r.dir = normalize(vec3(\n    r.dir.x * cos(radians(rot.x)) - r.dir.z * sin(radians(rot.x)),\n    r.dir.y,\n    r.dir.z * cos(radians(rot.x)) + r.dir.x * sin(radians(rot.x))));\n    HitRecord nearest = HitRecord(false, vec2(0,0), r.dir, vec3(0,0,0), vec3(1,1,1), 1e24);\n    lowp int type = MIRROR;\n    int iter = 0;\n    int sphereIndex = -1;\n    spheres[0].pos = pos;\n    lights[0].pos = vec3(cos(iTime*.2)*-100.,150.,sin(iTime*.2)*20.);\n    bool reversed = false;\n    while (type != 0 && iter < MAX_REF)\n    {\n        iter++;\n        int minIndex = -1;\n        vec3 tmpcol = nearest.color;\n        for (int i = 0; i < spheres.length(); i++)\n        {\n            HitRecord rec = HitSphere(r, spheres[i], .0, nearest.dist, tmpcol, reversed);\n            if (rec.hit && (!nearest.hit || rec.dist < nearest.dist))\n            {\n                sphereIndex = i;\n                nearest = rec;\n                type = spheres[i].type;\n            }\n        }\n        for (int i = 0; i < tris.length(); i++)\n        {\n            HitRecord rec = HitTriangle(r, tris[i], .0, nearest.dist, tmpcol, reversed);\n            if (rec.hit && (!nearest.hit || rec.dist < nearest.dist))\n            {\n                sphereIndex = -1;\n                nearest = rec;\n                type = tris[i].type;\n            }\n        }\n        if (!nearest.hit) break;\n        for (int i = 0; i < lights.length(); i++)\n        {\n            Ray lr = Ray(nearest.point, normalize(lights[i].pos-nearest.point));\n            vec3 norm = nearest.normal;\n            if (type == 0) norm = normalize(nearest.normal+texture(iChannel2, nearest.normal).xyz*.1-.05);\n            float factor = dot(lr.dir,norm);\n            if (factor < 0.) continue;\n            bool hit = false;\n            for (int n = 0; n < spheres.length(); n++)\n            {\n                if (sphereIndex == n) continue;\n                HitRecord rec = HitSphere(lr, spheres[n], .0001, 1e24, vec3(0,0,0), true);\n                if (rec.hit)\n                {\n                    hit = true;\n                    break;\n                }\n                \n            }\n            if (!hit) for (int n = 0; n < tris.length(); n++)\n            {\n                HitRecord rec = HitTriangle(lr, tris[n], .0001, 1e24, vec3(0,0,0), true);\n                if (rec.hit)\n                {\n                    hit = true;\n                    break;\n                }\n            }\n            if (!hit)\n            {\n                vec3 halfV = normalize(lr.dir - r.dir);\n                float deltaB = pow(max(dot(norm, halfV), 0.0), 512.);\n                nearest.color += vec3(lights[i].strength * factor*.45 + deltaB);\n            }\n        }\n        if (type != 0)\n        {\n            r.pos = nearest.point;\n            if (type == MIRROR)\n            {\n                r.dir = reflect(r.dir, nearest.normal);\n            }\n            else\n            {\n                vec3 newDir = refract(r.dir, nearest.normal, reversed ? 1.45 : 0.689655);\n                if (dot(newDir, nearest.normal) < 0.) reversed = !reversed;\n                else\n                {\n                    newDir = reflect(r.dir, nearest.normal);\n                }\n                r.dir = newDir;\n            }\n            nearest.normal = r.dir;\n            nearest.dist = 1e24;\n            nearest.hit = false;\n        }\n    }\n    if (!nearest.hit)\n    {\n        float s = pow(max(dot(normalize(lights[0].pos-pos), r.dir), 0.0), 512.);\n        fragColor = texture(iChannel1, nearest.normal)*vec4(nearest.color*.7,1.)+s;\n    }\n    else\n    {\n        fragColor = vec4(nearest.color,1.);\n    }\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tmp = fragCoord / iResolution.xy * iChannelResolution[1].xy;\n    if (int(tmp.x) == 0 && int(tmp.y) == 0)\n    {\n        vec3 mov = vec3(texture(iChannel0, vec2(bindings[0]/256.,0.)).x*iTimeDelta -\n        texture(iChannel0, vec2(bindings[1]/256.,0.0)).x*iTimeDelta,\n        texture(iChannel0, vec2(bindings[2]/256.,0.0)).x*iTimeDelta -\n        texture(iChannel0, vec2(bindings[3]/256.,0.0)).x*iTimeDelta,\n        texture(iChannel0, vec2(bindings[4]/256.,0.0)).x*iTimeDelta -\n        texture(iChannel0, vec2(bindings[5]/256.,0.0)).x*iTimeDelta);\n        vec2 rot = texture(iChannel1, vec2(1.5/iResolution.x,0)).zw;\n        mov = vec3(\n        mov.x * cos(radians(rot.x)) - mov.z * sin(radians(rot.x)),\n        mov.y,\n        mov.z * cos(radians(rot.x)) + mov.x * sin(radians(rot.x)));\n        fragColor = texture(iChannel1, vec2(0,0)) + vec4(\n        mov*2.,\n        1);\n    }\n    else if (int(tmp.x) == 1 && int(tmp.y) == 0)\n    {\n        vec4 old = texture(iChannel1, vec2(1.5/iResolution.x,.0));\n        fragColor = vec4(\n        iMouse.x,\n        iMouse.y,\n        mod(((iMouse.z > .5 && iMouse.w < .5) ? iMouse.x - old.x : .0)*.4 + texture(iChannel1, vec2(1.5/iResolution.x,0.0)).z, 360.),\n        clamp(((iMouse.z > .5 && iMouse.w < .5) ? iMouse.y - old.y : .0)*.4 + texture(iChannel1, vec2(1.5/iResolution.x,0.0)).w, -90., 90.));\n    }\n    else if (int(tmp.x) == 2 && int(tmp.y) == 0)\n    {\n        fragColor = vec4(\n        texture(iChannel0, vec2(40./256.,0.0)).x*iTimeDelta*30. -\n        texture(iChannel0, vec2(38./256.,0.0)).x*iTimeDelta*30.,\n        0,0,1) + texture(iChannel1, vec2(2.5/iResolution.x,0));\n        fragColor.x = clamp(fragColor.x, -69.99, 180.);\n    }\n    else\n    {\n        fragColor = vec4(0.,0.,0.,1.);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define QWERTY\n\n#define OPAQUE 0\n#define MIRROR 1\n#define TRANSP 2\n\nstruct HitRecord\n{\n    bool hit;\n    vec2 UV;\n    vec3 normal;\n    vec3 point;\n    vec3 color;\n    float dist;\n};\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n    vec3 pos;\n    float radius2;\n    vec3 color;\n    lowp int type;\n};\n\nstruct Triangle\n{\n    vec3 A, AB, AC;\n    vec3 normal;\n    vec3 color;\n    lowp int type;\n};\n\nstruct Light\n{\n    vec3 pos;\n    float strength;\n};\n\nHitRecord HitSphere(Ray r, Sphere sp, float minimum, float maximum, vec3 colorIn, bool reverse)\n{\n    HitRecord result = HitRecord(false, vec2(0,0), vec3(0,1,0), vec3(0,0,0), vec3(1,1,1), 0.0);\n    float t0, t1;\n    vec3 L = r.pos - sp.pos;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(r.dir, L);\n    float c = dot(L,L) - sp.radius2;\n    float discr = b * b - 4.0 * a * c;\n    if (discr < 0.0)\n    {\n        return result;\n    }\n    else if (discr == 0.0)\n    {\n        t0 = - 0.5 * b / a;\n        t1 = t0;\n       }\n    else\n    {\n        float q = (b > 0.0) ? -0.5 * (b + sqrt(discr)) : -0.5 * (b - sqrt(discr));\n        t0 = q / a;\n        t1 = c / q;\n    }\n    if (reverse ? (t1 > t0) : (t0 > t1))\n    {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    if (t0 < minimum || t0 > maximum) {\n        return result;\n    }\n    result.hit = true;\n    result.dist = t0;\n    result.point = r.pos + r.dir * t0;\n    result.normal = normalize(result.point-sp.pos);\n    if (reverse) result.normal = -result.normal;\n    result.color = colorIn * sp.color;\n    return result;\n}\n\nHitRecord HitTriangle(Ray r, Triangle tr, float minimum, float maximum, vec3 colorIn, bool reverse)\n{\n\tHitRecord result = HitRecord(false, vec2(0,0), vec3(0,1,0), vec3(0,0,0), vec3(1,1,1), 0.0);\n    if (reverse)\n    {\n        vec3 pvec = cross(r.dir, tr.AB);\n        float det = dot(tr.AC, pvec);\n        if (det < 0.00001) return result;\n        vec3 tvec = r.pos - tr.A;\n        result.UV.x = dot(tvec, pvec);\n        if (result.UV.x < .0 || result.UV.x > det) return result;\n        vec3 qvec = cross(tvec, tr.AC);\n        result.UV.y = dot(r.dir, qvec);\n        if (result.UV.y < .0 || result.UV.y + result.UV.x > det) return result;\n        det = 1./det;\n        result.dist = dot(tr.AB, qvec) * det;\n        if (result.dist < minimum || result.dist > maximum) return result;\n        result.UV *= det;\n        result.normal = -tr.normal;\n    }\n    else\n    {\n        vec3 pvec = cross(r.dir, tr.AC);\n        float det = dot(tr.AB, pvec);\n        if (det < 0.00001) return result;\n        vec3 tvec = r.pos - tr.A;\n        result.UV.x = dot(tvec, pvec);\n        if (result.UV.x < .0 || result.UV.x > det) return result;\n        vec3 qvec = cross(tvec, tr.AB);\n        result.UV.y = dot(r.dir, qvec);\n        if (result.UV.y < .0 || result.UV.y + result.UV.x > det) return result;\n        det = 1./det;\n        result.dist = dot(tr.AC, qvec) * det;\n        if (result.dist < minimum || result.dist > maximum) return result;\n        result.UV *= det;\n        result.normal = tr.normal;\n    }\n\tresult.point = r.pos + r.dir * result.dist;\n    result.color = colorIn * tr.color;\n\tresult.hit = true;\n\treturn result;\n}\n\n#define MAX_REF 50\n\nSphere[] spheres = Sphere[] (\nSphere(vec3(0,0,0), 0.5, vec3(.85,.85,.9), MIRROR),\nSphere(vec3(4,0.1,1.2),1.0, vec3(.6,.1,.8), OPAQUE),\nSphere(vec3(3.8,-1.2,-0.8),4.0, vec3(.3,.6,.8), OPAQUE),\nSphere(vec3(5.7,0.7,-0.2),2.0, vec3(.1,.7,.4), OPAQUE),\nSphere(vec3(3.5,2.5,2.0),0.8, vec3(.85,.9,.85), TRANSP),\nSphere(vec3(3.0,3.2,-6.8),25.0, vec3(.9,.85,.85), MIRROR));\n\nTriangle[] tris = Triangle[] (\nTriangle(vec3(-1,1,4),vec3(0,-2,-2),vec3(0,-2,0),vec3(-1,-0,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(-1,1,2),vec3(2,-2,0),vec3(0,-2,0),vec3(-0,-0,-1),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,1,2),vec3(0,-2,2),vec3(0,-2,0),vec3(1,-0,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,1,4),vec3(-2,-2,0),vec3(0,-2,0),vec3(-0,-0,1),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,-1,2),vec3(-2,0,2),vec3(-2,0,0),vec3(-0,-1,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(-1,1,2),vec3(2,0,2),vec3(2,0,0),vec3(-0,1,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(-1,1,4),vec3(0,0,-2),vec3(0,-2,-2),vec3(-1,-0,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(-1,1,2),vec3(2,0,0),vec3(2,-2,0),vec3(-0,-0,-1),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,1,2),vec3(0,0,2),vec3(0,-2,2),vec3(1,-0,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,1,4),vec3(-2,0,0),vec3(-2,-2,0),vec3(-0,-0,1),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(1,-1,2),vec3(0,0,2),vec3(-2,0,2),vec3(-0,-1,-0),vec3(.7,.4,.4),TRANSP),\nTriangle(vec3(-1,1,2),vec3(0,0,2),vec3(2,0,2),vec3(-0,1,-0),vec3(.7,.4,.4),TRANSP),\n\nTriangle(vec3(-3,-.5,0), vec3(0,0,1), vec3(1,0,0), vec3(0,1,0), vec3(.9,.9,.9), MIRROR),\nTriangle(vec3(-2,-.5,0), vec3(-1,0,1), vec3(0,0,1), vec3(0,1,0), vec3(.9,.9,.9), MIRROR));\n\nLight[] lights = Light[] (\nLight(vec3(-100,150,50), 1.1));\n\n#ifdef QWERTY\n    float[] bindings = float[] (87.5, 83.5, 69.5, 81.5, 68.5, 65.5);\n#else\n    float[] bindings = float[] (90.5, 83.5, 69.5, 65.5, 68.5, 81.5);\n#endif", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 4202]], "test": "untested"}
{"id": "Nt3fDX", "name": "Windows GLSL bug #67", "author": "FabriceNeyret2", "description": "on Windows Angle, wrong eval of test : b1 = a is done before the test ! \n-> Windows: all red but top right that is black.\n    OpenGL:   all red but bottom right is green ( which is the correct result )", "tags": ["glsl", "bug"], "likes": 1, "viewed": 211, "published": 3, "date": "1663693225", "time_retrieved": "2024-07-30T16:30:24.443193", "image_code": "// acid test extracted from https://shadertoy.com/view/7lcfDB\n\n  #define OP    ( b1 = a, ( I = k < 1 ? 1. : .5 ) ) // a simpler test would work\n//#define OP    ( ( I = k < 1 ? 1. : .5 ), b1 = a ) // fails differently on Windows\n\nvoid mainImage( out vec4 O, vec2 u ) {\n\n    vec2 R = iResolution.xy;\n    float a=0., b1=1., b2=b1, I=0.; \n    int k = 0, y = int(3.*u.y/R.y);\n  //const int k=0;               // would make it work on Windows Angle\n    \n    if (u.x<R.x/2.)              // LEFT\n       { if (a < b1)  OP ; }   \n    else                         // RIGHT:\n      if (y==2)                  //    TOP:\n             a < b1 ? OP : I;    //      should be like #13 but don't works on Windows Angle but const test would\n      else if (y==1)             //    MIDDLE:\n             a < b2 ? OP : I;    //      like #16 but works, since b1 not used in test\n      else if (y==0)             //    BOTTOM:\n            a == b1 ? OP : I;    //      proof that (b1=a) is done too early: get red instead of green on Windows Angle\n\n    O = vec4(I,b1,a,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3fDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 267, 267, 1049]], "test": "untested"}
{"id": "ft3fWX", "name": "Windows GLSL bug #66", "author": "FabriceNeyret2", "description": "on windows, black but if you uncomment either line 11 or 15.\n", "tags": ["glsl", "bug"], "likes": 2, "viewed": 256, "published": 3, "date": "1663690194", "time_retrieved": "2024-07-30T16:30:25.247043", "image_code": "// Fork of \"BuckleUp (golfed)\" by FabriceNeyret2. https://shadertoy.com/view/7lcfDB\n\nvoid mainImage( out vec4 O, vec2 u ) {\n\n    float f;\n    O = vec4(0);\n    \n    for (float i=0.; i < 5.; i++) {\n        for (float j = 0.; j < 2.; j++)\n            f =  iTime*4. + i/2.; \n     // f = fract(f);                    // try uncomment\n        O += fract(f);\n    }  \n    \n   //if ( isnan(O.r)) O = vec4(1,0,0,1); // try uncomment\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3fWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 123, 123, 424]], "test": "untested"}
{"id": "7ltBD2", "name": "Zoomed Refracted Apollonion ", "author": "SnoopethDuckDuck", "description": "basically a plane with a fractal removed from inside of it, im not sure how long it can zoom for before breaking completely\n\nalso might look less centred the more it zooms (had to offset the point it looks at because of refraction)", "tags": ["fractal", "weird", "refract", "appollonion"], "likes": 10, "viewed": 268, "published": 3, "date": "1663690118", "time_retrieved": "2024-07-30T16:30:26.074830", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 10.\n#define SURF_DIST .1\n\n// RayMarching from TheArtOfCode\n\n// From BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(in vec2 p, in vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nvec3 GetRayOrigin() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = 5.;\n    float a = 0.25 * iTime;\n    vec3 ro = vec3(r * cos(a), 7, r * sin(a));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat test(vec3 p0) {\n   // p0.y += 4.;\n    float sd = length(p0.xz) - 3.;\n    //p0 *= 0.5;\n    //sd = p0.y - 0.5;\n    vec4 p = vec4(p0, 1.);\n    p.y += 0.05 * iTime;\n    for(int i = 0; i < 6; i++){\n      p.xyz = mod(p.xyz-1., 2.)-1.;\n      p*=(1./dot(p.xyz, p.xyz));\n    }\n    p/=p.w;\n    return max(sd, abs(p.y));\n}\n\nfloat GetDist(vec3 p) {\n    float d2 = p.y + 0.02 *  dot(p.xz,p.xz);//0.005 * length(p.xz);//length(p) - 0.5;\n    \n    vec3 dim = vec3(0.5,100.,0.5);\n    float d = length(p + vec3(0,2,0)) - 1.;\n    //d = sdBox(p + vec3(0,2. + dim.y,0), dim) - 0.25;\n    d = test(p + vec3(0,2,0));\n    d2 = -smin(-d2, d, 0.1);\n    return d2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = GetRayOrigin();\n    \n    // starts becoming unenjoyable before ~1000 seconds\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.025,0), 1. + iTime * tanh(0.1 * iTime));\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n    \n    vec3 p = ro + rd * d;\n    float IOR = 2.;\n    if(d<MAX_DIST) {        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(nExit, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n           \n        float spec = pow(dif, 15.);\n        \n        if (dIn < MAX_DIST) {\n            float fres = pow(1. + dot(rd, n), 5.);\n            float fres2 = pow(1. + dot(rd, nExit), 4.);\n\n            vec3 c1 = texture(iChannel0, iTime * 0.01 + 0.5 * pExit.xy).rgb;\n            vec3 c2 = texture(iChannel0, iTime * 0.01 + 0.5 * pExit.yz).rgb;\n            vec3 c3 = texture(iChannel0, iTime * 0.01 + 0.5 * pExit.zx).rgb;\n            vec3 c = nExit.z * c1 + nExit.x * c2 + nExit.y * c3;\n            col = clamp(col + spec, 0., 1.); //???\n            col = mix(col, vec3(0), 1. - fres2);\n            \n            float k = 0.25;\n            col += smoothstep(-k,k, c.r-0.5);\n        }\n        float fog = 1.-exp(-0.5 * length(p));\n        col = mix(col, vec3(0.5 * col), fog);\n        col *= pal(fog + 1.75, 0.5 * vec3(0,1,1)/3.);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 204, 204, 280], [282, 282, 320, 320, 385], [387, 387, 406, 406, 489], [491, 491, 520, 520, 601], [603, 603, 637, 637, 713], [715, 715, 736, 736, 952], [954, 954, 975, 993, 1271], [1273, 1273, 1296, 1296, 1598], [1600, 1600, 1643, 1643, 1950], [1952, 1952, 1976, 1976, 2166], [2168, 2168, 2218, 2218, 2409], [2411, 2411, 2468, 2468, 4167]], "test": "untested"}
{"id": "sltfWj", "name": "The surface of the Sun", "author": "klk", "description": "The surface of the Sun (as imagined by an artist)", "tags": ["sun", "plasma"], "likes": 28, "viewed": 630, "published": 3, "date": "1663675859", "time_retrieved": "2024-07-30T16:30:26.882670", "image_code": "// Created by Alex Kluchikov\n\nvec2 rot(vec2 p,float a)\n{\n    float c=cos(a*15.83);\n    float s=sin(a*15.83);\n    return p*mat2(s,c,c,-s);\n}\n\nvoid mainImage(out vec4 o, in vec2 uv)\n{\n    uv/=iResolution.xx;\n    uv=vec2(.125,.75)+(uv-vec2(.125,.75))*.015;\n    float T=iTime*.5;\n\n    vec3 c = normalize(.75-.25*vec3(\n        sin(length(uv-vec2(.1,0))*132.+T*3.3),\n        sin(length(uv-vec2(.9,0))*136.-T*2.5),\n        sin(length(uv-vec2(.5,1))*129.+T*4.1)\n        ));\n\n    vec3 c0=vec3(0);\n    float w0=0.;\n    float N=80.;\n    float wb=.012;\n    for(float i=0.;i<N;i++)\n    {\n        float wt=(i*i/N/N-.2)*.3;\n        float wp=0.5+(i+1.)*(i+1.5)*0.001;\n    \tc.zx=rot(c.zx,1.6+T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7+T*wt+(uv.y+1.1)*15.*wp);\n    \tc.yz=rot(c.yz,c.x*c.y*wb+2.4-T*0.79*wt+(uv.x+uv.y*(fract(i/2.)-0.25)*4.)*17.*wp);\n    \tc.zx=rot(c.zx,c.y*c.z*wb+1.6-T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7-T*wt+(uv.y+1.1)*15.*wp);\n        float w=(1.5-i/N);\n        c0+=c*sqrt(w);\n        w0+=sqrt(w);\n    }\n    c0=c0/w0*3.+.5;\n    \n\to=vec4(sqrt(c0.r)*1.2,c0.r*c0.r*.9,c0.r*c0.r*c0.r*.4,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 56, 56, 139], [141, 141, 181, 181, 1135]], "test": "untested"}
{"id": "fttfWj", "name": "Colliding Scribbles", "author": "fenix", "description": "Another experiment with particles-in-cells, this time adding collision between particles. The particles seem to organize into similar-colored regions since they can move freely through their own color.\n*space to reset*\n*mouse to erase particles*", "tags": ["2d", "collision", "particles", "abstract"], "likes": 10, "viewed": 269, "published": 3, "date": "1663657813", "time_retrieved": "2024-07-30T16:30:27.686521", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another experiment with particles-in-cells, this time adding collision\n//  between particles. The particles seem to organize into similar-colored\n//  regions since they can move freely through their own color. Since laying\n//  down trails of their own color protects them and similar colored particles,\n//  the particles establish zones of the same color, fighting for dominance\n//  along region boundaries.\n//\n//  Each region also seems to have a primary direction, which reminds me of\n//  crystal growth, the the resulting patterns have a crystal-like quality.\n//\n//  The mouse allows you to delete areas when they are getting too boring.\n//\n// ---------------------------------------------------------------------------------------\n\nvec3 floatToColor(float f)\n{\n    return normalize(sin((f + iTime * .01) * vec3(3,4,5)) * 0.5 + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    cellData d = unpackCell(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    \n    fragColor = vec4(mix(vec3(1), floatToColor(d.color), d.trailDensity), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A updates a compressed cellData per pixel\n\n// Particles die after this many frames\nconst float MAX_AGE = 4000.0;\n\n// Particles are created each frame on each pixel with this probability\nconst float SPAWN_PROBABILITY = 2e-6;\n\n// Bigger RANGE makes larger velocities possible, but starts to be prohibitively expensive\nconst int RANGE = 5;\n\n// Control particle rendering into the trail buffer\nconst float MIN_SIZE = 0.0;\nconst float MAX_SIZE = 1.6;\n\nbool collides(vec2 fragCoord, vec2 from, vec2 to, float color, out vec2 normal)\n{\n    vec2 delta = to - from;\n    if (abs(delta.x) > abs(delta.y))\n    {\n        float f = delta.y / delta.x;\n        float s = sign(delta.x);\n        for (vec2 x = from; x.x * s <= to.x * s; x += vec2(s, f))\n        {\n            cellData d = unpackCell(texelFetch(iChannel0, ivec2(fragCoord + x), 0));\n            if (d.trailDensity > 0.25 && d.color != color)\n            {\n                normal = vec2(sin(d.trailDir), cos(d.trailDir));\n                return true;\n            }\n        }\n    }\n    else if (abs(delta.y) > 0.)\n    {\n        float f = delta.x / delta.y;\n        float s = sign(delta.y);\n        for (vec2 y = from; y.y * s <= to.y * s; y += vec2(f, sign(delta.y)))\n        {\n            cellData d = unpackCell(texelFetch(iChannel0, ivec2(fragCoord + y), 0));\n            if (d.trailDensity > 0.25 && d.color != color)\n            {\n                normal = vec2(sin(d.trailDir), cos(d.trailDir));\n                return true;\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    \n    if (ifc == ivec2(0))\n    {\n        // Reset if resolution doesn't match\n        if ((iFrame % 2000) == 0 || abs(state.xy) != iResolution.xy || keyDown(KEY_SPACE))\n        {\n            fragColor = vec4(-iResolution.xy, vec2(.5));\n        }\n        else\n        {\n            if (iMouse.z > 0.)\n            {\n                state.zw = iMouse.xy / iResolution.xy;\n            }\n            \n            fragColor = vec4(abs(state.xy), state.zw);\n        }\n        return;\n    }\n    \n    float h = hash(\n        ifc.x + \n        ifc.y*int(iResolution.x) + \n        iFrame*int(iResolution.x*iResolution.y)\n    );\n    \n    if (iFrame == 0 || state.x < 0.)\n    {\n        // Clear buffer\n        cellData init;\n        init.pos = vec2(0.5, 0.5);\n        init.vel = vec2(0);\n        init.density = 0.0;\n        init.trailDensity = 0.0;\n        init.color = 0.0;\n        init.trailDir = 0.0;\n        \n        fragColor = packCell(init);\n\n        return;\n    }\n    \n    if (h > 1. - SPAWN_PROBABILITY)\n    {\n        // Spawn new particle\n        float h1 = hash(\n            ifc.x*int(iResolution.x) + \n            ifc.y*int(iResolution.y) + \n            iFrame*int(iResolution.x*iResolution.y)\n        );\n\n        float h2 = hash(int(h1*994888228.));\n        float h3 = hash(int(h2*4343555.));\n        float h4 = hash(int(h3*84999223.));\n\n        cellData newParticle;\n        newParticle.pos = vec2(0.5, 0.5); // Start in the middle of the cell\n        newParticle.vel = normalize(vec2(h2 - 0.5, h3 - 0.5));\n        newParticle.density = 1.0;\n        newParticle.trailDensity = 1.0;\n        newParticle.color = h1;\n        newParticle.trailDir = atan(newParticle.vel.y, newParticle.vel.x);\n        \n        fragColor = packCell(newParticle);\n    }\n    else\n    {\n        float newDensity = 0.;\n        vec2 newVel = vec2(0);\n        cellData d = unpackCell(texelFetch(iChannel0, ivec2(fragCoord), 0));\n\n        // Search the nearest NxN cells to find any that has density that wants to move into our cell\n        for (int x = -RANGE; x <= RANGE; ++x)\n        {\n            for (int y = -RANGE; y <= RANGE; ++y)\n            {\n                if (ifc.x + x < 0 || ifc.x + x >= int(iResolution.x)) continue;\n                if (ifc.y + y < 0 || ifc.y + y >= int(iResolution.y)) continue;\n\n                cellData nb = unpackCell(texelFetch(iChannel0, ivec2(fragCoord) + ivec2(x, y), 0));\n\n                vec2 nbPos = nb.pos + vec2(x, y);\n                vec2 newNbPos = nbPos + nb.vel * float(RANGE);\n                \n                if (nb.density > 0.)\n                {\n                    vec2 normal;\n                    if (collides(fragCoord, nbPos, newNbPos, nb.color, normal))\n                    {\n                        nb.vel = reflect(nb.vel, normal);\n                        //float temp = nb.vel.x;\n                       // nb.vel.x = -nb.vel.y;\n                        //nb.vel.y = temp;\n                        \n                        newNbPos = nbPos + nb.vel * float(RANGE);\n                    }\n                    else\n                    {\n                        // Apply some rotation to make the spirals\n                        nb.vel = rot2((nb.color - 0.5) * 0.5) * nb.vel;\n                    }\n\n                    // Draw smooth line from old position to new, even if it jumped past our position\n                    float aa = smoothstep(MAX_SIZE, MIN_SIZE, linePointDist(fragCoord + newNbPos, fragCoord + nbPos, fragCoord));\n                    \n                    // Use full color if we're drawing on black\n                    d.color = d.trailDensity < .2 || aa > .2 ? nb.color : d.color;\n                    d.trailDensity += aa;\n                    d.trailDir = nb.trailDir;\n                    \n                    if (all(greaterThan(newNbPos, vec2(0))) && all(lessThan(newNbPos, vec2(1))))\n                    {\n                        d.pos = newNbPos;\n                        newVel = nb.vel;\n                        newDensity = 1.;\n                    \n                        d.trailDir = nb.trailDir;\n                        d.color = nb.color; // Copy over the whole color so it doesnt get lost even with thin lines\n                    }\n                }\n            }\n        }\n\n        if (iMouse.z > 0.0)\n        {\n            vec2 delta = iMouse.xy - fragCoord;\n            if (length(delta) < iResolution.y * 0.25)\n            {\n                newDensity = 0.;\n            }\n        }\n        // Record data in fragColor\n\n        d.vel = newVel;\n        d.density = min(1., newDensity);\n        d.trailDensity *= 0.95; // Fade out old density to keep the display from becoming too busy\n\n\n        fragColor = packCell(d);\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pack2(vec2 v)\n{\n    return uintBitsToFloat(packSnorm2x16(v));\n}\n\nvec2 unpack2(float f)\n{\n    return unpackSnorm2x16(floatBitsToUint(f));\n}\n\nstruct cellData\n{\n    vec2 pos;           // 0 ... 1, position within the cell\n    vec2 vel;           // -1 ... 1, multiplied by RANGE\n    float density;      // either 0 or 1, depending on if a particle is present\n    float trailDensity; // 0 ... 1, allows particles to leave trails behind\n    float trailDir;\n    float color;        // 0 ... 1, color of trail\n};\n\ncellData unpackCell(vec4 c)\n{\n    cellData d;\n    \n    d.pos = unpack2(c.x);\n    d.vel = unpack2(c.y);\n    vec2 den = unpack2(c.z);\n    d.density = den.x;\n    d.trailDensity = den.y;\n    vec2 colorDir = unpack2(c.w);\n    d.color = colorDir.x;\n    d.trailDir = colorDir.y;\n    \n    return d;\n}\n\nvec4 packCell(cellData d)\n{\n    float x = pack2(d.pos);\n    float y = pack2(d.vel);\n    float z = pack2(vec2(d.density, d.trailDensity));\n    float w = pack2(vec2(d.color, d.trailDir));\n    \n    return vec4(x, y, z, w);\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nmat2 rot2(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat length2(vec2 x)\n{\n    return dot(x, x);\n}\n\nfloat linePointDist(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        // Line is very short; either end will do\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    return distance(closest, fragCoord);\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttfWj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[949, 949, 977, 977, 1051], [1053, 1053, 1110, 1110, 1268]], "test": "untested"}
{"id": "7lcfD2", "name": "2d weird things", "author": "jorge2017a2", "description": "2d weird things", "tags": ["2dweirdthings"], "likes": 12, "viewed": 188, "published": 3, "date": "1663641399", "time_retrieved": "2024-07-30T16:30:28.490372", "image_code": "//por jorge2017a2\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n//2d weird things---- 19-sep-2022\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nvec3 EscaleraX1(vec2 p,vec3 colIn,  vec3 colOut)\n{\n float t=0.0;\n    float x=p.x; \n    float fx2=3.0*sin(x)/x;\n float fx3= 2.0*noise(vec2(3.*x+t,1.0))+fx2;\n   float y1=p.y+fx3;\n    float y2=p.y+5.0;\n    float yg2= differenceSDF(y1,y2);\n    vec3 col= DrawFigBorde(colIn, colOut, yg2); //verde noise    \n    return col;\n}\n\nvec3 EscaleraX(vec2 p,vec3 colIn,  vec3 colOut)\n{   float t=mod(p.x,3.0);\n    float x=p.x;\n    float fx1=sin(x);\n    float fx5=floor(x);\n    float fx6=sin(fx5 -0.5 )+2.0*(fx5/8.0);\n    fx6+=cos(fx5*1.5 +x)+2.0*(fx5/8.0);\n    \n    float y1=p.y+fx6;\n    float y2=p.y+5.0;\n    \n    float yg0= differenceSDF(y1,y2);\n    float fxy1=yg0;\n    \n    vec3 col;\n    col= DrawFigBorde(colIn, colOut, fxy1); \n    \n    return col;\n}\n\nvec3 EscaleraY(vec2 p , vec3 colIn, vec3 colOut)\n{   float t=0.0;\n    float y=p.y;\n    float fx1=4. + 4.*smoothstep(0.0,0.7,sin(y+t));\n    float fx5=(t + floor(y-t))/2.0 - 5.0;\n    float fx6=sin(fx5 -0.5 )+2.0*(fx5/8.0);\n    \n    float y1=p.x+fx6;\n    float y2=p.x+2.0;\n    float yg0= differenceSDF(y1,y2);\n    float fxy1=yg0;\n    vec3 col= DrawFigBorde(colIn, colOut, fxy1); \n    \n    return col;\n}\n\n\nvec3 EscaleraY2(vec2 p,vec3 colIn, vec3 colOut)\n{   float t=0.0;\n    float y=p.y;\n    float fx1=4. + 4.*smoothstep(0.0,0.7,sin(y+t+cos(y*0.5)));\n    float fx5=(t + floor(y-t))/2.0 - 5.0;\n    float fx6=sin(fx5 -0.5 )+2.0*(fx5/8.0);\n    float y1=p.x+fx6;\n    float y2=p.x+2.0;\n    \n    float yg0= differenceSDF(y1,y2);\n    float fxy1=yg0;\n    vec3 col;\n    col= DrawFigBorde(colIn, colOut, fxy1); \n    return col;\n}\n\n\nvec3 EscaleraY3(vec2 p,vec3 colIn, vec3 colOut)\n{   float t=0.0;\n    float y=p.y;\n    float fx1=step(0.5,sin(y*5.0));\n    float fx5=(t + floor(y-t))/2.0 - 5.0;\n    fx5*=fx1;\n    float fx6=sin(fx5 -0.5 )+2.0*(fx5/8.0);\n    \n    float y1=p.x+fx6;\n    float y2=p.x+2.0;\n    \n    float yg0= differenceSDF(y1,y2);\n    float fxy1=yg0;\n    \n    vec3 col;\n    col= DrawFigBorde(colIn, colOut, fxy1); \n    \n    return col;\n}\n\nvec3 EscaleraY4(vec2 p,vec3 colIn, vec3 colOut)\n{   float t=0.0;\n    float y=p.y;\n    float fx1=4. + 4.*smoothstep(0.0,0.7,sin(y+t+cos(y*0.5)));\n    float fx5=(t + floor(y-t))/2.0 - 5.0;\n    fx5+=fx1;\n    float fx6=sin(fx5 -0.5 )+0.5*sin(2.0*fx5+2.0);\n    \n    float y1=p.x+fx6;\n    float y2=p.x+2.0;\n    \n    float yg0= differenceSDF(y1,y2);\n    float fxy1=yg0;\n    \n    vec3 col;\n    col= DrawFigBorde(colIn, colOut, fxy1); \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float t=iTime*5.0;\n    float esc=8.0+3.0*sin(t+cos(t)+0.5*cos(2.0*t));\n    \n    uv*=esc;\n    vec2 uv0=uv;\n    uv.y-=3.;\n    uv.x+=-10.0+mod(t,4.0);\n     vec3 col=vec3(0.2,0.1,1.8);\n    col= EscaleraX(uv, vec3(0.1),col);\n    uv=uv0;\n    uv.y-=3.;\n    uv.x+=t;\n    col=EscaleraX1(uv,vec3(0.2,0.2,0.3),  col);\n    \n    uv.x= opRep1D(uv.x+iTime, 12.0 );\n    \n    uv.x=abs(uv.x)-0.5;\n    col= EscaleraY(uv*3.5, vec3(0.5,0.5,0.8), col);\n    \n    uv=uv0;\n    uv.x= opRep1D(uv.x+t, 20.0 );\n    uv-=vec2(-4.0,0.0);\n    uv.x=abs(uv.x)-1.5;\n    col= EscaleraY2(uv, vec3(0.5,0.5,0.1), col);\n    \n    uv=uv0;\n    uv.x= opRep1D(uv.x+t*2., 30.0 );\n    uv-=vec2(10.0,-2.0);\n    uv.x=abs(uv.x)-1.5;\n    col= EscaleraY3(uv, vec3(0.8,0.5,0.1), col);\n    \n    uv=uv0;\n    uv.x= opRep1D(uv.x+t*2., 35.0 );\n    uv-=vec2(14.0,-1.0);\n    \n    uv.x=abs(uv.x)-1.5;\n    col= EscaleraY4(uv, vec3(1.,0.1,0.1), col);\n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 335, 371, 371, 416], [422, 422, 469, 469, 496], [497, 497, 540, 540, 567], [568, 568, 616, 616, 644], [648, 648, 710, 710, 840], [842, 842, 923, 923, 1051], [1053, 1117, 1144, 1144, 1218], [1220, 1298, 1324, 1324, 1704], [1707, 1707, 1757, 1757, 2026], [2028, 2028, 2077, 2077, 2446], [2448, 2448, 2498, 2498, 2847], [2850, 2850, 2899, 2899, 3263], [3266, 3266, 3315, 3315, 3681], [3683, 3683, 3732, 3732, 4132], [4135, 4135, 4192, 4192, 5269]], "test": "untested"}
{"id": "sltfWS", "name": "Acoustic Pipes", "author": "pyBlob", "description": "Pressure wave through pipes.", "tags": ["wave", "simulation", "acoustic"], "likes": 8, "viewed": 222, "published": 3, "date": "1663639813", "time_retrieved": "2024-07-30T16:30:29.270286", "image_code": "/*\nThings to try out (need recompile and reset):\n    - Input waveforms (cw-pulse, cw, pulse)\n    - Switch visualized field (v variable in mainImage)\n    - Wavelengths (f variable in _step)\n    - Pipe shapes (initialization in update)\n\nBuffer:\n    .x radius of pipe\n    .y mass density \"m\" contained in this pipe element\n    .z mass flux \"f\" into this pipe element from the left\n\nUsing short notation for derivatives: for fn(a, b)\n    fn_a (a, b) == d  fn(a, b) / d a\n    fn_b (a, b) == d  fn(a, b) / d b\n    fn_ab(a, b) == d² fn(a, b) / d a / d b\n\nModels an acoustic wave in a pipe:\n    x          : L\n    t          : T\n    c          : L/T\n    damping    : 1/T\n    area(x)    : L²\n    mass(x, t) : M/L\n    flux(x, t) : M/T\n\nThis assumes that the sound pressure level and flow velocity is small, so that \"c\" can be considered constant.\n\nProblems:\n    - Stability issues when using more than one buffer. (off by one?, precision?)\n\nCode:\n    mass_t(x, t) : M/L/T =\n        - flux_x(x, t)\n\n    density  (x, t) : M/L³ =\n          (mass  (x, t) : M/L) / (area(x) : L²)\n    density_x(x, t) : M/L⁴ =\n          (mass_x(x, t) : M/L²) / (area(x)  : L²)\n        - (mass  (x, t) : M/L ) / (area(x)² : L⁴) * (area_x(x) : L)\n\n    effective_mass_x(x, t) : M/L²\n        = density_x(x, t) * area(x)\n        = (mass_x (x, t) : M/L²)\n        - (density(x, t) : M/L³) * (area_x(x) : L)\n\n    flux_t(x, t) : M/T² =\n        - (effective_mass_x(x, t) : M/L²) * (c² : L²/T²)\n        - (flux(x, t) : M/T) * (damping : 1/T)\n\nInteresting:\n    For a settled one-way wave without damping, without sources, without sinks and a fixed cross-section:\n        (mass : M/L) is proportional to (-flux : M/T) or (+flux : M/T)\n    Basically, you can measure distances using either length or time with \"c\" as the proportionality constant.\n    This get's really obvious when applying the constraints and multiplying mass with \"c\":\n\n        mass_t(x, t) = -     flux_x(x, t)\n        flux_t(x, t) = -     mass_x(x, t) * c²\n                     = - sym_mass_x(x, t) * c\n\n        sym_mass  (x, t) : M/T  =   mass(x, t) * c\n        sym_flux  (x, t) : M/T  =   flux(x, t)\n\n        -- same unit, same update !!\n        sym_mass_t(x, t) : M/T² = - flux_x(x, t) * c\n        sym_flux_t(x, t) : M/T² = - mass_x(x, t) * c\n\n*/\n\nvoid mainImage(out vec4 C, vec2 O)\n{\n    ivec2 I = ivec2(O);\n    int y = int(O.y / iResolution.y * float(npipes));\n    float Oy = O.y - (float(y) + .5) * iResolution.y / float(npipes);\n    \n    vec4 h = texelFetch(iChannel0, ivec2(I.x, y), 0);\n    C = vec4(0);\n    float r = h.x - abs(Oy);\n    float v = h.y; // mass\n    //v = h.z / c; // flux\n    if (r > 0.)\n    {\n        if (true)\n        //if (false)\n        {\n            C = mix(C, vec4(0, .1, 1, 1), clamp(-v, 0., 1.));\n            C = mix(C, vec4(1, .2, 0, 1), clamp(+v, 0., 1.));\n        }\n        else\n            C = mix(C, vec4(0,  1, 0, 1), clamp(abs(v), 0., 1.));\n    }\n    C = mix(C, vec4(1), clamp((1. + .3 * abs(dFdx(r))) - abs(r), 0., 1.));\n    C = sqrt(C);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "buffer(0)", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int   npipes = 5     ;\nconst int   sub    = 80    ; // (step/bufferframe)\nconst float c      = 1./20.; // speed of sound (px/step)\n\nconst float pi = radians(180.);\nconst float tau = pi * 2.;\n\n#define buffer(i) \\\nvoid mainImage(out vec4 C, vec2 O) \\\n{ \\\n    update(C, O, iChannel0, iResolution, iFrame * 1 + i); \\\n} \\\n\nconst int N = 1 + 2 * sub;\nint base;\nvec4 frame[N];\nvec4 dframe[N];\nvec3 resolution;\n\nvec4 fetch(int i)\n{\n    return frame[i];\n}\n\nvec4 _step(float t, int i)\n{\n    vec4 L = fetch(i - 1);\n    vec4 C = fetch(i);\n    vec4 R = fetch(i + 1);\n    \n    // wavelength [px]\n    float f = 10.;\n    //f = 50.;\n    f = resolution.x * .2;\n    \n    // period [step]\n    f /= c;\n\n    // waveforms\n    float z = 0.;\n    z = sin(t*tau/f) * .03 * float(t/f < 2.); // cw-pulse\n    //z = sin(t*tau/f) * .01; // cw\n    //float xt=t*tau/f-3.; z = exp(-xt*xt)*.03; // pulse\n\n    // boundary flux (left/right)\n    float lz = 0., rz = 0.;\n    lz = z, rz = 0.;\n    //lz = 0., rz = z;\n    \n    if (base+i == 0)\n        L.y = C.y, C.z = lz;\n    if (base+i == int(resolution.x)-1)\n        R.z = rz;\n    \n    // change of mass\n    float dm = 0.;\n    dm += C.z - R.z; // through boundary\n    \n    // effective pressure\n    float ep = (L.y-C.y) + 2.*mix(L.y,C.y,.5)*(L.x-C.x)/mix(L.x,C.x,.5);\n\n    // change of flux\n    float df = 0.;\n    df += ep * c * c; // through pressure\n    //if (false)\n        df -= C.z * 3e-5; // through damping\n\n    return vec4(0, dm, df, 0);\n}\n\nfloat constriction(float x, float w, float s)\n{\n    s /= resolution.x;\n    float a = .5-w;\n    float b = .5+w;\n    return mix(1., .1, smoothstep(a-s, a, x) - smoothstep(b, b+s, x));\n}\n\nfloat narrowing(float x, float w, float s)\n{\n    s /= resolution.x;\n    s /= 2.;\n    return mix(1., .4, smoothstep(w-s, w+s, x));\n}\n\nvoid update(out vec4 C, vec2 O, sampler2D iChannel0, vec3 iResolution, int iFrame)\n{\n    resolution = iResolution;\n    ivec2 I = ivec2(O);\n    \n    if (I.y >= npipes)\n    {\n        C = vec4(1,2,3,4);\n        return;\n    }\n\n    const int startFrame = 1;\n    //if (iFrame < startFrame) // preview doesn't work in firefox\n    if (texelFetch(iChannel0, ivec2(0, npipes), 0) != vec4(1,2,3,4))\n    {\n        float x = O.x / resolution.x;\n        float h = resolution.y/2./float(npipes)*.8;\n        if (I.y == 4)\n            h *= constriction(x, .1, 10.);\n        if (I.y == 3)\n            h *= constriction(x, .1, 100.);\n        if (I.y == 1)\n            h *= narrowing(-x, -.4, 10.);\n        if (I.y == 0)\n            h *= narrowing(x, .4, 10.);\n        C = vec4(h, 0, 0, 0);\n        return;\n    }\n    \n    base = I.x - sub;\n    for (int j=0 ; j<N ; ++j)\n        frame[j] = texelFetch(iChannel0, ivec2(base + j, I.y), 0);\n    for (int i=0 ; i<sub ; ++i)\n    {\n        float t = float((iFrame - startFrame) * sub + i);\n        // Leapfrog integration\n        // 1. Update flow\n        for (int j=1+i ; j<N-(1+i) ; ++j)\n            dframe[j] = _step(t, j);\n        for (int j=1+i ; j<N-(1+i) ; ++j)\n            frame[j] += dframe[j] * vec4(0, 0, 1, 0);\n        t += .5;\n        // 2. Update mass\n        for (int j=1+i ; j<N-(1+i) ; ++j)\n            dframe[j] = _step(t, j);\n        for (int j=1+i ; j<N-(1+i) ; ++j)\n            frame[j] += dframe[j] * vec4(0, 1, 0, 0);\n    }\n    C = fetch(I.x - base);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7tdBRX", "name": "RT in One Weekend: Diffuse", "author": "piyushslayer", "description": "Finally decided to give Ray Tracing In One Weekend book (Peter Shirley) a try. Covers until Ch 8 (Diffuse Materials). Drag the mouse to rotate camera. ", "tags": ["raytracing", "ray", "illumination", "tracing", "diffuse", "montecarlo", "hash", "weekendmglobal"], "likes": 3, "viewed": 270, "published": 3, "date": "1663625321", "time_retrieved": "2024-07-30T16:30:30.016292", "image_code": "/**\n* Finally decided to give Ray Tracing In One Weekend (Peter Shirley) a try.\n*\n* http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\n*\n* This shader covers diffuse (Ch. 7 of the book), seemed like a good checkpoint to \n* save in case I needed to start over carrying forward. I'll probably cover reflection\n* and refraction chapters in the next shader.\n*\n* Most of the ray tracer logic lies in the common tab with some initialization and input handling\n* in Buffer A. Buffer B stores last frame's mouse location. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 outColor = textureLod(iChannel0, uv, 0.0);\n    fragColor = vec4(pow(outColor.xyz, vec3(1.0 / 2.2)), 1.0);\n    if (fragCoord.x < 1.0) fragColor = vec4(0.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI         3.1415926535\n#define TWO_PI     6.2831853071\n\n#define Saturate(x) clamp(x, 0.0, 1.0)\n#define RemapNDC(x) (x * 0.5 + 0.5)\n\nconst float cameraNear = 0.001;\nconst float cameraFar  = 65535.0;\nconst float cameraRadius = 5.0;\nconst float cameraZoom = 2.5;\n\nconst int numberOfSpheres = 2;\n\nstruct Ray\n{\n    vec3 origin, direction;\n};\n\nstruct HitResult\n{\n    float t;\n    vec3 position, normal;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nconst Sphere sphereList[numberOfSpheres] = Sphere[](\n    Sphere(vec3(0.0), 1.0),\n    Sphere(vec3(0.0, -5001.0, 0.0), 5000.0)\n);\n\n// Quality hashes collection by nimitz https://www.shadertoy.com/view/Xt3cDn\nfloat hashSeed = 0.0;\n\nuint BaseHash(uvec2 p) {\n    p = 1103515245U * ((p >> 1U) ^ (p.yx));\n    uint h32 = 1103515245U * ((p.x) ^ (p.y >> 3U));\n    return h32 ^ (h32 >> 16);\n}\n\nvec2 Hash2(inout float seed) {\n    uint n = BaseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec2 rz = uvec2(n, n * 48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\nvec3 Hash3(inout float seed) {\n    uint n = BaseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    uvec3 rz = uvec3(n, n * 16807U, n * 48271U);\n    return vec3(rz & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\n// Source: Karthik Karanth's blog: \n// https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\nvec3 RandomPointInUnitSphere(inout float seed) {\n    vec3 h = Hash3(seed) * vec3(TWO_PI, 2.0, 1.0) - vec3(0.0, 1.0, 0.0);\n    float theta = h.x;\n    float sinPhi = sqrt(1.0 - h.y * h.y);\n    float r = pow(h.z, 1.0 / 3.0);\n    \n    return r * vec3(cos(theta) * sinPhi, sin(theta) * sinPhi, h.y);\n}\n\nvec3 GetIntersectPoint(in Ray ray, in float t)\n{\n    return ray.origin + ray.direction * t;\n}\n\nvec3 GetBackgroundColor(in float y)\n{\n    // Get a nice skyblue-ish gradient background\n    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), y);\n}\n\nbool IntersectSphere(in Ray ray, in Sphere sphere, in float tMin, in float tMax, inout HitResult result)\n{\n    vec3 oc = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere.radius * sphere.radius;\n    float d = b * b - a * c;\n    \n    if (d > 0.0)\n    {\n        float temp = (-b - sqrt(d)) / a;\n        if (temp < tMax && temp > tMin)\n        {\n            result.t = temp;\n            result.position = GetIntersectPoint(ray, temp);\n            result.normal = normalize(result.position - sphere.center);\n            return true;\n        }\n        \n        temp = (-b + sqrt(d)) / a;\n        if (temp < tMax && temp > tMin)\n        {\n            result.t = temp;\n            result.position = GetIntersectPoint(ray, temp);\n            result.normal = normalize(result.position - sphere.center);\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nbool IntersectWorld(in Ray ray, inout HitResult worldResult)\n{\n    float closestHit = cameraFar;\n    HitResult tempResult;\n\n    for (int i = 0; i < numberOfSpheres; ++i)\n    {\n        if (IntersectSphere(ray, sphereList[i], cameraNear, closestHit, tempResult))\n        {\n            closestHit = tempResult.t;\n            worldResult = tempResult;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n#define MAX_BOUNCES 8\n\nvec3 GetSceneColor(in Ray ray)\n{\n    HitResult worldResult;\n    vec3 sceneColor = vec3(1.0);\n    \n    for (int i = 0; i < MAX_BOUNCES; ++i)\n    {\n        if (IntersectWorld(ray, worldResult))\n        {\n            ray = Ray(worldResult.position, normalize(worldResult.normal + RandomPointInUnitSphere(hashSeed)));\n            sceneColor *= 0.5;\n        }\n    }\n    \n    return sceneColor * GetBackgroundColor(ray.direction.y * 0.5 + 0.5);\n}\n\nmat3 GetCameraMatrix(vec3 origin, vec3 target)\n{\n    vec3 lookAt = normalize(target - origin);\n    vec3 right = normalize(cross(lookAt, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(right, lookAt));\n    return mat3(right, up, lookAt);\n}\n\nRay GetCameraRay(vec2 uv, vec2 cameraMouse)\n{\n    // Make the camera arcball-ish using spherical coordinates\n    vec2 theta = vec2(0.);\n\n    theta.x = cameraMouse.x * PI * 4.;\n    theta.y = mix(PI * 0.16, PI * 0.564, cameraMouse.y);\n\n    vec3 origin = vec3(0.);\n    origin.x = sin(theta.x) * sin(theta.y);\n    origin.y = cos(theta.y);\n    origin.z = cos(theta.x) * sin(theta.y);\n    origin *= cameraRadius;\n    \n    // Generate camera ray through a camera view matrix\n    vec3 target = vec3(0.);\n    mat3 camera = GetCameraMatrix(origin, target);\n    vec3 direction = normalize(camera * vec3(uv, cameraZoom));\n    return Ray(origin, direction);\n}", "buffer_a_code": "/**\n* Buffer A initializes stuff for ray tracing (camera, rays, input handling etc) and initiates\n* the ray tracing process. At the end, it accumulates the ray traced result with the previously\n* accumulated history buffer. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    hashSeed = float(BaseHash(floatBitsToUint(fragCoord))) / float(0xffffffffU) + iTime;\n    \n    vec2 uv = (2.0 * (floor(fragCoord) + Hash2(hashSeed)) - iResolution.xy) / iResolution.y;\n    \n    vec4 currentMouse = iMouse / iResolution.xyxy;\n    vec4 previousMouse = texelFetch(iChannel1, ivec2(fragCoord), 0); // last frame mouse coords\n    vec2 cameraPositionUVSpace = texelFetch(iChannel0, ivec2(0), 0).xy;\n    \n    vec4 historyColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float sampleCount = historyColor.w;\n    \n    // Add mouse drag velocity to camera so it only moves from its current position\n    if (currentMouse.z > 0.0 && previousMouse.z > 0.0)\n    {\n        cameraPositionUVSpace += currentMouse.xy - previousMouse.xy;\n        cameraPositionUVSpace.y = Saturate(cameraPositionUVSpace.y);\n        \n        // Reset history on mouse click\n        sampleCount = 1.0;\n        historyColor.xyz = vec3(0.0);\n    }\n    \n    // Reset history on resolution change\n    if (texelFetch(iChannel0, ivec2(0), 0).z != iResolution.x)\n    {\n        sampleCount = 1.0;\n        historyColor.xyz = vec3(0.0);\n    }\n    \n    vec3 outColor = vec3(0.);\n    \n    if (iFrame == 0) // Initial camera position\n    {\n        cameraPositionUVSpace = vec2(0.0, 0.8);\n        sampleCount = 1.0;\n    } \n    \n    outColor = GetSceneColor(GetCameraRay(uv, cameraPositionUVSpace));\n    outColor = mix(historyColor.xyz, outColor, 1.0 / sampleCount++);\n    \n    // Save the cameraPosition at [0, 0] coordinate of this buffer\n    if (all(lessThan(fragCoord, vec2(1.0))))\n    {\n        outColor = vec3(cameraPositionUVSpace, iResolution.x);\n    }\n    \n    fragColor = vec4(outColor, sampleCount);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/**\n* Buffer B just saves the current frame's mouse position for it to be used in the next frame.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse = iMouse / iResolution.xyxy;\n    fragColor = mouse;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdBRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[539, 539, 596, 596, 805]], "test": "untested"}
{"id": "NltBDB", "name": "Fractured Torus F", "author": "SnoopethDuckDuck", "description": "bit of a mess. it's quite fun to refract inside stuff, then use exit values for fog/fresnel/usual stuff", "tags": ["f"], "likes": 6, "viewed": 198, "published": 3, "date": "1663614515", "time_retrieved": "2024-07-30T16:30:30.774265", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// RayMarching from TheArtOfCode\n\n// From BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(in vec2 p, in vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nvec3 GetRayOrigin() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = 12. - 8.5 * tanh(0.25 * iTime);\n    float a = -0.1 * iTime;\n    vec3 ro = vec3(r * cos(a), 0, r * sin(a));\n   // ro.yz *= rot(-m.y*3.14+1.);\n   // ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float oa = atan(p.x, p.z);\n    vec3 op = p;\n    p.xz = sabs(p.xz) - 2.;\n    p.y += 0.1 * cos(4. * p.x + iTime);\n    \n    float a = atan(p.x, p.z);\n    p.y += 0.1 * cos(3. * oa + iTime);\n    \n    //p.y = abs(p.y) - 1.5;\n    float r1 = 1.25;\n    float r2 = 0.75 + 0.5 * cos(a + iTime);\n    float d1 = length(p.xz) - r1;\n    float d2 = sdBox(vec2(p.y, d1), vec2(r2,1)) - 0.1;\n    return d2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = GetRayOrigin();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n    \n    vec3 p = ro + rd * d;\n    float IOR = 1.15 + (0.5 + 0.5*thc(2.,0.4 * iTime))*0.25 * h21(floor(10. * p.yy + 0.5 * iTime));\n    //float IOR = 1.15 + 0.5 * h21(floor(10. * p.yy + 2100. * iTime));//0.001 * h21(uv + iTime * 0.01);\n    if(d<MAX_DIST) {        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        float dif2 = dot(nExit, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        float fres = pow(1. + dot(rd, n), 5.);\n        float fres2 = pow(1. + dot(rd, nExit), 5.);\n        float fog = 1.-cos(-1.2 * .4 * length(pExit)); //was exp\n\n        float spec = pow(dif, 15.);\n        float spec2 = pow(dif2, 15.);\n        //col += vec3(spec);\n        //col = mix(col, vec3(0), 1. - fres);\n        vec3 col2 = pal(log(length(pExit)) * 0.5, 0.5 * vec3(0,1,2)/3.);\n        col *= col2;\n        col = mix(col, vec3(0), 1. - fres2);\n        col = mix(col, vec3(spec), 0.5);\n        \n        col += col2 * pow(0.5 + 0.5 * cos(50. * log(length(pExit)) - 2. * iTime), 33.);\n        //col += spec2 * col2;\n        col *= pal(0.8 + log(length(pExit.xz)) + spec2 * 2., 0.5 * vec3(0,1,2)/3.);\n       col = mix(col, vec3(1,0.5,0.5), fog);\n   }\n    //col *= abs(rd) * 0.5 + 0.5;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    col *= 1. + (1.-exp(-0.25 * length(uv))) * .15 * thc(4., 0.75 * iResolution.y * uv.y);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltBDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 207, 207, 283], [285, 285, 323, 323, 388], [390, 390, 409, 409, 492], [494, 494, 523, 523, 604], [606, 606, 640, 640, 716], [718, 718, 739, 739, 983], [985, 985, 1008, 1008, 1402], [1404, 1404, 1447, 1447, 1754], [1756, 1756, 1780, 1780, 1970], [1972, 1972, 2022, 2022, 2213], [2215, 2215, 2272, 2272, 4162]], "test": "untested"}
{"id": "7lcfDB", "name": "BuckleUp (golfed)", "author": "FabriceNeyret2", "description": "golfed version of 2340 chars  \"BuckleUp\" by dila. https://shadertoy.com/view/MltXzN\n", "tags": ["raymarch", "golf"], "likes": 9, "viewed": 1047, "published": 3, "date": "1663605695", "time_retrieved": "2024-07-30T16:30:31.514287", "image_code": "// golfed version of 2340 chars  \"BuckleUp\" by dila. https://shadertoy.com/view/MltXzN\n\nvec4    A =      vec4(0,11,33,0);\n#define R(x)     mat2(cos(x+A))                                // rotation\n#define Q(v)     v * v\n#define T(c,p) ( Q( texture(c, p.xy) ) + Q( texture(c, p.xz) ) +Q ( texture(c, p.yz) ) ) / 3.   \n#define W        length\n\nvoid mainImage( out vec4 O, vec2 u ) {\n\tvec3  R = iResolution,\n          r = vec3( u+u, 0 ) - R,    o,p,P,s,a,q; \n    r.z = R.y - dot(r,r)/3. /R.y; \n    r /= W(r);\n    float h = .5, l = 0.,L,d,f, i=l, j=i, n=9., m,w,I=1., // Windows want init\n          t = o.z  = iTime * 4.; \n    o.xy =  - sin(t * h + A.xz );                              // origin o, direction r\n    r.xy *= R(sin(t * h/2.) * 1.57);\n    r.xz *= R(-o.x * .78);\n    r.yz *= R(-o.y * .78);\n    \n    for ( ; j++ < 32.; ) {                                     // --- trace\n        P = p = o + .6*r*l; \n        P.xy += sin(P.z*h +A.xz );                             // map - sdf to scene\n        m = 1e3; \n        s = 1./vec3(2,8,8);\n        q = a = vec3( mod( atan(P.x,P.y)/.39 + P.z/2. , 4.) - 2.,\n                      W(P.xy) - 3.,\n                      fract(P.z) - .5 \n                    );\n        for ( int k=0 ; k++ < 4; s = s.yzx * .75 ) {\n            q = abs(q) - .3,\n            q.xy *= R(.4), // pi/8\n            P = abs(q) - s,\n            w = min(max(P.x,max(P.y,P.z)),0.) + W(max(P,0.));  // sdBox\n         // w < m ?  m = w, I = k < 4 ? 4. : 1. : I;           // Windows get it wrong\n         // w < m ?  I = k < 4 ? 4. : 1. , m = w: I;           // differently wrong\n            if ( w < m )  m = w, I = k < 4 ? 4. : 1.;\n          }\n\n        l += d = max(m, -1.-a.y);\n      }\n\n    for ( O*=0.; ++i < n; ) {\n        for (j = L = 0.; j++ < 5.;  L += 5. - W(P) )           // --- trace2\n            P = o + r * L, \n            P.z -= floor( f = o.z + 4.*i/n );\n        P.xz *= R( 6.28 * i/n ); \n        f = fract(f);\n        O += T(iChannel1, .5*P) * f*(1.-f); // fract(f)*fract(-f); // bug on Windows\n    }  \n    l = 1. + l * l * .0036;  // fog\n    O += ( T(iChannel0, p) / I / ( l + l* d * 1e2 ) - O ) /l;\n\tO = sqrt( dot(O, vec4(.6,1.2,.2,0)) +O.zyxw /vec4(1,2,.67,1) );\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcfDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[342, 342, 380, 380, 2195]], "test": "untested"}
{"id": "fldBWS", "name": "Loading Animation-Fractal Based", "author": "spenceryonce", "description": "loading animation shader based on fractalizing uv space and rendering circles on the warped uvs. ", "tags": ["fractal", "circles", "animation", "loading"], "likes": 6, "viewed": 199, "published": 3, "date": "1663602363", "time_retrieved": "2024-07-30T16:30:32.322127", "image_code": "float circle(vec2 uv, float r){\n    return smoothstep(-0.01,0.01,(length(uv)-r));\n}\n\n\nvoid mainImage(out vec4 c, in vec2 fc)\n{\n    vec2 uv = (2.0*fc.xy -iResolution.xy)/iResolution.y;\n    float angle = 0.2 + sin(iTime)*0.3+cos(1./iTime);\n    \n    vec3 color = vec3(0.0);\n    \n    for(float i = 1.0;i<12.0;i+=1.0){\n        uv = abs(uv);\n    uv -= 0.5;\n    uv *= 1.1;\n    uv *= mat2(sin(angle),sin(angle),cos(angle),sin(angle));\n    uv += 0.5;\n    }\n    \n    float ci = circle(uv, 0.3+sin(iTime*2.)*0.1);\n    \n    color.r = ci;\n    \n    c = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldBWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 83], [86, 86, 126, 126, 557]], "test": "untested"}
{"id": "NltBWS", "name": "Simple, Fractal based on Circles", "author": "spenceryonce", "description": "was playing around with some circles and wanted to make a fractal that was using the equation of the circle on fractalized space. Which is what I've done here. ", "tags": ["fractal", "simple", "math", "circle"], "likes": 2, "viewed": 158, "published": 3, "date": "1663601905", "time_retrieved": "2024-07-30T16:30:33.086084", "image_code": "float circle(vec2 uv, float r){\n    return smoothstep(-0.01,0.01,(length(uv)-r));\n}\n\n\nvoid mainImage(out vec4 c, in vec2 fc)\n{\n    vec2 uv = (2.0*fc.xy -iResolution.xy)/iResolution.y;\n    float angle = 0.2 + sin(iTime)*0.3+cos(1./iTime);\n    \n    vec3 color = vec3(0.0);\n    \n    for(float i = 1.0;i<12.0;i+=1.0){\n        uv = abs(uv);\n    uv -= 0.5;\n    uv *= 1.1;\n    uv *= mat2(sin(angle),-sin(angle),cos(angle),sin(angle));\n    //uv += 0.5;\n    }\n    \n    float ci = circle(uv, 0.3+sin(iTime*2.)*0.1);\n    float cig = circle(uv, 0.3+cos(iTime*2.)*0.1);\n    \n    color.r = ci;\n    color.b=cig;\n    \n    c = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltBWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 83], [86, 86, 126, 126, 628]], "test": "untested"}
{"id": "stcBDB", "name": "group velocity demo", "author": "skal", "description": "Showcase of the difference between group velocity and phase velocity\nThe demo superposes several waves around a central wavelength.\nIt shows that the envelop of the superposed waves (the 'bulge') is traveling\nat half the speed of the main wave.", "tags": ["wave", "fluid", "dispersion", "waveequation"], "likes": 1, "viewed": 220, "published": 3, "date": "1663599880", "time_retrieved": "2024-07-30T16:30:33.835082", "image_code": "// The demo superposes several waves of wavelength uniformly\n// distributed in a window around a central wavelength Lambda0.\n//\n// The waves are assumed to be gravity waves at the surface\n// of very deep incompressible fluid (= ocean).\n// The dispersion relation is then 𝛚 = √(gk)\n//\n// The demo shows that the envelop of the superposed waves\n// (the 'bulge') is traveling at *half* the speed of the physical\n// (aka 'phase') speed of the main wave (≃ √(lambda0 * g)).\n//\n// y-mouse controls the number of sampling points (=superposed sources)\n// x-mouse divides the display in 3 regions resp.: \n//   drawing of the amplitude curve, circular wave, planar wave\n//\n// skal/ (Pascal Massimino)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n//\n//  https://en.wikipedia.org/wiki/Group_velocity\n//  http://www.cbeaume.com/download/MATH3620_chap6.pdf\n//\n\nconst float Lambda0 = 0.20;  // center of the window\nconst float dLambda = 0.02;  // window half-size\nconst vec2 uv0 = vec2(0., .5);   // origin of waves\n\nconst float eps = .05;  // drawn curve size\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  int draw_type = 0, N = 2 /* number of sources */;\n\n  if (iTime > 0.) {\n    draw_type = int(3. * iMouse.x / iResolution.x);\n    N = 2 + int(iMouse.y / iResolution.y * 10.);\n  }\n  float norm = 1. / float(2 * N - 1);\n  float t = iTime * 10.;\n  float acc0 = 0., acc = 0., dacc = 0.;\n  for (int i = -N + 1; i <= N - 1; ++i) {\n    float lambda = Lambda0 + float(i) * dLambda / float(N);\n    float omega = sqrt(1. / lambda);    // 2.𝛑.g = unity\n    vec2 r = uv - uv0;\n    float d = length(draw_type == 1 ? r : r.xx) * 50.;\n    float phi = d / lambda - omega * t;\n    dacc += -sin(phi) / lambda;  // derivative\n    acc += cos(phi);\n    if (i == 0) acc0 = cos(phi);  // stored for the background\n  }\n  dacc *= norm * 1.5;\n  acc = 0.5 + 0.5 * acc * norm;\n  if (draw_type > 0) {\n    fragColor = vec4(acc, acc, acc, 1.0);\n  } else {\n    float pt = abs(uv.y - acc) / sqrt(1. + dacc * dacc);\n    float d = 1. - clamp(pt, 0., eps) / eps;\n    vec3 background =\n        clamp(acc0 * uv.x * uv.x, 0., 1.) * vec3(.9, .1, .9);\n    vec3 col = mix(background, vec3(1., 1., 1.), d);\n    fragColor = vec4(col,1.0);\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcBDB.jpg", "access": "api", "license": "cc-by-nc-sa-2.0", "functions": [[1081, 1081, 1136, 1136, 2278]], "test": "untested"}
{"id": "7lcBDB", "name": "Scrolling Wave based on Position", "author": "Molgerax", "description": "Created as an example of how to displace e.g. a hexagon shield's parts by a wave travelling downwards. This shader gives a normalized output from 0 to 1, which can be applied to things like color interpolation or vertex displacement in other applications.", "tags": ["simple", "function", "1dtransformation"], "likes": 0, "viewed": 210, "published": 3, "date": "1663598049", "time_retrieved": "2024-07-30T16:30:34.583082", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    float frequency = 0.5;       // How often the ripple appears per second\n    float scrollingSpeed = 2.5;  // How fast the ripple propagates\n    float thickness = 0.3;       // How thick the ripple is in (1 == entire screen height)\n    \n    \n    // Take the height (here uv.y, but could be position.y)\n    float ripple = uv.y;\n    \n    // Add the time (according to some parameters) to the height, then take the fraction of that to get value from 0 to 1\n    ripple = fract((ripple + iTime * scrollingSpeed) * frequency / abs(scrollingSpeed));\n    \n    // Turn sawtooth wave ( /|/|/| ) into triangle wave ( /\\/\\/\\ )\n    ripple = abs(ripple * 2. - 1.);\n    \n    \n    // Cut off the wave below a certain threshold and smoothly blend\n    ripple = smoothstep(1.0 - thickness * frequency / abs(scrollingSpeed), 1.0, ripple);\n    \n    // Alternatively cut off the wave without smoothly blending\n    //ripple = step(1.0 - thickness * frequency / scrollingSpeed, ripple);\n\n\n    // Get the color and put it on the screen\n    vec3 col = vec3(ripple, ripple, ripple);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcBDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1244]], "test": "untested"}
{"id": "7l3BDB", "name": "Hexagonal LMR SDF V2", "author": "josaid", "description": "New implementation of an algorithm for limited repetition of Hexagonal SDFs in a Hexagonal Grid.\nBased on the works of Inigo Quilez (https://iquilezles.org) and Red Blob Games (https://redblobgames.com/grids/hexagons).", "tags": ["sdf", "repetition", "hexagon", "distance", "field", "hex", "tile", "hexagonal", "tilling", "signed", "limited"], "likes": 4, "viewed": 247, "published": 3, "date": "1663596935", "time_retrieved": "2024-07-30T16:30:35.335071", "image_code": "// The MIT License\n// Copyright © 2022 João Pedro Braz (brazjoaopedro@ymail.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define CAMERA_ZOOM 16.0\n#define GRID_RADIUS 8.0\n#define HEX_RADIUS 0.5\n#define HEX_MARGIN 0.0\n#define ANIMATED 1\n\nconst float PI = 3.141592653589793;\nconst float TAU = 2.0 * PI;\nconst float SQRT_3 = 1.732050807568877;\nconst float HALF_SQRT_3 = 0.8660254037844386;\nconst float THIRD_SQRT_3 = 0.5773502691896258;\nconst float THIRD = 0.33333333333333334;\nconst float TWO_THIRDS = 0.6666666666666667;\nconst float THREE_HALFS = 1.5;\nconst float EPSILON = 0.00000001;\n\nconst vec3 KERNEL = vec3(-HALF_SQRT_3, 0.5, THIRD_SQRT_3);\n\n// Transformation Utilities\nvec2 translate(vec2 point, vec2 by);\nvec2 scale(vec2 point, vec2 scale);\n\n\n// Hex Utilities\nbool is_inside_grid(vec3 hex, float half_width);\nvec3 cube_round(vec3 cube);\nvec3 uv_to_hex(vec2 uv, float size);\nvec2 hex_to_uv(vec3 hex, float size);\n\n\n// SDF Utilities\nfloat sd_hexagon(vec2 point, float half_size);\nfloat sd_segment(vec2 point, vec2 a, vec2 b);\nfloat sd_lmr_hexagon(vec2 point, float radius, float grid_radius);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Resolution dependent antialiasing, used with smoothstep\n\tfloat aa = 1.0 / min(iResolution.y, iResolution.x) * 10.0 * CAMERA_ZOOM;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Compute zoom taking into account the current aspect ratio\n\tvec2 zoom = iResolution.xy * CAMERA_ZOOM / min(iResolution.y, iResolution.x);\n    \n    // Our camera offset\n    vec2 camera_offset = vec2(0.0, 0.0);\n    if (iMouse.z > EPSILON) {\n        camera_offset = iMouse.xy / iResolution.xy;\n        camera_offset = scale(translate(camera_offset, vec2(0.5, 0.5)), zoom);\n    }\n    \n    // Center and scale the UV\n\tvec2 point = translate(scale(translate(uv, vec2(0.5, 0.5)), zoom), camera_offset);\n    \n    // Compute the current Hexagon in Cube Coordinates\n\tvec3 hex = uv_to_hex(point, HEX_RADIUS);\n    \n    // Get the center of the Hexagon\n\tvec2 center = hex_to_uv(hex, HEX_RADIUS);\n    \n    // Transform our UV into the Local Coordinate System of the Hexagon\n\tvec2 relative_point = (point - center) / HEX_RADIUS;\n\t\n    // Compute the SDF\n    float roundness = 0.0;\n#if ANIMATED == 1\n    roundness = cos(iTime * 0.75) * 1.1 + 1.0;\n#endif\n\n    vec3 color;\n    if (is_inside_grid(hex, GRID_RADIUS)) {\n        // Hexagon SDF\n        float signed_distance =\n            sd_hexagon(relative_point * (HEX_MARGIN + HEX_RADIUS + roundness), HEX_RADIUS) - roundness;\n\n        // Inigo Quilez's Color Scheme\n        color = vec3(1.0) - sign(signed_distance) * vec3(0.1,0.4,0.7);\n        color *= 1.0 - exp(-2.0 * abs(signed_distance));\n        color *= 0.8 + 0.2 * cos(signed_distance);\n        color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01 + aa, abs(signed_distance)));\n    } else {\n        // LMR Hexagonal Grid SDF\n        float signed_distance = sd_lmr_hexagon(point, HEX_RADIUS, GRID_RADIUS);\n        \n        color = mix(\n            color,\n            vec3(1.0),\n            smoothstep(\n                0.08 + aa * 0.25,\n                0.06,\n                abs(signed_distance - 0.25) + 0.05\n            )\n        );\n\n        color = mix(\n            color,\n            vec3(1.0),\n            smoothstep(\n                0.08 + aa * 0.25,\n                0.06,\n                abs(signed_distance - 0.02) + 0.06\n            )\n        );\n        \n\t\tcolor *= 1.0 - exp(-60.0 * abs(signed_distance));\n\t\tcolor *= 0.9 + 0.6 * cos(30.0 * signed_distance);\n\t\tcolor += (vec3(1.0, 0.58, 0.3) * cos(25.0 * signed_distance)) * smoothstep(0.01, 0.1, signed_distance);\n    }\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n\n\n// -- Transformation Utilities Implementations --\nvec2 translate(vec2 point, vec2 by) {\n    return point - by;\n}\n\nvec2 scale(vec2 point, vec2 scale) {\n    return point * scale;\n}\n\n// -- Hex Utilities Implementations --\n// Please check out https://www.redblobgames.com/grids/hexagons/\n// The source of most these functions.\nbool is_inside_grid(vec3 hex, float grid_radius) {\n\treturn (\n\t\tabs(hex.x) <= grid_radius && \n\t\tabs(hex.y) <= grid_radius && \n\t\tabs(hex.z) <= grid_radius\n\t);\n}\n\n// Justin Pombrio's\n// https://justinpombrio.net/programming/2020/04/28/pixel-to-hex.html\nvec3 cube_round(vec3 cube) {\n\tfloat a = ceil(cube.x - cube.y);\n    float b = ceil(cube.y - cube.z);\n    float c = ceil(cube.z - cube.x);\n\t\n\treturn vec3(\n\t\tround((a - c) / 3.0),\n\t\tround((b - a) / 3.0),\n\t\tround((c - b) / 3.0)\n\t);\n}\n\nvec3 uv_to_hex(vec2 uv, float size) {\n\tfloat q = uv.x * TWO_THIRDS / size;\n\tfloat r = (-THIRD * uv.x + THIRD_SQRT_3 * uv.y) / size;\n\tfloat s = -q - r;\n\n\treturn cube_round(vec3(q, r, s));\n}\n\nvec2 hex_to_uv(vec3 hex, float size) {\n\tfloat x = THREE_HALFS * hex.x * size;\n\tfloat y = ((HALF_SQRT_3 * hex.x) + (SQRT_3 * hex.y)) * size;\n\t\n\treturn vec2(x, y);\n}\n\n// -- SDF Utilities Implementations --\n// Please check out https://iquilezles.org/articles/distfunctions2d/\n// For other SDF functions\nfloat sd_hexagon(vec2 point, float radius) {\n    point = abs(point);\n    point -= 2.0 * min(dot(KERNEL.xy, point), 0.0) * KERNEL.xy;\n    point -= vec2(clamp(point.x, -KERNEL.z * radius, KERNEL.z * radius), radius);\n    return length(point) * sign(point.y);\n}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sd_lmr_hexagon(vec2 point, float radius, float grid_radius) {\n    float H = 2.0 * radius;     // height\n    float W = SQRT_3 * radius;  // width\n    float XS = W;               // horizontal spacing\n    float YS = H * 0.75;        // vertical spacing\n    \n    // Here you can swap point.y and point.x for pointy-hex grids\n    float a = PI + atan(point.y, point.x);\n    a = mod(round(a / TAU * 6.0) / 6.0 * TAU, TAU); // pick one of six wedges\n    // And also here, you can swap \"-sin(a), -cos(a)\" and \"cos(a), -sin(a)\" for pointy-hex grids\n    point = mat2(-sin(a), -cos(a), cos(a), -sin(a)) * point;\n\n    // q is the hexagonal column, should be an integer or half integer\n    float left_q = -grid_radius / 2.0;\n    float right_q = -left_q;\n    float q = round(point.x / W - left_q) + left_q;\n    q = clamp(q, left_q, right_q);\n   \n    // Distance field is to the nearest hexagonal column\n    vec2 column = vec2(q * W, grid_radius * YS);\n    vec2 left = column + 0.5 * vec2(-W, radius);\n    vec2 right = column + 0.5 * vec2(W, radius);\n    vec2 center = column + vec2(0, radius);\n    return min(sd_segment(point, left, center),\n                  sd_segment(point, right, center));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3BDB.jpg", "access": "api", "license": "mit", "functions": [[2084, 2084, 2141, 2204, 4715], [4718, 4768, 4805, 4805, 4830], [4832, 4832, 4868, 4868, 4896], [4898, 5041, 5091, 5091, 5199], [5201, 5291, 5319, 5319, 5520], [5522, 5522, 5559, 5559, 5710], [5712, 5712, 5750, 5750, 5875], [5877, 6012, 6056, 6056, 6270], [6272, 6272, 6314, 6314, 6433], [6435, 6435, 6502, 6502, 7623]], "test": "ok"}
{"id": "7l3fWS", "name": "Inside A Torus F", "author": "SnoopethDuckDuck", "description": "f", "tags": ["torus", "refraction", "idk"], "likes": 27, "viewed": 517, "published": 3, "date": "1663592652", "time_retrieved": "2024-07-30T16:30:36.081077", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// RayMarching from TheArtOfCode\n\n// From BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(in vec2 p, in vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\n\nvec3 GetRayOrigin() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = 3.;\n    float a = pi/2.;// + cos(iTime) * pi/4.;\n    vec3 ro = vec3(r * cos(a), 0, r * sin(a));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    p.y -= 0.17 + 0.05 * cos(length(p) * 1. - 0.5 * iTime);\n    p.y += 0.05 * cos(4. * atan(p.x,p.z) + 4. * length(p.xz) + iTime);\n    p.y += 0.01 * thc(3., 32. * log(length(p.xz)));\n    float r1 = 1.25 + 0.025 * thc(3., p.y * 2. - 0.5 * iTime);\n    float r2 = 0.5 + 0.5 * thc(2., 2. * p.y);\n    float d1 = length(p.xz) - r1;\n    float d2 = sdBox(vec2(p.y, d1), \n    vec2(2. + 0.5 * cos(16. * log(length(p.xz)) - 2. * iTime),1) * r2) \n    - 0.1;\n    return d2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = GetRayOrigin();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    vec3 p = ro + rd * d;\n    float IOR = 1.05 +0.01 * thc(4., 200. * p.y + iTime);\n       \n    if(d<MAX_DIST) {        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        vec3 lightDir = normalize(vec3(1,2,3));\n        float dif = dot(n, lightDir)*.5+.5;\n        col = vec3(dif);\n       // col = vec3(1);\n        float fres = pow(1. + dot(rd, n), 5.);\n        float fres2 = pow(1. + dot(rd, nExit), 4.);\n        float fog = 1.-exp(-length(p));\n\n        float spec = pow(dif, 15.);\n        vec3 col2 = pal(spec, vec3(0,1,2)/3.);\n        col = vec3(spec);\n        //col = mix(col, vec3(0), 1. - fres);\n        col = mix(col, vec3(0), 1. - fres2);\n        //col = mix(col, vec3(spec) * col2, 0.5);\n        //col = mix(col, 0.5 * col, fog);\n        col *= 0.8 + 0.2 * h21(p.xz);\n        col += exp(-4. * length(p.xz));\n        col *= exp(-1.5 * thc(4., 32. * log(length(p.xz)))-12. * (GetDist(p - 0.2 * lightDir)));\n        float v = length(col);\n        col *= pal(v * 0.08 + 1., vec3(0,1,2)/3.);\n        col *= 0.5 + 0.5 * min(1., exp(-10. * p.y));\n        col = pow(col, vec3(.4545));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// From iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3fWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 207, 207, 283], [285, 285, 323, 323, 388], [390, 390, 409, 409, 492], [494, 494, 523, 523, 604], [606, 606, 640, 640, 716], [718, 718, 739, 739, 972], [974, 974, 997, 997, 1460], [1462, 1462, 1505, 1505, 1812], [1814, 1814, 1838, 1838, 2028], [2030, 2030, 2080, 2080, 2271], [2273, 2273, 2330, 2330, 3979]], "test": "untested"}
{"id": "ft3fWB", "name": "Martian Farming", "author": "dr2", "description": "Agricultural experiment", "tags": ["mars", "plant", "polyhedron", "farm", "agriculture"], "likes": 16, "viewed": 247, "published": 3, "date": "1663578938", "time_retrieved": "2024-07-30T16:30:37.002613", "image_code": "// \"Martian Farming\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv3 (vec3 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm2e (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 gId, obOff, obRand, obCs;\nfloat tCur, dstFar, rEx, trSzFac, treeHt, grndScl, dSep;\nint idObj;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GrndDf (vec3 p)\n{\n  vec3 q;\n  float d, h, a, r, s, f;\n  q = p / grndScl;\n  r = length (q.xz);\n  d = p.y;\n  if (r > 0.) {\n    a = atan (q.z, - q.x) / (2. * pi) + 0.5;\n    s = sqrt (r) / (2. * pi);\n    f = 32.;\n    h = mix (Fbm2e (f * vec2 (s, a + 1.)), Fbm2e (f * vec2 (s, a)), a);\n    d = max (r - 20., q.y - s * mix (1., 3. * h, smoothstep (1.4, 2.2, r)) * smoothstep (1.4, 2.6, r));\n  }\n  return grndScl * d;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + s * rd;\n    h = GrndDf (p);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.001, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (GrndDf (p) > 0.) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GrndDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjGdf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, y;\n  dMin = dstFar;\n  if (trSzFac > 0.) {\n    dMin /= trSzFac;\n    p.xz -= HexToPix (gId) + obOff;\n    p /= trSzFac;\n    q = p;\n    q.xz = Rot2Cs (q.xz, obCs);\n    q.y -= treeHt;\n    y = 0.5 * (1. + q.y / treeHt);\n    r = 0.35 * (1. - 0.5 * obRand.y) * (1. - 0.9 * y * y);\n    r *= 1. + 0.1 * sin (24. * (1. + obRand.y) * pi * y);\n    r += 0.2 * (1. - smoothstep (0., 0.1, y));\n    q.xz += Rot2D (vec2 (0.2 + 0.2 * obRand.x, 0.),\n       12. * pi * sign (obRand.x - 0.5) * (0.3 + 0.7 * obRand.y) * y + pi * obRand.x);\n    q.x += 0.5 * (0.4 + 0.6 * obRand.y) * y;\n    q.xz = abs (q.xz) - 0.3 * r;\n    d = PrCylDf (q.xzy, r, treeHt);\n    DMINQ (1);\n    q = p;\n    q.y -= 0.05;\n    q.xz += Rot2D (vec2 (0.2 + 0.2 * obRand.x, 0.), pi * obRand.x);\n    q.xz = abs (q.xz) - 0.3 * r - 0.4;\n    d = max (PrSphDf (q, 0.12), - q.y);\n    DMINQ (2);\n    dMin *= 0.6 * trSzFac;\n  }\n  return dMin;\n}\n\nvoid SetObjConf ()\n{\n  vec2 q;\n  float r;\n  obRand = Hashv2v2 (13.3 * gId + 1.1);\n  q = HexToPix (gId);\n  q = Rot2D (q, 2. * pi * floor (5. * (atan (q.y, - q.x) / (2. * pi) + 0.5) + 0.5) / 5.);\n  q.x -= dSep * rEx;\n  r = length (q) / rEx;\n  if (r > 1.) trSzFac = 0.;\n  else {\n    trSzFac = sqrt (1. - r * r) * 0.5 * sqrt3 *  0.6 * (0.85 -\n       0.15 * clamp (3. * (obRand.x - 0.5), -1., 1.));\n    if (trSzFac < 0.1) trSzFac = 0.;\n    obOff = max (0., 0.4 * sqrt3 - trSzFac) * obRand.x *\n       sin (2. * pi * obRand.y + vec2 (0.5 * pi, 0.));\n    obCs = sin ((0.4 * obRand.x + 0.2) * (obRand.y - 0.5) * pi * tCur + vec2 (0.5 * pi, 0.));\n  }\n}\n\nfloat ObjGRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = 1. / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2]));\n  pM = HexToPix (PixToHex (ro.xz));\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = Minv3 (hv);\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetObjConf ();\n    }\n    d = ObjGdf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjGNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjGdf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjGSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetObjConf ();\n    }\n    h = ObjGdf (p);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += clamp (h, 0.05, 0.5);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 csD;\n  csD = sin (0.5 * atan (2.) + vec2 (0.5 * pi, 0.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), csD);\n  p.xy = Rot2D (p.xy, -0.1 * pi);\n  p.x = - abs (p.x);\n  for (int k = VAR_ZERO; k <= 3; k ++) {\n    p.zy = Rot2Cs (p.zy, vec2 (csD.x, - csD.y));\n    p.zy = Rot2Cs (vec2 (p.z, - abs (p.y)), csD);\n    if (k < 3) p.xy = Rot2Cs (p.xy, sin (-2. * pi / 5. + vec2 (0.5 * pi, 0.)));\n  }\n  p.xy = sin (mod (atan (p.x, p.y) + pi / 5., 2. * pi / 5.) - pi / 5. +\n     vec2 (0., 0.5 * pi)) * length (p.xy);\n  p.xz = - vec2 (abs (p.x), p.z);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{ // based on \"Pentakis Dodecahedron\"\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p.xz = Rot2D (p.xz, 2. * pi * floor (5. * (atan (p.z, - p.x) / (2. * pi) + 0.5) + 0.5) / 5.);\n  p.x -= dSep * rEx;\n  q = DodecSym (p);\n  d = SmoothMax (abs (length (p) - rEx) - 0.1, min (dot (q.yz,\n     sin (0.5 * acos (-1. / sqrt (5.)) - pi + vec2 (0., 0.5 * pi))),\n     dot (q.xy, sin (pi / 5. + vec2 (0.5 * pi, 0.)))) - 0.1, 0.05);\n  d = max (d, - p.y);\n  DMIN (3);\n  q = p;\n  d = length (max (abs (vec2 (length (q.xz) - rEx, q.y)) - vec2 (0.05, 0.1), 0.)) - 0.05;\n  DMIN (3);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat TrObjDf (vec3 p)\n{\n  p.xz = Rot2D (p.xz, 2. * pi * floor (5. * (atan (p.z, - p.x) / (2. * pi) + 0.5) + 0.5) / 5.);\n  p.x -= dSep * rEx;\n  return max (abs (PrSphDf (p, rEx)) - 0.01, - p.y);\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 GrndCol (vec3 ro, vec3 vn)\n{\n  vec4 col4;\n  col4 = vec4 (0.65, 0.5, 0.3, 0.) * (1. - 0.4 * Fbm2e (0.5 * ro.xz));\n  if (ro.y > -0.1) {\n    col4 = mix (col4, 0.8 * col4, smoothstep (0.2, 0.7, 1. - vn.y));\n    col4 = mix (col4, 1.2 * col4, smoothstep (0.6, 0.8, ro.y / grndScl +\n       0.2 * sin (32. * atan (ro.z, - ro.x))));\n  }\n  return col4;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (8. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.4, 0.3, 0.3);\n  } else {\n    q = 0.005 * (ro.xz + 20. * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.2, 0.3, 0.3) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    col = vec3 (1., 0.8, 0.8) * mix (vec3 (0.6, 0.4, 0.4), clCol,\n       0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nfloat PerBumpf (float p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 PerBumpv3 (vec3 p)\n{\n  return 0.5 * smoothstep (0., 0.5, abs (fract (p) - 0.5));\n}\n\nvec3 noiseDisp;\nfloat fogAmp;\n\nfloat BumpFbm3 (vec3 p)\n{  // from \"Energy Temple\"\n  vec3 q;\n  float a, f;\n  a = 1.;\n  f = 0.;\n  q = p;\n  for (int j = 0; j < 4; j ++) {\n    p += noiseDisp;\n    p += PerBumpv3 (q + PerBumpv3 (q).yzx);\n    p *= 1.5;\n    f += a * (PerBumpf (p.z + PerBumpf (p.x + PerBumpf (p.y))));\n    q = 2. * q + 0.5;\n    a *= 0.75;\n  }\n  return f;\n}\n\nfloat FogDens (vec3 p)\n{\n  return fogAmp * BumpFbm3 (0.02 * p);\n}\n\nvec3 FogCol (vec3 col, vec3 ro, vec3 rd, float dHit)\n{  // updated from \"Sailing Home\"\n  float s, ds, f, fn;\n  noiseDisp = 0.1 * vec3 (-1., 0., 1.) * tCur + 0.02 * sin (vec3 (0.3, 0.2, 0.3) * pi * tCur);\n  s = 5.;\n  ds = 5.;\n  fn = FogDens (ro + s * rd);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    s += ds;\n    f = fn;\n    fn = FogDens (ro + (s + 0.5 * ds * Hashfv3 (16. * rd)) * rd);\n    col = mix (col, vec3 (0.95, 0.8, 0.5) * (1. - clamp (f - fn, 0., 1.)),\n       min (f * (1. - smoothstep (0.3 * dHit, dHit, s)), 1.));\n    if (s > dHit) break;\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo, qHitG;\n  vec2 vf, q;\n  float dstObj, dstObjG, dstGrnd, dstTrObj, sh, f, a;\n  int idObjG;\n  fogAmp = 0.25 * SmoothBump (0.25, 0.75, 0.22, fract (0.03 * tCur));\n  rEx = 8.;\n  roo = ro;\n  vf = vec2 (0.);\n  dstObjG = ObjGRay (ro, rd);\n  idObjG = idObj;\n  qHitG = qHit;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  if (min (min (dstObj, dstObjG), dstGrnd) < dstFar) {\n    if (dstObjG < min (dstObj, dstGrnd)) {\n      dstObj = dstObjG;\n      idObj = idObjG;\n      qHit = qHitG;\n      ro += dstObj * rd;\n      gId = PixToHex (ro.xz);\n      vn = ObjGNf (ro);\n      a = atan (qHit.z, - qHit.x) / pi;\n      if (idObj == 1) {\n        f = smoothstep (-0.9, -0.7, qHit.y / treeHt);\n        col4 = mix ((1. - 0.6 * obRand.x) * vec4 (0.6, 0.4, 0., 0.),\n           vec4 (0., 0.4 + 0.6 * obRand.y, 0.1, 0.05), f) *\n           (0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.05, fract (8. * a)));\n        vf = vec2 (16., (3. - 2.5 * f) * (1. - smoothstep (0.1, 0.3, dstObj / dstFar)));\n      } else if (idObj == 2) {\n        col4 = mix (vec4 (0.8, 0.1, 0., 0.3), vec4 (0.7, 0.7, 0., 0.3), step (0.6, obRand.y)) *\n           (0.5 + 0.5 * SmoothBump (0.1, 0.9, 0.05, fract (4. * a)));\n        vf = vec2 (32., 1.);\n      }\n    } else if (dstObj < dstGrnd) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == 3) col4 = vec4 (0.9, 0.9, 0.95, 0.2);\n    } else {\n      ro += dstGrnd * rd;\n      q = Rot2D (ro.xz, 2. * pi * floor (5. * (atan (ro.z, - ro.x) / (2. * pi) + 0.5) + 0.5) / 5.);\n      q.x -= dSep * rEx;\n      if (length (q) > rEx) {\n        vn = GrndNf (ro);\n        col4 = GrndCol (ro, vn);\n        vf = vec2 (0.5, 2. - smoothstep (0.7, 0.9, dstGrnd / (3. * grndScl)));\n      } else {\n        col4 = vec4 (0.4, 0.6, 0.3, 0.);\n        vn = vec3 (0., 1., 0.);\n        vf = vec2 (16., 0.2);\n      }\n    }\n    sh = min (ObjSShadow (ro + 0.01 * vn, sunDir), ObjGSShadow (ro + 0.01 * vn, sunDir));\n    sh = mix (sh, 1., smoothstep (0., 1., fogAmp / 0.25));\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    col = col4.rgb * (0.2 + 0.1 * max (vn.y, 0.) + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n  } else col = SkyBgCol (ro, rd);\n  ro = roo;\n  dstTrObj = TrObjRay (ro, rd);\n  if (dstTrObj < min (dstObj, dstFar)) {\n    ro += dstTrObj * rd;\n    vn = TrObjNf (ro);\n    col = mix (col * vec3 (1., 1., 0.7), SkyBgCol (ro, reflect (rd, vn)),\n       0.2 + 0.7 * pow (1. - max (- dot (rd, vn), 0.), 3.));\n  }\n  col = FogCol (col, roo, rd, min (dstObj, dstGrnd));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  treeHt = 7.;\n  dSep = 3.;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az -= 2. * pi * mPtr.x;\n    el -= 0.5 * pi * mPtr.y;\n  } else {\n    t = mod (0.005 * tCur, 2.);\n    az = 2.5 * pi * (0.5 - abs ((floor (16. * t) + smoothstep (0.8, 1., fract (16. * t))) / 16. - 1.));\n  }\n  el = clamp (el, -0.45 * pi, -0.02 * pi);\n  vuMat = StdVuMat (el, az);\n  grndScl = 50.;\n  ro = vec3 (0., 0.05, -1.7 + 0.5 * abs (mod (az / pi + 1., 2.) - 1.)) * grndScl;\n  ro = vuMat * ro;\n  zmFac = 3.5;\n  dstFar = 10. * grndScl;\n  sunDir = normalize (vec3 (0., 1., 1.));\n #if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2e (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 6; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.96875);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.05, 0.); //vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3fWB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1042, 1042, 1065, 1065, 1460], [1462, 1462, 1496, 1496, 1986], [1988, 1988, 2010, 2010, 2266], [2268, 2268, 2291, 2291, 3205], [3207, 3207, 3227, 3227, 3849], [3851, 3851, 3885, 3885, 4941], [4943, 4943, 4965, 4965, 5221], [5223, 5223, 5261, 5261, 5661], [5663, 5663, 5687, 5687, 6240], [6242, 6242, 6264, 6300, 6843], [6845, 6845, 6878, 6878, 7061], [7063, 7063, 7084, 7084, 7334], [7336, 7336, 7373, 7373, 7616], [7618, 7618, 7642, 7642, 7814], [7816, 7816, 7851, 7851, 8035], [8037, 8037, 8060, 8060, 8312], [8314, 8314, 8347, 8347, 8663], [8665, 8665, 8699, 8699, 9318], [9320, 9320, 9346, 9346, 9408], [9410, 9410, 9435, 9435, 9497], [9530, 9530, 9555, 9580, 9864], [9866, 9866, 9890, 9890, 9931], [9933, 9933, 9987, 10019, 10502], [10504, 10504, 10539, 10539, 13157], [13159, 13159, 13215, 13215, 14487], [14489, 14489, 14522, 14522, 14549], [14551, 14551, 14593, 14593, 14644], [14646, 14646, 14670, 14670, 14900], [14902, 14902, 14926, 14926, 14986], [14988, 14988, 15010, 15010, 15048], [15050, 15050, 15081, 15081, 15145], [15147, 15147, 15192, 15192, 15284], [15286, 15286, 15331, 15331, 15369], [15371, 15371, 15428, 15428, 15511], [15513, 15513, 15549, 15549, 15755], [15757, 15757, 15787, 15787, 15900], [15934, 15934, 15958, 15958, 16023], [16025, 16025, 16049, 16049, 16102], [16104, 16104, 16128, 16128, 16240], [16242, 16242, 16267, 16267, 16413], [16415, 16415, 16440, 16440, 16626], [16628, 16628, 16650, 16650, 16804], [16806, 16806, 16827, 16827, 16982], [16984, 16984, 17006, 17006, 17162], [17164, 17164, 17193, 17193, 17405], [17407, 17407, 17446, 17446, 17717]], "test": "untested"}
{"id": "fl3fWS", "name": "Balloon Trip", "author": "ianthehenry", "description": "Animated balloon that I made with https://bauble.studio.", "tags": ["animation", "balloon", "bauble"], "likes": 21, "viewed": 284, "published": 3, "date": "1663563754", "time_retrieved": "2024-07-30T16:30:38.106662", "image_code": "precision highp float;\n\nconst int MAX_STEPS = 256;\nconst float MINIMUM_HIT_DISTANCE = 0.1;\nconst float NORMAL_OFFSET = 0.005;\nconst float MAXIMUM_TRACE_DISTANCE = 64.0 * 1024.0;\n\n/*\n\nI created this using https://bauble.studio, although this code has\nbeen formatted to fit your TV.\n\nI recorded a video of myself modeling the balloon (the animation\nhere is a pretty simple modification):\n\nhttps://www.youtube.com/watch?v=0-OtdjiR7dc&list=PLjT5GDnW_UMBS6ih0kG7jWB0n1SnotnEu\n\nThis is the original Bauble source for the image:\n\n    (def bottom (+ -100 -50))\n\n    (defn quantize [x y]\n      (x * y | round / y))\n\n    (def envelope\n      (sphere 100\n      | union :r 50 (cylinder :y 25 50 | move :y -100)\n      | scale\n         :y (ss p.y bottom 100 1 0.80)\n         :z (ss p.y bottom (+ bottom 75) 1 0.50)\n      | onion 0.1\n      | subtract :r 1 (half-space :-y (+ bottom 7))\n      | radial :y 18 (fn [$ i]\n        (resurface $\n          (shade (hsv (/ p.y 100 - (* 0.2 t) | quantize 8) 1 1)\n          | move :y (sin (t * 1.5) | ss * 100 / 8 * (mod i 2))\n          | rotate :x (sin (t / 2) * pi/4)\n          | rotate :y (cos+ t)\n          )\n        | scale :z (mod i 2 * 2 - 1)))\n      | color (* c (ss occlusion 0 0.75 0 1))\n      | fresnel))\n\n    (def flame\n      (cone :-y 50 403\n      | union :r 10 (cone :y 31 148)\n      | bounded-offset 30 :threshold 3\n        (perlin (- (* p [0.05 0.025 0.05]) [0 (* 5 t) 0]))\n      | color (+ (* [1 1 0.7] (ss p.y -72 400))\n        (mix [1 0.25 0] [1 1 0] (- normal.y)))\n      | move :y -72))\n\n\n    (def metal\n      (shade [0.37 0.25 0.21] :gloss 7 :shine 1\n      | fresnel [0.5 0.5 1]))\n\n    (def torch\n      (sphere 20\n      | scale :y 0.75\n      | union :r 3 (cylinder :r 1 :y (+ 20 (sin (p.y * 2))) 2 | move :y 10)\n      | subtract (sphere 20 | move :y 20)\n      | union :r 1 (line [30 10 0] [0 -10 0] 0.5 | union :r 1 (torus :x 2 0.5 | move [30 12 0]) | radial :y 6)\n      | resurface metal\n      ))\n\n    (def basket\n      (box 50\n      | onion 10\n      | subtract :r 10\n        (half-space :y (+ 29 (pow (p.xz / 15) 2 | sum)))\n      | offset (* 0.25 (+\n        (cos (min (abs p.xz) * 3 + (step (sin (* 2 p.y)) 0 * pi/2)) | abs)\n        (sin (p.y * 1) | abs)))\n      | shade (hsv 0.10 0.54 0.88)\n      | union\n        (box [66 5 10] :r 5\n        | move [0 (+ 48 (pow (p.x / 15) 2)) 55]\n        | rotate :y (- tau/8)\n        | mirror :x :z :r 10\n        | rotate :y tau/8\n        | shade [0.4 0.05 0.1] :gloss 3 :shine 0.5\n        | fresnel)))\n\n    (def collar\n      (cylinder :y 50 8 :r 2\n      | subtract :r 4 (cylinder :y 46 100)\n      | union :r 1\n        (union :r 1\n          (cylinder :r 1 :x 4 4 | move :x 48)\n          (cone :r 1 :x 2 2 | move :x 51)\n        | radial :y 12)\n      | rotate :y tau/8\n      | resurface metal\n      ))\n\n    (def basket-corner [10 -38 10])\n    (def basket-ropes\n      (union\n        (line [24 4 6] basket-corner 0.15)\n        (line [17 4 17] basket-corner 0.15)\n        (line [6 4 24] basket-corner 0.15)\n      | mirror :x :z\n      | offset (sin+ (p.y * 20) * 0.01)\n      | shade (hsv 0.1 0.9 0.5)\n      | fresnel 0.05 :exponent 2\n      ))\n\n    (def torch-ropes\n      (line [24 4 6] [9 -10.25 0] 0.1\n      | mirror :z\n      | radial :y 6\n      | resurface metal))\n\n    (union\n      (envelope\n      | color (+ c (* 0.05 [1 1 0]\n        (ss (distance p [0 bottom 0]) 0 150 1 0)\n        (perlin [(* 2 t) 0]))))\n      (bound (union\n        (flame | scale 0.1 | move :y (- bottom 5))\n        (torch | scale 0.3 | move :y (- bottom 14))\n        (basket | scale 0.2 | move :y (- bottom 50))\n        (collar | scale 0.53 | move :y (- bottom -5))\n        (basket-ropes | move :y bottom)\n        (torch-ropes | move :y bottom))\n      (sphere 45 | move :y (- bottom 25)))\n    | rotate :y (sin t * 1.5 + t * 0.1)\n    | move :y 81)\n\n*/\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nstruct Light {\n  vec3 position;\n  vec3 color;\n  float radius;\n};\n\nconst Light lights[1] = Light[1](\n  Light(vec3(512.0, 512.0, 512.0), vec3(1.0), 4096.0)\n);\nfloat s3d_cylinder_0(vec3 p, float radius, float height) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(radius, height);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n}\nfloat union_0(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = (length(p) - 100.0);\n  float _r1; {\n    vec3 p1 = (p - vec3(0.0, -100.0, 0.0));\n    _r1 = s3d_cylinder_0(p1, 25.0, 50.0);\n  }\n  b = _r1;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nfloat min3(vec3 p) {\n  return min(p.x, min(p.y, p.z));\n}\nfloat subtract_0(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float _r1; {\n    vec3 scale0_1 = vec3(1.0, ((1.0 * (1.0 + (smoothstep(-150.0, 100.0, p.y) * -0.200000))) * 1.0), (1.0 * (1.0 + (smoothstep(-150.0, -75.0, p.y) * -0.500000))));\n    vec3 p1 = (p / scale0_1);\n    _r1 = (abs((union_0(p1, 50.0) * min3(abs(scale0_1)))) - 0.100000);\n  }\n  float a = _r1;\n  float _r2; {\n    vec3 p1 = (p - vec3(0.0, -143.0, 0.0));\n    _r2 = p1.y;\n  }\n  b = _r2;\n  h = clamp(0.5 - 0.5 * (a + b) / r, 0.0, 1.0);\n  a = mix(a, -b, h) + r * h * (1.0 - h);\n\n  return a;\n}\nfloat atan2(float y, float x) {\n  return x == 0.0 ? sign(y) * 0.5 * PI : atan(y, x);\n\n}\nmat3 rotate_y(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(\n    c, 0.0, s,\n    0.0, 1.0, 0.0,\n    -s, 0.0, c);\n}\nfloat s3d_cone_0(vec3 p, float radius, float height) {\n  vec2 q = vec2(radius, height);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n\n}\nfloat s3d_cone_1(vec3 p, float radius, float height) {\n  vec2 q = vec2(radius, height);\n  vec2 w = vec2(length(p.xz), height - p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n\n}\nfloat union_1(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = s3d_cone_0(p, 50.0, 403.0);\n  b = s3d_cone_1(p, 31.0, 148.0);\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nvec3 fade3(vec3 t) {\n  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\nvec4 taylor_inv_sqrt4(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 mod289_3(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289_4(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute4(vec4 x) {\n  return mod289_4(((x * 34.0) + 10.0) * x);\n}\n// Perlin noise functions by Stefan Gustavson\n// https://github.com/stegu/webgl-noise\nfloat perlin3(vec3 P) {\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3(Pi0);\n  Pi1 = mod289_3(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute4(permute4(ix) + iy);\n  vec4 ixy0 = permute4(ixy + iz0);\n  vec4 ixy1 = permute4(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = taylor_inv_sqrt4(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylor_inv_sqrt4(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade3(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n\n}\nfloat bound_0(float magnitude0_, float t, vec3 p, float threshold) {\n  float boundary_distance = (union_1(p, 10.0) - magnitude0_);\n  if (boundary_distance < threshold) {\n    return (union_1(p, 10.0) - (magnitude0_ * perlin3(((p * vec3(0.050000, 0.025000, 0.050000)) - vec3(0.0, (5.0 * t), 0.0)))));\n  } else {\n    return boundary_distance;\n  }\n}\nfloat union_2(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float _r1; {\n    vec3 scale0_1 = vec3(1.0, 0.750000, 1.0);\n    vec3 p1 = (p / scale0_1);\n    _r1 = ((length(p1) - 20.0) * min3(abs(scale0_1)));\n  }\n  float a = _r1;\n  float _r2; {\n    vec3 p1 = (p - vec3(0.0, 10.0, 0.0));\n    _r2 = (s3d_cylinder_0(p1, ((20.0 + sin((p1.y * 2.0))) - 1.0), 1.0) - 1.0);\n  }\n  b = _r2;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nfloat subtract_1(vec3 p) {\n  float d = union_2(p, 3.0);\n  float _r1; {\n    vec3 p1 = (p - vec3(0.0, 20.0, 0.0));\n    _r1 = (length(p1) - 20.0);\n  }\n  d = max(d, -_r1);\n  return d;\n}\nfloat s3d_line(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n\n}\nfloat s3d_torus_0(vec3 p, float major_radius, float minor_radius) {\n  vec2 q = vec2(length(p.yz) - major_radius, p.x);\n  return length(q) - minor_radius;\n\n}\nfloat union_3(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = (s3d_line(p, vec3(30.0, 10.0, 0.0), vec3(0.0, -10.0, 0.0)) - 0.500000);\n  float _r1; {\n    vec3 p1 = (p - vec3(30.0, 12.0, 0.0));\n    _r1 = s3d_torus_0(p1, 2.0, 0.500000);\n  }\n  b = _r1;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nfloat union_4(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = subtract_1(p);\n  float _r1; {\n    float angle0_1 = 1.047198;\n    float index0_1 = floor((mod((atan2(p.z, p.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p1 = ((p * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    _r1 = union_3(p1, 1.0);\n  }\n  b = _r1;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nfloat s3d_box(vec3 p, vec3 size) {\n  vec3 q = abs(p) - size;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n\n}\nfloat sum2(vec2 p) {\n  return p.x + p.y;\n}\nfloat subtract_2(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = (abs(s3d_box(p, vec3(50.0, 50.0, 50.0))) - 10.0);\n  float _r1; {\n    vec3 p1 = (p - vec3(0.0, (29.0 + sum2(pow((p.xz / 15.0), vec2(2.0)))), 0.0));\n    _r1 = (-p1.y);\n  }\n  b = _r1;\n  h = clamp(0.5 - 0.5 * (a + b) / r, 0.0, 1.0);\n  a = mix(a, -b, h) + r * h * (1.0 - h);\n\n  return a;\n}\nfloat min2(vec2 p) {\n  return min(p.x, p.y);\n}\nvec3 biased_sqrt_xz_0(vec3 p, float r) {\n  p.xz = sqrt(p.xz * p.xz + r * r);\n  return p;\n}\nfloat union_5(vec3 p) {\n  float d = (subtract_2(p, 10.0) - (0.250000 * (abs(cos(((min2(abs(p.xz)) * 3.0) + (step(0.0, sin((2.0 * p.y))) * 1.570796)))) + abs(sin((p.y * 1.0))))));\n  float _r1; {\n    vec3 p1 = (p * mat3(0.707107, 0.0, 0.707107, 0.0, 1.0, 0.0, -0.707107, 0.0, 0.707107));\n    vec3 p2 = biased_sqrt_xz_0(p1, 10.0);\n    vec3 p3 = (p2 * mat3(0.707107, 0.0, -0.707107, 0.0, 1.0, 0.0, 0.707107, 0.0, 0.707107));\n    vec3 p4 = (p3 - vec3(0.0, (0.0 + (48.0 + pow((p3.x / 15.0), 2.0))), 55.0));\n    _r1 = (s3d_box(p4, vec3(61.0, 0.0, 5.0)) - 5.0);\n  }\n  d = min(d, _r1);\n  return d;\n}\nfloat subtract_3(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = (s3d_cylinder_0(p, 48.0, 6.0) - 2.0);\n  b = s3d_cylinder_0(p, 46.0, 100.0);\n  h = clamp(0.5 - 0.5 * (a + b) / r, 0.0, 1.0);\n  a = mix(a, -b, h) + r * h * (1.0 - h);\n\n  return a;\n}\nfloat s3d_cylinder_1(vec3 p, float radius, float height) {\n  vec2 d = abs(vec2(length(p.yz), p.x)) - vec2(radius, height);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n}\nfloat s3d_cone_2(vec3 p, float radius, float height) {\n  vec2 q = vec2(radius, height);\n  vec2 w = vec2(length(p.yz), height - p.x);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n\n}\nfloat union_6(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float _r1; {\n    vec3 p1 = (p - vec3(48.0, 0.0, 0.0));\n    _r1 = (s3d_cylinder_1(p1, 3.0, 3.0) - 1.0);\n  }\n  float a = _r1;\n  float _r2; {\n    vec3 p1 = (p - vec3(51.0, 0.0, 0.0));\n    float height0_1 = 2.0;\n    float radius0_1 = 2.0;\n    float r0_1 = 1.0;\n    float tip_offset0_1 = (r0_1 * (height0_1 / radius0_1));\n    vec3 p2 = (p1 - vec3(r0_1, 0.0, 0.0));\n    _r2 = (s3d_cone_2(p2, (radius0_1 - r0_1), (height0_1 - tip_offset0_1)) - r0_1);\n  }\n  b = _r2;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nfloat union_7(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = subtract_3(p, 4.0);\n  float _r1; {\n    float angle0_1 = 0.523599;\n    float index0_1 = floor((mod((atan2(p.z, p.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p1 = ((p * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    _r1 = union_6(p1, 1.0);\n  }\n  b = _r1;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nvec3 abs_xz_0(vec3 p) {\n  p.xz = abs(p.xz);\n  return p;\n}\nfloat union_8(vec3 p) {\n  float d = (s3d_line(p, vec3(24.0, 4.0, 6.0), vec3(10.0, -38.0, 10.0)) - 0.150000);\n  d = min(d, (s3d_line(p, vec3(17.0, 4.0, 17.0), vec3(10.0, -38.0, 10.0)) - 0.150000));\n  d = min(d, (s3d_line(p, vec3(6.0, 4.0, 24.0), vec3(10.0, -38.0, 10.0)) - 0.150000));\n  return d;\n}\nvec3 abs_z_0(vec3 p) {\n  p.z = abs(p.z);\n  return p;\n}\nfloat union_9(float t, vec3 p) {\n  float _r1; {\n    vec3 p1 = (p - vec3(0.0, -155.0, 0.0));\n    float scale0_1 = 0.100000;\n    vec3 p2 = (p1 / scale0_1);\n    vec3 p3 = (p2 - vec3(0.0, -72.0, 0.0));\n    float magnitude0_1 = 30.0;\n    _r1 = (bound_0(magnitude0_1, t, p3, 3.0) * scale0_1);\n  }\n  float d = _r1;\n  float _r2; {\n    vec3 p1 = (p - vec3(0.0, -164.0, 0.0));\n    float scale0_1 = 0.300000;\n    vec3 p2 = (p1 / scale0_1);\n    _r2 = (union_4(p2, 1.0) * scale0_1);\n  }\n  d = min(d, _r2);\n  float _r3; {\n    vec3 p1 = (p - vec3(0.0, -200.0, 0.0));\n    float scale0_1 = 0.200000;\n    vec3 p2 = (p1 / scale0_1);\n    _r3 = (union_5(p2) * scale0_1);\n  }\n  d = min(d, _r3);\n  float _r4; {\n    vec3 p1 = (p - vec3(0.0, -145.0, 0.0));\n    float scale0_1 = 0.530000;\n    vec3 p2 = (p1 / scale0_1);\n    vec3 p3 = (p2 * mat3(0.707107, 0.0, 0.707107, 0.0, 1.0, 0.0, -0.707107, 0.0, 0.707107));\n    _r4 = (union_7(p3, 1.0) * scale0_1);\n  }\n  d = min(d, _r4);\n  float _r5; {\n    vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n    vec3 p2 = abs_xz_0(p1);\n    _r5 = (union_8(p2) - ((0.500000 * (sin((p1.y * 20.0)) + 1.0)) * 0.010000));\n  }\n  d = min(d, _r5);\n  float _r6; {\n    vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n    float angle0_1 = 1.047198;\n    float index0_1 = floor((mod((atan2(p1.z, p1.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p2 = ((p1 * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    vec3 p3 = abs_z_0(p2);\n    _r6 = (s3d_line(p3, vec3(24.0, 4.0, 6.0), vec3(9.0, -10.250000, 0.0)) - 0.100000);\n  }\n  d = min(d, _r6);\n  return d;\n}\nfloat bound_1(float t, vec3 p, float threshold) {\n  vec3 p1 = (p - vec3(0.0, -175.0, 0.0));\n  float boundary_distance = (length(p1) - 45.0);\n  if (boundary_distance < threshold) {\n    return union_9(t, p);\n  } else {\n    return boundary_distance;\n  }\n}\nfloat union_10(float t, vec3 p) {\n  float _r1; {\n    float angle0_1 = 0.349066;\n    float index0_1 = floor((mod((atan2(p.z, p.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p1 = ((p * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    vec3 scale0_1 = vec3(1.0, 1.0, (1.0 * ((mod(index0_1, 2.0) * 2.0) - 1.0)));\n    vec3 p2 = (p1 / scale0_1);\n    _r1 = (subtract_0(p2, 1.0) * min3(abs(scale0_1)));\n  }\n  float d = _r1;\n  d = min(d, bound_1(t, p, 1.0));\n  return d;\n}\nfloat bound_2(float magnitude0_, float t, vec3 p, float threshold) {\n  float boundary_distance = (union_1(p, 10.0) - magnitude0_);\n  if (boundary_distance < threshold) {\n    return (union_1(p, 10.0) - (magnitude0_ * perlin3(((p * vec3(0.050000, 0.025000, 0.050000)) - vec3(0.0, (5.0 * t), 0.0)))));\n  } else {\n    return boundary_distance;\n  }\n}\nvec3 fresnel(vec3 normal, vec3 P, vec3 camera_origin, vec3 color, float strength, float exponent) {\n  vec3 view_dir = normalize(camera_origin - P);\n  float fresnel = pow(1.0 - dot(normal, view_dir), exponent);\n  return color * strength * fresnel;\n\n}\nvec3 blinn_phong(vec3 normal, float occlusion, vec3 P, float light_intensities[1], vec3 camera_origin, vec3 color, float shine, float gloss, float ambient) {\n  vec3 view_dir = normalize(camera_origin - P);\n  vec3 result = color * ambient;\n  for (int i = 0; i < lights.length(); i++) {\n    vec3 light_color = lights[i].color * light_intensities[i];\n    vec3 light_dir = normalize(lights[i].position - P);\n    vec3 halfway_dir = normalize(light_dir + view_dir);\n    float specular_strength = shine * pow(max(dot(normal, halfway_dir), 0.0), gloss * gloss);\n    float diffuse = max(0.0, dot(normal, light_dir));\n    result += light_color * specular_strength;\n    result += color * diffuse * light_color;\n  }\n  return result;\n\n}\nmat3 rotate_x(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, -s,\n    0.0, s, c);\n}\nvec3 hsv(float h, float s, float v) {\n  vec3 p = abs(fract(vec3(h, h, h) + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);\n  return v * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), s);\n\n}\nvec2 fade2(vec2 t) {\n  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Perlin noise functions by Stefan Gustavson\n// https://github.com/stegu/webgl-noise\nfloat perlin2(vec2 P) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289_4(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute4(permute4(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x, gy.x);\n  vec2 g10 = vec2(gx.y, gy.y);\n  vec2 g01 = vec2(gx.z, gy.z);\n  vec2 g11 = vec2(gx.w, gy.w);\n\n  vec4 norm = taylor_inv_sqrt4(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade2(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\nfloat bound_3(float magnitude0_, float t, vec3 p, float threshold) {\n  float boundary_distance = (union_1(p, 10.0) - magnitude0_);\n  if (boundary_distance < threshold) {\n    return (union_1(p, 10.0) - (magnitude0_ * perlin3(((p * vec3(0.050000, 0.025000, 0.050000)) - vec3(0.0, (5.0 * t), 0.0)))));\n  } else {\n    return boundary_distance;\n  }\n}\nvec3 union_color_0(vec3 normal, vec3 p, float r) {\n  float b, h;\n  r = max(r, 0.0000000001);\n  float a = s3d_cone_0(p, 50.0, 403.0);\n  vec3 color = (0.500000 * (1.0 + normal));\n  b = s3d_cone_1(p, 31.0, 148.0);\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n  color = mix((0.500000 * (1.0 + normal)), color, h);\n  return color;\n}\nvec3 union_color_1(vec3 p, vec3 normal, float occlusion, vec3 P, float light_intensities[1], vec3 camera_origin) {\n  float d = (subtract_2(p, 10.0) - (0.250000 * (abs(cos(((min2(abs(p.xz)) * 3.0) + (step(0.0, sin((2.0 * p.y))) * 1.570796)))) + abs(sin((p.y * 1.0))))));\n  float d2;\n  int surface = 0;\n  vec3 color;\n  float _r1; {\n    vec3 p1 = (p * mat3(0.707107, 0.0, 0.707107, 0.0, 1.0, 0.0, -0.707107, 0.0, 0.707107));\n    vec3 p2 = biased_sqrt_xz_0(p1, 10.0);\n    vec3 p3 = (p2 * mat3(0.707107, 0.0, -0.707107, 0.0, 1.0, 0.0, 0.707107, 0.0, 0.707107));\n    vec3 p4 = (p3 - vec3(0.0, (0.0 + (48.0 + pow((p3.x / 15.0), 2.0))), 55.0));\n    _r1 = (s3d_box(p4, vec3(61.0, 0.0, 5.0)) - 5.0);\n  }\n  d2 = _r1;\n  if (d2 < d) {\n    d = d2;\n    surface = 1;\n  }\n  switch (surface) {\n  case 0:\n    color = blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.880000, 0.689920, 0.404800), 0.250000, 4.0, 0.200000);\n    break;\n  case 1:\n    color = (blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.400000, 0.050000, 0.100000), 0.500000, 3.0, 0.200000) + fresnel(normal, P, camera_origin, vec3(1.0, 1.0, 1.0), 0.250000, 5.0));\n    break;\n  }\n  return color;\n}\nvec3 union_color_2(vec3 p, vec3 normal, float occlusion, vec3 P, float t, float light_intensities[1], vec3 camera_origin) {\n  float _r1; {\n    vec3 p1 = (p - vec3(0.0, -155.0, 0.0));\n    float scale0_1 = 0.100000;\n    vec3 p2 = (p1 / scale0_1);\n    vec3 p3 = (p2 - vec3(0.0, -72.0, 0.0));\n    float magnitude0_1 = 30.0;\n    _r1 = (bound_3(magnitude0_1, t, p3, 3.0) * scale0_1);\n  }\n  float d = _r1;\n  float d2;\n  int surface = 0;\n  vec3 color;\n  float _r2; {\n    vec3 p1 = (p - vec3(0.0, -164.0, 0.0));\n    float scale0_1 = 0.300000;\n    vec3 p2 = (p1 / scale0_1);\n    _r2 = (union_4(p2, 1.0) * scale0_1);\n  }\n  d2 = _r2;\n  if (d2 < d) {\n    d = d2;\n    surface = 1;\n  }\n  float _r3; {\n    vec3 p1 = (p - vec3(0.0, -200.0, 0.0));\n    float scale0_1 = 0.200000;\n    vec3 p2 = (p1 / scale0_1);\n    _r3 = (union_5(p2) * scale0_1);\n  }\n  d2 = _r3;\n  if (d2 < d) {\n    d = d2;\n    surface = 2;\n  }\n  float _r4; {\n    vec3 p1 = (p - vec3(0.0, -145.0, 0.0));\n    float scale0_1 = 0.530000;\n    vec3 p2 = (p1 / scale0_1);\n    vec3 p3 = (p2 * mat3(0.707107, 0.0, 0.707107, 0.0, 1.0, 0.0, -0.707107, 0.0, 0.707107));\n    _r4 = (union_7(p3, 1.0) * scale0_1);\n  }\n  d2 = _r4;\n  if (d2 < d) {\n    d = d2;\n    surface = 3;\n  }\n  float _r5; {\n    vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n    vec3 p2 = abs_xz_0(p1);\n    _r5 = (union_8(p2) - ((0.500000 * (sin((p1.y * 20.0)) + 1.0)) * 0.010000));\n  }\n  d2 = _r5;\n  if (d2 < d) {\n    d = d2;\n    surface = 4;\n  }\n  float _r6; {\n    vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n    float angle0_1 = 1.047198;\n    float index0_1 = floor((mod((atan2(p1.z, p1.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p2 = ((p1 * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    vec3 p3 = abs_z_0(p2);\n    _r6 = (s3d_line(p3, vec3(24.0, 4.0, 6.0), vec3(9.0, -10.250000, 0.0)) - 0.100000);\n  }\n  d2 = _r6;\n  if (d2 < d) {\n    d = d2;\n    surface = 5;\n  }\n  switch (surface) {\n  case 0:\n    vec3 _r7; {\n      vec3 p1 = (p - vec3(0.0, -155.0, 0.0));\n      vec3 p2 = (p1 / 0.100000);\n      vec3 p3 = (p2 - vec3(0.0, -72.0, 0.0));\n      vec3 color0_1 = union_color_0(normal, p3, 10.0);\n      _r7 = ((vec3(1.0, 1.0, 0.700000) * smoothstep(-72.0, 400.0, p3.y)) + mix(vec3(1.0, 0.250000, 0.0), vec3(1.0, 1.0, 0.0), (-normal.y)));\n    }\n    color = _r7;\n    break;\n  case 1:\n    vec3 _r8; {\n      vec3 p1 = (p - vec3(0.0, -164.0, 0.0));\n      vec3 p2 = (p1 / 0.300000);\n      _r8 = (blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.370000, 0.250000, 0.210000), 1.0, 7.0, 0.200000) + fresnel(normal, P, camera_origin, vec3(0.500000, 0.500000, 1.0), 0.250000, 5.0));\n    }\n    color = _r8;\n    break;\n  case 2:\n    vec3 _r9; {\n      vec3 p1 = (p - vec3(0.0, -200.0, 0.0));\n      vec3 p2 = (p1 / 0.200000);\n      _r9 = union_color_1(p2, normal, occlusion, P, light_intensities, camera_origin);\n    }\n    color = _r9;\n    break;\n  case 3:\n    vec3 _r10; {\n      vec3 p1 = (p - vec3(0.0, -145.0, 0.0));\n      vec3 p2 = (p1 / 0.530000);\n      _r10 = (blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.370000, 0.250000, 0.210000), 1.0, 7.0, 0.200000) + fresnel(normal, P, camera_origin, vec3(0.500000, 0.500000, 1.0), 0.250000, 5.0));\n    }\n    color = _r10;\n    break;\n  case 4:\n    vec3 _r11; {\n      vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n      _r11 = (blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.500000, 0.320000, 0.050000), 0.250000, 4.0, 0.200000) + fresnel(normal, P, camera_origin, vec3(1.0, 1.0, 1.0), 0.050000, 2.0));\n    }\n    color = _r11;\n    break;\n  case 5:\n    vec3 _r12; {\n      vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n      _r12 = (blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.370000, 0.250000, 0.210000), 1.0, 7.0, 0.200000) + fresnel(normal, P, camera_origin, vec3(0.500000, 0.500000, 1.0), 0.250000, 5.0));\n    }\n    color = _r12;\n    break;\n  }\n  return color;\n}\nvec3 union_color_3(vec3 p, vec3 normal, float occlusion, vec3 P, float t, float light_intensities[1], vec3 camera_origin) {\n  float _r1; {\n    float angle0_1 = 0.349066;\n    float index0_1 = floor((mod((atan2(p.z, p.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p1 = ((p * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    vec3 scale0_1 = vec3(1.0, 1.0, (1.0 * ((mod(index0_1, 2.0) * 2.0) - 1.0)));\n    vec3 p2 = (p1 / scale0_1);\n    _r1 = (subtract_0(p2, 1.0) * min3(abs(scale0_1)));\n  }\n  float d = _r1;\n  float d2;\n  int surface = 0;\n  vec3 color;\n  d2 = bound_1(t, p, 1.0);\n  if (d2 < d) {\n    d = d2;\n    surface = 1;\n  }\n  switch (surface) {\n  case 0:\n    vec3 _r2; {\n      float angle0_1 = 0.349066;\n      float index0_1 = floor((mod((atan2(p.z, p.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n      vec3 p1 = ((p * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n      vec3 p2 = (p1 / vec3(1.0, 1.0, (1.0 * ((mod(index0_1, 2.0) * 2.0) - 1.0))));\n      vec3 p3 = (p2 * (mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0) * rotate_y((1.0 * (0.500000 * (cos(t) + 1.0))))));\n      vec3 p4 = (p3 * (mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0) * rotate_x((1.0 * (sin((t / 2.0)) * 0.785398)))));\n      vec3 p5 = (p4 - vec3(0.0, (0.0 + (((smoothstep(0.0, 1.0, sin((t * 1.500000))) * 100.0) / 8.0) * mod(index0_1, 2.0))), 0.0));\n      vec3 color1_1 = blinn_phong(normal, occlusion, P, light_intensities, camera_origin, hsv((round((((p5.y / 100.0) - (0.200000 * t)) * 8.0)) / 8.0), 1.0, 1.0), 0.250000, 4.0, 0.200000);\n      vec3 color0_1 = ((color1_1 * (0.0 + (smoothstep(0.0, 0.750000, occlusion) * 1.0))) + fresnel(normal, P, camera_origin, vec3(1.0, 1.0, 1.0), 0.250000, 5.0));\n      _r2 = (color0_1 + ((vec3(0.050000, 0.050000, 0.0) * (1.0 + (smoothstep(0.0, 150.0, distance(p, vec3(0.0, -150.0, 0.0))) * -1.0))) * perlin2(vec2((2.0 * t), 0.0))));\n    }\n    color = _r2;\n    break;\n  case 1:\n    color = union_color_2(p, normal, occlusion, P, t, light_intensities, camera_origin);\n    break;\n  }\n  return color;\n}\nfloat nearest_distance(vec3 p) {\n  float t = iTime;\n  vec3 p1 = (p - vec3(0.0, 81.0, 0.0));\n  vec3 p2 = (p1 * (mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0) * rotate_y((1.0 * (((sin(t) * 1.500000) + t) * 0.100000)))));\n  return union_10(t, p2);\n}\n\nvec3 calculate_normal(vec3 p) {\n  const vec3 step = vec3(NORMAL_OFFSET, 0.0, 0.0);\n\n  return normalize(vec3(\n    nearest_distance(p + step.xyy) - nearest_distance(p - step.xyy),\n    nearest_distance(p + step.yxy) - nearest_distance(p - step.yxy),\n    nearest_distance(p + step.yyx) - nearest_distance(p - step.yyx)\n  ));\n}\n\nfloat calculate_occlusion(vec3 p, vec3 normal) {\n  const int step_count = 10;\n  const float max_distance = 10.0;\n  const float step_size = max_distance / float(step_count);\n  float baseline = nearest_distance(p);\n  float occlusion = 0.0;\n  vec3 step = normal * step_size;\n  for (int i = 1; i <= step_count; i++) {\n    float expected_distance = baseline + float(i) * step_size;\n    float actual_distance = max(nearest_distance(p + float(i) * step), 0.0);\n    occlusion += actual_distance / expected_distance;\n  }\n  occlusion /= float(step_count);\n  return clamp(occlusion, 0.0, 1.0);\n}\n\nfloat cast_light(vec3 p, vec3 light, float radius) {\n  vec3 direction = normalize(light - p);\n  float light_distance = distance(light, p);\n\n  float light_brightness = 1.0 - (light_distance / radius);\n  if (light_brightness <= 0.0) {\n    return 0.0;\n  }\n\n  float in_light = 1.0;\n  float sharpness = 16.0;\n\n  float last_distance = 1e20;\n  float progress = MINIMUM_HIT_DISTANCE;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    if (progress > light_distance) {\n      return in_light * light_brightness;\n    }\n\n    float distance = nearest_distance(p + progress * direction);\n\n    if (distance < MINIMUM_HIT_DISTANCE) {\n      return 0.0;\n    }\n\n    float intersect_offset = distance * distance / (2.0 * last_distance);\n    float intersect_distance = sqrt(distance * distance - intersect_offset * intersect_offset);\n    if (distance < last_distance) {\n      in_light = min(in_light, sharpness * intersect_distance / max(0.0, progress - intersect_offset));\n    }\n    progress += distance;\n    last_distance = distance;\n  }\n  return 0.0;\n}\n\nvec3 march(vec3 ray_origin, vec3 ray_direction, out int steps) {\n  float distance = 0.0;\n\n  for (steps = 0; steps < MAX_STEPS; steps++) {\n    vec3 p = ray_origin + distance * ray_direction;\n    float nearest = nearest_distance(p);\n    if (nearest < MINIMUM_HIT_DISTANCE || distance > MAXIMUM_TRACE_DISTANCE) {\n      return p + nearest * ray_direction;\n    }\n\n    distance += nearest;\n  }\n  return ray_origin + distance * ray_direction;\n}\n\nvec3 nearest_color(vec3 p, vec3 camera_origin) {\n  float t = iTime;\n  vec3 normal = calculate_normal(p);\n  float occlusion = calculate_occlusion(p, normal);\n  vec3 P = p;\n  float light_intensities[1];\n  light_intensities[0] = cast_light(p + 2.0 * MINIMUM_HIT_DISTANCE * normal, lights[0].position, lights[0].radius);\n  vec3 p1 = (p - vec3(0.0, 81.0, 0.0));\n  vec3 p2 = (p1 * (mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0) * rotate_y((1.0 * (((sin(t) * 1.500000) + t) * 0.100000)))));\n  return union_color_3(p2, normal, occlusion, P, t, light_intensities, camera_origin);\n}\n\nvec3 perspective(float fov, vec2 size, vec2 pos) {\n  vec2 xy = pos - size * 0.5;\n\n  float cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\n  float z = min(size.x, size.y) * 0.5 * cot_half_fov;\n\n  return normalize(vec3(xy, -z));\n}\n\nmat3 rotate_xy(vec2 angle) {\n  vec2 c = cos(angle);\n  vec2 s = sin(angle);\n\n  return mat3(\n    c.y, 0.0, -s.y,\n    s.y * s.x, c.x, c.y * s.x,\n    s.y * c.x, -s.x, c.y * c.x\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float gamma = 2.2;\n  vec2 resolution = iResolution.xy;\n  vec2 local_coord = gl_FragCoord.xy;\n\n  vec3 camera_origin = vec3(0.0, 50.0 + 20.0 * sin(iTime * 0.25), 420.0);\n  vec2 rotation = vec2(-0.125, 0.125 - 0.5 * sin(iTime * 0.25));\n  if (iMouse.z > 0.0) {\n    vec2 mouse_offset = (iMouse.xy / resolution) - 0.5;\n    mouse_offset *= vec2(-1.0, 1.0);\n    rotation += mouse_offset;\n  }\n  mat3 camera_matrix = rotate_xy(rotation.yx);\n\n  camera_origin = camera_matrix * camera_origin + vec3(0.0, -32.0, 0.0);\n\n  int view_type = 1;\n\n  vec3 dir = camera_matrix * perspective(45.0, resolution, gl_FragCoord.xy);\n\n  const vec3 fog_color = vec3(0.15);\n\n  int steps;\n  vec3 hit = march(camera_origin, dir, steps);\n\n  vec3 color;\n  float depth = distance(camera_origin, hit);\n  if (depth >= MAXIMUM_TRACE_DISTANCE) {\n    const vec3 light = pow(vec3(69.0, 128.0, 230.0) / vec3(255.0), vec3(gamma));\n    const vec3 dark = pow(vec3(40.0, 60.0, 150.0) / vec3(255.0), vec3(gamma));\n    color = vec3(mix(dark, light, (local_coord.x + local_coord.y) / (resolution.x + resolution.y)));\n  } else {\n    color = nearest_color(hit, camera_origin);\n  }\n\n  fragColor = vec4(pow(color, vec3(1.0 / gamma)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3fWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4029, 4029, 4087, 4087, 4210], [4211, 4211, 4243, 4243, 4543], [4544, 4544, 4564, 4564, 4600], [4601, 4601, 4636, 4636, 5178], [5179, 5179, 5210, 5210, 5266], [5267, 5267, 5295, 5295, 5411], [5412, 5412, 5466, 5466, 5808], [5809, 5809, 5863, 5863, 6214], [6215, 6215, 6247, 6247, 6472], [6473, 6473, 6493, 6493, 6547], [6548, 6548, 6579, 6579, 6631], [6632, 6632, 6655, 6655, 6704], [6705, 6705, 6728, 6728, 6777], [6778, 6778, 6801, 6801, 6847], [6848, 6934, 6957, 6957, 9284], [9285, 9285, 9353, 9353, 9630], [9631, 9631, 9663, 9663, 10132], [10133, 10133, 10159, 10159, 10314], [10315, 10315, 10355, 10355, 10475], [10476, 10476, 10543, 10543, 10632], [10633, 10633, 10665, 10665, 11015], [11016, 11016, 11048, 11048, 11491], [11492, 11492, 11526, 11526, 11621], [11622, 11622, 11642, 11642, 11664], [11665, 11665, 11700, 11700, 12045], [12046, 12046, 12066, 12066, 12092], [12093, 12093, 12133, 12133, 12183], [12184, 12184, 12207, 12207, 12774], [12775, 12775, 12810, 12810, 13050], [13051, 13051, 13109, 13109, 13232], [13233, 13233, 13287, 13287, 13638], [13639, 13639, 13671, 13671, 14283], [14284, 14284, 14316, 14316, 14764], [14765, 14765, 14788, 14788, 14822], [14823, 14823, 14846, 14846, 15120], [15121, 15121, 15143, 15143, 15175], [15176, 15176, 15208, 15208, 16736], [16737, 16737, 16786, 16786, 16989], [16990, 16990, 17023, 17023, 17480], [17481, 17481, 17549, 17549, 17826], [17827, 17827, 17926, 17926, 18076], [18077, 18077, 18234, 18234, 18800], [18801, 18801, 18829, 18829, 18945], [18946, 18946, 18983, 18983, 19128], [19129, 19129, 19149, 19149, 19203], [19204, 19290, 19313, 19313, 20357], [20358, 20358, 20426, 20426, 20703], [20704, 20704, 20754, 20754, 21074], [21075, 21075, 21189, 21189, 22272], [22273, 22273, 22396, 22396, 26193], [26194, 26194, 26317, 26317, 28258], [28259, 28259, 28291, 28291, 28509], [28511, 28511, 28542, 28542, 28833], [28835, 28835, 28883, 28883, 29419], [29421, 29421, 29473, 29473, 30448], [30450, 30450, 30514, 30514, 30887], [30889, 30889, 30937, 30937, 31465], [31467, 31467, 31517, 31517, 31700], [31702, 31702, 31730, 31730, 31881], [31883, 31883, 31938, 31938, 33134]], "test": "untested"}
{"id": "sltfRs", "name": "Mega Polynomial Curve", "author": "iq", "description": "The curve that is made of all of the y(x) = xⁿ functions, one after the next. The first red segment is y=x, the next purple segment is y=x^2+c₂, the next blue one is y=x^3+c₃, etc. The function has been scaled vertically by 1/4 for display purposes.", "tags": ["2d", "polynomial"], "likes": 31, "viewed": 1738, "published": 3, "date": "1663549271", "time_retrieved": "2024-07-30T16:30:38.847679", "image_code": "// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// This is a curve made of all polynomials of the form yₙ(x)=xⁿ+cₙ, by stitiching\n// them together at the proper points xₙ and with the right vertical shifts cₙ, \n// such that their tangents coincide, forming a smooth curve (C1). The stitching\n// points are xₙ = { 1/2, 2/3, 3/4, 4/5, ...} and the coefficients cₙ are\n// { 0,  ½¹-½²+⅔³, ... }, so our \"Mega Polynomial\" function is \n// \n// mp(x) = \n//     if x<½ : x¹\n//     if x<⅔ : x² + (½¹ - ½²)\n//     if x<¾ : x³ + (½¹ - ½² + ⅔² - ⅔³)\n//     if x<⅘ : x⁴ + (½¹ - ½² + ⅔² - ⅔³ + ¾³ - ¾⁴)\n//     if x<⅚ : x⁵ + (½¹ - ½² + ⅔² - ⅔³ + ¾³ - ¾⁴ + ⅘⁴ - ⅘⁵)\n//     ...\n//\n// or alternativelly, shoter but less numerically stable (see line 59):\n// \n// mp(x) = \n//     if x<½ : x¹\n//     if x<⅔ : x² + 1¹/2²\n//     if x<¾ : x³ + 1¹/2² + 2²/3³\n//     if x<⅘ : x⁴ + 1¹/2² + 2²/3³ + 3³/4⁴\n//     if x<⅚ : x⁵ + 1¹/2² + 2²/3³ + 3³/4⁴ + 4⁴/5⁵\n//     ...\n//\n// Full expansion of connection points and coefficients:\n//\n// xₙ = { 0,  1/2,    2/3,       3/4,               4/5,                 5/6,                             6/7, ... }\n// cₙ = { 0,  1/4, 43/108, 3481/6912, 12647597/21600000, 380547619/583200000, 340607106994117/480290277600000, ... }\n//\n// The curve is only defined in [0,1), it tends to infinity as x approaches 1.\n// For ω = (1/6)*(202652381/12500)^(1/6) = 0.838473..., mp(ω) = 1.\n//\n// For a given x, the polynomial to consider is n = ⌊1/(1-x)⌋\n//\n// The coefficients cₙ can be computed with a loop. Or if you want to find a\n// closed form, the denominators are https://oeis.org/A061464, although before\n// simplifications they follow a simple multiplicative rule with nⁿ as a factor.\n//\n// Also, empirically cₙ seems to undulate around f(x)=-log(-log(x))/e, which\n// suggest attempting something in the lines of cₙ = -log(-log(1-1/(n+0.5)))/e\n\nfloat mp( float x, out int n )\n{\n    // determine segment n\n    n = int( min(floor(1.0/(1.0-x)),256.0) ); // max 256 polynomials\n\n    // compute cₙ\n    float c = 0.0;\n    for( int i=1; i<n; i++ )\n    {\n        float a = float(i+0);\n        float b = float(i+1);\n        \n     // c += pow(a,a)/pow(b,b);     // version a : simplified but unstable\n        c += pow(a/b,a)-pow(a/b,b); // version b : more stable\n    }\n\n    // compute yₙ as xⁿ + cₙ\n    return pow(x,float(n)) + c;\n}\n\nfloat helper( float x, in int n )\n{\n    float c = 0.0;\n    for( int i=1; i<n; i++ )\n    {\n        float a = float(i+0);\n        float b = float(i+1);\n        float d = a/b;\n        c += pow(d,a) - pow(d,b);\n    }\n    return c + pow(x,float(n));\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2  p = fragCoord/iResolution.x;\n    float px = 1.0/iResolution.x;\n    \n    p.x *= 0.995;\n    px  *= 0.995;\n    \n    // animate \"support\" polynomial\n    float time = mod(iTime,16.0);\n    int n = int(floor(time));\n\n    float demo = min(time,1.0) * (1.0-clamp(time-14.0,0.0,1.0));\n    if( n>0 ) n=n-1;\n    \n    // draw background\n    vec3 col = vec3( 0.0 );\n\n    // draw stiching points\n    {\n        float n = floor(1.0/(1.0-p.x));\n        float d = min(abs(p.x-n/(n+1.0)),\n                      abs(p.x-(n-1.0)/n));\n\n        float al = (1.0-smoothstep(0.0,1.0*px,d));\n        al *= 1.0-0.95*p.x;\n        al *= demo;\n        col = mix( col, vec3(0.85), al);\n    }\n    \n    // draw helper curve\n    if( n>0 )\n    {\n        float d = 1e20;\n        for( int i=-2; i<=2; i++ )\n        {\n            float x0 = p.x + px*(float(i+0));\n            float x1 = p.x + px*(float(i+1));\n            float y0 = 0.25*helper( x0, n );\n            float y1 = 0.25*helper( x1, n );\n            d = min( d, sdLine(p,vec2(x0,y0),vec2(x1,y1) ) );\n        }\n        float al = 1.0-smoothstep(0.0,2.0*px,d);\n        al *= demo;\n        col = mix( col, vec3(0.5), al );\n    }\n    \n    // draw Mega Polynomial\n    {\n        vec4 min_dis_col = vec4(1e20,0.0,0.0,0.0);\n        for( int i=-2; i<=2; i++ )\n        {\n            int e = 0;\n            int f = 0;\n            float x0 = p.x + px*(float(i+0));\n            float x1 = p.x + px*(float(i+1));\n            float y0 = 0.25*mp( x0, e );\n            float y1 = 0.25*mp( x1, f );\n            float d = sdLine(p,vec2(x0,y0),vec2(x1,y1) );\n            \n            if( e==n ) d -= 4.0*px*demo; // inflate current segment\n            \n            if( d < min_dis_col.x )\n            {\n                vec3 tmp = mix( vec3(1.0), 0.5+0.5*cos(float(e)+vec3(0,2,4)), demo );\n                min_dis_col = vec4(d,tmp);\n            }\n        }\n        col = mix( col, min_dis_col.yzw, 1.0-smoothstep(1.0*px,3.0*px,min_dis_col.x) );\n    }\n\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltfRs.jpg", "access": "api", "license": "mit", "functions": [[3024, 3024, 3056, 3083, 3510], [3512, 3512, 3547, 3547, 3758], [3760, 3760, 3809, 3809, 3919]], "test": "untested"}
{"id": "NltBRs", "name": "Dune Ornithopter", "author": "dean_the_coder", "description": "I fancied modelling the Dune ornithopter. :)\nApologies if performance is a problem - This one is a bit GPU-hungry.\nYouTube: https://youtu.be/01X29MpidM8", "tags": ["3d", "raymarching", "sand", "dune", "movie", "cineshader"], "likes": 45, "viewed": 3792, "published": 3, "date": "1663523201", "time_retrieved": "2024-07-30T16:30:39.778191", "image_code": "// 'Dune Ornithopter' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/NltBRs (YouTube: https://youtu.be/01X29MpidM8)\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// I fancied modelling the Dune ornithopter. :)\n// Apologies if performance is a problem - This one is a bit GPU-hungry.\n//\n// Tricks to aid performance:\n//   - Precalculate function results, rotation matrices, and simplify calculations\n//     when possible (see GLSL Shader Shrinker).\n//   - The 'copter SDF is not calculated when the ray is too far away.\n//   - Shadows not calculated if surface normal points away from the sun.\n//   - Only the ground and sky are reflected.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// totetmatt, Blackle, Dave Hoskins, byt3_m3chanic, tater,\n// and a bunch of others for sharing their time and knowledge!\n//\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n#define R\tiResolution\n#define Z0\tmin(iTime, 0.)\n#define I0\tmin(iFrame, 0)\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n\n/// Global time.\nfloat gt, WING_SPEED, fade = 1.;\nstruct Hit {\n\tfloat d;\n\tint id;\n\tvec3 p;\n};\n\nvoid U(inout Hit h, float d, int id, vec3 p) { if (d < h.d) h = Hit(d, id, p); }\n\nvoid UH(inout Hit h, Hit h2) { if (h2.d < h.d) h = h2; }\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nfloat sum2(vec2 v) { return dot(v, vec2(1)); }\n\nfloat mul3(vec3 v) { return v.x * v.y * v.z; }\n\nfloat h31(vec3 p3) {\n\tp3 = fract(p3 * .1031);\n\tp3 += dot(p3, p3.yzx + 333.3456);\n\treturn fract(sum2(p3.xy) * p3.z);\n}\n\nfloat h21(vec2 p) { return h31(p.xyx); }\n\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, sum2(s.yz)) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// Two n31 results from two scales.\nvec2 n331(vec3 p) {\n\treturn vec2(n31(p * 20.), n31(p * 38.));\n}\n\nfloat n21(vec2 p) { return n31(vec3(p, 1)); }\n\nfloat smin(float a, float b) {\n\tfloat h = sat(.5 + .5 * (b - a) / -.05);\n\treturn mix(b, a, h) + .05 * h * (1. - h);\n}\n\nfloat remap(float f, float in1, float in2) { return sat((f - in1) / (in2 - in1)); }\n\n// Dip below 0, overshoot 1, back down to 1.\nfloat backInOut(float x) {\n\tfloat f = x < .5 ? 2. * x : 1. - (2. * x - 1.),\n\t      g = pow(f, 3.) - f * sin(f * 3.141);\n\treturn x < .5 ? .5 * g : .5 * (1. - g) + .5;\n}\n\n// Ray/plane intersection.\nbool intPlane(vec3 p0, vec3 n, vec3 ro, vec3 rd, out float t) {\n\tfloat denom = dot(n, rd);\n\tt = dot(p0 - ro, n) / denom;\n\treturn t >= 0. && abs(denom) > 1e-4;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nfloat cap(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0., h);\n\treturn length(p) - r;\n}\n\nfloat honk(inout vec3 p, mat2 rot, vec2 r) {\n\tp.xy *= rot;\n\tfloat d = cap(p, r.x, r.y);\n\tp.x -= r.x;\n\treturn d;\n}\n\nfloat oct3D(vec3 p, float r, float h) {\n\tconst vec3 k = vec3(-.9239, .3827, .4142);\n\tp = abs(p);\n\tp.xy -= 2. * min(dot(k.xy, p.xy), 0.) * k.xy;\n\tp.xy -= 2. * min(dot(vec2(-k.x, k.y), p.xy), 0.) * vec2(-k.x, k.y);\n\tp.xy -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n\tvec2 d = vec2(length(p.xy) * sign(p.y), p.z - h);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nvec3 rayDir(vec3 ro, vec2 uv) {\n\tvec3 f = normalize(-ro),\n\t     r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 sky(vec3 rd) { return mix(mix(vec3(.74, .61, .52), vec3(.85, .81, .74), S(-.2, 0., rd.y)), vec3(1.54, 1.28, 1.23), S(.4, 1., dot(rd, vec3(-.33, .67, .67)))); }\n\n// Shameless self-promotion. :)\nfloat dtc(vec2 p, float fl) {\n\tp += vec2(.8, .9);\n\tp.y += p.x;\n\tp.x *= fl;\n\tp *= vec2(2.5, 3);\n\tif (abs(p.x) > .6 || abs(p.y) > .5) return 0.;\n\tif (step(min2(abs(p - vec2(0, .2))), .08) * step(p.y, .3) * step(abs(p.x), .4) > 0.) return 1.4;\n\tfloat f,\n\t      dc = step(.5, p.x);\n\tp.x = abs(p.x) - .46;\n\tf = dot(p, p);\n\tdc += step(f, .25) * step(.16, f);\n\treturn dc > 0. ? .8 : 0.;\n}\n\nvec2 dockFeet;\nHit wing(vec3 p, float ti, float isTop, float isBack) {\n\tp.y += .1 * (isTop * 2. - 1.) * (1. - isBack);\n\tp.xz *= rot(isBack * .1);\n\tif (isTop > 0.) {\n\t\tp.xy *= mat2(.995, .09983, -.09983, .995);\n\t\tti += .2;\n\t}\n\n\t// Wing dock and spin.\n\tp.xz *= rot(mix(1.25, 1.4, isBack) * dockFeet.x);\n\tp.yz *= rot(dockFeet.x * 5.2);\n\tfloat a, f, d, thk,\n\t      l = length(p);\n\tHit h = Hit(max(l - .35, p.x - .1), 3, p); // Ball socket. // Wing time.\n\ta = sin(3.141 * isBack + ti * WING_SPEED * 70. - abs(p.x) / 34.78261); // Pivot wing, and bend ends.\n\tf = max(sin(p.x * 70.), 0.) * .01; // Ridges.\n\td = l - .3; // Ball joint.\n\ta *= S(12., 12.5, gt); // Fade in initial wing movement.\n\td = min(d, honk(p, rot(a * .05), vec2(2, .16 - f))); // Wing rod.\n\tp.x -= 7.9;\n\tp.z -= .18;\n\n\t// Wing.\n\tthk = 1.01 - WING_SPEED;\n\tvec3 v = vec3(8, .04 * thk, .4);\n\tv.z -= .35 * sat(-6. - p.x) * sat(sign(p.z));\n\td = min(d, box(p, v - (.03 - .05 * S(-.35, -.15, p.z)) * thk));\n\tU(h, d, 3, p);\n\treturn h;\n}\n\nHit wings(vec3 p, float ti) {\n\tHit h;\n\th.d = 1e7;\n\tp.x--;\n\tp.y -= .1;\n\tvec3 dyz = vec3(0, .8, .8);\n\tfloat b = 1.;\n\tfor (float i = Z0; i < 2.; i++) {\n\t\tUH(h, wing(p - dyz * vec3(1, 1, -1), ti, b, 1. - b));\n\t\tUH(h, wing(p - dyz, ti, b, b));\n\t\tdyz = -dyz;\n\t\tb = 1. - b;\n\t}\n\n\treturn h;\n}\n\nvec3 rot2(vec3 p, float r) {\n\tp.xz *= rot(1.57079);\n\tp.yz *= rot(r);\n\treturn p;\n}\n\n// Copter pitch, height, distance.\nvec3 cop;\n\nvec3 copterPos(vec3 p) {\n\tp.yz *= rot(cop.x);\n\treturn p;\n}\n\n// 'smooth' abs().\nfloat sabs(float f) { return sqrt(f * f + 3e-4); }\n\nHit gnd(vec3 p) {\n\tp.y += cop.y;\n\tp.z -= cop.z;\n\tfloat h1,\n\t      lz = S(0., 90., length(p.xz));\n\tp.y += 1.77;\n\tvec3 pp = p;\n\tp.x += sin(p.z * .02 + 1.4 * n21(p.zx * .05)) * 15.;\n\n\t// Dunes.\n\th1 = (1. - sabs(sin(p.x * .03))) * 12.;\n\n\t// Sand bumps.\n\treturn Hit((p.y - mix(max(-.7, sin(p.x * 10. + sin(p.z + p.y))) * .02 * (1. - lz), h1, lz * lz)) * .9, 4, pp);\n}\n\nHit map(vec3 p) {\n\tp = p.zyx;\n\tHit h = gnd(p);\n\n\t// Optimization - Not close enough to the 'copter to bother including it.\n\tif (abs(p.z) > 52.) return h;\n    \n\tp = copterPos(p);\n\tp.x = abs(p.x);\n\tvec3 q,\n\t     op = p;\n\n\t// Legs.\n\tp += vec3(-.3, .8, .8);\n    mat2 m = mat2(.87758, .47943, -.47943, .87758);\n\tp.xy *= m;\n\tfloat f,\n\t      d = honk(p.zyx, rot(-dockFeet.y * .5), vec2(1, .1));\n\td = min(d, honk(p.zyx, rot(3.4 + dockFeet.y * .8), vec2(1, .1)));\n\tp.yz *= rot(.25 + .31 * S01(dockFeet.y));\n\tp.xy *= m;\n\td = min(d, box(p + vec3(0, -.05 * S(.2, .4, abs(p.z)), 0), vec3(.14, .05, .4)));\n\tp.z -= .3;\n\tp.y += (S(1., 1.3, abs(p.z)) - 1.) * .05;\n\td = min(d, box(p, vec3(.2, .03, 1.2)) - .02);\n\tU(h, d, 3, p);\n\tp = op;\n\n\t// Tail.\n\td = oct3D(p.xzy - vec3(0, 14.8, .4), 1., .3 - .2 * p.x);\n\n\t// Fuselage.\n\tp.z += 4.2;\n\tf = S(5., 10., p.z);\n\tp.y = abs(p.y - .1 - .3 * f) + .4;\n\td = min(d, oct3D(p - vec3(0, 0, 10), 1.3 - f * .6, 10.));\n\n\t// Cockpit.\n\tp = op;\n\tp.y -= 4.4;\n\tp.yz *= mat2(.97367, -.22798, .22798, .97367);\n\tp.z += 4.;\n\td = max(d, p.x - p.z * .4 - .6);\n\td = max(d, -p.z - 1.18);\n\tq = p;\n\tq.y += .3 * abs(sat(p.x - .28 - .14 * p.z));\n\n\t// Windows.\n\tf = S(.06, 0., abs(q.z) - .9) * S(.52, .46, q.x - q.z * .32);\n\tf *= step(-3., q.y);\n\n\t// Nose top slope.\n\td = max(d, f * .015 - oct3D(q.zyx, 3., 2.));\n\n\t// Nose window side cut-outs.\n\tp += vec3(-3.02, 3.5, 1.28);\n\tp.y -= max(0., p.z - 1.5) * S(.2, 0., p.y);\n\tp.yz *= mat2(.99755, .06994, -.06994, .99755);\n\tp.xz *= mat2(.90045, .43497, -.43497, .90045);\n\td = smin(d, -oct3D(p.xzy, 3., .65) - .2);\n\n\t// Glass.\n\tf += step(-.4, p.y) * mul3(step(p, vec3(p.z * 1.02 - 3.9, .43, 2.8)));\n\tU(h, d - .05, 3 - 2 * int(step(1., f)), p);\n\n\t// Wings.\n\tUH(h, wings(op, gt));\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * .1;\n\tvec3 n = vec3(0);\n\tfor (int i = I0; i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld, vec3 n) {\n\t// Quick abort if light is behind the normal.\n\tif (dot(ld, n) < -.1) return 0.;\n\tfloat d,\n\t      s = 1.,\n\t      t = .01;\n\tfor (float i = Z0; i < 47.; i++) {\n\t\td = map(t * ld + p).d;\n\t\ts = min(s, 25. * d / t);\n\t\tt += max(.05, d);\n\t\tif (70. - t < .5 || s < .01) break;\n\t}\n\n\treturn S01(s);\n}\n\n// Quick 2-level ambient occlusion.\nfloat ao(vec3 p, vec3 n, vec2 h, float wingDock) {\n\tfloat od = dockFeet.x;\n\tdockFeet.x = wingDock;\n\tvec2 ao;\n\tfor (int i = I0; i < 2; i++)\n\t\tao[i] = map(h[i] * n + p).d;\n\n\tdockFeet.x = od;\n\treturn sat(min2(ao / h));\n}\n\nfloat fog(float d) { return S(0., -80., d - 4e2); }\n\nvec3 lights(vec3 p, vec3 rd, vec3 n, Hit h) {\n\tconst vec3 ld = vec3(-.33333, .66667, .66667);\n\tfloat fre,\n\t      spe = 10.,\n\t      shine = 1.;\n\tvec3 c, l, sc;\n\tif (h.id == 4) {\n\t\t// Sand.\n\t\tc = vec3(.45, .35, .23);\n\t\tspe = .1;\n\t\tvec2 uv = h.p.xz * 1e2;\n\t\tshine = .05 + .1 * S(h21(floor(uv)), 0., length(fract(uv) - .5));\n\t\tfloat dust = S(1., 0., abs(gt - 21.) / 7.);\n\t\tif (dust > 0.) {\n\t\t\tfloat l = length(p.xz);\n\t\t\tdust *= S(15., 0., abs(l - 9.));\n\t\t\tdust *= n21(vec2(atan(p.x, p.z), l - gt * 20.) * vec2(12, 2));\n\t\t\tc = mix(c, vec3(.63, .49, .322), dust);\n\t\t}\n\t}\n\telse if (h.id == 3) {\n\t\t// 'copter.\n\t\tvec2 ns = n331(h.p);\n\t\tshine = 1.2 - sum2(ns) * .3;\n\t\tshine += dtc(h.p.xy, sign(p.z));\n\t\tc = vec3(.0185, .0165, .0125) * shine;\n\t\tfloat sand = S(.9, 0., ao(p, n, vec2(.2, 1.3), 0.) - ns.x * .45);\n\t\tsand *= .5 + .5 * ns[1];\n\t\tc = mix(c, vec3(.45, .35, .23), sand * .16);\n\t}\n\telse {\n\t\t// Window.\n\t\tc = vec3(.01);\n\t\tshine = 10.;\n\t\tspe = 20.;\n\t}\n\n\tl = sat(vec3(dot(ld, n),  // Key light.\n                 sat(-n.y),  // Reverse light.\n                 sat(n.y) // Sky light.\n\t       ));\n\tl.xy = .1 + .9 * l.xy; // Diffuse.\n\tl.yz *= .1 + .9 * ao(p, n, vec2(.2, 1), dockFeet.x); // Ambient occlusion.\n\tl *= vec3(1.1, .25, .3); // Light contributions (key, reverse, sky).\n\tl.x += pow(sat(dot(normalize(ld - rd), n)), spe) * shine; // Specular (Blinn-Phong)\n\tl.x *= .01 + .99 * shadow(p, ld, n); // Shadow.\n\tfre = S(.7, 1., 1. + dot(rd, n)) * .05;\n\tsc = sky(rd);\n\treturn mix((sum2(l.xy) * vec3(2.4, 2, 1.92) + l.z * sc) * c, sc, fre);\n}\n\nfloat addFade(float a) { return min(1., abs(gt - a)); }\n\nvec3 scene(vec3 ro, vec3 rd) {\n\tfade = addFade(0.) * addFade(20.);\n\n\t// March the scene.\n\tvec3 n, col,\n\t     p = ro;\n\tfloat i,\n\t      d = 1.;\n\tHit h;\n\tfor (i = Z0; i < 150.; i++) {\n\t\th = map(p);\n\n\t\tif (abs(h.d) < .001 * d || d > 4e2) break;\n\t\td += h.d;\n\t\tp += h.d * rd;\n\t}\n\n\tn = N(p, d);\n\tcol = mix(sky(rd), lights(p, rd, n, h), fog(d));\n\n\t// Wing blur.\n\tfloat blurVis = S(.4, .7, WING_SPEED);\n\tif (blurVis > 0.) {\n\t\tconst mat2 m1 = mat2(.63268e-5, 1, -1, .63268e-5);\n\t\tfloat t,\n\t\t      ws = gt * WING_SPEED;\n\t\tmat2 m2 = rot(-cop.x);\n\t\tvec3 pn = vec3(0, 0, 1);\n\t\tpn.yz *= m2;\n\t\tpn.xz *= m1;\n\t\tfor (float dz = -1.; dz <= 1.; dz += 2.) {\n\t\t\tvec3 copP = vec3(0, 0, .8 * dz);\n\t\t\tcopP.yz *= m2;\n\t\t\tcopP.xz *= m1;\n\t\t\tfor (float dy = -1.; dy <= 1.; dy += 2.) {\n\t\t\t\tif (intPlane(copP, pn, ro, rd, t) && t < d) {\n\t\t\t\t\tp = rot2(rd * t + ro, cop.x);\n\t\t\t\t\tp.x = abs(p.x);\n\t\t\t\t\tp.xy *= rot(.1 * sat(-dy));\n\t\t\t\t\tp.y += .8 * dy + sat(-dy) * .3;\n\t\t\t\t\tfloat tint = sin(p.y * 120. / p.x + ws * 10.);\n\t\t\t\t\ttint *= sin(p.y * 80. / p.x - ws * 20.);\n\t\t\t\t\ttint = sat(tint * .5 + .9);\n\t\t\t\t\ttint *= S(1.5, 2., p.x);\n\t\t\t\t\ttint *= S(6., -5., p.x - 16.);\n\t\t\t\t\ttint *= S(p.x * .15, 0., abs(p.y));\n\t\t\t\t\tcol = mix(col, vec3(.02, .03, .01), tint * .4 * blurVis);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (h.id < 2) {\n\t\t// We hit a reflective surface, so march reflection.\n\t\trd = reflect(rd, n);\n\t\tp += n * .01;\n\t\td = .01;\n\t\tfor (i = Z0; i < 32.; i++) {\n\t\t\th = gnd(p.zyx);\n\t\t\tif (abs(h.d) < .0015 * d || d > 10.) break;\n\t\t\td += h.d;\n\t\t\tp += h.d * rd;\n\t\t}\n\n\t\t// Add a hint of the reflected color.\n\t\tvec3 sc = sky(rd);\n\t\tcol += .1 * (d > 10. ? sc : mix(sc, lights(p, rd, N(p, d), h), fog(d)));\n\t}\n\n    // Gamma.\n\treturn pow(max(vec3(0), col), vec3(.4545));\n}\n\n#define rgba(col)\tvec4(col * fade, 0)\n\nvoid mainImage(out vec4 fragColor, vec2 fc) {\n\tgt = mod(iTime, 60.);\n\tvec2 uv = (fc - .5 * R.xy) / R.y;\n\n\t// Camera.\n\tfloat fly, x,\n\t      camDrift = remap(gt, 30., 34.);\n\tvec3 ro, col,\n\t     cam = mix(vec3(0, .30, .125), vec3(.44, .58, .32), S01(remap(gt, 0., 10.)));\n\tcam = mix(mix(mix(mix(cam, vec3(.37, .78, .44), S01(remap(gt, 9., 20.))), vec3(.46, .5, .19), S01(remap(gt, 20., 20.01))), vec3(.35, .53, .3), S01(remap(gt, 20.01, 25.))), vec3(.8, .75, 1.25), S01(remap(gt, 31., 33.)));\n\tWING_SPEED = pow(ceil(pow(remap(gt, 12., 18.), 2.) * 4.) / 4., 2.);\n\n\t// Movement.\n\tfly = remap(gt, 28., 30.);\n\tx = max(0., gt - 29.) * fly;\n\tcop.z = x * (1. - exp(-.1 * x)) * 250.;\n\tcop.y = 8. * sin(x * 1.5) * camDrift;\n\tcop.y += 8. + fly * 22.;\n\tcop.y *= S01(remap(gt, 24., 27.));\n\tcop.x = (cop.x / -360. - backInOut(fly)) * .2;\n\tdockFeet = vec2(S(9., 5., gt), remap(gt, 29., 25.));\n\n\t// Camera drift.\n\tcam += vec3(sin(gt * .4) * .05 - .05 - sin(gt * .1), sin(gt * .6) * .05, sin(gt * .5) * .8) * camDrift;\n\n\t// Scene.\n\tro = vec3(0, 0, -35. * cam.z);\n\tro.yz *= rot(1. - cam.y * 2.);\n\tro.xz *= rot(cam.x * -6. - 3.);\n\tcol = scene(ro, rayDir(ro, uv));\n\n\t// Vignette.\n\tcol *= 1. - .3 * dot(uv, uv);\n\n\t// Grain.\n\tcol += (h21(fc) - .5) / 32.;\n    \n\tfragColor = rgba(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltBRs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1264, 1264, 1310, 1310, 1344], [1346, 1346, 1376, 1376, 1402], [1404, 1404, 1424, 1424, 1448], [1450, 1450, 1470, 1470, 1494], [1496, 1496, 1516, 1516, 1550], [1552, 1552, 1572, 1572, 1598], [1600, 1600, 1620, 1620, 1646], [1648, 1648, 1668, 1668, 1765], [1767, 1767, 1786, 1786, 1807], [1809, 1809, 1828, 1828, 2170], [2172, 2208, 2227, 2227, 2271], [2273, 2273, 2292, 2292, 2318], [2320, 2320, 2350, 2350, 2437], [2439, 2439, 2483, 2483, 2522], [2524, 2569, 2595, 2595, 2736], [2738, 2765, 2828, 2828, 2925], [2927, 2927, 2946, 2946, 3013], [3015, 3015, 3042, 3042, 3113], [3115, 3115, 3152, 3152, 3204], [3206, 3206, 3250, 3250, 3319], [3321, 3321, 3360, 3360, 3682], [3684, 3684, 3715, 3715, 3843], [3845, 3845, 3864, 3864, 4009], [4011, 4043, 4072, 4072, 4424], [4441, 4441, 4496, 4496, 5415], [5417, 5417, 5446, 5446, 5700], [5702, 5702, 5730, 5730, 5783], [5831, 5831, 5855, 5855, 5889], [5891, 5910, 5931, 5931, 5960], [5962, 5962, 5979, 5979, 6324], [6326, 6326, 6343, 6343, 8057], [8059, 8059, 8084, 8084, 8291], [8293, 8293, 8332, 8379, 8622], [8624, 8660, 8710, 8710, 8877], [8879, 8879, 8899, 8899, 8930], [8932, 8932, 8977, 8977, 10464], [10466, 10466, 10490, 10490, 10521], [10523, 10523, 10553, 10553, 12228], [12269, 12269, 12314, 12314, 13530]], "test": "untested"}
{"id": "sldcW2", "name": "Into Infinity", "author": "dominionxvii", "description": "wat ever", "tags": ["raymarching"], "likes": 0, "viewed": 53, "published": 3, "date": "1663509888", "time_retrieved": "2024-07-30T16:30:40.911162", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 5000\n#define MAX_DIST 200.\n#define SURF_DIST .01\n\n#define S smoothstep\n#define T iTime\n#define STEPS 0.5\n#define IOR 1.47\n\n#define ANTIALIASING\n\n//vec3 camPosition;\nvec3 cameraForward;\n\nstruct RayHit\n{\n    vec3 ro;\n    vec3 rd;\n    \n    vec3 pos;\n    float dist;\n\n    vec3 normal;\n    vec3 reflDir;\n    vec3 refractDir;\n    int steps;\n    bool hasHit;\n    vec3 instanceID;\n    float closestDist;\n    \n    float totalDist;\n};\n\nvec3 GetObjectColor(vec3 instanceID)\n{\n    float hue = 37. * instanceID.x + 43. * instanceID.y + 29. * instanceID.z;\n    return HSVtoColor(hue, 1., 1.);\n}\n\nvec3 GetObjectColor(RayHit hit)\n{\n    return GetObjectColor(hit.instanceID);\n}\n\n\nvec3 GetInstanceID(vec3 p)\n{\n    return floor((p + STEPS/2.) / STEPS);\n}\n\nvec3 DistortTimeAndSpace(vec3 p)\n{\n    p.y += 5.5 * sin(p.z * .15); \n    p.x += 5.5 * cos(p.z * .15);\n    \n    mat2 r2 = Rot(p.z * .0);\n    p.xy *= r2;\n    \n    return p;\n}\n\nfloat GetDist(vec3 p)\n{\n    p = DistortTimeAndSpace(p);\n    vec3 ids = GetInstanceID(p);\n    \n    p = opRep(p, vec3(STEPS));\n\n    //float d = sdSphere(p, 0.15 + 0.05 * sin(ids.z * .7 + ids.x * 0.5));\n    float d = sdSphere(p, 0.1);\n\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nRayHit CalculateRayHit(vec3 ro, vec3 rd, float dist, bool hasHit, int steps, float closestDist)\n{\n    RayHit hit;\n    hit.ro = ro;\n    hit.rd = rd;\n    hit.dist = dist;\n    hit.pos = ro + rd * dist;\n    hit.normal = GetNormal(hit.pos);\n    hit.reflDir = reflect(rd, hit.normal);\n    hit.refractDir = refract(rd, hit.normal, IOR);\n    hit.steps = steps;\n    hit.closestDist = closestDist;\n\n    hit.hasHit = hasHit;\n    hit.instanceID = GetInstanceID(DistortTimeAndSpace(hit.pos));\n    return hit;\n}\n\n\n\nRayHit RayMarch(vec3 ro, vec3 rd) {\n\tfloat dist = 0.;\n    bool hasHit = false;\n    \n    int steps = 0;\n    float closestDist = MAX_DIST;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * dist;\n        float dS = GetDist(p);\n        dist += dS;\n        \n        closestDist = min(closestDist, dS);\n        \n        steps = i;\n        \n        if(dist > MAX_DIST) break;\n        \n        if(abs(dS) < SURF_DIST)\n        {\n            hasHit = true;\n            break;\n        }\n    }\n    \n    return CalculateRayHit(ro, rd, dist, hasHit, steps, closestDist);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) \n{ \n    vec3 f = normalize(l-p);\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f,r);\n    vec3 c = f*z;\n    vec3 i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 GetColor(RayHit hit)\n{\n    vec3 col;\n    vec3 highLight;\n    \n    if(hit.hasHit) \n    {\n        float fresnel = saturate(dot(-hit.rd, hit.normal));\n        fresnel = 1. - pow(fresnel, 1.);\n        \n        col = GetObjectColor(hit);\n        \n        col += fresnel;\n        \n        vec3 lightDir = cameraForward;\n\n        float diffuse = 2. * saturate(dot(hit.normal, lightDir));\n        \n        float specularStrength = 1.5;\n        float spec = pow(max(dot(hit.rd, hit.reflDir), 0.0), 32.);\n        vec3 specular = specularStrength * spec * vec3(1);  \n\n        col *= diffuse + specular;\n        col *= saturate(0.5 - saturate(hit.totalDist / (MAX_DIST * 0.3)));\n        //col = pow(col, 5.);\n    }\n    \n    \n    //highLight = vec3(1.0) * saturate(hit.closestDist * 1.);\n    \n    \n    float highlightRatio = saturate(float(hit.steps) / 150.);\n    highlightRatio = highlightRatio * highlightRatio;\n    vec3 fog = GetCol(109, 143, 163);\n    //vec3 fog =  vec3(0.0);\n\n    return mix(col, fog, highlightRatio) + highLight; \n}\n\nvoid PerspectiveCam(vec3 camPos, vec4 camRot, vec2 uv, float fov, float aspectRatio, out vec3 ro, out vec3 rd)\n{\n\n    //float imageAspectRatio = resolution.x / resolution.y;  //assuming width > height\n    uv.x = uv.x * tan(fov / 2. * PI / 180.) * aspectRatio;\n    uv.y = uv.y * tan(fov / 2. * PI / 180.);\n\n    //Add FOV\n    vec3 forward = normalize(vec3(uv.x, uv.y, 1.));\n    ro = camPos;\n    rd = qmul(camRot, forward);\n}\n\nvoid OrthographicCam(vec3 camPos, vec4 camRot, vec2 uv, float size, float aspectRatio, out vec3 ro, out vec3 rd)\n{\n    //float imageAspectRatio = resolution.x / resolution.y;  //assuming width > height\n    uv.x = uv.x * aspectRatio;\n    uv.y = uv.y;\n\n    //Add FOV\n    //float3 forward = normalize(float3(uv.x, uv.y, 1.0));\n    ro = camPos + (uv.x * qmul(camRot, vec3(1, 0, 0)) * size) + (uv.y * qmul(camRot, vec3(0, 1, 0)) * size);\n    rd = qmul(camRot, vec3(0, 0, 1));\n}\n\n\n\nvec3 GetColor(vec3 camPos, vec4 camRot, vec2 uv)\n{\n    //vec3 ro1, rd1;\n    //vec3 ro2, rd2;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    //PerspectiveCam(camPos, camRot, uv, aspectRatio, ro1, rd1);\n    //OrthographicCam(camPos, camRot, uv, 5., aspectRatio, ro2, rd2);\n\n    //vec3 ro = mix(ro1, ro2, 0.0);\n   // vec3 rd = mix(rd1, rd2, 0.0);\n    vec3 ro, rd;\n    const float fov = 40.;\n    PerspectiveCam(camPos, camRot, uv, fov, aspectRatio, ro, rd);\n\n\n    //vec3 fpos = DistortTimeAndSpace(vec3(0.0, 0.0, 0.75 * iTime));\n    //vec3 ro = vec3(-fpos.x - STEPS/2., -fpos.y - STEPS/2., fpos.z);\n    //camPosition = ro;\n    \n    //vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n\n    const int reflections = 5;\n    int lastReflectionId = 0;\n    vec3 hitColors[reflections];\n    \n    float totalDist = 0.;\n    RayHit hit;\n    for(int i = 0; i < reflections; i++)\n    {\n        hit = RayMarch(ro, rd);\n        \n        if(hit.hasHit)\n        {\n            totalDist += hit.dist;\n            hit.totalDist = totalDist;\n            hitColors[i] = GetColor(hit);\n        \n            lastReflectionId = i;\n            ro = hit.pos + hit.normal * (SURF_DIST + 0.01);\n            rd = hit.reflDir;\n        }\n        else\n        {\n            \n            break;\n        }\n    }\n    \n    vec3 col = hitColors[lastReflectionId];\n    for (int i = lastReflectionId - 1; i >= 0; i--)\n    {\n        col = mix(hitColors[i], col, 0.2);\n    }\n    return col;\n}\n\nvec3 FixPos(vec3 pos)\n{\n    pos = DistortTimeAndSpace(pos);\n    return vec3(-pos.x + STEPS/2., -pos.y + STEPS/2. , pos.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uv = (fragCoord.xy / iResolution.xy) - vec2(0.5);\n\n    \n    float speed = 1.5;\n    //float speed = 1.5;\n\n   // vec3 fpos = DistortTimeAndSpace(vec3(0.0, 0.0,speed * iTime));\n    \n    vec3 fposPrev1 = FixPos(vec3(0.0, 0.0, speed * iTime + 1.5));\n    vec3 fposPrev2 = FixPos(vec3(0.0, 0.0, speed * iTime + 1.4));\n    cameraForward = normalize(fposPrev1 - fposPrev2);\n\n    //vec3 camPos = vec3(-fpos.x + STEPS/2., -fpos.y + STEPS/2. , fpos.z);\n    vec3 camPos = FixPos(vec3(0.0, 0.0, speed * iTime));\n\n    vec4 camRot = qLookAt(cameraForward, vecY(1.0));\n\n\n    vec3 col;\n    #ifdef ANTIALIASING\n        vec3 colorSum = vec3(0.0);        \n        //vec2 nextUv = ((fragCoord+vec2(1.0))-0.5*iResolution.xy)/iResolution.y;\n        vec2 nextUv = ((fragCoord.xy+vec2(1.0)) / iResolution.xy) - vec2(0.5);\n\n\n        colorSum += GetColor(camPos, camRot, uv);\n        colorSum += GetColor(camPos, camRot, mix(uv, vec2(uv.x, nextUv.y), 0.5));\n        colorSum += GetColor(camPos, camRot, mix(uv, vec2(nextUv.x, uv.y), 0.5));\n        colorSum += GetColor(camPos, camRot, mix(uv, nextUv, 0.5));\n        colorSum /= 4.0;\n        \n        col = colorSum;  \n    #else\n        col = GetColor(camPos, camRot, uv);\n    #endif\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "\n#define TAU 6.283185\n#define PI 3.141592\n\nvec3 GetCol(int r, int g, int b)\n{\n    return vec3(r, g, b) / 255.;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 v)\n{\n    return vec3(saturate(v.x), saturate(v.y), saturate(v.z));\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat Quantize(float x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec2 Quantize(vec2 x, vec2 resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec2 Quantize(vec2 x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec3 Quantize(vec3 x, float resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec3 Quantize(vec3 x, vec3 resolution)\n{\n    return floor(x * resolution) / resolution;\n}\nvec3 HSVtoColor(float hue, float saturation, float value)\n{\n    float hi = mod(floor(hue / 60.), 6.);\n    float f = hue / 60. - floor(hue / 60.);\n\n    value = value;\n    float v = value;\n    float p = value * (1. - saturation);\n    float q = value * (1. - f * saturation);\n    float t = value * (1. - (1. - f) * saturation);\n\n    if (hi == 0.)\n        return vec3(v, t, p);\n    else if (hi == 1.)\n        return vec3(q, v, p);\n    else if (hi == 2.)\n        return vec3(p, v, t);\n    else if (hi == 3.)\n        return vec3(p, q, v);\n    else if (hi == 4.)\n        return vec3(t, p, v);\n    else\n        return vec3(v, p, q);\n}\n\n// NOISE\n// All this section is taken from \n//https://github.com/Unity-Technologies/Unity.Mathematics/blob/master/src/Unity.Mathematics/Noise/noise2D.cs\n\nfloat mod289(float x)  \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\n vec4 mod289(vec4 x) \n{ return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec4 permute(vec4 x) \n{ return mod289((34.0 * x + 1.0) * x); }\nvec3 mod7(vec3 x) \n{ return x - floor(x * (1.0f / 7.0f)) * 7.0f; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec4 fade(vec4 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n        \nfloat snoise(vec2 v)\n{\n    vec4 C = vec4(0.211324865405187,  // (3.0-math.sqrt(3.0))/6.0\n                          0.366025403784439,  // 0.5*(math.sqrt(3.0)-1.0)\n                         -0.577350269189626,  // -1.0 + 2.0 * C.x\n                          0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = math.step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0f, 1.0f);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    float  gx = a0.x * x0.x + h.x * x0.y;\n    vec2 gyz = a0.yz * x12.xz + h.yz * x12.yw;\n    vec3 g = vec3(gx,gyz);\n\n    return 130.0 * dot(m, g);\n}\n\nfloat snoiseRotate(vec2 center, float r, float t)\n{\n    t *= TAU;\n    float s = sin(t), c = cos(t);\n    vec2 p = center + r * vec2(s, c);\n    return snoise(p);\n}\n\nfloat snoise(vec3 v)\n{\n    vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy; \n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n                                 i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                             + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n\n\nfloat pnoise(vec2 P, vec2 rep)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x, gy.x);\n    vec2 g10 = vec2(gx.y, gy.y);\n    vec2 g01 = vec2(gx.z, gy.z);\n    vec2 g11 = vec2(gx.w, gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\n\nvec2 cellular(vec2 P)\n{\n    const float K = 0.142857142857f; // 1/7\n    const float Ko = 0.428571428571f; // 3/7\n    const float jitter = 1.0f; // Less gives more regular pattern\n\n    vec2 Pi = mod289(floor(P));\n    vec2 Pf = fract(P);\n    vec3 oi = vec3(-1.0, 0.0, 1.0);\n    vec3 of = vec3(-0.5, 0.5, 1.5);\n    vec3 px = permute(Pi.x + oi);\n    vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n    vec3 ox = fract(p * K) - Ko;\n    vec3 oy = mod7(floor(p * K)) * K - Ko;\n    vec3 dx = Pf.x + 0.5 + jitter * ox;\n    vec3 dy = Pf.y - of + jitter * oy;\n    vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n    p = permute(px.y + Pi.y + oi); // p21, p22, p23\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 0.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n    p = permute(px.z + Pi.y + oi); // p31, p32, p33\n    ox = fract(p * K) - Ko;\n    oy = mod7(floor(p * K)) * K - Ko;\n    dx = Pf.x - 1.5 + jitter * ox;\n    dy = Pf.y - of + jitter * oy;\n    vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n    // Sort out the two smallest distances (F1, F2)\n    vec3 d1a = min(d1, d2);\n    d2 = max(d1, d2); // Swap to keep candidates for F2\n    d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n    d1 = min(d1a, d2); // F1 is now in d1\n    d2 = max(d1a, d2); // Swap to keep candidates for F2\n    d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n    d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n    d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n    d1.y = min(d1.y, d1.z); // nor in  d1.z\n    d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n    return sqrt(d1.xy);\n}\n\nvec2 cellular(vec3 P)\n{\n    const float K = 0.142857142857; // 1/7\n    const float Ko = 0.428571428571; // 1/2-K/2\n    const float K2 = 0.020408163265306; // 1/(7*7)\n    const float Kz = 0.166666666667; // 1/6\n    const float Kzo = 0.416666666667; // 1/2-1/6*2\n    const float jitter = 1.0f; // smaller jitter gives more regular pattern\n\n    vec3 Pi = mod289(floor(P));\n    vec3 Pf = fract(P) - 0.5;\n    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n    vec3 p1 = permute(p + Pi.y - 1.0);\n    vec3 p2 = permute(p + Pi.y);\n    vec3 p3 = permute(p + Pi.y + 1.0);\n    vec3 p11 = permute(p1 + Pi.z - 1.0);\n    vec3 p12 = permute(p1 + Pi.z);\n    vec3 p13 = permute(p1 + Pi.z + 1.0);\n    vec3 p21 = permute(p2 + Pi.z - 1.0);\n    vec3 p22 = permute(p2 + Pi.z);\n    vec3 p23 = permute(p2 + Pi.z + 1.0);\n    vec3 p31 = permute(p3 + Pi.z - 1.0);\n    vec3 p32 = permute(p3 + Pi.z);\n    vec3 p33 = permute(p3 + Pi.z + 1.0);\n    vec3 ox11 = fract(p11 * K) - Ko;\n    vec3 oy11 = mod7(floor(p11 * K)) * K - Ko;\n    vec3 oz11 = floor(p11 * K2) * Kz - Kzo; // p11 < 289 guaranteed\n    vec3 ox12 = fract(p12 * K) - Ko;\n    vec3 oy12 = mod7(floor(p12 * K)) * K - Ko;\n    vec3 oz12 = floor(p12 * K2) * Kz - Kzo;\n    vec3 ox13 = fract(p13 * K) - Ko;\n    vec3 oy13 = mod7(floor(p13 * K)) * K - Ko;\n    vec3 oz13 = floor(p13 * K2) * Kz - Kzo;\n    vec3 ox21 = fract(p21 * K) - Ko;\n    vec3 oy21 = mod7(floor(p21 * K)) * K - Ko;\n    vec3 oz21 = floor(p21 * K2) * Kz - Kzo;\n    vec3 ox22 = fract(p22 * K) - Ko;\n    vec3 oy22 = mod7(floor(p22 * K)) * K - Ko;\n    vec3 oz22 = floor(p22 * K2) * Kz - Kzo;\n    vec3 ox23 = fract(p23 * K) - Ko;\n    vec3 oy23 = mod7(floor(p23 * K)) * K - Ko;\n    vec3 oz23 = floor(p23 * K2) * Kz - Kzo;\n    vec3 ox31 = fract(p31 * K) - Ko;\n    vec3 oy31 = mod7(floor(p31 * K)) * K - Ko;\n    vec3 oz31 = floor(p31 * K2) * Kz - Kzo;\n    vec3 ox32 = fract(p32 * K) - Ko;\n    vec3 oy32 = mod7(floor(p32 * K)) * K - Ko;\n    vec3 oz32 = floor(p32 * K2) * Kz - Kzo;\n    vec3 ox33 = fract(p33 * K) - Ko;\n    vec3 oy33 = mod7(floor(p33 * K)) * K - Ko;\n    vec3 oz33 = floor(p33 * K2) * Kz - Kzo;\n    vec3 dx11 = Pfx + jitter * ox11;\n    vec3 dy11 = Pfy.x + jitter * oy11;\n    vec3 dz11 = Pfz.x + jitter * oz11;\n    vec3 dx12 = Pfx + jitter * ox12;\n    vec3 dy12 = Pfy.x + jitter * oy12;\n    vec3 dz12 = Pfz.y + jitter * oz12;\n    vec3 dx13 = Pfx + jitter * ox13;\n    vec3 dy13 = Pfy.x + jitter * oy13;\n    vec3 dz13 = Pfz.z + jitter * oz13;\n    vec3 dx21 = Pfx + jitter * ox21;\n    vec3 dy21 = Pfy.y + jitter * oy21;\n    vec3 dz21 = Pfz.x + jitter * oz21;\n    vec3 dx22 = Pfx + jitter * ox22;\n    vec3 dy22 = Pfy.y + jitter * oy22;\n    vec3 dz22 = Pfz.y + jitter * oz22;\n    vec3 dx23 = Pfx + jitter * ox23;\n    vec3 dy23 = Pfy.y + jitter * oy23;\n    vec3 dz23 = Pfz.z + jitter * oz23;\n    vec3 dx31 = Pfx + jitter * ox31;\n    vec3 dy31 = Pfy.z + jitter * oy31;\n    vec3 dz31 = Pfz.x + jitter * oz31;\n    vec3 dx32 = Pfx + jitter * ox32;\n    vec3 dy32 = Pfy.z + jitter * oy32;\n    vec3 dz32 = Pfz.y + jitter * oz32;\n    vec3 dx33 = Pfx + jitter * ox33;\n    vec3 dy33 = Pfy.z + jitter * oy33;\n    vec3 dz33 = Pfz.z + jitter * oz33;\n    vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n    vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n    vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n    vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n    vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n    vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n    vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n    vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n    vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n    // Sort out the two smallest distances (F1, F2)\n    // Do it right and sort out both F1 and F2\n    vec3 d1a = min(d11, d12);\n    d12 = max(d11, d12);\n    d11 = min(d1a, d13); // Smallest now not in d12 or d13\n    d13 = max(d1a, d13);\n    d12 = min(d12, d13); // 2nd smallest now not in d13\n    vec3 d2a = min(d21, d22);\n    d22 = max(d21, d22);\n    d21 = min(d2a, d23); // Smallest now not in d22 or d23\n    d23 = max(d2a, d23);\n    d22 = min(d22, d23); // 2nd smallest now not in d23\n    vec3 d3a = min(d31, d32);\n    d32 = max(d31, d32);\n    d31 = min(d3a, d33); // Smallest now not in d32 or d33\n    d33 = max(d3a, d33);\n    d32 = min(d32, d33); // 2nd smallest now not in d33\n    vec3 da = min(d11, d21);\n    d21 = max(d11, d21);\n    d11 = min(da, d31); // Smallest now in d11\n    d31 = max(da, d31); // 2nd smallest now not in d31\n    d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n    d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n    d12 = min(d12, d21); // 2nd smallest now not in d21\n    d12 = min(d12, d22); // nor in d22\n    d12 = min(d12, d31); // nor in d31\n    d12 = min(d12, d32); // nor in d32\n    d11.yz = min(d11.yz, d12.xy); // nor in d12.yz\n    d11.y = min(d11.y, d12.z); // Only two more to go\n    d11.y = min(d11.y, d11.z); // Done! (Phew!)\n    return sqrt(d11.xy); // F1, F2\n}\n\n   \nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                  -0.80,  0.36, -0.48,\n                  -0.60, -0.48,  0.64 );\n\n   \nfloat fbm_4r( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n    }\n\treturn a;\n}\n\nfloat fbm_4r( in vec3 x, mat3 rot)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = snoise(x);\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\n\nfloat fmb4_3x( in vec3 x)\n{\n    return fbm_4(x + vec3(fbm_4(x + vec3(fbm_4(x)))));\n}\n\nfloat fmb4r_3x( in vec3 x, mat3 rot)\n{\n    return fbm_4r(x + vec3(fbm_4r(x + vec3(fbm_4r(x, rot), rot), rot)));\n}\n\nfloat fmb4_3x( in vec3 x, vec3 offset)\n{\n    return fbm_4(x + offset + vec3(fbm_4(x + vec3(fbm_4(x)))));\n}\n\nfloat cellfbm( in vec2 x, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*x;\n    }\n\treturn a;\n}\n\nfloat cellfbmr( in vec2 x, mat2 rot, int n)\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<n; i++ )\n    {\n        float n = cellular(x).x;\n        a += b*n;\n        b *= s;\n        x = f*rot*x;\n    }\n\treturn a;\n}\n\n\n\n// RNG\nuint WangHash(uint n)\n{\n    // https://gist.github.com/badboy/6267743#hash-function-construction-principles\n    // Wang hash: this has the property that none of the outputs will\n    // collide with each other, which is important for the purposes of\n    // seeding a random number generator.  This was verified empirically\n    // by checking all 2^32 uints.\n    n = (n ^ 61u) ^ (n >> 16);\n    n *= 9u;\n    n = n ^ (n >> 4);\n    n *= 0x27d4eb2du;\n    n = n ^ (n >> 15);\n\n    return n;\n}\n\nuint NextState(uint state)\n{\n    state ^= state << 13;\n    state ^= state >> 17;\n    state ^= state << 5;\n    return state;\n}\n\nfloat NextFloat(float xmin, float xmax, inout uint state)\n{\n    state = NextState(state);\n    int n = int(state % 1000u);\n    float t = float(n) / 1000.;   \n    return mix(xmin, xmax, t);\n}\n\nvec2 NextVec2(vec2 rmin, vec2 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    return vec2(x, y);\n}\n\nvec3 NextVec3(vec3 rmin, vec3 rmax, inout uint state)\n{\n    float x = NextFloat(rmin.x, rmax.x, state);\n    float y = NextFloat(rmin.y, rmax.y, state);\n    float z = NextFloat(rmin.z, rmax.z, state);\n    return vec3(x, y, z);\n}\n\n\nvec3 vecX(float x)\n{\n    return vec3(x, 0.0, 0.0);\n}\nvec3 vecY(float y)\n{\n    return vec3(0.0, y, 0.0);\n}\nvec3 vecZ(float z)\n{\n    return vec3(0.0, 0.0, z);\n}\n\n// Quaternion multiplication.\n// http://mathworld.wolfram.com/Quaternion.html\nvec4 qmul(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n\n// Rotate a vector with a rotation quaternion.\n// http://mathworld.wolfram.com/Quaternion.html\nvec3 qmul(vec4 r, vec3 v)\n{\n    vec4 r_c = r * vec4(-1.0, -1.0, -1.0, 1.0);\n    return qmul(r, qmul(vec4(v, 0.0), r_c)).xyz;\n}\n\nvec4 qAxisAngleRotation(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s,c;\n\ts = sin(angle);\n    c = cos(angle);\n\treturn vec4(axis.x*s,axis.y*s,axis.z*s,c);\n}\n\nvec4 qInverse(vec4 q)\n{\n    vec4 x = q;\n    return vec4(1.0/(dot(x, x)) * x * vec4(-1.0, -1.0, -1.0, 1.0));\n}\n\nvec4 qLookAt(vec3 forward, vec3 up)\n{\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward, right));\n\n    float m00 = right.x;\n    float m01 = right.y;\n    float m02 = right.z;\n    float m10 = up.x;\n    float m11 = up.y;\n    float m12 = up.z;\n    float m20 = forward.x;\n    float m21 = forward.y;\n    float m22 = forward.z;\n\n    float num8 = (m00 + m11) + m22;\n    vec4 q = vec4(0., 0., 0., 1.);\n    if (num8 > 0.0)\n    {\n        float num = sqrt(num8 + 1.0);\n        q.w = num * 0.5;\n        num = 0.5 / num;\n        q.x = (m12 - m21) * num;\n        q.y = (m20 - m02) * num;\n        q.z = (m01 - m10) * num;\n        return q;\n    }\n\n    if ((m00 >= m11) && (m00 >= m22))\n    {\n        float num7 = sqrt(((1.0 + m00) - m11) - m22);\n        float num4 = 0.5 / num7;\n        q.x = 0.5 * num7;\n        q.y = (m01 + m10) * num4;\n        q.z = (m02 + m20) * num4;\n        q.w = (m12 - m21) * num4;\n        return q;\n    }\n\n    if (m11 > m22)\n    {\n        float num6 = sqrt(((1.0 + m11) - m00) - m22);\n        float num3 = 0.5 / num6;\n        q.x = (m10 + m01) * num3;\n        q.y = 0.5 * num6;\n        q.z = (m21 + m12) * num3;\n        q.w = (m20 - m02) * num3;\n        return q;\n    }\n\n    float num5 = sqrt(((1.0 + m22) - m00) - m11);\n    float num2 = 0.5 / num5;\n    q.x = (m20 + m02) * num2;\n    q.y = (m21 + m12) * num2;\n    q.z = 0.5 * num5;\n    q.w = (m01 - m10) * num2;\n    return q;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldcW2.jpg", "access": "api", "license": "mit", "functions": [[1813, 1813, 1851, 1851, 1967], [1969, 1969, 2002, 2002, 2047], [2050, 2050, 2078, 2078, 2122], [2124, 2124, 2158, 2158, 2296], [2298, 2298, 2321, 2321, 2546], [2548, 2548, 2572, 2572, 2726], [2729, 2729, 2826, 2826, 3226], [3230, 3230, 3265, 3265, 3807], [3809, 3809, 3860, 3860, 4041], [4043, 4043, 4070, 4070, 5073], [5075, 5075, 5187, 5275, 5497], [5499, 5499, 5613, 5700, 5971], [5975, 5975, 6025, 6067, 7427], [7429, 7429, 7452, 7452, 7553], [7555, 7555, 7612, 7673, 8921]], "test": "untested"}
{"id": "7t3fzs", "name": "UI Test 4", "author": "yasuo", "description": "sci-fi ui design experiment", "tags": ["ui", "cineshader"], "likes": 109, "viewed": 5944, "published": 3, "date": "1663507951", "time_retrieved": "2024-07-30T16:30:41.877578", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define seg_0 0\n#define seg_1 1\n#define seg_2 2\n#define seg_3 3\n#define seg_4 4\n#define seg_5 5\n#define seg_6 6\n#define seg_7 7\n#define seg_8 8\n#define seg_9 9\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat segBase(vec2 p){\n    vec2 prevP = p;\n    \n    float size = 0.02;\n    float padding = 0.05;\n\n    float w = padding*3.0;\n    float h = padding*5.0;\n\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.005;\n    float gridMask = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    \n    p = prevP;\n    float d = B(p,vec2(w*0.5,h*0.5));\n    float a = radians(45.0);\n    p.x = abs(p.x)-0.1;\n    p.y = abs(p.y)-0.05;\n    float d2 = dot(p,vec2(cos(a),sin(a)));\n    d = max(d2,d);\n    d = max(-gridMask,d);\n    return d;\n}\n\nfloat seg0(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg1(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    \n    p.x+=size*1.8;\n    p.y-=size*3.5;\n    mask = B(p,vec2(size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg2(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg3(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg4(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x+=size;\n    p.y+=0.08;\n    float mask = B(p,vec2(size*2.,size*2.0));\n    d = max(-mask,d);\n\n    p = prevP;\n    \n    p.y-=0.08;\n    mask = B(p,vec2(size,size*2.0));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg5(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg6(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg7(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    return d;\n}\n\n\nfloat seg8(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg9(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat drawFont(vec2 p, int char){\n    p*=2.0;\n    float d = 10.;\n    if(char == seg_0) {\n        d = seg0(p);\n    } else if(char == seg_1) {\n        d = seg1(p);\n    } else if(char == seg_2) {\n        d = seg2(p);\n    } else if(char == seg_3) {\n        d = seg3(p);\n    } else if(char == seg_4) {\n        d = seg4(p);\n    } else if(char == seg_5) {\n        d = seg5(p);\n    } else if(char == seg_6) {\n        d = seg6(p);\n    } else if(char == seg_7) {\n        d = seg7(p);\n    } else if(char == seg_8) {\n        d = seg8(p);\n    } else if(char == seg_9) {\n        d = seg9(p);\n    }\n    \n    return d;\n}\nfloat barCode(vec2 p){\n    p*=1.1;\n    vec2 prevP = p;\n    p.x+=iTime*0.5;\n    p*=15.0;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n\n    float n = Hash21(vec2(id.x))*5.;\n    \n    p.x = mod(p.x,0.2)-0.1;\n    float d = abs(p.x)-((0.01*n)+0.01);\n    \n    p = prevP;\n    d = max(abs(p.x)-0.15,d);\n    d = max(abs(p.y)-0.1,d);\n\n    float d2 = abs(B(p,vec2(0.16,0.11)))-0.001;\n    d2 = max(-(abs(p.x)-0.14),d2);\n    d2 = max(-(abs(p.y)-0.09),d2);\n\n    return min(d,d2);\n}\n\nfloat circleUI(vec2 p){\n    vec2 prevP = p;\n    float speed = 3.;\n    mat2 animRot = Rot(radians(iTime*speed)*30.0);\n    p*=animRot;\n    \n    p = DF(p,32.0);\n    p -= vec2(0.28);\n    \n    float d = B(p*Rot(radians(45.0)), vec2(0.002,0.02));\n    \n    p = prevP;\n    p*=animRot;\n    \n    float a = radians(130.);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(-130.);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    \n    p = prevP;\n    animRot = Rot(radians(iTime)*20.0);\n    p*=animRot;\n    \n    p = DF(p,24.0);\n    p -= vec2(0.19);\n    \n    float d2 = B(p*Rot(radians(45.0)), vec2(0.003,0.015));\n    \n    p = prevP;\n    p*=animRot;\n    \n    a = radians(137.5);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-137.5);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,d2);\n    \n\n    p = prevP;\n    animRot = Rot(-radians(iTime*speed)*25.0);\n    p*=animRot;\n    \n    p = DF(p,16.0);\n    p -= vec2(0.16);\n    \n    d2 = B(p*Rot(radians(45.0)), vec2(0.003,0.01));\n    \n    p = prevP;\n    p*=animRot;\n    \n    a = radians(25.5);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-25.5);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,d2);\n    \n    \n    p = prevP;\n    animRot = Rot(radians(iTime*speed)*35.0);\n    p*=animRot;\n    \n    p = DF(p,8.0);\n    p -= vec2(0.23);\n    \n    d2 = B(p*Rot(radians(45.0)), vec2(0.02,0.02));\n    \n    p = prevP;\n    p*=animRot;\n    \n    a = radians(40.0);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-40.0);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    \n    d = min(d,d2);    \n    \n    \n    p = prevP;\n    \n    animRot = Rot(radians(iTime*speed)*15.0);\n    p*=animRot;\n    \n    d2 = abs(length(p)-0.36)-0.002;\n    d2 = max(abs(p.x)-0.2,d2);\n    d = min(d,d2);    \n    \n    p = prevP;\n    \n    animRot = Rot(radians(90.)+radians(iTime*speed)*38.0);\n    p*=animRot;\n    \n    d2 = abs(length(p)-0.245)-0.002;\n    d2 = max(abs(p.x)-0.1,d2);\n    d = min(d,d2);    \n    \n    p = prevP;\n    d2 = abs(length(p)-0.18)-0.001;\n    d = min(d,d2);       \n    \n    p = prevP;\n    animRot = Rot(radians(145.)+radians(iTime*speed)*32.0);\n    p*=animRot;\n    d2 = abs(length(p)-0.18)-0.008;\n    \n    a = radians(30.0);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-30.0);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);    \n    \n    d = min(d,d2);  \n    \n    p = prevP;\n    \n    a = radians(iTime*speed)*30.0;\n    p.x+=cos(a)*0.45;\n    p.y+=sin(a)*0.45;\n    \n    d2 = Tri(p*Rot(-a)*Rot(radians(90.0)),vec2(0.02),radians(45.));\n    d = min(d,d2);  \n    \n    p = prevP;\n    \n    a = radians(-sin(iTime*speed*0.5))*120.0;\n    a+=radians(-70.);\n    p.x+=cos(a)*0.45;\n    p.y+=sin(a)*0.45;\n    \n    d2 = abs(Tri(p*Rot(-a)*Rot(radians(90.0)),vec2(0.02),radians(45.)))-0.001;\n    d = min(d,d2);      \n    \n    p = prevP;\n    animRot = Rot(-radians(iTime*speed)*27.0);\n    p*=animRot;\n    \n    d2 = abs(length(p)-0.43)-0.0001;\n    d2 = max(abs(p.x)-0.3,d2);\n    d = min(d,d2);    \n    \n    p = prevP;\n    animRot = Rot(-radians(iTime*speed)*12.0);\n    p*=animRot;\n    \n    p = DF(p,8.0);\n    p -= vec2(0.103);\n    \n    d2 = B(p*Rot(radians(45.0)), vec2(0.001,0.007));    \n    d = min(d,d2);  \n    \n    p = prevP;\n    animRot = Rot(radians(16.8)-radians(iTime*speed)*12.0);\n    p*=animRot;    \n    \n    p = DF(p,8.0);\n    p -= vec2(0.098);\n    \n    d2 = B(p*Rot(radians(45.0)), vec2(0.001,0.013));    \n    d = min(d,d2);      \n    \n    \n    p = prevP;\n    animRot = Rot(radians(iTime*speed)*30.0);\n    p*=animRot;    \n    \n    p = DF(p,10.0);\n    p -= vec2(0.28);\n    \n    d2 = abs(B(p*Rot(radians(45.0)), vec2(0.02,0.02)))-0.001;\n    \n    p = prevP;\n    p*=animRot;\n    \n    a = radians(50.);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-50.);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);    \n    d = min(d,d2);   \n    \n    p = prevP;\n    int num = int(mod(iTime*10.0,10.0));\n    d2 = drawFont(p-vec2(0.038,0.),num);\n    d = min(d,abs(d2)-0.001); \n    num = int(mod(iTime*3.0,10.0));\n    d2 = drawFont(p-vec2(-0.038,0.),num);\n    d = min(d,d2); \n    \n    return d;\n}\n\nfloat smallCircleUI(vec2 p){\n    p*=1.3;\n    vec2 prevP = p;\n    float speed = 3.;\n    \n    mat2 animRot = Rot(radians(iTime*speed)*35.0);\n    p*=animRot;  \n    \n    float d = abs(length(p)-0.2)-0.005;\n    \n    float a = radians(50.);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(-50.);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);   \n    \n    p*=Rot(radians(10.));\n    float d2 = abs(length(p)-0.19)-0.006;\n    \n    a = radians(60.);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-60.);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);   \n    \n    d = min(d,d2);\n    \n    p = prevP;\n    \n    d2 = abs(length(p)-0.195)-0.0001;\n    d = min(d,d2);\n    \n    \n    p = prevP;\n    animRot = Rot(-radians(iTime*speed)*30.0);\n    p*=animRot;      \n    \n    p = DF(p,12.0);\n    p -= vec2(0.11);\n    \n    d2 = B(p*Rot(radians(45.0)), vec2(0.003,0.015));      \n    \n\n    \n    d = min(d,d2);  \n    \n    p = prevP;\n    animRot = Rot(radians(iTime*speed)*23.0);\n    p*=animRot;  \n    p = DF(p,2.5);\n    p -= vec2(0.05);\n    \n    d2 = B(p*Rot(radians(45.0)), vec2(0.01));      \n    d = min(d,d2); \n    \n    p = prevP;\n    animRot = Rot(-radians(iTime*speed)*26.0);\n    p*=animRot;  \n    d2 = abs(length(p)-0.11)-0.005;\n    \n    d2 = max(abs(p.x)-0.05,d2);\n    \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat smallCircleUI2(vec2 p){\n    p.x = abs(p.x)-0.4;\n    p.y = abs(p.y)-0.34;\n    vec2 prevP = p;\n    float speed = 3.;\n    mat2 animRot = Rot(radians(iTime*speed)*28.0);\n    p*=animRot;  \n    \n    float d = abs(length(p)-0.028)-0.0005;\n    d = max(B(p,vec2(0.015,0.1)),d);\n    \n    p = prevP;\n    animRot = Rot(-radians(iTime*speed)*31.0);\n    p*=animRot;  \n    float d2 = abs(length(p)-0.027)-0.004;\n    \n    float a = radians(50.);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-50.);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);    \n    \n    d = min(max(-d2,d),abs(d2)-0.001);\n    \n    p = prevP;\n    animRot = Rot(-radians(iTime*speed)*30.0);\n    p*=animRot;      \n    \n    p = DF(p,2.0);\n    p -= vec2(0.008);\n    \n    d2 = B(p*Rot(radians(45.0)), vec2(0.0005,0.002));       \n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat mainWave(vec2 p){\n    p*=1.5;\n    \n    float thickness = 0.003;\n    \n    vec2 prevP = p;\n\n    float t = fract(sin(iTime*100.0))*0.5;\n\n    p.x+=iTime*1.0;\n    p.y+=sin(p.x*8.)*(0.05+abs(sin(t*10.0)*0.12));\n    float d = abs(p.y)-thickness;\n\n    p = prevP;\n    \n    p.x-=iTime*0.5;\n    p.y+=sin(p.x*3.)*(0.1+abs(sin(t*9.0)*0.13));\n    float d2 = abs(p.y)-thickness;\n\n    d = min(d,d2);\n\n    p = prevP;\n    \n    p.x+=iTime*0.7;\n    p.y+=sin(p.x*5.)*(0.1+abs(sin(t*9.3)*0.15));\n    d2 = abs(p.y)-thickness;\n\n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p.x-=iTime*0.6;\n    p.y+=sin(p.x*10.)*(0.1+abs(sin(t*9.5)*0.08));\n    d2 = abs(p.y)-thickness;\n\n    d = min(d,d2);\n        \n    p = prevP;\n    \n    p.x+=iTime*1.2;\n    p.y+=cos(-p.x*15.)*(0.1+abs(sin(t*10.0)*0.1));\n    d2 = abs(p.y)-thickness;\n\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat graph(vec2 p){\n    vec2 prevP = p;\n    float d = 10.;\n    float t = iTime+Hash21(vec2(floor(p.y-0.5),0.0));\n    p.y = abs(p.y);\n    p.y+=0.127;\n    for(float i = 1.0; i<=20.0; i+=1.0) {\n        float x = 0.0;\n        float y = i*-0.015;\n        float w = abs(sin(Hash21(vec2(i,0.0))*t*3.0)*0.1);\n        float d2 = B(p+vec2(0.1-w,y),vec2(w,0.003));\n        d = min(d,d2);\n    }\n    p = prevP;\n    \n    return max(abs(p.y)-0.2,d);\n}\n\nfloat scifiUI(vec2 p){\n    p*=1.1;\n    vec2 prevP = p;\n    float d = B(p,vec2(0.15,0.06));\n    float a = radians(45.);\n    p.x = abs(p.x)-0.195;\n    p.y = abs(p.y);\n    float m = dot(p,vec2(cos(a),sin(a)));\n    d = max(m,d);\n    \n    p = prevP;\n    \n    p.x+=0.16;\n    p.y+=0.008;\n    float d2 = B(p,vec2(0.06,0.052));\n    a = radians(45.);\n    p.x = abs(p.x)-0.095;\n    p.y = abs(p.y);\n    m = dot(p,vec2(cos(a),sin(a)));\n    d2 = max(m,d2);\n    \n    p = prevP;\n    d2 = min(d,d2);\n    d2 = max(-B(p-vec2(-0.03,-0.05),vec2(0.2,0.05)),abs(d2)-0.003);\n    \n    return abs(d2)-0.001;\n}\n\nfloat triAnimatin(vec2 p){\n    p.x = abs(p.x)-0.458;\n    p.y = abs(p.y)-0.45;\n    vec2 prevP = p;\n    p.x+=iTime*0.1;\n    p.x=mod(p.x,0.04)-0.02;\n    p.x+=0.01;\n    float d = abs(Tri(p*Rot(radians(-90.)),vec2(0.012),radians(45.)))-0.0001;\n    p = prevP;\n    return max(abs(p.x)-0.125,d);\n}\n\nfloat randomDotLine(vec2 p){\n    vec2 prevP = p;\n    p.x+=iTime*0.08;\n    vec2 gv = fract(p*17.0)-0.5;\n    vec2 id = floor(p*17.0);\n    \n    float n = Hash21(id);\n    float d = B(gv,vec2(0.25*(n*2.0),0.2));\n    p = prevP;\n    p.y+= 0.012;\n    d = max(abs(p.y)-0.01,max(abs(p.x)-0.27,d));\n    return d;\n}\n\nfloat scifiUI2(vec2 p){\n    vec2 prevP = p;\n\n    p*=1.2;\n    p.x= abs(p.x)-0.72;\n    p.y= abs(p.y)-0.53;\n    \n    float d = B(p,vec2(0.03));\n    float a = radians(-45.);\n    \n    float m = -dot(p-vec2(-0.005,0.0),vec2(cos(a),sin(a)));\n    d = max(m,d);\n    m = dot(p-vec2(0.005,0.0),vec2(cos(a),sin(a)));\n    d = max(m,d);\n    \n    float d2 = B(p-vec2(0.175,0.0256),vec2(0.15,0.004));\n    d = min(d,d2);\n    d2 = B(p-vec2(-0.175,-0.0256),vec2(0.15,0.004));\n    d = abs(min(d,d2))-0.0005;\n    \n    p.y-=0.003;\n    p.x+=iTime*0.05;\n    p.x = mod(p.x,0.03)-0.015;\n    p.x-=0.01;\n    d2 = B(p,vec2(0.026));\n    \n    m = -dot(p-vec2(-0.005,0.0),vec2(cos(a),sin(a)));\n    d2 = max(m,d2);\n    m = dot(p-vec2(0.005,0.0),vec2(cos(a),sin(a)));\n    d2 = max(m,d2);\n    \n    p = prevP;\n    p*=1.2;\n    p.x= abs(p.x)-0.72;\n    p.y= abs(p.y)-0.53;\n    m = -dot(p-vec2(0.02,0.0),vec2(cos(a),sin(a)));\n    d2 = max(m,d2);\n    m = dot(p-vec2(0.32,0.0),vec2(cos(a),sin(a)));\n    d2 = max(m,d2);\n    \n    d = min(d,d2);\n    \n    p = prevP;\n    \n    d2 = triAnimatin(p);\n    d = min(d,d2);\n    \n    \n    p = prevP;\n    p.x= abs(p.x)-0.6;\n    p.y= abs(p.y)-0.418;\n    \n    d2 = randomDotLine(p);\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat scifiUI3Base(vec2 p){\n    float d = abs(length(p)-0.03)-0.01;\n    p.x=abs(p.x)-0.1;\n    float d2 = abs(length(p)-0.03)-0.01;\n    d = min(d,d2);\n    return d;\n}\n\nfloat scifiUI3(vec2 p){\n    vec2 prevP = p;\n    float speed = 3.;\n    float d = abs(length(p)-0.03)-0.01;\n    \n    mat2 animRot = Rot(radians(iTime*speed)*40.0);\n    p*=animRot;  \n    \n    float a = radians(50.);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);\n    a = radians(-50.);\n    d = max(dot(p,vec2(cos(a),sin(a))),d);   \n    \n    p = prevP;\n    p.x=abs(p.x)-0.1;\n    animRot = Rot(radians(iTime*speed)*45.0);\n    p*=animRot;  \n    \n    \n    float d2 = abs(length(p)-0.03)-0.01;\n    \n    a = radians(170.);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);\n    a = radians(-170.);\n    d2 = max(dot(p,vec2(cos(a),sin(a))),d2);   \n    \n    return min(d,d2);\n}\n\nfloat slider(vec2 p){\n    vec2 prevP = p;\n    \n    float d = abs(B(p,vec2(0.15,0.015)))-0.001;\n    float d2 = B(p-vec2(sin(iTime*1.5)*0.13,0),vec2(0.02,0.013));\n    d = min(d,d2);\n    \n    p.y = abs(p.y)-0.045;\n    d2 = abs(B(p,vec2(0.15,0.015)))-0.001;\n    d = min(d,d2);\n    d2 = B(p-vec2(sin(iTime*2.0)*-0.13,0),vec2(0.02,0.013));\n    d = min(d,d2);\n    \n    p = prevP;\n    p.y=abs(p.y);\n    d2 = scifiUI(p-vec2(0.032,0.045));\n    d = min(d,d2);\n    \n    return d;\n}\n\nfloat bg(vec2 p){\n    p = mod(p,0.3)-0.15;\n    float d = B(p,vec2(0.001,0.01));\n    float d2 = B(p,vec2(0.01,0.001));\n    d = min(d,d2);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col =vec3(0.0);\n    float d = bg(uv);\n    col = mix(col, vec3(0.3),S(d,0.0));\n    \n    d = mainWave(uv);\n    col = mix(col, vec3(1.),S(d,-0.005));\n    \n    d = scifiUI2(uv);\n    \n    float d2 = circleUI(uv);\n    d = min(d,d2);\n\n    d2 = smallCircleUI(uv-vec2(-0.62,-0.22));\n    d = min(d,d2);\n    \n    d2 = smallCircleUI2(uv);\n    d = min(d,d2);\n    \n    d2 = graph(uv-vec2(-0.67,0.19));\n    d = min(d,d2);\n    \n    d2 = barCode(uv-vec2(0.63,-0.27));\n    d = min(d,d2);\n    \n    d2 = slider(uv-vec2(0.62,0.26));\n    d = min(d,d2);\n    \n    col = mix(col, vec3(1.),S(d,0.0));\n    \n    d = scifiUI3Base(uv-vec2(0.65,0.));\n    col = mix(col, col+vec3(0.5),S(d,0.0));\n    \n    d = scifiUI3(uv-vec2(0.65,0.));\n    col = mix(col, vec3(1.),S(d,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound( in int samp,float time) {\n    float t = fract(sin(time*100.0))*0.1;\n    vec2 result = vec2(sin(float(samp)*2.5*t));\n    float volume = 0.01;    \n    return result*volume;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3fzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[603, 603, 625, 625, 715], [717, 717, 739, 739, 1230], [1232, 1232, 1251, 1251, 1401], [1403, 1403, 1422, 1422, 1723], [1725, 1725, 1744, 1744, 2032], [2034, 2034, 2053, 2053, 2343], [2345, 2345, 2364, 2364, 2652], [2654, 2654, 2673, 2673, 2961], [2963, 2963, 2982, 2982, 3252], [3254, 3254, 3273, 3273, 3456], [3459, 3459, 3478, 3478, 3664], [3666, 3666, 3685, 3685, 3955], [3957, 3957, 3990, 3990, 4561], [4562, 4562, 4584, 4584, 5035], [5037, 5037, 5060, 5060, 9125], [9127, 9127, 9155, 9155, 10435], [10437, 10437, 10466, 10466, 11274], [11276, 11276, 11299, 11299, 12118], [12120, 12120, 12140, 12140, 12557], [12559, 12559, 12581, 12581, 13142], [13144, 13144, 13170, 13170, 13433], [13435, 13435, 13463, 13463, 13738], [13740, 13740, 13763, 13763, 14954], [14956, 14956, 14983, 14983, 15121], [15123, 15123, 15146, 15146, 15778], [15780, 15780, 15801, 15801, 16249], [16251, 16251, 16268, 16268, 16403], [16405, 16405, 16462, 16462, 17314]], "test": "untested"}
{"id": "ftcfzl", "name": "012 - ShaderToy App State", "author": "PiGIon", "description": "I wanted to test application state in ShaderToy, control the circle with arrow keys.", "tags": ["beginner", "keyboard", "state", "buffer", "ichannel"], "likes": 1, "viewed": 193, "published": 3, "date": "1663471966", "time_retrieved": "2024-07-30T16:30:42.667467", "image_code": "// 2022.09.17\n\nfloat antiAlias;\n\nvec4 circle(vec2 uv, vec2 origin, float size, vec3 col) {\n    return vec4(col, smoothstep(size + antiAlias, size - antiAlias, length(uv - origin)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    antiAlias = 1.5/iResolution.y;\n    \n    vec3 col;\n    \n    vec4 s = texture(iChannel0, vec2(0.));\n\n    vec3 bg = vec3(1.);\n    vec4 c = circle(uv, s.xy, 0.25, s.rgr);\n    \n    col = mix(bg, c.rgb, c.a);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\n#define SPEED 1.\n\nfloat key(int keyCode) {\n    return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 O;\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    if (iFrame == 0) {\n        O = vec4(0.0);\n    } else {\n        vec4 s = vec4(\n            key(KEY_RIGHT) - key(KEY_LEFT),\n            key(KEY_UP) - key(KEY_DOWN),\n            0., 0.\n        ) * SPEED * iTimeDelta;\n        \n        O = texture(iChannel0, vec2(0.)) + s;\n    }\n    \n    fragColor = O;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcfzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 90, 90, 183], [185, 185, 242, 242, 553]], "test": "untested"}
{"id": "NtcBzX", "name": "Candy Mixer", "author": "fenix", "description": "Same particle system as the Dream Mixer, but with a candy-flavored rendering style. Can you tell from the color scheme what kind of candies these are supposed to be?\n*mouse to grab/spin the mixer*\n*space to reset* \n*shift to render neighbors*", "tags": ["2d", "voronoi", "simulation", "particles", "bubble", "britney", "dynamics"], "likes": 43, "viewed": 1165, "published": 3, "date": "1663458062", "time_retrieved": "2024-07-30T16:30:43.594987", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Dentists, avert your eyes!  A new rendering method combined with nearly the same\n//  particle system as Dream Mixer. https://www.shadertoy.com/view/7ttBzH\n//\n//  In case it's not obvious, I should mention that you can \"throw\" the mixer with the mouse\n//  to impart some velocity (which will eventually damp out to the default clockwise spin).\n//\n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a voronoi search to help out building neighborhoods\n//\n// ---------------------------------------------------------------------------------------\n\nconst vec3 lightDir = normalize(vec3(1,-1,1));\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = sqrt(linePointDist2(p.pos, p.pos - p.vel, fragCoord, iResolution, closest));\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n\n    float wd =  2./(min(iResolution.x, iResolution.y));\n    \n    float drawSize = min(PARTICLE_REPEL_SIZE, p.size);\n    \n    vec3 norm = normalize(vec3(p.pos-fragCoord, drawSize));\n    float diffuse = dot(lightDir, norm)*0.7 + 0.3;\n    \n    vec3 reflection = reflect(lightDir, norm);\n    float spec = -reflection.z;\n    spec = spec > 0. ? pow(abs(spec), 15.0) : 0.;\n\n    fragColor.xyz = mix(fragColor.xyz, p.color * diffuse + spec, 1.-smoothstep(drawSize - wd, drawSize + wd, dist));\n    \n    // Render neighbor lines\n    if (keyDown(KEY_SHIFT))\n    {\n        for(int i = 0; i < 4; i++){\n            ivec4 neighbors = p.neighbors[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                int cid = neighbors[j];\n                if(cid==-1 || cid >= maxParticles || cid == 0) continue;\n\n                vec2 otherPos = fxGetParticleData(cid, POS_VEL).xy;\n                otherPos.x *= iResolution.y / iResolution.x;\n\n                float distToLin = linePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution, closest);\n                fragColor.xyz += iResolution.x* max(0.0, 0.001 - sqrt(distToLin)) / (0.0004);\n            }\n        }\n    }\n}\n\nfloat computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.25); // change pow for modifying the extend of the  vignette\n    //fragColor = vec4(vig*.1, vig*.1, vig, 1);\n    fragColor = vec4(0);\n    \n  \tvec2 p = fragCoord/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n\n    //draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n    \n    fxState state = fxGetState();\n    vec2 steelCoord = vec2(fragCoord.x * 2.0, (fragCoord.y) * 0.004);\n    vec2 adjusted = (p - 0.5) * vec2(iResolution.x / iResolution.y, 1.);\n    if (length(adjusted) < 0.5/1.2 + 0.02)\n    {\n        float a = atan(adjusted.y, adjusted.x) + state.rotation;\n        steelCoord = vec2(a*400., length(adjusted)*20.);\n    }\n    \n    float wallDist = distanceFromWalls(p * vec2(iResolution.x / iResolution.y, 1.), iResolution, state.rotation);\n    \n    vec3 steelNorm = texture(iChannel2, steelCoord/iResolution.xy).xyz;\n    steelNorm.xz += getNormalFromWalls(p * vec2(iResolution.x / iResolution.y, 1.), iResolution, state.rotation) * (1.0 - smoothstep(0.007, 0.01, -wallDist));\n\n    steelNorm = normalize(steelNorm);\n    float steelSpec = computeSpecular(0.8, 15.0, steelNorm, lightDir, vec3(0.0, 1.75-p.x, 0.5 - p.y));\n    vec4 steel = vec4(vec3(steelSpec), 1.0) * 0.4 + 0.2;\n\n    fragColor = sqrt(mix(fragColor, steel, vec4(clamp(-wallDist*iResolution.y, 0.0, 1.0))));\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 1000; \nconst float PARTICLE_REPEL_SIZE = 0.01;\n\nconst float PI = 3.141592653589793;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return p * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution);\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 1e-10)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.x, sc.y, sc.y, -sc.x);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    vec2 c = (point - vec2(.5*resolution.x/resolution.y,  .5))*1.2;\n    float minDist = 1e30;\n    minDist = min(minDist, .5 - length(c));\n    const int NUM_PADDLES = 10;\n    for (int i = 0; i < NUM_PADDLES; ++i)\n    {\n        minDist = min(minDist, sdBox((rot2(time + float(i) *2.* PI / float(NUM_PADDLES))*c + vec2(0.0, 0.5)), vec2(0.01, 0.1)));\n    }\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define SIZE 5\n#define COLOR 6\n#define NUM_PARTICLE_DATA_TYPES 7\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    float size;\n    float closestDist;\n    vec3 color;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, SIZE), 0);\n    vec4 particleData6 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, COLOR), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.size = particleData5.x;\n    particle.closestDist = particleData5.y;\n    particle.color = particleData6.xyz;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case SIZE:\n        return vec4(p.size, p.closestDist, 0, 0);\n    case COLOR:\n        return vec4(p.color, 0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nstruct fxState\n{\n    float resolution;\n    float rotation;\n    float velocity;\n    float mouse;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    fxState state;\n    state.resolution = data.x;\n    state.rotation = data.y;\n    state.velocity = data.z;\n    state.mouse = data.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state)\n{\n    return vec4(state.resolution, state.rotation, state.velocity, state.mouse);\n}\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_P 80\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n", "buffer_a_code": "const vec2 GRAVITY = vec2(0.0000, -0.00001);\nconst float PARTICLE_REPEL = 0.0000002;\nconst float VISCOSITY = 0.0000001;\nconst float COLLISION_BOUNCE = 0.5;\nconst float POSITION_CORRECTION = 0.2;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\n#define RGB(R, G, B) vec3(float(R), float(G), float(B)) / 255.0\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    if (id == 0) return;\n    \n    fxParticle data = fxGetParticle(id);\n    fxState state = fxGetState();\n    \n    if (dataType >= POS_VEL)\n    {\n        if (iFrame == 0 || state.resolution < 0.)\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = (vec2((i + 0.5*(mod(j, 2.0))) / particlesPerRow, j / particlesPerRow) * vec2(0.4, 0.6) + vec2(0.3, 0.2)) * vec2(iResolution.x / iResolution.y, 1.0);\n            data.vel = vec2(0);\n            data.size = 1e6;\n                        \n            switch(int(5.* i / particlesPerRow))\n            {\n                case 0: data.color = RGB(255,46,0); break;\n                case 1: data.color = RGB(221,150,2); break;\n                case 2: data.color = RGB(4,150,7); break;\n                case 3: data.color = RGB(48,11,53); break;\n                case 4: data.color = RGB(140,4,12); break;           \n            }\n         }\n        else\n        {\n            vec2 force = GRAVITY;\n            float minDist = 1e6;\n            float minCirc = 1e6;\n\n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    fxParticle n = fxGetParticle(cid);\n                    \n                    vec2 deltaPos = data.pos - n.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    vec2 dir = deltaPos / dist;\n \n                    // Absorb some velocity from nearby particles\n                    force += VISCOSITY * n.vel / square(dist);\n\n                    // Apply SPH attract/repel force\n                    force -= PARTICLE_REPEL * dir * SPHgradKernel(dist / (20.*PARTICLE_REPEL_SIZE));\n\n                    // Repel small neighbors (restores density)\n                    if (data.size < PARTICLE_REPEL_SIZE*.8 && n.size < data.size && n.size > 1e-6 && data.size > 1e-6 && iFrame > 10)\n                    {\n                        force += 9.*(PARTICLE_REPEL_SIZE - data.size) * dir * (data.size - n.size);\n                    }\n                    \n                    // Collide with neighbor\n                    if (dist < PARTICLE_REPEL_SIZE * 2.)\n                    {\n                        data.pos -= dir * (dist - PARTICLE_REPEL_SIZE * 2.) * POSITION_CORRECTION;\n                        float normalVel = dot(dir, data.vel - n.vel);\n                        if (normalVel < 0.)\n                        {\n                            data.vel -= COLLISION_BOUNCE * dir * normalVel;\n                        }\n                    }\n\n                    // Record some data for size computation\n                    minDist = min(minDist, dist*0.5);\n                    minCirc = min(minCirc, max(dist*0.5, 0.5*(dist - n.size)));\n                }\n            }       \n \n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Record computed size\n            data.closestDist = minDist;\n            data.size = minCirc;\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, state.rotation);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, state.rotation - state.velocity);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, state.rotation);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= 1.5 * distNormal * min(0., dot(distNormal, data.vel));\n                data.vel += 0.0005 * distNormal;\n            }\n            \n            // Damping\n            data.vel -= data.vel * 0.01;\n\n            // Clamping\n            float maxSpeed = 0.05; // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos * vec2(iResolution.y / iResolution.x, 1.0))));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(data.neighbors[0][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[1][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[2][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[3][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            //int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n            //pick random id of particle\n            int p = int(mod(h*34534.0, float(MAX_PARTICLES)));\n            sort0(bestIds, bestDists, id, int(p), dataType, data.pos);  //sort this\n        }\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 || id >= MAX_PARTICLES ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    if (iFragCoord == ivec2(0))\n    {\n        fxState state = fxGetState();\n        \n        if (iFrame == 0 || iResolution.x * iResolution.y != abs(state.resolution) || keyDown(KEY_SPACE))\n        {\n            state.resolution = -iResolution.x * iResolution.y;\n            state.velocity = state.rotation = 0.0;\n        }\n        else\n        {\n            state.resolution = abs(state.resolution);\n            \n            // Apply acceleration and damping\n            state.velocity += 0.0001;\n            state.velocity *= 0.97;\n            \n            // Handle mouse input\n            if (iMouse.z > 0.)\n            {\n                if (iMouse.w > 0.)\n                {\n                    state.velocity = 0.;\n                    state.mouse = iMouse.x + iMouse.y;\n                }\n                else\n                {\n                    state.velocity = clamp((state.mouse - iMouse.x - iMouse.y) / iResolution.x, -0.1, 0.1);\n                    state.mouse = iMouse.x + iMouse.y;\n                }\n            }\n            \n            // Integrate rotation\n            state.rotation += state.velocity;\n        }\n        \n        fragColor = fxPutState(state);\n        return;\n    }\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n    \n    ivec4 old   = fxGetClosest( iFragCoord );      \n\n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, screen2world(fragCoord));\n        insertion_sort( new, dis, id, dis2 );\n    }\n    \n    // Search randomly in the nearest 15x15 neighbors instead of just\n    // the next-door neighbors. Seems to allow faster particle movement\n    uint searchRange = 15u;\n    uint searchCount = 16u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, screen2world(fragCoord));\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++)\n    {\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcBzX.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[831, 831, 910, 910, 2359], [2361, 2361, 2524, 2524, 2729], [2731, 2731, 2785, 2878, 4663]], "test": "untested"}
{"id": "st3fRf", "name": "Lightning Shader (v1)", "author": "W_Master", "description": "Simple lightning effect created with segments. Unfortunately has noticable artifacts when paused, or with lesser segments, or high amplitude. Can still look nice at times :)", "tags": ["2d", "lightning", "noise2d"], "likes": 10, "viewed": 533, "published": 3, "date": "1663440213", "time_retrieved": "2024-07-30T16:30:44.346976", "image_code": "// Created by Walter Jansen (2022-09-17)\n\n#define SPEED 0.45\n#define MUTATION_RATE 1.5\n#define SEGMENTS 100.0\n#define AMPLITUDE 0.2\n\nfloat segDist(vec2 a, vec2 b, vec2 p)\n{\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float h = dot(ab,ap)/dot(ab,ab);\n    h = clamp(h,0.0,1.0);\n    return (length(a + ab * h - p));\n}\n\nvec2 height(float v, float amp)\n{\n    float h = noise(vec2(v * 0.2, 1.2 + iTime * (MUTATION_RATE))) * 0.4 * amp;\n    return (vec2(v, h));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float amp = (AMPLITUDE) * smoothstep(0.5, 0.2, abs(uv.x-0.5));\n    uv.x *= iResolution.x/iResolution.y;\n    uv.y -= 0.5;\n    \n    float len = SEGMENTS;\n    uv.x *= len;\n    \n    vec2 pos;\n    float move = iTime * -(SPEED) * len;\n    \n    pos.x = uv.x + move;\n    pos.x = floor(pos.x) + 0.5;\n    pos = height(pos.x, amp);\n    vec2 post = height(pos.x + 1.0, amp);\n    vec2 pre  = height(pos.x - 1.0, amp);\n    \n    pos.x -= move;\n    post.x -= move;\n    pre.x -= move;\n    \n    float c = min(segDist(pos, post, uv), segDist(pos, pre, uv));\n    c = (0.007/c) * smoothstep(0.3,0.0,c);\n    \n    vec3 col = vec3(1.7,0.5, 1.7) * c;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// -----------------------------------------------", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3fRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 172, 172, 316], [318, 318, 351, 351, 457], [459, 459, 516, 516, 1219]], "test": "untested"}
{"id": "NlcBRf", "name": "Damasdi tiling ( 661 chars )", "author": "FabriceNeyret2", "description": "golfed variant of [url]https://shadertoy.com/view/stcBRj[/url]\nreference: [url]https://twitter.com/pickover/status/1567297600281362433[/url] based on a unique quadrangle tile.\n", "tags": ["tiling", "short", "golf", "reproduction", "truchets"], "likes": 26, "viewed": 322, "published": 3, "date": "1663401588", "time_retrieved": "2024-07-30T16:30:45.086997", "image_code": "// golfed variant of https://shadertoy.com/view/stcBRj\n\n#define L     length          \n#define r(a)  mat2(cos(a+vec4(0,q,-q,0)))              // rotation\n#define R(a)  U = L(I)*4./R.y * cos( mod( atan(I.y,I.x) +  a/2. , a ) -  a/2. + vec2(0,q) ) // rotational symmetry(a)\n#define s(v)  smoothstep(-12./R.y, 0., v )             // AA draw\n\n// --- shuttle tile( center, angle, diagonal sign ) = equilateral tri + square + equilateral tri \n#define S(b,w)                                                                         \\\n    V  = abs( Q = U*r(b) - P*r(a) );                                                   \\\n    d  = min(.5 - V.y, .683 - .5*V.x-.866*V.y );                                       \\\n    O = max(O, s(d)                                             /* mask */             \\\n             *( 1.-s( min( L(V-.5), L(V-vec2(1.366,0)) ) -.33 ) /* dots */             \\\n                  +s( min( L(Q-vec2(1,w 1)), L(Q+vec2(1,w 1)) ) -1.3 ) *step(V.x,.5) ) ) /* diagonal bar */\n\nvoid mainImage( out vec4 O, vec2 u ) {\n    O-=O; \n    float d,a, q = 1.57;\n    vec2  R = iResolution.xy, V, D,T, Q, I =  u+u - R,\n    R(1.047),                                             // --- 6-symmetry\n    P = vec2(1.366,0);  \n    S(,);                                                 // central flower\n    a = q, S(a,-);                                        \n    a = .5236, R(a);                                      // --- 12 symmetry\n    mat2 M=r(a); D=M[0],T=M[1]; P.x+=.79, P += .79*T; \n    S(a,);  S(a+a,);                                      // 1st crown\n    P += D = 1.866*D - .5*T;                              // 2nd crown\n               S(a ,-); S(,-); \n    P += T;    S(a ,-);\n    P += D;    S(a ,-); S(,-);                            // 3rd crown\n    P += T;    S(a , );\n    P -= T+T;  S(a , ); S(, ); \n    O = sqrt(O);                                          // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "fl3fRf", "name": "Rainbow circle 71", "author": "Ivang", "description": "A simple circle with changing color", "tags": ["2d"], "likes": 1, "viewed": 152, "published": 3, "date": "1663400131", "time_retrieved": "2024-07-30T16:30:45.829013", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat circleShape(float radius, vec2 position) {\n\tfloat value = distance(position, vec2(0.5));\n\treturn 1. - step(radius, value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float circleWidth = 0.2;\n    float circle = circleShape(circleWidth, uv);\n    vec3 circleCol = vec3(circle);\n    vec3 color;\n    if (circleCol == vec3(0)) {\n        color = vec3(0);\n    } else {\n        color = 0.5 + 0.5 * sin(iTime * circleCol + vec3(0,2,4));\n    }\n\n    // Output to screen\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3fRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 94, 94, 176], [178, 178, 235, 235, 610]], "test": "untested"}
{"id": "fttfDn", "name": "Fork glowingMar TestCoder 972", "author": "TestCoder", "description": "https://twitter.com/nasana_x", "tags": ["cineshader"], "likes": 6, "viewed": 2484, "published": 3, "date": "1663397593", "time_retrieved": "2024-07-30T16:30:46.573024", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv =  (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float inverseSpeed = 15.;\n    float LOD = 50.0;\n    for(float i = 1.0; i < LOD; i++){\n        uv.x += 0.6 / i * cos(i * 2.5* uv.y + iTime/inverseSpeed);\n        uv.y += 0.6 / i * cos(i * 1.5 * uv.x + iTime/inverseSpeed);\n    }\n    \n    float intensity = .8;\n    \n    fragColor = vec4(vec3(intensity)/abs(sin(iTime/inverseSpeed-uv.y-uv.x)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 495]], "test": "untested"}
{"id": "NlcfzX", "name": "Radial Ripples", "author": "azaday", "description": "Working on code cleanup / readability of the original shader by Danilo Guanabara: https://www.shadertoy.com/view/XsXXDn\n", "tags": ["learning"], "likes": 7, "viewed": 296, "published": 3, "date": "1663393873", "time_retrieved": "2024-07-30T16:30:47.311051", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\n\n// improving readability + adding configurable params to Danilo's shader\n\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    /* visual params */\n    \n    float rippleDirection = -1.; // negative inwards, positive outwards\n    float rippleRate = 3.0; // rate that ripples move in/out\n    float numRipples = 20.; // num ripples\n    \n    float overallDensityRate = 1.0;  // rate of oscillation of overall ripple density. sin within sin\n    float densityCap = 1.0;  // cap density ie num of coexisting ripples\n\n\tvec3 c;\n\tfloat l, t=iTime;\n    vec2 p = fragCoord.xy/r;\n    p-=.5; // remap uv from [0,1] --> [-0.5, 0.5]. center pixel now (0,0)\n    p.x *= r.x / r.y;  // scale x by ratio of screen width to height. \n    // now p.x. and p.y range are proportional to screen resolution.\n    // e.g. if screen is 200px wide, 100px tall, p.x range from -1,1.\n    l=length(p); // distance from center of screen\n    \n\tfor(int i=0;i<3;i++) {\n        vec2 uv = fragCoord.xy/r;\n\t\n        t += .07;  // change time for each color channel. RGB diffraction effect\n\t\t\n        uv += // why are we using 0-1 UV here when this is a radially symmetric shader??\n            p / \n            l * densityCap * (sin(overallDensityRate * t)+1.) * // sin of time, shifted +1 to [0,2] range. independent for pixels, applies to entire screen\n            abs(sin(rippleDirection * rippleRate * t + l*numRipples)); // sin based on distance from center pixel, shifted proportionally to distance\n            // means freq of this sin is fixed at t coefficient, but repeats in ripples every 1/L*k units of radial distance\n\t\t\n        c[i]= .01 / length(fract(uv) - .5);  // why divide from .01??\n\t}\n\tfragColor=vec4(c / l, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcfzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 282, 306, 1853]], "test": "untested"}
{"id": "Nl3fRX", "name": "Bit depth visualization", "author": "absence", "description": "Visualize how different bit depth color ranges will fit onto your display.", "tags": ["visualize", "bitdepth"], "likes": 1, "viewed": 175, "published": 3, "date": "1663381766", "time_retrieved": "2024-07-30T16:30:48.052070", "image_code": "#define BIT_DEPTH 5.\n// bit depth 5 is being used to simulate color banding\n// defaults for almost all consumer displays are bit-depth 8\n// however, some high end equipment sometimes also use 10-bit\nconst float precisionAmount = 1. / ( pow( 2., BIT_DEPTH ) - 1.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n       \n    bool showRed = true;\n    bool showGreen = true;\n    bool showBlue = true;\n    \n    float r = clamp( precisionAmount * round( uv.x / precisionAmount ), 0., 1. ) - float(!showRed);\n    float g = clamp( precisionAmount * round( uv.x / precisionAmount ), 0., 1. ) - float(!showGreen);\n    float b = clamp( precisionAmount * round( uv.x / precisionAmount ), 0., 1. ) - float(!showBlue);\n    vec3 col = vec3(r,g,b);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3fRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[265, 265, 322, 322, 817]], "test": "untested"}
{"id": "fldBRB", "name": "Are we there yet?", "author": "cmzw", "description": "a little ride to nowhere", "tags": ["2d", "tunnel", "minecraft"], "likes": 34, "viewed": 791, "published": 3, "date": "1663364813", "time_retrieved": "2024-07-30T16:30:48.875867", "image_code": "#define AA 2\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec3 a = vec3(0); vec3 z = vec3(1); vec3 tot = a;\n\n    for( int m=0; m++<AA; )\n    for( int n=0; n++<AA; )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - .5;\n        vec2 p = (2.*I+o - iResolution.xy) / iResolution.y;\n       \n        float np = normalize(p).x;\n        p *= length(p)*.2+.8;\n        vec2 c = abs(p);\n\n        float s = 9.;\n        float t = iTime*s*2.;\n        float f = max(c.x,c.y);\n        float i = s/f;\n        \n        vec2 it = vec2(i+t,0);\n        vec2 piyx = floor(p*i+it.yx);\n        \n        vec3 x = vec3(hash12(floor(p*i + it.xy)));\n        vec3 y = vec3(hash12(piyx+.1));\n        \n        float g = hash12(piyx+.2);\n        float h = hash12(piyx+.3);\n        \n        float d = step(abs(np),.68);\n        float anp = abs(np);\n        float e0 = step(abs(anp-.5),.08);\n        float e1 = step(abs(anp-.5),.03);\n        float e2 = step(abs(anp-.55),.04);\n        \n        if (p.y < 0.)\n        {\n            y = mix(y,vec3(.7,-.05,-.5)-g*.5, step(sin(it.x+1.5),-.9)*d);\n            y = mix(y,vec3(.9,.2,-.5)+h*.5,  step(sin(it.x+.45),-.8)*d);\n            y -= e0*.4;\n            y = mix(y,vec3(-.2)*h*2.,e1);\n            y = mix(y,vec3(3)-h*1.1,e2);\n        }\n        \n        vec3 col = c.x > c.y ? x : y;   \n        \n        col = .3+col*.25;\n        \n        float ad = abs(-dot(c,vec2(-1,1)));\n        col = mix(col, a, smoothstep(.9,0.,ad)*.6);\n        col = mix(col, a, smoothstep(.2,0.,ad)*.25);\n        col = mix(col, a, smoothstep(.03,0.,ad)*.1);\n        col = mix(col, a, smoothstep(.3,1.5,1.-f));\n        \n        vec3 yy = vec3(.78,.57,.4)*4.5*smoothstep(5.,-.4,length(p));\n\n        col *= mix(col, yy, smoothstep(.2,2.5,length(p)*1.4));\n        col = mix(col, a, smoothstep(.3,3.5,length(p)));\n        \n        tot += col;\n    }   \n    tot /= float(AA*AA);\n   \n    O = vec4(aces_tonemap(tot),0);\n}", "image_inputs": [], "common_code": "float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fldBRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[14, 14, 55, 55, 1912]], "test": "untested"}
{"id": "stdfRj", "name": "Ancient Circuit Diagram", "author": "derSchamane", "description": "symmetrical micro chip pattern colorized.\ngive it some time (minutes) to develop and calm down.\nfullscreen highly recommended.\n\nsource: [url]www.shadertoy.com/view/wtlcR8[/url]\n\nSubstance Reference: MXP - Methoxphenidine", "tags": ["xor", "pattern", "circuit", "chip"], "likes": 14, "viewed": 328, "published": 3, "date": "1663361675", "time_retrieved": "2024-07-30T16:30:49.626859", "image_code": "// \"Circuit Diagram2\" by ntsutae (modified by jarble)\n// https://twitter.com/ntsutae/status/1268820823952916486\n// https://www.openprocessing.org/sketch/912094\n\n//mutated by derSchamane 2022 = Ancient Circuit Diagram =\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = iTime;\n  int x = int(fragCoord.x - iResolution/2.),\n      y = int(fragCoord.y +30.*t + 10000.),\n      r = (x+y+1)^(x-y);\n  float k = smoothstep(.5, 1., cos(t/5.+float(r)/(1000.+sin(t/97.)*100.)))-sin(t/8.+float(r)/200.)*.2;\n  float b = smoothstep(k*1., 1.+k*3., float(abs(r*r*r/(y+x+int(t*49.))) % (9970))/1000.);\n  fragColor = vec4(vec3((1.1-sin(t/9.)*.2-k)-b*b, (.8-k)-b, b*.3+k*.2), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdfRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 275, 275, 680]], "test": "untested"}
{"id": "fttBW7", "name": "Triangle Rasterizing", "author": "FifthStateOfMatter", "description": "Fast 3D rasterizing. Runs at 60 FPS on my phone.", "tags": ["rasterizing"], "likes": 4, "viewed": 328, "published": 3, "date": "1663355318", "time_retrieved": "2024-07-30T16:30:50.370870", "image_code": "#define PI 3.1415926545\n#define degreesToRadians PI/180.0\n#define a iResolution.y/iResolution.x\n#define FOV 90.0*degreesToRadians\n#define nearPlane 0.5\n#define farPlane 1000.0\n#define zNormalize farPlane/(farPlane - nearPlane)\n#define fogDensity 35.0\n#define fogColor vec3(0.7, 0.8, 1)\n\nstruct tri3{\n    vec3 v1;\n    vec3 v2;\n    vec3 v3;\n    vec3 inClr;\n};\n\ntri3[] mesh = tri3[](tri3(vec3(-0.5, 0.5, -0.5), vec3(-0.5, -0.5, -0.5), vec3(0.5, -0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, 0.5, -0.5), vec3(0.5, -0.5, -0.5), vec3(0.5, 0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(0.5, 0.5, -0.5), vec3(0.5, -0.5, -0.5), vec3(0.5, -0.5, 0.5), vec3(1, 0, 0)), tri3(vec3(0.5, 0.5, -0.5), vec3(0.5, -0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1, 0, 0)), tri3(vec3(0.5, 0.5, 0.5), vec3(0.5, -0.5, 0.5), vec3(-0.5, -0.5, 0.5), vec3(1, 0, 0)), tri3(vec3(0.5, 0.5, 0.5), vec3(-0.5, -0.5, 0.5), vec3(-0.5, 0.5, 0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, 0.5, 0.5), vec3(-0.5, -0.5, 0.5), vec3(-0.5, -0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, 0.5, 0.5), vec3(-0.5, -0.5, -0.5), vec3(-0.5, 0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, -0.5, -0.5), vec3(-0.5, -0.5, 0.5), vec3(0.5, -0.5, 0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, -0.5, -0.5), vec3(0.5, -0.5, 0.5), vec3(0.5, -0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, 0.5, 0.5), vec3(-0.5, 0.5, -0.5), vec3(0.5, 0.5, -0.5), vec3(1, 0, 0)), tri3(vec3(-0.5, 0.5, 0.5), vec3(0.5, 0.5, -0.5), vec3(0.5, 0.5, 0.5), vec3(1, 0, 0)));\n\nfloat f = 1.0/tan(FOV/2.0);\n\nfloat cross2D(vec2 av, vec2 bv){\n    return (av.x*bv.y - av.y*bv.x);\n}\n\nstruct tri2{\n    vec2 v1;\n    vec2 v2;\n    vec2 v3;\n    vec3 inClr;\n};\n\nstruct camera{\n    vec3 pos;\n    vec3 dir;\n};\n\n//Based on a chat on stackexchange.\n//https://gamedev.stackexchange.com/questions/23743/whats-the-most-efficient-way-to-find-barycentric-coordinates\nvec3 barycentricCoords(vec2 uv, tri3 tri){\n    vec2 v1 = tri.v2.xy - tri.v1.xy;\n    vec2 v2 = tri.v3.xy - tri.v1.xy;\n    vec2 v3 = uv - tri.v1.xy;\n    \n    float d1 = dot(v1, v1);\n    float d2 = dot(v1, v2);\n    float d3 = dot(v2, v2);\n    float d4 = dot(v3, v1);\n    float d5 = dot(v3, v2);\n    float denomInv = 1.0/(d1*d3 - d2*d2);\n    \n    float v = (d3*d4 - d2*d5)*denomInv;\n    float w = (d1*d5 - d2*d4)*denomInv;\n    float u = 1.0 - v - w;\n    \n    return vec3(u, v, w);\n}\n\nbool displayTriangle(vec2 uv, tri2 tri, in float clrInt, out vec3 outClr){\n    vec3 b = barycentricCoords(uv, tri3(vec3(tri.v1.xy, 0), vec3(tri.v2.xy, 0), vec3(tri.v3.xy, 0), tri.inClr));\n    if(b.x >= 0.0 && b.y >= 0.0 && b.x + b.y <= 1.0){\n        outClr = tri.inClr*clrInt;\n        return true;\n    }\n    return false;\n}\n\nbool render(vec2 uv, tri3 tri, vec3 rot, vec3 trans, vec3 scale, camera cam, out vec3 normal, out float depth, out vec3 camDir){\n    mat4 projection;\n    projection[0] = vec4(a*f, 0.0, 0.0, 0.0);\n    projection[1] = vec4(0.0, f, 0.0, 0.0);\n    projection[2] = vec4(0.0, 0.0, zNormalize, 1.0);\n    projection[3] = vec4(0.0, 0.0, -nearPlane*zNormalize, 0.0);\n    \n    mat4 camxRotation;\n    camxRotation[0] = vec4(1, 0, 0, 0);\n    camxRotation[1] = vec4(0, cos(cam.dir.x*degreesToRadians), -sin(cam.dir.x*degreesToRadians), 0);\n    camxRotation[2] = vec4(0, sin(cam.dir.x*degreesToRadians), cos(cam.dir.x*degreesToRadians), 0);\n    camxRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 camyRotation;\n    camyRotation[0] = vec4(cos(cam.dir.y*degreesToRadians), 0, sin(cam.dir.y*degreesToRadians), 0);\n    camyRotation[1] = vec4(0, 1, 0, 0);\n    camyRotation[2] = vec4(-sin(cam.dir.y*degreesToRadians), 0, cos(cam.dir.y*degreesToRadians), 0);\n    camyRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 camzRotation;\n    camzRotation[0] = vec4(cos(cam.dir.z*degreesToRadians), sin(cam.dir.z*degreesToRadians), 0, 0);\n    camzRotation[1] = vec4(-sin(cam.dir.z*degreesToRadians), cos(cam.dir.z*degreesToRadians), 0, 0);\n    camzRotation[2] = vec4(0, 0, 1, 0);\n    camzRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 camRotation = camxRotation*camyRotation*camzRotation;\n    \n    mat4 xRotation;\n    xRotation[0] = vec4(1, 0, 0, 0);\n    xRotation[1] = vec4(0, cos(rot.x*degreesToRadians), -sin(rot.x*degreesToRadians), 0);\n    xRotation[2] = vec4(0, sin(rot.x*degreesToRadians), cos(rot.x*degreesToRadians), 0);\n    xRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 yRotation;\n    yRotation[0] = vec4(cos(rot.y*degreesToRadians), 0, sin(rot.y*degreesToRadians), 0);\n    yRotation[1] = vec4(0, 1, 0, 0);\n    yRotation[2] = vec4(-sin(rot.y*degreesToRadians), 0, cos(rot.y*degreesToRadians), 0);\n    yRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 zRotation;\n    zRotation[0] = vec4(cos(rot.z*degreesToRadians), sin(rot.z*degreesToRadians), 0, 0);\n    zRotation[1] = vec4(-sin(rot.z*degreesToRadians), cos(rot.z*degreesToRadians), 0, 0);\n    zRotation[2] = vec4(0, 0, 1, 0);\n    zRotation[3] = vec4(0, 0, 0, 1);\n    \n    mat4 rotation = xRotation*yRotation*zRotation;\n    \n    vec4 v1 = vec4(tri.v1, 1);\n    vec4 v2 = vec4(tri.v2, 1);\n    vec4 v3 = vec4(tri.v3, 1);\n    \n    v1.xyz *= scale;\n    v2.xyz *= scale;\n    v3.xyz *= scale;\n    \n    v1 *= rotation;\n    v2 *= rotation;\n    v3 *= rotation;\n    \n    v1.xyz += trans;\n    v2.xyz += trans;\n    v3.xyz += trans;\n    \n    v1.xyz -= cam.pos;\n    v2.xyz -= cam.pos;\n    v3.xyz -= cam.pos;\n    \n    v1 *= camRotation;\n    v2 *= camRotation;\n    v3 *= camRotation;\n    \n    v1 *= projection;\n    v2 *= projection;\n    v3 *= projection;\n    \n    vec3 outClr;\n    \n    normal = normalize(cross(v3.xyz - v1.xyz, v2.xyz - v1.xyz));\n    \n    camDir = -v1.xyz;\n    \n    v1.xy /= v1.w;\n    v2.xy /= v2.w;\n    v3.xy /= v3.w;\n    \n    tri2 outTri = tri2((v1.xy + 1.0)*(iResolution.xy/2.0), (v2.xy + 1.0)*(iResolution.xy/2.0), (v3.xy + 1.0)*(iResolution.xy/2.0), vec3(1));\n    \n    vec3 barycentrics = barycentricCoords(uv, tri3(vec3((v1.xy + 1.0)*(iResolution.xy/2.0), v1.z), vec3((v2.xy + 1.0)*(iResolution.xy/2.0), v2.z), vec3((v3.xy + 1.0)*(iResolution.xy/2.0), v3.z), vec3(1)));\n    \n    float z = (1.0/v1.z)*barycentrics.x + (1.0/v2.z)*barycentrics.y + (1.0/v3.z)*barycentrics.z;\n    \n    depth = 1.0/z;\n    \n    return displayTriangle(uv, outTri, 1.0, outClr);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord;\n    camera cam = camera(vec3(0, 0, -3), vec3(-iMouse.y - abs(iMouse.w), iMouse.x - abs(iMouse.z), 0));\n    vec3 col = fogColor;\n    float depth;\n    vec3 camDir;\n    float testDepth = 10000000.0;\n        \n    for(int i = 0; i < mesh.length(); i++){\n        vec3 normal;\n        vec3 camDir = vec3(mesh[i].v1 - cam.pos);\n        bool r1 = render(uv, mesh[i], vec3(iTime*25.0, iTime*25.0, iTime*25.0), vec3(0, 0, 0), vec3(0.5, 1, 2), cam, normal, depth, camDir);\n        if(r1 && testDepth > depth && depth > 0.0 && dot(normal, camDir) >= 0.0){\n            testDepth = depth;\n            vec3 light = vec3(-10, -10, -10);\n            col = mix(max(dot(normal, normalize(light)), 0.1)*mesh[i].inClr, fogColor, 1.0 - exp(-testDepth * 0.1));\n        }\n        fragColor = vec4(col, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttBW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1473, 1473, 1505, 1505, 1543], [1664, 1813, 1855, 1855, 2291], [2293, 2293, 2367, 2367, 2616], [2618, 2618, 2746, 2746, 6101], [6103, 6103, 6157, 6157, 6973]], "test": "untested"}
{"id": "stcBRj", "name": "Damasdi tiling ", "author": "FabriceNeyret2", "description": "reference: [url]https://twitter.com/pickover/status/1567297600281362433[/url] based on a unique quadrangle tile.\n= equilateral tri +right isosceles tri, the latters always organized as squares. So the tiling ~also consists of \"shuttles\".", "tags": ["tiling", "short", "reproduction", "truchets"], "likes": 26, "viewed": 371, "published": 3, "date": "1663341151", "time_retrieved": "2024-07-30T16:30:51.121862", "image_code": "    float s = .866, d,a, // sqrt(3)/2\n          q = 1.5708,    // pi/4\n          tau = 6.283,   // 2pi\n          Z = 4.;\n          \n#define r(a)     mat2(cos(a+vec4(0,q,-q,0)))              // rotation\n#define R(a)     length(U0) * cos( mod( atan(U0.y,U0.x) +  a/2. , a  ) -  a/2. + vec2(0,q) ) // rotational symmetry(a)\n#define s(v)     smoothstep(-3.*Z/R.y, 0., v )            // AA draw\n\n       // --- shuttle tile( center, angle, diagonal sign ) = equilateral tri + square + equilateral tri \n#define S(P,a,w)                                                                      \\\n    V  = abs( Q = (U-P) * r(a) );                                                     \\\n    d  = min(.5 - V.y, .683 - dot(V,vec2(.5,s)) );          /* .683 = 1/4 + s/2   */  \\\n    O = max(O, s(d)                                         /* mask */                \\\n        * ( .3 + .5*s(-abs(d)) + .3* s(.5-max(V.x,V.y))     /* border + square    */  \\\n            + vec4( 1.-s( min(length(V-.5),length(V-vec2(.5+s,0))) -.33 ) /* dots */  \\\n                    +s( min( length(Q-vec2(1,w 1)), length(Q+vec2(1,w 1)) ) -1.3 ) *step(V.x,.5), 0,0,0) ))  /* diagonal bar */\n                //  +s( .1-abs(Q.x+ w Q.y) ),  0,0,0) ) )   /* diagonal bar */\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R  = iResolution.xy, V, D,T, P, Q,\n         U0 = Z*( 2.*u - R ) / R.y, U;\n    O-=O; \n\n    U = R(tau/6.);                                        // ---6-symmetry\n    P = vec2(s+.5,0);  \n    S(P, 0.,) * vec4(.7,1,0,0);                           // central flower\n // S(P, q,-) * vec4(.7,1,0,0);                           // fills the triangle gaps\n    \n    a = tau/12., U = R(a);                                // --- 12 symmetry\n                                        \n    D = cos(a+vec2(0,q));  T = vec2(-D.y,D.x),  P += vec2(.79,0) + .79*T;  // vec2(.5+s/3.,0.) + (.5+s/3.)*T;\n    S(P, a,);  S(P*r(-a), 2.*a ,);                       // 1st crown\n    // the second call is to complete when the pattern falls out of the main pie ( = fan within angle +- a/2 )\n    \n    P += (1.+s)*D - .5*T; S(P, a ,-); S(P*r(a),,-);      // 2nd crown\n    P += T;               S(P, a ,-);\n\n    P += (1.+s)*D - .5*T; S(P, a ,-); S(P*r(a),,-);      // 3rd crown\n    P += T;               S(P, a , );\n    P -= 2.*T;            S(P, a , ); S(P*r(a),, ); \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7tdBzB", "name": "Manos", "author": "lechuga", "description": "La textura no es la misma pero bueno.", "tags": ["noise", "body"], "likes": 9, "viewed": 450, "published": 3, "date": "1663310863", "time_retrieved": "2024-07-30T16:30:51.871857", "image_code": "#define fin return vec2(d, id)\nfloat t;\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pil(a,d) clamp(a.y, 0., d)\n#define pi acos(-1.)\n#define NN texture(iChannel0, p0.xz*.211+sin(tt*2.663)).x - texture(iChannel0, p0.yz*.121+cos(tt*1.245)).x - texture(iChannel0, p0.yx*.0721+sin(tt*1.934)).x * pi - sin(length(pi-(p0*.95)-vec3(0., -15., 0.))-t*5.)*sin(p0.x*.451)*sin(p0.z*.94)*2.94\n#define TIC clamp(0., 1.,sin(t*.125))\nfloat smin(float a, float b, float k){\n  float h = max(0., k-abs(a-b))/k;\n  return min(a,b)-h*h*k*.25;\n}\nfloat d = 1., id = 0., flameC = 0., bodyC = 0., oceanC = 0.;\nvec2 body(vec3 p){\n  float tt = t*.1;\n  id = 1.;\n  vec3 p0=p, p1, p2, p3, p4=p, p5=p, p6 =p;\n  p.x = abs(p.x)-10.;\n  p.xy *= rot(pi/4.);\n  p1 = p2 = p3 = p;\n  float s1 = 3.,s2 = .15;\n  d = length(vec2(length(p1.xy)-s1, p1.z))-s2;\n  p3-=vec3(0., 7.5, 20.);\n  p3.zy *= rot(pi/1.75);\n  p3.y -= pil(p3, 20.);\n  d = smin(d, length(p3)-1.-NN*.1, 1.);\n  p2.y += sin(p2.y*.81);\n  for(float i = 0.; i++ < 4.;){\n    p2.x = abs(p2.x)-i*.001;\n    p2.x -= .5;\n    p2.xy *= rot(pi/11.);\n  }\n  p2.z += p2.y*p2.y*.069;\n  p2 += vec3(0., 5., 0.);\n  p2.y -= pil(p2, 3.);\n  \n  float d2 = length(p2)-.5;\n  d = smin(d, d2, 1.)*.55;\n  p4.yz *= rot(pi/3.);\n  p4.zy -= 14.;\n  float d3 = length(p4)-5.-sin(sin(p4.y*.374)*p4.z*.591875-pi)*.5-.5-NN*.1;\n  d = min(d, d3);\n  p5-=vec3(0., 5.,20.);\n  for(int i = 0; i++ < 4;){\n    float d4 = length(p5)-2.-sin(p5.x*.623)*.5-.5-NN;\n    d = min(d, d4);\n    p5-=vec3(0., 5.+p5.z*.5,5.);\n  }\n  float d5 = -p6.z+29.-NN;\n  oceanC += .1/(.1+d5*d5);\n  d = smin(d, d5,1.);\n  bodyC += 0.1/(0.1+d*d);\n  \n  fin;\n}\nvec2 flame(vec3 p){\n  p.x = abs(p.x)-8.;\n  vec3 p1, p2;\n  p1 = p2 = p;\n  id = 2.;\n  float d2 = length(p1)-1.25-sin(p1.y+t)*sin(sin(p1.x*.34+t)*p1.x*.23+t)*sin(p1.z*.345+t*2.)*.5-.5;\n  d2 = smin(d2, length(p1-vec3(0., 1., 0.)), 1.);\n  flameC += .3/(1.+d2*d2);\n  fin;\n}\nvec2 m(vec3 p){\n  p.z = abs(p.z)-10.+TIC*10.; // 2.6\n  p.xy *= rot(cos(t*.225+p.z*.087345));\n  vec2 e = body(p);\n  vec2 e2 = flame(p);\n  d = e.x < e2.x ? e.x : e2.x;\n  fin;\n}\nvec3 nm(vec3 p){\n  vec2 e = vec2(0.81,0.);\n  return normalize(m(p).x-vec3(m(p-e.xyy).x, m(p-e.yxy).x, m(p-e.yyx).x));\n}\nvoid ray(inout vec3 p, inout vec3 r){\n  const float MM = 300.;\n  float di = 0., dd = 0., id = -1.;\n  for(float i = 0.; i++ < 100.;){\n    vec2 e = m(p);\n    di = e.x;\n    id = e.y;\n    if(di < .00001){\n      break;\n    }\n    //else if(dd > MM){\n      //p = vec3(MM);\n      //di = MM;\n      //break;\n    //}\n    dd += di;\n    p+=di*r;\n  }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = mod(iTime, 1e10)*2.;\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  t += fract(sin(dot(uv.x*343., uv.y*344.))*232.)*.0125;\n  vec3 s = vec3(0.01,-15.01,-96.);\n  s.zy *= rot(pi/2.);\n  vec3 p = s;\n  vec3 tg = vec3(0.01,10.01, 0.01);\n  vec3 cz = normalize(tg-s);\n  vec3 cx = normalize(cross(cz,vec3(0., -1., 0.)));\n  vec3 cy = normalize(cross(cz,cx));\n  vec3 r = mat3(cx,cy,cz)*normalize(vec3(-uv, 1.-uv.x*uv.x*3.));\n  vec3 co = vec3(0.);\n  ray(p, r);\n  vec3 n = nm(p);\n  vec3 l = normalize(vec3(1., 1., 1.));\n  float dif = clamp(dot(l, n), 0., 1.);\n  float esp = pow(clamp(dot(reflect(-l, -r), n), 0., 1.), 40.);\n  float fr = pow(.1-dot(l,n), 3.);\n  vec3 OCCO = vec3(0.15,.745, .66);\n  vec3 OCCO2 = vec3(0.5,.745, 1.);\n  co += vec3(dif + esp)*fr;\n  co += flameC * vec3(.6234,.4598, 0.275);\n  co += oceanC * OCCO*.02;\n  co += bodyC * vec3(.78,.745, 0.46) *max(.007246,(.007246+TIC*.5));\n  co += OCCO2*length(p)*.00295;\n  co *= 1.-length(uv)*.777;\n  co = pow(co, vec3(.7111))*.65;\n\tfragColor = vec4(co, 1.);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdBzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[431, 431, 469, 469, 535], [597, 597, 615, 615, 1616], [1617, 1617, 1636, 1636, 1884], [1885, 1885, 1900, 1900, 2059], [2060, 2060, 2076, 2076, 2179], [2180, 2180, 2217, 2217, 2518], [2519, 2519, 2576, 2576, 3678]], "test": "untested"}
{"id": "7ttfRB", "name": "Fractal mosaic 19 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 4, "viewed": 288, "published": 3, "date": "1663305732", "time_retrieved": "2024-07-30T16:30:52.624844", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        //vec2(1.5,0.5)\n        //vec2(-2.,.5+mod(floor(a.x),2.))\n\n        ///vec2(1.,.5+floor(a.y-.5)/2.)\n        //vec2(2.,0.)\n        //vec2(1.5,0.)\n        //vec2(1.25,1.75)\n        //vec2(abs(mod(a.x-.5,2.)-1.),abs(mod(a.y-.5,2.)-1.))\n    ,\n    \n    a1 = a+a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\n\n\nvec3 image1(vec2 uv){\n    vec3 col = vec3(0.);\n    vec3 col1 = col;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 3; k++){\n        //uv += floor(uv);\n        uv = abs(uv+t2);\n        \n        t2 = triangle_wave(uv+.5);\n        uv = t2-triangle_wave(uv.yx);\n        if(iMouse.z>.5)\n        uv = uv.xy + iMouse.xy / iResolution.xy;\n        \n        col.x =\n            //(length(uv-t2.yx)-.5)*3.;\n            //(length(uv-t2.yx)-t2.x)*3.;\n            (length(uv-t2.yx)-uv.x)*3.;\n            //(length(uv*t2.yx)-uv.x)*2.;\n        col =\n            min(abs(abs(col-1.)-col),abs(abs(col-1.)-col.yzx));\n            //min(abs(abs(col.yzx-1.)-col),abs(abs(col-1.)-col));\n        col1 =\n            abs(col1+col.yzx-1.);\n            //abs(col1.yzx*col+col-1.);\n            //abs(col1*col.yzx+col.yzx-1.);\n            //if(t2.y>t2.x) {uv=uv.yx;t2=t2.yx;}\n        //if(t2.x>t2.y) col1=col1.yzx;\n    }\n    return col1;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += iTime/t1/24.;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec3 col1 = image1(uv);\n    fragColor = vec4(col1,1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float t){\n  float m1 =\n      3.\n      //fmod(t/3.,3.)+3.\n  ,\n  s1 = 4.+fmod(t/m1,m1),\n  tempo =\n      3.5,\n      //4./(1.+fmod(t*(1.+fmod(t,2.)),2.)),\n\n      //2.5+fmod(t/4.+floor(t/4.),8.)/4.,\n  t1 = t*tempo+m1,\n  m2 = fmod(t1+floor(t1/m1+floor(t1/s1)/m1),s1+fmod(t1,m1)),\n\n  a=\n      //sqrt((1.-sqrt(fract((t*tempo+m2+t1)/2.))))*.2\n      32.*pow((1.-sqrt(fract((t*tempo+m2+t1)/2.))/1.25),2.)*.2\n  ,\n  \n  nb =\n      t*pow(2.,m2/5.+7.5);\n      //pow(2.,m2/(5.+s1/5.)+7.5);\n\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      //vec2(fract(t*nb*.998/(1.+m2)),fract(t*nb/(1.+m2)))*a\n  ;\n}\n\n/*\nvec2 mainSound(int samp, float t){\n  float m1 = 4.,\n  s1 = m1+fmod(t,m1),\n  tempo =\n      2.,\n      //2.5+fmod(t/4.+floor(t/4.),8.)/4.,\n      t1 = t*tempo+m1,\n  m2 = fmod(floor(-t1*m1+floor(t/s1))+floor(t1/m1-floor(t*m1)),s1),\n\n  a=sqrt((1.-sqrt(fract(t*tempo+(m2)/2.))))*.2,\n  \n  nb = pow(2.,m2/5.+7.5);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n}\n*/\n\n/*\nvec2 mainSound(int samp, float t){\n  float m1 = 4.,\n  s1 = m1+fmod(t,m1),\n  tempo =\n      2.,\n      //2.5+fmod(t/4.+floor(t/4.),8.)/4.,\n      t1 = t*tempo+m1,\n  m2 = fmod(floor(-t1*m1+floor(t/m1))+floor(t1/m1-floor(t*m1)),s1),\n\n  a=sqrt((1.-sqrt(fract(t*tempo+(m2)/2.))))*.2,\n  \n  nb = pow(2.,m2/5.+7.5);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n}\n*/\n\n/*\nvec2 mainSound(int samp, float t){\n  float m1 = 4.,\n  s1 = m1+fmod(t,m1),\n  tempo =\n      2.,\n      //2.5+fmod(t/4.+floor(t/4.),8.)/4.,\n      t1 = t*tempo+m1,\n  m2 = fmod(floor(t1*m1)*floor(t1/m1),s1),\n\n  a=sqrt((1.-sqrt(fract(t*tempo+(m2)/2.))))*.2,\n  \n  nb = pow(2.,m2/5.+7.5);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n}\n*/\n\n/*\nvec2 mainSound(int samp, float t){\n  float m1 = 5.,\n  f1 = floor(t+floor(t/m1)),\n  s1 = m1+fmod(t+f1,m1),\n  tempo =\n      3.5,\n      t1 = t*tempo+m1,\n  m2 = fmod(floor(t1)+floor(t1/s1+f1),s1),\n\n  a=sqrt((1.-sqrt(fract(t*tempo+(m2)/2.))))*.2,\n  \n  nb = pow(2.,m2/5.+7.5);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n}\n*/\n\n/*\nvec2 mainSound(int samp, float t){\n  float m1 = 4.,\n\n  tempo =\n      3.5,\n      //2.5+fmod(t/4.+floor(t/4.),8.)/4.,\n      t1 = t*tempo+m1,\n  m2 = fmod(t1+(floor(t1)+floor(t/m1)+floor(t1/m1)),m1+fmod(t1,m1)),\n\n  a=sqrt((1.-sqrt(fract(t*tempo+(m2)/2.))))*.2,\n  \n  nb = pow(2.,m2/5.+7.5);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n}\n\n*/\n\n/*\nvec2 mainSound(int samp, float t){\n  float m1 = 2.+fmod(t,6.),\n  tempo =\n      3.5,\n      //2.5+fmod(t/4.+floor(t/4.),8.)/4.,\n      t1 = t,\n  m2 = fmod(float(samp),m1),\n\n  a=sqrt((1.-sqrt(fract(t*tempo+(m2)/2.))))*.2,\n  \n  nb = pow(2.,m2/5.+7.5);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n}\n*/\n\n/*\nvec2 mainSound(int samp, float t){\n  float m1 = 4.+fmod(t/4.,4.),\n  s1 = 4.+fmod(t/m1,m1),\n  tempo =\n      3.5,\n      //2.5+fmod(t/4.+floor(t/4.),8.)/4.,\n      t1 = t*tempo+m1,\n  m2 = fmod(t1+floor(t1/m1+floor(t1/s1)/m1),s1+fmod(t1,m1)),\n\n  a=sqrt((1.-sqrt(fract(t*tempo+(m2)/2.))))*.2,\n  \n  nb = pow(2.,m2/5.+7.5);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n}\n\n*/\n\n/*\nvec2 mainSound(int samp, float t){\n  float m1 = 4.+fmod(t*4.,4.),\n  s1 = 4.,\n  tempo =\n      4.,\n      t1 = (t*tempo+m1)/m1,\n  m2 = fmod(t1+floor(t1*m1),s1),\n\n  a=sqrt((1.-sqrt(fract(t*tempo+(m2)/2.))))*.2,\n  \n  nb = pow(2.,m2/5.+7.5);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n}\n*/\n\n/*\nvec2 mainSound(int samp, float t){\n  float m1 = 3.,\n  s1 = 8.,\n  tempo =\n      3.,\n      //3.+fmod(t/8.+floor(t/8.),8.)/4.,\n  t1 = t*tempo+m1,\n  m2 = fmod(t1*2.+floor(t1/m1+floor(t1/s1)/m1),s1+fmod(t1,2.)),\n\n  a=sqrt((1.-sqrt(fract(t*tempo+(m2)/2.))))*.2,\n  \n  nb = pow(2.,m2/5.+7.5);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n\n}\n*/\n\n/*\nvec2 mainSound(int samp, float t){\n  float s1 = 8.,\n  tempo =\n      3.5,\n      //2.5+fmod(t/4.+floor(t/4.),8.)/4.,\n      t1 = (t+s1)*tempo,\n      c2 = fmod(t1/tempo,4.),\n      c1 = fmod(t1/4.+c2,2.+fmod(t1*2.,4.)+c2),\n  m2 = c1,\n\n  a=sqrt((1.-sqrt(fract(t*tempo+(m2)/2.))))*.2,\n  \n  nb = pow(2.,m2/5.+7.5);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n}\n*/", "sound_inputs": [], "common_code": "#define fmod1(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n\nfloat fmod(float a, float b){\n    //multiply by prime numbers to get interesting rhythms\n    //a /= 2.;\n    //a /= 1. + max(mod(floor((a))*7.,2.),mod(floor((a))*5.,2.));\n\n    //a += mod(floor((a))*7.,2.);\n    //a /= 5.;\n    \n    return mod(floor(a),b);\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttfRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 471], [475, 475, 496, 496, 1412], [1414, 1414, 1471, 1471, 1723]], "test": "untested"}
{"id": "sldBRS", "name": "Colored Sphere Waves", "author": "derSchamane", "description": "colored 2D variation of \"Anaglyph Sphere Waves\" - [url]www.shadertoy.com/view/ftdfW8[/url]\n\n\nSubstance Reference: Psilocin + DMXE (Deoxymethoxetamine)", "tags": ["3d", "sphere", "mirror"], "likes": 1, "viewed": 293, "published": 3, "date": "1663293666", "time_retrieved": "2024-07-30T16:30:53.365862", "image_code": "//                   = Colored Sphere Waves =         \n//                by  Maximilian Knape ·∑>| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n\n#define MAX_STEPS 300\n#define MAX_DIS 500.\n#define MIN_DIS 20.\n\n#define SURF_DIS .001\n#define SURF_MUL 100.\n#define SURF_EXP 2.\n\n#define iTime iTime*.5\n\nmat2 Rot(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Dist(vec3 p) \n{\n    p.xy *= Rot(smoothstep(-.2,.2,sin(iTime/15.))*.785);\n    p.xz *= Rot((smoothstep(-.8,.0,sin(iTime/12.))*2.-1.)*1.57+1.57);\n\n    float f = 1./(300.+sin(iTime/11.)*120.-sin(iTime/9.)*80.+sin(iTime/7.)*50.);\n    float dis = length(p)*f;\n    \n    p.xy *= Rot(p.z/MAX_DIS*(smoothstep(.2,1.,sin(iTime/13.)) - smoothstep(-.2,-1.,sin(iTime/13.)))*6.28);\n\n    vec3 size = vec3(20.+sin(iTime/33.)*5.);\n    p = mod(abs(-mod(p,4.*size)+2.*size),4.*size);    \n\n    float d = length(p - sin(iTime*.5+dis*6.28)*size.x-size) - \n              (10.+sin(iTime/33.)*5.)*(sin(iTime*1.5+dis*6.28)*.5+.8)*\n              (1.+.5*smoothstep(0.8,1.,sin(iTime/3.+dis/f/200.))); \n\n    return d;\n}\n\nvec3 RTM(vec3 ro, vec3 rd) \n{\n    int steps;\n    float sum = 0.;\n\tfloat s = 1.;\n    float d = MIN_DIS;\n    const float a = 1. / float(MAX_STEPS); \n    vec3 p = vec3(0.);\n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {    \n        float sd = (SURF_DIS * (pow(d/MAX_DIS, SURF_EXP)*SURF_MUL+1.));\n        if (s < sd || d > MAX_DIS) break;\n        \n        steps = i;\n        p = ro + rd*d;\n        s = Dist(p);\n        s = max(abs(s), 2.*sd);\n        d += s * 0.5;\n        sum += a;\n    }\n    \n    return vec3(smoothstep(0., 1., sum * (1.-exp(-d*d))), tanh(s/150.), float(steps) / float(MAX_STEPS));\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0.,1.,0.), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n    vec3 ro = vec3( 0., 0., -80.);\n    vec3 rd = R(uv, ro, vec3(0.), .3 + .8*smoothstep(.5,1.,sin(iTime/12.)));\n    vec3 r = RTM(ro, rd);\n    \n    vec3 col = vec3(r.y*r.z+r.y+r.x*.1, r.z-r.x*.4+r.y*.4, r.x-r.y);\n    col *= smoothstep(2.,-2./5., dot(uv,uv)); \n    vec3 colS = smoothstep(vec3(0.), vec3(1.), vec3(col));\n    \n    fragColor = vec4(colS, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldBRS.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[456, 456, 476, 476, 552], [554, 554, 575, 575, 1247], [1249, 1249, 1278, 1278, 1850], [1852, 1852, 1894, 1894, 2092], [2094, 2094, 2151, 2151, 2569]], "test": "untested"}
{"id": "Nt3fRB", "name": "Fork Fires cpyp0101 026", "author": "cpyp0101", "description": "Simple fire flames rendering. Multiple flame perturbations illustrated from candle light to strong fire.", "tags": ["procedural", "2d", "fire"], "likes": 4, "viewed": 257, "published": 3, "date": "1663292019", "time_retrieved": "2024-07-30T16:30:54.141787", "image_code": "//////////////////////\n// Fire Flame shader\n\n// procedural noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\n// no defines, standard redish flames\n//#define BLUE_FLAME\n//#define GREEN_FLAME\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = uv;\n\tq.x *= 1.;\n\tq.y *= 1.5;\n\tfloat strength = floor(q.x+1.);\n\tfloat T3 = max(3.,1.25*strength)*iTime;\n\tq.x = mod(q.x,1.)-0.5;\n\tq.y -= 0.25;\n\tfloat n = fbm(strength*q - vec2(0,T3));\n\tfloat c = 1. - 16. * pow( max( 0., length(q*vec2(1.8+q.y*1.5,.75) ) - n * max( 0., q.y+.25 ) ),1.2 );\n\tfloat c1 = n * c * (1.5-pow(0.50*uv.y,4.));\n\tc1=clamp(c1,0.,1.);\n\n\tvec3 col = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1);\n\t\n#ifdef BLUE_FLAME\n\tcol = col.zyx;\n#endif\n#ifdef GREEN_FLAME\n\tcol = 0.85*col.yxz;\n#endif\n\t\n\tfloat a = c * (1.-pow(uv.y,3.5));\n\tfragColor = vec4( mix(vec3(1),col,a), 0.1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt3fRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 73, 94, 94, 213], [215, 215, 241, 241, 699], [701, 701, 721, 721, 951], [1035, 1035, 1092, 1092, 1729]], "test": "untested"}
{"id": "7tdBRS", "name": "Fractal mosaic 18 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 4, "viewed": 304, "published": 3, "date": "1663286707", "time_retrieved": "2024-07-30T16:30:54.884801", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        //vec2(1.5,0.5)\n        //vec2(-2.,.5+mod(floor(a.x),2.))\n\n        ///vec2(1.,.5+floor(a.y-.5)/2.)\n        //vec2(2.,0.)\n        //vec2(1.5,0.)\n        //vec2(1.25,1.75)\n        //vec2(abs(mod(a.x-.5,2.)-1.),abs(mod(a.y-.5,2.)-1.))\n    ,\n    \n    a1 = a+a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += iTime/t1/24.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    for(int k = 0; k < 9; k++){\n        //uv += floor(uv*2.)/2.;\n        uv = (uv+t2)/scale;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*3.)-.5)/3.;\n        t2 = triangle_wave(uv+.5);\n        uv = t2-triangle_wave(uv.yx);\n        col.x =\n            //max(max(length(uv-t2),abs(uv.y-uv.x))/3.,col.x);\n            //max(max(length(abs(uv)-abs(t2)),abs(abs(uv.y)-abs(uv.x))),col.x);\n            max(max(length(uv-t2.yx),abs(uv.y-uv.x))/3.,col.x);\n            //max(max(min(length(uv-t2),length(uv-t2.yx)),abs(uv.y-uv.x))/3.,col.x);\n        col =\n            //abs(col-(1.-col.x));\n            abs(abs(abs(col-1.))-col);\n        col1 =\n            abs(col1-col-1.).yzx;\n            //abs(abs(col1.yzx*col1-col-1.)-col1);\n            //abs(col1-col*col1.yzx-1.).yzx;\n            ////abs(abs(col1.yzx-col-1.)-col1);\n            //if(uv.y>uv.x) {uv=uv.yx;t2=t2.yx;}\n    }\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "\nvec2 mainSound(int samp, float t){\n  float tempo = 1.;\n  t /= tempo;\n  float s1 = 5.,\n  m4 = fmod(t/s1,s1),\n  m2 = floor(s1/2.+abs(s1/2. - m4)),\n  m1 =\n      floor(abs(s1/2.-m2)),\n  m3 =\n      fmod(t*(s1)/abs(s1/2.+(m1-m2)),s1),\n  a = 64.*sqrt((1.-sqrt(fract(t/s1))))*.2,\n  \n  nb = t*tempo*pow(2.,m1/s1+m3/s1+7.);\n\n  return abs(.5-vec2(fract(nb*.998)\n   ,fract(nb)))*a;\n\n}\n\n/*\n#define fmod(x,y) mod(floor(x),y)\n\nvec2 mainSound(int samp, float t){\n  \n  float s1 = 5.,\n  m4 = fmod(t*s1,s1),\n  m2 = floor(s1/2.+abs(s1/2. - m4)),\n  m1 =\n      floor(abs(s1/2.-m2)),\n  m3 =\n      fmod(t/(s1)/abs(s1/2.+floor(m1-m2)),s1-m4),\n  a=sqrt((1.-sqrt(fract(t*s1))))*.2,\n  \n  nb = pow(2.,m1/s1+m3/s1+7.);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n\n}\n*/\n\n/*\nvec2 mainSound(int samp, float t){\n  \n  float s1 = 5.,\n  m4 = fmod(t*s1,s1),\n  m2 = floor(s1/2.+abs(s1/2. - m4)),\n  m1 =\n      floor(abs(s1/2.-m2-m4)),\n  m3 =\n      fmod(t*(s1)/abs(s1/2.+floor(m1-m2)),s1),\n  a=sqrt((1.-sqrt(fract(t*s1+m4))))*.2,\n  \n  nb = pow(2.,m1/s1+m3/s1+7.);\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n\n}\n*/", "sound_inputs": [], "common_code": "#define fmod(x,y) mod(floor(x),y)\n//#define fmod(a,b) mod(mod(floor((a)/2.),floor(1.+(a)/8.)),b)\n", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 471], [473, 473, 530, 530, 1715]], "test": "untested"}
{"id": "fltBzB", "name": "7segments display", "author": "SONENEIS", "description": "something lol", "tags": ["2d", "time", "sdf", "text", "texture", "antialiasing", "number", "iq", "green", "font", "rain", "aa", "debug", "segment", "7", "timer", "print", "num", "soneneis", "sns"], "likes": 5, "viewed": 338, "published": 3, "date": "1663278514", "time_retrieved": "2024-07-30T16:30:55.753478", "image_code": "float sdCirc(vec2 uv,float r){\n  return length(uv) - r;\n}\nfloat sdRect(vec2 uv,vec4 rect,float r){\n  return length(max(abs(uv-rect.xy)-rect.zw,0.0)) - r;\n}\n\nfloat segm7(vec2 uv,int n1,int n2,int n3,int n4,int n5,int n6,int n7,int dp){\n  float res = 1.0;\n\n  //   ——1——\n  // |       |\n  // 2       3\n  // |       |\n  //   ——4——\n  // |       |\n  // 5       6\n  // |       |\n  //   ——7——   (dp)\n\n  if(n1 == 1) res = min(res,sdRect(uv,vec4(0.0,0.4,0.1,0.01),0.05));\n  if(n4 == 1) res = min(res,sdRect(uv,vec4(0.0,0.0,0.1,0.01),0.05));\n  if(n7 == 1) res = min(res,sdRect(uv,vec4(0.0,-0.4,0.1,0.01),0.05));\n  if(n3 == 1) res = min(res,sdRect(uv,vec4(0.2,0.2,0.01,0.1),0.05));\n  if(n2 == 1) res = min(res,sdRect(uv,vec4(-0.2,0.2,0.01,0.1),0.05));\n  if(n6 == 1) res = min(res,sdRect(uv,vec4(0.2,-0.2,0.01,0.1),0.05));\n  if(n5 == 1) res = min(res,sdRect(uv,vec4(-0.2,-0.2,0.01,0.1),0.05));\n  if(dp == 1) res = min(res,sdCirc(uv-vec2(0.35,-0.4),0.05));\n\n  return res;\n}\n\nfloat digit(vec2 uv,int d,int dp){\n  float res = 1.0;\n  \n  if(d == 0) res = min(res,segm7(uv,1,1,1,0,1,1,1,dp));\n  if(d == 1) res = min(res,segm7(uv,0,0,1,0,0,1,0,dp));\n  if(d == 2) res = min(res,segm7(uv,1,0,1,1,1,0,1,dp));\n  if(d == 3) res = min(res,segm7(uv,1,0,1,1,0,1,1,dp));\n  if(d == 4) res = min(res,segm7(uv,0,1,1,1,0,1,0,dp));\n  if(d == 5) res = min(res,segm7(uv,1,1,0,1,0,1,1,dp));\n  if(d == 6) res = min(res,segm7(uv,1,1,0,1,1,1,1,dp));\n  if(d == 7) res = min(res,segm7(uv,1,0,1,0,0,1,0,dp));\n  if(d == 8) res = min(res,segm7(uv,1,1,1,1,1,1,1,dp));\n  if(d == 9) res = min(res,segm7(uv,1,1,1,1,0,1,1,dp));\n\n  return res;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n  \n  float size = 1.0;\n  \n  int t = int(iTime*50.0);\n  int nUni = (t / 10  ) % 10;\n  int nTen = (t / 100 ) % 10;\n  int nHun = (t / 1000) % 10;\n  \n  //unit\n  col = mix(vec3(0.04,0.07,0.05),col,smoothstep(0.0,5.0/iResolution.y,digit(size*uv-vec2(0.7,0),8,1)));\n  col = mix(vec3(0.10,1.0,0.500),col,smoothstep(0.0,5.0/iResolution.y,digit(size*uv-vec2(0.7,0),nUni,0)));\n  //ten\n  col = mix(vec3(0.04,0.07,0.05),col,smoothstep(0.0,5.0/iResolution.y,digit(size*uv-vec2(0.0,0),8,1)));\n  col = mix(vec3(0.10,1.0,0.500),col,smoothstep(0.0,5.0/iResolution.y,digit(size*uv-vec2(0.0,0),nTen,0)));\n  //hendred\n  col = mix(vec3(0.04,0.07,0.05),col,smoothstep(0.0,5.0/iResolution.y,digit(size*uv-vec2(-0.7,0),8,1)));\n  col = mix(vec3(0.10,1.0,0.500),col,smoothstep(0.0,5.0/iResolution.y,digit(size*uv-vec2(-0.7,0),nHun,0)));\n  \n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltBzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 57], [58, 58, 98, 98, 155], [157, 157, 234, 234, 982], [984, 984, 1018, 1018, 1617], [1619, 1619, 1672, 1672, 2601]], "test": "untested"}
{"id": "7tdBz7", "name": "011 - SSSnake", "author": "PiGIon", "description": "This doesn't looks like a .io game at all... What are you thinking?", "tags": ["2d", "beginner", "snake", "slither"], "likes": 8, "viewed": 309, "published": 3, "date": "1663271849", "time_retrieved": "2024-07-30T16:30:56.492503", "image_code": "#define PI 3.14159265\n#define RAD 6.2831853\n\nfloat antiAlias;\n\nvec2 rotAround(vec2 p, vec2 o, float ang);\n\nvec4 circle(vec2 uv, vec2 origin, float size, vec3 col) {\n    return vec4(col, smoothstep(size + antiAlias, size - antiAlias, length(uv - origin)));\n}\n\nvec4 eye(vec2 uv, vec2 origin, float size, float ang) {\n    vec4 eyeBall = circle(uv, origin, size, vec3(1.));\n    vec2 pupilO = vec2(origin.x + size/2., origin.y);\n    pupilO = rotAround(origin, pupilO, ang);\n    vec4 pupil = circle(uv, pupilO, size/2., vec3(0.));\n\n    return mix(eyeBall, pupil, pupil.w);\n}\n\n\nmat2 rot2D(float ang) {\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n}\n\n// p: reference point to rotation from\n// o: point that will be rotated\n// ang: angle in radians\nvec2 rotAround(vec2 p, vec2 o, float ang) {\n    vec2 v = (o - p);\n    \n    return (rot2D(ang) * v) + p;\n}\n\n// returns the angle of a vector in radians\nfloat angle(vec2 v) {    \n    return -atan(v.y/v.x);\n}\n\nvec3 rgb(int r, int g, int b) {\n    return vec3(float(r)/255., float(g)/255., float(b)/255.);\n}\n\n// https://www.wolframalpha.com/input?i=f%28x%29%3D0.5%2B%28cos%28%28%28x%2B0.5%2F1%29*20*1%29%2F%28PI%29%29%2F2.%29\nfloat cycle(float perSecond) {\n    float d = fract((iTime + iTimeDelta) * perSecond);\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\n\n// returns -size to size cycle\nfloat rangeCycle(float size, float perSec) {\n    return mod(iTime*perSec - size, size) - .5*size;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    antiAlias = 1.5/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float size = floor(50. + (200. * cycle(0.1)));\n    float thick = 0.15 + (0.25 * cycle(0.2));\n    \n    vec2 o = vec2(-1.3, 0.);\n    vec3 initCol = rgb(186, 98, 245);\n    vec3 destCol = rgb(228, 237, 62);\n    \n    // what is the step size when going from source color to destinate color?\n    vec3 incCol = (destCol-initCol) / size;\n    // used for the head\n    vec2 lastO;\n    \n    for (float i = 1.; i <= size; i+= 1.) {\n       lastO = vec2(o);\n       o.x += 0.01;\n       o.y = cos(o.x + iTime*5.12) / (0.5/thick);\n       initCol += incCol;\n       \n       vec4 circleColor = circle(uv, o, thick, initCol);\n       col = mix(col, circleColor.xyz, circleColor.w);\n       \n       // last part, time for the eyes c.c\n       if (i == size) {\n           float eyeSize = thick/4.;\n           vec2 eyeVec = vec2(eyeSize, eyeSize * 2.);\n           \n           // discover the angle between the head and the body\n           vec2 angVec = o - lastO;\n           float ang = angle(angVec);\n           \n           // discover the left eye origin\n           vec2 lEyeO = o + eyeVec;\n           // align the eye with the body\n           lEyeO = rotAround(o, lEyeO, ang);\n          \n           // draw the eye\n           vec4 lEye = eye(uv, lEyeO, eyeSize, ang);\n           col = mix(col, lEye.xyz, lEye.w);\n           \n           // same thing as above but for right eye\n           // note that ang is the same, since I want the two eyes to look at the same place\n           eyeVec.y = -eyeVec.y;\n           vec2 rEyeO = o + eyeVec;\n           rEyeO = rotAround(o, rEyeO, ang);\n           vec4 rEye = eye(uv, rEyeO, eyeSize, ang);\n          \n           col = mix(col, rEye.xyz, rEye.w);\n       }\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 164, 164, 257], [259, 259, 314, 314, 568], [571, 571, 594, 594, 654], [656, 753, 796, 796, 858], [860, 904, 925, 925, 958], [960, 960, 991, 991, 1055], [1057, 1174, 1204, 1204, 1298], [1301, 1332, 1376, 1376, 1431], [1433, 1433, 1489, 1489, 3374]], "test": "untested"}
{"id": "7ttBzH", "name": "Dream Mixer", "author": "fenix", "description": "Before dreams are sent out of the factory to your bedroom, they need to be carefully mixed to ensure no lumps remain.\n*mouse to grab/spin the mixer*\n*space to reset* \n*press P to render particles*\n*shift P to also render neighbors*", "tags": ["2d", "voronoi", "simulation", "particles", "bubble", "britney"], "likes": 5, "viewed": 297, "published": 3, "date": "1663226621", "time_retrieved": "2024-07-30T16:30:57.471884", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Honestly the rendering style was originally an accident, but I thought it was cool\n//  enough to keep. I thought I was working on a shader using the \"bubble\" rendering\n//  technique (press P to see this) but I turned it off because it seemed to just distract\n//  from the whirling pattern.\n//\n//  All this is, is a regular voronoi renderer, but instead of rendering the closest\n//  particle to each point, I render the 4th closest particle.\n//\n//  I'm fairly happy with the simulation itself. Developing the bubble shaders forced me\n//  to improve the neighbor search, which probably helped. You can stop the rotation by\n//  grabbing with the mouse, and the particles keep most of their volume, and don't move\n//  too erratically.\n//\n//  In case it's not obvious, I should mention that you can \"throw\" the mixer with the mouse\n//  to impart some velocity (which will eventually damp out to the default clockwise spin).\n//\n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a voronoi search to help out building neighborhoods\n//\n// ---------------------------------------------------------------------------------------\n\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = sqrt(linePointDist2(p.pos, p.pos - p.vel, fragCoord, iResolution, closest));\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n\n    float wd =  2./(min(iResolution.x, iResolution.y));\n    \n    fragColor.xyz = max(fragColor.xyz, (mix(vec3(1), fragColor.xyz, smoothstep(0.0, wd, abs(dist -  min(PARTICLE_REPEL_SIZE*2., p.size))))));\n    \n    // Render neighbor lines\n    if (keyDown(KEY_SHIFT))\n    {\n        for(int i = 0; i < 4; i++){\n            ivec4 neighbors = p.neighbors[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                int cid = neighbors[j];\n                if(cid==-1 || cid >= maxParticles || cid == 0) continue;\n\n                vec2 otherPos = fxGetParticleData(cid, POS_VEL).xy;\n                otherPos.x *= iResolution.y / iResolution.x;\n\n                float distToLin = linePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution, closest);\n                fragColor.xyz += iResolution.x* max(0.0, 0.001 - sqrt(distToLin)) / (0.0004);\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.25); // change pow for modifying the extend of the  vignette\n    fragColor = vec4(vig*.1, vig*.1, vig, 1);\n    \n  \tvec2 p = fragCoord/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    // The complex color pattern comes from computing a traditional voronoi, but then instead of using\n    // the closest particle we choose the fourth closest particle. Change to zero for traditional\n    // voronoi, 1 or 2 for other abstract patterns\n    const int WHICH_NEIGHBOR = 3;\n    int id = ids[WHICH_NEIGHBOR];\n    fxParticle particle = fxGetParticle(id);\n\n    fragColor.xyz = particle.color;\n\n    if (keyDown(KEY_P))\n    {\n        //draw the particles\n        for(int i = 0; i < 4; i++)\n        {\n            //get the particles position\n            int id = ids[i];\n            fxParticle particle = fxGetParticle(id);\n\n            renderParticle(particle, p, fragColor);\n        }\n    }\n    \n    fxState state = fxGetState();\n\n    p.x /= iResolution.y / iResolution.x;\n    fragColor = mix(fragColor, vec4(vig), vec4(clamp(-distanceFromWalls(p, iResolution, state.rotation)*iResolution.y, 0.0, 1.0)));\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 1000; \nconst float PARTICLE_REPEL_SIZE = 0.01;\n\nconst float PI = 3.141592653589793;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return p * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution);\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.x, sc.y, sc.y, -sc.x);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    vec2 c = (point - vec2(.5*resolution.x/resolution.y,  .5))*1.2;\n    float minDist = 1e30;\n    minDist = min(minDist, .5 - length(c));\n    const int NUM_PADDLES = 10;\n    for (int i = 0; i < NUM_PADDLES; ++i)\n    {\n        minDist = min(minDist, sdBox((rot2(time*0.3 + float(i) *2.* PI / float(NUM_PADDLES))*c + vec2(0.0, 0.5)), vec2(0.01, 0.1)));\n    }\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define SIZE 5\n#define COLOR 6\n#define NUM_PARTICLE_DATA_TYPES 7\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    float size;\n    float closestDist;\n    vec3 color;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, SIZE), 0);\n    vec4 particleData6 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, COLOR), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.size = particleData5.x;\n    particle.closestDist = particleData5.y;\n    particle.color = particleData6.xyz;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case SIZE:\n        return vec4(p.size, p.closestDist, 0, 0);\n    case COLOR:\n        return vec4(p.color, 0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nstruct fxState\n{\n    float resolution;\n    float rotation;\n    float velocity;\n    float mouse;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data = texelFetch(sampler, ivec2(0), 0);\n    fxState state;\n    state.resolution = data.x;\n    state.rotation = data.y;\n    state.velocity = data.z;\n    state.mouse = data.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state)\n{\n    return vec4(state.resolution, state.rotation, state.velocity, state.mouse);\n}\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_P 80\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n", "buffer_a_code": "const vec2 GRAVITY = vec2(0.0000, -0.00001);\nconst float PARTICLE_REPEL = 0.0000002;\nconst float VISCOSITY = 0.0000001;\nconst float COLLISION_BOUNCE = 0.6;\nconst float POSITION_CORRECTION = 0.2;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    if (id == 0) return;\n    \n    fxParticle data = fxGetParticle(id);\n    fxState state = fxGetState();\n    \n    if (dataType >= POS_VEL)\n    {\n        if (iFrame == 0 || state.resolution < 0.)\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = (vec2((i + 0.5*(mod(j, 2.0))) / particlesPerRow, j / particlesPerRow) * 0.2 + 0.4) * vec2(iResolution.x / iResolution.y, 1.0);\n            data.vel = vec2(0);\n            data.size = 1e6;\n            \n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y)\n            );\n            \n            data.color = sin(h + vec3(0,4,3)) * vec3(0.3, 0.5, 0.5) + 0.5;\n         }\n        else\n        {\n            vec2 force = GRAVITY;\n            float minDist = 1e6;\n            float minCirc = 1e6;\n\n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    fxParticle n = fxGetParticle(cid);\n                    \n                    vec2 deltaPos = data.pos - n.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    vec2 dir = deltaPos / dist;\n \n                    // Absorb some velocity from nearby particles\n                    force += VISCOSITY * n.vel / square(dist);\n\n                    // Apply SPH attract/repel force\n                    force -= PARTICLE_REPEL * dir * SPHgradKernel(dist / (20.*PARTICLE_REPEL_SIZE));\n\n                    // Repel small neighbors (restores density)\n                    if (data.size < PARTICLE_REPEL_SIZE*.8 && n.size < data.size && n.size > 1e-6 && data.size > 1e-6 && iFrame > 10)\n                    {\n                        force += 9.*(PARTICLE_REPEL_SIZE - data.size) * dir * (data.size - n.size);\n                    }\n                    \n                    // Collide with neighbor\n                    if (dist < PARTICLE_REPEL_SIZE * 2.)\n                    {\n                        data.pos -= dir * (dist - PARTICLE_REPEL_SIZE * 2.) * POSITION_CORRECTION;\n                        float normalVel = dot(dir, data.vel - n.vel);\n                        if (normalVel < 0.)\n                        {\n                            data.vel -= COLLISION_BOUNCE * dir * normalVel;\n                        }\n                    }\n\n                    // Record some data for size computation\n                    minDist = min(minDist, dist*0.5);\n                    minCirc = min(minCirc, max(dist*0.5, 0.5*(dist - n.size)));\n                }\n            }       \n \n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Record computed size\n            data.closestDist = minDist;\n            data.size = minCirc;\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, state.rotation);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, state.rotation - state.velocity);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, state.rotation);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= 1.3 * distNormal * min(0., dot(distNormal, data.vel));\n            }\n            \n            // Damping\n            data.vel -= data.vel * 0.003;\n\n            // Clamping\n            float maxSpeed = 1.; // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                //data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos * vec2(iResolution.y / iResolution.x, 1.0))));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(data.neighbors[0][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[1][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[2][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[3][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            //int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n            //pick random id of particle\n            int p = int(mod(h*3434534.0, float(MAX_PARTICLES)));\n            sort0(bestIds, bestDists, id, int(p), dataType, data.pos);  //sort this\n        }\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 || id >= MAX_PARTICLES ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    if (iFragCoord == ivec2(0))\n    {\n        fxState state = fxGetState();\n        \n        if (iFrame == 0 || iResolution.x * iResolution.y != abs(state.resolution) || keyDown(KEY_SPACE))\n        {\n            state.resolution = -iResolution.x * iResolution.y;\n            state.velocity = state.rotation = 0.0;\n        }\n        else\n        {\n            state.resolution = abs(state.resolution);\n            \n            // Apply acceleration and damping\n            state.velocity += 0.0001;\n            state.velocity *= 0.99;\n            \n            // Handle mouse input\n            if (iMouse.z > 0.)\n            {\n                if (iMouse.w > 0.)\n                {\n                    state.velocity = 0.;\n                    state.mouse = iMouse.x + iMouse.y;\n                }\n                else\n                {\n                    state.velocity = clamp(4.*(state.mouse - iMouse.x - iMouse.y) / iResolution.x, -0.1, 0.1);\n                    state.mouse = iMouse.x + iMouse.y;\n                }\n            }\n            \n            // Integrate rotation\n            state.rotation += state.velocity;\n        }\n        \n        fragColor = fxPutState(state);\n        return;\n    }\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n    \n    ivec4 old   = fxGetClosest( iFragCoord );      \n\n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, screen2world(fragCoord));\n        insertion_sort( new, dis, id, dis2 );\n    }\n    \n    // Search randomly in the nearest 15x15 neighbors instead of just\n    // the next-door neighbors. Seems to allow faster particle movement\n    uint searchRange = 15u;\n    uint searchCount = 16u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, screen2world(fragCoord));\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++)\n    {\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttBzH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1360, 1360, 1439, 1439, 2607], [2609, 2609, 2663, 2756, 4196]], "test": "untested"}
{"id": "NlVyWt", "name": "Modelo Ernesto C. R.", "author": "mbaernestocr", "description": "Shader simulating bull run in crypto. Point of this shader is to induce adrenaline or euphoria in you. If you feel it, then you are probably a trader. Fork of Crypto bull.", "tags": ["finance", "crypto", "stocks", "trading", "bullrun"], "likes": 3, "viewed": 184, "published": 3, "date": "1663225547", "time_retrieved": "2024-07-30T16:30:58.221879", "image_code": "float curve(in vec2 p, in float fy, in float minLimit, in float maxLimit) {\n    \n    if(p.x < minLimit)\n        return 0.;\n    \n    if(p.x > maxLimit)\n        return 0.;\n    \n    float d = 1. - 150.*abs(p.y - fy);\n    \n    d = clamp(d, 0., 1.);\n    \n    return d;\n}\nfloat gR = 1.61;\n\nfloat nSin(in float t) {\n    \n\treturn 0.5 + 0.5 * sin(t);   \n}\n\nfloat glowingPoint(in vec2 uv, in vec2 pos, in float size) {\n    \n    float dist = distance(uv, pos);\n    \n    float d = (1. - (1./(1.*size)) *dist);\n    \n    \n    \n    d = clamp(d, 0., 1.);\n    \n    d = sqrt(sqrt(d));\n    \n    //d = (d + d*d) / 2.;\n    \n    return d;\n}\n\nfloat speed = 0.15;\nfloat trend = +1.5;\nfloat stockFunction(in float x) {\n    \n    float t = x + iTime * speed;\n    \n    float f0 = 6.28;\n    float f1 = 3.68;\n    float f2 = 13.28;\n    float f3 = 32.43;\n    float f4 = 123.;\n    float f5 = 331.;   \n    float f6 = 730.;    \n    float f7 = 1232.;\n    \n    \n    float s0 = sin(f0 * t) * 0.4;\n    float s1 = sin(f1 * t) * 0.2;\n    float s2 = sin(f2 * t) * 0.1;\n    float s3 = cos(f3 * t) * 0.15;\n    float s4 = sin(f4 * t) * 0.1;\n    float s5 = sin(f5 * t) * 0.05;\n    float s6 = sin(f6 * t) * 0.035;\n    float s7 = sin(f7 * t) * 0.02;\n    \n    float wave = s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7;\n    \n    float mod = mod(s1 * s2, 0.1 ) * (5.*sqrt(nSin(f0*t)));\n    \n    float final = wave + mod;\n    \n    float fy = -trend / 1.5 + (trend)*x  - 0.5*final;\n    \n    return fy / 5.;\n}\n\n//derivative\nfloat d_stockFunction(in float x, in float delta) {\n    \n    float x0 = x;\n    float x1 = x - delta;\n    \n    float y0 = stockFunction(x0);\n    float y1 = stockFunction(x1);\n    \n    return (y1 - y0) / delta;\n}\n\nfloat longTrend(in float x) {\n    \n    float trend0 = d_stockFunction(x, 0.025);\n    float trend1 = d_stockFunction(x, 0.05);\n    float trend2 = d_stockFunction(x, 0.1);\n    \n    float finalTrend = trend0 + trend1 + trend2;\n    \n    return finalTrend / 3.;\n}\n\nfloat shortTrend(in float x) {\n    \n    float trend0 = d_stockFunction(x, 0.0040);\n    float trend1 = d_stockFunction(x, 0.0050);\n    float trend2 = d_stockFunction(x, 0.0060);\n    \n    float finalTrend = trend0 + trend1 + trend2;\n    \n    return finalTrend / 3.;\n}\n\n\nvec3 trendColor(in float trend) {\n    \n    vec3 red   = vec3(1., 0., 0.);   \n    vec3 green = vec3(0., 1., 0.);\n    \n    trend *= 100.;\n    \n    trend = atan(trend) / (1.57079632679);\n    trend += 1.;   \n    trend /= 2.;\n        \n    return mix(green, red, trend);\n}\n\nfloat grid(in vec2 uv, float tileSize, float borderSize) {\n\n    float xMod = mod(uv.x, tileSize);\n    float yMod = mod(uv.y, tileSize); \n    \n    float treshold = borderSize;\n    \n\tif(xMod < treshold || yMod < treshold)\n        return 1.;\n    \n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;   \n    \n    uv.y = uv.y - .33;\n    \n    vec3 points;\n    \n    float size = 0.025;\n    \n    float start = 0.9;\n    float end = 0.85;\n\n    float delta = end - start;\n    \n    //x20\n    for(float offset = 0.; offset < 1. ; offset += 0.05) {\n    \n        float pos = start + delta * offset; \n        \n        vec3 pColor = glowingPoint(uv, vec2(pos, stockFunction(pos)),  size) * trendColor(longTrend(pos));\n        \n        points = max(points, pColor);       \n        size *= 0.92;\n    }\n    \n    \n    vec3 line = trendColor(shortTrend(uv.x)) * curve(uv, stockFunction(uv.x), 0., start);\n    \n    vec2 gridOffset = vec2(iTime * speed, + iTime * speed * trend/5.);\n    vec3 background = vec3(1.,1.,1.) * grid(uv + gridOffset, 0.2, 0.002);\n    \n    vec3 color = max(line, points) + background * 0.05;\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 75, 75, 265], [284, 284, 308, 308, 346], [348, 348, 408, 408, 618], [660, 660, 693, 693, 1448], [1450, 1463, 1514, 1514, 1673], [1675, 1675, 1704, 1704, 1933], [1935, 1935, 1965, 1965, 2200], [2203, 2203, 2236, 2236, 2469], [2471, 2471, 2529, 2529, 2731], [2733, 2733, 2790, 2790, 3665]], "test": "untested"}
{"id": "ftdfW8", "name": "Anaglyph Sphere Waves", "author": "derSchamane", "description": "I tested a transparent 3D raymarching idea and found some sacred patterns.\nEnjoy an extra dimension with your red/cyan glasses on and drag the mouse to rotate the cam.\n\nSubstance Reference: 5-MeO-MiPT", "tags": ["3d", "dof", "spheres", "anaglyph", "stereo"], "likes": 4, "viewed": 405, "published": 3, "date": "1663202360", "time_retrieved": "2024-07-30T16:30:58.960903", "image_code": "//                  = Anaglyph Sphere Waves =         \n//                by Maximilian Knape ·∑>| 2022            \n// -----------------------------------------------------------\n// This work is licensed under a Creative Commons Attribution-\n//        NonCommercial-ShareAlike 3.0 Unported License\n\n// In the end there is just a moving sphere in a mirror box...\n\n\n#define MAX_STEPS 200\n#define MAX_DIS 400.\n#define MIN_DIS 10.\n\n#define SURF_DIS .01\n#define SURF_MUL 100.\n#define SURF_EXP 2.\n\n#define EYE_DIS 1.0\n#define FIL_COR 1.05\n\n#define iTime iTime*.6\n\nmat2 Rot(float a)  \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Dist(vec3 p) \n{\n    //cam rotation\n    float q = min(iTime/200., 5.);\n    float c = 0.2 / (1.+q/3.);\n    p.yx *= Rot(.7854*smoothstep(0.,c+c,-cos(iTime/(23.+q))));\n    p.zx *= Rot(.7854*smoothstep(-c,c+c,-cos(iTime/(11.+q))));\n    p.zy *= Rot(.7854*smoothstep(c,c+c,-cos(iTime/(45.+q))));\n\n    //distance frequency\n    float f = 1./(400.+sin(iTime/13.)*200.+sin(iTime/19.)*100.);\n    float dis = length(p)*f;\n    \n    //mirrorbox\n    vec3 size = vec3(10.);\n    p = mod(abs(-mod(p,4.*size)+2.*size),4.*size);\n    \n    //sphere\n    float d = length(p - sin(iTime*.5+dis*6.28)*size.x-size) - \n              10.*(sin(iTime*1.+dis*6.28)*.5+.8)*pow(dis/f/MAX_DIS, 1.2) *\n              (1.+smoothstep(0.9,1.,sin(iTime/2.+dis/f/200.))); \n\n    return d;\n}\n\nfloat RTM(vec3 ro, vec3 rd) \n{\n    float sum = 0.;\n\tfloat s = 1.;\n    float d = MIN_DIS;\n    const float a = 1. / float(MAX_STEPS); \n    \n    for(int i = 0; i < MAX_STEPS; i++) \n    {    \n        float sd = (SURF_DIS * (pow(d/MAX_DIS, SURF_EXP)*SURF_MUL+1.));\n        if (s < sd || d > MAX_DIS) break;\n        \n        s = Dist(ro + rd*d);\n        s = max(abs(s), 2.*sd);\n        d += s * .8;\n        sum += a;\n    }\n    \n    return smoothstep(0., 1., sum * (1.-exp(-d*d)));\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n\t\n    //interaction\n    vec2 m = iMouse.xy / iResolution.xy;\n    if (length(m) == 0.) m = vec2(.5);\n    m.x = clamp(m.x, .1, .9);\n    m.y = clamp(m.y, .25, .75);\n    \n    //set cam\n    vec3 ro = vec3( 0., 0., -15.);\n    ro.yz *= Rot(-m.y*3.14159 + 1.5708);\n    ro.xz *= Rot(-m.x*6.28318);\n    vec3 rd = R(uv, ro, vec3(0., 0., 0.), .7 + 0.4*smoothstep(.6,.9,sin(iTime/16.)));\n    ro += normalize(cross(rd, vec3(0., -1., 0.))) * EYE_DIS * -.5;\n    \n    //left eye\n    float colL = RTM(ro, rd);\n    \n    //eye distance\n    ro += normalize(cross(rd, vec3(0., -1., 0.))) * EYE_DIS;\n    \n    //right eye\n    float colR = RTM(ro, rd);\n    \n    //filter correction\n    colL *= FIL_COR; \n    colR /= FIL_COR;\n    \n    //contrast\n    vec3 colS = smoothstep(vec3(0.), vec3(1.), vec3(colL, colR, colR));\n    \n    //Vignette\n    colS *= smoothstep(2.,-2./5., dot(uv,uv)); \n    \n    fragColor = vec4(colS, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdfW8.jpg", "access": "api", "license": "unknown-license-reference", "functions": [[560, 560, 581, 581, 657], [659, 659, 680, 699, 1411], [1413, 1413, 1443, 1443, 1889], [1891, 1891, 1933, 1933, 2128], [2130, 2130, 2187, 2187, 3147]], "test": "untested"}
{"id": "sldBW7", "name": "green screen shader", "author": "Stilic", "description": "epic way to remove the silly green from a video!!!", "tags": ["video", "screen", "blending", "green"], "likes": 2, "viewed": 437, "published": 3, "date": "1663195636", "time_retrieved": "2024-07-30T16:30:59.701921", "image_code": "// Based off https://jameshfisher.com/2020/08/11/production-ready-green-screen-in-the-browser/\n\n// From https://github.com/libretro/glsl-shaders/blob/master/nnedi3/shaders/rgb-to-yuv.glsl\nvec2 RGBtoUV(vec3 rgb) {\n  return vec2(\n    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,\n    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 texCoord = fragCoord.xy / iResolution.xy;\n\n  vec4 rgba = texture(iChannel0, texCoord);\n  float chromaDist = distance(RGBtoUV(texture(iChannel0, texCoord).rgb), RGBtoUV(vec3(0.0, 1.0, 0.0)));\n\n  // For similarity\n  float baseMask = chromaDist - 0.46;\n  // For smoothness\n  float fullMask = pow(clamp(baseMask / 0.08, 0., 1.), 1.5);\n  rgba.a = fullMask;\n\n  // For spill\n  float spillVal = pow(clamp(baseMask / 0.1, 0., 1.), 1.5);\n  float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.);\n  rgba.rgb = mix(vec3(desat, desat, desat), rgba.rgb, spillVal);\n  fragColor = rgba;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldBW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 188, 212, 212, 355], [357, 357, 412, 412, 1018]], "test": "untested"}
{"id": "sltfDM", "name": "dark room", "author": "jorge2017a2", "description": "dark room\n\n", "tags": ["darkroom"], "likes": 2, "viewed": 268, "published": 3, "date": "1663188407", "time_retrieved": "2024-07-30T16:31:00.445932", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 255.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n//dark room--14-sep-2022\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n     p.y=p.y+10.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    float planeDist2 = 50.0-p.y;  //piso sup\n    float planeDist3 = p.x+40.0; //pared izq\n    float planeDist4 = 40.0-p.x;  //pared der\n    float planeDist5 = -p.z+50.0;  //pared frente\n    float planeDist6 = p.z+50.0;  //pared atras\n    res =opU2(res, vec2(planeDist1,57.0));\n    p.y=p.y-8.0;\n    p.z-=30.0;\n    float d1a;\n    float t=iTime+2.5;\n    if(5.0*sin(t+2.0*cos(t*0.5))>0.0)\n     d1a= sdBox(p-vec3(0.0,0.0,5.0), vec3(18.0,14.0,40.0) );\n    else\n     d1a= sdBox(p-vec3(0.0,0.0,0.0), vec3(18.0,14.0,40.0) );\n    \n    float d1b= sdBox(p, vec3(17.0,13.0,42.0) );\n    \n    float ddif1= Difference(d1a,d1b);\n    float d2=sdSphere(p-vec3(0.0,abs(5.0*sin(iTime)),0.0) , 5.0 );\n    float d3=sdSphere(p-vec3(10.0,0.0,0.0), 5.0 );\n    res =opU2(res, vec2(ddif1,1.0));\n    res =opU2(res, vec2(d2,41.0));\n    res =opU2(res, vec2(d3,100.0));\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat FakeSoftShadow(float result, vec3 LightPos,vec3 point,vec3 normal)\n{   vec3 shadowOffset = normal * 0.2 ;\n    int epoch = 5;\n    \n    float delta = result/float(epoch-1);\n    float lightOffset = 0.2;\n    float dis;\n    for(int i = 0; i<epoch; i++)\n    {   vec3 tmp = LightPos +vec3(0,0,i)*lightOffset;\n        dis=RayMarch(point + shadowOffset,normalize(tmp-point), int( MAX_DIST/10.)).x;\n        if (dis< length(tmp-point))\n        {  result -= delta; }\n    }\n    return result;\n}\n\nfloat ShadingLVNHR(vec3 LightPos, vec3 pos, vec3 L, vec3 V, vec3 N, vec3 H, vec3 R)\n{\n    float Ambient = 0.5;       \n    float result = max(dot(L,N),0.0)*0.5 + pow(max(dot(H,N),0.0),20.)*0.9;\n   result = FakeSoftShadow(result, LightPos,pos,N);\n    return result+Ambient;\n        \n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//iq cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n\n    vec3 L = normalize (lightPos - p);\n    vec3 V = normalize(ro - p);\n    vec3 N = normal;\n    vec3 H = normalize(L+V);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    \n    float shadow=ShadingLVNHR(lightPos,p,L, V,N,H,R);\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 )\n    { col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel1, p/32., nor); }\n\tif (i==102 ) { return tex3D(iChannel2, p/32., nor); }\n\tif (i==103 ) { return tex3D(iChannel3, p/32., nor); }\n    return vec3(0.0);\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    return sky;\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.45);\n    vec3 col2 = 0.5 * cos(iTime + uv.xyx*0.05 + vec3(0,2,4));  \n    col += 0.5*smoothstep(-0.05,0.06,cos(uv.x*0.4)*cos(uv.y*0.4))*col2; // color piso\n    col *= smoothstep(-1.0,-0.95,cos(uv.x*0.8))*smoothstep(-1.0,-0.95,cos(uv.y*0.8)) ;\n    return col;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n     \n     if (id_color==41)\n     {  vec3 colp = palette( sin(21.29*0.25), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n        return colp;        \n     }\n\n    if (id_color==57) { return pattern( p.xz );}\n    if (id_color==58) {return pattern( p.xy );}\n    if (id_color==59) {return pattern( p.zy );}\n  \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n  return vec3(0.0);\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n  float multc=1.0;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n        \n        float t=iTime+3.0;\n        if(int(hit.y)==1   )\n        { multc=0.3+0.2*sin(t+cos(t)+1.0); }\n        \n        if( int(hit.y)==100 || int(hit.y)==41 )\n        { multc=0.650+0.2*sin(t+cos(t)); }\n        \n        \n        result=  lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1*multc;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2*multc;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n//https://www.shadertoy.com/view/7dKfRt\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nmat3 cameraToWorld(vec3 ro,vec3 lookAt){\n    vec3 a = normalize(lookAt - ro);\n    vec3 b = cross(vec3(0.,1.,0),a);\n    vec3 c = cross(a,b);\n    return mat3(b,c,a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n     vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n\n    vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n   \n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n\n    light_pos1= vec3(-10.0, 50.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n    //light_pos2= vec3(10.0, 15.0+15.0*sin(t0), 0.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n \tlight_pos2= vec3(10.0, 15.0, 0.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n  \n   vec3 ro=vec3(0.0,-2.0,-25.0+15.0*sin(t0-cos(t0*0.5)+1.5) );\n    vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n     ///light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sltfDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[487, 487, 523, 523, 544], [545, 545, 577, 577, 661], [663, 663, 707, 707, 734], [735, 735, 775, 775, 802], [803, 803, 848, 848, 876], [878, 878, 903, 903, 1872], [1874, 1874, 1898, 1898, 2060], [2062, 2062, 2110, 2110, 2389], [2391, 2391, 2465, 2465, 2878], [2880, 2880, 2965, 2965, 3162], [3164, 3164, 3208, 3208, 3529], [3531, 3531, 3568, 3568, 3825], [3827, 3868, 3940, 3940, 3983], [3985, 3985, 4075, 4075, 5086], [5088, 5088, 5137, 5137, 5411], [5413, 5413, 5445, 5445, 5645], [5647, 5695, 5723, 5723, 6003], [6005, 6005, 6075, 6075, 6605], [6607, 6607, 6634, 6634, 6723], [6725, 6725, 6783, 6783, 6831], [6833, 6833, 6856, 6856, 6968], [6971, 6971, 7002, 7002, 7890], [7892, 7932, 7979, 7979, 8192], [8194, 8194, 8234, 8234, 8359], [8361, 8361, 8418, 8418, 9103]], "test": "untested"}
{"id": "stdfW4", "name": "Raymarcher with soft shadows", "author": "fishy", "description": "It works. @FifthStateOfMatter helped me some. Mouse to control light direction. Lacks some important features (like color) but maybe I'll add those later.", "tags": ["shadow", "raymarcher", "penumbra", "diffuse"], "likes": 1, "viewed": 247, "published": 3, "date": "1663186851", "time_retrieved": "2024-07-30T16:31:01.213879", "image_code": "struct material\n{\n    vec3 baseColor;\n};\n\nfloat join(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat sdPlane(vec3 p, float y)\n{\n    return p.y - y;\n}\n\nfloat sdSphere(vec3 p, vec3 pos, float r)\n{\n    return length(p - pos) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( vec3 p, vec3 b, vec3 bPos )\n{\n    return sdBox(p - bPos, b);\n}\n\nfloat sceneDist(vec3 p)\n{\n    vec3 material = vec3(0.0, 0.0, 0.0);\n    float dist = sdSphere(p, vec3(0.3, 0.0, 2.0), 0.2);\n    dist = join(dist, sdSphere(p, vec3(-0.3, 0.0, 2.0), 0.2));\n    dist = join(dist, sdBox(p, vec3(0.5, 0.1, 0.5), vec3(0.0,-0.3, 2.0)));\n    dist = join(dist, sdPlane(p, -0.3));\n    return dist;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneDist( p + k.xyy*h ) + \n                      k.yyx*sceneDist( p + k.yyx*h ) + \n                      k.yxy*sceneDist( p + k.yxy*h ) + \n                      k.xxx*sceneDist( p + k.xxx*h ) );\n}\n\nvoid march(vec3 dir, inout vec3 p, int maxSteps, float minDist, out bool hit, out float depth, out vec3 normal)\n{\n    vec3 oldP = p;\n    depth = 0.0;\n    for(int i = 0; i < maxSteps; i++)\n    {\n        depth = sceneDist(p);\n        p += depth*dir;\n        hit = depth < minDist;\n        if(hit)\n        {\n            normal = calcNormal(p);\n            depth = distance(oldP, p);\n            return;\n        }\n    }\n    normal = calcNormal(p);\n}\n\nvoid marchShadow(vec3 dir, vec3 p, int maxSteps, float minDist, out float inShadow, float k)\n{\n    vec3 oldP = p;\n    float dist = 0.002;\n    float totalDist = dist;\n\n    p += dist*dir;\n    inShadow = 1.0;\n    for(int i = 0; i < maxSteps; i++)\n    {\n        dist = sceneDist(p);\n        totalDist += dist;\n\n        if(dist < minDist)\n        {\n            inShadow = 1.0;\n            return;\n        }\n        \n        p += dist*dir;\n        inShadow = min(inShadow, k*dist/totalDist);\n    }\n    inShadow = 1.0-inShadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n\n    vec3 eyeDir = normalize(vec3(uv * vec2(1.0, 1.0), 1.0));\n    vec3 eyePos = vec3(0.0, 0.0, 0.0);\n    vec2 mouse = iMouse.z > 0.0?iMouse.xy/iResolution.xy - 0.5 : vec2(sin(iTime), cos(iTime) + 2.0);\n    vec3 lightingDir = normalize(vec3((mouse) * vec2(1.0, iResolution.y/iResolution.x) * 10.0, -1.0));\n    \n    bool hit = false;\n    float depth = 0.0;\n    vec3 normal = vec3(0.0);\n    march(eyeDir, eyePos, 512, 0.0001, hit, depth, normal);\n    \n    float inShadow = 0.0;\n    marchShadow(lightingDir, eyePos, 64, 0.00001, inShadow, 4.0);\n    \n    //lightingDir = vec3(0.0, 1.0, 0.0);\n    float lighting = max(0.0, dot(normal, lightingDir));\n    lighting *= (1.0-inShadow) + 0.5;\n    lighting /= 1.5;\n\n    //fragColor = vec4(vec3(depth/8.0),1.0);\n    fragColor = vec4(vec3(lighting),1.0);\n    //fragColor = vec4(eyeDir.xy,0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdfW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 72, 72, 96], [98, 98, 130, 130, 152], [154, 154, 197, 197, 231], [233, 233, 264, 264, 355], [357, 357, 399, 399, 432], [434, 434, 459, 459, 754], [756, 756, 807, 807, 1127], [1129, 1129, 1242, 1242, 1574], [1576, 1576, 1670, 1670, 2098], [2100, 2100, 2157, 2207, 3140]], "test": "untested"}
{"id": "ftdfDM", "name": "Maptoy 1.1.0", "author": "iY0Yi", "description": "This is a \"Maptoy\" template.\nI wanted an editor dedicated to distance functions, so I created it in Shadertoy.\nYou can bookmark this page, fork, and edit it.\nI've tried to keep everything but the map functions in the Common tab.", "tags": ["maptoy"], "likes": 40, "viewed": 691, "published": 3, "date": "1663172152", "time_retrieved": "2024-07-30T16:31:02.153367", "image_code": "/*\n   __  __    __    ____  ____  _____  _  _ \n  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n\n  Version: 1.1.0\n\n  This is a \"Maptoy\" template.\n  I wanted an editor dedicated to distance functions,\n  so I created it in Shadertoy.\n  You can bookmark this page, fork, and edit it.\n  I've tried to keep everything but the map functions\n  in the Common tab.\n\n  Hotkeys:\n  -------------------------------------------------------------\n   1   | Camera: Front\n  -------------------------------------------------------------\n   3   | Camera: Side\n  -------------------------------------------------------------\n   7   | Camera: Top\n  -------------------------------------------------------------\n   0   | Camera: Free (release specific views above.)\n  -------------------------------------------------------------\n   W/S | Camera: Zoom +/-\n  -------------------------------------------------------------\n   Q   | ViewMode: Quad view\n  -------------------------------------------------------------\n   T   | ViewMode: Turntable\n  -------------------------------------------------------------\n   I   | Debug: ISO line\n  -------------------------------------------------------------\n   C   | Debug: Cost\n  -------------------------------------------------------------\n   N   | Debug: Normal\n  -------------------------------------------------------------\n   M   | Debug: Matcap (overwrite the Normal debug drawing.)\n  -------------------------------------------------------------\n*/\n\nfloat map(vec3 p){\n    return length(p)-.5;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "uniform vec3 iWheel;\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\nfloat opUniS(float a,float b,float r){\n\tfloat h = max(r-abs(a-b),0.)/r;\n    return min(a,b)-h*h*h*r*(1./6.);\n}\n\nfloat sdCapsule(vec3 p, float h, float r){\n  p.y=abs(p.y);\n  p.y-=clamp(p.y,0.,h);\n  return length(p)-r;\n}\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 30.\n#define STEP_MAX 100\n\n// Markers: 8 colors\n#define cRED     vec3(0xe1U, 0x2aU, 0x0cU)/255.\n#define cGREEN   vec3(0x35U, 0xb8U, 0x51U)/255.\n#define cPURPLE  vec3(0xbdU, 0x6aU, 0xb0U)/255.\n#define cYELLOW  vec3(0xf2U, 0xdeU, 0x01U)/255.\n#define cORANGE  vec3(0xf5U, 0x9dU, 0x04U)/255.\n#define cCOBALT  vec3(0x61U, 0x75U, 0xbdU)/255.\n#define cBLUE    vec3(0x26U, 0xb9U, 0xf0U)/255.\n#define cBLACK   vec3(0x64U, 0x52U, 0x40U)/255.\n\nfloat tRED = 1.;\nfloat tGREEN = 1.;\nfloat tPURPLE = 1.;\nfloat tYELLOW = 1.;\nfloat tORANGE = 1.;\nfloat tCOBALT = 1.;\nfloat tBLUE = 1.;\nfloat tBLACK = 1.;\n#define RED(v) tRED = step(DIST_MIN*10., v)\n#define GREEN(v) tGREEN = step(DIST_MIN*10., v)\n#define PURPLE(v) tPURPLE = step(DIST_MIN*10., v)\n#define YELLOW(v) tYELLOW = step(DIST_MIN*10., v)\n#define ORANGE(v) tORANGE = step(DIST_MIN*10., v)\n#define COBALT(v) tCOBALT = step(DIST_MIN*10., v)\n#define BLUE(v) tBLUE = step(DIST_MIN*10., v)\n#define BLACK(v) tBLACK = step(DIST_MIN*10., v)\n\n#define INIT_CAM_POS vec3(2,-1,2)*2.\n#define CAM_DIST 2.\n#define CAM_INIT_SCALE 1.25\n#define TURN_TABLE_SPEED .25\n\n/*\n   __  __    __    ____  ____  _____  _  _ \n  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n\n  Version: 1.1.0\n\n  This is a \"Maptoy\" template.\n  I wanted an editor dedicated to distance functions,\n  so I created it in Shadertoy.\n  You can bookmark this page, fork, and edit it.\n  I've tried to keep everything but the map functions\n  in the Common tab.\n\n  Hotkeys:\n  -------------------------------------------------------------\n   1   | Camera: Front\n  -------------------------------------------------------------\n   3   | Camera: Side\n  -------------------------------------------------------------\n   7   | Camera: Top\n  -------------------------------------------------------------\n   0   | Camera: Free (release specific views above.)\n  -------------------------------------------------------------\n   W/S | Camera: Zoom +/-\n  -------------------------------------------------------------\n   Q   | ViewMode: Quad view\n  -------------------------------------------------------------\n   T   | ViewMode: Turntable\n  -------------------------------------------------------------\n   I   | Debug: ISO line\n  -------------------------------------------------------------\n   C   | Debug: Cost\n  -------------------------------------------------------------\n   N   | Debug: Normal\n  -------------------------------------------------------------\n   M   | Debug: Matcap (overwrite the Normal debug drawing.)\n  -------------------------------------------------------------\n*/\n\n/*\n  Update:\n\n  1.1.0 @ 2022/09/14 \n      - Fixed long compilation in Quad view.\n      - Many of the features went to hotkeys from #defines.\n\n  1.0.4 @ 2021/11/03    \n      - Added Isoline draw.\n\n  1.0.3 @ 2021/10/22    \n      - Added Matcap debug mode.\n\n  1.0.2 @ 2021/10/20    \n      - Added Quad view mode.\n\n  1.0.1 @ 2021/10/15    \n      - Added Axis draw.\n      - Added Hotkeys for Camera View angle.\n      ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n\n  1.0.0 @ 2021/10/14   \n      - Released.\n*/\n\n\n// Theme\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define THM_BACKGROUND (vec3(1,.95,.9)*.8)\n#define THM_GRID (vec3(.1,.2,.25)*1.7)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(1)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist){\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr ){\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc char(U,64+CAPS+c);\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\nvec3 mouse=vec3(0);\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_TARGET_X vec2(14,0)\n#define C_TARGET_Y vec2(16,0)\n#define C_TARGET_Z vec2(18,0)\n#define C_DEBUG_ISO vec2(20,0)\n#define C_DEBUG_COST vec2(22,0)\n#define C_DEBUG_MATCAP vec2(24,0)\n#define C_DEBUG_NORMAL vec2(26,0)\n\n#define render() \\\nbool isTurntable = true;\\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nfloat char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ){char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;}\\\n    return 0.;\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=min(0,iFrame); i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=min(0,iFrame); i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 target = vec3(fetch(C_TARGET_X).x,fetch(C_TARGET_Y).x,fetch(C_TARGET_Z).x);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5) && num==0)\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && isTurntable)\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED+PI*.25), 1, cos(iTime*TURN_TABLE_SPEED+PI*.25))*INIT_CAM_POS) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(target-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST+iWheel.y*.0005;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = target-pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(fetch(C_DEBUG_NORMAL).x>.5)col = (n*.5+.5)*.5;\\\n        if(fetch(C_DEBUG_MATCAP).x>.5){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    float vx = 1., vy = 1., vz = 1.;\\\n    if(num==1) vx=0.,vz=0.;\\\n    if(num==7) vx=0.,vy=0.;\\\n    if(num==3) vy=0.,vz=0.;\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz)*1.5;\\\n    if((fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx*vx+gy*vy+gz*vz);\\\n    if(fetch(C_DEBUG_COST).x>.5)\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(4.2)), g);\\\n    if(fetch(C_DEBUG_ISO).x>.5) {\\\n        vec4 n;\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(num!=3 && axisX>0. && (fetch(C_DEBUG_ISO).x>.5 || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(num!=7 && axisY>0. && (fetch(C_DEBUG_ISO).x>.5 || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(num!=1 && axisZ>0. && (fetch(C_DEBUG_ISO).x>.5 || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col*= (tRED<.5)?cRED:vec3(1);\\\n    col*= (tGREEN<.5)?cGREEN:vec3(1);\\\n    col*= (tPURPLE<.5)?cPURPLE:vec3(1);\\\n    col*= (tYELLOW<.5)?cYELLOW:vec3(1);\\\n    col*= (tORANGE<.5)?cORANGE:vec3(1);\\\n    col*= (tCOBALT<.5)?cCOBALT:vec3(1);\\\n    col*= (tBLUE<.5)?cBLUE:vec3(1);\\\n    col*= (tBLACK<.5)?cBLACK:vec3(1);\\\n    col = mix(col, pow(1.-THM_GRID,vec3(2.2)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    isTurntable = fetch(C_TURN_TABLE).x<.5;\\\n    float scale = 1.;\\\n    vec2 offset=vec2(0);\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    mouse = (vec3(iMouse.xy/iResolution.xy,.5)*2.)-1.;\\\n    if(num==1)mouse = mouse.xyz;\\\n    if(num==3)mouse = mouse.zyx;\\\n    if(num==7)mouse = mouse.xzy;\\\n    if(num==0)mouse = vec3(.0001);\\\n    vec3 Res = vec3(iResolution.xy, 0);\\\n    if(fetch(C_QUAD_VIEW).x>.5){\\\n        scale = 2.;\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {isTurntable=false;forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {isTurntable=false;forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n    }\\\n    fragColor = vec4(renderRect(fragCoord*scale-offset),1);\\\n    if(fetch(C_QUAD_VIEW).x>.5 &&\\\n    ((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) ||\\\n    (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.)))\\\n    fragColor = vec4(pow(1.-THM_GRID,vec3(2.2)),1);\\\n    drawDebug(fragColor);\\\n}int dummy\\\n", "buffer_a_code": "/*\n  User Inputs\n\n  References:\n  \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n  \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n  \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n  \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n  Shows how to use the mouse input (only left button supported):\n       mouse.xy  = mouse position during last button down\n   abs(mouse.zw) = mouse position during last button click\n  sign(mouze.z)  = button is down\n  sign(mouze.w)  = button is clicked\n  \n*/\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\nconst int K_X = 88;\nconst int K_Y = 89;\nconst int K_Z = 90;\n\nconst int K_SHIFT = 16;\nconst int K_CTRL = 17;\nconst int K_ALT = 18;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 O, in vec2 C ){\n\n    if(iFrame < 2 ){O = vec4(0);return;}\n    \n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){O = (sign(iMouse.z)>.0) ? iMouse : last;return;}\n    \n    if(ID(C_CAMERA)){\n        O = last;\n        bool isFreeCamera = bool(last.y);\n        if((getKeypress(K_NUM_0)||getKeypress(K_PAD_0)) && sign(iMouse.z)<=.0)O = vec4(0, 0, 0, 0);\n        if(getState(K_NUM_1)||getState(K_PAD_1))O = vec4(1, true, 0, 0);\n        if(getState(K_NUM_3)||getState(K_PAD_3))O = vec4(3, true, 0, 0);\n        if(getState(K_NUM_7)||getState(K_PAD_7))O = vec4(7, true, 0, 0);\n        return;}\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        O = last;\n        return;}\n    \n    if(ID(C_TARGET_X)){\n        if(getState(K_X) &&  getState(K_ALT))last+=.01;\n        if(getState(K_X) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n        \n    if(ID(C_TARGET_Y)){\n        if(getState(K_Y) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Y) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n            \n    if(ID(C_TARGET_Z)){\n        if(getState(K_Z) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Z) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n    if(ID(C_QUAD_VIEW))   {O = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE))  {O = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO))   {O = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST))  {O = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){O = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){O = vec4(getToggle(K_N));return;}\n    \n    // blank pixel\n    O = vec4(0,0,1,1);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdfDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1557, 1557, 1575, 1575, 1602]], "test": "untested"}
{"id": "7l3BWM", "name": "Bokeh filter of net pattern", "author": "FabriceNeyret2", "description": "Comparing the effect of Bokeh ( disc vs Gaussian vs ring ) on a net pattern.\nDepth of Fied = either X or Mouse.x \n\nNote: you can go faster by lowering dens.  Or just stop the shader and mouse tune ;-)", "tags": ["dof", "bokeh"], "likes": 10, "viewed": 490, "published": 3, "date": "1663164249", "time_retrieved": "2024-07-30T16:31:02.909346", "image_code": "// variant from https://shadertoy.com/view/ft3fDM\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    int T = int(iTime)%3;\n    float w, t=0., d2,  \n         dof = 38.*( iMouse.z > 0. ? iMouse.x : U.x ) / R.x, // depth of field → current radius\n         dens = 8.,                                          // sampling density\n         N = clamp( dens*dof*dof , 8., 1e4 );                // sampling ~ disk area\n    O-=O;\n    for( float i=0.; i < N; i++ ) {\n        vec2 dP = vec2(cos(i*2.4),sin(i*2.4)) * sqrt(i/N);   // Vogel disc sampling ( 2.39996 )\n        vec4 C = texture(iChannel0,(U+dof * dP) / R );       // Bokeh sampling of the image\n        d2 = dot(dP,dP);\n        t += w =   T==0 ? 1.                                 // disc profile\n                 : T==1 ? exp( -.5*d2 *6.)                   // Gaussian profile ( cut at 2.5 sigma )\n                 :        step( abs( d2 - .5 ) , .1 );       // ring\n        O += w * C;\n    }\n    \n    O = pow( O/t, vec4(1./2.2));                             // to sRGB\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    if ( U.y/H < .1 ) { O = 1e2*vec4( mod(U-.5,32.)==vec2(16) ); return; } // impulse ( to show filter as impulse response )\n    \n    // net pattern\n    U = (U+vec2(-U.y,U.x))/1.4; U.x*=2.;  U = (U-vec2(-U.y,U.x))/1.4;\n    U = abs( fract(S*U/H)-.5 );\n    O = vec4( smoothstep( 1.5*S/H, 0., min(U.x,U.y)-.1 ) );\n}", "buffer_a_inputs": [], "common_code": "#define R iResolution.xy\n#define H 360.  // R.y\n#define S 10.", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3BWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 90, 90, 1018]], "test": "untested"}
{"id": "ft3fDM", "name": "unsaturating post-image Bokeh", "author": "FabriceNeyret2", "description": "\"correcting\" the clamping of bright peaks in source images  while digital Bokeh by using L_infinity norm.\n( variant of \"Bokeh [194 Chars]\" by Xor. https://shadertoy.com/view/fldfWH )", "tags": ["dof", "bokeh", "2tweets", "short", "golf"], "likes": 39, "viewed": 839, "published": 3, "date": "1663143110", "time_retrieved": "2024-07-30T16:31:03.652359", "image_code": "/* Ultra-bright thin dots, as glints, speculars on misty grass, stars in telscope images, \n   saturate the sensors so that the result image is clamped ( small white dots not justicing the intensity ).\n   Worse: filtering post-treatment like digital Bokeh would totally underestimate the light.\n   Using L_infinity norm during filtering allows to keep the intensity along its spreading.\n   Or a good approximation, and allowing smoother transition, is to use something like L_50 norm instead.\n   ( adapted from \"Bokeh [194 Chars]\" by Xor. https://shadertoy.com/view/fldfWH )\n*/\n\n/**/                                                  // --- using real L_infinity ( Envy24 version )\n\nvoid mainImage( out vec4 O, vec2 I)\n{\n    vec2 r = iResolution.xy, dP, i = vec2(0,11);      // cos( t + i ) ~ vec2(cos,sin)\n    vec4 C;\n    for( O-=O ; i.x<2e2; ) {\n        float dof = (I+I-r-r*sin(iTime)).y;           // depth of field: current radius\n              dP  = sin(i+i.x*1.4)/6e2 *sqrt(i++).x;  // disc sampling\n        C = texture(iChannel0,(I+dof * dP) / r );     // Bokeh sampling of the image\n        O = max(O, C);                                // L_infinity norm\n    }\n    O = pow(O, vec4(1.2));\n}\n\n\n\n/**\n\nfloat p = 50.;                                        // --- using norm L_p\n\nvoid mainImage( out vec4 O, vec2 I)\n{\n    vec2 r = iResolution.xy, dP, i = vec2(0,11);      // cos( t + i ) ~ vec2(cos,sin)\n    vec4 C;\n    for( O-=O ; i.x<2e2; ) {\n        float dof = (I+I-r-r*sin(iTime)).y;           // depth of field: current radius\n              dP  = sin(i)/6e2 *sqrt(i++).x;          // disc sampling\n        C = texture(iChannel0,(I+dof * dP) / r ),     // Bokeh sampling of the image\n        O += pow(C, vec4(p)); // L_50 as an approx of L_infinity norm\n    }\n    O = pow( O/2e2, vec4(1./p) );  // finishing the L_50 norm.\n}\n\n/**/", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3fDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[681, 681, 718, 718, 1197]], "test": "untested"}
{"id": "NtdyWS", "name": "worley tileworks", "author": "ufffd", "description": "playing with buffers and worley noise", "tags": ["feedback", "buffer"], "likes": 3, "viewed": 203, "published": 3, "date": "1663127659", "time_retrieved": "2024-07-30T16:31:04.392380", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.1415926535897932384626433832795;\nconst float PI_2 = 1.57079632679489661923;\nconst float PI_4 = 0.785398163397448309616;\n\nfloat PHI = (1.0+sqrt(5.0))/2.0;\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 permute(vec4 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec4 dist(vec4 x, vec4 y,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) :  (x * x + y * y);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2 search window instead of 3x3,\n// at the expense of some strong pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a smooth F2, use the slower 3x3 version.\n// F1 is sometimes wrong, too, but OK for most purposes.\nvec2 worley(vec2 P, float jitter, bool manhattanDistance) {\nfloat K =  0.142857142857;// 1/7\nfloat K2= 0.0714285714285; // K/2\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 ox = mod(p, 7.0)*K+K2;\n\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\tvec4 dx = Pfx + jitter*ox;\n\tvec4 dy = Pfy + jitter*oy;\n\tvec4 d =  dist(dx, dy, manhattanDistance); // d11, d12, d21 and d22, squared\n\t// Sort out the two smallest distances\n\n\t// Do it right and find both F1 and F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap if smaller\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx;\n\td.y = min(d.y, d.z);\n\td.y = min(d.y, d.w);\n\treturn sqrt(d.xy);\n}\n\nfloat cubicPulse( float c, float w, float x ) {\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}", "buffer_a_code": "vec3 worleyTiles(in vec2 uv, in vec3 col) {\n    vec2 R = iResolution.xy;\n    vec2 px = 1./R,\n         pxc = 2./R.yy;          // [-1,1] vertically\n    \n    uv.x += iTime*0.000001;\n    uv.y += sin(iTime*1.1+uv.x)*0.0005;\n    \n    float worls = 0.;\n    for (int i=0;i<8;i++) {\n        float worl = worley(uv*(4.+sin(iTime*0.1)*3.)+iTime*0.1,1.5+sin(iTime*0.5)-float(i)/8.,true).x;\n        float worlstep = float(i)*0.15;\n        worls += smoothstep(-0.01,0.01,worl-worlstep);\n    }\n    worls = mod(worls,2.);\n    col *= worls;\n    \n    vec3 lp = texture(iChannel0,uv).rgb;\n    col = mix(col,lp, 0.96);\n    \n    vec3 lpn = texture(iChannel0,uv+vec2(0.,pxc.y)).rgb;\n    vec3 lps = texture(iChannel0,uv-vec2(0.,pxc.y)).rgb;\n    vec3 lpe = texture(iChannel0,uv+vec2(pxc.x,0.)).rgb;\n    vec3 lpw = texture(iChannel0,uv-vec2(pxc.x,0.)).rgb;\n    \n    vec3 newcol = vec3(lpn.r,lpe.g,lps.b);\n    \n    float mixer = mix(lps.r,lps.b,sin(iTime)*0.5+0.5);\n    col = mix(col,newcol,mixer);\n    \n    // color adjustments\n    vec3 hsv = rgb2hsv(col);\n    col = hsv2rgb(hsv);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy,\n         uv = fragCoord / R,\n         uvc = ( 2.*fragCoord - R ) / R.y;\n         \n         // uvc *= 1.001;\n         \n    vec2 bguv = uvc * 2.5;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n    \n    \n    float input_bright = texture(iChannel1,uv).r;\n         \n    col = worleyTiles(uv, col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdyWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 205]], "test": "untested"}
{"id": "sldfD4", "name": "Tiny Circle Shader (81 chars)", "author": "spenceryonce", "description": "Tiny circle shader. ", "tags": ["simple", "circle", "shader", "tiny", "small"], "likes": 0, "viewed": 369, "published": 3, "date": "1663120707", "time_retrieved": "2024-07-30T16:31:05.141378", "image_code": "//thanks to xor 81 chars\nvoid mainImage(out vec4 c, vec2 f) {\n    c = length(f+f-(c.xy=iResolution.xy))/c.yyyy-.5;\n}\n\n/*spenceryonce with 88 chars\nvoid mainImage(out vec4 c, vec2 f){\n    c=vec4(length(f*2.-iResolution.xy)/iResolution.y-.5);\n}*/\n\n/*spalmer with 87 chars\nvoid mainImage(out vec4 c, vec2 f){\n    c.xyz = iResolution; c = vec4(length((f+f-c.xy)/c.y)-.5);\n}\n*/\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 25, 61, 61, 116]], "test": "untested"}
{"id": "flcBD4", "name": "Baroque Fractal Pattern", "author": "leon", "description": "curvastic experience with a lot of twistic rotations", "tags": ["gold", "baroque"], "likes": 22, "viewed": 367, "published": 3, "date": "1663107514", "time_retrieved": "2024-07-30T16:31:05.886386", "image_code": "\n// Baroque Fractal Pattern\n// a golden wood baroque painting frame pattern generator\n//\n// previous iterations:\n// https://www.shadertoy.com/view/NddSWs\n// https://www.shadertoy.com/view/ftcBW8\n// https://www.shadertoy.com/view/fsdfW8\n// https://www.shadertoy.com/view/7syXDy\n// https://www.shadertoy.com/view/fdd3Ws\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    float total = data.a;\n    vec4 color = vec4(0);\n    \n    if (total > .001 && total < max_dist)\n    {\n        // lighting\n        float shade = data.r;\n        float timeline = data.g;\n        float mat = data.b;\n        data = texture(iChannel1, uv);\n        vec3 normal = data.xyz;\n        float ao = data.a;\n        vec3 light = normalize(vec3(0,1,2));\n        float lamp = dot(normal, light)*.5+.5;\n        float gray = (1.-ao)*lamp;\n        gray += .25*pow(lamp, 40.);\n        gray *= .7+.3*smoothstep(.1,0.,ao);\n        color = mix(vec4(0.239,0,0,1),vec4(0.996,0.863,0.384,1),gray);\n        color *= shade;\n    }\n    else\n    {\n        // background\n        color = vec4(1) * smoothstep(2., -2., length(uv-.5));\n    }\n    \n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// globals\nconst float delay = 15.;\nfloat timeline, mat;\n\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    float shape = 100.;\n    float t = timeline;\n    float w = fract(t/delay);\n    \n    // shape parameters\n    float a = 1.;\n    float n = 196.+t*.2;\n    float r = 1.;\n    float f = 1.7;\n    float b = 1.;\n    float s = .05;\n    const float count = 8.;\n    \n    for (float i = 0.; i < count; ++i)\n    {\n        p.xy *= rot(n/a);\n        p.yz *= rot(n*a);\n        p.x = abs(p.x)-r*a;\n        shape = length(p)-s*a;\n        mat = mix(i, mat, smoo(dist, shape, b*a));\n        dist = smin(dist, shape, b*a);\n        a /= f;\n    }\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/R.xy;\n    vec4 frame = texture(iChannel0, uv);\n    \n    const float count = 3.;\n    for (float frames = 0.; frames < count; ++frames)\n    {\n        // init globals\n        float f = float(iFrame) * 123. + frames * 196.;\n        vec3 rng = hash(uvec3(fragCoord, f));\n        timeline = rng.x*.1+iTime;\n        mat = 0.;\n\n        // raymarch\n        vec2 p = 1.*(fragCoord-R.xy/2.)/R.y;\n        vec3 pos = vec3(0,0,10.);\n        vec3 ray = normalize(vec3(p, -4));\n        float total = 0.;\n        float steps = 0.;\n        const float count = 20.;\n        for (steps = count; steps > 0.; --steps) {\n            float dist = map(pos);\n            if (dist < .001 * total || total > max_dist) break;\n            total += dist;\n            pos += ray * dist;\n        }\n\n        // draw if closer\n        if (total < max_dist && (total < frame.a || frame.a < .001))\n        {\n            // data pack\n            float shade = steps/count;\n            float time = fract(timeline/delay);\n            fragColor = vec4(shade, time, mat, total);\n            frame = fragColor;\n        }\n        else\n        {\n            // store result\n            fragColor = frame;\n        }\n    }\n    \n    // wipe\n    fragColor *= step(.01, fract(iTime/delay));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution\n#define T(uv) texture(iChannel0, uv).a\nconst float max_dist = 20.;\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// Inigo Quilez https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat smoo( float d1, float d2, float k )\n{\n     return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n}\n\n// Victor Shepardson + Inigo Quilez \n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}", "buffer_b_code": "\n// compute ao and normal\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    // ao\n    float ao = 0.;\n    const float count = 6.;\n    for (float f = 0.; f < count; ++f)\n    {\n        vec3 rng = hash(uvec3(fragCoord, float(iFrame)+196.*f));\n        vec2 offset = 20.*rng.z*normalize(rng.xy*2.-1.)/R.xy;\n        float total = texture(iChannel0, uv+offset).r;\n        ao += 2.*abs(color.r - total)/count;\n    }\n    \n    float frame = texture(iChannel1, uv).a;\n    fragColor.a = mix(frame, ao, .1);\n    \n    // normal\n    vec3 unit = vec3(1./R.xy, 0);\n    float w = T(uv+unit.xz);\n    float e = T(uv-unit.xz);\n    float n = T(uv+unit.zy);\n    float s = T(uv-unit.zy);\n    bool edge = w * e * n * s < .001;\n    if (color.a > .001 && color.a < max_dist && !edge)\n    {\n        vec3 normal = normalize(vec3(w-e, n-s, unit.y));\n        fragColor.rgb = normal;\n    }\n    else\n    {\n        fragColor.rgb = vec3(0);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcBD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 376, 376, 1213]], "test": "untested"}
{"id": "sl3BD4", "name": "Random fractal hack", "author": "mrange", "description": "CC0: Random fractal hack\nInspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nDid this along time ago. It was created by just applying random math to kali fractal.\n", "tags": ["2d", "kali"], "likes": 11, "viewed": 375, "published": 3, "date": "1663084880", "time_retrieved": "2024-07-30T16:31:06.642365", "image_code": "// CC0: Random fractal hack\n//  Inspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n//  Did this along time ago. It was created by just applying random math to kali fractal.\n//  I kind of like it though and thought it is worth to share.\n\n// SABS by ollj\n#define less(a,b,c)      mix(a,b,step(0.,c))\n#define sabs(x,k) less((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n  p *= 2.0;\n\n  vec2 c = vec2(-0.5, -0.5)*1.0;\n  vec2 u = p;\n  for (int i = 0; i < 5; ++i) {\n    float m = pow(dot(u,u),0.3);\n    u = sabs(u, (0.33 + 0.1*p.y))/m + c;\n  }\n  \n  vec3 col = vec3(length(u));\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3BD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[414, 414, 469, 469, 804]], "test": "untested"}
{"id": "Nl3BWN", "name": "Finite Water Cymatic Fork", "author": "tarnith", "description": "Fork of Finite Water by overlii \n\nTreating the render window as a kind of Chladni plate. Fun to watch the modes.", "tags": ["procedural", "simulation", "water", "multipass"], "likes": 4, "viewed": 257, "published": 3, "date": "1663083593", "time_retrieved": "2024-07-30T16:31:07.386376", "image_code": "// Wave propagation simulation using finite differences.\n// See (f.ex.) http://www.uio.no/studier/emner/matnat/ifi/INF2340/v05/foiler/sim04.pdf\n// for the model and equations.\n\nvoid mainImage( out vec4 C, in vec2 co )\n{\n\tvec2 uv = co.xy / R.xy;\n\tC = vec4(T(uv).r*vec3(.5,0,0)+T(uv).r*vec3(.0,0.2,0)+abs(T(uv).g)*vec3(0,0.,.5),1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nvoid mainImage( out vec4 C, in vec2 co )\n{\n    float dx = 1.0/R.x;\n    float dy = 1.0/R.y;\n    vec2 uv = co.xy / R.xy;\n\n    vec2 udu = T(uv).xy;\n    \n\t// old elevation\n    float u = udu.x;\n    // old velociy\n    float du = udu.y;\n    \n    // Finite differences\n    float ux = T(vec2(uv.x+dx, uv.y)).x;\n    float umx = T(vec2(uv.x-dx, uv.y)).x;\n    float uy = T(vec2(uv.x, uv.y+dy)).x;\n    float umy = T(vec2(uv.x, uv.y-dy)).x;\n\n    // new elevation\n    float nu = u + du + 0.5*(umx+ux+umy+uy-4.0*u);\n    nu *= 0.999;\n    if (iFrame == 1)\n        C = T(uv)+vec4(vec3(sin(length((uv-.5)*R.x*.1)))*length((uv-.5)),1.0);\n    else\n    // store elevation and velocity\n        C = vec4(nu,nu-u,0.0,0.0);\n\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texture(iChannel0,u)\n#define R iResolution", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3BWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 219, 219, 333]], "test": "untested"}
{"id": "NttBW8", "name": "Back to Fractal City", "author": "leon", "description": "just a little detour, it won't take long", "tags": ["city", "buildings", "concrete"], "likes": 54, "viewed": 952, "published": 3, "date": "1663072093", "time_retrieved": "2024-07-30T16:31:08.197208", "image_code": "\n// Back to Fractal City\n// welcome to intricate concrete jungle\n// there are some lipschitz discontinuity turbulences ahead\n//\n// previous fractal city iterations:\n// https://www.shadertoy.com/view/7slcRX\n// https://www.shadertoy.com/view/ftG3D1\n// https://www.shadertoy.com/view/NdyXDt\n// https://www.shadertoy.com/view/WdlyWH\n\n// parameters\nconst float speed = .05;\nconst float falloff = 1.75;\nconst float range = .5;\nconst float count = 11.;\n\n// globals\nvec3 pp, ppp;\nfloat mat, glow;\n\nfloat map (vec3 p)\n{\n    float dist = 100.;\n    float shape = 100.;\n    vec3 pos = p;\n    pp = p;\n    ppp = p;\n    \n    // travel\n    float px = p.x-iTime*speed;\n    float ix = floor(px);\n    p.x = repeat(px,1.);\n    \n    // city\n    float a = 1.;\n    float angle = 196.+ix;\n    for (float i = 0.; i < count; ++i)\n    {\n        p.xz *= rot(angle/a);\n        p = abs(p)-range*a;\n        shape = max(p.x,max(p.y,p.z));\n        mat = shape < dist ? i : mat;\n        pp = i == 7. ? p : pp;\n        ppp = i == 6. ? p : ppp;\n        dist = min(dist, shape);\n        a /= falloff;\n    }\n    dist = -dist;\n    \n    // columns\n    shape = max(length(pp.xz)-.001, dist - .005);\n    dist = min(dist, shape);\n\n    // lights\n    shape = max(length(ppp.xy)-.001, dist - .001);\n    glow += .0001/max(.0005,shape);\n    \n    // crop\n    dist = max(dist, abs(pos.y-.1)-.2);\n    \n    return dist;\n}\n\n// from Inigo Quilez\nfloat shadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 1.;\n    float t = .002;\n    for (float i = 0.; i <= 1.; i += 1./30.) {\n        float dist = map(pos + dir * t);\n        if (dist < .001) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,0);\n    \n    const float frames = 3.;\n    for (float frame = 0.; frame < frames; ++frame)\n    {\n        // coordinates\n        vec2 uv = fragCoord/R.xy;\n        vec2 p = 2.*(fragCoord-R.xy/2.)/R.y;\n        \n        // anti aliasing\n        float aa = 6.28*frame/frames;\n        p += vec2(cos(aa),sin(aa))/R.xy;\n        \n        vec3 pos = vec3(.04,-.02,.09);\n        vec3 ray = look(pos, vec3(0,0,0), p, 4.);\n        vec3 rng = hash(uvec3(fragCoord, float(iFrame) + frame*196.));\n\n        // init globals\n        glow = 0.;\n        mat = 0.;\n\n        // raymarch\n        float total = 0.;\n        float steps = 0.;\n        const float count = 100.;\n        const float max_dist = 4.;\n        for (steps = count; steps > 0.; --steps) {\n            float dist = map(pos);\n            if (dist < .001 * total || total > max_dist) break;\n            dist *= .9 + .1 * rng.z;\n            total += dist;\n            pos += ray * dist;\n        }\n        \n        vec4 result;\n\n        if (total < max_dist)\n        {\n            // lighting\n            float shade = steps/count;\n            vec3 sun = normalize(vec3(0,1,.2));\n            vec3 palette = .5+.5*cos(vec3(1,2,3)*5. + pos.z * 6. + pos.y * 6.);\n            vec3 color = vec3(1.5);\n            color *= sin(mat+1.)*.25+.75;\n            color *= step(.01, ppp.z)*.25+.75;\n            color *= step(pp.y, -.005)*.25+.75;\n            color += palette*clamp(.1/abs(mat-10.), 0., 1.)*.9;\n            color += palette*glow;\n            color *= shade;\n            color *= .4+.6*shadow(pos, sun, 100.);\n            result = vec4(color, 1);\n        }\n        else\n        {\n            // sky\n            vec3 color = .5+.5*cos(vec3(1,2,3)*5.+uv.y*2.+2.);\n            result = vec4(color, 1);\n        }\n        \n        // sum it up\n        fragColor += result/frames;\n    }        \n}", "image_inputs": [], "common_code": "#define R iResolution\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nvec3 look (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = cross(x, z);\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\n\n// Victor Shepardson + Inigo Quilez \n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[490, 490, 510, 510, 1369], [1371, 1392, 1435, 1435, 1773], [1775, 1775, 1832, 1832, 3692]], "test": "untested"}
{"id": "fttBD8", "name": "Sinusoidal Painting", "author": "leon", "description": "sine qua none painting", "tags": ["curve", "paint", "brush", "graffiti"], "likes": 53, "viewed": 817, "published": 3, "date": "1663062851", "time_retrieved": "2024-07-30T16:31:09.009037", "image_code": "\n// Sinusoidal Painting\n// when you let sine paint\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0, 0, 0, 1);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    float mask = data.r;\n    \n    if (mask > .001)\n    {\n        // lighting\n        vec3 normal = texture(iChannel1, uv).rgb;\n        vec3 light = normalize(vec3(0,1,1));\n        float timestamp = data.b;\n        float shade = dot(normal, light)*.5+.5;\n        vec3 palette = .5+.5*cos(vec3(1,2,3)*5.+timestamp*3.);\n        color.rgb = palette * shade;\n        color += pow(shade,  50.);\n\n    }\n    else\n    {\n        // background\n        color.rgb = vec3(1) * smoothstep(2., -2., length(uv-.5));\n\n        // shadow\n        float sdf = data.g;\n        color *= smoothstep(-.3, .2,  sdf);\n    }\n    \n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// move brush\nvec2 move(float t)\n{\n    vec2 pos = vec2(0);\n    \n    // random targets\n    float jitter = .5;\n    float time = t*3.;\n    float index = floor(time);\n    float anim = fract(time);\n    vec2 rng = mix(hash21(index), hash21(index+1.), anim);\n    pos += (rng*2.-1.)*jitter;\n    \n    // translate to right\n    pos.x += .5;\n    \n    // twist it\n    float angle = t;\n    float radius = .1;\n    pos += vec2(cos(angle),sin(angle))*radius;\n    \n    // fbm gyroid noise\n    angle = fbm(vec3(pos,t))*6.28;\n    radius = .2;\n    pos += vec2(cos(angle),sin(angle))*radius;\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    vec2 p = 1.5*(fragCoord-R.xy/2.)/R.y;\n    \n    // scroll\n    uv.x += 1./R.x;\n    \n    // framebuffer\n    vec4 frame = texture(iChannel0, uv);\n    float mask = frame.r;\n    float sdf = frame.g;\n    \n    // interaction\n    if (iMouse.z > 0.)\n    {\n        vec2 mouse = iMouse.xy;\n        vec4 prev = texture(iChannel0, vec2(0));\n        vec3 dither = hash(uvec3(fragCoord, iFrame)); \n        mouse = prev.z > 0. ? mix(mouse, prev.xy, dither.x) : mouse;\n        mouse = 1.5*(mouse-R.xy/2.)/R.y;\n        float thin = .04+.03*sin(iTime*20.);\n        float dist = length(p-mouse);\n        float msk = smoothstep(thin,.0,dist);\n        if (msk > .001) frame.b = iTime;\n        sdf = sdf < .001 ? dist : min(sdf, dist);\n        mask += msk;\n    }\n    else\n    {\n        // accumulate noisy results\n        for (float frames = 20.; frames > 0.; --frames)\n        {\n            // cursor timeline with noise offset\n            float f = float(iFrame) + frames * 200.;\n            vec3 rng = hash(uvec3(fragCoord, f));\n            float cursor = rng.x*.03+iTime;\n\n            // brush\n            float thin = .04+.03*sin(cursor*20.);\n            float dist = length(p-move(cursor));\n            float msk = smoothstep(thin,.0,dist);\n\n            // timestamp\n            if (msk > .001) frame.b = iTime;\n\n            // distance\n            sdf = sdf < .001 ? dist : min(sdf, dist);\n\n            // accumulate\n            mask += msk;\n        }\n    }\n\n    // save data\n    frame.r = mask;\n    frame.g = sdf;\n    fragColor = frame;\n    \n    // avoid glitch after disabling fullscreen\n    if (fragCoord.x > R.x-1.) fragColor = vec4(0,0,0,1);\n    \n    if (fragCoord.x < 1. && fragCoord.y < 1.)\n    {\n        fragColor = iMouse;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define R iResolution\n#define T(uv) texture(iChannel0, uv).r\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec3 seed) {\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 3; ++i) {\n        result += gyroid(seed/a)*a;\n        a /= 3.;\n    }\n    return result;\n}\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Victor Shepardson + Inigo Quilez \n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}", "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // compute normal\n    vec4 color = texture(iChannel0, uv);\n    vec3 unit = vec3(1./iResolution.xy, 0);\n    vec3 normal = normalize(vec3(\n                            T(uv+unit.xz)-T(uv-unit.xz),\n                            T(uv-unit.zy)-T(uv+unit.zy),\n                            color.r));\n                            \n    fragColor = vec4(normal, 1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttBD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 109, 109, 850]], "test": "untested"}
{"id": "7ttBW8", "name": "BLF IK Armature", "author": "iY0Yi", "description": "Rigged primitives on IK bones.\nRef:\"Foundation ActionScript 3.0 Animation\" P.367\nRef: https://www.alanzucconi.com/2020/09/14/inverse-kinematics-in-3d/\n\nNumkeys for changing the view:\nFree: 0\nFront: 1\nSide: 3\nTop: 7", "tags": ["ik", "maptoy", "armature"], "likes": 24, "viewed": 496, "published": 3, "date": "1663049159", "time_retrieved": "2024-07-30T16:31:09.956504", "image_code": "#define UI_AXIS 0\n#define UI_GRID_2D 0\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 1\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE .75\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\nstruct IKBone{\n    float len;\n    vec3 tip;\n    float pitch;\n};\n\nstruct IKArmature{\n    IKBone[3] bon;\n    float yaw;\n    bool inverted;\n};\n\n// Ref:\"Foundation ActionScript 3.0 Animation\" P.367\n// Ref: https://www.alanzucconi.com/2020/09/14/inverse-kinematics-in-3d/\nvoid calcIK(inout IKArmature ika){\n    vec3 CA = ika.bon[0].tip-ika.bon[2].tip;\n    ika.yaw = atan(CA.x, CA.z);\n    ika.bon[2].tip.xz=rot(ika.bon[2].tip.xz,-ika.yaw);\n    vec3 C = ika.bon[2].tip-ika.bon[0].tip;\n    float a = ika.bon[1].len, b = ika.bon[2].len, c = min(a+b, length(C));\n    float aB = acos((b*b-a*a-c*c)/(-2.*a*c));\n    float aC = acos((c*c-a*a-b*b)/(-2.*a*b));\n    float aD = atan(C.z, C.y);\n    float dir = (ika.inverted) ? 1. : -1.;\n    float aDB = PI*.5-(aD+aB*dir);\n    float aE = aD+aB*dir+PI+aC*dir;\n    ika.bon[1].tip = vec3(0,sin(aDB),cos(aDB))*a+ika.bon[0].tip;\n    ika.bon[2].pitch = PI*.5-aE;\n    ika.bon[1].pitch = aDB;\n    ika.bon[1].tip.xz=rot(ika.bon[1].tip.xz,ika.yaw);\n    ika.bon[2].tip.xz=rot(ika.bon[2].tip.xz,ika.yaw);\n}\n\n// https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nfloat sdSphere(vec3 p,float s){\n    return length(p)-s;\n}\n\nfloat sdCapsule(vec3 p,vec3 pos1,vec3 pos2,float r){\n    vec3 ap=p-pos1,ab=pos2-pos1;\n    float pro=clamp(dot(ap,ab)/dot(ab,ab),0.,1.);\n    return length(ab*pro-ap)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb ){\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nfloat map(vec3 p){\n    p.y+=.3;\n    float t = iTime*1.;\n    \n    // init IK Armature(Bones)\n    IKArmature ika;\n    ika.inverted = true;\n    ika.bon[0].len = 0.;\n    ika.bon[1].len = .4;\n    ika.bon[2].len = .5;\n\n    ika.bon[0].tip = vec3(0,.2,0);\n    vec3 offC = vec3(sin(t*.5), 0, cos(t*.5))*.5;\n    float radC = .3;\n    ika.bon[2].tip = vec3(sin(t)*radC, sin(t*.3)*.2+.3, cos(t)*radC) + offC;\n    \n    // calc IK\n    calcIK(ika);\n    \n    // draw result\n    float d = 3e38;\n    bool drawBones = false;//int(floor(t*.1))%2 > 0;\n    if(drawBones){\n        // draw IK Bones\n        d=min(d, sdCapsule(p,vec3(0),ika.bon[0].tip,.005));\n        d=min(d, sdCapsule(p,ika.bon[0].tip,ika.bon[1].tip,.005));\n        d=min(d, sdCapsule(p,ika.bon[1].tip,ika.bon[2].tip,.005));\n        d=min(d, length(p-ika.bon[0].tip)-.025);\n        d=min(d, length(p-ika.bon[1].tip)-.025);\n        d=min(d, length(p-ika.bon[2].tip)-.025);\n        d=min(d, max(abs(length(p.xz-offC.xz)-radC)-.01, abs(p.y-ika.bon[2].tip.y)-.01));\n    }\n    else{\n    \n        vec3 q = p;\n\n        // roll along vector of root to tip\n        #if 0\n        vec3 axis = normalize(ika.bon[0].tip-ika.bon[2].tip);\n        q-=ika.bon[0].tip;\n        q = erot(q, axis, t);\n        q+=ika.bon[0].tip;\n        #endif\n        \n        // draw rigged primitives\n        vec3 p0 = p-ika.bon[0].tip;\n        p0.xz = rot(p0.xz, -ika.yaw);\n        d=min(d, sdBox(p0+vec2(0,.1).xyx, vec2(.025,.1).xyx));\n        d=min(d, max(length(p0.yz)-.025, abs(p0.x)-.025));\n\n        // segment1\n        vec3 p1 = q-ika.bon[1].tip;\n        p1.xz = rot(p1.xz, -ika.yaw);\n        p1.yz = rot(p1.yz, -ika.bon[1].pitch);\n        d=min(d, sdBox(p1+vec2(0,ika.bon[1].len*.5).xxy, vec2(.025, ika.bon[1].len).xxy*.5));\n        d=min(d, max(length(p1.yz)-.025, abs(p1.x)-.025));\n\n        // segment2\n        vec3 p2 = q-ika.bon[2].tip;\n        p2.xz = rot(p2.xz, -ika.yaw);\n        p2.yz = rot(p2.yz, -ika.bon[2].pitch);\n        float hr = .1;\n        d=min(d, sdBox(p2+vec2(0,ika.bon[2].len*.5+hr*.5).xxy, vec2(.025, ika.bon[2].len-hr).xxy*.5));\n        \n        // head\n        p2.xy = rot(p2.xy, (sin(iTime*1.))*10.);\n        d=min(d, max(length(p2.xz+vec2(0,hr))-.025, abs(p2.y)-.025));\n        float an = -2.7+floor(sin(t*1.)*20.)*.05;\n        vec2 c = vec2(sin(an),cos(an));\n        d=min(d, max(sdArc(p2.xz+vec2(0,hr*.5), c, hr*.5, .01), abs(p2.y)-.01));\n        \n        // target\n        d=min(d, length(p-ika.bon[2].tip)-.025);\n    }\n    \n    // draw a stage\n    d=min(d, max(length(p.xz)-.5, abs(p.y+.0125)-.0125));\n        \n    return d;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.5\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.5 @ 2022/09/14    \n//        - Fixed long compilation in Quad view.\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n#define INIT_CAM_POS vec3(-2,-.5,0)\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 6.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -1, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        vec2 offset;\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n        fragColor = vec4(renderRect(fragCoord*2.-offset),1);\\\n        if((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) || (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.))fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// User Inputs\n\n// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_PAD_0) || getState(K_NUM_0) && sign(iMouse.z)<=.0)fragColor = vec4(0, 0, 0, 0);\n        \n        //if(getState(K_PAD_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_PAD_1) || getState(K_NUM_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_PAD_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_PAD_3) || getState(K_NUM_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_PAD_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_PAD_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_PAD_7) || getState(K_NUM_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_PAD_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_PAD_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 504, 538, 538, 1262], [1264, 1314, 1352, 1352, 1417], [1419, 1419, 1450, 1450, 1476], [1478, 1478, 1530, 1530, 1647], [1649, 1649, 1679, 1679, 1766], [1768, 1768, 1828, 1828, 1962], [1964, 1964, 1982, 1982, 4536]], "test": "untested"}
{"id": "NldfDH", "name": "[twigl]Manjusaka (239chrs)", "author": "Catzpaw", "description": "https://twitter.com/catzpaw/status/1522855197470515201", "tags": ["raymarching", "fractal", "twigl"], "likes": 19, "viewed": 498, "published": 3, "date": "1663041540", "time_retrieved": "2024-07-30T16:31:10.727442", "image_code": "//--- Manjusaka\n// by Catzpaw 2022\n\n//https://bit.ly/38ZvP9w\n\nTWIGL_GEEKEST_300ES\n\nfloat l,i,v,e;\nfor(vec3 p,\n    O=vec3(.1,fract(t/4e2)*PI,.16),\n    R=normalize(vec3((FC.xy-r*.5)/r.y,.9));\n    ++i<1e2;\n    o.rgb+=hsv(l,.8,e/3e6)){\n        p=O+R*l;p.y-=l*.5;e=2.;\n        for(int j;++j<9;e/=v=min(dot(p,p),.3723),p/=v)\n            p=mod(abs(p-.1),PI)-1.;\n        l+=(p.x+p.z+4.5)/e;}\n\nEND_GEEKEST_300ES\n", "image_inputs": [], "common_code": "/* ============================================ **\n\n███████        █   TWIGL GEEKEST WRAPPER\n█  █  █            for Shadertoy\n   █  ███  █████\n   █   █ ▐▌ █  █    by Catzpaw 2022\n  ███  ▐█▌▐█▌ ███\n\n ██       ██  ██\n █  ▐█████ █   █\n█▌ ▐█   █  █   ▐█  \"twigl\"\n █ ▐█   █  █   █    https://twigl.app/\n ██ ▐████ ███ ██    Copyright (c) 2020 doxas\n    ████▌\n\nMIT License\nhttps://github.com/doxas/twigl/blob/master/LICENSE\n\n** ============================================ */\n\n\n/*** NOTICE **************************************\n  No backbuffer supported.\n  No MRT supported.\n  \"s\" is always zero.\n*************************************************/\n\n\n\n// --------------------------------------------\n//  noise.glsl\n// --------------------------------------------\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec2  mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3  mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4  mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nfloat permute(float x){return mod289(((x*34.0)+1.0)*x);}\nvec3  permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);}\nvec4  permute(vec4 x) {return mod289(((x*34.0)+1.0)*x);}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4  taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise2D(vec2 v){\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\nfloat snoise3D(vec3 v){\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\nvec4 grad4(float j, vec4 ip){\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\nfloat snoise4D(vec4 v){\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  // 2 * G4\n                          0.414589803375032,  // 3 * G4\n                         -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n               i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n             + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n             + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n             + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                  + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\nfloat fsnoise      (vec2 c){return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);}\nfloat fsnoiseDigits(vec2 c){return fract(sin(dot(c, vec2(0.129898, 0.78233))) * 437.585453);}\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\nconst float PI = 3.141592653589793;\nconst float PI2 = PI * 2.0;\n\n\n// --------------------------------------------\n//  twigl geekest(300 es) aliases\n// --------------------------------------------\n#define TWIGL_GEEKEST_300ES void mainImage(out vec4 o,in vec2 _fc){vec2 r=iResolution.xy,m=iMouse.xy/r;vec4 FC=vec4(_fc,.5,1);float s=0.,t=iTime;int f=iFrame;o=vec4(0);\n#define END_GEEKEST_300ES o=clamp(o,0.,1.);}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldfDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NldBDH", "name": "fyne rounded rectangle", "author": "bluebugs", "description": "Simple shader to do a rounded rectangle learned from https://www.warp.dev/blog/how-to-draw-styled-rectangles-using-the-gpu-and-metal and https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border", "tags": ["stroke", "rectangle", "fill", "rounded", "fyne"], "likes": 2, "viewed": 311, "published": 3, "date": "1663039363", "time_retrieved": "2024-07-30T16:31:11.500376", "image_code": "const float strokeWidth = 10.0;\nconst float radius = 350.0;\n\nconst vec2 backgroundGradientStart = vec2(0.0,0.0);\nconst vec2 backgroundGradientEnd = vec2(1.0,0.0);\nconst float backgroundSteps[8]= float[8](0.0, 0.5, 1.0, 2.0, 2.0, 2.0, 2.0, 2.0);\nconst vec4 backgroundColors[8] = vec4[8](vec4(0,0,1.0,1.0), vec4(0,0,0.0,1.0), vec4(0,0,1.0,1.0), vec4(0,0,1.0,1.0),\n                                         vec4(0,0,1.0,1.0), vec4(0,0,0.5,1.0), vec4(0,0,0.3,1.0), vec4(0,0,1.0,1.0));\n\nconst vec2 strokeGradientStart = vec2(0.0,0.0);\nconst vec2 strokeGradientEnd = vec2(1.0,1.0);\nconst float strokeSteps[8] = float[8](0.1, 0.2, 0.3, 0.4, 0.6, 0.7, 0.8, 0.9);\nconst vec4 strokeColors[8] = vec4[8](vec4(0,1.0,0,1.0),vec4(0,0.3,0,1.0),vec4(0,1.0,0,1.0),vec4(0,0.3,0,1.0),\n                                     vec4(0,1.0,0,1.0),vec4(0,0.3,0,1.0),vec4(0,1.0,0,1.0),vec4(0,0.3,0,1.0));\nconst vec2 fillGradientStart = vec2(0.0,0.0);\nconst vec2 fillGradientEnd = vec2(1.0,1.0);\nconst float fillSteps[8] = float[8](0.0, 0.2, 0.3, 0.4, 0.6,0.7, 0.8, 1.0);\nconst vec4 fillColors[8] = vec4[8](vec4(1.0,0,0,1.0),vec4(0.3,0,0,1.0),vec4(1.0,0,0,1.0),vec4(0.3,0,0,1.0),\n                                   vec4(1.0,0,0,1.0),vec4(0.3,0,0,1.0),vec4(1.0,0,0,1.0),vec4(0.3,0,0,1.0));\n\nfloat rectangleDistanceField(vec2 pixelPosition, vec2 rectangleCenter, float r)\n{\n    vec2 q = abs(pixelPosition) - rectangleCenter + vec2(r);\n\treturn length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;   \n}\n\nvec4 deriveColor(vec2 pixelPosition, vec2 startGradient, vec2 endGradient, in float[8] steps, in vec4[8] colors)\n{\n   vec2 adjustedEnd = endGradient - startGradient;\n   // -1.0 <= dot <= 1.0 => 0.0 < step < 1.0\n   float h = (1.0 + dot(pixelPosition - startGradient, endGradient) / dot(endGradient, endGradient))/2.0;\n   \n   vec4 outColor = mix(colors[0], colors[1], smoothstep(steps[0], steps[1], h));\n   for (int i = 2; i < 8; i++)\n   {\n     outColor = mix(outColor, colors[i], smoothstep(steps[i-1], steps[i], h));\n   }\n   return outColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float halfStrokeWidth = strokeWidth / 2.0;\n\n    vec2 halfResolution = iResolution.xy / 2.0;\n    vec2 halfRectangleSize = halfResolution - vec2(halfStrokeWidth);    \n\tvec2 pixelPosition = (fragCoord - halfResolution);\n    vec2 relativePixelPosition = pixelPosition / iResolution.xy;\n    \n    float dist = rectangleDistanceField(pixelPosition, halfRectangleSize, radius - halfStrokeWidth);\n\n    vec4 insideColor = deriveColor(relativePixelPosition, strokeGradientStart, strokeGradientEnd, strokeSteps, strokeColors);\n    vec4 outsideColor = deriveColor(relativePixelPosition, backgroundGradientStart, backgroundGradientEnd, backgroundSteps, backgroundColors);\n\n    if (halfStrokeWidth > 0.0)\n    {\n        if (dist < 0.0)\n        {\n            outsideColor = deriveColor(relativePixelPosition, fillGradientStart, fillGradientEnd, fillSteps, fillColors);\n        } \n        \n        dist = abs(dist) - halfStrokeWidth;\n    }\n    \n    float blendAmount = smoothstep(-1.0, 1.0, dist);\n    \n    fragColor = mix(insideColor, outsideColor, blendAmount);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1259, 1259, 1340, 1340, 1465], [2013, 2013, 2070, 2070, 3122]], "test": "untested"}
{"id": "slcfWH", "name": "Fractal mosaic 17", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 18, "viewed": 489, "published": 3, "date": "1663014934", "time_retrieved": "2024-07-30T16:31:12.311208", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //min(abs(.5-fract(a.yx)),abs(.5-fract(a+.5)))\n        //fract(a-fract(-a*2.+.5)/2.)\n        //fract(a-floor(a.y*2.+.5)/2.)\n    ;\n}\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n#define fmod(x,y) mod(floor(x),y)\nvec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        //vec2(-2.,.5+mod(floor(a.x),2.))\n        //vec2(1.5,0.5)\n        \n        //vec2(1.5,0.)\n        //vec2(1.25,1.75)\n        //vec2(abs(mod(a.x-.5,2.)-1.),abs(mod(a.y-.5,2.)-1.))\n    ,\n    \n    a1 = a+a2;\n    //a1 = a*sign(a-a2.yx)+a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    return abs(f1((a1)*(a2.x+a2.y))-.5);\n}\nconst float scale = 1.5;\n\n\nvoid transform(inout vec2 uv, inout vec2 t2){\n\n        //if(mod(uv.x,1.)>.5){uv.x=uv.x*2.;}\n\n        \n        //uv += vec2(pow(floor(-uv.x*fmod(uv.y,3.)),2.),pow(floor(-uv.y*fmod(uv.y,3.)),2.))/2.;\n\n        \n        //uv.x -= abs(fract(uv.x)-.5)/2.;\n        //uv += floor(uv)/2.;\n        \n        uv =\n            (uv+t2)/scale\n            //abs(-.5+uv+t2)/scale\n        ;\n        //col.x = max(max(length(abs(fract(uv)-.5)-t2),abs(uv.y-uv.x))/3.,col.x);\n\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*3.)-.5)/3.;\n        \n        //uv *= r;\n        \n        //uv *= sign(uv-uv.yx);\n        //if(col.y>col.x)\n        t2 = triangle_wave(uv+.5);\n        \n        //uv += (distance(floor(uv),round(uv)));\n\n        //uv_last = abs(uv-uv_last);\n        //if(col.y>col.x)\n        uv =\n            (t2-triangle_wave(uv.yx))\n            //(t2-triangle_wave(uv.yx)/2.)\n            //(t2-max(triangle_wave(uv.yx),triangle_wave(uv+.5)/2.))\n            //(t2-triangle_wave(uv.yx))/(1.5-mod(floor(uv.y),2.)/2.)\n            //t2*length(uv)-triangle_wave(uv.yx)\n        ;\n        //if(length(uv_last) > 1.0) uv_last = vec2(0.);\n        //uv2 =\n        //    (t2-triangle_wave(uv2.yx/1.5));\n        \n        //if(uv.y>uv.x) uv.x += .5;\n\n        \n        //uv *= (1.+uv.x);\n        //t2 *= (1.+uv.x);\n        \n        //uv.x -= floor(uv.x-uv.y)*1.125;\n        \n        //uv.x -= max(uv.y,uv.x);\n        \n        //uv.y += abs(fract(uv.y)-.5)/2.;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += iTime/t1/24.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    vec2 uv_last = vec2(0.);\n    \n    mat2 r = rotate2D(0.785398);\n    vec2 uv2 = uv;\n    \n    for(int k = 0; k < 9; k++){\n        \n        float warp_scale = 8./3.14159;\n        vec2 uv1 = uv;\n        //if(k>3) uv1 += iTime/8.;\n        vec2 warp =\n            vec2(0.)\n            //vec2(sin((uv1.x)*warp_scale),cos((uv1.y)*warp_scale))/warp_scale\n            //1.-t2.yx*t2.yx\n            //uv1.yx/2.\n        ;\n        \n        vec2 uv_1 =\n            uv+warp.yx\n            //uv/2.+warp.yx\n        ,\n        t2_1=\n            t2+warp.yx\n        ;\n        vec3 col_1 = col;\n        transform(uv,t2);\n        transform(uv_1,t2_1);\n        \n        uv_1 =\n            uv\n            //triangle_wave((uv_1-.5)/3.)-triangle_wave((uv_1.yx)/3.)\n        ;\n        \n        col.x =\n            max(max(length(uv_1-t2_1),abs(uv_1.y-uv_1.x))/3.,col.x);\n            //max(max(length(uv2-t2),abs(uv2.y-uv2.x))/3.,col.x);\n            //max(max(length(uv_last-t2),abs(uv.y-uv.x))/3.,col.x);\n            //max(max(length(vec2(pow(uv.x,2.),pow(uv.y,2.))-sqrt(t2)),abs(uv.y-uv.x))/3.,col.x);\n            //max(max(length(uv*sign(uv)-t2),abs(uv.y-uv.x*sign(uv.y)))/3.,col.x);\n            //max(max(length(uv),length(t2))/3.,col.x);\n            //max(max(length(uv-t2.x),length(t2))/3.,col.x);\n\n            //max(max(length(abs(uv)-abs(t2)),abs(uv.y-uv.x))/3.,col.x);\n            //max(max(length(t2*max(t2,uv)),abs(uv.y-uv.x))/3.,col.x);\n            //max(max(length(abs(uv)-abs(t2)),abs(abs(uv.y)-abs(uv.x)))/3.,col.x);\n            //max(max(length(uv-t2.yx),abs(uv.y-uv.x))/3.,col.x);\n            //max(max(min(length(uv-t2),length(uv-t2.yx)),abs(uv.y-uv.x))/3.,col.x);\n        col =\n            abs(col-(1.-col.x));\n            //abs(abs(col-1.+col.x)-col);\n        col1 =\n            abs(col1-col-1.).yzx;\n            //abs(abs(col1.yzx-col-1.)-col1);\n        //if(uv.y>uv.x) uv /= 1.5;\n        //if(k%3 == 0) {uv = -uv;}\n        //if(uv.x<uv.y) uv.x -= .5;\n\n\n    }\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //a += pow(2.,mod(floor(a*2.),4.))/2.;\n    \n    /*\n    for(float i = 1.; i < mod(floor(a/2.),8.); i++){\n        //a += floor(pow(2.,b));\n        a += mod(floor(a*2.),b)*i;\n    }\n    */\n    \n    //divide by powers of 2 to get interesting rhythms\n    float a1 = (a);\n    //a /= 1. + mod(floor(a1/32.),2.);\n    //a /= 1. + mod(floor(a1/16.),2.);\n    //a /= 1. + mod(floor(a1/8.),2.);\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(a*(1.+mod(floor(a/8.*b),2.))),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n#define fmax1(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fmin1(x,y,z) min(fmod(x,z),fmod(y,z))\nvec2 mainSound(int samp, float time){\n  float tempo = 1.;\n  time /= tempo;\n  float s1 =\n      4.,\n  m4 = fmax1(time+floor(time*s1),time,2.),\n  s2 = 8./(1.+m4),\n  t=\n      time/(1.+m4)\n  ,\n  m1 =\n      fmax1(t*s1,t,s2)\n  ,\n  m3 =\n      fmax1(t/(m1+.5),t,s2);\n  t /=\n      (1.+fmod(t+floor(t+.5),2.))\n  ;\n  //t += pow(2.,mod(floor(t*2.),4.))/2.;\n  t *=\n      s1*s1*(1.+fmod(floor(t*s1*2.)/s1,2.))/(1.+fmod(floor(t*s1/2.)/s1,2.))\n  ;\n  \n  float m2 =\n      1. + fmod((t/s1+floor(t/s1)),s1)\n  ;\n  \n  float a=\n      8.*sqrt((1.-sqrt(fract(t/s1))))\n      //128.*pow((1.-(fract(t/s1))),2.)*.2\n  ,\n\n  nb = time*tempo*pow(2.,(m3+m2)/5.+7.);\n\n  return\n      abs(.5-vec2(fract(nb*.998),fract(nb)))*a\n      //(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 184], [186, 186, 210, 210, 262], [298, 298, 325, 325, 784], [812, 812, 857, 1091, 2244], [2247, 2247, 2304, 2304, 4550]], "test": "untested"}
{"id": "7tcBD8", "name": "FBM morphing noise", "author": "fishy", "description": "Perlin noise", "tags": ["noise", "morph"], "likes": 2, "viewed": 280, "published": 3, "date": "1663008634", "time_retrieved": "2024-07-30T16:31:13.285603", "image_code": "mat2 r(float t)\n{\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\n\nvec2 hash(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return (fract((p3.xx+p3.yz)*p3.zy) - 0.5) * 2.0;\n}\n\nfloat perlinNoise(vec2 p, float s)\n{\n    mat2 r = r(iTime*2.0);\n    vec2 tlVal = r*hash(vec2(floor(p.x),  ceil(p.y)));\n    vec2 blVal = r*hash(vec2(floor(p.x), floor(p.y)));\n    vec2 trVal = r*hash(vec2( ceil(p.x),  ceil(p.y)));\n    vec2 brVal = r*hash(vec2( ceil(p.x), floor(p.y)));\n    \n    vec2 tlOffset = p - vec2(floor(p.x),  ceil(p.y));\n    vec2 blOffset = p - vec2(floor(p.x), floor(p.y));\n    vec2 trOffset = p - vec2( ceil(p.x),  ceil(p.y));\n    vec2 brOffset = p - vec2( ceil(p.x), floor(p.y));\n    \n    float tl = dot(tlOffset, tlVal);\n    float bl = dot(blOffset, blVal);\n    float tr = dot(trOffset, trVal);\n    float br = dot(brOffset, brVal);\n    \n    float a = mix(bl, tl, erp(fract(p.y), s));\n    float b = mix(br, tr, erp(fract(p.y), s));\n    \n    return mix(a, b, erp(fract(p.x), s)) / 2.0 + 0.5;\n}\n\n\n\nfloat fbm(in vec2 x, float s, in float H)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        t += a*perlinNoise(f*x, s);\n        f *= 2.0;\n        a *= G;\n    }\n    return t * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    uv += iTime*0.05;\n    \n    float h = fbm(uv*10.0, 2.0, 1.0);\n    //float h = perlinNoise(uv * 10.0, 2.0);\n    \n    fragColor = vec4(vec3(h),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcBD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 69], [71, 71, 100, 100, 175], [178, 178, 197, 197, 341], [343, 343, 379, 379, 1160], [1164, 1164, 1207, 1207, 1425], [1427, 1427, 1484, 1534, 1767]], "test": "untested"}
{"id": "NlcfWH", "name": "BLF Inverse Kinematics 3D", "author": "iY0Yi", "description": "Ref:\"Foundation ActionScript 3.0 Animation\" P.367\nRef: https://www.alanzucconi.com/2020/09/14/inverse-kinematics-in-3d/", "tags": ["maptoy"], "likes": 16, "viewed": 337, "published": 3, "date": "1663004881", "time_retrieved": "2024-07-30T16:31:14.351752", "image_code": "#define UI_AXIS 0\n#define UI_GRID_2D 0\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 1\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE .75\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\nfloat sdSphere(vec3 p,float s)\n{\n    return length(p)-s;\n}\n\nfloat sdCapsule(vec3 p,vec3 pos1,vec3 pos2,float r)\n{\n    vec3 ap=p-pos1,ab=pos2-pos1;\n    float pro=clamp(dot(ap,ab)/dot(ab,ab),0.,1.);\n    return length(ab*pro-ap)-r;\n}\n\n// Ref:\"Foundation ActionScript 3.0 Animation\" P.367\n// Ref: https://www.alanzucconi.com/2020/09/14/inverse-kinematics-in-3d/\nvec2 ik(vec2 A, vec2 C, float a, float b, bool isInverted){\n    C -= A;\n    float aD = atan(C.y, C.x);\n    float c = min(a+b, length(C));\n    float aB = acos((b*b-a*a-c*c)/(-2.*a*c));\n    float dir = (isInverted) ? -1. : 1.;\n    float aDB = -(aD-aB*dir)+PI*.5;\n    return vec2(sin(aDB),cos(aDB))*a+A;\n}\n\nvec3 ik(inout vec3 A, inout vec3 C, float a, float b, bool isInverted){\n    vec3 ax = vec3(0,1,0); \n    float aC = atan(C.x,C.z);\n    A.xz=rot(A.xz,-aC);\n    C.xz=rot(C.xz,-aC);\n    \n    vec3 B = vec3(0, ik(A.yz, C.yz, a, b, false));\n    \n    A.xz=rot(A.xz,aC);\n    B.xz=rot(B.xz,aC);\n    C.xz=rot(C.xz,aC);\n    return B;\n}\n\nfloat map(vec3 p){\n    p.y+=.35;\n    float t = iTime*3.;\n    float a = 0.4;\n\tfloat b = 0.5;\n\tvec3 A = vec3(0,.2,0);\n    \n    vec3 offC = vec3(sin(t*.5), 0, cos(t*.5))*.5;\n    float radC = .3;\n\tvec3 C = vec3(sin(t)*radC, sin(t*.3)*.2+.3, cos(t)*radC);\n    C+=offC;\n    \n    vec3 B = ik(A, C, a, b, false);\n    \n    float d = 3e38;\n    d=min(d, sdCapsule(p,vec3(0),A,.005));\n    d=min(d, sdCapsule(p,A,B,.005));\n    d=min(d, sdCapsule(p,B,C,.005));\n    d=min(d, length(p-A)-.025);\n    d=min(d, length(p-B)-.025);\n    d=min(d, length(p-C)-.025);\n    d=min(d, max(abs(length(p.xz-offC.xz)-radC)-.01, abs(p.y-C.y)-.01));\n    d=min(d, max(length(p.xz)-.0125, abs(p.y-.05)-.05));\n    d=min(d, max(length(p.xz)-.5, abs(p.y+.0125)-.0125));\n    return d;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.5\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.5 @ 2022/09/14    \n//        - Fixed long compilation in Quad view.\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n#define INIT_CAM_POS vec3(-2,-.5,0)\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 6.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -1, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        vec2 offset;\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n        fragColor = vec4(renderRect(fragCoord*2.-offset),1);\\\n        if((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) || (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.))fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// User Inputs\n\n// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(0, 0, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcfWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 237, 269, 269, 295], [297, 297, 350, 350, 467], [469, 595, 654, 654, 897], [899, 899, 970, 970, 1222], [1224, 1224, 1242, 1242, 1970]], "test": "untested"}
{"id": "ftcBW8", "name": "Graffiti 3D", "author": "leon", "description": "graffin' pixies scree's", "tags": ["tag", "curve", "graffiti"], "likes": 31, "viewed": 475, "published": 3, "date": "1663000243", "time_retrieved": "2024-07-30T16:31:15.153608", "image_code": "\n// Graffiti 3D\n//\n// is it what we call stochastic?\n// when we agree onto something random?\n//\n// trying to render an extruded cube on a curve\n// in a least worst way possible\n//\n// previous iterations were Cyborg Signature and Fraggiti:\n// https://www.shadertoy.com/view/7lcfz7\n// https://www.shadertoy.com/view/NldfR4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // data unpacking\n    vec4 data = texture(iChannel0, uv);\n    float shade = data.r;\n    float timeline = data.g;\n    float glow = data.b;\n    float total = data.a;\n    \n    // background\n    vec4 color = vec4(1) * smoothstep(2., -2., length(uv-.5));\n    \n    if (total > .001 && total < max_dist)\n    {\n        // coloring\n        float tint = shade*2.+total*5.+timeline*1.;\n        vec3 palette = .5+.5*cos(vec3(1,2,3)*5.+tint);\n        color = vec4(palette,1);\n        color *= shade;\n        color += .5*pow(shade, 10.);\n    }\n    else\n    {\n        // outline and shadow\n        color *= smoothstep(5.,0.,glow);\n        color *= .8+.2*smoothstep(.8,0.,glow);\n    }\n    \n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// globals\nconst float delay = 5.;\nvec3 rng;\nfloat timeline, glow;\n\n// move brush\nvec3 move(float t)\n{\n    vec2 pos = vec2(0);\n    float angle = t*100./delay;\n    float radius = .1;\n    float jitter = .2;\n    float time = t*60./delay;\n    float index = floor(time);\n    float anim = fract(time);\n    float scroll = fract(t/delay);\n    vec2 rng = mix(hash21(index), hash21(index+1.), anim);\n    pos += (rng*2.-1.)*jitter;\n    pos.x += scroll*2.-1.;\n    pos.y += pow(abs(sin(time*.2)), 20.)*.4;\n    pos.y -= pow(abs(sin(time*.3)), 50.)*.4;\n    pos += vec2(cos(angle),sin(angle))*radius;\n    return vec3(pos*2., 0);\n}\n\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    float t = timeline;\n    \n    // move it\n    p -= move(t);\n    \n    // twist it\n    p.xz *= rot(t*4.);\n    p.yz *= rot(t*10.);\n    \n    // shape it\n    float size = .05 + .03 * sin(t*16.);\n    dist = sdBox(p, vec3(.5,2,.5)*size);\n    \n    glow += .01/dist;\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    vec2 p = 1.*(fragCoord-R.xy/2.)/R.y;\n    \n    // framebuffer\n    vec4 frame = texture(iChannel0, uv);\n    \n    // accumulate results\n    for (float frames = 10.; frames > 0.; --frames)\n    {\n        // init globals\n        float f = float(iFrame) + frames * 200.;\n        rng = hash(uvec3(fragCoord, f));\n        timeline = rng.x*delay+hash21(floor(iTime/delay)).x*1000.;\n        glow = 0.;\n        \n        // raymarch\n        vec3 pos = vec3(0,0,3);\n        vec3 ray = normalize(vec3(p, -1));\n        float total = 0.;\n        float steps = 0.;\n        const float count = 20.;\n        for (steps = count; steps > 0.; --steps) {\n            float dist = map(pos);\n            if (dist < .001 * total || total > max_dist) break;\n            total += dist;\n            pos += ray * dist;\n        }\n\n        // draw if closer\n        if (total < max_dist && (total < frame.a || frame.a < .001))\n        {\n            // data pack\n            float shade = steps/count;\n            float time = fract(timeline/delay);\n            fragColor = vec4(shade, time, glow, total);\n            frame = fragColor;\n        }\n        else\n        {\n            // store result\n            frame.b = max(frame.b, glow);\n            fragColor = frame;\n        }\n    }\n    \n    // wipe\n    fragColor *= step(.01, fract(iTime/delay));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution\nconst float max_dist = 4.;\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// Inigo Quilez https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Victor Shepardson + Inigo Quilez \n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    return vec3(x)*(1.0/float(0xffffffffU));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcBW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[322, 322, 379, 379, 1127]], "test": "untested"}
{"id": "7ttBWn", "name": "A simple PathTracing test22912", "author": "feiqi3", "description": "Test", "tags": ["pathtracing"], "likes": 1, "viewed": 294, "published": 3, "date": "1662962355", "time_retrieved": "2024-07-30T16:31:16.097086", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nconst int STEPMAX = 32;\nconst float START = 0.0001;\nconst float END = 50.001;\nconst float EPS = 0.00001; \nconst int bounces = 4;\n\nstruct record{\n    float t;\n    vec3 p;\n    mediump vec3 nor;\n    int mat;\n};     \n\nstruct matInfo{\n    vec3 attenuation;\n    bool emitted;\n};\n\n\n//https://iquilezles.org/articles/distfunctions/\nvec2 sdSphere( vec3 p,vec3 pos, float r,int mat )\n{\n  return vec2(length(p - pos)-r,mat);\n}\n\nvec2 Box(vec3 p,vec3 c,vec3 pos,int mat){\n    vec3 p2surf = abs(p - pos) - c;\n    return vec2(length(max(p2surf,0.)) + min(max(max(p2surf.x,p2surf.y),p2surf.z),0.),mat);\n}\n\n\n//https://iquilezles.org/articles/distfunctions/\nvec2 udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d ,int mat)\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return vec2(sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) )\n    ,mat);\n}\n\nvec2 map(vec3 p){\n    vec2 lightTop = udQuad( p, vec3(-8,3.,0), vec3(-8,3,-10), vec3(8,3,-10), vec3(8,3,0),5);\n    vec2 sphere1 =  sdSphere(p,vec3(-2,0.3,-3),1.,2);\n    vec2 sphere2 =  sdSphere(p,vec3(0,1,-5),1.,1);\n    vec2 lightdown = udQuad( p, vec3(-8,-3.,0), vec3(-8,-3,-10), vec3(8,-3,-10), vec3(8,-3,0),5);\n    return uSDF(sphere1,sphere2);\n}\n\nfloat random(float x)\n{\n    float y = fract(sin(x * iTime)*234.567);\n    return y;\n}\n\nvec3 randDirInSph(vec3 seed){\n    return normalize(vec3(2.*(random(seed.y)-.5),2.*(random(seed.z) -.5), 2.*(random(seed.x)-.5)));\n}\n\nvec3 getRay(float fov_degree,vec2 fragCoord,vec2 imgSize){\n    vec2 img_center = imgSize / 2.;\n    float z_cam = ((imgSize.y/2.)/tan(radians(fov_degree)/2.)); \n    return normalize(vec3(fragCoord,0.) - vec3(img_center,z_cam));\n}\n\nvec3 calcNormal( in vec3 p ){ // for function f(p)\n    const float h = 0.0003; // replace by an appropriate value\n    const vec2 k = vec2(1,-1)*0.5773;\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}    \n\nbool intersection(vec3 ro,vec3 rd,inout record rec){\n    float t = START;\n    for(int i = 0; i < STEPMAX; i++){\n        vec3 p = vec3(ro + t * rd);\n        vec2 dis = map(p);\n        if(dis.x < EPS){\n            rec.p = p;\n            rec.t = t;\n            rec.mat = int(dis.y);\n            rec.nor = calcNormal(rec.p);\n            return true;\n        }\n        t += dis.x;\n        if(t > END){\n            return false;\n        }\n    }\n    return false;\n}    \n\nvec3 getMatAndDir(vec3 seed,int mat,vec3 nor,vec3 inDir,inout matInfo info){\n    vec3 dir = vec3(0);\n    //mirror\n    switch(mat){\n        case 1:\n        {\n            info.attenuation = vec3(.7, .7, .7);\n            return reflect(inDir, nor);\n            break;\n        }\n        //red\n        case 2:\n        {\n            info.attenuation = vec3(.65, .05, .05);\n            return normalize(nor + randDirInSph(seed));\n            break;\n        }\n        //white\n        case 3:\n        {\n            info.attenuation = vec3(.73, .73, .73);\n            return normalize(nor + randDirInSph(seed));\n            break;\n        }\n        //green\n        case 4:\n        {\n            info.attenuation = vec3(.12, .45, .15);\n            return normalize(nor + randDirInSph(seed));\n            break;\n        }\n        //light\n        case 5:\n        {\n            info.attenuation = vec3(1,1,1);\n            info.emitted = true;\n            return normalize(nor + randDirInSph(seed));\n            break;\n        }\n    }\n    return dir;\n}\n\nvec3 pathTracing(vec3 ro,vec3 rd){\n    vec3 r_ori = ro;\n    vec3 r_dir = rd;\n    vec3 clr = vec3(1,1,1);\n    record rec;\n    matInfo info;\n    for(int i = 0; i < bounces; i++){\n        if(intersection(r_ori,r_dir,rec)){\n            r_dir = getMatAndDir(rec.p,rec.mat,rec.nor,r_dir,info);\n            r_ori = rec.p;\n            clr *= info.attenuation;\n            if(info.emitted){\n                return clr;\n            }\n        }\n    }\n    return texture(iChannel1,r_dir).rgb * clr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //AA\n    vec2 jitter = randDirInSph(fragCoord.xyy).xz/2.;\n    vec3 camPos =vec3(0,0,10);\n    vec3 dir = getRay(45.0,fragCoord+jitter,iResolution.xy);  \n    vec4 clr =vec4(pathTracing(camPos,dir),1.);\n    vec4 lastFrame;\n    if(iFrame == 0){\n        fragColor = clr;\n        return;\n    }else{\n        lastFrame = texture(iChannel0,fragCoord/iResolution.xy);\n    }\n    fragColor = mix(lastFrame,clr,1./ float(iFrame+1));\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 uSDF(vec2 a,vec2 b){\n    return a.x < b.x ? a : b;\n}\nvec2 iSDF(vec2 a,vec2 b){\n    return a.x > b.x ? a : b;\n}\nvec2 dSDF(vec2 a,vec2 b){\n    return a.x > -b.x ? a : b;\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttBWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 121]], "test": "untested"}
{"id": "NtdBDr", "name": "fake cloud", "author": "jorge2017a2", "description": "fake cloud", "tags": ["fakecloud"], "likes": 6, "viewed": 283, "published": 3, "date": "1662951361", "time_retrieved": "2024-07-30T16:31:16.903928", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 255.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n\n//fake cloud....por jorgefp--JFP\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\nvec2 uvg;\n\n///referencia Iq, patriciogv, FabriceNeyret2, Shane, etc\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat HacerCuadro(vec2 uv)\n{   return sdBox(uv, vec2(1.0,1.0)); }\n\nfloat HacerCuadroRnd(vec2 uv)\n{   vec2 pos;\n   float t=iTime;\n    float pnx= noise(uv+t)*5.0;\n    float pny= noise(uv+t)*4.0;\n    uv=vec2(floor(pnx), (pny));\n    float d1= HacerCuadro(uv);\n    return d1;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n     p.y=p.y+10.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    float planed2= -p.y+30.0;\n    \n    res =opU2(res, vec2(planeDist1,57.0));\n    res =opU2(res, vec2(planed2,70.0));\n    p.y=p.y-5.0;\n    float sds1=sdSphere(p-vec3(0.0,abs(5.0*sin(iTime)),0.0) , 5.0 );\n    res =opU2(res, vec2(sds1,13.0));\n    float d2=sdSphere(p-vec3(10.0,0.0,0.0), 5.0 );\n    res =opU2(res, vec2(d2,100.0));\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 )\n    { col=tex3D(iChannel0, p/16., nor); return col*2.0; }\n    return vec3(0.0);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    //col += 0.4*smoothstep(-0.03,0.04,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col += 0.5*smoothstep(-0.05,0.06,cos(uv.x*0.4)*cos(uv.y*0.4)); \n    col *= smoothstep(-1.0,-0.95,cos(uv.x*0.8))*smoothstep(-1.0,-0.95,cos(uv.y*0.8));\n    return col;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color, vec3 colOut)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n     \n        \n    if (id_color==57) {return pattern( p.xz );}\n    if (id_color==58) {return pattern( p.xy );}\n    if (id_color==59) {return pattern( p.zy );}\n    \n    \n    if (id_color==70)\n    {  float d1=HacerCuadroRnd(p.xz*0.25);\n     if (d1<0.1)\n         colobj=vec3(1.0)*d1; \n     else\n         colobj=colOut*2.0;\n          return colobj;\n     }\n    \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n      \n  return vec3(0.0);\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{ \n vec3 col = vec3(0);\n col= render_sky_color(rd);\n \n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y),col);\n        vec3 result;\n         float d1=HacerCuadroRnd(p.xz*0.25);\n         if(d1>0.6)\n             d1=1.0;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1*d1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2*d1;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;        \n    }\n   // else if(hit.x>MAX_DIST)\n   // col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n     vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    uvg=uv;\n   \n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n  \n   vec3 ro=vec3(0.0,7.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n      float tc=5.0*sin(t0);\n    if(tc>0.0)\n    rd= rotate_x(rd, clamp( sin(t0*0.5),-0.25,0.5 ) );\n    else\n    rd= rotate_y(rd, clamp( sin(t0*0.5),-0.25,0.5 ) );\n    \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n\n\n\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtdBDr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[565, 565, 601, 601, 622], [623, 623, 655, 655, 739], [741, 741, 777, 777, 822], [824, 824, 858, 858, 954], [955, 955, 989, 989, 1080], [1081, 1081, 1115, 1115, 1206], [1210, 1210, 1247, 1247, 1321], [1323, 1323, 1351, 1351, 1388], [1390, 1390, 1421, 1421, 1595], [1597, 1597, 1622, 1622, 2081], [2083, 2083, 2107, 2107, 2269], [2272, 2272, 2321, 2321, 2430], [2432, 2432, 2480, 2480, 2759], [2762, 2762, 2806, 2806, 3127], [3129, 3129, 3166, 3166, 3423], [3426, 3426, 3516, 3516, 4473], [4476, 4476, 4508, 4508, 4706], [4708, 4756, 4784, 4784, 5050], [5052, 5052, 5135, 5135, 5692], [5694, 5694, 5721, 5721, 5810], [5812, 5812, 5870, 5870, 5918], [5920, 5920, 5943, 5943, 6055], [6057, 6057, 6088, 6088, 6847], [6849, 6849, 6906, 6906, 7581]], "test": "untested"}
{"id": "ftdfWn", "name": "Julia set of x^-2 + c", "author": "chengsun", "description": "The most well-known Julia set is defined by the iteration function x -> x^2 + c.\nChanging the exponent to negative or complex numbers leads to interesting results.\nHere it is set to -2.", "tags": ["2d", "fractal", "julia"], "likes": 5, "viewed": 235, "published": 3, "date": "1662934051", "time_retrieved": "2024-07-30T16:31:17.746675", "image_code": "#define ITER_MAX 13\n#define TIME_SCALE 6\n#define ZOOM 4\n//#define CUSTOM_EXPONENT vec2(-2., 0.)\n\n\n\n// conversions between cartesian (x+yi) and polar (xe^(iy)) forms of complex numbers\nvec2 cartesian_of_polar(vec2 polar) {\n    return vec2(polar.x * cos(polar.y), polar.x * sin(polar.y));\n}\n\nvec2 polar_of_cartesian(vec2 cartesian) {\n    return vec2(length(cartesian), atan(cartesian.y, cartesian.x));\n}\n\n// multiplication of two complex numbers in cartesian form\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// exponential of a complex number by a complex number, both in cartesian form\nvec2 cexp(vec2 b, vec2 e) {\n    vec2 b_polar = polar_of_cartesian(b);\n    vec2 logb = vec2(log(b_polar.x), b_polar.y);\n    vec2 new_e = cmul(logb, e);\n    vec2 ans_polar = vec2(exp(new_e.x), new_e.y);\n    return cartesian_of_polar(ans_polar);\n}\n\n// cexp, specialized to e = vec2(-2., 0.)\nvec2 cexp_m2(vec2 b) {\n    vec2 b_invmag = b / vec2(dot(b, b));\n    return vec2((b_invmag.x*b_invmag.x - b_invmag.y*b_invmag.y), -2.*b_invmag.x*b_invmag.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -ZOOM to ZOOM)\n    vec2 uv = vec2(2. * float(ZOOM)) * (fragCoord - iResolution.xy/vec2(2.)) / vec2(max(iResolution.x, iResolution.y));\n\n    // Animate the constant c\n    float t = iTime/float(TIME_SCALE);\n    vec2 c = (vec2(cos(t)*abs(cos(t)), sin(t)*abs(sin(t)))) * vec2(0.7665);\n\n    // Computation of the Julia set defined by the iteration x -> x^-2 + c\n    vec2 x = uv;\n    int iter = 0;\n    for (iter = 0; iter < ITER_MAX; ++iter) {\n        \n        if (dot(x, x) > 40.) break;\n#ifdef CUSTOM_EXPONENT\n            x = cexp(x, CUSTOM_EXPONENT);\n#else\n            x = cexp_m2(x);\n#endif\n        x += c;\n    }\n    vec3 col = vec3(float(iter) / float(ITER_MAX)) * vec3(c, 1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 184, 221, 221, 288], [290, 290, 331, 331, 401], [403, 462, 489, 489, 554], [556, 635, 662, 662, 879], [881, 923, 945, 945, 1081], [1083, 1083, 1138, 1195, 1916]], "test": "untested"}
{"id": "7tcBDn", "name": "shiny kifs", "author": "pb", "description": "just one of an amazing variety of structures possible, play with #define t2", "tags": ["fractal", "raymarch", "kifs"], "likes": 21, "viewed": 515, "published": 3, "date": "1662929569", "time_retrieved": "2024-07-30T16:31:18.717080", "image_code": "//philip.bertani@gmail.com\n//kifs dist func taken from Shane's - https://www.shadertoy.com/view/XsKXzc - and modified\n#define t2 4.2 + .1*sin(t1/5.) //modify this to get LOTS of different shapes\n#define cc2 vec2(cos(t2),sin(t2))\n#define dp vec2(1.,-1) \n#define dN(x) x*ff(p+.0001*(1.+totdist*20.)*x)\n#define t1 iTime\n#define cc vec2(cos(t1),sin(t1))\n#define t4 t2 + .1\n#define cc4 vec2(cos(t4),sin(t4))\n#define t3 iTime/7.\n#define cc3 vec2(cos(t3),sin(t3))\n#define FR  mat2(cc2.x,-cc2.y,cc2.y,cc2.x)\n#define FR1 mat2(cc4.x,-cc4.y,cc4.y,cc4.x)\n#define FR2 mat2(cc.x,-cc.y,cc.y,cc.x)\n#define FR3 mat2(cc3.x,-cc3.y,cc3.y,cc3.x)\n#define R(k,v) v*cc.x+cross(k,v)*cc.y+k*dot(k,v)*(1.-cc.x)\nvec3 ro,rd,ll=vec3(20.,-2.,-10.),kk=normalize(vec3(1.,-.5,-1.)),l2;float mi,dt,tt,totdist;\nfloat ff(vec3 p){p.xz=FR3*p.xz;float dist=1e6,sc=1.006,amp=1./sc,sz=.02,ew=.002;vec3 offs=vec3(1.,.75,.15);\nfor(float i=0.;i<100.;i++){if(i>mi)break;p.xy=FR*p.xy;p.yz=FR1*p.yz;p=abs(p);\np.xy+=step(p.x,p.y)*(p.yx-p.xy);p.xz+=step(p.x,p.z)*(p.zx-p.xz);p.yz+=step(p.y,p.z)*(p.zy-p.yz);\np=p*sc+offs*(1.-sc);p.z-=step(p.z,offs.z*(1.-sc)*.5)*offs.z*(1.-sc);p=abs(p);vec3 q=p*amp;float box=max(max(q.x,q.y),q.z)-sz;\nbox=max(box,-(min(min(max(q.x,q.y),max(q.x,q.z)),max(q.y,q.z))-sz+ew));dist=min(dist,box);amp/=sc;}return dist;}\nvec3 nn(vec3 p){return normalize(dN(dp.xxx)+dN(dp.yyx)+dN(dp.xyy)+dN(dp.yxy));}\nvec3 color(vec3 p){l2=normalize(l2-p);vec3 no=nn(p);return .4*(max(0.,dot(-nn(p),l2)))*vec3(.5,.6,.8)\n+.6*pow(max(0.,dot(reflect(-rd,no),l2)),4.)*vec3(.8,.6,2.);}\nvoid mainImage(out vec4 rgba,in vec2 xy){xy=(2.*xy-iResolution.xy)/iResolution.y;rgba.rgb=vec3(0.);rgba.a=1.;\nro=vec3(0.,0.,max(0.,0.37-max(.7*sin(t1/2.),0.)));rd=normalize(vec3(xy,-2.));vec3 p=ro;float dist=0.;totdist=0.;mi=28.;\nl2=R(kk,ll);for (float i=0.;i<100.;i++) {dist=ff(p)*.8;totdist+=dist;if(dist<(dt=.0001*(1.+totdist*70.))) \n{rgba.rgb=pow((1.-exp(-color(p-abs(dist-dt)*rd)))*2.5*exp(-totdist/2.),vec3(3.));break;}else if(totdist>3.)break;p+=dist*rd;}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tcBDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[775, 775, 792, 792, 1296], [1297, 1297, 1313, 1313, 1376], [1377, 1377, 1396, 1396, 1539], [1540, 1540, 1581, 1581, 2004]], "test": "untested"}
{"id": "sttfz4", "name": "BLF Inverse Kinematics 2D", "author": "iY0Yi", "description": "inverse kinematics using the law of cosines.\nRef: \"Foundation ActionScript 3.0 Animation\"", "tags": ["ik"], "likes": 10, "viewed": 366, "published": 3, "date": "1662918681", "time_retrieved": "2024-07-30T16:31:19.752313", "image_code": "#define PI acos(-1.)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle(vec2 p, float r){\n    return length(p)-r;\n}\n\n// Ref: \"Foundation ActionScript 3.0 Animation\" P.367\nvec2 ik(vec2 A, vec2 C, float a, float b){\n    vec2 oC = C-A;\n    float aD = atan(oC.y, oC.x);\n    float c = min(a+b, (C.x-A.x)/cos(aD));\n    if(c<=abs(a-b))return normalize(C)*a;\n    float aB = acos((b*b - a*a - c*c) / (-2.*a*c));\n    float aDB = -(aD+aB)+PI*.5;\n    return vec2(sin(aDB),cos(aDB))*a;\n}\n\nvoid mainImage( out vec4 O, in vec2 R )\n{\n    vec2 uv = ( R - .5 * iResolution.xy ) / iResolution.y;\n    \n    const float l1 = .5;\n    const float l2 = .3;\n    vec2 st = vec2(0);//vec2(sin(iTime*3.),cos(iTime*3.))*.01;\n    vec2 ed = vec2(sin(iTime),cos(iTime))*(.4+(sin(iTime*5.)+1.)*.2);\n    if(iMouse.z>0.)ed = -vec2((iMouse.x/iResolution.x-.5)*iResolution.x/iResolution.y, iMouse.y/iResolution.y-.5);\n\n    vec2 md = ik(st, ed, l1, l2);\n    \n    float s = sdCircle(uv+st, .025);\n    float m = sdCircle(uv+st+md, .025);\n    float e = sdCircle(uv+st+ed, .025);\n    float seg1 = sdSegment(uv, -st, -st-md);\n    float seg2 = sdSegment(uv, -st-md, -st-ed);\n    \n    float cirStMd = abs(sdCircle(uv+st, l1))-.001;\n    float cirMdEd = abs(sdCircle(uv+st+md, l2))-.001;\n    \n    float aas = 2.5/iResolution.y;\n    float d = smoothstep(.0,aas,min(s,min(m,e)));\n    d = smoothstep(.0,aas,min(d,min(seg1,seg2)));\n    d = min(d, smoothstep(.0,aas,cirStMd));\n    d = min(d, smoothstep(.0,aas,cirMdEd));\n    vec3 col = mix(vec3(0.875,0.835,0.749), vec3(0.102,0.082,0.039), d);    \n    O = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sttfz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 102, 102, 123], [125, 177, 229, 229, 348], [350, 350, 382, 382, 408], [410, 464, 506, 506, 767], [769, 769, 810, 810, 1862]], "test": "untested"}
{"id": "7lcBWr", "name": "curl_noise", "author": "lanx06", "description": "curl_noise", "tags": ["curlnoise", "sinlerp"], "likes": 5, "viewed": 251, "published": 3, "date": "1662916082", "time_retrieved": "2024-07-30T16:31:20.700777", "image_code": "\n#ifdef GL_ES\n#define PI 3.1415926538\nprecision mediump float;\n#endif\n\nfloat sin_lerp(float a,float b,float t){\n    float tem=(1.0-cos(t*PI))/2.0;\n    return a*(1.0-tem)+b*tem;\n}\nfloat random(float seed){\n    return fract(sin(seed+1.) * 43758.5453);\n}\nfloat curl_random(float seed,float offset,float freq){\n    return sin_lerp(random(offset+floor(mod(seed,freq))),random(offset+floor(mod(seed+1.,freq))),abs(seed-floor(seed)));\n}\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0? sign(y)*PI/2.0 : atan(y, x);\n}\nfloat draw(float y,float v,float size){\n    return smoothstep(v-size,v,y)-smoothstep(v,v+size,y);\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st-=vec2(0.5);\n    vec3 col=vec3(0.0);\n    vec2 new_st=vec2((atan2(st.x,st.y)+PI)/PI/2.+iTime*.000,length(st));\n    float freq=10.0;\n    float noise=.1;\n    float size=.3;\n    float widht=.005;\n    #define SIDE_DEPTH 100\n    for(int i=0;i<SIDE_DEPTH;i++){\n        float nor=float(i)/float(SIDE_DEPTH)/2.;\n        float offset=curl_random(iTime*3.+float(i)*.01+new_st.x*20.,0.,20.);\n        float v=(curl_random(new_st.x*freq,10.,freq)*offset*noise+size);\n        col+=vec3(draw(new_st.y*.5,nor*v,widht))/float(SIDE_DEPTH-i);; \n    }\n    col*=vec3(0.8706, 0.9765, 0.9843);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcBWr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 111, 111, 178], [179, 179, 204, 204, 251], [252, 252, 306, 306, 429], [430, 430, 467, 467, 519], [520, 520, 559, 559, 619], [620, 620, 674, 674, 1326]], "test": "untested"}
{"id": "Nl3BDr", "name": "Union Jack Flag 2", "author": "dr2", "description": "Flying at half mast", "tags": ["flag", "dynamics", "physics"], "likes": 8, "viewed": 285, "published": 3, "date": "1662896374", "time_retrieved": "2024-07-30T16:31:22.067123", "image_code": "// \"Union Jack Flag 2\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  1   // optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (vec2 vId);\n\nconst ivec2 nBallE = ivec2 (65, 33);\nconst int nsMax = 5000;\n\nvec4 bsSize;\nvec3 sunDir, qHit;\nvec2 qgHit;\nfloat dstFar, tCur, spLen, szFac, flSize;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qt;\n  float dMin, d, h;\n  dMin = dstFar;\n  h = 4. * flSize + 1.;\n  q = p;\n  q.y -= h + bsSize.y;\n  d = PrCylDf (q.xzy, 0.1, h);\n  DMINQ (1);\n  q = p;\n  q.y = abs (q.y - h - bsSize.y) - h;\n  d = PrCylDf (q.xzy, 0.2, 0.06);\n  DMINQ (2);\n  q = p;\n  d = max (PrRoundBoxDf (q, bsSize.xyz - bsSize.w, bsSize.w), - q.y);\n  DMINQ (3);\n  qt.xz = abs (p.xz) + 0.4;\n  qt.y = p.y - 0.7;\n  qt -= bsSize.xyz;\n  d = min (PrCylDf (vec3 (qt.xy, p.z), 0.1, bsSize.z - 0.4),\n     PrCylDf (vec3 (p.x, qt.yz).zyx, 0.1, bsSize.x - 0.4));\n  qt.y -= -0.3;\n  d = min (d, PrCylDf (qt.xzy, 0.1, 0.4));\n  DMINQ (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nfloat SheetRay (vec3 ro, vec3 rd)\n{\n  vec3 r, q;\n  vec2 g;\n  float d, dMin, sz, szMax, szMin, grLen;\n  bvec2 ilt;\n  bool bkTrak;\n  grLen = 0.92 * spLen;\n  dMin = dstFar / (grLen * szFac);\n  ro /= szFac;\n  rd /= grLen;\n  szMax = float (nBallE.x - 1);\n  szMin = 1./32.;\n  sz = szMax;\n  g = vec2 (0.);\n  bkTrak = false;\n  for (int ns = VAR_ZERO; ns < nsMax; ns ++) {\n    if (sz == szMin) {\n      r = GetR (g) - ro;\n      q = cross (r, rd);\n      if (dot (q, q) < sz * sz) {\n        d = dot (r, rd);\n        if (d < dMin) {\n          dMin = d;\n          qgHit = g;\n        }\n      }\n      bkTrak = true;\n    }\n    q = cross (GetR (g + 0.5 * sz) - ro, rd);\n    bkTrak = bkTrak || (dot (q, q) > sz * sz);\n    if (bkTrak) {\n      bkTrak = false;\n      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));\n      g.x += ilt.x ? sz : - sz;\n      if (! ilt.x) {\n        if (sz == 0.5 * szMax) break;\n        g.y += ilt.y ? sz : - sz;\n        if (! ilt.y) {\n          sz *= 2.;\n          if (sz == szMax) break;\n          bkTrak = true;\n        }\n      }\n    } else if (sz > szMin) sz *= 0.5;\n  }\n  return dMin * grLen * szFac;\n}\n\nvec3 GetRC (vec2 v)\n{\n  return GetR (clamp (v, vec2 (0.), vec2 (nBallE - 1)));\n}\n\nvec3 SheetNf () \n{\n  vec3 c;\n  vec2 e = vec2 (1., 0.);\n  c = GetRC (qgHit);\n  return normalize (cross (GetRC (qgHit + e.yx) - c, GetRC (qgHit + e) - c));\n}\n\nfloat SheetSilHit (vec3 ro, vec3 rd)\n{\n  vec3 blkSize, pMin, pMax, v, tm, tp;\n  float dn, df;\n  pMin = Loadv4 (vec2 (1, nBallE.y)).xyz;\n  pMax = Loadv4 (vec2 (2, nBallE.y)).xyz;\n  ro /= szFac;\n  ro -= 0.5 * (pMin + pMax);\n  blkSize = 0.5 * (pMax - pMin) + 0.5;\n  v = ro  / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  return (df > 0. && dn < df) ? szFac * dn : dstFar;\n}\n\nvec3 SheetCol (float s)\n{  // specs from Wikipedia\n  vec3 col, colB, colR, colW;\n  vec2 p, q;\n  float w;\n  p = (qgHit / (0.5 * float (nBallE.y - 1)) - 1.);\n  p.x -= 1.;\n  colB = vec3 (1., 33., 105.) / 255.;\n  colR = vec3 (200., 16., 46.) / 255.;\n  colW = vec3 (1.);\n  col = colB;\n  w = 1./15.;\n  q = Rot2D (p, atan (0.5));\n  col = mix (colW, col, smoothstep (0., 0.02, abs (q.y) - 3. * w));\n  col = mix (colR, col, smoothstep (0., 0.02, abs (q.y - sign (p.x) * w) - w));\n  q = Rot2D (p, atan (-0.5));\n  col = mix (colW, col, smoothstep (0., 0.02, abs (q.y) - 3.* w));\n  col = mix (colR, col, smoothstep (0., 0.02, abs (q.y - sign (p.x) * w) - w));\n  q = p;\n  col = mix (colW, col, smoothstep (0., 0.02, min (abs (q.x), abs (q.y)) - 5.* w));\n  col = mix (colR, col, smoothstep (0., 0.02, min (abs (q.x), abs (q.y)) - 3.* w));\n  return col;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, p, c1, c2, vn;\n  float ds, fd, att, attSum, sd;\n  c1 = vec3 (0.8, 0.7, 0.3);\n  c2 = vec3 (0.3, 0.9, 0.);\n  if (rd.y > -0.003 && rd.y < 0.01 + 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = 0.215 * (c1 + c2);\n  } else if (rd.y < 0.) {\n    p = ro - (ro.y / rd.y) * rd;\n    vn = VaryNf (0.25 * p, vec3 (0., 1., 0.), 0.2 * (1. -\n       smoothstep (0.5, 0.8, length (ro) / dstFar)));\n    col = mix (c1, c2, Fbm2 (0.5 * p.xz)) * (1. - 0.1 * Noisefv2 (p.xz));\n    col = mix (col, 0.5 * (c1 + c2), smoothstep (-0.1, 0., rd.y)) *\n       (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) *\n       (0.8 + 0.2 * smoothstep (0., 0.5, PrRoundBox2Df (p.xz, bsSize.xz - bsSize.w, bsSize.w)));\n  } else {\n    p = ((100. - ro.y) / rd.y) * rd;\n    ds = 0.1 * sqrt (length (p));\n    p += ro;\n    fd = 0.002 / (smoothstep (0., 10., ds) + 0.1);\n    p.xz = p.xz * fd - 0.1 * tCur;\n    att = Fbm2 (p.xz);\n    attSum = att;\n    for (float j = 0.; j < 4.; j ++) {\n      attSum += Fbm2 (p.xz + (1. + j * ds) * fd * sunDir.xz);\n    }\n    attSum *= 0.3;\n    att *= 0.3;\n    sd = clamp (dot (sunDir, rd), 0., 1.);\n    col = mix (vec3 (0.5, 0.75, 1.), mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1),\n       0.25 + 0.75 * sd), exp (-2. * (3. - sd) * max (rd.y - 0.1, 0.))) +\n       0.3 * (vec3 (1., 0.8, 0.7) * pow (sd, 1024.) + vec3 (1., 0.4, 0.2) * pow (sd, 256.));\n    attSum = 1. - smoothstep (1., 9., attSum);\n    col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.3, 0.3, 0.3), att), attSum) +\n       vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (sd, 10.) + 0.5);\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, q;\n  float dstObj, dstSheet, s;\n  szFac = 4. / float (nBallE.y - 1);\n  flSize = szFac * 0.5 * float (nBallE.y + 1);\n  bsSize = vec4 (3.5, 0.3, 3.5, 0.2);\n  dstObj = ObjRay (ro, rd);\n  q = ro;\n  q.xy -= vec2 (2. * flSize + 0.1, 4. * flSize + 4. + bsSize.y);\n  dstSheet = (SheetSilHit (q, rd) < dstFar) ? SheetRay (q, rd) : dstFar;\n  if (min (dstSheet, dstObj) < dstFar) {\n    if (dstSheet < dstObj) {\n      vn = SheetNf ();\n      s = sign (dot (rd, vn));\n      if (s > 0.) vn = - vn;\n      col4 = vec4 (SheetCol (s), 0.05);\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        col4 = vec4 (0.85, 0.8, 0.8, 0.2);\n        if (abs (qHit.y - 3.) < flSize + 0.1) col4.rgb *= (0.7 + 0.3 * smoothstep (0.05, 0.1,\n           abs (mod (4. * (qHit.y - 3. + 0.02) / flSize + 0.5, 1.) - 0.5)));\n      } else if (idObj == 2) {\n        col4 = vec4 (0.85, 0.85, 0.8, 0.2);\n      } else if (idObj == 3) {\n        col4 = vec4 (0.55, 0.5, 0.5, 0.);\n        vn = VaryNf (2. * ro, vn, 0.5);\n      } else if (idObj == 4) {\n        col4 = vec4 (0.4, 0.1, 0., 0.2);\n      }\n    }\n    col = col4.rgb * (0.4 + 0.2 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n       0.6 * max (dot (vn, sunDir), 0.)) +\n       col4.a * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n  } else col = BgCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = mod (0.01 * tCur, 2.);\n    az = pi - 2.5 * pi * (0.5 - abs ((floor (16. * t) + smoothstep (0.8, 1., \n       fract (16. * t))) / 16. - 1.));\n  }\n  el = clamp (el, -0.3 * pi, 0.);\n  vuMat = StdVuMat (el, az);\n  zmFac = 4.;\n  ro = vec3 (2., 9., -50.);\n  ro = vuMat * ro;\n  stDat = Loadv4 (vec2 (0, nBallE.y));\n  spLen = stDat.x;\n  dstFar = 160.;\n  sunDir = normalize (vec3 (0., 0.3, -1.));\n  sunDir.xz = Rot2D (sunDir.xz, - pi / 6.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Union Jack Flag 2\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.1415927;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 2) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if      (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \"Union Jack Flag 2\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Fbm1 (float p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst ivec2 nBallE = ivec2 (65, 33);\n\nvec3 pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat tCur, spLen, nStep;\nconst float pi = 3.1415927;\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE.x), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fSpringD, fDamp;\n  fSpring = 400.;\n  fDamp = 1.;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  fSpringD = 3. * fSpring;\n  spLenD = spLen * sqrt(2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE.y && ivn.x >= 0 && ivn.x < nBallE.x) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpringD * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd;\n  bool doInt;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE.x - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE.x - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE.y - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE.y - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE.x * nBallE.y; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE.x) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE.y - 1 && iv.x > 0 && iv.x < nBallE.x - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f, wDir;\n  vec2 s;\n  float fOvlap, fBend, fGrav, fDamp, dt;\n  IdNebs ();\n  fOvlap = 1000.;\n  fBend = 50.;\n  fGrav = 0.25;\n  fDamp = 0.5;\n  wDir = vec3 (Rot2D (vec2 (-1., 0.), 0.7 * pi * (2. * Fbm1 (1.5 * tCur) - 1.)), 0.).xzy;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = fOvlap * PairForce (r) + SpringForce (iv, r, v) + fBend * BendForce (iv, r) +\n     (1. + 10. * Fbm1 (tCur)) * NormForce (iv, r, wDir);\n  f -= fDamp * v;\n  f.y -= fGrav;\n  dt = 0.02;\n  if (iv.x != 0 || mod (float (iv.y), float ((nBallE.y - 1) / 8)) != 0. && iv.y != nBallE.y - 2) {\n    v += dt * f;\n    r += dt * v;\n  }\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, iy, 0.);\n        r.xy -= 0.5 * (vec2 (nBallE.x, nBallE.y) - 1.);\n        r *= 0.97 * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE.x + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3), Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE.y; iy ++) {\n    for (int ix = 0; ix < nBallE.x; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v;\n  ivec2 pxIv, iv;\n  int mId, pxId, nb;\n  tCur = iTime;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE.x * pxIv.y;\n  nb = nBallE.x * nBallE.y;\n  if (pxIv.x >= 2 * nBallE.x || pxId >= 2 * nb + 3) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE.x) iv.x -= nBallE.x;\n  mId = iv.y * nBallE.x + iv.x;\n  if (iFrame <= 2) {\n    spLen = 1.1;\n    nStep = 0.;\n    if (mId < nb) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE.y));\n    spLen = stDat.x;\n    nStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE.y));\n    ++ nStep;\n    if (mId < nb) Step (iv, r, v);\n  }\n  if (pxId == 2 * nb + 1 || pxId == 2 * nb + 2) SheetLims ();\n  if (pxId < 2 * nb) stDat = vec4 (((pxIv.x >= nBallE.x) ? v : r), 0.);\n  else {\n    if      (pxId == 2 * nb + 0) stDat = stDat = vec4 (spLen, nStep, 0., 0.);\n    else if (pxId == 2 * nb + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * nb + 2) stDat = vec4 (pMax, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3BDr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[915, 915, 937, 937, 1552], [1554, 1554, 1587, 1587, 1834], [1836, 1836, 1857, 1857, 2112], [2114, 2114, 2134, 2134, 2161], [2163, 2163, 2198, 2198, 3279], [3281, 3281, 3302, 3302, 3361], [3363, 3363, 3381, 3381, 3518], [3520, 3520, 3558, 3558, 3942], [3944, 3944, 3969, 3994, 4784], [4786, 4786, 4817, 4817, 6387], [6389, 6389, 6424, 6424, 7809], [7811, 7811, 7867, 7867, 9129], [9131, 9131, 9173, 9173, 9224], [9226, 9226, 9272, 9272, 9319], [9321, 9321, 9368, 9368, 9415], [9417, 9417, 9439, 9439, 9477], [9479, 9479, 9501, 9501, 9539], [9541, 9541, 9598, 9598, 9681], [9683, 9683, 9719, 9719, 9925], [9927, 9927, 9957, 9957, 10070], [10104, 10104, 10128, 10128, 10181], [10183, 10183, 10207, 10207, 10337], [10339, 10339, 10364, 10364, 10510], [10512, 10512, 10537, 10537, 10723], [10725, 10725, 10747, 10747, 10901], [10903, 10903, 10924, 10924, 11079], [11081, 11081, 11110, 11110, 11322], [11324, 11324, 11363, 11363, 11615], [11682, 11682, 11706, 11706, 11756]], "test": "untested"}
{"id": "7lcfz7", "name": "Cyborg Signature", "author": "leon", "description": "virtual artificial intelligence signing generated algorithm certificates", "tags": ["tag", "graffiti", "cyborg"], "likes": 26, "viewed": 541, "published": 3, "date": "1662891620", "time_retrieved": "2024-07-30T16:31:23.175162", "image_code": "\n// Cyborg Signature,\n// when you have to sign that check for your ai bot therapist\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0, 0, 0, 1);\n    vec2 uv = fragCoord/iResolution.xy;\n    float timeline = fract(iTime*speed);\n    \n    // data readability unpacking\n    vec4 data = texture(iChannel0, uv);\n    float mask = data.r;\n    float timestamp = data.b;\n    float dist = data.g;\n    float material = data.a;\n    float glow = texture(iChannel1, uv).a;\n    vec3 normal = texture(iChannel1, uv).rgb;\n    \n    // background\n    color.rgb = vec3(1) * smoothstep(2., -2., length(uv-.5));\n    \n    // ambient occlusion\n    if (.01 < timeline) \n        color *= smoothstep(-.5,.2,dist);\n    \n    if (mask > .001)\n    {\n        // lighting\n        vec3 light = normalize(vec3(0,1,1));\n        float shade = dot(normal, light)*.5+.5;\n        color *= material;\n        color += glow;\n        color += pow(shade, 10.);\n\n    // debug g-buffer\n    } else if (false) {\n    \n        uv *= 4.;\n        if (inside(uv))\n        {\n            // data pack\n            vec4 d = texture(iChannel0, uv);\n            color = fract(d.grba*3.);\n        }\n        uv.x -= 1.;\n        if (inside(uv))\n        {\n            // normal and glow\n            vec4 d = texture(iChannel1, uv);\n            if (d.r > .001)\n                color += d;\n            color += d.aaaa;\n        }\n    }\n    \n    // shine\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*5.+uv.x*6.);\n    color.rgb += tint*glow;\n    \n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// move horizontally, with circles and random offset\nvec2 move(float t)\n{\n    vec2 pos = vec2(0);\n    float angle = t*10.;\n    float radius = .1;\n    float jitter = .1;\n    float time = t*5.;\n    float index = floor(time);\n    float anim = fract(time);\n    float scroll = fract(t*speed);\n    vec2 rng = mix(hash21(index), hash21(index+1.), anim);\n    pos += (rng*2.-1.)*jitter;\n    pos.x += scroll*2.-1.;\n    pos.y += pow(abs(sin(time*.2)), 20.)*.5;\n    pos.y -= pow(abs(sin(time*.1)), 50.)*.4;\n    pos += vec2(cos(angle),sin(angle*1.5))*radius;\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = 1.5*(fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    // shape\n    float thin = .02+.01*sin(iTime*10.);\n    float time = iTime;\n    float dist = sdSegment(pos, move(time-iTimeDelta), move(time));\n    float mask = smoothstep(thin,.0,dist);\n    \n    // frame buffer\n    vec4 frame = texture(iChannel0, uv);\n    if (frame.g > .0) dist = min(dist, frame.g);\n    float timestamp = mix(frame.b, iTime, step(.0001,mask));\n    mask = max(mask*.1,frame.r);\n    float material = step(threshold,fract(timestamp*cycle));\n    \n    // pack\n    fragColor = vec4(mask, dist, timestamp, material);\n    \n    // wipe\n    float timeline = fract(iTime*speed);\n    fragColor *= step(.01, timeline);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define speed 0.1\n#define cycle 2.\n#define threshold 0.95\n\n#define T(uv) texture(iChannel0, uv).r\n#define inside(uv) (abs(uv.x-.5) < 0.5 && abs(uv.y-.5) < 0.5)\n\n// Inigo Quilez https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float timeline = fract(iTime*speed);\n    \n    // compute normal\n    vec4 color = texture(iChannel0, uv);\n    vec3 unit = vec3(1./iResolution.xy, 0);\n    vec3 normal = normalize(vec3(\n                            T(uv+unit.xz)-T(uv-unit.xz),\n                            T(uv-unit.zy)-T(uv+unit.zy),\n                            color.r));\n    \n    // glow diffusion\n    float glow = 0.;\n    vec4 blue = texture(iChannel2, fragCoord/1024.+iTime)*2.-1.;\n    uv += 5.*blue.xy/iResolution.xy;\n    float gold = texture(iChannel1, uv).a;\n    glow = max(gold, color.a*.35);\n    glow *= step(.01, timeline);\n    \n    fragColor = vec4(normal, glow);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 142, 142, 1526]], "test": "untested"}
{"id": "7l3BRM", "name": "Pulsating aberrations", "author": "Pidhorskyi", "description": "Inspired by \"Fractal Tiling\" by Inigo Quilez https://www.shadertoy.com/view/Ml2GWy\nUses hash from \"Hash without Sine\" by David Hoskins https://www.shadertoy.com/view/4djSRW", "tags": ["2d", "aberration", "tiling"], "likes": 9, "viewed": 319, "published": 3, "date": "1662889579", "time_retrieved": "2024-07-30T16:31:29.046463", "image_code": "/* Stanislav Pidhorskyi - 2022 \nInspired by \"Fractal Tiling\" by Inigo Quilez https://www.shadertoy.com/view/Ml2GWy\nUses hash from \"Hash without Sine\" by David Hoskins https://www.shadertoy.com/view/4djSRW */\n\n#define r iResolution\n#define f(v,e) for(int v=0;v<e;++v)\n#define m(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nvoid mainImage(out vec4 o,vec2 a){\n    float g=iTime,s=0.,k;\n    f(c,3){s+=.005;\n    f(l,5){g+=.03;k=-2.;vec2 i=(a-.5*r.xy)/r.y*2./(abs(sin(g))+1.);\n    f(j,8){\n        f(t,2){i=(abs(i+s)-s)*m(.1+g*.1)*2.;}\n        vec4 w=fract(floor(i).xyxy*vec4(.1031,.103,.0973,.1099));\n        w+=dot(w,w.wzxy+33.33)+iTime*.001;\n        w=fract((w.xxyz+w.yzzw)*w.zywx);\n        o[c]+=w[c]*w.w*exp(k);k-=.2;\n    }}}\n    o=pow(o*.7-.02,vec4(1.5,2.2,3.,0.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3BRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NtcfDn", "name": "0efficient poisson distribution", "author": "FabriceNeyret2", "description": "random distribution of points with density d = 1% * mouse.y\n\ntop left:     Npix*d points,    pos =  Uniform(window)\ntop right:   Npix*d/64 points,  pos = Uniform(cells = 64 subwindows )\nbottom right: Poisson(Npix*d/64)  points per cell  ( as for Worley )\n", "tags": ["poisson", "points", "uniform"], "likes": 8, "viewed": 399, "published": 3, "date": "1662881933", "time_retrieved": "2024-07-30T16:31:30.101641", "image_code": "// top-left: Brute force distribution of all points is way too costly\n// bottom-right: smaller distrib or N=Poisson points per cell is equivalent but hugely cheaper ( as in Cell noise Workey paper: http://www.rhythmiccanvas.com/research/papers/worley.pdf )\n// top-right: fix density small distrib per cell is ok if the number of points per cell is big enough.\n//                                but for small density it lacks lacunarity. cf https://www.desmos.com/calculator/sjjo3qgnfp\n#define sqrt(x) sqrt(max(x, 0.))\n#define log(x)  log(clamp(x,1e-9,1.)) // debug crash <><><>\n\n#define Z     min(0.,iTime)\n#define H(p)  fract(sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453)\n#define H2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\n#define Poisson(n, seed)  Normal(n,sqrt(n),seed)               // approx valid for n not too small https://en.wikipedia.org/wiki/Poisson_distribution#Related_distributions\n#define Normal(m,s,seed)  m + s * Gauss(seed)\n#define Gauss(u)          sqrt(-2.*log(u.x)) * cos(6.283*u.y ) // takes u = rand2_uniform()\n\n#define D(seed,aa) O += max(0., 1.- R.y/3./aa * length( abs(U) - H(seed)*R/R.y ) ) // * H(seed+7.5).x // variant with varying intensity\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, I,\n          U = ( 2.*u - R ) / R.y;\n    float d = ( length(iMouse.xy)<20. ? .5+.5*sin(iTime) : iMouse.y/R.y ) * min(R.x*R.y, 1e6) / 100., // min(): debug Windows crash\n          S = 1.; // put 0 to use same seed in each cell\n    O-=O;  // if ( iTime<.1 || ( iTime >= 10. && iTime < 10.3 )) return; // debug Windows crash\n    if ( U.y > 0. ) \n        if ( U.x < 0. )                               // --- top left: brute force draw Npix*d Uniform points \n            for( float k=Z; k < d; k++ )              // at 640x360 , d=1% : 2304 dots\n                D(k,1.);\n        else {\n            I = floor( U *= 8. ); U = fract(U);       // --- top right:draw Npix*d/64 Uniform points per cell \n            for( float k=Z; k < d/64.; k++ )          // at 640x360 , d=1% : 36 dots ( per cell )\n                D(k - S*(7.7*I.x-13.3*I.y) , 8. );\n        }\n    else   if ( U.x > 0. ) {\n            I = floor( U *= 8. ); U = fract(U);       // --- bottom right: accurate draw Poisson(Npix*d/64) points per cell\n            if (H2(I).x==0.) { O=vec4(1,0,0,1); return; };  // debug crash <><><>\n            d = Poisson(d/64., H2(I)) -.5;  \n         // if( isnan(d) || isinf(d) ) { O=vec4(1,0,0,1); return; }; d = min(d,1000.); // debug crash <><><>\n            for( float k=Z; k < d; k++ )\n                D( k - S*(7.7*I.x-13.3*I.y) , 8. );\n        }\n    O = sqrt(O);                                      // to sRGB\n    if ( int(u.x) == int(R.x)/2 || int(u.y) == int(R.y)/2 ) O = vec4(1,0,0,1);  // red separator \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtcfDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1201, 1201, 1239, 1239, 2777]], "test": "untested"}
{"id": "slcfzM", "name": "Eternal Eclipse", "author": "deni_de", "description": "9x - 7i > 3(3x - 7u) shader magic", "tags": ["sun", "space", "for"], "likes": 9, "viewed": 299, "published": 3, "date": "1662877892", "time_retrieved": "2024-07-30T16:31:31.160810", "image_code": "void mainImage( out vec4 fragColor, in vec2 U )\n{\n    //Space and shapes\n    vec2 uv = U/iResolution.y;\n    vec2 suv = uv;\n    vec2 suv2 = suv;\n    \n    float sizeOffset = 0.0;\n    \n    vec4 space = texture(iChannel1, U/iResolution.xy * 0.5 - vec2(iTime * 0.05,0.0));\n\n    uv.x -= 0.4;\n    uv += anim(-65.) * 0.1;\n    \n    suv.x -= 0.4;\n    suv += anim(-65.) * 0.29;\n    \n    suv2.x -= 0.4;\n    suv2 += anim(-65.) * 0.06;\n     \n    float scircle05 =  smoothstep( 0.05, 0.33 , length(U / iResolution.y - vec2(0.9,0.5)));\n    float scircle25 =  smoothstep( 0.25, 0.30 , length(U / iResolution.y - vec2(0.9,0.5)));\n    float scircle15 =  smoothstep( 0.15, 0.40 , length(uv - vec2(0.5)));\n    float scircle01 =  smoothstep( 0.01, 0.15 , length(suv - vec2(0.5)));\n    \n    float hcircle   =  step(0.22 , length(suv2 - vec2(0.5,0.5) ) );\n    \n    float scircleHVM =  smoothstep( 0.01, 0.5 + 0.5 * sin(hash(1.153255, iTime) + iTime * 155.0) , length(suv - vec2(0.5,0.5)));\n    float scircleH =  smoothstep( 0.01, 0.11 , length(suv * vec2(0.1,9.0) - vec2(0.05,4.5)));\n    float scircleV =  smoothstep( 0.01, 0.11 , length(suv * vec2(9.0,0.1) - vec2(4.5,0.05)));\n    \n    //Application\n    vec3 tex = vec3(0.0);\n    for(int i = -5; i < 15; i++)\n    {\n        \n        uv -= vec2(0.5);\n        uv *= Rotate( iTime * 0.03 + (sin(0.5 + 0.1 * (iTime*0.1+uv.x + 2.) + float(i + int(hash(1.1243124, iTime))) * 0.01)));\n        float sizeOffset = clamp(sin((7. + iTime * 0.5 + 1.0) * (float(i)) + hash(75734.13213 + iTime, iTime)),0.0, 1.0) ;\n        uv *= 1.0 + 0.05 * sizeOffset;\n        uv += vec2(0.5);\n        \n        tex += texture(iChannel0, uv + space.r * 0.05).rgb;\n    }\n    \n    tex -= scircle05;\n    \n    tex = mix(tex, vec3(0.2,0.4,0.7) , (1. - scircle15 )) ;\n    \n    tex *= scircle25;\n    \n    tex *= hcircle;\n\n    tex += (1.- scircle01 ) * scircle25  ;\n    \n    float mask = clamp(((1.-scircleH) + (1.-scircleV)) * 1.- scircleHVM, 0.0, 1.0);\n    \n    tex = mix( tex, vec3(1.) , mask / 2. ) ;\n    \n    fragColor = vec4(tex , 1.0) ;\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvs = fragCoord/iResolution.xy;\n    \n    float scircle = clamp( smoothstep(0.01,0.55,length((fragCoord / iResolution.y) - vec2(0.8,0.5))) , 0.5, 1.0) ;\n    \n    vec3 tex = vec3(0);\n    uv.x *= 0.9;\n    //chaotic\n    //uv.xy += vec2( 0.2 * anim(-iTime).y, 0.1 * anim(iTime).x) * 0.5;\n    uv.x += 0.1;\n    for(int i = 0; i < 7; i++)\n    {\n        float fi = float(i);\n       \n        uv.xy -= vec2(0.5,0.5);\n        vec2 scale = mix(uv * 2., uv * 1.5, sin(mod(iTime, 3.5) * fi * 0.5 )) * (scircle * 0.1);\n        uv -= scale;\n        \n        uv.xy += vec2(0.5,0.5);\n        \n        vec3 img = texture(iChannel0, uv).rgb; \n        img = step(0.96,img + fi * 0.05);\n        \n        tex += clamp(pow(img , vec3(1.0)), 0.0, 1.0) * (1.0-scircle);\n    }\n    tex *= 0.5 + 0.5 * sin(iTime+uv.xyx+vec3(0,2,4));\n    tex = vec3((tex.r + tex.g + tex.b) / 3.0);\n    \n    fragColor = vec4(tex * vec3(2.0,1.0,0.0) ,1.0) ;\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float hash(float seed,float t)\n{\n    return fract(seed * t * 94515.67657324);\n}\n\nvec2 anim(float angle)\n{    \n    return vec2(1.0  * sin(angle) , 1.0  * cos(angle) );\n}\n\nmat2 Rotate(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,-s,s,c);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 72, 2033]], "test": "untested"}
{"id": "NlcfWn", "name": "DayC's Pathtracing", "author": "DayC", "description": "a pathtracing demo,with light bouncing 20 times\npress space to repaint", "tags": ["cornellbox", "pathtracing"], "likes": 3, "viewed": 304, "published": 3, "date": "1662875380", "time_retrieved": "2024-07-30T16:31:32.252890", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color=texture(iChannel0,uv).rgb;\n    color=ACESFilm(color);\n    color=LinearToSRGB(color);\n    fragColor=vec4(color,1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const float EPI=0.005;\nconst int BOUNCE_CNT=20;\nconst float rayPosNormalNudge = 0.01f;\n\nvec3 camera_pos=vec3(278,273,-800);\nvec3 camera_dir=vec3(0,0,1);\nvec3 camera_up=vec3(0,1,0);\nfloat near=0.035;\nvec2 size=vec2(0.044,0.025);\n\nfloat skyBox_intensity=1.0f;\nfloat light_intensity=15.0f;\n\n//材质\nPBRMaterial white_material=PBRMaterial(\n    vec3(1,1,1),\n    vec3(0,0,0),\n    vec3(1,1,1),\n    0.0f,\n    1.0f,\n    1.0f,\n    vec3(0,0,0),\n    0.0f,\n    1.0f);\n\nPBRMaterial green_material=PBRMaterial(\n    vec3(0,1,0),\n    vec3(0,0,0),\n    vec3(0,1,0),\n    0.0f,\n    0.5f,\n    1.0f,\n    vec3(0,0,0),\n    0.0f,\n    1.0f);\n\nPBRMaterial red_material=PBRMaterial(\n    vec3(1,0,0),\n    vec3(0,0,0),\n    vec3(1,0,0),\n    0.0f,\n    0.5f,\n    1.0f,\n    vec3(0,0,0),\n    0.0f,\n    1.0f);\n\nPBRMaterial agate_material=PBRMaterial(\n    vec3(1,1,1),\n    vec3(0,0,0),\n    vec3(0.0f,0.0f,0),\n    0.1f,\n    0.2f,\n    2.0f,\n    vec3(0,0.0f,0),\n    0.8f,\n    0.1f);\n\nPBRMaterial light_material=PBRMaterial(\n    vec3(0,0,0),\n    vec3(1,1,1)*15.0f,\n    vec3(1,1,1),\n    0.0f,\n    0.0f,\n    1.0f,\n    vec3(0,0,0),\n    0.0f,\n    1.0f);\n\nPBRMaterial mirror_material=PBRMaterial(\n    vec3(1,1,1),\n    vec3(0,0,0),\n    vec3(1,1,1),\n    0.4f,\n    0.1f,\n    1.0f,\n    vec3(0,0,0),\n    0.0f,\n    1.0f);\n\nPBRMaterial sphere_material=PBRMaterial(\n    vec3(0.8,0.2,1),\n    vec3(0,0,0),\n    vec3(0.8,0.4,0.1),\n    0.9f,\n    0.8f,\n    1.0f,\n    vec3(0,0,0),\n    0.0f,\n    1.0f);\n\n\nvoid Scene(vec3 eyePos,vec3 dir,inout HitInfo hitInfo)\n{\n    float dist=LIGHT_MAX_DIST,dist_temp;\n\n    vec3 normal,normal_temp;\n    bool fromInside,fromInside_temp;\n    PBRMaterial material;\n\n    //地板\n    dist_temp=Quad(eyePos,dir,vec3(552.8,0,0), vec3(0,0,0), vec3(0,0,559.2), vec3(549.6,0,559.2),normal_temp);\n    if(dist_temp<dist)\n    {\n        dist=dist_temp;\n        normal=normal_temp;\n        material=mirror_material;\n        fromInside=false;\n    }\n    //后墙\n    dist_temp=Quad(eyePos,dir,vec3(549.6,0.0,559.2), vec3(0.0,0.0,559.2), vec3(0.0,548.8,559.2), vec3(556.0,548.8,559.2),normal_temp);\n    if(dist_temp<dist)\n    {\n        dist=dist_temp;\n        normal=normal_temp;\n        material=white_material;\n        fromInside=false;\n    }   \n    //天花板\n    dist_temp=Quad(eyePos,dir,vec3(556.0,548.8,0.0), vec3(556.0,548.9,559.2), vec3(0.0,548.9,559.2), vec3(0.0,548.9,0.0),normal_temp);\n    if(dist_temp<dist)\n    {\n        dist=dist_temp;\n        normal=normal_temp;\n        material=white_material;\n        fromInside=false;\n    }\n    //左墙\n    dist_temp=Quad(eyePos,dir,vec3(552.8,0.0,0.0), vec3(549.6,0.0,559.2), vec3(556.0,548.8,559.2), vec3(556.0,548.8,0.0),normal_temp);\n    if(dist_temp<dist)\n    {\n        dist=dist_temp;\n        normal=normal_temp;\n        material=red_material;\n        fromInside=false;\n    }\n\n    //右墙\n    dist_temp=Quad(eyePos,dir,vec3(0.0,0.0,559.2), vec3(0.0,0.0,0.0), vec3(0.0,548.8,0.0), vec3(0.0,548.8,559.2),normal_temp);\n    if(dist_temp<dist)\n    {\n        dist=dist_temp;\n        normal=normal_temp;\n        material=green_material;\n        fromInside=false;\n    }\n\n    //小盒子\n    mat4 smallbox_transform=translate(vec3(185,82.5,169))*rotate(vec3(0,1,0),-0.29);\n    vec4 smallbox_point=inverse(smallbox_transform)*vec4(eyePos,1);\n    vec4 smallbox_dir=inverse(smallbox_transform)*vec4(dir,0);\n    dist_temp=Box(smallbox_point.xyz,smallbox_dir.xyz,vec3(0,0,0),vec3(165,165,165),normal_temp,fromInside_temp);\n    normal_temp=(smallbox_transform*vec4(normal_temp,0)).xyz;\n    if(dist_temp<dist)\n    {\n        dist=dist_temp;\n        normal=normal_temp;\n        material=white_material;\n        fromInside=fromInside_temp;\n    }\n\n    //大盒子\n    mat4 tallbox_transform=translate(vec3(368,165,351))*rotate(vec3(0,1,0),-1.27);\n    vec4 tallbox_point=inverse(tallbox_transform)*vec4(eyePos,1);\n    vec4 tallbox_dir=inverse(tallbox_transform)*vec4(dir,0);\n    dist_temp=Box(tallbox_point.xyz,tallbox_dir.xyz,vec3(0,0,0),vec3(165,330,165),normal_temp,fromInside_temp);\n    normal_temp=(tallbox_transform*vec4(normal_temp,0)).xyz;\n    if(dist_temp<dist)\n    {\n        dist=dist_temp;\n        normal=normal_temp;\n        material=white_material;\n        fromInside=fromInside_temp;\n    }\n\n    //反射球\n    mat4 sphere_transform=translate(vec3(480,250,300));\n    vec4 sphere_point=inverse(sphere_transform)*vec4(eyePos,1);\n    vec4 sphere_dir=inverse(sphere_transform)*vec4(dir,0);\n    dist_temp=Sphere(sphere_point.xyz,sphere_dir.xyz,50.0f,normal_temp,fromInside_temp);\n    normal_temp=(sphere_transform*vec4(normal_temp,0)).xyz;\n    if(dist_temp<dist)\n    {\n        dist=dist_temp;\n        normal=normal_temp;\n        material=sphere_material;\n        fromInside=fromInside_temp;\n    }\n\n    if(dist<hitInfo.dist)\n    {\n        hitInfo.dist=dist;\n        hitInfo.material=material;\n        hitInfo.hitPoint=eyePos+dir*hitInfo.dist;\n        hitInfo.normal=normal;\n        hitInfo.inside=fromInside;\n    }\n}\n\nvoid Light(vec3 eyePos,vec3 dir,inout HitInfo hitInfo)\n{\n    float dist=LIGHT_MAX_DIST;\n\n    vec3 normal;\n\n    //地板\n    dist=min(dist,Quad(eyePos,dir,vec3(343.0,548.8,227.0), vec3(343.0,548.8,332.0),vec3(213.0,548.8,332.0),vec3(213.0,548.8,227.0),normal));\n\n    if(dist<hitInfo.dist)\n    {\n        hitInfo.dist=dist;\n        hitInfo.material=light_material;\n        hitInfo.hitPoint=eyePos+dir*hitInfo.dist;\n        hitInfo.normal=normal;\n        hitInfo.inside=false;\n    }\n}\n\n//透视摄像机射线\nvec3 CameraRay_Perspective(vec3 eyePos,vec3 upVec,vec3 front,float near,vec2 size,vec2 uv)\n{\n    upVec=normalize(upVec);\n    front=normalize(front);\n    vec3 right=cross(front,upVec);\n    vec3 hitPoint=vec3(size*uv,0);\n    hitPoint=hitPoint.x*right+hitPoint.y*upVec+eyePos+front*near;\n    return normalize(hitPoint-eyePos);\n}\n\nbool LightCollision(vec3 eyePos,vec3 rayDir,out HitInfo hitInfo)\n{\n    hitInfo=HitInfo(false,vec3(0,0,0),LIGHT_MAX_DIST,white_material,vec3(0,0,0));\n\n    Scene(eyePos,rayDir,hitInfo);\n    Light(eyePos,rayDir,hitInfo);\n    if(hitInfo.dist!=LIGHT_MAX_DIST)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n} \n\nuint random_seed;\n\nvec4 PathTracing(vec3 rayPoint,vec3 rayDir)\n{\n    //着色结果\n    vec3 result=vec3(0,0,0);\n    //强度\n    vec3 intensity=vec3(1,1,1);\n\n    vec3 pos_now=rayPoint;\n    vec3 dir_now=rayDir;\n\n    for(int i=0;i<BOUNCE_CNT;i++)\n    {\n        HitInfo hitInfo;\n        if(!LightCollision(pos_now,dir_now,hitInfo))\n        {\n            result+=SRGBToLinear(texture(iChannel1,dir_now).rgb)*intensity;\n            break;\n        }\n\n        //光线吸收\n        /*if(hitInfo.inside)\n        {\n            intensity*=exp(-hitInfo.material.refractionColor*hitInfo.dist);\n        }*/\n\n        //specular-roughness\n        float specularChance=hitInfo.material.specularChance;\n        float refractionChance=hitInfo.material.refractionChance;\n        \n        //根据Fresnel项调整反射率\n        if (specularChance > 0.0f)\n        {\n            specularChance = FresnelReflectAmount(\n                hitInfo.inside?hitInfo.material.IOR:1.0f,\n                !hitInfo.inside?hitInfo.material.IOR:1.0f,\n                dir_now, hitInfo.normal, hitInfo.material.specularChance, 1.0f);\n\n            float ratio=(1.0f-specularChance)/(1.0f-hitInfo.material.specularChance);\n            refractionChance*=ratio;\n        }\n\n        //根据概率决定此光线的路径\n        float rayProbability;\n        float doSpecular=0.0f;\n        float doRefraction=0.0f;\n        float rnd=RandomFloat01(random_seed);\n        if(rnd<specularChance&&specularChance>0.0f)\n        {\n            doSpecular=1.0f;\n            rayProbability=specularChance;\n        }\n        else if(rnd<specularChance+refractionChance&&refractionChance>0.0f)\n        {\n            doRefraction=1.0f;\n            rayProbability=refractionChance;\n        }\n        else\n        {\n            rayProbability=1.0f-specularChance-refractionChance;\n        }\n\n        rayProbability=max(rayProbability,0.001f);\n\n        //计算光线位置并进行偏移\n        if(doRefraction>0.0f)\n        {\n            pos_now=pos_now+dir_now*hitInfo.dist-hitInfo.normal*rayPosNormalNudge;\n        }\n        else\n        {\n            pos_now=pos_now+dir_now*hitInfo.dist+hitInfo.normal*rayPosNormalNudge;\n        }\n\n        vec3 diffuseDir=normalize(hitInfo.normal+RandomUnitVector(random_seed));\n\n        vec3 specularDir=reflect(dir_now,hitInfo.normal);\n        specularDir=normalize(mix(specularDir,diffuseDir,hitInfo.material.specularRoughness*hitInfo.material.specularRoughness));\n\n        vec3 refractionDir = refract(dir_now,hitInfo.inside? -hitInfo.normal:hitInfo.normal, hitInfo.inside ? hitInfo.material.IOR : 1.0f / hitInfo.material.IOR);\n        refractionDir = normalize(mix(refractionDir, normalize(-hitInfo.normal + RandomUnitVector(random_seed)), hitInfo.material.refractionRoughness*hitInfo.material.refractionRoughness));\n\n        dir_now = mix(diffuseDir, specularDir, doSpecular);\n        dir_now = mix(dir_now, refractionDir, doRefraction);\n\n        //计算自发光\n        result+=hitInfo.material.emissive*intensity;\n\n        //计算漫反射\n        if (doRefraction == 0.0f)\n            intensity *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);\n\n        intensity/=rayProbability;\n\n        //Russian-Roulette\n        float p=max(intensity.r,max(intensity.g,intensity.b));\n        if(RandomFloat01(random_seed)>sqrt(p))\n        {\n            break;\n        }\n        intensity*=(1.0/p);\n    }\n\n    return vec4(result,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    random_seed=uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    /*vec2 uv=fragCoord/iResolution.xy;\n    uv-=0.5;\n    vec4 color;\n    vec3 ray=CameraRay_Perspective(camera_pos,camera_up,camera_dir,near,size,uv);\n    color=PathTracing(camera_pos,ray);*/\n\n    //super-sample\n    vec4 color=vec4(0,0,0,0);\n    vec2[4] delta;\n    delta[0]=vec2(-0.5,0.5);\n    delta[1]=vec2(0.5,0.5);\n    delta[2]=vec2(-0.5,-0.5);\n    delta[3]=vec2(0.5,-0.5);\n    for(int i=0;i<4;i++)\n    {\n        vec2 uv=(fragCoord+delta[i])/iResolution.xy;\n        uv-=0.5;\n        vec3 ray=CameraRay_Perspective(camera_pos,camera_up,camera_dir,near,size,uv);\n        color+=(1.0f/4.0f)*PathTracing(camera_pos,ray);\n    }\n    vec2 uv=fragCoord/iResolution.xy;\n    uv-=0.5f;\n    color.a=1.0f;\n    \n    //vec4 lastFrameColor=texture(iChannel0,uv+0.5);\n    //fragColor=mix(lastFrameColor,color,1.0f/float(iFrame+1));\n\n    bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1);\n \n    vec4 lastFrameColor = texture(iChannel0, uv+0.5);\n    float blend = (lastFrameColor.a == 0.0f || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    vec3 rgb = mix(lastFrameColor.rgb, color.rgb, blend);\n     \n    // show the result\n    fragColor = vec4(rgb, blend);\n}", "buffer_a_inputs": [{"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct  LambertMaterial\n{\n    //漫反射系数\n    vec3 diffuse;\n    //高光系数\n    vec3 specular;\n    //环境光系数\n    vec3 ambient;\n};\n\nstruct LambertLight\n{\n    //位置\n    vec3 pos;\n    //颜色\n    vec3 color;\n    //强度\n    float intensity;\n};\n\nstruct PBRMaterial\n{\n    //漫反射颜色\n    vec3 albedo;\n    //发光颜色\n    vec3 emissive;\n    //反射颜色\n    vec3 specularColor;\n    //反射概率\n    float specularChance;\n    //粗糙度\n    float specularRoughness;\n    //折射率\n    float IOR;\n    //折射\n    vec3 refractionColor;\n    //折射概率\n    float refractionChance;\n    //折射粗糙度\n    float refractionRoughness;\n};\n\nstruct HitInfo\n{\n    //判断是否为正面\n    bool inside;\n    //法线方向\n    vec3 normal;\n    //距离\n    float dist;\n    //材质\n    PBRMaterial material;\n    //击中的点\n    vec3 hitPoint;\n};\n\nconst float PI=3.1415926526;\n\nmat4 translate(vec3 delta)\n{\n\treturn mat4(\n\t\tvec4(1,0,0,0),\n\t\tvec4(0,1,0,0),\n\t\tvec4(0,0,1,0),\n\t\tvec4(delta.x,delta.y,delta.z,1));\n}\n\nmat4 scale(vec3 delta)\n{\n\treturn mat4(\n\t\tvec4(delta.x,0,0,0),\n\t\tvec4(0,delta.y,0,0),\n\t\tvec4(0,0,delta.z,0),\n\t\tvec4(0,0,0,1));\n}\n\nmat4 rotate(vec3 axis,float theta_rad)\n{\n\taxis=normalize(axis);\n\tfloat cos_theta=cos(theta_rad);\n\tfloat sin_theta=sin(theta_rad);\n\treturn mat4(\n\t\tvec4(axis.x*axis.x*(1.0-cos_theta)+cos_theta       , axis.y*axis.x*(1.0-cos_theta)+axis.z*sin_theta, axis.z*axis.x*(1.0-cos_theta)-axis.y*sin_theta , 0.0),\n\t\tvec4(axis.x*axis.y*(1.0-cos_theta)-axis.z*sin_theta, axis.y*axis.y*(1.0-cos_theta)+cos_theta       , axis.z*axis.y*(1.0-cos_theta)+axis.x*sin_theta, 0.0),\n\t\tvec4(axis.x*axis.z*(1.0-cos_theta)+axis.y*sin_theta, axis.y*axis.z*(1.0-cos_theta)-axis.x*sin_theta, axis.z*axis.z*(1.0-cos_theta)+cos_theta       , 0.0),\n\t\tvec4(0.0                                           , 0.0                                           , 0.0                                           , 1.0));\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * 2.0f*PI;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n//点到直线的距离,方向向量必须为单位向量\nfloat DistPoint2Line(vec3 point,vec3 rayPos,vec3 dir)\n{\n    return length(cross(point-rayPos,dir));\n}\n\n//菲涅尔项计算\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)\n{\n    // Schlick aproximation\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2 > 1.0)\n            return f90;\n        cosX = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-cosX;\n    float ret = r0+(1.0-r0)*x*x*x*x*x;\n    // adjust reflect multiplier for object reflectivity\n    return mix(f0, f90, ret);\n}\n\n\nconst float LIGHT_MAX_DIST=10000.0f;\n\n//求光线与球的交点\nfloat Sphere(vec3 rayPos,vec3 rayDir,float radius,out vec3 normal,out bool fromInside)\n{\n\tfloat dist_point2line=DistPoint2Line(vec3(0,0,0),rayPos,rayDir);\n\tfloat dist_points=length(rayPos);\n\t\n\tbool ray_facesphere=dot(rayDir,-rayPos)>0.0;\n\tbool line_close=dist_point2line<radius;\n\tbool point_close=dist_points<radius;\n\n\tif(!point_close&&((!line_close&&ray_facesphere)||!ray_facesphere))\n\t{\n\t\tfromInside=false;\n\t\treturn LIGHT_MAX_DIST;\n\t}\n\telse\n\t{\n\t\tfloat A=1.0f;\n\t\tfloat B=2.0f*dot(rayDir,rayPos);\n\t\tfloat len_O=length(rayPos);\n\t\tfloat C=(len_O+radius)*(len_O-radius);\n\n\t\tfloat sqrt_delta=sqrt(B*B-4.0*A*C);\n\t\tfloat t1=(-B+sqrt_delta)/(2.0f*A);\n\t\tfloat t2=(-B-sqrt_delta)/(2.0f*A);\n\n\t\tfloat res=LIGHT_MAX_DIST;\n\n\t\tif(t1>.0)\n\t\t{\n\t\t\tres=min(res,t1);\n\t\t}\n\t\tif(t2>.0)\n\t\t{\n\t\t\tres=min(res,t2);\n\t\t}\n\n\t\tfromInside=point_close;\n\t\tnormal=normalize(rayPos+rayDir*res);\n\t\treturn res;\n\t}\n}\n\n//求光线与三角形的交点(Moller-Trumbore算法)\nfloat Triangle(vec3 rayPos,vec3 rayDir,vec3 a,vec3 b,vec3 c,out vec3 normal)\n{\n\tvec3 E1=b-a;\n\tvec3 E2=c-a;\n\tvec3 S=rayPos-a;\n\tvec3 S1=cross(rayDir,E2);\n\tvec3 S2=cross(S,E1);\n\n\tfloat S1E1=dot(S1,E1);\n\tfloat b1_S1E1=dot(S1,S);\n\tfloat b2_S1E1=dot(S2,rayDir);\n\tif(b1_S1E1>.0&&b2_S1E1>.0&&S1E1-b1_S1E1-b2_S1E1>.0)\n\t{\n\t\tnormal=normalize(cross(E1,E2));\n\t\treturn dot(S2,E2)/S1E1;\n\t}\n\telse\n\t{\n\t\treturn LIGHT_MAX_DIST;\n\t}\n}\n\nfloat Quad(vec3 rayPos,vec3 rayDir,vec3 a,vec3 b,vec3 c,vec3 d,out vec3 normal)\n{\n\tfloat res=LIGHT_MAX_DIST;\n\tvec3 normal1,normal2;\n\tfloat res1=Triangle(rayPos,rayDir,a,b,d,normal1);\n\tfloat res2=Triangle(rayPos,rayDir,d,b,c,normal2);\n\tif(res1<res2)\n\t{\n\t\tnormal=normal1;\n\t}\n\telse\n\t{\n\t\tnormal=normal2;\n\t}\n\treturn min(res,min(res1,res2));\n}\n\nfloat Box(vec3 rayPos,vec3 rayDir,vec3 center,vec3 size,out vec3 normal,out bool fromInside)\n{\n\tfloat res=LIGHT_MAX_DIST;\n\n\tsize-=(size/2.0f);\n\tvec3 p1=center+size;\n\tvec3 p2=center+vec3(-size.x,size.y,size.z);\n\tvec3 p3=center+vec3(-size.x,-size.y,size.z);\n\tvec3 p4=center+vec3(size.x,-size.y,size.z);\n\tvec3 p5=center+vec3(size.x,size.y,-size.z);\n\tvec3 p6=center+vec3(-size.x,size.y,-size.z);\n\tvec3 p7=center+vec3(-size.x,-size.y,-size.z);\n\tvec3 p8=center+vec3(size.x,-size.y,-size.z);\n\n\tvec3 n1,n2,n3,n4,n5,n6;\n\tfloat r1=Quad(rayPos,rayDir,p1,p2,p3,p4,n1);\n\tif(r1<res)\n\t{\n\t\tres=r1;\n\t\tnormal=n1;\n\t}\n\tfloat r2=Quad(rayPos,rayDir,p1,p5,p6,p2,n2);\n\tif(r2<res)\n\t{\n\t\tres=r2;\n\t\tnormal=n2;\n\t}\n\tfloat r3=Quad(rayPos,rayDir,p4,p8,p7,p3,n3);\n\tif(r3<res)\n\t{\n\t\tres=r3;\n\t\tnormal=n3;\n\t}\n\tfloat r4=Quad(rayPos,rayDir,p1,p4,p8,p5,n4);\n\tif(r4<res)\n\t{\n\t\tres=r4;\n\t\tnormal=n4;\n\t}\n\tfloat r5=Quad(rayPos,rayDir,p3,p2,p6,p7,n5);\n\tif(r5<res)\n\t{\n\t\tres=r5;\n\t\tnormal=n5;\n\t}\n    \n\tfloat r6=Quad(rayPos,rayDir,p5,p8,p7,p6,n6);\n\tif(r6<res)\n\t{\n\t\tres=r6;\n\t\tnormal=n6;\n\t}\n\n\tvec3 relativePos=rayPos-center;\n\tfromInside=abs(relativePos.x)<size.x&&abs(relativePos.y)<size.y&&abs(relativePos.z)<size.z;\n\treturn res;\n}\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlcfWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 228]], "test": "untested"}
{"id": "Nl3BWn", "name": "Fractal mosaic 16", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 6, "viewed": 263, "published": 3, "date": "1662871246", "time_retrieved": "2024-07-30T16:31:33.694036", "image_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 f1(vec2 a){\n    return\n        fract(a)\n        //fract(a+floor(a.y*2.+.5)/2.)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        //vec2(-2.,.5+mod(floor(a.x),2.))\n        //vec2(1.5,0.5)\n        //vec2(1.5,0.)\n        //vec2(2.,0.)\n        //vec2(2.5,0.)\n        //vec2(1.25,1.75)\n        //vec2(abs(mod(a.x-.5,2.)-1.),abs(mod(a.y-.5,2.)-1.))\n    ,\n    \n    a1 = a+a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n        //abs(fract(a+vec2(floor(a.x),floor(a.y)))-.5)\n    ;\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += iTime/t1/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n\n    for(int k = 0; k < 12; k++){\n    \n        //uv.y += t1_(floor(uv),floor(uv));\n    \n        bool c1 = t2.x < uv.x;\n        uv =\n            (uv+t2)/scale\n            //(uv+t2)/scale*(1.+mod(floor(uv.y),2.)/2.)\n        ;\n        //uv *= max(sign(uv),sign(uv-uv.yx));\n        t2 = triangle_wave(uv-.5);\n        uv = t2-triangle_wave(uv.yx);\n        \n        //uv.x -= max(uv.y,uv.x);\n        //uv.x -= floor(uv.x-uv.y)*2.;\n        vec2 uv1 =\n            uv\n            //triangle_wave((uv-.5)/1.5)-triangle_wave((uv.yx)/1.5)\n        ;\n        vec2 t21 =\n            t2\n            //triangle_wave((t2-.5)/3.)-triangle_wave((t2.yx)/1.5)\n        ;\n        \n        float z1 =\n            //Several interesting variants here:\n            abs(uv1.x-uv1.y)-t21.x-t21.y\n            //abs(uv.x-uv.y-.5*sign(uv.x-uv.y))\n            //length(uv-t2)\n            //max(abs(t2.y),abs(uv.y))\n            //max(abs(t2.x),abs(uv.x))\n            //abs(uv.y)-t2.y\n            //abs(uv.x)-t2.x\n            //max(abs(uv.x-t2.x),abs(uv.y-t2.y))\n            //uv.x-t2.x\n            //t2.y\n            //abs(uv.x+uv.y)-t2.x-t2.y\n            //t2.x+uv.x\n            //uv.x+t2.x\n            \n            //max(abs(t2.y-uv.y),abs(t2.x-uv.x))\n\n            //max(abs(uv.y),abs(uv.x))\n        ;\n\n        col.x = max((abs(z1))/3.,col.x);\n        col =\n            abs(col-(1.-col.x));\n            //abs(col.yzx-(1.-col.x));\n        col1 =\n            abs(col1-col-1.).yzx;\n            //col1 = abs(abs(col1-1.)-col).yzx;\n        //if(uv.y>uv.x) uv *= 1.5;\n        \n        //if(c1) col =\n            //col.yzx;\n            //abs(col.yzx-col);\n        //if(uv.x<uv.y) col=col.yzx;\n        //if(uv.x < .5) uv.x += .5;\n        //if(uv.y < .5) uv.y += .5;\n    }\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3BWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 50, 50, 125], [127, 127, 154, 154, 686], [803, 803, 829, 829, 918], [920, 920, 977, 977, 3030]], "test": "untested"}
{"id": "7tdfz7", "name": "Spiraling  8", "author": "91isprime", "description": "An analog clock. ", "tags": ["spirals"], "likes": 2, "viewed": 185, "published": 3, "date": "1662868110", "time_retrieved": "2024-07-30T16:31:34.501877", "image_code": "const float D_MAX = 4.0;\nconst float BASE_FREQUENCY = 1.0 / 60.0;\nconst float PI = 3.14159265;\nconst float POINT_COUNT = 60.0;\nconst float MARGIN = .2; //percent margin on shortest side\n\nconst vec4 BLACK = vec4(0,0,0,0);\nconst vec4 WHITE = vec4(1,1,1,0);\nconst vec4 GRAY = vec4(1,1,1,0) * .6;\nconst vec4 RED = vec4(1,0,0,0);\nconst vec4 GREEN = vec4(0,1,0,0);\nconst vec4 BLUE = vec4(0,0,1,0);\n\nvec4 alpha_blend(vec4 top, vec4 bottom, float alpha){\n    return mix(bottom,top,clamp(alpha,0.0,1.0));\n}\n\nfloat sdf_to_alpha(float d){\n    float scale_divisor = min(iResolution.x, iResolution.y)/2.0*(1.0-MARGIN);\n    return clamp(-d*scale_divisor,0.0,1.0);\n}\n\nfloat point_sdf(float t, vec2 xy0, float multiplier){\n    // t is time of day in seconds\n    // xy0 is from -1 to 1\n    //returns a distance to the point with frequency multiplier\n    \n    float t2 = fract(t * BASE_FREQUENCY) * multiplier;\n    //rotate clockwise from 12:00\n    float theta = PI/2.0 - fract(t2) * 2.0 * PI;\n    \n    vec2 xy = multiplier/POINT_COUNT * vec2(cos(theta), sin(theta)) * float (multiplier <= POINT_COUNT);\n    return length(xy-xy0);\n}\n\nfloat hand(float t, float period, vec2 xy0, float thickness, float height){\n    //t is time of day in seconds\n    //xy0 is from -1 to 1\n    //thickness from 0 to 1\n    //height from 0 to 1\n    float angle = fract(t / period) * 2.0 * PI;\n    float back_height = 0.2 * height;\n    //rotate xy0 angle by angle\n    float r = length(xy0);\n    float theta = atan(xy0.y, xy0.x) + angle;\n    vec2 xy1 = r * vec2(cos(theta), sin(theta));\n    //bounding box sdf\n    float dx = abs(xy1.x)-thickness/2.0;\n    float dy = max(xy1.y-height,-xy1.y-back_height);\n    float sdf = max(dx,dy);\n    return sdf_to_alpha(sdf);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale_divisor = min(iResolution.x, iResolution.y)/2.0*(1.0-MARGIN);\n    vec2 xy0 = (fragCoord - iResolution.xy/2.0)/scale_divisor;\n    \n    scale_divisor = 1.0;\n    float frequency = max(floor(length(xy0)*POINT_COUNT), 1.0);\n    \n    float t = mod(iDate.w, 12.0*60.0*60.0);\n    //t = iDate.w;\n    //not a true sdf. only valid at the boundry\n    float blobs_sdf = 0.0;\n    blobs_sdf = 999.0;\n    for(float i = -D_MAX; i<=D_MAX; i++){\n        float r = max(frequency+i, 1.0);\n        float dist = point_sdf(t, xy0, r);\n        blobs_sdf = min(blobs_sdf, dist);\n    }\n    float blobs_alpha = sdf_to_alpha(blobs_sdf-D_MAX/POINT_COUNT);\n    \n    t = floor(t); // comment out for smooth\n    //background\n    fragColor = vec4(.95,.9,.8,0);\n    fragColor = alpha_blend(BLACK, fragColor, sdf_to_alpha(length(xy0)-1.15));\n    fragColor = alpha_blend(WHITE, fragColor, sdf_to_alpha(length(xy0)-1.1));\n    // points ... hours, minutes, seconds\n    fragColor = alpha_blend(GRAY,  fragColor, blobs_alpha);\n    fragColor = alpha_blend(BLACK, fragColor, hand(t, 12.0*60.0*60.0, xy0, .05, .7));\n    fragColor = alpha_blend(BLACK, fragColor, hand(t,      60.0*60.0, xy0, .03, .8));\n    fragColor = alpha_blend(RED,   fragColor, hand(t,           60.0, xy0, .02, .9));\n    fragColor = alpha_blend(BLACK, fragColor, sdf_to_alpha(length(xy0)-.04));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 393, 446, 446, 497], [499, 499, 527, 527, 651], [653, 653, 706, 832, 1114], [1116, 1116, 1191, 1304, 1721], [1723, 1723, 1780, 1780, 3120]], "test": "untested"}
{"id": "stdBz7", "name": "lamparas basicas", "author": "jorge2017a2", "description": "lamparas basicas", "tags": ["lamparasbasicas"], "likes": 5, "viewed": 160, "published": 3, "date": "1662864502", "time_retrieved": "2024-07-30T16:31:35.263839", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 255.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n#define PI2 6.28318530718\n\n//referencia shadertoy usuarios, Iq,Xor,etc\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\nvec3 hitPoint;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n     p.y=p.y+10.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    \n    res =opU2(res, vec2(planeDist1,57.0));\n    p.y=p.y-5.0;\n    \n    p.y+=10.0;\n    p.z=opRep1D( p.z, 20.0 );\n    float d0= sdBox(p, vec3(20.0,1.0,20.0) );\n    res =opU2(res, vec2(d0,9.0));\n    \n    p=p0;\n    p.x=abs(p.x)-10.0;\n    p.z=opRep1D( p.z, 15.0 );\n    float d1= sdCylinderXZ( p, vec2(1.0,10.0) );\n    res =opU2(res, vec2(d1,100.0));\n    \n    float d3= sdCylinderXZ(p-vec3(0.0,12.0,0.0), vec2(0.5,0.5) );\n    res =opU2(res, vec2(d3,4.0));\n    \n    p.y-=10.0;\n    float d2=sdSphere(p, 2.0 );\n    res =opU2(res, vec2(d2,50.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 )\n    { col=tex3D(iChannel0, p/16., nor); return col*2.0; }\n    return vec3(0.0);\n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.5*smoothstep(-0.05,0.06,cos(uv.x*0.4)*cos(uv.y*0.4)); \n    col *= smoothstep(-1.0,-0.95,cos(uv.x*0.8))*smoothstep(-1.0,-0.95,cos(uv.y*0.8));\n    return col;\n}\n\n\n//Xor, 2022-09-10  //199 chars with no discontinuities:\nvec3 portal( vec2 I)\n{\n    vec4 O;\n    float tes=iTime*0.01;\n    float r = length(I -= (O.xy = iResolution.xy) * .5)/O.y,\n    z = log(r) -tes;\n    O = pow(1.-texture(iChannel0, vec2(z, sign(I)*atan(I.yy,abs(I))/3.14-z*.5-tes*.1))*r,\n    vec4(3,2,1,1));\n    return O.xyz;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n\n    if (id_color<48) { colobj=getColor(int( id_color));  return colobj; }\n    if (id_color==57) {return pattern( p.xz );}\n    if (id_color==58) {return pattern( p.xy );}\n    if (id_color==59) {return pattern( p.zy );}\n    \n    \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n  return vec3(0.0);\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        vec3 result;\n\n        if( int(hit.y)==50)\n        {colobj=vec3(2.0);result=colobj; }\n        else\n        {   colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n            result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n            result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        }\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col=vec3(1.0)*portal(rd.xy*10.0);\n   return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n   ///mObj.uv=uv;\n   // vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(0.0, 10.0, -25.);\n    light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n  \n   vec3 ro=vec3(0.0,-5.0,-25.0+t);\n    vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    float tc=5.0*sin(t0);\n    if(tc>0.0)\n    rd= rotate_x(rd, clamp( sin(t0*0.5),-0.25,0.5 ) );\n    else\n    rd= rotate_y(rd, clamp( sin(t0*0.5),-0.25,0.5 ) );\n    \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[549, 549, 585, 585, 606], [607, 607, 639, 639, 723], [724, 724, 763, 763, 858], [860, 860, 896, 896, 941], [943, 943, 977, 977, 1073], [1074, 1074, 1108, 1108, 1199], [1200, 1200, 1234, 1234, 1325], [1327, 1327, 1352, 1352, 2018], [2020, 2020, 2044, 2044, 2206], [2208, 2208, 2256, 2256, 2535], [2537, 2537, 2581, 2581, 2902], [2904, 2904, 2941, 2941, 3198], [3200, 3200, 3290, 3290, 4247], [4249, 4249, 4298, 4298, 4407], [4409, 4457, 4485, 4485, 4681], [4684, 4740, 4762, 4762, 5012], [5014, 5014, 5084, 5084, 5431], [5433, 5433, 5460, 5460, 5549], [5551, 5551, 5609, 5609, 5657], [5659, 5659, 5682, 5682, 5794], [5797, 5797, 5828, 5828, 6561], [6564, 6564, 6621, 6621, 7360]], "test": "untested"}
{"id": "stdBzM", "name": "Fractal mosaic 15 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 3, "viewed": 238, "published": 3, "date": "1662853613", "time_retrieved": "2024-07-30T16:31:36.406784", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        \n        //vec2(1.5,0.5)\n        //vec2(1.5,0.)\n        //vec2(abs(mod(a.x-.5,2.)-1.),abs(mod(a.y-.5,2.)-1.))\n    ,\n    \n    a1 = a+a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    return\n        abs(fract((a1)*(a2.x+a2.y))-.5)\n        //abs(fract(a+vec2(floor(a.x),floor(a.y)))/2.-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.y += iTime/t1/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n    \n        //Uncomment this line to make another interesting pattern\n        //uv.x -= abs(fract(uv.x)-.5)/scale;\n        \n        bool c1 = t2.x < uv.x;\n        uv = (uv+t2)/scale;\n        t2 = triangle_wave(uv-.5);\n        uv = t2-triangle_wave(uv.yx);       \n        \n        col.x = max(abs(uv.y-uv.x)/3.,col.x);\n        col =\n            abs(abs(col-(1.-col.x))-col.yzx);\n            //abs(abs(col-(float(c1)+1.-col.x))-col.yzx);\n            //abs(abs(col*col-(1.-col.x))-col.yzx);\n            //abs(abs(col-(1.-col.x))-col.yzx*col.yzx);\n        //if(uv.y>uv.x) uv = uv.yx;\n        //if(c1) col =\n            //col.yzx;\n            //abs(col.yzx-col);\n\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "#define fmod(x,y) mod(floor(x),y)\n//#define fmod(a,b) mod(mod(floor((a)),floor(1.+(a)/5.)),b)\n#define fmod1(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n\nvec2 mainSound(int samp, float time){\n  \n  float s1 =\n      8.,\n  s2 = 8.,\n  m4 =\n      fmod(floor(time*s1)+floor(time/s1),2.)\n  ,\n  t=\n      time/(1.+m4)\n  ,\n  m3 =\n      fmod(floor(t*s1)/1.5,s2);\n  t *=\n      s1*s1\n  ;\n\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  \n  float a = 64.*sqrt((1.-sqrt(max(fract(t/s1/s1),fract(t/s1)))))*.2,\n\n  nb = pow(2.,(m3+m2)/5.+6.5);\n\n  return abs(.5-vec2(fract(time*nb*.998)\n   ,fract(time*nb)))*a;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdBzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 461], [463, 463, 520, 520, 1512]], "test": "untested"}
{"id": "7ttBRM", "name": "Survey Results", "author": "ianthehenry", "description": "An experiment that I modeled with https://bauble.studio and then ported into Shadertoy.", "tags": ["3d", "landscape", "topography", "diorama", "bauble"], "likes": 17, "viewed": 289, "published": 3, "date": "1662844939", "time_retrieved": "2024-07-30T16:31:37.316351", "image_code": "precision highp float;\n\nconst int MAX_STEPS = 256;\nconst float MINIMUM_HIT_DISTANCE = 0.1;\nconst float NORMAL_OFFSET = 0.005;\nconst float MAXIMUM_TRACE_DISTANCE = 1024.0;\n\n/*\n\nThis shader was originally generated with https://bauble.studio, but\nI optimized the shader by hand and colorized it inside Shadertoy.\n\nThe original Bauble source that I used to iterate on shapes and values:\n\n    (defn quantize [x y]\n      (x * y | round / y))\n\n    (defn wave [angle period phase magnitude]\n      (sin ((~(. (* ,p (rotate_y (* ,angle ,tau))) :x) / 100 * period) + (tau * phase)) * magnitude))\n\n    (half-space :-y\n      (+ (wave 0.10 1.93 0.45 1.0)\n         (wave 0.10 5.33 1.27 1.0)\n         (wave 0.54 4.50 0.76 1.29)\n         (wave 2.43 4.72 -1.87 0.94)\n         (wave 2.38 6.74 -1.87 0.94)\n         (p.z / -50)\n         ((/ (length p.xz / 100)) * -4.5)\n      | remap+\n      | quantize 2\n      * 10\n      )\n    | union\n      (half-space :-y -36.6\n      | bounded-offset 1 (perlin (vec3 (~(. (* (rotate_y -0.33) ,p) :xz) / [2 14]) t))\n      | color [0 0 1]\n      | fresnel)\n    | intersect :r 5 (line [0 86 0] [0 100 0] 197)\n    | slow 0.5)\n\nI was planning to shade it normally, but I really liked the look of Bauble's\ndebug convergence view for this scene, so I decided to port it to Shadertoy\nand use the raymarching steps as an input for the shading. This gives the shader\na nice, free \"glow\" effect. But because of this, it only looks good from a few\nangles -- if you look straight down at the model, it's far too dark.\n\n*/\n\nmat3 rotate_y(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(\n    c, 0.0, s,\n    0.0, 1.0, 0.0,\n    -s, 0.0, c);\n}\n\n// Perlin noise functions by Stefan Gustavson\n// https://github.com/stegu/webgl-noise\nvec3 fade3(vec3 t) {\n  return t*t*t*(t * (t * 6.0 - 15.0) + 10.0);\n}\nvec4 taylor_inv_sqrt4(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 mod289_3(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289_4(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute4(vec4 x) {\n  return mod289_4(((x * 34.0) + 10.0) * x);\n}\nfloat perlin3(vec3 P) {\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3(Pi0);\n  Pi1 = mod289_3(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute4(permute4(ix) + iy);\n  vec4 ixy0 = permute4(ixy + iz0);\n  vec4 ixy1 = permute4(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylor_inv_sqrt4(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylor_inv_sqrt4(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade3(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat lake(vec3 p) {\n  float mag = 0.2;\n  float threshold = 1.0;\n  vec3 p1 = (p - vec3(0.0, -36.60, 0.0));\n  float boundary_distance = (p1.y - mag);\n  if (boundary_distance < threshold) {\n    vec3 p1 = (p - vec3(0.0, -36.6, 0.0));\n    vec3 rotated = rotate_y(-0.33) * p;\n    return p1.y - mag * (\n      perlin3(vec3(\n        (rotated - vec3(0.0, 0.0, 10.0 * iTime)).xz / vec2(2.0, 14.0),\n        sin(iTime)))\n      + 0.25 * perlin3(vec3(4.0 * (rotated - vec3(0.0, 0.0, 10.0 * iTime)).xz / vec2(2.0, 14.0), iTime))\n      );\n  } else {\n    return boundary_distance;\n  }\n}\n\nconst float TAU = 6.283185;\n\nfloat quantize(float x, float y) {\n  return round(x * y) / x;\n}\n\nfloat remap(float x) {\n  return 0.5 * (x + 1.0);\n}\n\nfloat wave(vec3 p, float angle, float period, float phase, float magnitude) {\n  float x = (p * rotate_y(angle * TAU)).x;\n  return sin(x * 0.01 * period + TAU * phase) * magnitude;\n}\n\nfloat landscape(vec3 p) {\n  float elevation = 10.0 * quantize(2.0, remap(\n      wave(p, 0.10, 1.93, 0.45, 1.0)\n    + wave(p, 0.10, 5.33, 1.27, 1.0)\n    + wave(p, 0.54, 4.50, 0.76, 1.29)\n    + wave(p, 2.43, 4.72, -1.87, 0.94)\n    + wave(p, 2.38, 6.74, -1.87, 0.94)\n    - (p.z / 50.0)\n    - (450.0 / length(p.xz))\n    ));\n\n  return 0.4 * (p.y - elevation);\n}\n\nfloat union_0(vec3 p) {\n  return min(landscape(p), lake(p));\n}\n\nfloat s3d_line(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\nvec3 fresnel(vec3 normal, vec3 P, vec3 camera_origin, vec3 color, float strength, float exponent) {\n  vec3 view_dir = normalize(camera_origin - P);\n  float fresnel = pow(1.0 - dot(normal, view_dir), exponent);\n  return color * strength * fresnel;\n}\n\nvec3 union_color_0(int steps, vec3 normal, vec3 camera_origin, vec3 p) {\n  if (landscape(p) < lake(p)) {\n    return vec3(0.0, 0.5*smoothstep(0.0, 0.5, float(steps) / float(MAX_STEPS)), 0.0);\n  } else {\n    float glow = smoothstep(0.0, 0.4, float(steps) / float(MAX_STEPS));\n    float sun = clamp(dot(normalize(reflect(p - camera_origin, normal)), normalize(vec3(0.5, 1.0, -5))), 0.0, 1.0);\n    sun = smoothstep(0.99, 1.0, sun);\n    return\n      vec3(0.0, 0.0, glow * 1.0)\n      + vec3(1.0, 0.5, 0.0) * sun\n      + fresnel(normal, p, camera_origin, vec3(0.8, 0.3, 1.0), 0.5, 3.0);\n  }\n}\n\nvec3 intersect_color_1(int steps, vec3 normal, vec3 camera_origin, vec3 p) {\n  float d = union_0(p);\n  float d2;\n  int surface = 0;\n  vec3 color;\n  d2 = (s3d_line(p, vec3(0.0, 86.0, 0.0), vec3(0.0, 100.0, 0.0)) - 197.0);\n  if (d2 > d) { d = d2; surface = 1; }\n\n  switch (surface) {\n    case 0:\n      return union_color_0(steps, normal, camera_origin, p);\n      break;\n    case 1:\n      // underside\n      return vec3(0.0, 0.25*smoothstep(0.0, 0.5, float(steps) / float(MAX_STEPS)), 0.0);\n      break;\n  }\n  return color;\n}\n\nfloat nearest_distance(vec3 p) {\n  float b, h = 0.0;\n  float r = 10.0;\n  float a = union_0(p);\n  b = s3d_line(p, vec3(0.0, 86.0, 0.0), vec3(0.0, 100.0, 0.0)) - 197.0;\n  h = clamp(0.5 - 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) + r * h * (1.0 - h);\n  return a;\n}\n\nvec3 calculate_normal(vec3 p) {\n  const vec3 step = vec3(NORMAL_OFFSET, 0.0, 0.0);\n\n  return normalize(vec3(\n    nearest_distance(p + step.xyy) - nearest_distance(p - step.xyy),\n    nearest_distance(p + step.yxy) - nearest_distance(p - step.yxy),\n    nearest_distance(p + step.yyx) - nearest_distance(p - step.yyx)\n  ));\n}\n\nvec3 march(vec3 ray_origin, vec3 ray_direction, out int steps) {\n  float distance = 0.0;\n\n  for (steps = 0; steps < MAX_STEPS; steps++) {\n    vec3 p = ray_origin + distance * ray_direction;\n\n    float nearest = nearest_distance(p);\n\n    // TODO: this attenuation only works when we're\n    // using march to render from the camera's point\n    // of view, so we can't use the march function\n    // as-is to render reflections. I don't know if\n    // it's worth having.\n    // if (nearest < distance * MINIMUM_HIT_DISTANCE * 0.01) {\n    if (nearest < MINIMUM_HIT_DISTANCE || distance > MAXIMUM_TRACE_DISTANCE) {\n      return p + nearest * ray_direction;\n    }\n\n    distance += nearest;\n  }\n  return ray_origin + distance * ray_direction;\n}\n\nvec3 nearest_color(vec3 p, vec3 camera_origin, int steps) {\n  return intersect_color_1(steps, calculate_normal(p), camera_origin, p);\n}\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec3 ray_dir(float fov, vec2 size, vec2 pos) {\n  vec2 xy = pos - size * 0.5;\n\n  float cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\n  float z = size.y * 0.5 * cot_half_fov;\n\n  return normalize(vec3(xy, -z));\n}\n\nmat3 rotate_xy(vec2 angle) {\n  vec2 c = cos(angle);\n  vec2 s = sin(angle);\n\n  return mat3(\n    c.y      ,  0.0, -s.y,\n    s.y * s.x,  c.x,  c.y * s.x,\n    s.y * c.x, -s.x,  c.y * c.x\n  );\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float gamma = 2.2;\n  vec2 resolution = iResolution.xy;\n\n  vec3 camera_origin = vec3(0.0, 0.0, 350.0);\n  vec2 rotation = vec2(-0.125, -0.25);\n  if (iMouse.z > 0.0) {\n    vec2 mouse_offset = (iMouse.xy / resolution) - 0.5;\n    mouse_offset *= vec2(-1.0, 0.5);\n    rotation += mouse_offset;\n  }\n  mat3 camera_matrix = rotate_xy(rotation.yx);\n\n  camera_origin = camera_matrix * camera_origin + vec3(0.0, -32.0, 0.0);\n\n  int view_type = 1;\n\n  vec3 dir = camera_matrix * ray_dir(45.0, resolution, gl_FragCoord.xy);\n\n  const vec3 fog_color = vec3(0.15);\n\n  int steps;\n  vec3 hit = march(camera_origin, dir, steps);\n\n  vec3 color;\n  float depth = distance(camera_origin, hit);\n  if (depth >= MAXIMUM_TRACE_DISTANCE) {\n    float glow = float(steps) / float(MAX_STEPS);\n    color = mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.2), gl_FragCoord.y / resolution.y);\n    color += vec3(0.0, glow, glow);\n  } else {\n    color = nearest_color(hit, camera_origin, steps);\n  }\n\n\n  fragColor = vec4(pow(color, vec3(1.0 / gamma)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1524, 1524, 1552, 1552, 1668], [1670, 1756, 1776, 1776, 1824], [1825, 1825, 1856, 1856, 1908], [1909, 1909, 1932, 1932, 1981], [1982, 1982, 2005, 2005, 2054], [2055, 2055, 2078, 2078, 2124], [2125, 2125, 2148, 2148, 4458], [4460, 4460, 4480, 4480, 5029], [5060, 5060, 5094, 5094, 5123], [5125, 5125, 5147, 5147, 5175], [5177, 5177, 5254, 5254, 5358], [5360, 5360, 5385, 5385, 5716], [5718, 5718, 5741, 5741, 5780], [5782, 5782, 5822, 5822, 5941], [5943, 5943, 6042, 6042, 6191], [6193, 6193, 6265, 6265, 6778], [6780, 6780, 6856, 6856, 7302], [7304, 7304, 7336, 7336, 7572], [7574, 7574, 7605, 7605, 7896], [7898, 7898, 7962, 7962, 8634], [8636, 8636, 8695, 8695, 8771], [8843, 8843, 8889, 8889, 9059], [9061, 9061, 9089, 9089, 9250], [9254, 9254, 9309, 9309, 10332]], "test": "untested"}
{"id": "NltfzM", "name": "Simplest Raymarching", "author": "01000001", "description": "absolute simplest raymarching program for educational purposes, with no additional features besides basic optimizations.\nSee https://www.shadertoy.com/view/dtjSDy for a golfed version.", "tags": ["raymarching", "basic", "tutorial"], "likes": 2, "viewed": 143, "published": 3, "date": "1662833840", "time_retrieved": "2024-07-30T16:31:38.280773", "image_code": "int maxSteps = 200;\n//max steps the loop will take.  try setting this really low, like 2 steps.\nfloat maxDepth = 10.0;\n//camera far plane pretty much.  See line 42.  This is usually around 500\n//but for this example we can make it tiny to boost performance.\nfloat minDist = 0.001;\n//distance from a surface at which the ray stops\n\nfloat DF(vec3 p)\n{\n    return length(p)-1.0;\n    //this is the distance function of a sphere.  Finds the distance to the centre,\n    //then subtracts the radius of the sphere\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*2.0;\n    //default UVs are fragCoord/iResolution.xy, which gives 0-1 coords from left to right and bottom to top.\n    //Non-default UVs.  Cartesian coordinates instead, (0,0) is the centre of the screen\n    \n    float depth = 0.0;\n    //how far along the ray is currently\n    vec3 o = vec3(0, -2, 0);\n    //origin point of the rays.  Camera position.\n    vec3 dirV = vec3(uv.x, 1.0, uv.y);\n    //Directional vector.  Added to the origin vector, to get a point in space offset from the camera\n    //You may want to normalize this vector to avoid future issues.\n    \n    for (int i = 0; i < maxSteps; i++)\n    {\n        vec3 p = o + dirV * depth;\n        //This is a ray.  \n        //p is a point in space of a ray going in direction dirV, starting from o, with a length of depth\n        float d = DF(p);\n        //finding the scene distance function\n        \n        depth += d;\n        //now we step forward by the minimum distance to the scene\n        \n        if (depth > maxDepth)\n        //Effectively camera far plane.  It's not completely necessary but it provides \n        //a performance boost and prevents random noise in the sky\n        {\n            break;\n        }\n        \n        if (d < minDist)\n        //Stop the ray once it hits something.  Important for performance to stop the ray from\n        //digging into a surface after it's close enough.  Sub pixel precision can almost always be discarded\n        //and in fact, removing sub pixel precision tends to reduce noise in complex geometry.\n        {\n            break;\n        }\n    }\n    \n    //screen output\n    fragColor = vec4(vec3(depth*2.0-2.0 /*bit of math that shifts the depth \n    to go from 0-1 from the front to the edge of the sphere.*/),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NltfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 331, 349, 349, 507], [509, 509, 566, 566, 2358]], "test": "untested"}
{"id": "stcfzM", "name": "Complex Rational Functions", "author": "mla", "description": "Complex rational functions, ie. ratios of complex polynomials.\n\nZeros are black, poles are white. Use mouse to move zeros and poles around.\n\nInspired by (and using a little code from):  [url]https://www.shadertoy.com/view/7sGXRm[/url]", "tags": ["function", "complex", "rational"], "likes": 17, "viewed": 302, "published": 3, "date": "1662831351", "time_retrieved": "2024-07-30T16:31:39.354901", "image_code": "// Complex Rational Functions, mla, 2022.\n//\n// ie. f(z) = F(z)/G(z) where F and G are polynomials so\n// f has zeros for roots of F and poles for roots of G. \n//\n// Here we set the roots of the two polynomials (drag around with the mouse)\n// and calculate F & G from them (ie. F(z) = (z-z0)(z-z1)... for roots z0,z1,...)\n//\n// Coloring shows arg(w), with contours shown for log(w)\n//\n// 'z' key adds an extra (unmoveable) zero at 0\n// 'i' key shows 1/f(z)\n// 'x' key inverts shading of magnitude\n\nvec2 polyeval(int off, vec2 z) {\n  vec2 res = vec2(1,0);\n  for (int i = 0; i < N; i++) {\n    res = cmul(res,z-getselection(2*i+off));\n  }\n  if (key(CHAR_Z) && off == 0) res = cmul(res,z);\n  return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setscale();\n    vec2 z = map(fragCoord);\n    \n    vec3 col1 = vec3(1,1,0);\n    vec3 col2 = vec3(0,1,1);\n    vec3 neutral = vec3(1,0,0);\n\n    vec2 num = polyeval(0,z);\n    vec2 denom = polyeval(1,z);\n    vec2 w = cdiv(num,denom);\n    if (!key(CHAR_R)) {\n      float t = 0.25*iTime;\n      w = cmul(w,vec2(cos(t),sin(t)));\n    }\n    //if (key(CHAR_I)) w = cinv(w);\n    w = clog(w);\n    if (key(CHAR_I)) w = -w;\n    float alpha = w.y/PI;\n\n    vec3 color;\n\n    if (alpha < 0.0) color = mix(neutral, col1, -alpha);\n    else color = mix(neutral, col2, alpha);\n\n    float t = 0.5+atan(w.x)/PI;\n    vec2 uv = 10.0*w/PI;\n    float px = fwidth(uv.x);\n    uv = fract(uv);\n    uv = min(uv,1.0-uv);\n    if (key(CHAR_X)) t = 1.0-t;\n    color = mix(vec3(t),color,smoothstep(0.0,px,min(uv.x,uv.y)));\n    color = pow(color,vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float PI = 3.14159265;\n\nvec2 cmul(vec2 z, vec2 w) {\n  return vec2(z.x*w.x-z.y*w.y,z.x*w.y+z.y*w.x);\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat scale = 1.0;\nvoid setscale() {\n  scale = 2.5;\n}\n\n#define SELECTIONS\nconst int N = 5;\nconst int nselections = 2*N;\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n#define map(screenpos) (scale*(2.0*(screenpos)-iResolution.xy)/iResolution.y)\n\nvec2 initselection(int i) {\n  float theta = 2.0*PI*float(i)/float(nselections);\n  vec2 res = vec2(0,1);\n  if (i%2 == 0) res *= 2.0;\n  return rotate(res,theta);\n}\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\nconst int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\nconst int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}", "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0 && iFrame != 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n    } else if (iFrame == 0 || t.z != 1234.0) {\n      t.z = 1234.0;\n      t.xy = initselection(i-1); // Current coordinates\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcfzM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[497, 497, 529, 529, 700], [702, 702, 759, 759, 1647]], "test": "untested"}
{"id": "slcfz7", "name": "2d analytic refraction", "author": "elenzil", "description": "Another 2D refraction study.\nSURPRISING RESULT: [b]when a ray passes from outside a sphere to inside, once inside there is no total internal reflection.[/b]\nTop: With Fresnel (Schlick's approximation)\nBottom: Reflectance = 0.5\n\n", "tags": ["raytracing"], "likes": 11, "viewed": 332, "published": 3, "date": "1662825205", "time_retrieved": "2024-07-30T16:31:40.303365", "image_code": "\nconst float iorA = ior_air;\nconst float iorB = ior_water;\n\n#define RES    (iResolution)\n#define MINRES (min(RES.x, RES.y))\n\nconst float gMinContrib = 0.001;\nconst uint  gMaxRays    = 20u;\n\nfloat gT;\n\n\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    float contrib;\n    float side;           // 1 = external -1 = internal\n};\n\nstruct hit_t {\n    bool  hit;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float t;    // distance along ray\n};\n\nvoid rayVsSphere(in ray_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n#define Q_TYPE        ray_t\n#define Q_MAX_ENTRIES 10u\nQ_IMPLEMENTATION\n\nconst float gZoom  = 0.8;\n\nvec2 worldFromScreen(in vec2 p) {\n    return (p - RES.xy / 2.0) / MINRES * 2.0 / gZoom - vX.xy * 0.5;\n}\n\n// hit normal is oriented towards \"outside\"\nhit_t rayVsScene(in ray_t ray) {\n    hit_t hit;\n    hit.t   = 1e9;\n    hit.hit = false;\n    \n    rayVsSphere(ray,  v0, 1.0, 1u, hit);\n    \n    return hit;\n}\n\n//-----------------------------------------------------------\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n//-----------------------------------------------------------\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2 xy = worldFromScreen(XY);\n    vec2 m  = worldFromScreen(iMouse.xy);\n    float ssEps = 3.0 / MINRES;\n    float ssLw  = 2.0 / MINRES;\n    \n    gT = iTime * 0.2 + pi / 2.0;\n    \n    if (length(iMouse.xy) < 40.0) {\n        m = vec2(cos(gT), sin(gT)) * 1.1 - vX.xy * 1.2;\n    }\n    \n    float c = 0.0;\n    float a = 1.0;\n    \n    ray_t r0;\n    r0.ro      = vec3(m.x, m.y, 0.0);\n    r0.rd      = vX;\n    r0.contrib = 1.0;\n    r0.side    = length(r0.ro) > 1.0 ? 1.0 : -1.0;\n    QEnqueue(r0);\n    \n    float R0 = schlickR0(iorA, iorB); \n    \n    uint rayCount = 0u;\n    \n    while(!QIsEmpty()) {\n        ray_t r = QDequeue();\n        hit_t h = rayVsScene(r);\n        rayCount += 1u;\n        \n        if (!h.hit) {\n            h.pnt = r.ro + r.rd * 1e5;\n        }\n        else {\n            bool addMoreRays = true;\n            addMoreRays = addMoreRays && (QSpaceLeft() > 2u);\n            addMoreRays = addMoreRays && (r.contrib > gMinContrib);\n            addMoreRays = addMoreRays && (rayCount < gMaxRays);\n            if (addMoreRays) {\n                vec3 hitFacingNormal = h.nrm * r.side;\n                float eta = pow(iorA / iorB, r.side);\n                ray_t rTrn;\n                rTrn.ro      = h.pnt - hitFacingNormal * 0.0001;\n                rTrn.rd      = refract(r.rd, hitFacingNormal, eta);\n                if (rTrn.rd == v0) {\n                    // total internal\n                    rTrn.contrib = 0.0;\n                }\n                else {\n                    float R = schlick(R0, dot(r.rd, -hitFacingNormal));\n                    if (r0.ro.y < 0.0) {\n                        R = 0.5;\n                    }\n                    rTrn.contrib = r.contrib * (1.0 - R);\n                    rTrn.side    = -r.side;\n                    QEnqueue(rTrn);\n                }\n                \n                ray_t rRfl;\n                rRfl.ro      = h.pnt + hitFacingNormal * 0.0001;\n                rRfl.rd      = reflect(r.rd, hitFacingNormal);\n                rRfl.side    = r.side;\n                rRfl.contrib = r.contrib - rTrn.contrib;\n                QEnqueue(rRfl);\n            }\n        }\n        \n        float d;\n        d = length(xy - h.pnt.xy);\n        c += a * r.contrib * smoothstep(ssEps, 0.0, d - ssLw * 4.0);\n        a *= 0.2 + 0.8 * smoothstep(0.0, ssLw * 7.0, d - ssLw * 7.0);\n        d = sdSegment(xy, r.ro.xy, h.pnt.xy);\n        c += a * r.contrib * smoothstep(ssEps, 0.0, d - ssLw * 4.0);\n        a *= 0.2 + 0.8 * smoothstep(0.0, ssLw * 7.0, d - ssLw * 7.0);\n    }\n    \n    RGBA.rgb = vec3(c);\n    \n    const vec3 sceneColor = vec3(0.1, 0.5, 0.7) * 0.04;\n    \n    RGBA.rgb += sceneColor * smoothstep(ssEps, 0.0, abs(length(xy) - 1.0) - ssLw);\n    RGBA.rgb += sceneColor * smoothstep(ssEps, 0.0, abs(xy.y) - ssLw) * smoothstep(0.0, ssEps, length(xy) - 1.0);\n    \n    // boost darker colors\n    RGBA.rgb = pow(RGBA.rgb, vec3(0.45));\n    RGBA.a = 1.0;\n}\n\n\n", "image_inputs": [], "common_code": "const vec3  v0 = vec3(0.0);\nconst vec3  v1 = vec3(1.0);\nconst vec3  vX = vec3(1.0, 0.0, 0.0);\nconst vec3  vY = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ = vec3(0.0, 0.0, 1.0);\nconst float pi = 3.14159265359;\n\n\n//--------------------------------------------------------------------------------\nconst float ior_air     = 1.0003;\nconst float ior_ice     = 1.309;\nconst float ior_water   = 1.333;\nconst float ior_quartz  = 1.46;\nconst float ior_diamond = 2.42;\n\n\n//--------------------------------------------------------------------------------\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENMTATION.\n// this is a basic ringbuffer.\n// NO ERROR CHECKING\n// orion elenzil 2022.\n//\n// Usage:\n// #define Q_TYPE        <your type>\n// #define Q_MAX_ENTRIES <size of rungbuffer you want. unsigned int>\n// Q_IMPLEMENTATION\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n\tif (gQHead >= gQTail) {                        \\\n\t\treturn gQHead - gQTail;                    \\\n\t}                                              \\\n\telse {                                         \\\n\t\treturn gQNumSlots - (gQTail - gQHead);     \\\n\t}                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n\treturn gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n\treturn QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n\treturn QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint QEnqueueIndex() {                             \\\n\tgQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint QDequeueIndex() {                             \\\n\tgQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n\tgQ[QEnqueueIndex()] = item;                    \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n\treturn gQ[QDequeueIndex()];                    \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\n\n// returns false if there are no real roots.\n// returns true if there are one or two real roots.\n// roots.x <= roots.y.\nbool solveQuadratic(in vec3 coeffs, out vec2 roots) {\n    const uint A = 0u;\n    const uint B = 1u;\n    const uint C = 2u;\n    \n    // (-B +- sqrt(BB - 4AC)) / 2A\n    \n    float disc = (coeffs[B] * coeffs[B]) - (4.0 * coeffs[A] * coeffs[C]);\n    \n    if (disc < 0.0) {\n        return false;\n    }\n    \n    float sqrt_disc = sqrt(disc);\n    \n    roots.x = (-coeffs[B] - sqrt_disc) / (2.0 * coeffs[A]);\n    roots.y = (-coeffs[B] + sqrt_disc) / (2.0 * coeffs[A]);\n    \n    if (roots.y < roots.x) {\n        roots.xy = roots.yx;\n    }\n    \n    return true;\n}\n\n\n//--------------------------------------------------------------------------------\n// From IQ - https://iquilezles.org/articles/distfunctions2d\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcfz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[441, 441, 520, 520, 1385], [1486, 1486, 1519, 1519, 1589], [1591, 1635, 1667, 1667, 1791], [1793, 1914, 1957, 1995, 2072], [2073, 2073, 2120, 2120, 2222], [2287, 2287, 2330, 2330, 5223]], "test": "untested"}
{"id": "sl3Bz7", "name": "Saturday Torus III", "author": "mrange", "description": "CC0: Saturday Torus II\nI did a B&W torus sometime ago. I revisited it \nand instead for glowing lines.\n", "tags": ["3d"], "likes": 37, "viewed": 789, "published": 3, "date": "1662817730", "time_retrieved": "2024-07-30T16:31:41.096245", "image_code": "// CC0: Saturday Torus III\n//  I did a B&W torus sometime ago. I revisited it \n//  and instead for glowing lines.\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define PERIOD      30.0\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nfloat rayTorus(vec3 ro, vec3 rd, vec2 tor) {\n  float po = 1.0;\n\n  float Ra2 = tor.x*tor.x;\n  float ra2 = tor.y*tor.y;\n\n  float m = dot(ro,ro);\n  float n = dot(ro,rd);\n\n  // bounding sphere\n  {\n    float h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n    if(h<0.0) return -1.0;\n    //float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n  }\n\n  // find quartic equation\n  float k = (m - ra2 - Ra2)/2.0;\n  float k3 = n;\n  float k2 = n*n + Ra2*rd.z*rd.z + k;\n  float k1 = k*n + Ra2*ro.z*rd.z;\n  float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\n  #ifndef TORUS_REDUCE_PRECISION\n  // prevent |c1| from being too close to zero\n  if(abs(k3*(k3*k3 - k2) + k1) < 0.01)\n  {\n    po = -1.0;\n    float tmp=k1; k1=k3; k3=tmp;\n    k0 = 1.0/k0;\n    k1 = k1*k0;\n    k2 = k2*k0;\n    k3 = k3*k0;\n  }\n  #endif\n\n  float c2 = 2.0*k2 - 3.0*k3*k3;\n  float c1 = k3*(k3*k3 - k2) + k1;\n  float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n\n  c2 /= 3.0;\n  c1 *= 2.0;\n  c0 /= 3.0;\n\n  float Q = c2*c2 + c0;\n  float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n\n  float h = R*R - Q*Q*Q;\n  float z = 0.0;\n  if(h < 0.0) {\n    // 4 intersections\n    float sQ = sqrt(Q);\n    z = 2.0*sQ*cos(acos(R/(sQ*Q)) / 3.0);\n  } else {\n    // 2 intersections\n    float sQ = pow(sqrt(h) + abs(R), 1.0/3.0);\n    z = sign(R)*abs(sQ + Q/sQ);\n  }\n  z = c2 - z;\n\n  float d1 = z   - 3.0*c2;\n  float d2 = z*z - 3.0*c0;\n  if(abs(d1) < 1.0e-4) {\n    if(d2 < 0.0) return -1.0;\n    d2 = sqrt(d2);\n  } else {\n    if(d1 < 0.0) return -1.0;\n    d1 = sqrt(d1/2.0);\n    d2 = c1/d1;\n  }\n\n  //----------------------------------\n\n  float result = 1e20;\n\n  h = d1*d1 - z + d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=t1;\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  h = d1*d1 - z - d2;\n  if(h > 0.0) {\n    h = sqrt(h);\n    float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n    if(t1 > 0.0) result=min(result,t1);\n    if(t2 > 0.0) result=min(result,t2);\n  }\n\n  return result;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nvec3 torusNormal(vec3 pos, vec2 tor) {\n  return normalize(pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nvec3 effect(vec2 p, float ntime, float ptime) {\n  float h0 = hash(ntime + 1.5);\n  float h1 = fract(8677.0*h0);\n  float rn = mod(ntime, 3.0);\n  const float rdd = 2.0;\n  const vec3 ro0 = vec3(0.0, 0.75, -0.2); \n  const vec3 ro1 = vec3(0.0, 0.75, 0.2); \n  const vec3 ro2 = vec3(0.0, 0.5, -0.38); \n  vec3 ro  = ro0;\n  if (rn == 1.0) {\n    ro = ro1;\n  } else if (rn == 2.0) {\n    ro = ro2;\n  }\n  \n  const vec3 la  = vec3(0.0, 0.0, 0.2);\n  const vec3 up  = normalize(vec3(0.3, 0.0, 1.0));\n  vec3 lp1 = ro;\n  lp1.xy  *= ROT(0.85);\n  lp1.xz  *= ROT(-0.5);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = (cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n\n  const vec2 tor = 0.55*vec2(1.0, 0.75);\n  float td    = rayTorus(ro, rd, tor);\n  vec3  tpos  = ro + rd*td;\n  vec3  tnor  = -torusNormal(tpos, tor);\n  vec3  tref  = reflect(rd, tnor);\n\n  vec3  ldif1 = lp1 - tpos;\n  float ldd1  = dot(ldif1, ldif1);\n  float ldl1  = sqrt(ldd1);\n  vec3  ld1   = normalize(ldif1);\n  vec3  sro   = tpos+0.05*tnor;\n  float sd    = rayTorus(sro, ld1, tor);\n  vec3  spos  = sro+ld1*sd;\n  vec3  snor  = -torusNormal(spos, tor);\n\n  float dif1  = max(dot(tnor, ld1), 0.0);\n  float spe1  = pow(max(dot(tref, ld1), 0.0), 10.0);\n  float r     = length(tpos.xy);\n\n  float a     = atan(tpos.y, tpos.x);\n  float tw    = 1.0*PI*tpos.z/(r+0.5*abs(tpos.z));\n  float aa    = ptime*TAU/45.0;\n  a -= tw+aa;\n\n  float n = floor(mix(1.0, 7.0, h0));\n  vec2 pg = vec2(a, tpos.z-TIME*0.1);\n  vec2 ng = mod2(pg, vec2(TAU/n, 0.5));\n  float dg0 = max(abs(pg.x)-0.01, 0.001);\n  float dg1 = 0.5*max(length(pg)-0.01, 0.001);\n  float dg = h1 < 0.5 ? dg0 : dg1;\n\n  vec3 gcol = hsv2rgb(vec3(fract(0.1*ptime+0.125*ng.x*tpos.y), 0.75, 1.0-0.5));\n  const vec3 lcol = HSV2RGB(vec3(0.55, 0.9, 0.75));\n  \n  float fre = 1.0+dot(rd, tnor);\n  fre *= fre;\n\n  vec3 col = vec3(0.0);\n\n  vec3 mat = 0.125*lcol*dif1+4.0*sqrt(lcol)*spe1*fre; \n  if (td > -1.0) {\n    col += mat;\n  }\n  \n  float shade = mix(1.0, 0.1, pow(abs(dot(ld1, snor)), 3.0*tanh_approx(sd))); \n  if (sd < ldl1) {\n    col *= shade;\n  }\n\n  vec3 glow = 0.0125*gcol/(dg)*smoothstep(1.0, 0.8, fre); \n  if (td > -1.0) {\n    col += glow;\n  }\n\n  return col;\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float ptime = mod(TIME, PERIOD);\n  float ntime = floor(TIME/PERIOD);\n  vec3 col = effect(p, ntime, ptime);\n  col = aces_approx(col);\n  col *= smoothstep(0.0, 2.0, ptime);\n  col *= smoothstep(PERIOD, PERIOD-2.0, ptime);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3Bz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[471, 471, 493, 493, 639], [934, 1025, 1069, 1069, 3127], [3129, 3220, 3258, 3258, 3346], [3348, 3408, 3436, 3502, 3578], [3580, 3666, 3702, 3702, 3796], [3798, 3858, 3880, 3880, 3928], [3930, 3930, 3977, 3977, 6127], [6129, 6229, 6248, 6248, 6335], [6337, 6444, 6470, 6470, 6654], [6656, 6656, 6711, 6711, 7080]], "test": "untested"}
{"id": "NldfR4", "name": "Fraggiti", "author": "leon", "description": "Fragmento del graffiti, es el fraggiti!", "tags": ["tag", "graffiti"], "likes": 32, "viewed": 603, "published": 3, "date": "1662812459", "time_retrieved": "2024-07-30T16:31:42.093579", "image_code": "\n// Fraggiti\n// revisiting Brush Toy https://www.shadertoy.com/view/NlSBW3\n// but this time paint is fresh and leaky\n// the three thumbnails on the right are the \"debug g-buffer art\"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // lighting\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    float mask = data.r;\n    vec3 light = normalize(vec3(0,1,1));\n    vec3 normal = texture(iChannel1, uv).rgb;\n    float shade = dot(normal, light)*.5+.5;\n    vec4 color = vec4(uv, .5, 1);\n    \n    // background\n    color.rgb = vec3(1) * smoothstep(2., -2., length(uv-.5));\n    \n    if (shade > .01)\n    {\n        // materials\n        float select = fract(iTime*speed/4.);\n        if (select > .75) {\n            color.rgb = .5+.5*cos(vec3(1,2,3)*5.+min(3., mask));\n            color += pow(shade, 60.);\n        } else if (select > .5) {\n            color.rgb = .5+.5*cos(vec3(1,2,3)*5.+uv.y*5.);\n            color *= shade*.5+.5;\n            color += pow(shade, 60.);\n        } else if (select > .25) {\n            color.rgb = .5+.5*cos(vec3(1,2,3)*5.5+shade*2.+2.);\n        } else {\n            color = vec4(shade);\n        }\n        \n    } else {\n        \n        // debug g-buffer\n        uv *= 3.;\n        uv.x -= 2.;\n        uv.y -= 2.;\n        if (uv.x < 1. && uv.y < 1.) {\n            vec4 map = texture(iChannel0, uv);\n            if (map.r + map.g > .01) color = map;\n        }\n        uv.y += 1.;\n        if (uv.x < 1. && uv.y < 1.) {\n            vec4 map = texture(iChannel1, uv);\n            if (map.a > .01) color = map;\n        }\n        uv.y += 1.;\n        if (uv.x < 1. && uv.y < 1.) {\n            normal = texture(iChannel1, uv).rgb;\n            shade = dot(normal, light)*.5+.5;\n            if (shade > .01) color = vec4(shade);\n        }\n    }\n    \n    fragColor = color;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// move horizontally, with circles and random offset\nvec2 move(float t)\n{\n    vec2 pos = vec2(0);\n    float angle = t*12.;\n    float radius = .1;\n    float time = t*5.;\n    float index = floor(time);\n    float anim = fract(time);\n    float scroll = fract(t*speed);\n    vec2 rng = mix(hash21(index), hash21(index+1.), anim);\n    pos += (rng*2.-1.)*.5;\n    pos.x += scroll*2.-1.;\n    pos += vec2(cos(angle),sin(angle))*radius;\n    return pos;\n}\n\n// draw mask\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = 2.*(fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    // mask\n    float scroll = fract(iTime*speed);\n    float thin = .1+.05*sin(iTime*16.);\n    float dist = sdSegment(pos, move(iTime-iTimeDelta), move(iTime));\n    float mask = smoothstep(thin,.0,dist);\n    \n    // leaks\n    float time = iTime*100.;\n    float anim = fract(time);\n    float index = floor(time);\n    float wave = sin(anim*3.14);\n    vec3 noise = texture(iChannel2, uv).rgb;\n    vec3 normal = texture(iChannel1, uv).rgb;\n    vec2 target = (hash21(index)*2.-1.);\n    float d = length(pos-target);\n    float gravity = wave * smoothstep(.1,.0,d) * 10.;\n    vec2 offset = vec2(0,1)/iResolution.xy;\n    vec4 frame = texture(iChannel0, uv+offset);\n    float leak = frame.g;\n    gravity *= smoothstep(.6, 1., noise.g);\n    gravity *= max(0., dot(normal, -vec3(0,1,0)));\n    uv.y += noise.b*leak/iResolution.y;\n    uv -= leak*normal.xy/iResolution.xy;\n    \n    // frame buffer\n    frame = texture(iChannel0, uv);\n    mask = mask * 0.1 + frame.r;\n    fragColor = vec4(mask, frame.g+gravity, 0, 0);\n    fragColor *= step(.01, scroll);\n}", "buffer_a_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define speed 0.2\n\n#define T(uv) texture(iChannel0, uv).r\n\n// Inigo Quilez https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}", "buffer_b_code": "\n// compute normal\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    vec3 unit = vec3(1./iResolution.xy, 0);\n    vec3 normal = normalize(vec3(\n                            T(uv+unit.xz)-T(uv-unit.xz),\n                            T(uv-unit.zy)-T(uv+unit.zy),\n                            color.r*.5));\n                            \n    fragColor = vec4(normal, length(normal));\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[184, 184, 241, 257, 1832]], "test": "untested"}
{"id": "stcfRM", "name": "Peano x Sierpinski ", "author": "FabriceNeyret2", "description": "reference: [url] https://twitter.com/ruuddotorg/status/1566955520652500992 [/url]", "tags": ["fractal", "sierpinski", "short", "reproduction", "peano"], "likes": 37, "viewed": 424, "published": 3, "date": "1662805895", "time_retrieved": "2024-07-30T16:31:42.932336", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( u - .5*R ) / R.y, F;\n     O = vec4(1);     \n    if (abs(U.x)>.5) return;                                        // out of bounds\n    int m=1, z=0, t = int(iTime)%8;\n    \n    for( ; z < 1+min(t,8-t); z++ ) {                                // === fractal loop\n        U *= 3.; \n        ivec2 I = ivec2(mod(U+1.5,3.)) - 1;                         // sub-tile id\n        if ( m==2 && (I.x+I.y+2)%2 < 1 ) U = vec2(U.y,-U.x);        // rot  // +2 for MacOS\n        if ( I.y==0 && I.x!=0 ) U = float(I.x)*vec2(-U.y,U.x);      // rot\n                                                //  ( c = tile id, I = sub-tile pos ) →  sub-tile id \n        m = int[]( -3,2,1,3,4,3,1,2,3, -3,-3,-3,2,4,2,3,3,3, -3,2,3,3,4,3,1,2,3, \n                   0,0,-5,0,6,0,5,0,0, 0,0,6, 0,6,0, 5,0,0,  0,0,6, 0,6,0, 6,0,0 ) [I.x+3*I.y+9*m-5];\n        if ( m==0 )  return;                                        // empty area\n        if ( m < 0 ) U = -U, m = -m;                                // rot2 ( = sym )\n    }   \n    F = fract(U+1.5); \n    float y = ( 1. + smoothstep(1.,0., m!=5 ? F.x : F.x/2. ) ) / 3.,// --- draw tile elements\n          d =   m==1 ? F.y - y                                      // meander elements\n              : m==2 ? F.y + y-1.       \n              : m==3 ? length(F) - .67  \n              : m==4 ? F.y - y                                      // diagonal elements\n              : m==5 ? F.y - 4.*y+2.    \n              :        F.y+F.x - 1.;              \n    O = sqrt( abs(d) * R.yyyy/pow(3.,float(z)) );                   // draw with AA + final sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcfRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7tKyWD", "name": "Cat the Game", "author": "deni_de", "description": "My first shader game exp, just a little hardcore game about cat, bad cat and mooncat-coins; \nDifficult change at pick coins 10-30-50-70-100-150.\n[ arrows ] - moving\n[ space ] -  jump", "tags": ["game", "cat"], "likes": 11, "viewed": 352, "published": 3, "date": "1662790897", "time_retrieved": "2024-07-30T16:31:44.274747", "image_code": "#define catSize 4.3\n#define NormalizeScale uv -= vec2(0.5, 0.5); uv *= catSize; uv += vec2(0.5, 0.5);\n\nvoid storeValue (in ivec2 v, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord)\n{\n    fragColor = ( v.x == fragCoord.x && v.y == fragCoord.y ) ? va : fragColor;\n}\n\nvec2 uvRotate(vec2 uv, vec2 offset, float mul)\n{\n    uv -= vec2(offset.x, offset.y);\n    uv *= vec2(3.7,3.7);\n    //fake rotate\n    //uv.x /= 1.0 * sin(iTime * 2.5 * mul);\n    uv += vec2(offset.x, offset.y);\n    \n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 finaly = vec4(0.0);\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    vec4 badCatUv = fetchData(iChannel1, badCatPos);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 buv = uv;\n    vec2 m = uv;\n    vec2 hudUv = uv;\n    \n    vec2 bcat = uv;\n    \n    bcat -= badCatUv.xy;\n    \n    NormalizeScale;\n    \n    vec4 pos = fetchData(iChannel1, position);\n    vec4 _jump = fetchData(iChannel1, jump);\n    float dir = fetchData(iChannel1, direction).r;\n    vec4 coinY = fetchData(iChannel1, coinsY);\n    vec4 coinX = fetchData(iChannel1, coinsX);\n    vec4 catP = fetchData(iChannel1, catPos);\n    vec4 sbcatP = fetchData(iChannel1, sbadCatPos);\n    vec4 cl = fetchData(iChannel1, CL);\n    vec4 stg = fetchData(iChannel1, stage);\n    \n    vec4 coin = vec4(0.0);\n    \n    coin += texture( iChannel3, uvRotate(m - vec2(coinX.x,coinY.x),  vec2(0.5,0.5),cl.w)) ;\n    coin += texture( iChannel3, uvRotate(m - vec2(coinX.y,coinY.y),  vec2(0.5,0.5),cl.w)) ;\n    coin += texture( iChannel3, uvRotate(m - vec2(coinX.z,coinY.z),  vec2(0.5,0.5),cl.w)) ;\n    \n    //UI Coin\n    coin += texture( iChannel3, hudUv * 9.5- vec2(-0.35, 8.32)); \n\n    vec2 shdUv = uv;\n    shdUv.y *= -1.0;\n    shdUv.x -= pos.x;\n    shdUv.xy -= vec2(.45, 1.15 + pos.y * 0.1);\n    shdUv.x *= -dir;\n    \n    vec2 catUv = uv - pos.xy; \n    catUv -= vec2(0.5,0.5);\n    catUv.x *= -dir;\n    shdUv.x += 0.2;\n    catUv += vec2(0.5,0.5);\n    \n    bcat -= vec2(0.5,0.5);\n    bcat *= 4.3;\n    bcat.x *= badCatUv.w;\n    bcat += vec2(0.5,0.5);\n    \n    vec4 cat = texture( iChannel0, catUv );\n    vec4 badCat = texture(iChannel0, bcat) * vec4(0.0,0.0,0.0,1.0);\n    vec4 badCatShadow = texture(iChannel0, bcat * vec2(1.0,-2.9) - vec2(0.,-0.8)) * vec4(0.0,0.0,0.0,0.5);\n    float eLR = circleA(bcat, vec2(0.65,0.5), 0.04);\n    eLR += circleA(bcat, vec2(0.8,0.5), 0.04);\n    badCat += eLR * vec4(1.0,0.0,0.0,1.0);\n    badCat += badCatShadow;\n    \n    \n    vec3 back = texture( iChannel2, buv ).rgb;\n\n    //add pink if danger distance\n    if(sbcatP.x >= 0.35)\n    {\n        back.rgb += vec3(0.5,0.0,0.5);\n    }\n    \n    //add red if hit damage \n    if(sbcatP.x >= 0.55)\n    {\n        back.rgb += vec3(1.0,0.0,-1.0);\n    }\n    \n    shdUv.y *= 2.9;\n    vec4 catShadow = texture( iChannel0, shdUv + vec2(0.3, -0.4) ) ;\n    \n    \n    cat.rgb = mix( catShadow.rgb * vec3(0,0,0) * back.r, cat.rgb, cat.a );\n    //Controll of shadow density \n    cat.a += catShadow.a * 0.5 ; //add jump modify to change density\n    cat.a = clamp(cat.a,0.0,1.0);\n    \n    finaly.rgb = mix(back, coin.rgb, coin.a);\n    finaly.rgb = mix(finaly.rgb, cat.rgb, cat.a);\n    finaly.rgb = mix(finaly.rgb, badCat.rgb, badCat.a);\n    \n    //UI lives \n    int count = int(cl.y);\n    \n    for(int i = 0; i < count; i++)\n    {\n        float cly = float(i);\n        \n        //HEART BLOCK------------------\n    \n        vec2 uv2 = fragCoord/iResolution.xy;\n        uv2.x *= 2.0;\n        uv2 /= 0.15;\n        uv2.x += 0.3;\n        uv2.y -= 6.18;\n        vec2 uv3 = uv2;\n        \n        uv2.x -= cly * 0.33;\n        uv3.x -= cly * 0.33;\n\n        uv2 += vec2(0.5,0.0) * uv2.y;\n        uv3 -= vec2(0.5,0.0) * uv2.y;\n\n        float hearth = clamp( circleA( uv2, vec2(0.60,0.29),0.1)\n                        + circleA( uv3, vec2(0.40,0.29),0.1), 0.0, 1.0);\n                        \n        //HEART BLOCK-------------------\n        \n        finaly += hearth * vec4(1.0,0.2,0.0,hearth);\n    }\n    \n    if(stg.z == 0.0)\n    {\n        vec4 _coin =  texture( iChannel3, hudUv * 2.5- vec2(0.5, 1.57));\n        finaly.rgb = mix(back.rgb, _coin.xyz * _coin.w, _coin.w)  ;\n    }\n    \n        \n    fragColor = clamp(vec4( vec3(finaly), 1.0), 0.0, 1.0);\n        \n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 loadValue (in ivec2 v)\n{\n    return texelFetch( iChannel0, v, 0);\n}\n\nvoid saveValue (in ivec2 v, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord)\n{\n    fragColor = ( v.x == fragCoord.x && v.y == fragCoord.y ) ? va : fragColor;\n}\n\nvoid difficult (float score, inout float multiple, inout float stage, inout float uitime)\n{\n    \n    if(score == 10.)\n    {\n        multiple = 1.0;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n    else if(score == 30.)\n    {\n        multiple = 1.5;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n    else if(score == 50.)\n    {\n        multiple = 2.0;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n    else if(score == 70.)\n    {\n        multiple = 2.5;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n    else if(score == 100.)\n    {\n        multiple = 2.9;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n    else if(score == 150.)\n    {\n        multiple = 3.5;\n        stage += 1.0;\n        uitime = 1.5;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    bool  E = texelFetch(iChannel1, ivec2(KEY_ENTER, 0.), 0).x  > 0.0 ?  true : false;\n    bool  S = texelFetch(iChannel1, ivec2(KEY_SPACE, 0.), 0).x  > 0.0 ?  true : false;\n    float L = texelFetch(iChannel1, ivec2(KEY_LEFT,  0.), 0).x  > 0.0 ?  1.0 : 0.0;\n    float R = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0.), 0).x  > 0.0 ? -1.0 : 0.0;\n    \n    //Start Data\n   \n    vec3 catColorRandom = vec3( 0.1 + random(uv,iTime * iDate.z), 0.1 + random(uv,iTime + iDate.z), 0.1 + random(uv,iTime * iDate.w) );\n\n    if (storeData(fragCoord, position))\n        fragColor = vec4(0.0, 0.25, 0.0, 0.0 );\n    if (storeData(fragCoord, jump))\n        fragColor = vec4(1.0, 0.0, 1.0, 0.0 );\n    if (storeData(fragCoord, direction))\n        fragColor = vec4(-1.0, 0.0, 0.0, 0.0 );\n    if (storeData(fragCoord, coinsX))\n        fragColor = vec4(-0.37, 0.0, 0.37, 0.0 );\n    if (storeData(fragCoord, coinsY))\n        fragColor = vec4(1.5, 1.0, 1.5, 0.0 );\n    if (storeData(fragCoord, CL))\n        fragColor = vec4(0.0, 9.0, 1.0, 1.0 );\n    if (storeData(fragCoord, catColor))\n        fragColor = vec4(catColorRandom, 0.0);\n    if (storeData(fragCoord, stage))\n        fragColor = vec4(48, 1.5, 1.0, 0.0);\n    \n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    vec4 pos = loadValue(position);\n    vec4 _jump = loadValue(jump);\n    vec4 dir = loadValue(direction);\n    vec4 coinY = loadValue(coinsY);\n    vec4 coinX = loadValue(coinsX);\n    vec4 bCatPos = loadValue(badCatPos); \n    vec4 sbCatPos = loadValue(sbadCatPos);\n    vec4 cl = loadValue(CL);\n    vec4 ccr = loadValue(catColor);\n    vec4 stg = loadValue(stage);\n    \n    if (iFrame > 0)  \n    {\n       if(stg.z == 2.0)\n       {\n           //Pasuse stage\n       }\n       else if(stg.z == 1.0)\n       {\n//CHARACTER SECTION--------------------------------\n\n            if( L > 0. && R == 0. || L == 0. && R < 0. )\n            {\n                pos.x -= (L + R) * speed;\n                dir.x = L + R;\n            }\n\n//----------------jump-----------------------------\n\n            if( S && _jump.x == 0.0)\n            {\n                _jump.x = 1.0;\n                _jump.y = jumpheight;\n                // add jump iteration\n                _jump.z = 1.0;\n            }\n\n            pos.y += _jump.y;\n\n            // wasting jump energy\n            if(_jump.x > 0.0)\n            {\n                _jump.y -= 0.005;\n            }\n\n            // emulate floor\n            pos.y = clamp(pos.y, border.x, 1.0);\n\n            // reset jump state\n            if(pos.y == border.x)\n            {\n                if(_jump.z > 0.0)\n                {\n                    _jump.z -= 1.0;\n                    _jump.y = jumpheight/3.0;\n                }\n                else\n                {\n                    _jump.x = 0.0;\n                }\n            }\n\n            pos.x = clamp(pos.x, -1.8, 1.8);\n\n//MOONCATCOINS SECTION--------------------------------\n\n            coinY.xyz -= 0.015 * cl.w;\n\n            if(coinY.x < -0.35)\n            {\n                coinY.x += 2.0;\n            }\n            if(coinY.y < -0.35)\n            {\n                coinY.y += 2.0;\n            }\n            if(coinY.z < -0.35)\n            {\n                coinY.z += 2.0;\n            }\n\n            sbCatPos.y = 1.-distance(pos.xy,vec2(coinX.y,coinY.y) * 4.3);\n\n            if(sbCatPos.y >= 0.5)\n            {\n\n                coinY.y = 1.0;\n                cl.x += 1.0;\n                difficult( cl.x, cl.w, stg.x, stg.y);\n            }\n\n            sbCatPos.z = 1.-distance(pos.xy,vec2(coinX.x,coinY.x) * 4.3);\n\n            if(sbCatPos.z >= 0.5)\n            {\n                coinY.x = 1.0;\n                cl.x += 1.0;\n                difficult( cl.x, cl.w, stg.x, stg.y);\n            }\n\n            sbCatPos.w = 1.-distance(pos.xy,vec2(coinX.z,coinY.z) * 4.3);\n\n            if(sbCatPos.w >= 0.5)\n            {\n                coinY.z = 1.0;\n                cl.x += 1.0;\n                difficult( cl.x, cl.w, stg.x, stg.y);\n            }\n\n            coinX.xyz += (L + R) * speed * 0.15;\n\n            coinX.x = clamp(coinX.x, -0.37-0.3, -0.37+0.25);\n            coinX.y = clamp(coinX.y, 0.0-0.3, 0.0+0.25);\n            coinX.z = clamp(coinX.z, 0.37-0.3, 0.37+0.25);\n\n// STAGE -----------------------------------------\n            if(stg.y > 0.0)\n                stg.y -= 0.01;\n\n// BAD CAT SECTION--------------------------------\n            bCatPos.xy = vec2(-0.35,-0.35) + vec2(2. * sin(iTime + 4.0) * .5 *  cl.w, 0.0);\n            vec2 zbCatPos = bCatPos.xy * 4.3;\n\n            //badCatDirection\n            bCatPos.w = sin(iTime) > 0. ? 1.0 : -1.0;\n\n            //distance to character\n            sbCatPos.x = 1.- distance(pos.xy, zbCatPos.xy) ;\n\n            if(sbCatPos.x >= 0.6)\n            {\n                //reset pos\n                pos.x = 0.0; \n                pos.y = 0.0;\n\n                //minus life\n                cl.y -= 1.0;\n\n                //resetcoins pos\n                coinX.x = -0.37;\n                coinX.y = 0.0;\n                coinX.z = 0.37;\n\n                //reset game is hp left\n                if(cl.y <= 0.)\n                {\n                    \n                    //\n                    cl.w = 1.;\n\n                    //start stage _1 and alphatext\n                    stg.x = 48.;\n                    stg.y = 1.5;\n\n                    //game over\n                    stg.z = 0.0;\n\n                    ccr.xyz = vec3( 0.1 + random(uv, fract(iTime)), 0.1 + random(uv, fract(iDate.w)), 0.1 + random(uv, fract(iDate.z)) );\n                }\n\n\n            }\n       }\n       //Restart\n       else if(stg.z == 0.0)\n       {\n           if( E )\n           {\n               //game Stage\n               stg.z = 1.0;\n               //coins\n               cl.x = 0.;\n               //lives\n               cl.y = 9.;\n           }\n       }\n\n        \n        saveValue( position,    vec4(pos),      fragColor,    ifragCoord );\n        saveValue( jump,        vec4(_jump),    fragColor,    ifragCoord );\n        saveValue( direction,   vec4(dir),      fragColor,    ifragCoord );\n        saveValue( coinsY,      vec4(coinY),    fragColor,    ifragCoord );\n        saveValue( coinsX,      vec4(coinX),    fragColor,    ifragCoord );\n        saveValue( badCatPos,   vec4(bCatPos),  fragColor,    ifragCoord );\n        saveValue( sbadCatPos,  vec4(sbCatPos), fragColor,    ifragCoord );\n        saveValue( CL,          vec4(cl),       fragColor,    ifragCoord );\n        saveValue( catColor,    vec4(ccr),      fragColor,    ifragCoord );\n        saveValue( stage,       vec4(stg),      fragColor,    ifragCoord );\n        \n        \n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define _speed 21.0\n#define cellAmount 6.0\n\nvec4 cat(vec2 uv)\n{\n    vec2 pos = fetchData(iChannel1, position).rg;\n    vec2 _jump = fetchData(iChannel1, jump).rg;\n    \n    \n    float cSpeed = 0.01 + (pos.x + _jump.y) * 10.0;\n    \n    uv.x = uv.x * 40.0 / 256.0;\n    float cellPercentage = 1.0 / cellAmount;\n    float frame = floor( mod( cSpeed, cellAmount ) );\n    uv.x += frame * 40. / 256.;\n    \n    return texture( iChannel0, uv ).rgba;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = fetchData(iChannel1, catColor).rgb;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 _cat = cat( uv );    \n    _cat.rgb  = _cat.rgb == vec3(0.6) ? color : _cat.rgb;\n    fragColor = vec4( _cat.rgb * _cat.w, _cat.w );\n}", "buffer_b_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//thx: iq, Bl00dhound, xrx, FabriceNeyret2 for examples and more\n\n//STORE ADDRESS\nconst ivec2 position   = ivec2(21.0, 1.0);\nconst ivec2 jump       = ivec2(21.0, 2.0);\nconst ivec2 direction  = ivec2(21.0, 3.0);\nconst ivec2 coinsY     = ivec2(69.,21.);\nconst ivec2 coinsX     = ivec2(69.,22.);\nconst ivec2 catPos     = ivec2(69.,23.);\nconst ivec2 badCatPos  = ivec2(69., 29.);\nconst ivec2 sbadCatPos = ivec2(69., 30.);\nconst ivec2 CL         = ivec2(69., 31.);\nconst ivec2 catColor   = ivec2(69.,32.);\nconst ivec2 stage      = ivec2(69.,33.);\n\nconst int KEY_SPACE  = 32;\nconst int KEY_LEFT   = 37;\nconst int KEY_UP     = 38;\nconst int KEY_RIGHT  = 39;\nconst int KEY_DOWN   = 40;\nconst int KEY_ENTER  = 13;\n\nfloat circleA(vec2 uv, vec2 pos, float size)\n{\n    float c = length(uv - pos);\n    c = step(size,c);\n    return 1. - c;\n}\n\n//1D random\nfloat random (vec2 xy, float t) \n{\n    return fract( sin( (xy.x * xy.y + t) * 1534345.1234645) );\n}\n\n//DATA\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n\n//PROPS\n#define radius 0.05\n#define jumpheight 0.1\n#define speed  0.05\n#define border vec2(-1.48+radius,1.0 - radius)\n\n//TEXT STUFF\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n\n//FOR Z MOVEMENT\n    //float U = texelFetch(iChannel1, ivec2(KEY_UP,    0.),0).x  > 0.?  1.0 : 0.0;\n    //float D = texelFetch(iChannel1, ivec2(KEY_DOWN,  0.),0).x  > 0.? -1.0 : 0.0;", "buffer_c_code": "int[] textScore = int[] (_0,_0,_0);\nint[] textStage = int[] (83,84,65, 71, 69, 32, 1);\nint[] textOver = int[] (71,65,77, 69, 32, 79, 86,69,82);\n\nint[] textRestart = int[] (80, 82, 69, 83, 83, 32, \n                            69, 78, 84, 69, 82, 32,\n                                84, 79, 32,\n                            83, 84, 65, 82, 84);\n\nint tSize = 3;\nint tStageSize = 7;\nint tOver = 9;\nint tRestart = 20;\n\nvec4 char(vec2 p, int c) \n{\n  if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n  return textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nfloat prc(float a, float b)\n{\n    return  a - (b * floor(a/b));\n}\n\n//Background\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fetchData(iChannel0, position).rg;\n    vec3 _jump = fetchData(iChannel0, jump).rgb;\n    vec2 cl = fetchData(iChannel0, CL).xy;\n    vec4 stg = fetchData(iChannel0, stage);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 _uv = fragCoord/iResolution.y;\n    vec2 uvs = uv;\n    float xvalue = uv.x + pos.x / 77.; \n    vec2 uvCells = ceil((vec2(xvalue,uv.y))  * vec2(25.,25.));\n    vec2 uvStars = uv;\n    vec2 uvFloor = uv;\n    vec3 gradient = mix( vec3(1.3,0.2,0.9) / 7., vec3(0.6,0.2,1.0) * 0.001, uv.y);\n    \n    //stage up\n    textStage[6] += int(stg.x);\n    \n    //aprox score\n    float n1 = prc(cl.x, 10.);\n    float n2 = prc(cl.x / 10., 10.);\n    float n3 = cl.x / 100.;\n    \n    textScore[0] += int(n3);\n    textScore[1] += int(n2);\n    textScore[2] += int(n1);\n    //aprox end------------\n    \n    uv.x += pos.x / 9.0;\n    \n    uvStars.x += pos.x / 190.0;\n    \n    uvFloor.x = uvFloor.x * 0.01 * ( (uvFloor.y * 90.3 + 0.9) ) ;\n    uvFloor.x += pos.x / 96.0;\n    _uv.x += pos.x / 96.0;\n    uvs.x += pos.x / 96. ;\n    \n    //houses\n    vec2 houses = uvCells *  sin(uvCells + cos(uvCells));\n    houses.y = clamp(houses.y, 0.0, 1.0);\n                \n    float house = clamp(houses.x  * step( 0.19, uvFloor.y ) * step(0.3, 1.0 - uvFloor.y), 0.0, 1.0) ;\n        \n    vec4 stars = pow(texture(iChannel1, uvStars * vec2(1.2, 1.5) + iTime * 0.001), vec4(7.5));\n    \n    vec2 cellsTex = pow(   uvCells / 44.  , vec2(12.0 )) * 3.0;\n    \n    float circle = 1. - smoothstep( 0.15, 0.21, length( _uv * 1.5 - vec2(1.7, 1.1 ) ));\n    \n    //Windows\n    float windowsmask = texture(iChannel3, ceil((uvs + vec2(0.1,0.0))  * 40.) / 40. ).r;\n    vec3 windows = windowsmask > 0.5 ?  vec3(windowsmask) : vec3(0.0) ; //nice random //0.1 + 0.8 * cos(123123.1312 + uvW.xyx * uvW.x * uvW.yyy + vec3(1.,2.,3.) );\n    \n    //floor\n    vec3 _floor = vec3(0.8, 0.9, 1.0) * clamp(1. - step( 0.19, uvFloor.y ),0.0,1.0);\n    vec4 stones = texture(iChannel2, uvFloor * 2.1 + vec2(0.05,0.0) );\n    \n    //application\n    vec3 color = mix(gradient, gradient + _floor * stones.b / 2.0, _floor);\n    color = mix(color, vec3(0.6,0.2,1.0) * 0.03 * house + cellsTex.r * vec3(1.0,0.8,0.0), house);\n    color += vec3(0.6,0.9,1.1) * (stars.r * stars.b * 5.) * clamp(uv.y - 0.1 ,0.0,1.0) * (1. - house);\n    color = mix(color, circle * vec3(1.19,0.9,1.3), clamp(circle - house ,0. ,1.));\n    color += (vec3(1.0,0.5,0.0) * 1.5 * windows.r * house) * clamp(uv.y - 0.1 ,0.0,1.0);\n    \n    //TEXT SCORE BLOCK-------------------------------------\n    vec4 tcolor = vec4(0.0);\n    vec2 _UV = fragCoord / iResolution.y;\n    vec2 position = vec2(.5);\n    \n    \n    \n    float FontSize;// = 3.;\n    float strSz;//= ((float(tSize)*1.0)/FontSize);\n    vec2 uv_;//( _UV - position)*64.0/FontSize;\n    \n    \n    if(stg.z == 1.0)\n    {\n        if(stg.y > 0.0)\n        {\n            //STAGE TEXT\n            FontSize = 14.;\n            strSz = ((float(tStageSize)*1.0)/FontSize);\n            position = vec2(0.35, 0.4);\n            uv_ = ( _UV - position)*64.0/FontSize;\n\n            for (int i=0; i<tStageSize; i++) \n            {\n                int tx = textStage[i];\n                uv_.x -=.5;\n                uv_.y += sin(float(i) * 5.5 - iTime * 7.5) * 0.15;\n                vec4 tc = char(uv_.xy,tx);\n                tcolor += tc * stg.y;\n            }\n        }\n        \n        //SCORE POS IN GAME\n        position = vec2(.5);\n        position.x = 0.03;\n        position.y -= -0.397;\n        FontSize = 3.;\n        strSz = ((float(tSize)*1.0)/FontSize);\n        uv_ = ( _UV - position)*64.0/FontSize;\n    }\n    else if( stg.z == 0.0)\n    {\n        //GAME OVER\n        FontSize = 14.;\n        strSz = ((float(tStageSize)*1.0)/FontSize);\n        position = vec2(0.2, 0.4);\n        uv_ = ( _UV - position)*64.0/FontSize;\n        \n        for (int i=0; i<tOver; i++) \n        {\n            int tx = textOver[i];\n            uv_.x -=.5;\n            uv_.y += sin(float(i) * 2.5 - iTime * 7.5) * 0.15;\n            vec4 tc = char(uv_.xy,tx);\n            color = vec3(0.0,0.0,0.0);\n            tcolor += tc * stg.y;\n        }\n        //PRESS SPACE TO START\n        FontSize = 7.;\n        strSz = ((float(tStageSize)*1.0)/FontSize);\n        position = vec2(0.23, 0.2);\n        uv_ = ( _UV - position)*64.0/FontSize;\n        \n        for (int i=0; i<tRestart; i++) \n        {\n            int tx = textRestart[i];\n            uv_.x -=.5;\n            vec4 tc = char(uv_.xy,tx);\n            color = vec3(0.0,0.0,0.0);\n            tcolor += tc * stg.y;\n        }\n        \n        FontSize = 14.;\n        position = vec2(0.5);\n        position += vec2(.2, .2);\n        strSz = ((float(tSize)*1.0)/FontSize);\n        uv_ = ( _UV - position)*64.0/FontSize;\n    }\n    \n    //SCORE COMBINE\n    \n    for (int i=0; i<tSize; i++) \n    {\n        int tx = textScore[i];\n        uv_.x -=.5; \n        tcolor += char(uv_.xy,tx);\n    }\n    \n    \n    \n    //add all text to background\n    color += tcolor.r;\n    //TEXTS SCORE BLOCK--------------------------------------\n    fragColor = vec4( vec3( color ), 1.0 ) ;\n}", "buffer_c_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//MOONCATCOIN\nfloat circle(vec2 uv, vec2 pos, float b)\n{\n    uv.y *= 0.93;\n    return step(b, 1. - length(uv  - pos));\n}\n\nfloat circleS(vec2 uv, vec2 pos)\n{\n    float c = circle(uv,pos, 0.89);\n    float s = step(.88, 1. - length(uv - pos));\n    return s - c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mainUv = fragCoord / iResolution.xy;\n    vec4 coinY = fetchData(iChannel1, coinsY);\n    \n    vec2 uv = fragCoord / iResolution.x;\n    float spc = clamp(sin((mainUv.x * (mainUv.y * 25.)) + iTime * 5.5),0.0,1.0);\n    float ci1 = circle(uv, vec2(0.5,0.25), 0.9);\n    float ci2 = circleS(uv, vec2(0.5,0.25));\n    vec3 c = vec3(0.7,0.5,0.8) * ci1;\n    vec3 cc = vec3(0.7,0.5,0.8) * ci2 - circle(uv, vec2(0.5,0.25),0.9);\n    mainUv *= vec2(2.1,2.1);\n    vec4 cat = texture(iChannel0,vec2(mainUv.x/6.0 - 0.07, mainUv.y - 0.44));\n    \n    float pxMask = 0.0;\n    if(cat.rgb == vec3(0.0) && cat.w > 0.0)\n        pxMask = 1.0;\n    else\n        pxMask = 0.0;\n    \n    \n    vec3 catcoin = c * (cat.r * 1.5) + clamp(cc,0.,1.) + vec3(0.21,0.21,0.21) * pxMask * ci1 ;\n    \n    float mask = clamp(pow((catcoin.r + catcoin.g + catcoin.b ) * 25. /3., 25.),0.0,1.0);\n    \n    fragColor = vec4(catcoin + catcoin * (vec3(1.0,0.0,2.0) * spc * 0.7) + (vec3(0.0,2.0,1.0) * spc * 0.05), mask);\n}", "buffer_d_inputs": [{"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 187, 187, 268], [270, 270, 318, 318, 499], [501, 501, 558, 558, 4216]], "test": "untested"}
{"id": "sl3BRM", "name": "Fractal mosaic 14", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 17, "viewed": 363, "published": 3, "date": "1662790176", "time_retrieved": "2024-07-30T16:31:45.159382", "image_code": "#define fmod(x,y) mod(floor(x),y)\n\nvec2 f1(vec2 a){\n    return\n        fract(a)\n        //fract(a-floor(a.y)/2.)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    \n\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        //vec2(-2.,.5+mod(floor(a.x),2.))\n\n        \n        //vec2(1.5,0.)\n        //vec2(2.5,-1.)\n        //vec2(1.25,1.75)\n        //vec2(abs(mod(a.x-.5,2.)-1.),abs(mod(a.y-.5,2.)-1.))\n    ,\n    \n    a1 =\n        a+a2\n        //a+a2+floor(a.x)\n        //a+a2+floor(a.y)\n    ;\n    //a1 += (distance(floor(a1),round(a1)))/1.5;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n        //abs(fract(a)-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 16.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.x += iTime/t1/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 12; k++){\n        //uv += floor(uv+vec2(1.,.5))/1.5;\n        //bool c1 = t2.x < uv.x;\n        uv =\n            (uv+t2)/scale\n            //max(abs(.5+uv+t2),abs(-.5+uv+t2))/scale\n        ;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n        //uv += (distance(floor(uv),round(uv+.5)));\n        //uv += floor(uv);\n        \n        //uv = uv.yx;\n        t2 =\n            triangle_wave(uv+.5)\n            //triangle_wave(uv+.5+floor(uv.y+.5))\n        ;\n        uv =\n            t2-triangle_wave(uv.yx)\n            \n            //this pattern is amazing!\n            //t2-triangle_wave(uv.yx+floor(uv.y-uv.x))\n            \n            //t2-triangle_wave(uv.yx)-fract(t2/2.)\n            \n            //t2*length(uv)-triangle_wave(uv.yx)\n        ;\n        \n        //uv.x += sign(uv.y-uv.x)-.5;\n\n        //uv.x -= max(uv.y,-uv.x)/2.;\n\n        \n        col.x = max(max(max(t2.y,t2.x),abs(uv.y-uv.x))/3.,col.x);\n        col =\n            abs(col-(1.-col.x));\n            //abs(col*col-(1.-col.x));\n            //abs(col-(1.-col.x*col.x));\n        //if(c1) col = abs(abs(col.yzx-1.)-col);\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod2(float a, float b){\n    return mod(floor(a),b)*b;\n}\n\nfloat fmod1(float a, float b){\n    //a += fmod2(a,2.);\n    for(float i = 1.; i < mod(floor(a/b),5.); i++){\n        a += mod(floor(a/2.),b)*i;\n        a *= 1.+mod(floor(a)*2.,2.);\n        i /= 1.+mod(floor(a)*2.,2.);\n    }\n    float a1 = a;\n    return\n        mod(floor(a),b)\n        //mod(floor(floor(floor(a)*b)/3.),b)\n        //abs(2.-mod(floor(a+2.),b*2.))\n        //mod(mod(floor(a/2.),b+4.),b)\n        //mod(mod(floor(a+4.),floor(a/8.+4.)),b)\n        //mod(floor(a*sign(.5-mod(floor(a*4./b),2.))),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //mod(fmod1(a/2.,b)*fmod1(a,b*4.),8.)\n    ;\n}\n\n\nvec2 mainSound(int samp, float time){\n  float tempo = .5;\n  \n  float s1 =\n      8.;\n  for(float i = 1.; i < mod(floor(time),5.); i++){\n      time += mod(floor(time/2.),s1)*i;\n      tempo *= 1.+fmod(floor(time)*2.,2.);\n      time /= 1.+fmod(floor(time/tempo)*2.,2.);\n  }\n  time /= tempo;\n  float s2 = 8.,\n  t=\n      time,\n  m1 =\n      fmod(t,s2)\n  ,\n  m3 =\n      fmod(t,1.+m1)+fmod(t/8.,2.);\n  /*\n  for(int i = 0; i < 2; i++){\n      t += mod(floor(t*4.),2.);\n  }\n  */\n  t /=\n      (1.+fmod(t/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  float a=\n      64.*(1.-sqrt(fract(t/s1)/1.25))*.2\n  ,\n  nb = time*tempo*pow(2.,floor((m3+m2)/2.)/5.+6.5);\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3BRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 51, 51, 120], [122, 122, 149, 149, 779], [781, 781, 838, 838, 2258]], "test": "untested"}
{"id": "flcBz7", "name": "Fractal mosaic 13", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 12, "viewed": 436, "published": 3, "date": "1662784952", "time_retrieved": "2024-07-30T16:31:45.978192", "image_code": "#define fmod(x,y) mod(floor(x),y)\n\nvec2 f1(vec2 a){\n    return\n        fract(a)\n        //fract(a-floor(a.y*2.)/2.)\n    ;\n}\n\n\n\nvec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,.5)\n        //vec2(1.5,0.)\n        //vec2(0.,2.)\n    ,\n    \n    a1 = a+a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    //a1 += (distance(floor(a1),round(a1)))/1.5;\n\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n        //abs(abs(f1((a1)*(a2.x+a2.y))-.5)+.125)/1.125\n    ;\n}\n\nconst float scale = 1.5;\n\nvoid transform(inout vec2 uv, inout vec2 t2){\n        uv = (uv+t2)/scale;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n        //uv += (distance(floor(uv),round(uv+.5)));\n\n        //uv *= sign(uv1-uv1.yx);\n        //uv *= sign(uv-uv.yx);\n        \n        //if(uv.y>uv.x) uv = uv.yx;\n        t2 =\n            triangle_wave(uv+.5)\n            //triangle_wave(uv+.5*sign(uv.x-.5))\n            //triangle_wave(uv+.5)*sign(.5-uv.x)\n        ;\n        \n        //uv += floor(uv.y-uv.x);\n        uv = t2-triangle_wave(uv.yx);\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 16.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.x += iTime/t1/12.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    \n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 12; k++){\n        //uv += pow(floor(uv.x*2.),3.)/2.;\n\n        const float warp_scale = 16.;\n\n        //uv.x -= floor(uv.y*1.5)/1.5;\n        //uv += floor(uv+vec2(1.,.5))/1.5;\n        \n        //if(uv.x>uv.y)\n        \n        vec2 warp =\n            vec2(0)\n            //vec2(sin((t2.x)*warp_scale),cos((t2.y)*warp_scale))\n            //vec2(sin((uv.x)*warp_scale),cos((uv.y)*warp_scale))\n        ;\n        warp = warp*warp/warp_scale;\n        \n        vec2 uv_1 = uv+warp;\n        vec2 t2_1 = t2+warp;\n        \n        transform(uv,t2);\n        transform(uv_1,t2_1);\n        \n        //uv.x += sign(uv.y-uv.x-.5)+.5;\n        \n        //another really interesting pattern\n        //uv.x +=\n            //floor(uv1.x)/1.5\n            //.5\n        //;\n        \n        //uv += dot(uv,uv); //makes another interesting pattern\n        col.x =\n            max(max(abs(t2_1.y-t2_1.x),abs(uv_1.y-uv_1.x))/3.,col.x)\n            //max(abs(uv.y+uv.x*sign(t2.y-t2.x))/3.,col.x)\n            //max(max(fract(t2.y-t2.x+.5),fract(uv.y-uv.x+.5))/3.,col.x)\n            //max(max(abs(t2.y-t2.x),abs(uv.y*sign(uv.x)-uv.x))/3.,col.x)\n        ;\n        col =\n            abs(col-(1.-col.x));\n            max(abs(col-(1.-col.x)),col/4.);\n            \n            //abs(col*col.yzx-(1.-col.x));\n        //{uv=uv.yx;t2=t2.yx;}\n        //if(uv.x>uv.y) uv.y += .5;\n\n        //if(t2.y>t2.x) t2.y *= .5;\n        //else uv.y *= 1.5;\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod2(float a, float b){\n    return mod(floor(a/b),b)*b;\n}\n\nfloat mod1(float a, float b){\n    return\n        mod(a,b)\n        //mod(a+floor(a/8./8.),b)\n        //mod(a-mod(a,3.-mod(a,2.)),b)\n    ;\n}\n\nfloat fmod1(float a, float b){\n    //a += fmod2(a/4.,4.);\n    for(float i = 1.; i < 8.; i++){\n        //a += floor(pow(2.,b));\n        if(i < mod(floor(a),8.))\n        a +=\n            mod1(floor(a/2.),b)*i\n            //floor(mod(floor(a)/2.,b)*i)\n        ;\n        \n        //a += mod(floor(a/2.),b)*i;\n    }\n    /*\n    for(int i = 0; i < 3; i++){\n        a += floor(a/64.)*4.;\n    }\n    */\n    return\n        mod1(floor(a),b)\n        //mod1(floor(a+floor(a/8./8.)),b)\n        //mod(mod(floor(a)+4.,floor(a/4.)+4.),b)\n        //mod(floor(a+floor(a/b/8.)),b)\n        //mod(floor(a)/b*8.,b)\n        //mod(floor(a/b+b*2.)*floor(a),b)\n        //mod(floor(a*sign(.5-mod(floor(a/b/16.),2.))),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //fmod1(a/2.+fmod1(a,b*b),b/2.)*fmod1(a,b/2.)\n        //fmod1(a+fmod1(a/8.,8.*8.*b),b)\n    ;\n}\n\n\nvec2 mainSound1(int samp, float time,float scale){\n  float tempo = 1.;\n  time /= tempo;\n  float s1 =\n      8.;\n  float s2 = 8.,\n  t=\n      time*2.\n  ,\n  m1 =\n      fmod(t*4.,s2)\n  ,\n  m3 =\n      (fmod(m1,abs(s2*2.-m1)+1.)-m1),\n  m4= (1.+fmod(t/s1,2.))\n  ;\n  //t /= (1.+fmod((t/s1+floor(t/s1/s1))/2.,2.));\n  t *=\n      m4\n  ;\n  //t += m3;\n  float m2 =\n      1. + fmod(t,s1)\n  ;\n  float a=\n      //64.*(1.-sqrt(fract(t)/1.25))*.2\n      //(1.-log(fract(t)))*(1.-log(fract(t)))\n      (1.-log(fract(t)/2.))*(1.-log(fract(t/2.)))\n      //(1.-log(fract(t)))*(2.-log(fract(t*2.)))\n      //(1.-log(fract(t)))*(2.-log(fract(t/8.)))\n      //8.*(2.-sqrt(fract(t)))\n      //16.*(1.-log(fract(t)))\n  ,\n  nb = time*tempo*pow(2.,floor((m3+m2)/2.)/5.+scale);\n  return\n      abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //voice synth?\n      //log(abs(a/32.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))/2.\n      \n      //abs(1.+log(abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))/2.\n  ;\n}\n\nvec2 mainSound(int a,float b){\n    return mainSound1(a,b,6.5);\n    //return (mainSound1(a,b,7.5)+mainSound1(a*2,b*2.,7.5))/4.;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcBz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 51, 51, 123], [127, 127, 154, 154, 517], [545, 545, 590, 590, 1089], [1091, 1091, 1148, 1148, 2858]], "test": "untested"}
{"id": "ftcBRM", "name": "Lambmeow Sine Squares", "author": "lambmeow", "description": "made another cool accident ", "tags": ["sine", "squares", "lambmeow"], "likes": 4, "viewed": 189, "published": 3, "date": "1662766726", "time_retrieved": "2024-07-30T16:31:46.845873", "image_code": "void mainImage(out vec4 c, in vec2 f)\n{\n    vec2 r = iResolution.xy, u = (2. * f - r)/r.y;\n    float ss = 10.;\n    float time = 1.;\n\n    c = vec4(0.,0.1,.1,1);\n    for(int i = 0; i < 20; i++)\n    {\n        vec2 flu = floor(u * ss);\n        vec3 color = (1. - vec3(cos(flu.x/ss + iTime + float(i)), 1. - abs(sin(flu.x/ss + iTime + float(i))), 0)); \n        c.rgb += color.rgb * step(abs(u.y), abs(cos(flu.x/ss + iTime * time) + sin(iTime + flu.x/ss) *0.25));\n        time *= .88;\n    }\n    c /= 20.;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcBRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 505]], "test": "untested"}
{"id": "Nl3BRM", "name": "Blackbody flows", "author": "fishy", "description": "perlin noise + color mapping. Blackbody function (from @FabricNeyret) this time", "tags": ["noise", "fbm", "wallpaper"], "likes": 7, "viewed": 275, "published": 3, "date": "1662766576", "time_retrieved": "2024-07-30T16:31:47.621798", "image_code": "#define gamma 10.0\n\nfloat intensity(vec2 p)\n{\n    return float(distance(p, vec2(0.0)) < 1.0);\n}\n\nvec3 blur(sampler2D tex, float size, int res, vec2 uv, float ratio)\n{\n    float div = 0.0;\n    vec3 accumulate = vec3(0.0);\n    \n    for(int iy = 0; iy < res; iy++)\n    {\n        float y = (float(iy) / float(res))*2.0 - 1.0;\n        for(int ix = 0; ix < res; ix++)\n        {\n            float x = (float(ix) / float(res))*2.0 - 1.0;\n            vec2 p = vec2(x, y);\n            float i = intensity(p);\n            \n            div += i;\n            accumulate += pow(texture(tex, uv+p*size*vec2(1.0, ratio)).xyz, vec3(gamma)) * i;\n        }\n    }\n    \n    return pow(accumulate / vec3(div), vec3(1.0 / gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    fragColor = vec4(blur(iChannel0, (uv.y - 0.5)*0.03, 10, uv, iResolution.x/iResolution.y), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\n\nvec2 hash(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat perlinNoise(vec2 p, float s)\n{\n    vec2 tlVal = hash(vec2(floor(p.x),  ceil(p.y)));\n    vec2 blVal = hash(vec2(floor(p.x), floor(p.y)));\n    vec2 trVal = hash(vec2( ceil(p.x),  ceil(p.y)));\n    vec2 brVal = hash(vec2( ceil(p.x), floor(p.y)));\n    \n    vec2 tlOffset = p - vec2(floor(p.x),  ceil(p.y));\n    vec2 blOffset = p - vec2(floor(p.x), floor(p.y));\n    vec2 trOffset = p - vec2( ceil(p.x),  ceil(p.y));\n    vec2 brOffset = p - vec2( ceil(p.x), floor(p.y));\n    \n    float tl = dot(tlOffset, tlVal);\n    float bl = dot(blOffset, blVal);\n    float tr = dot(trOffset, trVal);\n    float br = dot(brOffset, brVal);\n    \n    float a = mix(bl, tl, erp(fract(p.y), s));\n    float b = mix(br, tr, erp(fract(p.y), s));\n    \n    return mix(a, b, erp(fract(p.x), s)) / 2.0 + 0.5;\n}\n\n\n\nfloat fbm(in vec2 x, float s, in float H)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        t += a*perlinNoise(f*x, s);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nvec4 blackbody(float x, float intensity) //By @FabriceNeyret2 (modified by me) https://www.shadertoy.com/view/4tdGWM\n{\n    vec4 O = vec4(0.0);\n    float m = .01+5.*intensity,\n        T = x*16000.; // absolute temperature (K)\n    \n    O -= O;\n    \n/*  // --- with physical units: (but math conditionning can be an issue)\n    float h = 6.6e-34, k=1.4e-23, c=3e8; // Planck, Boltzmann, light speed  constants\n\n    for (float i=0.; i<3.; i++) {  // +=.1 if you want to better sample the spectrum.\n        float f = 4e14 * (1.+.5*i); \n        O[int(i)] += 1e7/m* 2.*(h*f*f*f)/(c*c) / (exp((h*f)/(k*T)) - 1.);  // Planck law\n    }\n*/\n    // --- with normalized units:  f = 1 (red) to 2 (violet). \n    // const 19E3 also disappears if you normalized temperatures with 1 = 19000 K\n     for (float i=0.; i<3.; i += .05) {  // +=.1 if you want to better sample the spectrum.\n        float f = 1.+.5*i; \n        O[int(i)] += 10./m* (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}", "buffer_a_code": "vec3 colorMap(float value)\n{\n    return blackbody(value * 0.5+ 0.1, 1.0).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    uv *= 0.2;\n\n    uv.x += fbm((uv + iTime*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 10000.0, 1.0, 1.0);\n    uv.x += fbm((uv + iTime*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 10000.0, 1.0, 1.0);\n    uv.x += fbm((uv + iTime*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 1000.0,  1.0, 1.0);\n    uv.x += fbm((uv + iTime*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 1000.0,  1.0, 1.0)*5.0;\n\n    float value = erp(fbm(uv * 20.0, 1.0, 1.0)/2.1, 7.0);\n\n    fragColor = vec4(colorMap(value),1.0);\n    //fragColor = colors[1].xyzx;\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3BRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 95], [711, 711, 768, 818, 1004]], "test": "untested"}
{"id": "fl3BRM", "name": "Ice flows", "author": "fishy", "description": "perlin noise + color mapping. Different color scheme this time.", "tags": ["noise", "fbm", "wallpaper"], "likes": 16, "viewed": 339, "published": 3, "date": "1662766167", "time_retrieved": "2024-07-30T16:31:48.408694", "image_code": "#define gamma 10.0\n\nfloat intensity(vec2 p)\n{\n    return float(distance(p, vec2(0.0)) < 1.0);\n}\n\nvec3 blur(sampler2D tex, float size, int res, vec2 uv, float ratio)\n{\n    float div = 0.0;\n    vec3 accumulate = vec3(0.0);\n    \n    for(int iy = 0; iy < res; iy++)\n    {\n        float y = (float(iy) / float(res))*2.0 - 1.0;\n        for(int ix = 0; ix < res; ix++)\n        {\n            float x = (float(ix) / float(res))*2.0 - 1.0;\n            vec2 p = vec2(x, y);\n            float i = intensity(p);\n            \n            div += i;\n            accumulate += pow(texture(tex, uv+p*size*vec2(1.0, ratio)).xyz, vec3(gamma)) * i;\n        }\n    }\n    \n    return pow(accumulate / vec3(div), vec3(1.0 / gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    fragColor = vec4(blur(iChannel0, (uv.y - 0.5)*0.03, 10, uv, iResolution.x/iResolution.y), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\n\nvec2 hash(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat perlinNoise(vec2 p, float s)\n{\n    vec2 tlVal = hash(vec2(floor(p.x),  ceil(p.y)));\n    vec2 blVal = hash(vec2(floor(p.x), floor(p.y)));\n    vec2 trVal = hash(vec2( ceil(p.x),  ceil(p.y)));\n    vec2 brVal = hash(vec2( ceil(p.x), floor(p.y)));\n    \n    vec2 tlOffset = p - vec2(floor(p.x),  ceil(p.y));\n    vec2 blOffset = p - vec2(floor(p.x), floor(p.y));\n    vec2 trOffset = p - vec2( ceil(p.x),  ceil(p.y));\n    vec2 brOffset = p - vec2( ceil(p.x), floor(p.y));\n    \n    float tl = dot(tlOffset, tlVal);\n    float bl = dot(blOffset, blVal);\n    float tr = dot(trOffset, trVal);\n    float br = dot(brOffset, brVal);\n    \n    float a = mix(bl, tl, erp(fract(p.y), s));\n    float b = mix(br, tr, erp(fract(p.y), s));\n    \n    return mix(a, b, erp(fract(p.x), s)) / 2.0 + 0.5;\n}\n\n\n\nfloat fbm(in vec2 x, float s, in float H)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        t += a*perlinNoise(f*x, s);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}", "buffer_a_code": "ivec3[] colors = ivec3[] (ivec3(39, 55, 71), ivec3(0, 49, 98), ivec3(0, 97, 195), ivec3(0, 211, 255), ivec3(230, 255, 230));\n\nvec3 colorMap(float value)\n{\n    int colorCount = colors.length();\n    \n    float v = value * float(colorCount);\n    \n    int a = int(floor(v));\n    int b = a + 1;\n    \n    float fac = fract(v);\n    return mix(vec3(colors[a])*0.00392156862745, vec3(colors[b])*0.00392156862745, vec3(fac));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    uv *= 0.2;\n\n    uv.x += fbm((uv + iTime*0.01) * 1.0,        1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 10.0, 1.0, 1.0);\n    uv.x += fbm((uv + iTime*0.01) * 1.0,        1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 10.0, 1.0, 1.0);\n    uv.x += fbm((uv + iTime*0.01) * 1.0,        1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 1.0,  1.0, 1.0);\n    uv.x += fbm((uv + iTime*0.01) * 1.0,        1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 1.0,  1.0, 1.0)*5.0;\n\n    float value = erp(fbm(uv * 20.0, 1.0, 1.0)/2.1, 6.0);\n\n    fragColor = vec4(colorMap(value),1.0);\n    //fragColor = colors[1].xyzx;\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3BRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 95], [711, 711, 768, 818, 1004]], "test": "untested"}
{"id": "st3fRN", "name": "motion=depth illusion 2", "author": "FabriceNeyret2", "description": "multilayer variant of  [url] https://shadertoy.com/view/ftdcWX [/url].\nStrangely, the illusion ( perception of depth with parallax ) does not expend so clearly.\nUncomment for B&W or gfrey variants.", "tags": ["illusion", "2tweets", "perception", "short", "golf", "reproduction"], "likes": 12, "viewed": 279, "published": 3, "date": "1662732830", "time_retrieved": "2024-07-30T16:31:49.557623", "image_code": "// variant of https://shadertoy.com/view/ftdcWX\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n    float i = floor( textureLod(iChannel0, U/vec2(6,1) , 2. ).a * 3.99  ); // mask source\n    if ( mod(iTime/4.,2.) > 1. ) i = 3.-i;               // color order \n    O = sqrt( vec4(i/3.,1.-i/3.,0,0) );                  // color ( sqrt for sRGB conversion )\n // O = vec4(1);                                         // B&W variant\n // O = vec4(sqrt(1.+i)/2.);                             // grey variant\n    if ( mod(iTime/8.,2.) > 1. ) i = 3.-i;               // motion order\n    O *= texture(iChannel1, U + .1*iTime*vec2(i,0) ).r;  // morion\n}", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st3fRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 657]], "test": "untested"}
{"id": "stcBR4", "name": "Messy Spiral 95710", "author": "SnoopethDuckDuck", "description": "e", "tags": ["e"], "likes": 26, "viewed": 340, "published": 3, "date": "1662724827", "time_retrieved": "2024-07-30T16:31:50.374438", "image_code": "#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\nfloat getS(vec2 uv) {\n    float r = 0.8 * log(length(uv));\n    float a = atan(uv.x, uv.y);\n    \n    float k = 4.;//100. * exp(-iTime);\n    float s = 0.5 + 0.5 * thc(30., \n    3. * a + cos(3. * a - 3. * r + iTime) * 0.5 * pi * cos(1. * a \n    + (k-1.) * r - iTime) + k * 3. * r -  iTime);\n    return s;\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  \n    float a = atan(uv.x, uv.y);\n    float r = length(uv);\n    float s = getS(uv);\n    float v = 8. * a + iTime;\n    float s2 = getS(uv * 40. + 0.02 * vec2(cos(v), sin(v)));\n    float s3 = 0.5 * s + s2 * exp(-2. * r);\n    \n    vec3 col = vec3(0.5 * s + s2 * exp(-2. * r));\n    col = pal(s3 * 1.5, vec3(1,0.25,0)/3.);\n    col += 1.2/ cosh((7.5 + 2.5 * thc(4., s3 * pi * 0.5 + 8. * r - 1.5 * iTime)) * r);\n    col *= exp(-0.5 * r);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcBR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 81, 81, 363], [365, 365, 384, 384, 459], [461, 461, 494, 494, 549], [551, 551, 608, 608, 1139]], "test": "untested"}
{"id": "7ttfzH", "name": "Fractal mosaic 12 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 5, "viewed": 324, "published": 3, "date": "1662689769", "time_retrieved": "2024-07-30T16:31:53.793297", "image_code": "#define fmod(x,y) mod(floor(x),y)\nvec2 triangle_wave(vec2 a){\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        //vec2(2.5,-1.)\n        //vec2(-2.,.5+mod(floor(a.x),2.))\n\n        \n        //vec2(1.5,0.)\n        \n        //vec2(1.,1.5)\n    ,\n    \n    a1 = a+a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    //a1 += (distance(floor(a1),round(a1)))*1.5;\n\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nvec3 image1(vec2 uv,float sign1){\n    float scale = 1.5;\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    bool t3 = false;\n    for(int k = 0; k < 12; k++){\n        //uv += float(t3);\n        //uv += floor(uv+vec2(1.,.5))/1.5;\n        t3 = uv.x*sign1 > uv.y*sign1 || !t3;\n        //t3 = uv.x > uv.y && !t3;\n        uv =\n            abs(-.5+uv+t2)/scale+float(!t3)/2.;\n            //fract(.5+uv+t2)/scale+float(!t3)/2.;\n        \n        //uv *= -1.;\n        //uv += (distance(floor(uv),round(uv+.5)));\n\n        //if(uv.y>uv.x) uv = uv.yx;\n        t2 = triangle_wave(uv+.5);\n        //t2 = abs(t2);\n        \n        //uv += floor(uv.y-uv.x);\n        \n        uv = t2-triangle_wave(uv.yx);\n        \n\n        //uv.x -= max(uv.y,-uv.x)/2.;\n        \n        //uv += dot(uv,uv)/4.; //makes another interesting pattern\n\n        //uv.x += sign(uv.y-uv.x)/2.;\n\n        float c1 =\n            uv.y-uv.x\n            //uv.y*sign(uv.x)-uv.x\n        ;\n        \n        //another really interesting pattern\n        //uv.x += .5;\n\n        \n\n        //c1 = max(c1,t2.x-t2.y);\n        col = vec3(c1,col.yz);\n        //col *= abs(col+.5);\n\n        //col = col.xzy;\n        if(t2.x < t2.y && t3) col = col.yzx;\n        \n        //if(t2.x > t2.y && !t3) col = col.zxy;\n        //if(t2.x*uv.x < t2.y*uv.y) col = col.yzx;\n        //if(t2.x-t2.y > uv.x-uv.y) col = col.yzx;\n        //if(uv.x>uv.y) {uv=-uv;t2=-t2;}\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 16.*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n        if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    \n    vec3 col =\n        image1(uv,1.);\n        //image1(uv,-1.);\n    fragColor = vec4(abs(col)*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "//#define fmod(x,y) mod(floor(x),y)\n#define fmod(x,y) mod(floor(x)+floor((x)/5./5.),y)\n#define fmod0(x,y) mod(floor(x)*4.-floor((x)/4.),y)\n#define fmod1(x,y) mod(floor(x)*(4.+mod(floor(x),4.))-floor((x)/(4.+mod(floor(x),4.))),y)\n#define fmod2(x,y) mod(floor(x)*(1.+mod(floor(x),4.))+floor((x)/4.),y)\n#define fmod3(x,y) mod(floor((x)/4.+pow(2.,mod(floor(x),4.))),y)\n#define fmod4(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n#define fmax(x,y) max(mod(floor(-(x)/2.),y),mod(floor(x),y))\n\n\nint gcd (int a, int b) {    // Euclid algorithm:   gcd(a,b) = gcd(b, a%b) ; gcd(a,0) = a\n    int c;             \n    while ( b>0 && (c = a%b) != a ) a=b, b=c; \n    return b==0 ? a : c;\n}\n\nfloat gcd(float a, float b){\n   return float(gcd(int(a),int(b)));\n}\n\nvec2 mainSound(int samp, float time){\n  \n  float tempo = 1.;\n  time /= tempo;\n  \n  //for(int i = 0; i < 5; i++){ time += fmod(floor(time*5.),2.); }\n  \n  float s1 = 5.,\n  \n  \n  \n  s2 = 7.,\n  t =\n      time\n      //time - fmod(time,5.+fmod(time*s1,7.))\n      //time/(1.+fmod(time,2.))\n  ,\n  m1 = fmod(t/s2,s2),\n  m4 = fmod(t/s1+m1,s2),\n  m3 = fmod((t+gcd(m1,m4))*(s1)/abs(s1/2.-gcd(m1,m4)),s2);\n  \n  t *= s1*s1;\n  //t /= (1.+fmod(time,2.))/(1.+fmod(time/2.,2.)); //varying tempo\n\n\n  float m2 = 1. + fmod(t/s1,s1);\n  \n  float a=\n      64.*((1.-sqrt(fract(t/s1)/1.25)))*.2\n      //sqrt((1.-sqrt(fract(t/s1))))*.2\n  ,\n  \n  nb = pow(2.,(m3+m2)/5.+7.)*tempo;\n\n  return abs(.5-vec2(fract(time*nb*.998)\n   ,fract(time*nb)))*a;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 61, 61, 528], [530, 530, 563, 563, 1946], [1948, 1948, 2005, 2005, 2329]], "test": "untested"}
{"id": "7ttfRH", "name": "Lava flows", "author": "fishy", "description": "perlin noise + color mapping.", "tags": ["noise", "fbm", "wallpaper"], "likes": 12, "viewed": 536, "published": 3, "date": "1662674769", "time_retrieved": "2024-07-30T16:31:54.823542", "image_code": "#define gamma 10.0\n\nfloat intensity(vec2 p)\n{\n    return float(distance(p, vec2(0.0)) < 1.0);\n}\n\nvec3 blur(sampler2D tex, float size, int res, vec2 uv, float ratio)\n{\n    float div = 0.0;\n    vec3 accumulate = vec3(0.0);\n    \n    for(int iy = 0; iy < res; iy++)\n    {\n        float y = (float(iy) / float(res))*2.0 - 1.0;\n        for(int ix = 0; ix < res; ix++)\n        {\n            float x = (float(ix) / float(res))*2.0 - 1.0;\n            vec2 p = vec2(x, y);\n            float i = intensity(p);\n            \n            div += i;\n            accumulate += pow(texture(tex, uv+p*size*vec2(1.0, ratio)).xyz, vec3(gamma)) * i;\n        }\n    }\n    \n    return pow(accumulate / vec3(div), vec3(1.0 / gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    fragColor = vec4(blur(iChannel0, (uv.y - 0.5)*0.03, 10, uv, iResolution.x/iResolution.y), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\n\nvec2 hash(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat perlinNoise(vec2 p, float s)\n{\n    vec2 tlVal = hash(vec2(floor(p.x),  ceil(p.y)));\n    vec2 blVal = hash(vec2(floor(p.x), floor(p.y)));\n    vec2 trVal = hash(vec2( ceil(p.x),  ceil(p.y)));\n    vec2 brVal = hash(vec2( ceil(p.x), floor(p.y)));\n    \n    vec2 tlOffset = p - vec2(floor(p.x),  ceil(p.y));\n    vec2 blOffset = p - vec2(floor(p.x), floor(p.y));\n    vec2 trOffset = p - vec2( ceil(p.x),  ceil(p.y));\n    vec2 brOffset = p - vec2( ceil(p.x), floor(p.y));\n    \n    float tl = dot(tlOffset, tlVal);\n    float bl = dot(blOffset, blVal);\n    float tr = dot(trOffset, trVal);\n    float br = dot(brOffset, brVal);\n    \n    float a = mix(bl, tl, erp(fract(p.y), s));\n    float b = mix(br, tr, erp(fract(p.y), s));\n    \n    return mix(a, b, erp(fract(p.x), s)) / 2.0 + 0.5;\n}\n\n\n\nfloat fbm(in vec2 x, float s, in float H)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        t += a*perlinNoise(f*x, s);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}", "buffer_a_code": "vec3[] colors = vec3[] (vec3(40.0,45.0,49.0), vec3(79.0,84.0,88.0), vec3(243.0,99.0,38.0), vec3(255.0,220.0,92.0), vec3(255.0,255.0,212.0));\n\nvec3 colorMap(float value)\n{\n    int colorCount = colors.length();\n    \n    float v = value * float(colorCount);\n    \n    int a = int(floor(v));\n    int b = a + 1;\n    \n    float fac = fract(v);\n    return mix(colors[a]*0.00392156862745, colors[b]*0.00392156862745, vec3(fac));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    uv *= 0.2;\n\n    uv.x += fbm((uv + iTime*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 10000.0, 1.0, 1.0);\n    uv.x += fbm((uv + iTime*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 10000.0, 1.0, 1.0);\n    uv.x += fbm((uv + iTime*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 1000.0,  1.0, 1.0);\n    uv.x += fbm((uv + iTime*0.01) * 1.0,           1.0, 1.0);\n    uv.y += fbm((uv + iTime*0.01) * 1.0 + 1000.0,  1.0, 1.0)*5.0;\n\n    float value = erp(fbm(uv * 20.0, 1.0, 1.0)/2.1, 10.0);\n\n    fragColor = vec4(colorMap(value),1.0);\n    //fragColor = colors[1].xyzx;\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ttfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 95], [711, 711, 768, 818, 1004]], "test": "untested"}
{"id": "7ltBRH", "name": "Rep. Abstract Mat. 01 by hugolnx", "author": "hugolnx", "description": "Replicate abstract material.\nOriginal: https://github.com/HugoLnx/shaders-laboratory/tree/master/textures/shot-of-abstract-background.jpg\nOriginal Source: https://www.pexels.com/photo/full-frame-shot-of-abstract-background-247666/", "tags": ["procedural", "texture", "abstract", "background", "material", "texturing", "hugolnx"], "likes": 2, "viewed": 199, "published": 3, "date": "1662670789", "time_retrieved": "2024-07-30T16:31:56.073201", "image_code": "#define SHADERTOY 1\n// GITHUB: https://github.com/HugoLnx/shaders-laboratory/tree/master/shaders/replicate-abstract-material-01\n// ORIGINAL: https://github.com/HugoLnx/shaders-laboratory/tree/master/textures/shot-of-abstract-background.jpg\n// ORIGINAL SOURCE: https://www.pexels.com/photo/full-frame-shot-of-abstract-background-247666/\n\n//#define GREYSCALE 1\n#define PREVIEW_NOTEXTURE 1\n//#define PREVIEW_COMPARISON 1\n\n// Aux simple functions\n#define TWO_PI 6.283185\n#define PI 3.14159\nfloat norm(float x) { return x*.5 + .5; }\nfloat denorm(float x) { return x*2. - 1.; }\nfloat xstep(float b, float e, float v) {\n    return step(b, v) - step(e, v);\n}\nfloat xsmoothstep(float b, float e, float v) {\n    return smoothstep(b, e, v) - step(e, v);\n}\nfloat flatten(float v, float layers) {\n  return floor(v*layers) * (1./layers);\n}\nfloat nsin(float t) {return norm(sin(t * TWO_PI));}\nfloat ncos(float t) {return norm(cos(t * TWO_PI));}\nfloat ntan(float t) {return norm(tan(t * TWO_PI));}\nfloat sat(float t) {return clamp(t, 0., 1.);}\nfloat rsat(float t) {return mod(t+10000.0, 1.);}\nfloat xclamp(float v, float minV, float maxV) {\n  return clamp(v, minV, maxV) * xstep(minV, maxV, v);\n}\nfloat xclampnorm(float v, float minV, float maxV) {\n  return (xclamp(v, minV, maxV) - minV) / (maxV-minV);\n}\nvec3 togrey(vec3 c) {\n  return vec3((c.r+c.g+c.b)/3.);\n}\nfloat normrange(float v, float minV, float maxV) { return sat((v-minV)/(maxV-minV)); }\nfloat xnormrange(float v, float minV, float maxV) { return normrange(v, minV, maxV) * xstep(minV, maxV, v); }\nfloat putOver(float newV, float oldV) {\n  float hasV = ceil(newV);\n  return hasV * newV + (1.-hasV) * oldV;\n}\nfloat mixOverFiltered(float newV, float oldV, float oldMin, float oldMax) {\n  float hasV = ceil(abs(newV));\n  float isAvailable = xstep(oldMin, oldMax, oldV);\n  float hasToMix = floor((hasV + isAvailable)/2.);\n  return hasToMix * (oldV+newV) + (1.-hasToMix) * oldV;\n}\nvec3 mix3(vec3 cMin, vec3 cMid, vec3 cMax, float t) {\n  float t1 = normrange(t, -1., 0.);\n  float t2 = normrange(t, 0., 1.);\n  vec3 c = mix(cMin, cMid, t1);\n  c = mix(c, cMax, t2);\n  return c;\n}\n\n// -------------------\n// BEGIN https://github.com/stegu/webgl-noise\n// -------------------\n\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 mod7(vec3 x) {return x - floor(x * (1.0 / 7.0)) * 7.0;}\nvec3 permute(vec3 x) {return mod289((34.0 * x + 10.0) * x);}\nvec4 permute(vec4 x) {return mod289(((x*34.0)+10.0)*x);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n// Cellular\nvec2 cellular(vec3 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n\n\tvec3 Pi = mod289(floor(P));\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod7(floor(p11*K))*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod7(floor(p12*K))*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod7(floor(p13*K))*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod7(floor(p21*K))*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod7(floor(p22*K))*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod7(floor(p23*K))*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod7(floor(p31*K))*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod7(floor(p32*K))*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod7(floor(p33*K))*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\tvec3 d1 = min(min(d11,d12), d13);\n\tvec3 d2 = min(min(d21,d22), d23);\n\tvec3 d3 = min(min(d31,d32), d33);\n\tvec3 d = min(min(d1,d2), d3);\n\td.x = min(min(d.x,d.y),d.z);\n\treturn vec2(sqrt(d.x)); // F1 duplicated, no F2 computed\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n#endif\n}\n\nvec2 ncellular(vec2 p, float seed) {\n  p *= 15.;\n  seed *= 0.3;\n  return cellular(vec3(p, seed));\n}\n\n// Classic Perlin noise\nfloat perlin(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat nperlin(vec2 p, float seed) {\n  p *= 20.;\n  seed *= 0.5;\n  return norm(perlin(vec3(p, seed)));\n}\n\n// Simplex Noise\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat nsimplex(vec2 x, float seed) {\n  x *= 10.;\n  seed *= 0.3;\n  return norm(simplex(vec3(x, seed)));\n}\n\n\n// -------------------\n// END noise3D\n// -------------------\n\n// -------------------\n// BEGIN https://www.shadertoy.com/view/4dS3Wd\n// -------------------\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat morgan(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat morgan(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat morgan(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat nmorgan(float x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x, float seed) {\n  x *= 20.;\n  seed *= 0.5;\n  return morgan(vec3(x, seed));\n}\n// -------------------\n// END Morgan Noises\n// -------------------\n\n\n// -------------------\n// BEGIN http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// -------------------\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 P = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, P.wz) : vec4(c.gb, P.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n    // vec4 p = mix(vec4(c.bg, P.wz), vec4(c.gb, P.xy), step(c.b, c.g));\n    // vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 P = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + P.xyz) * 6.0 - P.www);\n    return c.z * mix(P.xxx, clamp(p - P.xxx, 0.0, 1.0), c.y);\n}\n// -------------------\n// END HSV Conversion \n// -------------------\n\nvec3 hsv(float h, float s, float v) {return hsv2rgb(vec3(h, s, v));}\n\n\n// Noise Aux Functions\nfloat random(vec2 uv, float seed) {\n    const float a = 12.9898;\n    const float b = 78.233;\n    const float c = 43758.543123;\n    return fract(sin(dot(uv, vec2(a, b)) + seed) * c);\n}\n\n#define OCTAVES 6\n#define OCTAVES_F 6.0\n\n// Simplex Variations\n#define SIMPLEX_VARS_SCALE 1.0\nfloat turbSimplex( vec3 p ) {\n  p *= SIMPLEX_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(100.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( simplex( power * p + shift ) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbSimplex(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.08;\n  return 1.-sat(-1.2*turbSimplex(vec3(p, seed)));\n}\n\nfloat nturb2Simplex(vec2 st2, float seed) {\n  seed *= 0.04;\n  vec3 st = vec3(st2, seed);\n  st *= SIMPLEX_VARS_SCALE * 3.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(200.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(simplex(st));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmSimplex(vec3 x) {\n  x *= SIMPLEX_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(300.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * simplex(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmSimplex(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmSimplex(vec3(x, seed)));\n}\n\n\n// Morgan Variations\n#define MORGAN_VARS_SCALE 2.5\nfloat turbMorgan( vec3 p ) {\n  p *= MORGAN_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(0.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(morgan( power * p + shift )) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbMorgan(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.05;\n  return 1.-sat(-2.0*turbMorgan(vec3(p, seed)));\n}\n\nfloat nturb2Morgan(vec2 st2, float seed) {\n  seed *= 0.03;\n  vec3 st = vec3(st2, seed);\n  st *= MORGAN_VARS_SCALE * 6.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(0.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(morgan(st)));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmMorgan(vec3 x) {\n  x *= MORGAN_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = .9;\n\tvec3 shift = vec3(0.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * (denorm(morgan(x))+0.05);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmMorgan(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmMorgan(vec3(x, seed)));\n}\n\n\n\n// Cellular Variations\n#define CELLULAR_VARS_SCALE 1.5\nfloat turbCellular( vec3 p ) {\n  p *= CELLULAR_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(700.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(cellular( power * p + shift ).x) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbCellular(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.07;\n  return sat(0.85+2.*turbCellular(vec3(p, seed)));\n}\n\nfloat nturb2Cellular(vec2 st2, float seed) {\n  seed *= 0.02;\n  vec3 st = vec3(st2, seed);\n  st *= CELLULAR_VARS_SCALE * 5.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(800.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(cellular(st).x));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmCellular(vec3 x) {\n  x *= CELLULAR_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(900.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * denorm(cellular(x).x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmCellular(vec2 x, float seed) {\n  seed *= 0.1;\n  x *= 5.;\n  return norm(fbmCellular(vec3(x, seed)));\n}\n\n\nvec2 rotate(vec2 v, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c) * v;\n}\n\n#define RED vec3(1., 0., 0.)\n#define GRE vec3(0., 1., 0.)\n#define BLU vec3(0., 0., 1.)\n#define WRED vec3(1., .8, .8)\n#define WGRE vec3(.8, 1., .8)\n#define WBLU vec3(.8, .8, 1.)\n#define BLU2 vec3(0.35, 0.5, 1.)\n#define PUR vec3(1., 0., 1.)\n#define YEL vec3(1., 1., 0.)\n#define CYA vec3(0., 1., 1.)\n#define WHI vec3(1., 1., 1.)\n#define BLA vec3(0., 0., 0.)\n#define BLANK vec3(0.35, 0., 0.35)\n\nfloat spots(vec2 uv, float seed, float scale, float size) {\n  float p2Zoom = 1./scale; //4.;\n  float p2Cut = mix(0.9, 0.65, size); //crowded; //.7;\n\n  float p3Zoom = p2Zoom * 3.;\n  float p3Cut = p2Cut * .65;\n  float p3 = nsimplex(uv*p3Zoom + 100.*p3Zoom, seed+129.327);\n  //p3 = flatten(p3, 5.);\n  p3 *= step(p3Cut, p3);\n  p3 = normrange(p3, p3Cut, 1.0);\n\n  vec2 p2uv = uv;\n  p2uv *= p2Zoom;\n  p2uv += p3*.02;\n  float p2 = nsimplex(p2uv, seed);\n  //float p2Flat = flatten(p2, 5.);\n  float p2SubCut1 = p2Cut - .1*(.2/scale);\n  float p2SubCut2 = p2SubCut1 - .2*(.2/scale);\n  float p2L1 = xnormrange(p2, p2SubCut1, p2Cut)*.8;\n  float p2L2 = xnormrange(p2, p2SubCut2, p2SubCut1)*.4;\n  p2 = step(p2Cut, p2)*.9 + p2L1 + p2L2;\n  return p2;\n}\n\nstruct noise_out {\n  float v1;\n  float v2;\n  float v3;\n\n  float l0;\n  float l1;\n  float l2;\n  float l3;\n  float l4;\n  float l5;\n\n  float l0Min;\n  float l0Max;\n};\n\nnoise_out getNoise(vec2 uv, float t) {\n  float tseed = floor(t*0.1);\n  float seed  = tseed;\n  float seed2 = tseed + 373.297;\n  float seed3 = tseed + 793.713;\n  float seed4 = tseed + 127.139;\n  float seed5 = tseed + 929.197;\n  vec2 roll = -0.05*t*vec2(1.);\n  // uv += roll;\n\n  float v = 0.;\n  float v1 = 0.;\n  float v2 = 0.;\n  float v3 = 0.;\n\n  float rand = random(uv, seed);\n  float p1 = rand;\n  float p1Min = 0.5;\n  float p1Max = 0.6;\n  p1 = mix(p1Min, p1Max, p1);\n\n  float c1 = .9-p1Min;\n  float c2 = .7-p1Min;\n  float c3 = -p1Min+.1;\n\n  float p2a = spots(uv, seed       , .2, .1) * c1;\n  float p2b = spots(uv, seed+1000. , .5, .3) * c1;\n  float p2c = spots(uv, seed+2000. , .5, .3) * c1;\n  float p4a = spots(uv, seed3      , .2, .5) * c3;\n  float p4b = 0.;//spots(uv, seed3+1000., .2, .2) * c3;\n\n\n  //float final = p1;\n  //final = mixOverFiltered(p2c, final, p1Min, p1Max);\n  //final = mixOverFiltered(p2a, final, p1Min, p1Max);\n  //final = mixOverFiltered(p4a, final, p1Min, p1Max);\n  //final = mixOverFiltered(p2b, final, p1Min, p1Max);\n  //final = mixOverFiltered(p4b, final, p1Min, p1Max);\n  //v = final;\n\n  float layer0 = p1;\n  float layer1 = p2c;\n  float layer2 = p2a;\n  float layer3 = p4a;\n  float layer4 = p2b;\n  //float layer5 = p4b;\n\n  noise_out n;\n  n.v1 = layer0;\n  n.v2 = layer1;\n  n.v3 = 1.+layer3;\n  n.l0 = layer0;\n  n.l1 = layer1;\n  n.l2 = layer2;\n  n.l3 = layer3;\n  n.l4 = layer4;\n  //n.l5 = layer5;\n  n.l0Min = p1Min;\n  n.l0Max = p1Max;\n\n  return n;\n}\n\nvec3 withColors(noise_out n) {\n  float final = n.l0;\n  final = mixOverFiltered(n.l1, final, n.l0Min, n.l0Max);\n  final = mixOverFiltered(n.l2, final, n.l0Min, n.l0Max);\n  final = mixOverFiltered(n.l3, final, n.l0Min, n.l0Max);\n  final = mixOverFiltered(n.l4, final, n.l0Min, n.l0Max);\n  //final = mixOverFiltered(n.l5, final, n.l0Min, n.l0Max);\n  final = sat(final);\n  //vec3 ORA = vec3(.745,.486,.216);\n  //vec3 ORA = vec3(0.8078, 0.5176, 0.2667);\n  vec3 ORA = vec3(0.8078, 0.5373, 0.302);\n  //final = n.l0;\n  float inDiff = normrange(final, n.l0Min, n.l0Max);\n  float outDiffUp = xclampnorm(final - n.l0Max, 0.0, 1.-n.l0Max);\n  float outDiffDown = xclampnorm(n.l0Min - final, 0.0, n.l0Min);\n  float outDiff = norm(outDiffUp-outDiffDown);\n  vec3 minOra = mix(ORA, BLA, 0.1);\n  vec3 maxOra = mix(ORA, WHI, 0.1);\n  //vec3 c = mix3(minOra, ORA, maxOra, denorm(inDiff));\n  vec3 c = mix(minOra, maxOra, inDiff);\n  minOra = mix(ORA, BLA, 0.85);\n  maxOra = mix(ORA, WHI, 0.97);\n  c = mix3(minOra, c, maxOra, denorm(outDiff));\n  return c;\n}\n\n\n#ifndef SHADERTOY\nuniform sampler2D iChannel0;\nuniform float iTime;\nuniform vec2 iResolution2D;\n#define iResolution vec4(iResolution2D, 0., 0.)\nout vec4 outColor;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from -0.5 to 0.5)\n  float mx = max(iResolution.x, iResolution.y);\n  vec2 ct = iResolution.xy / mx / 2.0;\n  vec2 uv = fragCoord/mx - ct;\n  vec2 uv2 = fragCoord / iResolution.xy - .5;\n\n  float t = iTime;\n  t *= 0.35;\n\n\n  vec3 sims[30];\n\n  float allZoom = .35;\n  vec2 uvZoom1 = uv / allZoom;\n  vec2 uvZoom2 = uvZoom1 / 2.;\n  vec2 uvZoom3 = uvZoom2 / 2.;\n  float textureZoom = 3.;\n\n  noise_out noises1 = getNoise(uvZoom1, t);\n  noise_out noises2 = getNoise(uvZoom2, t);\n  noise_out noises3 = getNoise(uvZoom3, t);\n\n  vec3 finalNoiseZoomed1 = withColors(noises1);\n  vec3 finalNoiseZoomed2 = withColors(noises2);\n  vec3 finalNoiseZoomed3 = withColors(noises3);\n\n  vec3 textureZoomed1 = texture(iChannel0, uvZoom1/textureZoom).rgb;\n  vec3 textureZoomed2 = texture(iChannel0, uvZoom2/textureZoom).rgb;\n  vec3 textureZoomed3 = texture(iChannel0, uvZoom3/textureZoom).rgb;\n\n#ifdef GREYSCALE\n  textureZoomed1 = togrey(textureZoomed1);\n  textureZoomed2 = togrey(textureZoomed2);\n  textureZoomed3 = togrey(textureZoomed3);\n#endif\n\n  int col0Count = 0;\n  sims[(col0Count++)*2] = WHI * noises1.v1;\n  sims[(col0Count++)*2] = WHI * noises1.v1;\n  sims[(col0Count++)*2] = WHI * noises1.v2;\n  sims[(col0Count++)*2] = WHI * noises1.v2;\n  sims[(col0Count++)*2] = WHI * noises1.v3;\n  sims[(col0Count++)*2] = WHI * noises1.v3;\n\n  int col1Count = 0;\n#ifdef PREVIEW_NOTEXTURE\n  sims[(col1Count++)*2+1] = finalNoiseZoomed1;\n  sims[(col1Count++)*2+1] = finalNoiseZoomed1;\n  sims[(col1Count++)*2+1] = finalNoiseZoomed1;\n  sims[(col1Count++)*2+1] = finalNoiseZoomed1;\n  sims[(col1Count++)*2+1] = finalNoiseZoomed2;\n  sims[(col1Count++)*2+1] = finalNoiseZoomed3;\n#elif PREVIEW_COMPARISON\n  sims[(col1Count++)*2+1] = finalNoiseZoomed1;\n  sims[(col1Count++)*2+1] = finalNoiseZoomed1;\n  sims[(col1Count++)*2+1] = finalNoiseZoomed1;\n  sims[(col1Count++)*2+1] = textureZoomed1;\n  sims[(col1Count++)*2+1] = textureZoomed1;\n  sims[(col1Count++)*2+1] = textureZoomed1;\n#else\n  sims[(col1Count++)*2+1] = finalNoiseZoomed1;\n  sims[(col1Count++)*2+1] = textureZoomed1;\n  sims[(col1Count++)*2+1] = finalNoiseZoomed2;\n  sims[(col1Count++)*2+1] = textureZoomed2;\n  sims[(col1Count++)*2+1] = finalNoiseZoomed3;\n  sims[(col1Count++)*2+1] = textureZoomed3;\n#endif\n\n  uv2 += .5;\n  float gridWidth = 2.0;\n  float gridHeight = 6.0;\n  float gridX = floor(uv2.x*gridWidth);\n  float gridY = floor((1.-uv2.y)*gridHeight);\n  int gridInx = int(floor(gridY*gridWidth + gridX));\n  vec3 c;\n  int count = col0Count + col1Count;\n  for (int i = 0; i < count; i++) {\n    c += sims[i] * (gridInx == i ? 1.0 : 0.0);\n  }\n  \n\n  // Output to screen\n  fragColor = vec4(c, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n  mainImage(outColor, gl_FragCoord.xy);\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltBRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[486, 486, 507, 507, 527], [528, 528, 551, 551, 571], [572, 572, 612, 612, 650], [651, 651, 697, 697, 744], [745, 745, 783, 783, 825], [826, 826, 847, 847, 877], [878, 878, 899, 899, 929], [930, 930, 951, 951, 981], [982, 982, 1002, 1002, 1027], [1028, 1028, 1049, 1049, 1076], [1077, 1077, 1124, 1124, 1180], [1181, 1181, 1232, 1232, 1289], [1290, 1290, 1311, 1311, 1346], [1347, 1347, 1397, 1397, 1433], [1434, 1434, 1485, 1485, 1543], [1544, 1544, 1583, 1583, 1653], [1654, 1654, 1729, 1729, 1921], [1922, 1922, 1975, 1975, 2116], [2211, 2211, 2232, 2232, 2277], [2278, 2278, 2299, 2299, 2344], [2345, 2345, 2364, 2364, 2405], [2406, 2406, 2428, 2428, 2466], [2467, 2467, 2489, 2489, 2523], [2524, 2524, 2551, 2551, 2599], [2600, 2600, 2619, 2619, 2655], [2657, 2669, 2692, 2692, 7499], [7501, 7501, 7537, 7537, 7600], [7602, 7626, 7648, 7648, 9943], [9945, 9945, 9980, 9980, 10047], [10049, 10066, 10091, 10091, 12230], [12232, 12232, 12268, 12268, 12336], [12401, 12568, 12589, 12589, 12656], [12657, 12657, 12677, 12677, 12782], [12784, 12784, 12807, 12807, 12939], [12941, 12941, 12963, 12963, 13597], [13600, 13600, 13622, 13622, 14383], [14385, 14385, 14409, 14409, 14443], [14444, 14444, 14467, 14467, 14501], [14502, 14502, 14537, 14537, 14598], [14668, 14779, 14801, 14801, 15262], [15264, 15264, 15286, 15286, 15455], [15526, 15526, 15563, 15563, 15594], [15597, 15620, 15655, 15655, 15803], [15899, 15899, 15928, 15928, 16162], [16164, 16164, 16204, 16204, 16283], [16285, 16285, 16328, 16328, 16651], [16653, 16653, 16679, 16679, 16890], [16892, 16892, 16931, 16931, 17001], [17055, 17055, 17083, 17083, 17321], [17323, 17323, 17362, 17362, 17440], [17442, 17442, 17484, 17484, 17811], [17813, 17813, 17838, 17838, 18060], [18062, 18062, 18100, 18100, 18169], [18228, 18228, 18258, 18258, 18504], [18506, 18506, 18547, 18547, 18627], [18629, 18629, 18673, 18673, 19008], [19010, 19010, 19037, 19037, 19260], [19262, 19262, 19302, 19302, 19373], [19376, 19376, 19410, 19410, 19492], [19885, 19885, 19944, 19944, 20619], [20784, 20784, 20822, 20822, 22256], [22258, 22258, 22288, 22288, 23291], [23465, 23465, 23522, 23575, 26167]], "test": "untested"}
{"id": "sldBz8", "name": "Lambmeow Arrow ", "author": "lambmeow", "description": "really cool accident when messing around.", "tags": ["color", "palette", "arrow", "lambmeow"], "likes": 9, "viewed": 297, "published": 3, "date": "1662665584", "time_retrieved": "2024-07-30T16:31:56.867079", "image_code": "#define resolution iResolution\n#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 r = resolution.xy, u = (2.* fragCoord - r)/r.y;\n    u.y = abs(u.y);\n    u *= mat2(cos(35.), -sin(45.),sin(45.),cos(45.)) + sin(time) * 0.005;\n    u.x *= 10.;\n    float pos = floor(u.x+ time);\n    fragColor.r = mod(pos, 2.) * sin(pos* 0.5 + time);\n    fragColor.g = mod(pos, 2.) * sin(pos* 0.5 + time + .6 );\n    fragColor.b = mod(pos, 2.) * sin(pos* 0.5 + time + .8);\n    fragColor *= (1.-abs(u.y *0.7));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sldBz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 107, 107, 523]], "test": "untested"}
{"id": "ftdfRH", "name": "BLF Cylinder Derivation", "author": "iY0Yi", "description": "Derived Primitives from Cylinder.", "tags": ["sdf", "boolean", "union"], "likes": 8, "viewed": 338, "published": 3, "date": "1662656764", "time_retrieved": "2024-07-30T16:31:58.009025", "image_code": "/*\nMIT License\n\nCopyright (c) 2024 iY0Yi\nhttps://www.shadertoy.com/user/iY0Yi\nhttps://x.com/IY0YI\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this code, to deal\nin the code without restriction, subject to the following conditions:\nThis license notice shall be included in all copies or substantial portions of the code.\nTHE CODE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND.\n*/\n\n#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 1\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 3.\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\n// https://iquilezles.org/articles/distfunctions/\n// vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n// return min(max(d.x,d.y),0.0) + length(max(d,0.0));\nfloat sdCylinder(vec3 p, float r, float h){\n    float xz = length(p.xz)-r;\n    float y = abs(p.y)-h;\n    float m = max(xz,y);\n    float e = length(max(vec2(xz,y),0.));\n    return min(m,0.)+e;\n}\n\nfloat sdPipe(vec3 p, float r, float h, float t){\n    float xz = abs(length(p.xz)-r+t)-t;\n    float y = abs(p.y)-h;\n    float m = max(xz,y);\n    float e = length(max(vec2(xz,y),0.));\n    return min(m,0.)+e;\n}\n\n// https://www.shadertoy.com/view/Ml3fWj\n// vec3 q = abs(p)-h;\n// return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\nfloat sdElongatedCylinder(vec3 p, vec3 s){\n    p = abs(p);\n    p.x -= s.x-s.y;\n    p = max(p, 0.);\n    \n    float xz = length(p.xz)-s.y;\n    float y = abs(p.y)-s.z;\n    float m = max(xz,y);\n    float e = length(max(vec2(xz,y),0.));\n    return min(m,0.)+e;\n}\n\nfloat sdElongatedPipe(vec3 p, vec3 s, float t){\n    p = abs(p);\n    p.x -= s.x-s.y;\n    p = max(p, 0.);\n    \n    float xz = abs(length(p.xz)-s.y+t)-t;\n    float y = abs(p.y)-s.z;\n    float m = max(xz,y);\n    float e = length(max(vec2(xz,y),0.));\n    return min(m,0.)+e;\n}\n\nfloat sdRectPipe(vec3 p, vec2 s, float h, float t){\n    vec2 d = abs(p.xz)-s;\n    float xz = length(max(d,0.)) + min(max(d.x,d.y),0.) + t;\n    xz = abs(xz)-t;\n    float y = abs(p.y)-h;\n    float m = max(xz,y);\n    float e = length(max(vec2(xz,y),0.));\n    return min(m,0.)+e;\n}\n\nfloat map( in vec3 p )\n{\n    float el = abs(sin(iTime))*.75;\n    float tk = max(0.,cos(iTime))*.25+.1;\n    float rn = .05;//abs(sin(iTime*.25))*.05+.025;\n    float d = 3e38;\n    d = min(d, sdCylinder(p+vec2(3,0).yyx, .5, .5));\n    d = min(d, sdPipe(p+vec2(1.5,0).yyx, .5, .5, tk));\n    d = min(d, sdRectPipe(p+vec2(-3,0).yyx, vec2(.5+el, .5), .5, tk));\n    \n    d = min(d, sdElongatedCylinder(p+vec2(0,0).yyx, vec3(.5+el, .5, .5)));\n    d = min(d, sdElongatedPipe(p+vec2(-1.5,0).yyx, vec3(.5+el, .5, .5), tk));\n    return d-rn;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n#define THM_MATCAP_TYPE 2\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n#define INIT_CAM_POS vec3(-2,-2,0)\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 6.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -1, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.149,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.8) - ambient, vec3(0.0), dirt);\\\n                float shininess = 64.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// User Inputs\n\n// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(0, 0, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftdfRH.jpg", "access": "api", "license": "mit", "functions": [[657, 814, 857, 857, 1007], [1009, 1009, 1057, 1057, 1216], [1218, 1343, 1385, 1385, 1600], [1602, 1602, 1649, 1649, 1873], [1875, 1875, 1926, 1926, 2152], [2154, 2154, 2178, 2178, 2683]], "test": "untested"}
{"id": "NttBRH", "name": "fake 15 grids segmentation font", "author": "yasuo", "description": "font experiment", "tags": ["font"], "likes": 17, "viewed": 294, "published": 3, "date": "1662648974", "time_retrieved": "2024-07-30T16:31:58.937543", "image_code": "float fonts(vec2 p){\n    p*=5.0;\n    p.x+=iTime*0.5;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n\n    float n = Hash21(id)*40.0;\n    \n    int char = int(n);\n    float size = 0.35;\n    float d = drawFont(gv*size,char);\n    if(char < 10){\n        int num = int(mod(iTime*float(n),10.0));\n        d = drawFont(gv*size,num);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float d = fonts(uv);\n    \n    col = mix(col,vec3(1.),S(d,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define seg_0 0\n#define seg_1 1\n#define seg_2 2\n#define seg_3 3\n#define seg_4 4\n#define seg_5 5\n#define seg_6 6\n#define seg_7 7\n#define seg_8 8\n#define seg_9 9\n#define seg_A 10\n#define seg_B 11\n#define seg_C 12\n#define seg_D 13\n#define seg_E 14\n#define seg_F 15\n#define seg_G 16\n#define seg_H 17\n#define seg_I 18\n#define seg_J 19\n#define seg_K 20\n#define seg_L 21\n#define seg_M 22\n#define seg_N 23\n#define seg_O 24\n#define seg_P 25\n#define seg_Q 26\n#define seg_R 27\n#define seg_S 28\n#define seg_T 29\n#define seg_U 30\n#define seg_V 31\n#define seg_W 32\n#define seg_X 33\n#define seg_Y 34\n#define seg_Z 35\n#define seg_Plus 36\n#define seg_Minus 37\n#define seg_Colon 38\n#define seg_DP 39\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat segBase(vec2 p){\n    vec2 prevP = p;\n    \n    float size = 0.02;\n    float padding = 0.05;\n\n    float w = padding*3.0;\n    float h = padding*5.0;\n\n    p = mod(p,0.05)-0.025;\n    float thickness = 0.005;\n    float gridMask = min(abs(p.x)-thickness,abs(p.y)-thickness);\n    \n    p = prevP;\n    float d = B(p,vec2(w*0.5,h*0.5));\n    float a = radians(45.0);\n    p.x = abs(p.x)-0.1;\n    p.y = abs(p.y)-0.05;\n    float d2 = dot(p,vec2(cos(a),sin(a)));\n    d = max(d2,d);\n    d = max(-gridMask,d);\n    return d;\n}\n\nfloat seg0(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat seg1(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    \n    p.x+=size*1.8;\n    p.y-=size*3.5;\n    mask = B(p,vec2(size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg2(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg3(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg4(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x+=size;\n    p.y+=0.08;\n    float mask = B(p,vec2(size*2.,size*2.0));\n    d = max(-mask,d);\n\n    p = prevP;\n    \n    p.y-=0.08;\n    mask = B(p,vec2(size,size*2.0));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg5(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg6(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg7(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y+=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    return d;\n}\n\n\nfloat seg8(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat seg9(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x+=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat segA(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.08;\n    mask = B(p,vec2(size,size*2.));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segB(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y= abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segC(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    float mask = B(p,vec2(size*2.,size*2.5));\n    d = max(-mask,d);\n    return d;\n    \n    return d;\n}\n\nfloat segD(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    \n    p.x-=0.05;\n    p.y= abs(p.y);\n    p.y-=0.1;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat segE(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y = abs(p.y);\n    p.x-=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segF(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=0.05;\n    p.y+=size;\n    float mask = B(p,vec2(size,size*3.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    p.y-=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    p = prevP;\n    p.y+=0.08;\n    mask = B(p,vec2(size,size*2.));\n    d = max(-mask,d);    \n    \n    return d;\n}\n\nfloat segG(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    p.x-=0.05;\n    p.y-=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat segH(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.y = abs(p.y);\n    p.y-=0.08;\n    float mask = B(p,vec2(size,size*2.));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segI(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x = abs(p.x);\n    p.x-=0.05;\n    float mask = B(p,vec2(size,size*2.5));\n    d = max(-mask,d);\n    return d;\n    \n    return d;\n}\n\nfloat segJ(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    \n    p.y-=0.05;\n    p.x+=0.05;\n    mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat segK(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.y = abs(p.y);\n    p.y-=0.08;\n    float mask = B(p,vec2(size,size*2.));\n    d = max(-mask,d);\n    \n    p = prevP;\n    p.x-=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat segL(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x-=size;\n    p.y-=size;\n    float mask = B(p,vec2(size*2.,size*3.7));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat segM(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y+=0.05;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    p = prevP;\n    p.y-=0.1;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat segN(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y+=0.03;\n    float mask = B(p,vec2(size,size*3.5));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat segO(vec2 p){\n    return seg0(p);\n}\n\nfloat segP(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x-=size;\n    p.y+=0.08;\n    float mask = B(p,vec2(size*2.,size*2.0));\n    d = max(-mask,d);\n\n    p = prevP;\n    \n    p.y-=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat segQ(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x+=size;\n    p.y+=0.1;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    \n    p.y-=0.03;\n    mask = B(p,vec2(size,size*1.7));\n    d = max(-mask,d);\n    \n    return d;\n}\n\n\nfloat segR(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.y+=0.08;\n    mask = B(p,vec2(size,size*2.));\n    d = max(-mask,d);\n    \n    p = prevP;\n    p.x-=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);    \n    \n    return d;\n}\n\nfloat segS(vec2 p){\n    return seg5(p);\n}\n\nfloat segT(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x = abs(p.x);\n    p.x-=0.05;\n    p.y+=0.03;\n    float mask = B(p,vec2(size,size*3.5));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat segU(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.03;\n    float mask = B(p,vec2(size,size*3.5));\n    d = max(-mask,d);\n    return d;\n}\n\n\nfloat segV(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    p = prevP;\n    p.y+=0.1;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    p = prevP;\n    \n    p.x-=0.05;\n    p.y+=0.08;\n    mask = B(p,vec2(size,size*2.0));\n    d = max(-mask,d);\n    return d;\n}\n\n\nfloat segW(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    p = prevP;\n    p.y+=0.1;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    return d;\n}\n\nfloat segX(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.y = abs(p.y);\n    p.y-=0.08;\n    float mask = B(p,vec2(size,size*2.));\n    d = max(-mask,d);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segY(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p.x=abs(p.x);\n    p.x-=0.05;\n    p.y+=0.05;\n    float mask = B(p,vec2(size,size*2.7));\n    d = max(-mask,d);\n    \n    p = prevP;\n    p.y-=0.08;\n    mask = B(p,vec2(size,size*2.));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segZ(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    p.x+=size;\n    p.y-=0.05;\n    float mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n\n    p = prevP;\n    p.x-=size;\n    p.y+=0.05;\n    mask = B(p,vec2(size*2.,size));\n    d = max(-mask,d);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.05;\n    mask = B(p,vec2(size,size));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segPlus(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p = abs(p);\n    p.x-=0.05;\n    p.y-=0.08;\n    float mask = B(p,vec2(size,size*2.));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segMinus(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.03;\n    \n    p = abs(p);\n    p.x-=0.05;\n    p.y-=0.08;\n    float mask = B(p,vec2(size*2.,size*2.));\n    d = max(-mask,d);\n    \n    return d;\n}\n\nfloat segColon(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.028;\n    p.y = abs(p.y);\n    p.y-=0.05;\n    float mask = B(p,vec2(size,size));\n    d = max(mask,d);\n    \n    return d;\n}\n\nfloat segDecimalPoint(vec2 p){\n    vec2 prevP = p;\n    float d = segBase(p);\n    float size = 0.028;\n    p.y+=0.1;\n    float mask = B(p,vec2(size,size));\n    d = max(mask,d);\n    return d;\n}\n\nfloat drawFont(vec2 p, int char){\n    float d = 10.;\n    if(char == seg_0) {\n        d = seg0(p);\n    } else if(char == seg_1) {\n        d = seg1(p);\n    } else if(char == seg_2) {\n        d = seg2(p);\n    } else if(char == seg_3) {\n        d = seg3(p);\n    } else if(char == seg_4) {\n        d = seg4(p);\n    } else if(char == seg_5) {\n        d = seg5(p);\n    } else if(char == seg_6) {\n        d = seg6(p);\n    } else if(char == seg_7) {\n        d = seg7(p);\n    } else if(char == seg_8) {\n        d = seg8(p);\n    } else if(char == seg_9) {\n        d = seg9(p);\n    } else if(char == seg_A) {\n        d = segA(p);\n    } else if(char == seg_B) {\n        d = segB(p);\n    } else if(char == seg_C) {\n        d = segC(p);\n    } else if(char == seg_D) {\n        d = segD(p);\n    } else if(char == seg_E) {\n        d = segE(p);\n    } else if(char == seg_F) {\n        d = segF(p);\n    } else if(char == seg_G) {\n        d = segG(p);\n    } else if(char == seg_H) {\n        d = segH(p);\n    } else if(char == seg_I) {\n        d = segI(p);\n    } else if(char == seg_J) {\n        d = segJ(p);\n    } else if(char == seg_K) {\n        d = segK(p);\n    } else if(char == seg_L) {\n        d = segJ(p);\n    } else if(char == seg_M) {\n        d = segM(p);\n    } else if(char == seg_N) {\n        d = segN(p);\n    } else if(char == seg_O) {\n        d = segO(p);\n    } else if(char == seg_P) {\n        d = segP(p);\n    } else if(char == seg_Q) {\n        d = segQ(p);\n    } else if(char == seg_R) {\n        d = segR(p);\n    } else if(char == seg_S) {\n        d = segS(p);\n    } else if(char == seg_T) {\n        d = segT(p);\n    } else if(char == seg_U) {\n        d = segU(p);\n    } else if(char == seg_V) {\n        d = segV(p);\n    } else if(char == seg_W) {\n        d = segW(p);\n    } else if(char == seg_X) {\n        d = segX(p);\n    } else if(char == seg_Y) {\n        d = segY(p);\n    } else if(char == seg_Z) {\n        d = segZ(p);\n    } else if(char == seg_Plus) {\n        d = segPlus(p);\n    } else if(char == seg_Minus) {\n        d = segMinus(p);\n    } else if(char == seg_Colon) {\n        d = segColon(p);\n    } else if(char == seg_DP) {\n        d = segDecimalPoint(p);\n    }\n    \n    return d;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttBRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 350], [352, 352, 409, 409, 610]], "test": "untested"}
{"id": "NttBR8", "name": "Room Test 1", "author": "voysys", "description": "First shader - yay! :)\n\nThis is very much based on this older shader by @fizzer: https://www.shadertoy.com/view/4slGz7\n", "tags": ["test1", "room"], "likes": 5, "viewed": 242, "published": 3, "date": "1662639843", "time_retrieved": "2024-07-30T16:31:59.789265", "image_code": "#define EPS vec2(1e-3, 0.0)\n#define ON  vec2(1.0, 0.0)\n\nvec2 t;\nfloat time;\n\nvec3 rotateX(float a, vec3 v) {\n    return vec3(v.x, cos(a) * v.y + sin(a) * v.z, cos(a) * v.z - sin(a) * v.y);\n}\n\nvec3 rotateY(float a, vec3 v) {\n    return vec3(cos(a) * v.x + sin(a) * v.z, v.y, cos(a) * v.z - sin(a) * v.x);\n}\n\nvec2 cubeInterval(vec3 ro, vec3 rd) {\n    vec3 slabs0 = (vec3(+1.0) - ro) / rd;\n    vec3 slabs1 = (vec3(-1.0) - ro) / rd;\n\n    vec3 mins = min(slabs0, slabs1);\n    vec3 maxs = max(slabs0, slabs1);\n\n    return vec2(max(max(mins.x, mins.y), mins.z), min(min(maxs.x, maxs.y), maxs.z));\n}\n\nfloat N(vec2 p) {\n    p = mod(p, vec2(101.0));\n    return fract(sin(p.x * 41784.0) + sin(p.y * 32424.0));\n}\n\nfloat smN2(vec2 p) {\n    vec2 fp = floor(p);\n    vec2 pf = smoothstep(0.0, 1.0, fract(p));\n\n    return mix(mix(N(fp), N(fp + ON), pf.x), mix(N(fp + ON.yx), N(fp + ON.xx), pf.x), pf.y);\n}\n\nfloat smN3(vec3 p) {\n    vec2 o = vec2(111.0);\n    return mix(\n        smN2(p.xy + floor(p.z) * o), smN2(p.xy + (floor(p.z) + 1.0) * o), smoothstep(0.0, 1.0, fract(p.z)));\n}\n\nfloat fbm3(vec3 p) {\n    float f = 0.0, x;\n    for (int i = 1; i <= 7; ++i) {\n        x = exp2(float(i));\n        f += (smN3(p * x) - 0.5) / x;\n    }\n    return f;\n}\n\n#define fbm2(g) fbm3(vec3(g, 0.0))\n\nfloat pulse(float e0, float e1, float x) {\n    return step(e0, x) - step(e1, x);\n}\n\nfloat beam(float x) {\n    x = clamp(x, 0.0, 1.0);\n    return smoothstep(0.7, 1.0, pow(1.0 - 2.0 * abs(x - 0.5), 0.02));\n}\n\nfloat beamShadow(float x) {\n    x = clamp(x + 0.1, 0.0, 0.5);\n    return smoothstep(0.7, 1.0, pow(1.0 - 2.0 * abs(x - 0.5), 0.1));\n}\n\nvec3 wood(vec2 p) {\n    p += vec2(200.0);\n    p.x *= 1.2;\n    p.y *= 0.6;\n    return vec3(0.4, 0.25, 0.1) * (1.0 + fbm2(p));\n}\n\nvec3 crate(vec3 o, vec2 p) {\n    float shadow = mix(0.5, 1.0, smoothstep(0.0, 0.2, o.y + 1.0));\n\n    float innercoord = fract(p.x * 3.0);\n    vec2 outercoord = abs(p) * 3.0 - vec2(2.0);\n    float acrosscoord = min(0.3, abs(dot(p, vec2(1.0)))) * 8.0 - 2.0;\n\n    float inner = beam(innercoord);\n\n    float outers0 = beamShadow(outercoord.y);\n    float outers1 = beamShadow(outercoord.x);\n\n    float outerm0 = beam(outercoord.y);\n    float outerm1 = beam(outercoord.x);\n\n    float acrosss0 = 1.0 - beamShadow(acrosscoord);\n    float acrossm0 = 1.0 - beam(acrosscoord);\n\n    o += vec3(1e-2);\n\n    float stain =\n        (smoothstep(0.95, 1.0, fbm3(mod(o, vec3(5.01)) * 0.5) + 0.8 + fbm3(mod(o, vec3(5.01)) * 4.0) * 0.4));\n\n    float v = inner * (1.0 - acrosss0) + acrossm0;\n\n    v = v * (1.0 - outers1) + outerm1;\n\n    vec3 innercol = wood(vec2(p.x * 3.0, p.y)) * 0.76;\n    vec3 acrosscol = wood(vec2(dot(p, vec2(1.0)) * 3.0, p.x * 2.0));\n    vec3 outer0col = wood(p.yx * vec2(4.0, 1.4)) * vec3(1.0, 1.0, 0.9);\n    vec3 outer1col = wood(p.xy * vec2(4.0, 1.4));\n\n    vec3 col = mix(innercol, acrosscol, acrossm0);\n\n    col = mix(col, outer1col, outerm1);\n    col = mix(col, outer0col, outerm0);\n\n    float f = mix(0.5, 1.0, (1.0 - pow(abs(p.x), 30.0)) * (1.0 - pow(abs(p.y), 30.0)));\n\n    return shadow * (v * (1.0 - outers0) + outerm0) * col * f * mix(vec3(1.0), vec3(0.8, 0.7, 0.5), stain);\n}\n\nbool gridSolidity1(vec3 rp) {\n    rp = floor(rp);\n    return rp.y < (N(rp.xz * 2.0) * 10.0 - 20.0 / (1.0 + abs(rp.x)));\n}\n\nfloat groundSolidity(vec2 p) {\n    return gridSolidity1(vec3(p.x, -2.0, p.y)) ? 1.0 : 0.0;\n}\n\nfloat groundShadow(vec2 p) {\n    vec2 fp = floor(p);\n    vec2 pf = smoothstep(0.0, 1.0, fract(p));\n\n    return mix(\n        mix(groundSolidity(fp), groundSolidity(fp + ON), pf.x),\n        mix(groundSolidity(fp + ON.yx), groundSolidity(fp + ON.xx), pf.x),\n        pf.y);\n}\n\nvec3 stone(vec2 p) {\n    p += vec2(200.0);\n    p.x *= 1.2;\n    p.y *= 0.6;\n    return vec3(0.5, 0.5, 0.51) * smoothstep(0.0, 0.9, 1.0 + fbm2(p));\n}\n\nvec3 stoneFloor(vec3 o, vec2 p) {\n    float shadow = 1.0 - groundShadow(o.xz * 2.0 - vec2(0.5));\n    return fbm2(p * 4.0) * 0.1 +\n           shadow * mix(0.6, 0.65, smoothstep(0.0, 0.1, fbm2(o.xz * 2.0))) * vec3(0.7, 0.7, 0.8);\n}\n\nvec3 wall(vec3 o, vec2 p) {\n    float f = mix(0.5, 1.0, (1.0 - pow(abs(p.x), 30.0)) * (1.0 - pow(abs(p.y), 30.0)));\n\n    if (o.y < -0.99)\n        return stoneFloor(o, p) * f * 0.7;\n\n    float innercoord = fract(p.x * 7.0);\n    vec2 outercoord = abs(p) * 3.0 - vec2(2.0);\n    float acrosscoord = min(0.3, abs(dot(p, vec2(1.0)))) * 8.0 - 2.0;\n\n    float inner = beam(innercoord);\n\n    float outers0 = beamShadow(outercoord.y);\n\n    float outerm0 = beam(outercoord.y);\n\n    float g = pow(clamp((-o.y - 0.5) * 2.0, 0.0, 1.0), 2.0);\n\n    float stain = (smoothstep(\n        0.95, 1.0, fbm3(mod(o, vec3(5.0)) * 4.0) + 0.8 + g + fbm3(mod(o, vec3(5.0)) * 16.0) * 0.6));\n\n    vec3 innercol = stone(vec2(p.x, p.y) * 2.0) * 0.76;\n    vec3 outer0col = stone(p.yx * vec2(4.0, 1.4)) * vec3(1.0, 1.0, 0.9);\n\n    vec3 col = mix(innercol, outer0col, outerm0);\n\n    float fray = smoothstep(0.0, 0.5, stain) - smoothstep(0.5, 1.0, stain);\n\n    return vec3(fray) * 0.2 * (1.0 - outerm0) +\n           (inner * (1.0 - outers0) + outerm0) * col * f *\n               mix(vec3(1.0), vec3(0.5, 0.4, 0.3), 0.5 * stain * (1.0 - outerm0));\n}\n\nvec2 cubeProject(vec3 v) {\n    vec3 av = abs(v);\n\n    if (av.x > av.y && av.x > av.z)\n        return v.yz / av.x;\n    else if (av.y > av.x && av.y > av.z)\n        return v.xz / av.y;\n    else\n        return v.xy / av.z;\n}\n\nbool gridSolidity0(vec3 rp) {\n    if (rp.x < 2.0 && rp.y < -2.0)\n        return true;\n\n    vec2 wc = fract(rp.xy * 0.4);\n\n    float wires = pulse(-0.17, -0.1, 3.6 - sin(wc.x * 3.14159 * 2.0 + rp.z * 123.0) - wc.y * 4.0);\n\n    wires += pulse(-0.3, -0.1, 11.4 - sin(wc.x * 3.14159 * 2.0 + rp.z * 23.0) - wc.y * 16.0);\n\n    return (length(floor(rp.xy)) > 3.0) || ((wires * step(fract(rp.z), 1e-3) * step(1.0, rp.y)) > 0.0);\n}\n\nbool traverseUniformGridStep(vec3 ro, vec3 rd, vec3 increment, inout vec3 intersection, out float t) {\n    t = min(intersection.x, min(intersection.y, intersection.z));\n    vec3 rp = ro + rd * t;\n\n    intersection +=\n        increment * step(intersection.xyz, intersection.yxy) * step(intersection.xyz, intersection.zzx);\n\n    return gridSolidity0(rp);\n}\n\nfloat traverseUniformGrid(vec3 ro, vec3 rd) {\n    ro *= 2.0;\n    rd *= 2.0;\n\n    vec3 increment = vec3(1.0) / rd;\n    vec3 intersection = ((floor(ro) + round(rd * 0.5 + vec3(0.5))) - ro) * increment;\n    float t;\n\n    increment = abs(increment);\n    ro += rd * 1e-3;\n\n    for (int i = 0; i < 30; ++i) {\n        if (traverseUniformGridStep(ro, rd, increment, intersection, t)) {\n            return t;\n        }\n    }\n\n    return 100.0;\n}\n\nfloat look(float x) {\n    float c = floor(x);\n    return smoothstep(0.5, 1.0, 1.0 - abs(fract(x) - 0.5) * 2.0) * step(0.2, cos(mod(c, 20.0) * 3.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    t = uv * 2.0 - vec2(1.0);\n    t.x *= iResolution.x / iResolution.y;\n    time = iTime;\n\n    // pos (moves forward over time)\n    vec3 cp = vec3(0.3, -0.7 + pow(0.5, 0.7) * 0.01, time * 0.2);\n\n    // directional basis vectors (singularity straight up and down)\n    vec3 cw = vec3(0.0, 0.0, -1.0); // look-at dir\n    vec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n    vec3 cv = normalize(cross(cu, cw));\n\n    // matrix with the directional basis vectors\n    mat3 rm = mat3(cu, cv, cw);\n\n    vec3 ro = cp;\n    vec3 rd = rm * vec3(t.xy * 0.3, -0.25);\n\n    float t = traverseUniformGrid(ro, rd);\n\n    vec3 rp = ro + rd * t;\n    vec2 cc = cubeProject(rp * 2.0 - (floor(rp * 2.0) + vec3(0.5)));\n\n    vec3 col0 = wall(rp, cc);\n    vec3 col1 = crate(rp, cc);\n\n    float order = gridSolidity0(rp * 2.0 + rd * 1e-3) ? 0.0 : 1.0;\n\n    float nearest = t;\n\n    vec3 l =\n        vec3(0.01) +\n        vec3(\n            pow(1.0 - smoothstep(\n                          0.04, (2.0 - rp.y) * 0.15, distance(fract(rp.xz * 0.6 + vec2(0.0)), vec2(0.5))),\n                2.0) *\n            1.0 * clamp(1.0 - rp.y, 0.0, 1.0));\n\n    l += 0.8 * vec3(1.1, 1.1, 0.8);\n\n    vec3 col =\n        mix(col0, col1, order) * mix(vec3(0.02, 0.03, 0.1) * (3.0 - rp.y) * 0.2, vec3(1.2, 1.2, 1.0), l);\n\n    float v = 1.0 - pow(distance(uv, vec2(0.5)), 2.0) * 0.5;\n\n#if 1\n    vec3 fog = vec3(0.2, 0.2, 0.2) * 0.1;\n    fragColor.rgb = 1.5 * mix(fog, col, exp(-nearest * nearest * 0.01)) * v;\n#else\n    fragColor.rgb = col;\n#endif\n\n    fragColor.rgb *= 1.2;\n\n    fragColor.rgb += vec3(N(fragCoord.xy) * 0.005);\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NttBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 108, 108, 190], [192, 192, 223, 223, 305], [307, 307, 344, 344, 591], [593, 593, 610, 610, 700], [702, 702, 722, 722, 888], [890, 890, 910, 910, 1063], [1065, 1065, 1085, 1085, 1230], [1268, 1268, 1310, 1310, 1350], [1352, 1352, 1373, 1373, 1473], [1475, 1475, 1502, 1502, 1607], [1609, 1609, 1628, 1628, 1735], [1737, 1737, 1765, 1765, 3125], [3127, 3127, 3156, 3156, 3248], [3250, 3250, 3280, 3280, 3342], [3344, 3344, 3372, 3372, 3615], [3617, 3617, 3637, 3637, 3764], [3766, 3766, 3799, 3799, 3995], [3997, 3997, 4024, 4024, 5108], [5110, 5110, 5136, 5136, 5331], [5333, 5333, 5362, 5362, 5755], [5757, 5757, 5859, 5859, 6111], [6113, 6113, 6158, 6158, 6549], [6551, 6551, 6572, 6572, 6701], [6703, 6703, 6758, 6758, 8406]], "test": "untested"}
{"id": "stcBzH", "name": "BLF opUnionGapped", "author": "iY0Yi", "description": "Gapped opUnion.\n*More sophisticated names are welcome :)", "tags": ["sdf", "boolean", "union"], "likes": 7, "viewed": 256, "published": 3, "date": "1662637591", "time_retrieved": "2024-07-30T16:32:00.788594", "image_code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 0\n\n#define DBG_MATCAP 1\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 1.\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\nfloat sdBox(vec3 p, vec3 s){\n    p = abs(p)-s;\n    return max(p.x,max(p.y,p.z));//length(max(p,0.)) + min(0.,max(p.x,max(p.y,p.z)));\n}\n\nfloat sdCylinder(vec3 p, float r, float h){\n    return max(length(p.xz)-r, abs(p.y)-h);\n}\n\nfloat opUnionGapped(float a, float b, float g){\n    return min(max(a,-b+g),b);\n}\n\nfloat map( in vec3 p )\n{\n    float sd0 = sdBox(p, vec3(.5));\n    \n    vec3 q = abs(p);\n    q.xz = rot(q.xz, PI*.25);\n    float sd1 = sdBox(q, vec2(.5,.125).xxy);\n    \n    float sd2 = sdCylinder(p, .125, .6);\n    \n    float gap = .1*(sin(iTime)+1.);\n    \n    float d = opUnionGapped(sd0, sd1, gap);\n    return opUnionGapped(d, sd2, gap);\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.4\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n#define THM_MATCAP_TYPE 2\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 6.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -1, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\\\n                vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\\\n                vec3(0.5, 0.4, 0.3), shine) - ambient;\\\n                vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.192,0.063,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.149,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.5) - ambient, vec3(0.0), dirt);\\\n                float shininess = 32.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t) caps C(-6)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p) caps C(-6)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e) caps C(-6)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e) caps C(-6)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);fragColor = vec4(renderRect(fragCoord*2.-Res.zz),1);}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);fragColor = vec4(renderRect(fragCoord*2.-Res.zy),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);fragColor = vec4(renderRect(fragCoord*2.-Res.xz),1);}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);fragColor = vec4(renderRect(fragCoord*2.-Res.xy),1);}\\\n        else fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// User Inputs\n\n// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(0, 0, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 236, 264, 264, 370], [372, 372, 415, 415, 461], [463, 463, 510, 510, 543], [545, 545, 569, 569, 883]], "test": "untested"}
{"id": "7t3fzH", "name": "Circle Stacks 2", "author": "FabriceNeyret2", "description": "( Wait ~ 30\" to get a similar look ). \nreference: [url] https://twitter.com/DonKarlssonSan/status/1567193595530076160 [/url]", "tags": ["2d", "short", "reproduction"], "likes": 15, "viewed": 290, "published": 3, "date": "1662637500", "time_retrieved": "2024-07-30T16:32:01.672231", "image_code": "// variant of https://shadertoy.com/view/fltBzn\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(p)  fract(sin(mod((p)* vec2(12.9898, 78.233),6.283)) * 43758.5453)\n#define S(v)   smoothstep( 1.5/R.y, 0., clamp(v,0.,1.) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u / R.y, P;\n    O =  .9998* T(u);                                  // dimmer with age\n    for( float l, i=0.; i++ < 50.; ) {\n        P = H(i-iTime); \n        P = .12*(.6+.5*cos(.1*iTime)) * sqrt(-2.*log(P.x)) * cos(6.283*P.y+vec2(0,1.57)); // Gaussian https://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution\n        P += H(i)*R/R.y;\n        l = length(U-P);\n        O = mix( O*(1.-.2*S((l-.01)/6.)), vec4(.5+.5*S(l-.013)), S( l-.015 ) );\n                 // ambient occlusion        circle pattern        mask\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch( iChannel0, ivec2(u), 0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3fzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 103]], "test": "untested"}
{"id": "stcfR8", "name": "Silver fractal knots", "author": "jarble", "description": "Yet another fractal knot pattern.", "tags": ["fractal", "knot"], "likes": 7, "viewed": 274, "published": 3, "date": "1662614936", "time_retrieved": "2024-07-30T16:32:02.440178", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = false;\n    for(int k = 0; k < 12; k++){\n        t3 = uv.x > uv.y || !t3;\n        //t3 = !t3 && uv.x > uv.y || t3 && uv.x < uv.y;\n        //t3 = !(t3 || uv.x < uv.y) && (!t3 || uv.x > uv.y);\n        uv = (.5+uv+t2)/scale+float(!t3)/2.;\n        t2 = triangle_wave(uv+.5);\n        //t2 = abs(t2-.5);\n        //t2 = abs(t2);\n\n        uv = t2-triangle_wave(uv.yx);\n        //uv.x += .5;\n        float c1 = abs(uv.y-uv.x);\n        //c1 = max(c1,t2.x-t2.y);\n        col = vec3(c1,col.yz);\n\n        //col = col.xzy;\n        if(t2.x < t2.y && t3) col = col.yzx;\n        //if(t2.x > t2.y && !t3) col = col.zxy;\n        //if(t2.x*uv.x < t2.y*uv.y) col = col.yzx;\n        //if(t2.x-t2.y > uv.x-uv.y) col = col.yzx;\n\n\n    }\n    fragColor = vec4(abs(col)*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 1112]], "test": "untested"}
{"id": "slcfzr", "name": "ray tracing refraction", "author": "elenzil", "description": "analytic ray tracing rather than SDF-based raymarching.", "tags": ["refraction", "ice", "fresnel", "schlick", "queue"], "likes": 17, "viewed": 344, "published": 3, "date": "1662614406", "time_retrieved": "2024-07-30T16:32:03.621021", "image_code": "void mainImage(out vec4 RGBA, in vec2 XY) {\n\n    ivec2 IJ = ivec2(XY);\n    \n    RGBA.r = texelFetch(iChannel0, IJ, 0).r;\n    RGBA.g = texelFetch(iChannel1, IJ, 0).g;\n    RGBA.b = texelFetch(iChannel2, IJ, 0).b;\n    \n    RGBA.a = 1.0;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst vec3  v0 = vec3(0.0);\nconst vec3  v1 = vec3(1.0);\nconst vec3  vX = vec3(1.0, 0.0, 0.0);\nconst vec3  vY = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ = vec3(0.0, 0.0, 1.0);\nconst float pi = 3.14159265359;\n\n\n//--------------------------------------------------------------------------------\nconst float ior_air     = 1.0003;\nconst float ior_aerogel = 1.03;\nconst float ior_ice     = 1.309;\nconst float ior_water   = 1.333;\nconst float ior_quartz  = 1.46;\nconst float ior_diamond = 2.42;\nconst float ior_shiny1  = 2.756;    // ad hoc\nconst float ior_mirror1 = 7.0;      // ad hoc\n\n// wavelengths in nm\nconst float wl_red = 612.0;\nconst float wl_grn = 549.0;\nconst float wl_blu = 464.0;\n\n\n//--------------------------------------------------------------------------------\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENMTATION.\n// this is a basic ringbuffer.\n// NO ERROR CHECKING\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n\tif (gQHead >= gQTail) {                        \\\n\t\treturn gQHead - gQTail;                    \\\n\t}                                              \\\n\telse {                                         \\\n\t\treturn gQNumSlots - (gQTail - gQHead);     \\\n\t}                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n\treturn gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n\treturn QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n\treturn QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint QEnqueueIndex() {                             \\\n\tgQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint QDequeueIndex() {                             \\\n\tgQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n\tgQ[QEnqueueIndex()] = item;                    \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n\treturn gQ[QDequeueIndex()];                    \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\n\n// returns false if there are no real roots.\n// returns true if there are one or two real roots.\n// roots.x <= roots.y.\nbool solveQuadratic(in vec3 coeffs, out vec2 roots) {\n    const uint A = 0u;\n    const uint B = 1u;\n    const uint C = 2u;\n    \n    // (-B +- sqrt(BB - 4AC)) / 2A\n    \n    float disc = (coeffs[B] * coeffs[B]) - (4.0 * coeffs[A] * coeffs[C]);\n    \n    if (disc < 0.0) {\n        return false;\n    }\n    \n    float sqrt_disc = sqrt(disc);\n    \n    roots.x = (-coeffs[B] - sqrt_disc) / (2.0 * coeffs[A]);\n    roots.y = (-coeffs[B] + sqrt_disc) / (2.0 * coeffs[A]);\n    \n    if (roots.y < roots.x) {\n        roots.xy = roots.yx;\n    }\n    \n    return true;\n}\n\n\n\n//--------------------------------------------------------------------------------\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins. https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.1;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(-pos.y, 0.0)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(vec3 dir, vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(vec3 p, vec3 d, vec3 lightDir)\n{\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d, lightDir) * transmittance(l);\n    float f = 1.0 - d.y / lightDir.y;\n    float l2 = atmosphereDepth(p, lightDir);\n    vec3 sk = simple_sun(lightDir, lightDir) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return clamp(sun + sk, 0.0, 1.0);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n\n// https://en.wikipedia.org/wiki/Cauchy%27s_equation\nfloat cauchyN(in float invWavelengthMicrometersSquared, in float A) {\n    // I can't find a table of Cauchy coefficients,\n    // so just going with something.\n    const float B = 0.015;\n    return A + B * invWavelengthMicrometersSquared;\n}\n\n\n//--------------------------------------------------------------------------------\n", "buffer_a_code": "// Fork of \"water crystals 2\" by elenzil. https://shadertoy.com/view/ftVyzK\n// 2022-09-07 03:51:17\n\n// Fork of \"water crystals 1\" by elenzil. https://shadertoy.com/view/7lVyWw\n// 2022-08-30 04:23:52\n\n#define RES    (iResolution.xy)\n#define MINRES min(RES.x, RES.y)\n\nfloat wavelengthNM = wl_red;\n\n\n// globals\nfloat gT;\nconst float gMinRayContribution =   0.05;\nconst uint  gMaxRays            =  10u;\nconst float gSurfaceEpsilon     =   0.001;\n\n// utils\nmat2 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\nstruct ray3_t {\n    vec3  ro;\n    vec3  rd;\n    float contribution;\n    float side;           // 1 = external -1 = internal\n};\n\n// ringbuffer of rays\n#define Q_TYPE ray3_t\n#define Q_MAX_ENTRIES 10u\nQ_IMPLEMENTATION\n\n\n/////////////////////////////////////////////\n\n\n// business\n\nstruct hit_t {\n    bool  hit;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float t;    // distance along ray\n    float originSide;\n};\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns; // 0 = diffuse 1 = transparent, modulo reflection\n    \n    // reflect            = Schlick()\n    // transmit + diffuse = 1 - reflect\n    // transmit           = difVsTrans * (1 - reflect)\n    // diffuse            = (1 - difVsTrans) * (1 - reflect)\n    //                    = 1 - difVsTrans - reflect + difVsTrans * reflect\n};\n\nconst uint mtl_ball1 = 0u;\nconst uint mtl_ball2 = 1u;\nconst uint mtl_ball3 = 2u;\nconst uint mtl_ball4 = 3u;\nconst uint mtl_floor = 4u;\n\nconst mtl_t materials[] = mtl_t[](\n    mtl_t(ior_aerogel, 0.6),\n    mtl_t(ior_water  , 1.0),\n    mtl_t(ior_diamond, 1.0),\n    mtl_t(ior_mirror1, 0.0),\n    mtl_t(ior_shiny1 , 0.0)\n);\n\n\nvec3 gDebugColor = v0;\n\nvoid rayVsSphere(in ray3_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    hit.originSide = -1.0;\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray3_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }    \n}\n\nvec2 ballPosXY(in float t) {\n    return vec2(cos(t * 3.0) * 3.0, sin(t * 6.0)) * 1.5;\n}\n\n// hit normal is oriented towards \"outside\"\nhit_t rayVsScene(in ray3_t ray) {\n    hit_t hit;\n    hit.t   = 1e9;\n    hit.hit = false;\n    hit.originSide = 1.0;\n    \n    float bR = 0.3;\n    vec3  bP = vec3(ballPosXY(gT), bR + 0.001).xzy;\n    \n    float bt1 = fract(gT * 1.02 + 0.5) * 2.0 - 1.0;\n    float bt2 = fract(gT * 3.0 / pi  ) * 2.0 - 1.0;\n    float bt3 = fract(gT * 1.18 + 0.5) * 2.0 - 1.0;\n    \n    rayVsSphere(ray, -vX * 2.3 + vY * (2.0 - bt1 * bt1), 1.0, mtl_ball1 , hit);\n    rayVsSphere(ray,  vX * 0.0 + vY * (2.0 - bt2 * bt2), 1.0, mtl_ball2 , hit);\n    rayVsSphere(ray,  vX * 2.3 + vY * (2.0 - bt3 * bt3), 1.0, mtl_ball3 , hit);\n    rayVsSphere(ray,  bP                               , bR , mtl_ball4 , hit);\n    rayVsPlane (ray,  vY                               , 0.0, mtl_floor, hit);\n    \n    return hit;\n}\n\nfloat pointSide(in vec3 p) {\n    ray3_t r;\n    r.ro = p;\n    r.rd = vY;\n    hit_t hit = rayVsScene(r);\n    return hit.originSide;\n}\n\n\nvec3 gSunDir;\n\nvec3 sky(ray3_t ray) {\n    return simple_sky(-vY, ray.rd, -gSunDir);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n\n    gT = iTime * 0.3;\n    \n    float zoom   = 3.0;\n    vec2  xy     = vec2(XY - RES/2.0) / MINRES * 2.0 / zoom;\n    \n    vec2  m      = dot(iMouse.xy, iMouse.xy) > 2000.0 ? iMouse.xy : iResolution.xy * 0.5;\n    vec2  mn     = (m - iResolution.xy/2.0) / iResolution.xy * 2.0;\n    \n    vec3 camPos;\n    camPos.y     = max(0.05, 3.1 - mn.y * 6.0 + 2.0 * sin(gT * 0.231));\n    camPos.xz    = vec2(sin(-gT - mn.x * pi * 1.1), cos(-gT - mn.x * pi * 1.1)) * 6.0;\n    vec3  trgPos = vec3(0.0, 1.4, 0.0);\n    \n    vec3 otherTrgPos = vec3(ballPosXY(gT - 0.05), 0.5).xzy;\n    vec3 otherCamPos = vec3(ballPosXY(gT + 0.2),  0.5).xzy;\n    otherCamPos = otherTrgPos + normalize(otherTrgPos - otherCamPos) * 1.5;\n    otherCamPos.y = 0.5;\n    float camMix = smoothstep(0.7, 0.9, sin(gT * 0.21));\n    \n    camPos = mix(camPos, otherCamPos, camMix);\n    trgPos = mix(trgPos, otherTrgPos, camMix);\n    \n    \n    vec3  camFw  = normalize(trgPos - camPos);\n    vec3  camRt  = normalize(cross(camFw, vY) - camMix * vY * camPos.x * 0.05);\n    vec3  camUp  = cross(camRt, camFw);\n    vec3  rd     = normalize(camFw + camRt * xy.x + camUp * xy.y);\n    \n    float lt     = gT * 0.231 - 2.0;\n    gSunDir      = normalize(vec3(cos(lt) * 20.0, -3.0, sin(lt) * 4.0));\n    \n    vec3  col    = vec3(0.0);\n    \n    ray3_t r0;\n    r0.ro           = camPos;\n    r0.rd           = rd;\n    r0.contribution = 1.0;\n    r0.side         = pointSide(camPos);\n    \n    float invWavelengthMicrometersSquared = 1.0 / (wavelengthNM * wavelengthNM * 1e-6);\n    \n    QEnqueue(r0);\n    \n    \n    uint rayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        ray3_t ray = QDequeue();\n        \n        hit_t hit = rayVsScene(ray);\n        \n        if (!hit.hit) {\n            col += ray.contribution * sky(ray);\n            continue;\n        }\n        \n        vec3 hitFacingNormal = hit.nrm * ray.side;\n        \n        mtl_t mtl     = materials[hit.mtl];\n        float ior     = cauchyN(invWavelengthMicrometersSquared, mtl.ior);\n        float R0      = schlickR0(ior, ior_air);\n        float reflAmt = schlick  (R0, dot(ray.rd, -hitFacingNormal));\n        float trnsAmt = mtl.diffVsTrns * (1.0 - reflAmt);\n        float diffAmt = (1.0 - mtl.diffVsTrns) * (1.0 - reflAmt);\n        \n        reflAmt *= ray.contribution;\n        trnsAmt *= ray.contribution;\n        diffAmt *= ray.contribution;\n        \n        \n        if (diffAmt > gMinRayContribution) {\n            \n            vec3 albedo = v1;\n            if (hit.mtl == mtl_floor) {\n                float q = 1.0;\n                \n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.x - 0.5) * pi));\n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.z - 0.5) * pi));\n                \n                albedo *= 0.2 + 0.8 * (1.0 - q);\n            }\n        \n            // shadow\n            ray3_t shadowRay;\n            shadowRay.ro = hit.pnt + hit.nrm * 0.01;\n            shadowRay.rd = -gSunDir;\n            hit_t shadowHit = rayVsScene(shadowRay);\n            float lightAmt = shadowHit.hit ? 0.1 : 1.0;\n\n            col += lightAmt * albedo * diffAmt * max(0.0, dot(hit.nrm, -gSunDir));\n        }\n        \n        bool keepGoing = true;\n        \n        keepGoing = keepGoing && (QSpaceLeft() >= 2u);\n        keepGoing = keepGoing && (rayCount < gMaxRays);\n        keepGoing = keepGoing && ((ray.contribution - diffAmt) > gMinRayContribution);\n        if (!keepGoing) {\n            continue;\n        }\n        \n        rayCount += 1u;\n                \n        if (mtl.diffVsTrns > 0.001) {\n            float eta = ior_air / ior;\n            if (ray.side < 0.0) {\n                eta = 1.0 / eta;\n            }\n            vec3 transmtRd       = refract(ray.rd, hitFacingNormal, eta);\n            // we don't check total internal because it's not possible\n            // for a ray which was originally outside the sphere.\n            if (trnsAmt > gMinRayContribution) {\n                ray3_t transmtRay        = ray;\n                transmtRay.contribution  = trnsAmt;\n                transmtRay.rd            = transmtRd;\n                transmtRay.side         *= -1.0;\n                transmtRay.ro            = hit.pnt - hitFacingNormal * gSurfaceEpsilon;\n                QEnqueue(transmtRay);\n            }\n        }\n\n        if (reflAmt > gMinRayContribution) {\n            ray3_t reflectRay;\n            reflectRay.contribution  = reflAmt;\n            reflectRay.ro            = hit.pnt + hitFacingNormal * gSurfaceEpsilon;\n            reflectRay.rd            = reflect(ray.rd, hit.nrm);\n            reflectRay.side          = ray.side;\n            QEnqueue(reflectRay);\n        }\n    }\n\n    // boost darker colors\n    col = pow(col, vec3(1.0/1.7));\n     \n    // col = col + gDebugColor;\n \n    RGBA = vec4(vec3(col), float(rayCount));\n}", "buffer_a_inputs": [], "buffer_b_code": "// Fork of \"water crystals 2\" by elenzil. https://shadertoy.com/view/ftVyzK\n// 2022-09-07 03:51:17\n\n// Fork of \"water crystals 1\" by elenzil. https://shadertoy.com/view/7lVyWw\n// 2022-08-30 04:23:52\n\n#define RES    (iResolution.xy)\n#define MINRES min(RES.x, RES.y)\n\nfloat wavelengthNM = wl_grn;\n\n\n// globals\nfloat gT;\nconst float gMinRayContribution =   0.05;\nconst uint  gMaxRays            =  10u;\nconst float gSurfaceEpsilon     =   0.001;\n\n// utils\nmat2 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\nstruct ray3_t {\n    vec3  ro;\n    vec3  rd;\n    float contribution;\n    float side;           // 1 = external -1 = internal\n};\n\n// ringbuffer of rays\n#define Q_TYPE ray3_t\n#define Q_MAX_ENTRIES 10u\nQ_IMPLEMENTATION\n\n\n/////////////////////////////////////////////\n\n\n// business\n\nstruct hit_t {\n    bool  hit;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float t;    // distance along ray\n    float originSide;\n};\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns; // 0 = diffuse 1 = transparent, modulo reflection\n    \n    // reflect            = Schlick()\n    // transmit + diffuse = 1 - reflect\n    // transmit           = difVsTrans * (1 - reflect)\n    // diffuse            = (1 - difVsTrans) * (1 - reflect)\n    //                    = 1 - difVsTrans - reflect + difVsTrans * reflect\n};\n\nconst uint mtl_ball1 = 0u;\nconst uint mtl_ball2 = 1u;\nconst uint mtl_ball3 = 2u;\nconst uint mtl_ball4 = 3u;\nconst uint mtl_floor = 4u;\n\nconst mtl_t materials[] = mtl_t[](\n    mtl_t(ior_aerogel, 0.6),\n    mtl_t(ior_water  , 1.0),\n    mtl_t(ior_diamond, 1.0),\n    mtl_t(ior_mirror1, 0.0),\n    mtl_t(ior_shiny1 , 0.0)\n);\n\n\nvec3 gDebugColor = v0;\n\nvoid rayVsSphere(in ray3_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    hit.originSide = -1.0;\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray3_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }    \n}\n\nvec2 ballPosXY(in float t) {\n    return vec2(cos(t * 3.0) * 3.0, sin(t * 6.0)) * 1.5;\n}\n\n// hit normal is oriented towards \"outside\"\nhit_t rayVsScene(in ray3_t ray) {\n    hit_t hit;\n    hit.t   = 1e9;\n    hit.hit = false;\n    hit.originSide = 1.0;\n    \n    float bR = 0.3;\n    vec3  bP = vec3(ballPosXY(gT), bR + 0.001).xzy;\n    \n    float bt1 = fract(gT * 1.02 + 0.5) * 2.0 - 1.0;\n    float bt2 = fract(gT * 3.0 / pi  ) * 2.0 - 1.0;\n    float bt3 = fract(gT * 1.18 + 0.5) * 2.0 - 1.0;\n    \n    rayVsSphere(ray, -vX * 2.3 + vY * (2.0 - bt1 * bt1), 1.0, mtl_ball1 , hit);\n    rayVsSphere(ray,  vX * 0.0 + vY * (2.0 - bt2 * bt2), 1.0, mtl_ball2 , hit);\n    rayVsSphere(ray,  vX * 2.3 + vY * (2.0 - bt3 * bt3), 1.0, mtl_ball3 , hit);\n    rayVsSphere(ray,  bP                               , bR , mtl_ball4 , hit);\n    rayVsPlane (ray,  vY                               , 0.0, mtl_floor, hit);\n    \n    return hit;\n}\n\nfloat pointSide(in vec3 p) {\n    ray3_t r;\n    r.ro = p;\n    r.rd = vY;\n    hit_t hit = rayVsScene(r);\n    return hit.originSide;\n}\n\n\nvec3 gSunDir;\n\nvec3 sky(ray3_t ray) {\n    return simple_sky(-vY, ray.rd, -gSunDir);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n\n    gT = iTime * 0.3;\n    \n    float zoom   = 3.0;\n    vec2  xy     = vec2(XY - RES/2.0) / MINRES * 2.0 / zoom;\n    \n    vec2  m      = dot(iMouse.xy, iMouse.xy) > 2000.0 ? iMouse.xy : iResolution.xy * 0.5;\n    vec2  mn     = (m - iResolution.xy/2.0) / iResolution.xy * 2.0;\n    \n    vec3 camPos;\n    camPos.y     = max(0.05, 3.1 - mn.y * 6.0 + 2.0 * sin(gT * 0.231));\n    camPos.xz    = vec2(sin(-gT - mn.x * pi * 1.1), cos(-gT - mn.x * pi * 1.1)) * 6.0;\n    vec3  trgPos = vec3(0.0, 1.4, 0.0);\n    \n    vec3 otherTrgPos = vec3(ballPosXY(gT - 0.05), 0.5).xzy;\n    vec3 otherCamPos = vec3(ballPosXY(gT + 0.2),  0.5).xzy;\n    otherCamPos = otherTrgPos + normalize(otherTrgPos - otherCamPos) * 1.5;\n    otherCamPos.y = 0.5;\n    float camMix = smoothstep(0.7, 0.9, sin(gT * 0.21));\n    \n    camPos = mix(camPos, otherCamPos, camMix);\n    trgPos = mix(trgPos, otherTrgPos, camMix);\n    \n    \n    vec3  camFw  = normalize(trgPos - camPos);\n    vec3  camRt  = normalize(cross(camFw, vY) - camMix * vY * camPos.x * 0.05);\n    vec3  camUp  = cross(camRt, camFw);\n    vec3  rd     = normalize(camFw + camRt * xy.x + camUp * xy.y);\n    \n    float lt     = gT * 0.231 - 2.0;\n    gSunDir      = normalize(vec3(cos(lt) * 20.0, -3.0, sin(lt) * 4.0));\n    \n    vec3  col    = vec3(0.0);\n    \n    ray3_t r0;\n    r0.ro           = camPos;\n    r0.rd           = rd;\n    r0.contribution = 1.0;\n    r0.side         = pointSide(camPos);\n    \n    float invWavelengthMicrometersSquared = 1.0 / (wavelengthNM * wavelengthNM * 1e-6);\n    \n    QEnqueue(r0);\n    \n    \n    uint rayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        ray3_t ray = QDequeue();\n        \n        hit_t hit = rayVsScene(ray);\n        \n        if (!hit.hit) {\n            col += ray.contribution * sky(ray);\n            continue;\n        }\n        \n        vec3 hitFacingNormal = hit.nrm * ray.side;\n        \n        mtl_t mtl     = materials[hit.mtl];\n        float ior     = cauchyN(invWavelengthMicrometersSquared, mtl.ior);\n        float R0      = schlickR0(ior, ior_air);\n        float reflAmt = schlick  (R0, dot(ray.rd, -hitFacingNormal));\n        float trnsAmt = mtl.diffVsTrns * (1.0 - reflAmt);\n        float diffAmt = (1.0 - mtl.diffVsTrns) * (1.0 - reflAmt);\n        \n        reflAmt *= ray.contribution;\n        trnsAmt *= ray.contribution;\n        diffAmt *= ray.contribution;\n        \n        \n        if (diffAmt > gMinRayContribution) {\n            \n            vec3 albedo = v1;\n            if (hit.mtl == mtl_floor) {\n                float q = 1.0;\n                \n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.x - 0.5) * pi));\n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.z - 0.5) * pi));\n                \n                albedo *= 0.2 + 0.8 * (1.0 - q);\n            }\n        \n            // shadow\n            ray3_t shadowRay;\n            shadowRay.ro = hit.pnt + hit.nrm * 0.01;\n            shadowRay.rd = -gSunDir;\n            hit_t shadowHit = rayVsScene(shadowRay);\n            float lightAmt = shadowHit.hit ? 0.1 : 1.0;\n\n            col += lightAmt * albedo * diffAmt * max(0.0, dot(hit.nrm, -gSunDir));\n        }\n        \n        bool keepGoing = true;\n        \n        keepGoing = keepGoing && (QSpaceLeft() >= 2u);\n        keepGoing = keepGoing && (rayCount < gMaxRays);\n        keepGoing = keepGoing && ((ray.contribution - diffAmt) > gMinRayContribution);\n        if (!keepGoing) {\n            continue;\n        }\n        \n        rayCount += 1u;\n                \n        if (mtl.diffVsTrns > 0.001) {\n            float eta = ior_air / ior;\n            if (ray.side < 0.0) {\n                eta = 1.0 / eta;\n            }\n            vec3 transmtRd       = refract(ray.rd, hitFacingNormal, eta);\n            // we don't check total internal because it's not possible\n            // for a ray which was originally outside the sphere.\n            if (trnsAmt > gMinRayContribution) {\n                ray3_t transmtRay        = ray;\n                transmtRay.contribution  = trnsAmt;\n                transmtRay.rd            = transmtRd;\n                transmtRay.side         *= -1.0;\n                transmtRay.ro            = hit.pnt - hitFacingNormal * gSurfaceEpsilon;\n                QEnqueue(transmtRay);\n            }\n        }\n\n        if (reflAmt > gMinRayContribution) {\n            ray3_t reflectRay;\n            reflectRay.contribution  = reflAmt;\n            reflectRay.ro            = hit.pnt + hitFacingNormal * gSurfaceEpsilon;\n            reflectRay.rd            = reflect(ray.rd, hit.nrm);\n            reflectRay.side          = ray.side;\n            QEnqueue(reflectRay);\n        }\n    }\n\n    // boost darker colors\n    col = pow(col, vec3(1.0/1.7));\n     \n    // col = col + gDebugColor;\n    \n    RGBA = vec4(vec3(col), float(rayCount));\n}", "buffer_b_inputs": [], "buffer_c_code": "// Fork of \"water crystals 2\" by elenzil. https://shadertoy.com/view/ftVyzK\n// 2022-09-07 03:51:17\n\n// Fork of \"water crystals 1\" by elenzil. https://shadertoy.com/view/7lVyWw\n// 2022-08-30 04:23:52\n\n#define RES    (iResolution.xy)\n#define MINRES min(RES.x, RES.y)\n\nfloat wavelengthNM = wl_blu;\n\n\n// globals\nfloat gT;\nconst float gMinRayContribution =   0.05;\nconst uint  gMaxRays            =  10u;\nconst float gSurfaceEpsilon     =   0.001;\n\n// utils\nmat2 rot(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\nstruct ray3_t {\n    vec3  ro;\n    vec3  rd;\n    float contribution;\n    float side;           // 1 = external -1 = internal\n};\n\n// ringbuffer of rays\n#define Q_TYPE ray3_t\n#define Q_MAX_ENTRIES 10u\nQ_IMPLEMENTATION\n\n\n/////////////////////////////////////////////\n\n\n// business\n\nstruct hit_t {\n    bool  hit;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float t;    // distance along ray\n    float originSide;\n};\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns; // 0 = diffuse 1 = transparent, modulo reflection\n    \n    // reflect            = Schlick()\n    // transmit + diffuse = 1 - reflect\n    // transmit           = difVsTrans * (1 - reflect)\n    // diffuse            = (1 - difVsTrans) * (1 - reflect)\n    //                    = 1 - difVsTrans - reflect + difVsTrans * reflect\n};\n\nconst uint mtl_ball1 = 0u;\nconst uint mtl_ball2 = 1u;\nconst uint mtl_ball3 = 2u;\nconst uint mtl_ball4 = 3u;\nconst uint mtl_floor = 4u;\n\nconst mtl_t materials[] = mtl_t[](\n    mtl_t(ior_aerogel, 0.6),\n    mtl_t(ior_water  , 1.0),\n    mtl_t(ior_diamond, 1.0),\n    mtl_t(ior_mirror1, 0.0),\n    mtl_t(ior_shiny1 , 0.0)\n);\n\n\nvec3 gDebugColor = v0;\n\nvoid rayVsSphere(in ray3_t ray, in vec3 c, float r, uint mtl, inout hit_t hit) {\n    \n    vec3 ro = ray.ro - c;\n    vec3 rd = ray.rd;\n\n    float A = dot(rd, rd);\n    float B = dot(ro, rd) * 2.0;\n    float C = dot(ro, ro) - (r * r);\n    \n    vec2 roots;\n    if (!solveQuadratic(vec3(A, B, C), roots)) {\n        return;\n    }\n    \n    if (roots.y < 0.0) {\n        // both hits are before the start of the ray\n        return;\n    }\n    \n    if (roots.x > 0.0) {\n        if (roots.x > hit.t) {\n            return;\n        }\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.x;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n    \n    hit.originSide = -1.0;\n    \n    if (roots.y < hit.t) {\n        // good hit\n        hit.hit = true;\n        hit.t   = roots.y;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = (hit.pnt - c) / r;\n        return;\n    }\n}\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray3_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }    \n}\n\nvec2 ballPosXY(in float t) {\n    return vec2(cos(t * 3.0) * 3.0, sin(t * 6.0)) * 1.5;\n}\n\n// hit normal is oriented towards \"outside\"\nhit_t rayVsScene(in ray3_t ray) {\n    hit_t hit;\n    hit.t   = 1e9;\n    hit.hit = false;\n    hit.originSide = 1.0;\n    \n    float bR = 0.3;\n    vec3  bP = vec3(ballPosXY(gT), bR + 0.001).xzy;\n    \n    float bt1 = fract(gT * 1.02 + 0.5) * 2.0 - 1.0;\n    float bt2 = fract(gT * 3.0 / pi  ) * 2.0 - 1.0;\n    float bt3 = fract(gT * 1.18 + 0.5) * 2.0 - 1.0;\n    \n    rayVsSphere(ray, -vX * 2.3 + vY * (2.0 - bt1 * bt1), 1.0, mtl_ball1 , hit);\n    rayVsSphere(ray,  vX * 0.0 + vY * (2.0 - bt2 * bt2), 1.0, mtl_ball2 , hit);\n    rayVsSphere(ray,  vX * 2.3 + vY * (2.0 - bt3 * bt3), 1.0, mtl_ball3 , hit);\n    rayVsSphere(ray,  bP                               , bR , mtl_ball4 , hit);\n    rayVsPlane (ray,  vY                               , 0.0, mtl_floor, hit);\n    \n    return hit;\n}\n\nfloat pointSide(in vec3 p) {\n    ray3_t r;\n    r.ro = p;\n    r.rd = vY;\n    hit_t hit = rayVsScene(r);\n    return hit.originSide;\n}\n\n\nvec3 gSunDir;\n\nvec3 sky(ray3_t ray) {\n    return simple_sky(-vY, ray.rd, -gSunDir);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n\n    gT = iTime * 0.3;\n    \n    float zoom   = 3.0;\n    vec2  xy     = vec2(XY - RES/2.0) / MINRES * 2.0 / zoom;\n    \n    vec2  m      = dot(iMouse.xy, iMouse.xy) > 2000.0 ? iMouse.xy : iResolution.xy * 0.5;\n    vec2  mn     = (m - iResolution.xy/2.0) / iResolution.xy * 2.0;\n    \n    vec3 camPos;\n    camPos.y     = max(0.05, 3.1 - mn.y * 6.0 + 2.0 * sin(gT * 0.231));\n    camPos.xz    = vec2(sin(-gT - mn.x * pi * 1.1), cos(-gT - mn.x * pi * 1.1)) * 6.0;\n    vec3  trgPos = vec3(0.0, 1.4, 0.0);\n    \n    vec3 otherTrgPos = vec3(ballPosXY(gT - 0.05), 0.5).xzy;\n    vec3 otherCamPos = vec3(ballPosXY(gT + 0.2),  0.5).xzy;\n    otherCamPos = otherTrgPos + normalize(otherTrgPos - otherCamPos) * 1.5;\n    otherCamPos.y = 0.5;\n    float camMix = smoothstep(0.7, 0.9, sin(gT * 0.21));\n    \n    camPos = mix(camPos, otherCamPos, camMix);\n    trgPos = mix(trgPos, otherTrgPos, camMix);\n    \n    \n    vec3  camFw  = normalize(trgPos - camPos);\n    vec3  camRt  = normalize(cross(camFw, vY) - camMix * vY * camPos.x * 0.05);\n    vec3  camUp  = cross(camRt, camFw);\n    vec3  rd     = normalize(camFw + camRt * xy.x + camUp * xy.y);\n    \n    float lt     = gT * 0.231 - 2.0;\n    gSunDir      = normalize(vec3(cos(lt) * 20.0, -3.0, sin(lt) * 4.0));\n    \n    vec3  col    = vec3(0.0);\n    \n    ray3_t r0;\n    r0.ro           = camPos;\n    r0.rd           = rd;\n    r0.contribution = 1.0;\n    r0.side         = pointSide(camPos);\n    \n    float invWavelengthMicrometersSquared = 1.0 / (wavelengthNM * wavelengthNM * 1e-6);\n    \n    QEnqueue(r0);\n    \n    \n    uint rayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        ray3_t ray = QDequeue();\n        \n        hit_t hit = rayVsScene(ray);\n        \n        if (!hit.hit) {\n            col += ray.contribution * sky(ray);\n            continue;\n        }\n        \n        vec3 hitFacingNormal = hit.nrm * ray.side;\n        \n        mtl_t mtl     = materials[hit.mtl];\n        float ior     = cauchyN(invWavelengthMicrometersSquared, mtl.ior);\n        float R0      = schlickR0(ior, ior_air);\n        float reflAmt = schlick  (R0, dot(ray.rd, -hitFacingNormal));\n        float trnsAmt = mtl.diffVsTrns * (1.0 - reflAmt);\n        float diffAmt = (1.0 - mtl.diffVsTrns) * (1.0 - reflAmt);\n        \n        reflAmt *= ray.contribution;\n        trnsAmt *= ray.contribution;\n        diffAmt *= ray.contribution;\n        \n        \n        if (diffAmt > gMinRayContribution) {\n            \n            vec3 albedo = v1;\n            if (hit.mtl == mtl_floor) {\n                float q = 1.0;\n                \n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.x - 0.5) * pi));\n                q *= smoothstep(-0.05, 0.05, sin((hit.pnt.z - 0.5) * pi));\n                \n                albedo *= 0.2 + 0.8 * (1.0 - q);\n            }\n        \n            // shadow\n            ray3_t shadowRay;\n            shadowRay.ro = hit.pnt + hit.nrm * 0.01;\n            shadowRay.rd = -gSunDir;\n            hit_t shadowHit = rayVsScene(shadowRay);\n            float lightAmt = shadowHit.hit ? 0.1 : 1.0;\n\n            col += lightAmt * albedo * diffAmt * max(0.0, dot(hit.nrm, -gSunDir));\n        }\n        \n        bool keepGoing = true;\n        \n        keepGoing = keepGoing && (QSpaceLeft() >= 2u);\n        keepGoing = keepGoing && (rayCount < gMaxRays);\n        keepGoing = keepGoing && ((ray.contribution - diffAmt) > gMinRayContribution);\n        if (!keepGoing) {\n            continue;\n        }\n        \n        rayCount += 1u;\n                \n        if (mtl.diffVsTrns > 0.001) {\n            float eta = ior_air / ior;\n            if (ray.side < 0.0) {\n                eta = 1.0 / eta;\n            }\n            vec3 transmtRd       = refract(ray.rd, hitFacingNormal, eta);\n            // we don't check total internal because it's not possible\n            // for a ray which was originally outside the sphere.\n            if (trnsAmt > gMinRayContribution) {\n                ray3_t transmtRay        = ray;\n                transmtRay.contribution  = trnsAmt;\n                transmtRay.rd            = transmtRd;\n                transmtRay.side         *= -1.0;\n                transmtRay.ro            = hit.pnt - hitFacingNormal * gSurfaceEpsilon;\n                QEnqueue(transmtRay);\n            }\n        }\n\n        if (reflAmt > gMinRayContribution) {\n            ray3_t reflectRay;\n            reflectRay.contribution  = reflAmt;\n            reflectRay.ro            = hit.pnt + hitFacingNormal * gSurfaceEpsilon;\n            reflectRay.rd            = reflect(ray.rd, hit.nrm);\n            reflectRay.side          = ray.side;\n            QEnqueue(reflectRay);\n        }\n    }\n\n    // boost darker colors\n    col = pow(col, vec3(1.0/1.7));\n     \n    // col = col + gDebugColor;\n    \n    RGBA = vec4(vec3(col), float(rayCount));\n}", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcfzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 235]], "test": "untested"}
{"id": "7t3fR8", "name": "Red and gold rug 2", "author": "jarble", "description": "A simple rug pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 6, "viewed": 215, "published": 3, "date": "1662613964", "time_retrieved": "2024-07-30T16:32:04.380989", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = false;\n    for(int k = 0; k < 9; k++){\n        t3 = uv.x > uv.y || !t3;\n        //t3 = !t3 && uv.x > uv.y || t3 && uv.x < uv.y;\n        //t3 = !(t3 || uv.x < uv.y) && (!t3 || uv.x > uv.y);\n        uv = (uv+t2)/scale;\n        t2 = triangle_wave(uv+.5);\n        //t2 = abs(t2);\n\n        uv = t2-triangle_wave(uv.yx);\n        float c1 = uv.y-uv.x;\n        //c1 = max(c1,t2.x-t2.y);\n        col = vec3(c1,col.yz);\n\n        //col = col.xzy;\n        if(t2.x < t2.y && t3) col = col.yzx;\n        //if(t2.x > t2.y && !t3) col = col.zxy;\n        //if(t2.x*uv.x < t2.y*uv.y) col = col.yzx;\n        //if(t2.x-t2.y > uv.x-uv.y) col = col.yzx;\n\n\n    }\n    fragColor = vec4(abs(col)*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3fR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 1040]], "test": "untested"}
{"id": "fl3fzr", "name": "Euler Tangles", "author": "fenix", "description": "This is a new kind of particle system for me, with each particle \"owned\" by a screen pixel. Cell particle state is stored in a single vec4 in buffer A. Click with mouse to control spiral parameters.\n*space to reset*\n*mouse to modify particle trajectories*", "tags": ["2d", "particles", "abstract", "squiggles", "eulerspiral"], "likes": 21, "viewed": 376, "published": 3, "date": "1662600135", "time_retrieved": "2024-07-30T16:32:05.189826", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  This is a new kind of particle system for me, with each screen pixel remembering the\n//  velocity, color, density, etc, of any particle within it, packed into a single vec4\n//  using packSnorm2x16.\n//\n//  There is no (intentional) interaction between particles, and when particles collide, all\n//  but one of them simply disappear, currently. Those might be subjects for future upgrades.\n//\n//  I believe these squiggles are a sort of Euler spiral. With these settings it starts\n//  to look like tangled psychadelic hair, hence the name, Euler Tangles.\n// \n// ---------------------------------------------------------------------------------------\n\nvec3 floatToColor(float f)\n{\n    return normalize(sin((f + iTime * .1) * vec3(9,10,14)) * 0.5 + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    cellData d = unpackCell(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    \n    fragColor = vec4(floatToColor(d.color) * d.trailDensity, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A updates a compressed cellData per pixel\n\n// Particles die after this many frames\nconst float MAX_AGE = 400.0;\n\n// Particles are created each frame on each pixel with this probability\nconst float SPAWN_PROBABILITY = 5e-6;\n\n// Bigger RANGE makes larger velocities possible, but starts to be prohibitively expensive\nconst int RANGE = 4;\n\n// Control particle rendering into the trail buffer\nconst float MIN_SIZE = 0.1;\nconst float MAX_SIZE = 1.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel0, ivec2(0), 0);\n    \n    if (ifc == ivec2(0))\n    {\n        // Reset if resolution doesn't match\n        if (iFrame == 0 || abs(state.xy) != iResolution.xy || keyDown(KEY_SPACE))\n        {\n            fragColor = vec4(-iResolution.xy, vec2(.5));\n        }\n        else\n        {\n            if (iMouse.z > 0.)\n            {\n                state.zw = iMouse.xy / iResolution.xy;\n            }\n            \n            fragColor = vec4(abs(state.xy), state.zw);\n        }\n        return;\n    }\n    \n    float h = hash(\n        ifc.x + \n        ifc.y*int(iResolution.x) + \n        iFrame*int(iResolution.x*iResolution.y)\n    );\n    \n    if (iFrame == 0 || state.x < 0.)\n    {\n        // Clear buffer\n        cellData init;\n        init.pos = vec2(0.5, 0.5);\n        init.vel = vec2(0);\n        init.density = 0.0;\n        init.trailDensity = 0.0;\n        init.color = 0.0;\n        init.age = 0.0;\n        \n        fragColor = packCell(init);\n\n        return;\n    }\n    \n    if (h > 1. - SPAWN_PROBABILITY)\n    {\n        // Spawn new particle\n        float h1 = hash(\n            ifc.x*int(iResolution.x) + \n            ifc.y*int(iResolution.y) + \n            iFrame*int(iResolution.x*iResolution.y)\n        );\n\n        float h2 = hash(int(h1*994888228.));\n        float h3 = hash(int(h2*4343555.));\n        float h4 = hash(int(h3*84999223.));\n\n        cellData newParticle;\n        newParticle.pos = vec2(0.5, 0.5); // Start in the middle of the cell\n        newParticle.vel = vec2(h1 - 0.5, h2 - 0.5);\n        newParticle.density = 1.0;\n        newParticle.trailDensity = 1.0;\n        newParticle.color = h3;\n        newParticle.age = h4;\n        \n        fragColor = packCell(newParticle);\n    }\n    else\n    {\n        float newDensity = 0.;\n        vec2 newVel = vec2(0), newPos = vec2(0);\n        cellData d = unpackCell(texelFetch(iChannel0, ivec2(fragCoord), 0));\n\n        // Search the nearest NxN cells to find any that has density that wants to move into our cell\n        for (int x = -RANGE; x <= RANGE; ++x)\n        {\n            for (int y = -RANGE; y <= RANGE; ++y)\n            {\n                if (ifc.x + x < 0 || ifc.x + x >= int(iResolution.x)) continue;\n                if (ifc.y + y < 0 || ifc.y + y >= int(iResolution.y)) continue;\n\n                cellData nb = unpackCell(texelFetch(iChannel0, ivec2(fragCoord) + ivec2(x, y), 0));\n\n                vec2 nbPos = nb.pos + vec2(x, y);\n                vec2 newNbPos = nbPos + nb.vel * float(RANGE);\n\n                if (nb.density > 0. && nb.age < 1.0) // Note: also rejecting particles here thar are too old\n                {\n                    // Draw smooth line from old position to new, even if it jumped past our position\n                    float aa = smoothstep(MAX_SIZE, MIN_SIZE, linePointDist(fragCoord + newNbPos, fragCoord + nbPos, fragCoord));\n                    \n                    // Use full color if we're drawing on black\n                    d.color = d.trailDensity < .2 || aa > .2 ? nb.color : d.color;\n                    d.trailDensity += aa;\n                    \n                    if (all(greaterThan(newNbPos, vec2(0))) && all(lessThan(newNbPos, vec2(1))))\n                    {\n                        newPos = newNbPos;\n                        newVel = nb.vel;\n                        newDensity = 1.;\n\n                        // Apply some rotation to make the spirals\n                        newVel = rot2(0.2*sin(nb.age * 50. * state.w) + nb.age * 0.1 * state.z) * newVel;\n                    \n                        d.age = nb.age;\n                        d.color = nb.color; // Copy over the whole color so it doesnt get lost even with thin lines\n                    }\n                }\n            }\n        }\n\n        // Record data in fragColor\n        d.pos = newPos;\n        d.vel = newVel;\n        d.density = min(1., newDensity);\n        d.trailDensity *= 0.995; // Fade out old density to keep the display from becoming too busy\n        d.age += 1. / MAX_AGE;\n\n        fragColor = packCell(d);\n    }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pack2(vec2 v)\n{\n    return uintBitsToFloat(packSnorm2x16(v));\n}\n\nvec2 unpack2(float f)\n{\n    return unpackSnorm2x16(floatBitsToUint(f));\n}\n\nstruct cellData\n{\n    vec2 pos;           // 0 ... 1, position within the cell\n    vec2 vel;           // -1 ... 1, multiplied by RANGE\n    float density;      // either 0 or 1, depending on if a particle is present\n    float trailDensity; // 0 ... 1, allows particles to leave trails behind\n    float color;        // 0 ... 1, color of trail\n    float age;          // 0 ... 1, particles die at age 1\n};\n\ncellData unpackCell(vec4 c)\n{\n    cellData d;\n    \n    d.pos = unpack2(c.x);\n    d.vel = unpack2(c.y);\n    vec2 den = unpack2(c.z);\n    d.density = den.x;\n    d.trailDensity = den.y;\n    vec2 colorAge = unpack2(c.w);\n    d.color = colorAge.x;\n    d.age = colorAge.y;\n    \n    return d;\n}\n\nvec4 packCell(cellData d)\n{\n    float x = pack2(d.pos);\n    float y = pack2(d.vel);\n    float z = pack2(vec2(d.density, d.trailDensity));\n    float w = pack2(vec2(d.color, d.age));\n    \n    return vec4(x, y, z, w);\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nmat2 rot2(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat linePointDist(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    vec2 closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        // Line is very short; either end will do\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    return distance(closest, fragCoord);\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3fzr.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[862, 862, 890, 890, 965], [967, 967, 1024, 1024, 1169]], "test": "untested"}
{"id": "7tVyz3", "name": "Pi Condition", "author": "wyatt", "description": "If you split a distance pi from the geometry, no cell has more than two adjacent cells. All cells are connected to cells that only differ by 1 or 0 levels.", "tags": ["quadtree"], "likes": 34, "viewed": 368, "published": 3, "date": "1662578275", "time_retrieved": "2024-07-30T16:32:06.033570", "image_code": "#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat map (vec2 u) {\n    u+= 1.;\n    for (float i = 0.; i < 5.; i++) \n        u=(u-exp(-.9*i))*ei(iTime),\n        u = abs(u);\n    return abs(length(u)-.05);\n}\nMain {\n    U = 2.*(U-.5*R)/R.y;\n    Q = vec4(.1);\n    \n    vec2 u = floor(U)+.5;\n    float s = 1.;\n    for (float i = 0.; i < 10.; i++) {\n        vec2 v = abs(U-u)-.5*s;\n        Q -= smoothstep(-2./R.y,0.,max(v.y,v.x));\n        s *= 0.5;\n        if (map(u)/s>3.1)break;\n        u = floor(U/s)*s+.5*s;\n        Q += .15;\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVyz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 69, 69, 207]], "test": "untested"}
{"id": "7ltBRr", "name": "illusory colors", "author": "FabriceNeyret2", "description": "reference: [url]https://twitter.com/gsarcone/status/1567532021257216003[/url]\nThere is NO yellow, nor red, nor green in this picture. Only colors are blue, cyan, magenta ( + B&W )\n\nyou can change strip size line #10", "tags": ["color", "illusion", "2tweets", "perception", "short", "golf"], "likes": 11, "viewed": 336, "published": 3, "date": "1662572443", "time_retrieved": "2024-07-30T16:32:06.939149", "image_code": "// 269\n\n#define D(x,y) length( U - vec2(x,y)/3. ) < .5   // distance to disk(x,y)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;   \n                //      / strip_size\n    O.rgb   = int(u-.5) / 1 % 2 < 1              // vertical strips\n               ? D(-.8,.5) ?                     // left disk\n                              D(0,-1) ? vec3(0,0,1)  : vec3(0,1,1)  \n               : D( 0, -1) ?                     // bottom disk\n                              vec3(1,0,1) : vec3(1)\n               : D( .8,.5) ?                     // right disk ( only one acting on odd strips )\n                              vec3(0) : vec3(0,0,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ltBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 121, 121, 691]], "test": "untested"}
{"id": "fltBzn", "name": "Circle Stacks", "author": "FabriceNeyret2", "description": "WIP. not the same look for now.\ninsipration: [url] https://twitter.com/DonKarlssonSan/status/1567193595530076160 [/url]", "tags": ["2d", "short", "reproduction"], "likes": 10, "viewed": 296, "published": 3, "date": "1662536750", "time_retrieved": "2024-07-30T16:32:07.796856", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    O = T(u);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define H(p)  fract(sin((p)* vec2(12.9898, 78.233)) * 43758.5453)\n#define S(v)   smoothstep( 1.5/R.y, 0., clamp(v,0.,1.) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u / R.y, P;\n    O =  .998 * T(u);                                  // dimmer with age\n    for( float l, i=0.; i++ < 50.; ) {\n        l = length( P = H(i-iTime)-.5 );   P *= l*l*l; //  1/l⁴ law \n     // P = H(i-iTime); P = .04*sqrt(-2.*log(P.x)) * cos(6.283*P.y+vec2(0,1.57)); // Gaussian https://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution\n        P += H(i)*R/R.y;\n        l = length(U-P);\n        O = mix( O*(1.-.2*S((l-.01)/6.)), vec4(.5+.5*S(l-.013)), S( l-.015 ) );\n                 // ambient occlusion        circle pattern        mask\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(u) texelFetch( iChannel0, ivec2(u), 0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 54]], "test": "untested"}
{"id": "stcfzn", "name": "Oriented Box - distance 2D", "author": "iq", "description": "Distance to an oriented box, or square line segment if you want. Mouse click and drag to see unbounding sphere", "tags": ["2d", "distancefield", "sdf", "circle", "distance", "box", "oriented"], "likes": 31, "viewed": 4669, "published": 3, "date": "1662526920", "time_retrieved": "2024-07-30T16:32:08.799176", "image_code": "// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an oriented box.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l*0.5,th);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n    // animation\n    vec2 v1 = cos( iTime*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2 v2 = cos( iTime*0.5 + vec2(0.0,3.00) + 1.5 );\n    float th = 0.3*(0.5+0.5*cos(iTime*1.1+1.0));\n\n\tfloat d = sdOrientedBox( p, v1, v2, th );\n\n    // distance\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdOrientedBox(m, v1, v2, th);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stcfzn.jpg", "access": "api", "license": "mit", "functions": [[1241, 1241, 1307, 1307, 1522], [1524, 1524, 1581, 1617, 2482]], "test": "untested"}
{"id": "NldBRn", "name": "sdf text atlas test", "author": "jcyuan", "description": "sdf text test", "tags": ["sdftextatlas"], "likes": 4, "viewed": 310, "published": 3, "date": "1662526422", "time_retrieved": "2024-07-30T16:32:10.044845", "image_code": "vec4 charLUT(in vec2 p, in int c) {\n    p.y += .5;\n    vec2 range = step(vec2(0.), p) * step(p, vec2(1.));\n    float check = range.x * range.y;\n    if (check == 0.) return vec4(vec3(0.), 1e+3);\n    vec2 o = p / 16.;\n\treturn textureGrad(iChannel0, o + fract(vec2(c, 15 - c / 16) / 16.), dFdx(o), dFdy(o));\n}\n\nvec4 _tmpChrVal;\nfloat charSpacing = .5;\nvec2 textUv;\nvec4 textOutput;\n\nvoid reset() {\n    _tmpChrVal = vec4(vec3(0.), 1e+3);\n    textUv = vec2(0);\n    textOutput = vec4(vec3(0), 1e+3);    \n}\n\nfloat getWold1(in vec2 p, float size) {\n    reset();\n    textUv = p * 64. / size;\n    textUv.x += 13.5 * charSpacing * .5;\n    \n    _H _e _l _l _o _space _W _o _r _l _d _exc\n    \n    return textOutput.w;\n}\n\nfloat getWold2(in vec2 p, float size) {\n    reset();\n    textUv = p * 64. / size;\n    textUv.x += 17.5 * charSpacing * .5;\n    \n    _I _space _a _m _space _a _space _t _e _x _t _space _t _e _s _t _exc\n    \n    return textOutput.w;\n}\n\nfloat timeSpan(float t, float from, float to) {\n    return clamp((t - from) / (to - from), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    float d1 = getWold1(uv, 20.);\n    float d2 = getWold2(uv, 20.);\n    float t = mod(iTime, 4.);\n    float t1 = timeSpan(t, .0, .4);\n    float t2 = timeSpan(t, .4, 1.);\n    float t3 = timeSpan(t, 1.2, 1.8);\n    float t4 = timeSpan(t, 1.8, 2.6);\n    float t5 = timeSpan(t, 2.6, 3.8);\n    float d = mix(1., d1, t1);\n    d = mix(d, d1, t2);\n    d = mix(d, d2, t3);\n    d = mix(d, d2, t4);\n    d = mix(d, 1., t5);\n    \n    fragColor = vec4(vec3(smoothstep(.0, .08, abs(d))), 1.);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define S(c) _tmpChrVal = charLUT(textUv, c); textOutput.xyz += _tmpChrVal.xyz; textOutput.w = min(textOutput.w, 2. * _tmpChrVal.w - 1.); textUv.x -= charSpacing;\n\n#define _A S(65)\n#define _B S(66)\n#define _C S(67)\n#define _D S(68)\n#define _E S(69)\n#define _F S(70)\n#define _G S(71)\n#define _H S(72)\n#define _I S(73)\n#define _J S(74)\n#define _K S(75)\n#define _L S(76)\n#define _M S(77)\n#define _N S(78)\n#define _O S(79)\n#define _P S(80)\n#define _Q S(81)\n#define _R S(82)\n#define _S S(83)\n#define _T S(84)\n#define _U S(85)\n#define _V S(86)\n#define _W S(87)\n#define _X S(88)\n#define _Y S(89)\n#define _Z S(90)\n\n#define _a S(97)\n#define _b S(98)\n#define _c S(99)\n#define _d S(100)\n#define _e S(101)\n#define _f S(102)\n#define _g S(103)\n#define _h S(104)\n#define _i S(105)\n#define _j S(106)\n#define _k S(107)\n#define _l S(108)\n#define _m S(109)\n#define _n S(110)\n#define _o S(111)\n#define _p S(112)\n#define _q S(113)\n#define _r S(114)\n#define _s S(115)\n#define _t S(116)\n#define _u S(117)\n#define _v S(118)\n#define _w S(119)\n#define _x S(120)\n#define _y S(121)\n#define _z S(122)\n\n#define _0 S(48)\n#define _1 S(49)\n#define _2 S(50)\n#define _3 S(51)\n#define _4 S(52)\n#define _5 S(53)\n#define _6 S(54)\n#define _7 S(55)\n#define _8 S(56)\n#define _9 S(57)\n\n#define _add  S(43)\n#define _dot  S(46)\n#define _exc  S(33)\n#define _space S(32)\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldBRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 306], [380, 380, 394, 394, 499], [942, 942, 989, 989, 1043], [1045, 1045, 1100, 1100, 1652]], "test": "untested"}
{"id": "7lcBzr", "name": "[twigl]Lagoon (230chrs)", "author": "Catzpaw", "description": "https://twitter.com/catzpaw/status/1522828215987089408", "tags": ["2d", "twigl"], "likes": 9, "viewed": 309, "published": 3, "date": "1662520271", "time_retrieved": "2024-07-30T16:32:11.041181", "image_code": "//--- Lagoon\n// by Catzpaw 2022\n\n//https://bit.ly/38Wgx5g\n\nTWIGL_GEEKEST_300ES\n\nvec2 p=(FC.xy*2.-r)/r.y;p*=1.+exp(p.y);\nfloat v,i,w,z,y=p.y;\nfor(w=sin(snoise2D(p*vec2(.5,1)))*.7;++i<8.;\n  v+=(.5-abs(w*.4+sin(w+(t+p.y)*i)))*(sin((p.x+p.y)*4.)*.5+1.)/i,\n  p.y+=i,p*=rotate2D(cos(i*.2)));\no.rgb+=hsv(.2+y*.04,.2,.6+v*.15);\n\nEND_GEEKEST_300ES\n", "image_inputs": [], "common_code": "/* ============================================ **\n\n███████        █   TWIGL GEEKEST WRAPPER\n█  █  █            for Shadertoy\n   █  ███  █████\n   █   █ ▐▌ █  █    by Catzpaw 2022\n  ███  ▐█▌▐█▌ ███\n\n ██       ██  ██\n █  ▐█████ █   █\n█▌ ▐█   █  █   ▐█  \"twigl\"\n █ ▐█   █  █   █    https://twigl.app/\n ██ ▐████ ███ ██    Copyright (c) 2020 doxas\n    ████▌\n\nMIT License\nhttps://github.com/doxas/twigl/blob/master/LICENSE\n\n** ============================================ */\n\n\n/*** NOTICE **************************************\n  No backbuffer supported.\n  No MRT supported.\n  \"s\" is always zero.\n*************************************************/\n\n\n\n// --------------------------------------------\n//  noise.glsl\n// --------------------------------------------\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec2  mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3  mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4  mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nfloat permute(float x){return mod289(((x*34.0)+1.0)*x);}\nvec3  permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);}\nvec4  permute(vec4 x) {return mod289(((x*34.0)+1.0)*x);}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4  taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise2D(vec2 v){\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\nfloat snoise3D(vec3 v){\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\nvec4 grad4(float j, vec4 ip){\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\nfloat snoise4D(vec4 v){\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  // 2 * G4\n                          0.414589803375032,  // 3 * G4\n                         -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n               i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n             + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n             + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n             + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                  + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\nfloat fsnoise      (vec2 c){return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);}\nfloat fsnoiseDigits(vec2 c){return fract(sin(dot(c, vec2(0.129898, 0.78233))) * 437.585453);}\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\nconst float PI = 3.141592653589793;\nconst float PI2 = PI * 2.0;\n\n\n// --------------------------------------------\n//  twigl geekest(300 es) aliases\n// --------------------------------------------\n#define TWIGL_GEEKEST_300ES void mainImage(out vec4 o,in vec2 _fc){vec2 r=iResolution.xy,m=iMouse.xy/r;vec4 FC=vec4(_fc,.5,1);float s=0.,t=iTime;int f=iFrame;o=vec4(0);\n#define END_GEEKEST_300ES o=clamp(o,0.,1.);}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "slKcDy", "name": "basic stars with bloom", "author": "ArmandB", "description": "stars using voronoi and white noise to scatter them, does not scale up sadly", "tags": ["noise"], "likes": 2, "viewed": 369, "published": 3, "date": "1662499958", "time_retrieved": "2024-07-30T16:32:12.344696", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 grad = vec4(mix(vec3(0,0,0.02),vec3(0.1,0.1,0.15),pow(1.0-uv.y,3.0)),0.0);\n    vec4 base = max(texture(iChannel0,uv,0.0),0.0);\n    //upscale\n    vec4 bloom = max(texture(iChannel1,uv*bloomSize,0.0)*bloomStrength,0.0);\n    \n    fragColor = base + bloom + grad;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//precomputed density map\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iFrame == 0 || iResolution.xy != texture(iChannel0,uv,0.0).xy) {\n        float scale = (\n            voronoi3d(vec3(uv.x,0,uv.y))*0.5 +\n            voronoi3d(vec3(uv.x/4.0,0,uv.y/4.0))*0.25 +\n            voronoi3d(vec3(uv.x*8.0,0,uv.y*8.0))\n        )/(0.5+0.25+1.0);\n        fragColor = vec4(iResolution.xy,0,1.0-scale);\n    } else {\n        fragColor = vec4(iResolution.xy,0,texture(iChannel0,uv,0.0).a);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float bloomStrength = 1.0;\nconst float bloomSize = 0.4; //0-1\nconst float twinkleDimming = 0.5;\n\nvec3 hsvToRgb(vec3 hsv){ //hsv.x = hue, hsv.y = saturation, hsv.z = value\n    vec3 col = vec3(hsv.x, hsv.x + 2.0/3.0, hsv.x + 4.0/3.0); //inputs for r, g, and b\n    col = clamp(abs(mod(col*2.0, 2.0)-1.0)*3.0 - 1.0, 0.0, 1.0)*hsv.z*hsv.y + hsv.z - hsv.z*hsv.y; //hue function (graph it on desmos)\n    return col;\n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3) //https://www.shadertoy.com/view/4djSRW\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p) //https://www.shadertoy.com/view/4djSRW\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat voronoi3d(vec3 uv){\n    //assume uv is on a 0-1 scale\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                n = min(n,distance(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv));\n            }\n        }\n    }\n    return n;\n}", "buffer_b_code": "//main star drawing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float noise = hash12(uv*100.0);\n    float density = texture(iChannel0,fragCoord/iResolution.xy,0.0).a;\n    float twinkle = 1.0-voronoi3d(vec3(uv+iTime*4.0,0.0))*twinkleDimming;\n    float brightness = pow(hash12(uv*10.0),2.0);\n    float color = smoothstep(0.0,0.7,1.0-hash12(uv*1000.0));\n        \n    vec3 col = vec3(0);\n    if (noise >= 1.0-density*density/20.0) {\n        col = hsvToRgb(vec3(color/2.0,1.0-brightness-color/2.0,brightness));\n    } else {\n        col = vec3(0,0,0.02);\n    }\n\n    fragColor = vec4(col,brightness + twinkle);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//get light pixels for bloom\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0,uv,0.0);\n    if (col.r+col.g+col.b > 0.1) {\n        fragColor = col*col.a;\n    } else {\n        fragColor = vec4(0);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//downscale for bloom\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy/bloomSize;\n    fragColor = texture(iChannel0,uv,0.0);\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKcDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 373]], "test": "untested"}
{"id": "NtKyWd", "name": "Day 992", "author": "jeyko", "description": "aa", "tags": ["mdtmjvm"], "likes": 28, "viewed": 408, "published": 3, "date": "1662491889", "time_retrieved": "2024-07-30T16:32:17.572718", "image_code": "\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 nuv = (U-0.5*R.xy)/min(R.x,R.y);\n    \n    C -= C;\n    for(float i = 0.; i < 50.; i++){\n        //vec2 p = uv + normalize(nuv)*dot(uv,uv)*i/50.*0.01;\n        //vec3 t = texture(iChannel0,p).xyz;\n        //t = lerpHSV(rgb2hsv(t) - vec3(0.2,0,0),rgb2hsv(t) + vec3(0.2,0,0),i/40.);\n        //C.xyz += hsv2rgb(t)/50.;\n    \n    }\n    float n1d = texelFetch(iChannel2,ivec2(mod(U + vec2(float(iFrame)*0.,0.),256.)),0).x*0.5;\n    vec3 n  = texelFetch(iChannel2,ivec2(mod(U + n1d*200. ,256.)),0).xyz*0.6;\n    \n        \n    \n    vec3 t = texture(iChannel0,uv).xyz;\n        \n    C = t.xyzz;\n    \n    \n    //C.xyz += smoothstep(1.,0.,length(C))*0.05;\n    \n    //C.xyz -= smoothstep(0.,1.,length(C))*0.02;\n    \n    C.xyz += smoothstep(1.,0.,length(C))*n*0.2;\n    \n    C.xyz -= smoothstep(0.,1.,length(C))*n*0.1;\n    \n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec3 pal[] = vec3[](\n    vec3(0.2,0.2,0.9),\n    vec3(0.9,0.8,0.2),\n    vec3(0.8,0.4,0.9)\n);\n\nfloat fun(\n    float param,\n    float seg,\n    float tran\n){\n    float cft = fract(param/seg);\n    float id = mod(floor(param/seg),2.);\n    float coolfun = smoothstep(0.,tran,cft);\n    if(id == 0.)\n        coolfun = 1. - coolfun;\n        \n    return coolfun;\n}\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 nuv = (U-0.5*R.xy)/min(R.x,R.y);\n    vec2 muv = (iMouse.xy-0.5*R.xy)/min(R.x,R.y);\n\n    vec3 col = vec3(0);\n    \n    int cnt = pal.length();\n    \n\n    \n    col += 1.;\n    \n    for (float i = 0.; i < 144.; i ++){\n        int id = int(i)%cnt;\n        \n        vec3 p = 1.*sin(vec3(3,2,1)*iTime*(0.2 + sin(i )*0.4)*0.2+ sin(iTime + i)*0.2 + i);\n        \n        float d = length(nuv - p.xy);\n        vec2 luv = nuv - p.xz/dot(p.xy,p.xz);\n        d = length(luv);\n        //d = abs(luv.x);\n        vec3 palc = (pal[id]) + sin(vec3(iTime + i,0,0))*0.1;\n        \n        luv /= dot(luv,luv);\n        palc.x *= 1. + smoothstep(1.,0.,dot(luv,luv));\n        col = lerpHSV(\n            col,\n            palc,\n            smoothstep(0.5 + sin(iTime + i)*0.5,0.,d*1.)\n        );\n    \n        \n    }\n    col = hsv2rgb(col);\n      \n    if(max(abs(nuv.x) - 0.6,abs(nuv.x)-0.8) < 0.)\n        col += 0.;\n    else \n        col -= vec3(1);\n        \n    vec2 camOffs = sin((iTime + sin(iTime)*1.)*vec2(1,1.4)*0.4)*0.4 - muv*0.5;\n    \n    \n    float seg = 15.;\n    float tran = 0.2;\n    vec2 cp = uv*5. + iTime*0.2;\n    float param = iTime + abs(dot(sin(cp.xy + 4.),cos(cp.xy)))*0. + uv.x*0. + sin(length(uv))*0.;\n    float cft = fract(param/seg);\n    float id = mod(floor(param/seg),2.);\n    float coolfun = smoothstep(0.,tran,cft);\n    if(id == 0.)\n        coolfun = 1. - coolfun;\n    \n    \n    {\n        vec2 p = nuv;\n        \n        float cfamt = 40.;\n        float cfenv = fract(coolfun*40.);\n        float its = 10. + sin(iTime)*0. + cfamt * coolfun;\n        \n        float cffl = floor(its);\n        \n        for(float i = 0.; i < its; i++){\n            vec2 lp = p;\n            \n            lp += camOffs*max(i/its*2. - 1.,0.);\n            lp -= camOffs*max((1.-i/its)*2. - 1.,0.)*0.2;\n            \n            float poffset = sin(iTime*0.6 + 0.5);\n            \n            lp += sin((i/its*14.+iTime)*vec2(1.1,2.4)*0.6)*0.1*pow((1.-i/its),2.+poffset);\n            \n            lp += vec2(1.89,1)*sin((i/its*4.+iTime)*vec2(1.1,2.4) + 0.*sin((i/its+iTime)*vec2(0.5,0.8))  )*0.7*pow(i/its,5. + poffset)*0.1;\n            lp /= 1. + dot(lp,lp)*5.;\n            float d = length(lp) - (1.-i/its)*0.2*(0.5+0.5*sin(iTime*1. + 15.*i/its))* ( 1. );\n            \n            float df = smoothstep(\n                fwidth((d)) +\n                //    0.1*pow((length(sin(sin(iTime)*0.4 - 0.5 + (i/its)))),2.)\n                    0.2*pow((length(sin(sin(iTime*1.)*0.4 - 0.5 + (i/its)))),2.) \n                \n                ,0.,d);\n            \n            //col = mix(col,vec3(1)*float(mod(i,2.)),df);\n            col = mix(col,\n                vec3(1) \n                //+ 0.*hsv2rgb(vec3(df*0.,-df*.4,1.))\n                *float(mod(i,2.))\n                ,df);\n            \n            \n        }\n    \n    }\n    \n\n    col = 1.-exp(-col*1.78);\n    col = smoothstep(0.,1.,col);\n    col = pow(col,vec3(0.454545));\n    C = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define iTime (iTime + 100. - texelFetch(iChannel1,ivec2(gl_FragCoord.xy)%8,0).x*0.)\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nfloat luma(vec4 color) { return dot(color.rgb, vec3(0.299, 0.587, 0.114)); }\n\nvec4 rgb2cmyki(in vec3 c) { float k = max(max(c.r, c.g), c.b); return min(vec4(c.rgb / k, k), 1.0); }\n\nvec3 cmyki2rgb(in vec4 c) { return c.rgb * c.a; }\n\nvec3 lerpHSV(in vec3 hsv1, in vec3 hsv2, in float rate)\n{\n    float hue = (mod(mod((hsv2.x-hsv1.x), 1.) + 1.5, 1.)-0.5)*rate + hsv1.x;\n    return vec3(hue, mix(hsv1.yz, hsv2.yz, rate));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nvec3 hueShift(vec3 col, vec3 hsv){\n    vec3 h = rgb2hsv(col);\n    h.x += hsv.x;\n\n    h.y *= hsv.y;\n    h.z *= hsv.z;\n\n    return hsv2rgbSmooth(h);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 878]], "test": "untested"}
{"id": "flcBRr", "name": "Replicate Giraffe - by hugolnx", "author": "hugolnx", "description": "Trying to replicate giraffe texture", "tags": ["procedural", "texture", "fur", "texturing", "giraffe", "hugolnx"], "likes": 13, "viewed": 297, "published": 3, "date": "1662483429", "time_retrieved": "2024-07-30T16:32:18.963001", "image_code": "#define SHADERTOY 1\n// GITHUB: https://github.com/HugoLnx/shaders-laboratory/tree/master/shaders/replicate-giraffe\n// ORIGINAL: https://github.com/HugoLnx/shaders-laboratory/tree/master/textures/giraffe-skin-fur.jpg\n// ORIGINAL SOURCE: https://www.pexels.com/photo/close-up-of-giraffe-body-skin-fur-12406721/\n\n// Aux simple functions\n#define TWO_PI 6.283185\n#define PI 3.14159\nfloat norm(float x) { return x*.5 + .5; }\nfloat denorm(float x) { return x*2. - 1.; }\nfloat xstep(float b, float e, float v) {\n    return step(b, v) - step(e, v);\n}\nfloat xsmoothstep(float b, float e, float v) {\n    return smoothstep(b, e, v) - step(e, v);\n}\nfloat flatten(float v, float layers) {\n  return floor(v*layers) * (1./layers);\n}\nfloat nsin(float t) {return norm(sin(t * TWO_PI));}\nfloat ncos(float t) {return norm(cos(t * TWO_PI));}\nfloat ntan(float t) {return norm(tan(t * TWO_PI));}\nfloat sat(float t) {return clamp(t, 0., 1.);}\nfloat rsat(float t) {return mod(t+10000.0, 1.);}\nfloat xclamp(float v, float minV, float maxV) {\n  return clamp(v, minV, maxV) * xstep(minV, maxV, v);\n}\nfloat xclampnorm(float v, float minV, float maxV) {\n  return (xclamp(v, minV, maxV) - minV) / (maxV-minV);\n}\nvec3 togrey(vec3 c) {\n  return vec3((c.r+c.g+c.b)/3.);\n}\nfloat normrange(float v, float minV, float maxV) { return sat((v-minV)/(maxV-minV)); }\n\n// -------------------\n// BEGIN https://github.com/stegu/webgl-noise\n// -------------------\n\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 mod7(vec3 x) {return x - floor(x * (1.0 / 7.0)) * 7.0;}\nvec3 permute(vec3 x) {return mod289((34.0 * x + 10.0) * x);}\nvec4 permute(vec4 x) {return mod289(((x*34.0)+10.0)*x);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n// Cellular\nvec2 cellular(vec3 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n\n\tvec3 Pi = mod289(floor(P));\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod7(floor(p11*K))*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod7(floor(p12*K))*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod7(floor(p13*K))*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod7(floor(p21*K))*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod7(floor(p22*K))*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod7(floor(p23*K))*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod7(floor(p31*K))*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod7(floor(p32*K))*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod7(floor(p33*K))*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\tvec3 d1 = min(min(d11,d12), d13);\n\tvec3 d2 = min(min(d21,d22), d23);\n\tvec3 d3 = min(min(d31,d32), d33);\n\tvec3 d = min(min(d1,d2), d3);\n\td.x = min(min(d.x,d.y),d.z);\n\treturn vec2(sqrt(d.x)); // F1 duplicated, no F2 computed\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n#endif\n}\n\nvec2 ncellular(vec2 p, float seed) {\n  p *= 15.;\n  seed *= 0.3;\n  return cellular(vec3(p, seed));\n}\n\n// Classic Perlin noise\nfloat perlin(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat nperlin(vec2 p, float seed) {\n  p *= 20.;\n  seed *= 0.5;\n  return norm(perlin(vec3(p, seed)));\n}\n\n// Simplex Noise\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat nsimplex(vec2 x, float seed) {\n  x *= 10.;\n  seed *= 0.3;\n  return norm(simplex(vec3(x, seed)));\n}\n\n\n// -------------------\n// END noise3D\n// -------------------\n\n// -------------------\n// BEGIN https://www.shadertoy.com/view/4dS3Wd\n// -------------------\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat morgan(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat morgan(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat morgan(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat nmorgan(float x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x, float seed) {\n  x *= 20.;\n  seed *= 0.5;\n  return morgan(vec3(x, seed));\n}\n// -------------------\n// END Morgan Noises\n// -------------------\n\n\n// -------------------\n// BEGIN http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// -------------------\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 P = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, P.wz) : vec4(c.gb, P.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n    // vec4 p = mix(vec4(c.bg, P.wz), vec4(c.gb, P.xy), step(c.b, c.g));\n    // vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 P = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + P.xyz) * 6.0 - P.www);\n    return c.z * mix(P.xxx, clamp(p - P.xxx, 0.0, 1.0), c.y);\n}\n// -------------------\n// END HSV Conversion \n// -------------------\n\nvec3 hsv(float h, float s, float v) {return hsv2rgb(vec3(h, s, v));}\n\n\n// Noise Aux Functions\nfloat random(vec2 uv, float seed) {\n    const float a = 12.9898;\n    const float b = 78.233;\n    const float c = 43758.543123;\n    return fract(sin(dot(uv, vec2(a, b)) + seed) * c);\n}\n\n#define OCTAVES 6\n#define OCTAVES_F 6.0\n\n// Simplex Variations\n#define SIMPLEX_VARS_SCALE 1.0\nfloat turbSimplex( vec3 p ) {\n  p *= SIMPLEX_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(100.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( simplex( power * p + shift ) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbSimplex(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.08;\n  return 1.-sat(-1.2*turbSimplex(vec3(p, seed)));\n}\n\nfloat nturb2Simplex(vec2 st2, float seed) {\n  seed *= 0.04;\n  vec3 st = vec3(st2, seed);\n  st *= SIMPLEX_VARS_SCALE * 3.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(200.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(simplex(st));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmSimplex(vec3 x) {\n  x *= SIMPLEX_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(300.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * simplex(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmSimplex(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmSimplex(vec3(x, seed)));\n}\n\n\n// Morgan Variations\n#define MORGAN_VARS_SCALE 2.5\nfloat turbMorgan( vec3 p ) {\n  p *= MORGAN_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(0.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(morgan( power * p + shift )) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbMorgan(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.05;\n  return 1.-sat(-2.0*turbMorgan(vec3(p, seed)));\n}\n\nfloat nturb2Morgan(vec2 st2, float seed) {\n  seed *= 0.03;\n  vec3 st = vec3(st2, seed);\n  st *= MORGAN_VARS_SCALE * 6.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(0.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(morgan(st)));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmMorgan(vec3 x) {\n  x *= MORGAN_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = .9;\n\tvec3 shift = vec3(0.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * (denorm(morgan(x))+0.05);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmMorgan(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmMorgan(vec3(x, seed)));\n}\n\n\n\n// Cellular Variations\n#define CELLULAR_VARS_SCALE 1.5\nfloat turbCellular( vec3 p ) {\n  p *= CELLULAR_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(700.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(cellular( power * p + shift ).x) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbCellular(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.07;\n  return sat(0.85+2.*turbCellular(vec3(p, seed)));\n}\n\nfloat nturb2Cellular(vec2 st2, float seed) {\n  seed *= 0.02;\n  vec3 st = vec3(st2, seed);\n  st *= CELLULAR_VARS_SCALE * 5.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(800.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(cellular(st).x));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmCellular(vec3 x) {\n  x *= CELLULAR_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(900.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * denorm(cellular(x).x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmCellular(vec2 x, float seed) {\n  seed *= 0.1;\n  x *= 5.;\n  return norm(fbmCellular(vec3(x, seed)));\n}\n\n\nvec2 rotate(vec2 v, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c) * v;\n}\n\n#define RED vec3(1., 0., 0.)\n#define GRE vec3(0., 1., 0.)\n#define BLU vec3(0., 0., 1.)\n#define WRED vec3(1., .8, .8)\n#define WGRE vec3(.8, 1., .8)\n#define WBLU vec3(.8, .8, 1.)\n#define BLU2 vec3(0.35, 0.5, 1.)\n#define PUR vec3(1., 0., 1.)\n#define YEL vec3(1., 1., 0.)\n#define CYA vec3(0., 1., 1.)\n#define WHI vec3(1., 1., 1.)\n#define BLANK vec3(0.35, 0., 0.35)\n\nvec4 getNoise(vec2 uv, float t) {\n  float tseed = floor(t*0.1);\n  float seed  = tseed;\n  float seed2 = tseed + 373.297;\n  float seed3 = tseed + 793.713;\n  float seed4 = tseed + 127.139;\n  float seed5 = tseed + 929.197;\n  vec2 roll = -0.05*t*vec2(1.);\n  // uv += roll;\n\n  float v = 0.;\n  float v1 = 0.;\n  float v2 = 0.;\n  float v3 = 0.;\n\n  float p4turb = nturb2Simplex(uv*3., seed);\n  p4turb = flatten(p4turb, 3.);\n  vec2 p4uv = uv/3.0 + p4turb * 0.0025;\n  vec2 p4Cel = ncellular(p4uv, seed);\n  float p4 = p4Cel.x - p4Cel.y*0.8;\n  p4 = normrange(p4, 0.0, 0.1)*2.;\n  p4 = sat(p4);\n\n  float p2 = nturbSimplex(uv*5., seed2);\n  p2 = flatten(p2, 5.0);\n  p2 = p2 * step(0.5, p2);\n\n  float p3 = nfbmSimplex(uv*10., seed);\n  float p3b = nfbmSimplex(uv, seed);\n\n  vec2 uvp1 = uv;\n  float rotation = PI * 0.25;\n  //vec2 dir = vec2(cos(rotation), sin(rotation));\n  uvp1 -= cos((uvp1.y*p2)*TWO_PI*50.)*mix(.001, 0.003, flatten(p3b, 2.));\n  uvp1 = rotate(uvp1, rotation);\n  float baseZoom = 1000.0;\n  float xZoom = 1.;\n  uvp1 *= baseZoom;\n  uvp1.x *= xZoom;\n  float rand = random(vec2(floor(uvp1.x), 0.0), seed);\n  float yZoom = mix(0.001, .1, rand);\n  uvp1.y *= yZoom;\n  uvp1 = floor(uvp1);\n  float p1 = random(uvp1, seed);\n  float mixC = p3;\n  float minC = mix(0.05, 0.15, mixC);\n  float maxC = mix(0.35, 0.5, mixC);\n  float mixB = p3b;\n  float minB = mix(.65, 0.8, mixB);\n  float maxB = mix(.75, 0.9, mixB);\n  p1 = (1.-p4)*mix(minC, maxC, p1) + p4*mix(minB, maxB, p1);\n\n  float final = p1;\n\n  v1 = p1;\n  v2 = p4turb;\n  v3 = p4;\n  v = final;\n\n  return vec4(v1, v2, v3, v);\n}\n\n\n#ifndef SHADERTOY\nuniform sampler2D iChannel0;\nuniform float iTime;\nuniform vec2 iResolution2D;\n#define iResolution vec4(iResolution2D, 0., 0.)\nout vec4 outColor;\n#endif\n\nvec3 withColor(vec4 noises) {\n  float v = noises.w;\n  float stripes = noises.z;\n\n  // RGB(58,30,18)\n  vec3 CMIN = vec3(58., 30., 18.)/255.;\n\n  // RGB(106,62,31)\n  //vec3 CMIN = vec3(106., 62., 31.)/255.;\n\n  // RGB(157,124,103)\n  //vec3 CMAX = vec3(157., 124., 103.)/255.;\n  // RGB(190,143,120)\n  //vec3 CMAX = vec3(190.0, 143., 120.)/255.;\n\n  // RGB(126,70,27)\n  vec3 CMAX = vec3(126., 70., 27.)*2./255.;\n\n  vec3 c = mix(CMIN, CMAX, normrange(v, 0.0, 0.8));\n  //vec3 c = CMAX * normrange(v, 0.0, 0.5);\n  c = mix(c, WHI*v, stripes);\n  return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from -0.5 to 0.5)\n  float mx = max(iResolution.x, iResolution.y);\n  vec2 ct = iResolution.xy / mx / 2.0;\n  vec2 uv = fragCoord/mx - ct;\n  vec2 uv2 = fragCoord / iResolution.xy - .5;\n\n  float t = iTime;\n  t *= 0.35;\n\n\n  int count = 0;\n  vec3 sims[30];\n\n  float alldiv = .5;\n  vec2 uvZoom1 = uv / 2.;\n  vec2 uvZoom2 = uvZoom1 / 2.;\n  float txdiv = 1.;\n  txdiv *= alldiv;\n\n  vec4 noises1 = getNoise(uv/alldiv, t);\n  vec4 noises2 = getNoise(uvZoom1/alldiv, t);\n  vec4 noises3 = getNoise(uvZoom2/alldiv, t);\n\n  sims[count++] = WHI * noises1.x;\n  sims[count++] = withColor(noises1);\n  sims[count++] = WHI * noises1.x;\n  sims[count++] = withColor(noises1); //texture(iChannel0, uv/txdiv).rgb;\n  sims[count++] = WHI * noises1.y;\n  sims[count++] = withColor(noises1);\n  sims[count++] = WHI * noises1.y;\n  sims[count++] = withColor(noises1); //texture(iChannel0, uvZoom1/txdiv).rgb;\n  sims[count++] = WHI * noises1.z;\n  sims[count++] = withColor(noises2);\n  sims[count++] = WHI * noises1.z;\n  sims[count++] = withColor(noises3); //texture(iChannel0, uvZoom2/txdiv).rgb;\n\n  uv2 += .5;\n  float gridWidth = 2.0;\n  float gridHeight = 6.0;\n  float gridX = floor(uv2.x*gridWidth);\n  float gridY = floor((1.-uv2.y)*gridHeight);\n  int gridInx = int(floor(gridY*gridWidth + gridX));\n  vec3 c;\n  for (int i = 0; i < count; i++) {\n    c += sims[i] * (gridInx == i ? 1.0 : 0.0);\n  }\n  \n\n  // Output to screen\n  fragColor = vec4(c, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n  mainImage(outColor, gl_FragCoord.xy);\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[377, 377, 398, 398, 418], [419, 419, 442, 442, 462], [463, 463, 503, 503, 541], [542, 542, 588, 588, 635], [636, 636, 674, 674, 716], [717, 717, 738, 738, 768], [769, 769, 790, 790, 820], [821, 821, 842, 842, 872], [873, 873, 893, 893, 918], [919, 919, 940, 940, 967], [968, 968, 1015, 1015, 1071], [1072, 1072, 1123, 1123, 1180], [1181, 1181, 1202, 1202, 1237], [1238, 1238, 1288, 1288, 1324], [1419, 1419, 1440, 1440, 1485], [1486, 1486, 1507, 1507, 1552], [1553, 1553, 1572, 1572, 1613], [1614, 1614, 1636, 1636, 1674], [1675, 1675, 1697, 1697, 1731], [1732, 1732, 1759, 1759, 1807], [1808, 1808, 1827, 1827, 1863], [1865, 1877, 1900, 1900, 6707], [6709, 6709, 6745, 6745, 6808], [6810, 6834, 6856, 6856, 9151], [9153, 9153, 9188, 9188, 9255], [9257, 9274, 9299, 9299, 11438], [11440, 11440, 11476, 11476, 11544], [11609, 11776, 11797, 11797, 11864], [11865, 11865, 11885, 11885, 11990], [11992, 11992, 12015, 12015, 12147], [12149, 12149, 12171, 12171, 12805], [12808, 12808, 12830, 12830, 13591], [13593, 13593, 13617, 13617, 13651], [13652, 13652, 13675, 13675, 13709], [13710, 13710, 13745, 13745, 13806], [13876, 13987, 14009, 14009, 14470], [14472, 14472, 14494, 14494, 14663], [14734, 14734, 14771, 14771, 14802], [14805, 14828, 14863, 14863, 15011], [15107, 15107, 15136, 15136, 15370], [15372, 15372, 15412, 15412, 15491], [15493, 15493, 15536, 15536, 15859], [15861, 15861, 15887, 15887, 16098], [16100, 16100, 16139, 16139, 16209], [16263, 16263, 16291, 16291, 16529], [16531, 16531, 16570, 16570, 16648], [16650, 16650, 16692, 16692, 17019], [17021, 17021, 17046, 17046, 17268], [17270, 17270, 17308, 17308, 17377], [17436, 17436, 17466, 17466, 17712], [17714, 17714, 17755, 17755, 17835], [17837, 17837, 17881, 17881, 18216], [18218, 18218, 18245, 18245, 18468], [18470, 18470, 18510, 18510, 18581], [18584, 18584, 18618, 18618, 18700], [19064, 19064, 19097, 19097, 20626], [20800, 20800, 20829, 20829, 21345], [21347, 21347, 21404, 21457, 22856]], "test": "untested"}
{"id": "stycDt", "name": "Yee Lattice", "author": "wyatt", "description": "Solving Maxwell equations on Yee lattice gives twice the resolution. (https://www.shadertoy.com/view/fstfWj) gave two independent solutions in a checkered pattern that give the correct solution after averaging. ", "tags": ["fem"], "likes": 17, "viewed": 342, "published": 3, "date": "1662480028", "time_retrieved": "2024-07-30T16:32:20.335331", "image_code": "Main {\n    Q = A(U)*(A(U).w>1.?A(U).w*.75:1.);\n    float b = length(Q.xy);\n        Q = sin(3.6+0.2/4.*b+vec4(1,2,3,4));\n    //Q = A(U).xyxy;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\nfloat sdLine (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n", "buffer_a_code": "Main {\n    /*Q.x = sin(.1*U.x);\n    Q.y = cos(.1*U.y);\n    \n    vec4 n = A(U+vec2(0,0)),\n         e = A(U+vec2(0,0)),\n         s = A(U-vec2(0,1)),\n         w = A(U-vec2(1,0));\n    Q.z = (e.x-w.x+n.y-s.y);\n    //Q.z = .1*cos(.1*U.x)-.1*sin(.1*U.y);\n    */\n    \n    vec4 dQ = vec4(0);\n    Q = A(U);\n    \n    // div mu H = 0\n    // curl H = J\n    \n    { // n, e me = s, w\n      float n = A(U+vec2(0,1)).x;\n      float e = A(U+vec2(1,0)).y;\n      float s = A(U+vec2(0,0)).x;\n      float w = A(U+vec2(0,0)).y;\n      float j = B(U).z;\n      // e-w-n+s = j\n      // w = e-j-n+s\n      dQ.y += e-n+s-2.*j-Q.y;\n      // s = j-e+w+n\n      dQ.x += 2.*j-e+w+n-Q.x;\n    }\n    { // w me = e\n      float n = A(U+vec2(-1,1)).x;\n      float e = A(U+vec2(0,0)).y;\n      float s = A(U+vec2(-1,0)).x;\n      float w = A(U+vec2(-1,0)).y;\n      float j = B(U+vec2(-1,0)).z;\n      // e-w-n+s = j\n      // e = j+w+n-s\n      dQ.y += 2.*j+w+n-s-Q.y;\n    }\n    { // s me = n\n      float n = A(U+vec2(0,0)).x;\n      float e = A(U+vec2(1,-1)).y;\n      float s = A(U+vec2(0,-1)).x;\n      float w = A(U+vec2(0,-1)).y;\n      float j = B(U+vec2(0,-1)).z;\n      // e-w-n+s = j\n      // n = e-w+s-j\n      dQ.x += e-w+s-2.*j-Q.x;\n    }\n    float G = .3;\n    vec4 ddQ = vec4(0);\n    { // n, me = s\n      vec4 n = A(U+vec2(0,1));\n      vec4 e = A(U+vec2(0,1));\n      vec4 s = A(U+vec2(0,0));\n      vec4 w = A(U+vec2(-1,1));\n      // e.x*e.w-w.x*w.w+n.y*n.w-s.y*s.w = 0\n      ddQ.y += (\n          (e.x*e.w-w.x*w.w+n.y*n.w)/s.w\n          -Q.y\n          ) / (\n          1.+G*(abs(s.w-e.w)+abs(s.w-n.w)+abs(s.w-w.w))\n          );\n    }\n    { // e, me = w\n      vec4 n = A(U+vec2(1,0));\n      vec4 e = A(U+vec2(1,0));\n      vec4 s = A(U+vec2(1,-1));\n      vec4 w = A(U+vec2(0,0));\n      // e.x*e.w-w.x*w.w+n.y*n.w-s.y*s.w = 0\n      ddQ.x += (\n          (e.x*e.w+n.y*n.w-s.y*s.w)/w.w\n          -Q.x\n          ) / (\n          1.+G*(abs(w.w-e.w)+abs(w.w-n.w)+abs(w.w-s.w))\n          );\n    }\n    { // w,s me = n,e\n      vec4 n = A(U+vec2(0,0));\n      vec4 e = A(U+vec2(0,0));\n      vec4 s = A(U+vec2(0,-1));\n      vec4 w = A(U+vec2(-1,0));\n      // e.x*e.w-w.x*w.w+n.y*n.w-s.y*s.w = 0\n      ddQ.x += (\n          -(-w.x*w.w+n.y*n.w-s.y*s.w)/e.w\n          -Q.x\n          ) / (\n          1.+G*(abs(e.w-w.w)+abs(e.w-n.w)+abs(e.w-s.w))\n          );\n      ddQ.y += (\n          -(e.x*e.w-w.x*w.w-s.y*s.w)/n.w\n          -Q.y\n          ) / (\n          1.+G*(abs(n.w-e.w)+abs(n.w-w.w)+abs(n.w-s.w))\n          );\n    }\n    \n    Q.xy += 0.25*dQ.xy;\n    Q.xy += .25*ddQ.xy;\n    if (iFrame < 2) Q = vec4(0);\n    Q.w = B(U).w;\n    \n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = vec4(0);\n    if (sdLine(U,vec2(.4,.3)*R,vec2(.4,.7)*R)<2.)\n        Q.z += 1.;\n    if (sdLine(U,vec2(.6,.3)*R,vec2(.6,.7)*R)<2.)\n        Q.z -= 1.;\n   Q.w = 1.;\n   if (sdLine(U,vec2(.3,.2)*R,vec2(.3,.8)*R)<.05*R.y||\n        sdLine(U,vec2(.3,.8)*R,vec2(.7,.8)*R)<.05*R.y||\n        sdLine(U,vec2(.7,.8)*R,vec2(.7,.2)*R)<.05*R.y||\n        sdLine(U,vec2(.3,.2)*R,vec2(.7,.2)*R)<.05*R.y||\n        sdLine(U,vec2(.5,.25)*R,vec2(.5,.75)*R)<.1*R.y)\n        Q.w = 3300.;\n    \n    if (sdLine(U,vec2(.4,.5)*R,vec2(.6,.5)*R)<.03*R.y)\n       Q.w = 1.;\n       \n        \n}", "buffer_b_inputs": [], "buffer_c_code": "Main {\n    /*Q.x = sin(.1*U.x);\n    Q.y = cos(.1*U.y);\n    \n    vec4 n = A(U+vec2(0,0)),\n         e = A(U+vec2(0,0)),\n         s = A(U-vec2(0,1)),\n         w = A(U-vec2(1,0));\n    Q.z = (e.x-w.x+n.y-s.y);\n    //Q.z = .1*cos(.1*U.x)-.1*sin(.1*U.y);\n    */\n    \n    vec4 dQ = vec4(0);\n    Q = A(U);\n    \n    // div mu H = 0\n    // curl H = J\n    \n    { // n, e me = s, w\n      float n = A(U+vec2(0,1)).x;\n      float e = A(U+vec2(1,0)).y;\n      float s = A(U+vec2(0,0)).x;\n      float w = A(U+vec2(0,0)).y;\n      float j = B(U).z;\n      // e-w-n+s = j\n      // w = e-j-n+s\n      dQ.y += e-n+s-2.*j-Q.y;\n      // s = j-e+w+n\n      dQ.x += 2.*j-e+w+n-Q.x;\n    }\n    { // w me = e\n      float n = A(U+vec2(-1,1)).x;\n      float e = A(U+vec2(0,0)).y;\n      float s = A(U+vec2(-1,0)).x;\n      float w = A(U+vec2(-1,0)).y;\n      float j = B(U+vec2(-1,0)).z;\n      // e-w-n+s = j\n      // e = j+w+n-s\n      dQ.y += 2.*j+w+n-s-Q.y;\n    }\n    { // s me = n\n      float n = A(U+vec2(0,0)).x;\n      float e = A(U+vec2(1,-1)).y;\n      float s = A(U+vec2(0,-1)).x;\n      float w = A(U+vec2(0,-1)).y;\n      float j = B(U+vec2(0,-1)).z;\n      // e-w-n+s = j\n      // n = e-w+s-j\n      dQ.x += e-w+s-2.*j-Q.x;\n    }\n    float G = .3;\n    vec4 ddQ = vec4(0);\n    { // n, me = s\n      vec4 n = A(U+vec2(0,1));\n      vec4 e = A(U+vec2(0,1));\n      vec4 s = A(U+vec2(0,0));\n      vec4 w = A(U+vec2(-1,1));\n      // e.x*e.w-w.x*w.w+n.y*n.w-s.y*s.w = 0\n      ddQ.y += (\n          (e.x*e.w-w.x*w.w+n.y*n.w)/s.w\n          -Q.y\n          ) / (\n          1.+G*(abs(s.w-e.w)+abs(s.w-n.w)+abs(s.w-w.w))\n          );\n    }\n    { // e, me = w\n      vec4 n = A(U+vec2(1,0));\n      vec4 e = A(U+vec2(1,0));\n      vec4 s = A(U+vec2(1,-1));\n      vec4 w = A(U+vec2(0,0));\n      // e.x*e.w-w.x*w.w+n.y*n.w-s.y*s.w = 0\n      ddQ.x += (\n          (e.x*e.w+n.y*n.w-s.y*s.w)/w.w\n          -Q.x\n          ) / (\n          1.+G*(abs(w.w-e.w)+abs(w.w-n.w)+abs(w.w-s.w))\n          );\n    }\n    { // w,s me = n,e\n      vec4 n = A(U+vec2(0,0));\n      vec4 e = A(U+vec2(0,0));\n      vec4 s = A(U+vec2(0,-1));\n      vec4 w = A(U+vec2(-1,0));\n      // e.x*e.w-w.x*w.w+n.y*n.w-s.y*s.w = 0\n      ddQ.x += (\n          -(-w.x*w.w+n.y*n.w-s.y*s.w)/e.w\n          -Q.x\n          ) / (\n          1.+G*(abs(e.w-w.w)+abs(e.w-n.w)+abs(e.w-s.w))\n          );\n      ddQ.y += (\n          -(e.x*e.w-w.x*w.w-s.y*s.w)/n.w\n          -Q.y\n          ) / (\n          1.+G*(abs(n.w-e.w)+abs(n.w-w.w)+abs(n.w-s.w))\n          );\n    }\n    \n    Q.xy += 0.25*dQ.xy;\n    Q.xy += .25*ddQ.xy;\n    if (iFrame < 2) Q = vec4(0);\n    Q.w = B(U).w;\n    \n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    /*Q.x = sin(.1*U.x);\n    Q.y = cos(.1*U.y);\n    \n    vec4 n = A(U+vec2(0,0)),\n         e = A(U+vec2(0,0)),\n         s = A(U-vec2(0,1)),\n         w = A(U-vec2(1,0));\n    Q.z = (e.x-w.x+n.y-s.y);\n    //Q.z = .1*cos(.1*U.x)-.1*sin(.1*U.y);\n    */\n    \n    vec4 dQ = vec4(0);\n    Q = A(U);\n    \n    // div mu H = 0\n    // curl H = J\n    \n    { // n, e me = s, w\n      float n = A(U+vec2(0,1)).x;\n      float e = A(U+vec2(1,0)).y;\n      float s = A(U+vec2(0,0)).x;\n      float w = A(U+vec2(0,0)).y;\n      float j = B(U).z;\n      // e-w-n+s = j\n      // w = e-j-n+s\n      dQ.y += e-n+s-2.*j-Q.y;\n      // s = j-e+w+n\n      dQ.x += 2.*j-e+w+n-Q.x;\n    }\n    { // w me = e\n      float n = A(U+vec2(-1,1)).x;\n      float e = A(U+vec2(0,0)).y;\n      float s = A(U+vec2(-1,0)).x;\n      float w = A(U+vec2(-1,0)).y;\n      float j = B(U+vec2(-1,0)).z;\n      // e-w-n+s = j\n      // e = j+w+n-s\n      dQ.y += 2.*j+w+n-s-Q.y;\n    }\n    { // s me = n\n      float n = A(U+vec2(0,0)).x;\n      float e = A(U+vec2(1,-1)).y;\n      float s = A(U+vec2(0,-1)).x;\n      float w = A(U+vec2(0,-1)).y;\n      float j = B(U+vec2(0,-1)).z;\n      // e-w-n+s = j\n      // n = e-w+s-j\n      dQ.x += e-w+s-2.*j-Q.x;\n    }\n    float G = .3;\n    vec4 ddQ = vec4(0);\n    { // n, me = s\n      vec4 n = A(U+vec2(0,1));\n      vec4 e = A(U+vec2(0,1));\n      vec4 s = A(U+vec2(0,0));\n      vec4 w = A(U+vec2(-1,1));\n      // e.x*e.w-w.x*w.w+n.y*n.w-s.y*s.w = 0\n      ddQ.y += (\n          (e.x*e.w-w.x*w.w+n.y*n.w)/s.w\n          -Q.y\n          ) / (\n          1.+G*(abs(s.w-e.w)+abs(s.w-n.w)+abs(s.w-w.w))\n          );\n    }\n    { // e, me = w\n      vec4 n = A(U+vec2(1,0));\n      vec4 e = A(U+vec2(1,0));\n      vec4 s = A(U+vec2(1,-1));\n      vec4 w = A(U+vec2(0,0));\n      // e.x*e.w-w.x*w.w+n.y*n.w-s.y*s.w = 0\n      ddQ.x += (\n          (e.x*e.w+n.y*n.w-s.y*s.w)/w.w\n          -Q.x\n          ) / (\n          1.+G*(abs(w.w-e.w)+abs(w.w-n.w)+abs(w.w-s.w))\n          );\n    }\n    { // w,s me = n,e\n      vec4 n = A(U+vec2(0,0));\n      vec4 e = A(U+vec2(0,0));\n      vec4 s = A(U+vec2(0,-1));\n      vec4 w = A(U+vec2(-1,0));\n      // e.x*e.w-w.x*w.w+n.y*n.w-s.y*s.w = 0\n      ddQ.x += (\n          -(-w.x*w.w+n.y*n.w-s.y*s.w)/e.w\n          -Q.x\n          ) / (\n          1.+G*(abs(e.w-w.w)+abs(e.w-n.w)+abs(e.w-s.w))\n          );\n      ddQ.y += (\n          -(e.x*e.w-w.x*w.w-s.y*s.w)/n.w\n          -Q.y\n          ) / (\n          1.+G*(abs(n.w-e.w)+abs(n.w-w.w)+abs(n.w-s.w))\n          );\n    }\n    \n    Q.xy += 0.25*dQ.xy;\n    Q.xy += .25*ddQ.xy;\n    if (iFrame < 2) Q = vec4(0);\n    Q.w = B(U).w;\n    \n}\n", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stycDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ft3BRn", "name": "A Simple Color  Levels", "author": "ololeecn", "description": "a simple color levels with smooth", "tags": ["2d", "levels"], "likes": 1, "viewed": 194, "published": 3, "date": "1662479047", "time_retrieved": "2024-07-30T16:32:21.528142", "image_code": "#define LEVEL_COUNT 10 //How many levels you want\n#define START_COLOR vec3(1.0,0.0,0.0) //level start color\n#define END_COLOR  vec3(0.0,1.0,0.0) //level end color\n#define RAMP_SMOOTH 0.5f //ramp smooth coefficient\n\n\nfloat smoothLevels(float x,float levelCount,float rampSmooth){\n    float _step = floor(x * levelCount);\n    float _smoothStep = smoothstep(_step,_step + rampSmooth,x*levelCount) + _step;\n    return  _smoothStep/levelCount;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float _normalizedSmoothStep = smoothLevels(uv.x,float(LEVEL_COUNT),RAMP_SMOOTH);\n    vec3 col = mix(START_COLOR,END_COLOR,_normalizedSmoothStep);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft3BRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 278, 278, 440], [443, 443, 500, 500, 728]], "test": "untested"}
{"id": "7lKcDd", "name": "Spread Sun", "author": "OneBear", "description": "N-Order Mandelbrot", "tags": ["experiment"], "likes": 2, "viewed": 175, "published": 3, "date": "1662478040", "time_retrieved": "2024-07-30T16:32:22.395823", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float sun = 0.2 / dot(uv, uv);\n\n    vec2 znew,z = vec2(0.0, 0.0); \n    float exponent = 40.0;\n    float n = 30.0;\n    for(float i = 0.0; i < n; i++)\n    {\n        znew = vec2(cos(atan(z.y / z.x) * exponent * (fract(iTime * 0.25) + 0.25)) * pow(length(z), 4.0), sin(atan(z.y / z.x) * exponent) * pow(length(z), 4.0)) + uv;\n        if(length(znew) > 4.0)\n        {\n            float result = i / n;\n            fragColor = vec4(result, result, result, 1.0);\n            return;\n        }\n        z.x = znew.x;\n        z.y = znew.y;\n    }\n    fragColor = vec4(sun, sun, sun, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 728]], "test": "untested"}
{"id": "wsfXWf", "name": "View dependent noise", "author": "Danielhu", "description": "View dependent noise", "tags": ["fbm"], "likes": 12, "viewed": 270, "published": 3, "date": "1662476953", "time_retrieved": "2024-07-30T16:32:23.149806", "image_code": "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n#define MAX_FBM 8\n\nfloat fbm(vec2 uv, float baseFreq, vec2 eye, float lodSpeed) {\n    float lodLevel = length(eye - uv) * lodSpeed;\n    uv *= baseFreq;\n    float amplitude = 1.0, rougthness = 1.0;\n    float f = 0.0;\n    int i = 0;\n    float t = 1.0 / lodLevel;\n    for (; i < MAX_FBM; ++i) {\n        if(float(i) > t) \n            break;\n        f += snoise(uv * amplitude) * rougthness;\n        amplitude *= 2.0;\n        rougthness /= 1.3;\n    }\n    t = min(t, float(MAX_FBM));\n    f += (1.0 - (float(i) - t)) * snoise(uv * amplitude) * rougthness;\n    return f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n    vec2 m = (iMouse.xy - iResolution.xy / 2.0) / iResolution.xx ;\n    fragColor.xyz = vec3(fbm(uv, 2.0, m, 1.0) * 0.5 + 0.5);\n    fragColor.r += float(step(length(uv - m), 0.01));\n    fragColor.gb -= float(step(length(uv - m), 0.01));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfXWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 70], [72, 72, 93, 93, 142], [144, 144, 166, 166, 203], [205, 205, 229, 229, 1737], [2305, 2305, 2362, 2362, 2670]], "test": "untested"}
{"id": "slKcDt", "name": "Rule 110 CA", "author": "lukeathedev", "description": "This is Turing Complete!", "tags": ["gameoflife", "cellularautomaton", "gol", "emergent", "rule110"], "likes": 5, "viewed": 203, "published": 3, "date": "1662472234", "time_retrieved": "2024-07-30T16:32:23.929721", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "bool brand(float x) {\n    return fract(abs(sin(x * 301.238)) * x * 138.83) > 0.5;\n}\n\nbool alive(ivec2 c) {\n    vec3 t = texelFetch(iChannel0, c, 0).rgb;\n    return t.r > 0.0 ||\n           t.g > 0.0 ||\n           t.b > 0.0;\n}\n\nvoid mainImage( out vec4 C, in vec2 P )\n{\n    // Rule 110\n    // 7 6 5 4 3 2 1 0\n    // 0 1 1 0 1 1 1 0\n    int c = 0;\n    for (int x = -1; x < 2; ++x) {\n        // Look below current line\n        if (alive(ivec2(int(P.x) - x, int(P.y) - 1))) c += 1 << (1-x);\n    }\n    \n    bool state = alive(ivec2(P));\n    bool alive = false;\n    \n    // Not very elegant\n    if (c==6||c==5||c==3||c==2||c==1) alive = true;\n    //if (c == 0) alive = true;\n    \n    vec2 uv = P/iResolution.xy;\n    vec3 rainbow = 0.5 + 0.5*cos(iTime*80./iResolution.y+uv.xyx+vec3(0,2,4));\n    vec4 col = texelFetch(iChannel0, ivec2(P), 0);\n    \n    C = alive ? (!state ? vec4(rainbow, 1.0) : col) : vec4(0.0);\n    if (int(P.y) == 0) {\n        C = brand(P.x * P.y) ? vec4(1.0) : vec4(0.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 214]], "test": "untested"}
{"id": "stVyDt", "name": "chromatic aberration 3", "author": "FabriceNeyret2", "description": "from top to bottom:\n- Image of a white band on black background with chromatic aberration ( amount increasing to top, or Mouse.y ).\n- full spectrum sum from IR to f\n- full spectrum sum from f to UV\n- show spectrum", "tags": ["spectrum", "color", "perception", "metameric"], "likes": 28, "viewed": 454, "published": 3, "date": "1662470195", "time_retrieved": "2024-07-30T16:32:24.733572", "image_code": "// variant of \"why sky color is not violet\" by FabriceNeyret2. https://shadertoy.com/view/ltSBRt\n// perception = int( intensity(f) * coneResponse(f) )\n// using very heuristical cone response. ( May try with: https://www.shadertoy.com/view/llKSDz )\n\n#define N 200.            // spectrum sampling rate\n\n#define RGB(f, fc) ( .5 + .5* cos(3.14*clamp(f-(fc),-1.,1.) ) ) // base lobe approximation\n#define EQ(f,a) ( abs(f-(a)) < .5/N )\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    O -= O;\n    vec2 R = iResolution.xy;\n    U /= R;\n    float y = 7.*U.y, a = fract(y), \n          A = iMouse.z>0. ? iMouse.y/R.y : y >4. ? .5 * ( y-4.) / 3. : .05, // aberration amount\n          F = 2.*(2.*U.x-1.),\n          I, v=0., r=1.;    \n    if (a < 6./R.y && y < 5.) return;              // line separator\n    \n    for (float f=-2.; f<2.; f+=1./N) {             // --- color spectrum (normalized):\n        r = step( abs(F-f*A), .5 );\n        I =   y > 3. ?             r               // integrate filter intensity\n            : y > 2. ?      f<F  ? 1. : 0.         // sum from IR to F\n            : y > 1. ?      f>F  ? 1. : 0.         // sum from F to UV\n            :            EQ(f,F) ? 1. : 0. ;       // peak at F ( i.e. show full spectrum )\n       \n        v += I;\n        O[0] += I * ( RGB(f, -2./3.)*.7 + RGB(f, 2./3.)*.3);  // perceptive integration\n        O[1] += I * RGB(f,  0.   );\n        O[2] += I * RGB(f,  2./3.);\n    }\n    \n // if ( y > 1. ) O *= 2./v;                       // normalization by luminance\n    if ( y > 1. ) O /= N;\n    O = pow(O,vec4(1./2.2));                       // RGB to sRGB transform\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stVyDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[432, 432, 471, 471, 1609]], "test": "untested"}
{"id": "NlKyDd", "name": "Forward Gradient Fitting", "author": "paniq", "description": "fitting an arbitrary 1D function or point set with a SIREN neural network using a combination of Adam and forward gradient optimization https://arxiv.org/pdf/2202.08587.pdf - also uses differential evolution laterally for best of breed effects.", "tags": ["gradient", "optimization", "training", "fitting", "forward", "siren", "ml", "cost", "loss", "adam"], "likes": 17, "viewed": 521, "published": 3, "date": "1662464222", "time_retrieved": "2024-07-30T16:32:26.184693", "image_code": "//////////////////////////////////////////////////////////\n\nModel f_scoeffs;\nfloat f_scoeffs_func(float x) {\n    ModelIO io;\n    io.i[0] = ad_const(x);\n    model_eval(f_scoeffs, f_scoeffs, io);\n    return io.o[0].x;\n}\n\nfloat f_error(float x) {\n    return pow2(f_scoeffs_func(x) - target_func(x))*1000.0 - 1.0;\n}\n\nvoid paint() {\n    setup_s_K(iFrame);\n    float t = iTime;\n    \n    Random rng = seed(seed(get_origin()), iFrame);\n    int mi = range(rng, 0, int(iResolution.y));\n    //mi = 0;\n\n    Model source;\n    for (int i = 0; i < ModelSize; ++i) {\n#if EMA\n        source.c[i] = texelFetch(iChannel0, ivec2(i,mi), 0).a / (1.0 - pow(beta2, float(iFrame+1)));\n#else\n        source.c[i] = texelFetch(iChannel0, ivec2(i,mi), 0).x;\n#endif\n    }\n\n    set_source_rgb(0.0,0.0,0.0);\n    clear();\n    \n    grid(vec2(1.0/10.0));\n    set_line_width_px(1.0);\n    set_source_rgba(vec4(vec3(1.0),0.3));\n    stroke();\n\n    set_source_rgba(vec4(vec3(1.0),0.7));\n    rectangle(-1.0,-1.0,2.0,2.0);\n    stroke();\n\n    f_scoeffs = source;\n#ifdef FIT_POINTS\n    set_source_rgba(vec4(vec3(1.0,0.5,0.5),1.0));\n    for (int i = 0; i < FIT_POINTS; ++i) {\n        vec2 p = get_point(i, iFrame);\n        float y = f_scoeffs_func(p.x);\n        float err = pow2(y - p.y) / 1e-3;\n        move_to(p.x, -1.0);\n        line_to(p.x, -1.0 + err);\n        stroke();\n    }\n    set_source_rgba(vec4(vec3(1.0),1.0));\n    for (int i = 0; i < FIT_POINTS; ++i) {\n        circle(get_point(i, iFrame), 0.02);\n        fill();\n    }\n#else\n    graph1D(target_func);\n    set_source_rgba(vec4(vec3(1.0),1.0));\n    stroke();\n    \n    graph1D(f_error);\n    set_source_rgba(vec4(vec3(1.0,0.5,0.5),1.0));\n    stroke();\n#endif\n#if 0\n    graph1D(f_scoeffs_func_i0);\n    set_line_width_px(1.0);\n    set_source_rgba(vec4(vec3(0.8,0.5,1.0),0.8));\n    stroke();\n    graph1D(f_scoeffs_func_i1);\n    set_line_width_px(1.0);\n    set_source_rgba(vec4(vec3(0.8,0.5,1.0),0.8));\n    stroke();\n#endif\n    graph1D(f_scoeffs_func);\n    set_line_width_px(2.0);\n    set_source_rgba(vec4(vec3(0.8,0.5,1.0),1.0));\n    stroke();\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord, iMouse.xy, iResolution.xy);\n\n    paint();\n\n    blit(fragColor);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n// fit a random cloud of points instead\n#define FIT_POINTS 32\n// use triangle wave (PSIREN) rather than sinusoid (SIREN)\n#define USE_TRI 0\n\n// if 0, project random vector; if 1, compute full gradient (slow, O(n^2) for n weights)\n// empirically, stochastic descent takes longer to ramp up speed, but appears to take\n// twice as many steps, but converges much faster in this shader, simply because the\n// framerate is higher.\n// using newton stepmethods requires a full gradient\n#define FULL_GRADIENT 0\n\n// forward gradient descent (https://arxiv.org/abs/2202.08587)\n#define METHOD_FGD 0\n// Adam gradient descent (https://arxiv.org/abs/1412.6980, algorithm 1)\n#define METHOD_ADAM 1\n// AdaMax gradient descent (https://arxiv.org/abs/1412.6980, algorithm 2)\n#define METHOD_ADAMAX 2\n\n#define METHOD METHOD_ADAM\n//#define METHOD METHOD_FGD\n\n// step by negative gradient\n#define STEPMETHOD_GRADIENT 0\n// step by newton's method, unbounded\n#define STEPMETHOD_NEWTON 1\n// step by newton's method, clamped (this one is quite good for functions with discontinuities)\n#define STEPMETHOD_CLAMP_NEWTON 2\nconst float newton_clamp_limit = 10.0;\n// step by newton's method, softclamped (same)\n#define STEPMETHOD_SOFTCLAMP_NEWTON 3\n\n#define STEPMETHOD STEPMETHOD_GRADIENT\n//#define STEPMETHOD STEPMETHOD_CLAMP_NEWTON\n\n// if 1, smooth result with exponential moving average; needs restart\n// (https://arxiv.org/abs/1412.6980, 7.2)\n#define EMA 0\n\n#if (METHOD == METHOD_ADAMAX)\nconst float alpha = 0.002;\n#elif (METHOD == METHOD_ADAM)\nconst float alpha = 0.001;\n#else\nconst float alpha = 0.001;\n#endif\n#if FULL_GRADIENT\nconst float beta1 = 0.9;\nconst float beta2 = 0.999;\n#else\nconst float beta1 = 0.95;\nconst float beta2 = 0.9995;\n#endif\nconst float epsilon = 10.0 * 1e-8;\n\nconst float max_float = 3.402e+38;\n\n// for stochastic descent, if set to 1, clamp the random gradient\n// close to infinity and normalize.\n#define NORMALIZE_MC_GRADIENT 0\n#if NORMALIZE_MC_GRADIENT\nconst float gradient_clamp = 3.402e+38;\n#else\n// for stochastic descent, clamp the generated gaussian amplitudes\n// not doing so can cause sudden inf/nan death.\nconst float gradient_clamp = 1.0;\n#endif\n\nfloat smoothReLU(float x, float r) {\n    float xa = abs(x);\n    float c = max(r - xa, 0.0);\n    return 0.5*x + 0.5*xa + 0.25*c*c/r;\n}\nfloat smoothReLUdx(float x, float r) {\n    return clamp(0.5 + 0.5*x/r,0.0,1.0);\n}\n\nvec2 explu(vec2 x) {\n    float w = exp(x.x);\n    return vec2(w, x.y*w);\n}\n\nvec2 relu(vec2 x) {\n    return vec2(\n        max(0.0, x.x),\n        x.y*step(0.0, x.x));\n}\n\nvec2 gelu(float x) {\n    float w = exp(x);\n    float ww = w + 1.0;\n    return vec2(\n        x*w/(1.0 + w),\n        w*(x + w + 1.0) / (ww*ww));\n}\n\nfloat s_K = 1.0;\n\nvec2 clamped_relu(vec2 x) {\n    return vec2(\n        clamp(x.x, 0.0, 1.0),\n        x.y*step(0.0,x.x)*step(x.x,1.0));\n}\n\nvec2 logistic(vec2 x) {\n    float w = exp(-x.x);\n    float w1 = w + 1.0;\n    return vec2(\n        1.0 / (1.0 + w),\n        x.y*w/(w1*w1));\n}\n\nvec2 tanhlu(vec2 x) {\n    float w = tanh(x.x);\n    return vec2(w, x.y*(1.0 - w*w));\n}\n\n// logistic function over 0..1, with unit rate of change\n// the smooth version of clamped_relu()\nvec2 logistic_unit(vec2 x) {\n    float w = exp(-4.0*x.x + 2.0);\n    float w1 = w + 1.0;\n    return vec2(\n        1.0 / (1.0 + w),\n        4.0*x.y*w/(w1*w1));\n}\n\n// logistic unit clamped to zero \nvec2 clamped_logistic_unit(vec2 x) {\n    const float K = exp(0.01);\n    vec2 q = x;\n    q.x -= 0.5;\n    q /= K;\n    q.x += 0.5;\n    q = logistic_unit(x);\n    q.x -= 0.5;\n    q *= K;\n    q.x += 0.5;\n    return clamped_relu(q);\n}\n\n// inverse of logistic unit\nvec2 inv_logistic_unit(vec2 x) {\n    return vec2(\n        0.5 - 0.25*log(1.0/x.x - 1.0),\n        x.y*0.25/((1.0 / x.x - 1.0)*x.x*x.x));\n}\n\nvec2 lerp_logistic_unit_to_clamped_relu(vec2 x) {\n    vec2 b = clamped_relu(x);\n    if (s_K < 1e-3)\n        return b;\n    vec2 a = logistic_unit(x);\n    return mix(b, a, s_K);\n}\n\nvec2 crazy(vec2 x) {\n    float w = exp(-x.x*x.x);\n    float ws = w*sin(x.x);\n    float wc = w*cos(x.x);\n    return vec2(\n        w,\n        x.y*w*(cos(x.x) - 2.0*sin(x.x)*x.x));\n}\n\nvoid setup_s_K(int frame) {\n    // after 100 seconds, lower K towards zero, approximating the sharp ReLU function\n    float t = float(frame) / 60.0;\n    //s_K = 1.0 / (1.0 + pow(float(t)/100.0,2.0));    \n    //Random rng = seed(frame);\n    s_K = exp(-t/5.0);\n    //s_K = 1.0 / (1.0 + t/100.0);\n}\n\n/////////////////////////////////////////////////////////////////////////\n\nbool isbad(float x) {\n    return isinf(x) || isnan(x);\n}\n\nvec2 ad_const(float c) {\n    return vec2(c, 0.0);\n}\n\nvec2 ad_max(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nvec2 ad_mul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x, a.x*b.y + a.y*b.x);\n}\nvec2 ad_mul(vec2 a, float b) {\n    return a * b;\n}\nvec2 ad_neg(vec2 a) {\n    return -a;\n}\nvec2 ad_sq(vec2 a) {\n    return vec2(a.x * a.x, 2.0*a.x*a.y);\n}\nvec2 ad_sqrt(vec2 a) {\n    float w = sqrt(a.x);\n    return vec2(w, 0.5 * a.y / w);\n}\nvec2 ad_abs(vec2 a) {\n    return vec2(abs(a.x), sign(a.x)*a.y);\n}\nvec2 ad_add(vec2 a, vec2 b) {\n    return a + b;\n}\nvec2 ad_add(vec2 a, float b) {\n    return vec2(a.x + b, a.y);\n}\nvec2 ad_sub(vec2 a, float b) {\n    return vec2(a.x - b, a.y);\n}\nvec2 ad_div(vec2 a, vec2 b) {\n    return vec2(a.x / b.x, a.y/b.x - a.x*b.y/(b.x*b.x));\n}\nvec2 ad_sin(vec2 a) {\n    return vec2(sin(a.x), a.y*cos(a.x));\n}\nconst float pi = 3.14159265359;\nvec2 ad_sin_L1T(vec2 a) {\n    return vec2(\n        (abs(2.0-abs(fract(a.x/(2.0*pi))*4.0-1.0))-1.0)*pi/2.0,\n        a.y*sign(1.0-fract(a.x/(2.0*pi) + 1.0/4.0)*2.0));\n}\nvec2 ad_sin_L1(vec2 a) {\n    return vec2(\n        (abs(2.0-abs(fract(a.x/(2.0*pi))*4.0-1.0))-1.0),\n        a.y*sign(1.0-fract(a.x/(2.0*pi) + 1.0/4.0)*2.0))*2.0/pi;\n}\nvec2 ad_fract(vec2 a) {\n    return vec2(\n        fract(a.x),\n        a.y);\n}\nvec2 ad_tri(vec2 a) {\n    float w = fract(a.x);\n    return vec2(\n        abs(0.5-w),\n        a.y*sign(w-0.5));\n}\nvec2 ad_mf(vec2 a) {\n    float w = fract(a.x);\n    return vec2(\n        min(w, 0.5),\n        step(w, 0.5));\n}\nvec2 ad_exp2(vec2 a) {\n    float w = exp2(a.x);\n    return vec2(w, a.y*w*log(2.0));\n}\nvec2 ad_gfloor(vec2 a) {\n    float k = exp2(-4.0);\n    float w = floor(a.x/k)*k;\n    //return vec2(a.x + w, a.y);\n    return vec2(w, a.y);\n}\n\n// edit target_func() at the very bottom of this file to define the target to fit\n\n\n// 2d vector graphics library (https://www.shadertoy.com/view/lslXW8)\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.16\n\n// I release this into the public domain.\n// some estimators have been lifted from other shaders and are not\n// necessarily PD licensed, note the links in the source code comments below.\n\n// 2020-12-02: 0.16\n// * support for drawing concentric rings\n\n// 2020-11-30: 0.15\n// * support for drawing orthogonal grids\n// * adjusted uv so corners are centered on pixels\n// * small adjustment to line pixel width computation\n\n// 2020-11-12: 0.14\n// * added support for depth testing\n\n// 2020-11-11: 0.13\n// * fixed 2D graphs not filling\n// * added circle_px()\n\n// 2019-06-06: 0.12\n// * split implementation and demo into common and image tab\n\n// 2017-10-05: 0.11\n// * anti-aliasing is gamma-correct\n\n// 2017-10-01: 0.10\n// * added experimental letter() function\n\n// 2017-09-30: 0.9\n// * save() is now a declarative macro\n\n// 2017-09-11: 0.8\n// * added ellipse()\n\n// 2017-09-10: 0.7\n// * paths painted with line_to/curve_to can be filled.\n\n// 2017-09-09: 0.6\n// * added rounded_rectangle()\n// * added set_source_linear_gradient()\n// * added set_source_radial_gradient()\n// * added set_source_blend_mode()\n// * added support for non-uniform scaling\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1);\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1);\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r);\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r);\nvoid set_source(sampler2D image);\nvoid set_source_depth(float depth);\n// control how source changes are applied\nconst int Replace = 0; // default: replace the old source with the new one\nconst int Alpha = 1; // alpha-blend the new source on top of the old one\nconst int Multiply = 2; // multiply the new source with the old one\nvoid set_source_blend_mode(int mode);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n// if enabled, use the depth value for testing;\n// smaller values win\nvoid depth_test(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a circle path at P with pixel radius R\nvoid circle_px(vec2 p, float r);\nvoid circle_px(float x, float y, float r);\n// add an ellipse path at P with radii RW and RH\nvoid ellipse(vec2 p, vec2 r);\nvoid ellipse(float x, float y, float rw, float rh);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n// add a rectangle at O with size S and rounded corner of radius R\nvoid rounded_rectangle(vec2 o, vec2 s, float r);\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r);\n\n// add an orthogonal grid with cell size S\nvoid grid(vec2 s);\nvoid grid(float w, float h);\nvoid grid(float s);\n// draw concentric rings around origin p, with spacing r and offset phase\nvoid rings(vec2 p, float r, float phase);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// draw a letter with the given texture coordinate\nvoid letter(sampler2D font_texture_source, ivec2 l);\nvoid letter(sampler2D font_texture_source, int lx, int ly);\n    \n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// non-uniformly scale the context by S\nvoid scale(vec2 s);\nvoid scale(float sx, float sy);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    vec2 clip;\n    vec2 scale;\n    float line_width;\n    bool premultiply;\n    bool depth_test;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n    int source_blend;\n    bool has_clip;\n    float source_z;\n};\n\n// save current stroke width, starting\n// point and blend mode from active context.\nContext _save();\n#define save(name) Context name = _save();\n// restore stroke width, starting point\n// and blend mode to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\nvoid debug_clip_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp(\n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n#define DEFAULT_CLIP_V -1e+20\n#define DEFAULT_DEPTH 1e+30\n\nContext _stack;\n\nvoid init (vec2 fragCoord, vec2 mouse, vec2 resolution) {\n\taspect = vec2(resolution.x / resolution.y, 1.0);\n\tScreenH = min(resolution.x,resolution.y);\n\tAA = ScreenH*0.5;\n\tAAINV = 1.0 / AA;\n    \n    uv = (fragCoord.xy - 0.5) / resolution;\n    vec2 m = mouse / resolution;\n\n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n\n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        vec2(DEFAULT_CLIP_V),\n        vec2(1.0),\n        1.0,\n        false,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0),\n        Replace,\n        false,\n        DEFAULT_DEPTH\n    );\n}\n\nvec3 _color = vec3(1);\nfloat _depth = DEFAULT_DEPTH;\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n    _stack.clip.y = DEFAULT_CLIP_V;\n}\n\nContext _save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;\n    vec2 clip = _stack.clip;\n    bool has_clip = _stack.has_clip;\n    // preserve source\n    vec4 source = _stack.source;\n    _stack = ctx;\n    _stack.shape = shape;\n    _stack.clip = clip;\n    _stack.source = source;\n    _stack.has_clip = has_clip;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = vec2(1.0);\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;\n    _stack.scale = vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    _stack.scale *= vec2(length(mtx[0].xy), length(mtx[1].xy));\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(vec2 s) {\n    transform(mat3(s.x,0.0,0.0,0.0,s.y,0.0,0.0,0.0,1.0));\n}\n\nvoid scale(float sx, float sy) {\n    scale(vec2(sx, sy));\n}\n\nvoid scale(float s) {\n    scale(vec2(s));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color.rgb = mix(_color.rgb, _stack.source.rgb, _stack.source.a);\n    _depth = (_stack.source.a == 1.0)?_stack.source_z:_depth;\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(pow(_color.rgb, vec3(1.0/2.2)), 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color.rgb;\n}\n\nvoid add_clip(vec2 d) {\n    d = d / _stack.scale;\n    _stack.clip = max(_stack.clip, d);\n    _stack.has_clip = true;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);\n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n    _stack.clip = vec2(DEFAULT_CLIP_V);\n    _stack.has_clip = false;\n}\n\nvoid debug_gradient() {\n    vec2 d = _stack.shape;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid debug_clip_gradient() {\n    vec2 d = _stack.clip;\n    _color.rgb = mix(_color.rgb,\n        hsl(d.x * 6.0,\n            1.0, (d.x>=0.0)?0.5:0.3),\n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    if (_stack.depth_test) {\n        if ((w == 1.0) && (_stack.source_z <= _depth)) {\n            _depth = _stack.source_z;\n        } else if ((w == 0.0) || (_stack.source_z > _depth)) {            \n            return;\n        }\n    }\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color.rgb = _color.rgb * (1.0 - src_a) + rgba.rgb * dst_a;\n}\n\n\nvoid depth_test(bool enable) {\n    _stack.depth_test = enable;\n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat min_uniform_scale() {\n    return min(_stack.scale.x, _stack.scale.y);\n}\n\nfloat uniform_scale_for_aa() {\n    return min(1.0, _stack.scale.x / _stack.scale.y);\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA*uniform_scale_for_aa(), 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);\n\treturn wa * wb;\n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n    if (_stack.has_clip) {\n\t    write_color(_stack.source, calc_aa_blur(_stack.clip.x));        \n    }\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*min_uniform_scale() * AAINV;\n}\n\nfloat get_gradient_eps() {\n    return (1.0 / min_uniform_scale()) * AAINV;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    //c.rgb *= c.rgb;\n    c *= c;\n    if (_stack.source_blend == Multiply) {\n        _stack.source *= c;\n    } else if (_stack.source_blend == Alpha) {\n    \tfloat src_a = c.a;\n    \tfloat dst_a = _stack.premultiply?1.0:src_a;\n\t    _stack.source =\n            vec4(_stack.source.rgb * (1.0 - src_a) + c.rgb * dst_a,\n                 max(_stack.source.a, c.a));\n    } else {\n    \t_stack.source = c;\n    }\n}\n\nvoid set_source_depth(float depth) {\n    _stack.source_z = depth;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) {\n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvoid set_source_linear_gradient(vec4 color0, vec4 color1, vec2 p0, vec2 p1) {\n    vec2 pa = _stack.position.xy - p0;\n    vec2 ba = p1 - p0;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_linear_gradient(vec3 color0, vec3 color1, vec2 p0, vec2 p1) {\n    set_source_linear_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p0, p1);\n}\n\nvoid set_source_radial_gradient(vec4 color0, vec4 color1, vec2 p, float r) {\n    float h = clamp( length(_stack.position.xy - p) / r, 0.0, 1.0 );\n    set_source_rgba(mix(color0, color1, h));\n}\n\nvoid set_source_radial_gradient(vec3 color0, vec3 color1, vec2 p, float r) {\n    set_source_radial_gradient(vec4(color0, 1.0), vec4(color1, 1.0), p, r);\n}\n\nvoid set_source_blend_mode(int mode) {\n    _stack.source_blend = mode;\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid letter(sampler2D font_texture_source, ivec2 l) {\n  vec2 p = vec2(l);\n  vec3 tx;\n  vec2 ip;\n  float d;\n  int ic;\n  ip = vec2(l);\n  p += clamp(_stack.position.xy, 0.0, 1.0);\n  ic = 0x21 + int (mod (16. + ip.x + 2. * ip.y, 94.));\n  tx = texture (font_texture_source, mod ((vec2 (mod (float (ic), 16.),\n     15. - floor (float (ic) / 16.)) + fract (p)) * (1. / 16.), 1.)).gba - 0.5;\n  d = tx.b + 1. / 256.;\n  add_field(d / min_uniform_scale());\n}\n\nvoid letter(sampler2D font_texture_source, int lx, int ly) {\n    letter(font_texture_source, ivec2(lx,ly));\n}\n\nvoid rounded_rectangle(vec2 o, vec2 s, float r) {\n    s = (s * 0.5);\n    r = min(r, min(s.x, s.y));\n    o += s;\n    s -= r;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    vec2 df = max(dmin.xz, dmin.yw) + length2(dmax);\n    add_field(df - r);\n}\n\nvoid rounded_rectangle(float ox, float oy, float sx, float sy, float r) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), r);\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    rounded_rectangle(o, s, 0.0);\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rounded_rectangle(vec2(ox,oy), vec2(sx,sy), 0.0);\n}\n\nvoid grid(vec2 size) {\n    vec4 f = abs(fract(_stack.position/size.xyxy+0.5)-0.5)*size.xyxy;\n    add_field(vec2(min(f.x,f.y),min(f.z,f.w)));\n}\nvoid grid(float w, float h) {\n    grid(vec2(w,h));\n}\nvoid grid(float s) {\n    grid(vec2(s));\n}\nvoid rings(vec2 p, float r, float phase) {\n    vec4 q = _stack.position - p.xyxy;\n    vec2 f = abs(fract(vec2(length(q.xy),length(q.zw))/r-phase+0.5)-0.5)*r;\n    add_field(f);\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid circle_px(vec2 p, float r) {\n    circle(p, r/(0.5*ScreenH));\n}\nvoid circle_px(float x, float y, float r) {\n    circle_px(vec2(x,y), r);\n}\n\n// from https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n    if (l == 0.0) {\n        return length(p) - ab.x;\n    }\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = vec2( ab.x*co, ab.y*si );\n\t\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nvoid ellipse(vec2 p, vec2 r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(sdEllipse(c.xy, r), sdEllipse(c.zw, r)));\n}\n\nvoid ellipse(float x, float y, float rw, float rh) {\n    ellipse(vec2(x,y), vec2(rw, rh));\n}\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 s = sign(pa.xz*ba.y-pa.yw*ba.x);\n    vec2 d = length2(pa - ba.xyxy*h.xxyy);\n    add_field(d);\n    add_clip(d * s);\n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat test_cross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat bezier_sign(vec2 A, vec2 B, vec2 C, vec2 p) {\n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0,\n        step(test_cross(A, B, p) * test_cross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * test_cross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);\n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    vec2 shape = vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw));\n    add_field(abs(shape));\n    add_clip(shape);\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(f_x / length(df_x));\n}\n\n// random number generator library (https://www.shadertoy.com/view/ssGXDd)\n// by Leonard Ritter (@leonard_ritter)\n\n// based on https://www.shadertoy.com/view/MdcfDj\n// license: https://unlicense.org/\n\n// comment out for faster but lower quality hashing\n#define RNGL_HIGH_QUALITY\n\nstruct Random { uint s0; uint s1; };\n\n// constructors; note that constructors are wilfully unique,\n// i.e. calling a different constructor with the same arguments will not\n// necessarily produce the same state.\nuint uhash(uint a, uint b);\nRandom seed(uint s) { return Random(s, uhash(0x1ef7c663u, s)); }\nRandom seed(uvec2 s) { return Random(s.y, uhash(s.x, s.y)); }\nRandom seed(Random a, uint b) { return Random(b, uhash(a.s1, b)); }\nRandom seed(Random a, uvec2 b) { return seed(a, uhash(b.x, b.y)); }\nRandom seed(Random a, uvec3 b) { return seed(a, uhash(uhash(b.x, b.y), b.z)); }\nRandom seed(Random a, uvec4 b) { return seed(a, uhash(uhash(b.x, b.y), uhash(b.z, b.w))); }\nRandom seed(uvec3 s) { return seed(seed(s.xy), s.z); }\nRandom seed(uvec4 s) { return seed(seed(s.xy), s.zw); }\nRandom seed(int s) { return seed(uint(s)); }\nRandom seed(ivec2 s) { return seed(uvec2(s)); }\nRandom seed(ivec3 s) { return seed(uvec3(s)); }\nRandom seed(ivec4 s) { return seed(uvec4(s)); }\nRandom seed(Random a, int b) { return seed(a, uint(b)); }\nRandom seed(Random a, ivec2 b) { return seed(a, uvec2(b)); }\nRandom seed(Random a, ivec3 b) { return seed(a, uvec3(b)); }\nRandom seed(Random a, ivec4 b) { return seed(a, uvec4(b)); }\nRandom seed(float s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec2 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec3 s) { return seed(floatBitsToUint(s)); }\nRandom seed(vec4 s) { return seed(floatBitsToUint(s)); }\nRandom seed(Random a, float b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec2 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec3 b) { return seed(a, floatBitsToUint(b)); }\nRandom seed(Random a, vec4 b) { return seed(a, floatBitsToUint(b)); }\n\n// fundamental functions to fetch a new random number\n// the last static call to the rng will be optimized out\nuint urandom(inout Random rng) {\n    uint last = rng.s1;\n    uint next = uhash(rng.s0, rng.s1);\n    rng.s0 = rng.s1; rng.s1 = next;\n    return last;\n}\nuvec2 urandom2(inout Random rng) { return uvec2(urandom(rng),urandom(rng)); }\nuvec3 urandom3(inout Random rng) { return uvec3(urandom2(rng),urandom(rng)); }\nuvec4 urandom4(inout Random rng) { return uvec4(urandom2(rng),urandom2(rng)); }\nint irandom(inout Random rng) { return int(urandom(rng)); }\nivec2 irandom2(inout Random rng) { return ivec2(urandom2(rng)); }\nivec3 irandom3(inout Random rng) { return ivec3(urandom3(rng)); }\nivec4 irandom4(inout Random rng) { return ivec4(urandom4(rng)); }\n\nfloat unorm(uint n);\nfloat random(inout Random rng) { return unorm(urandom(rng)); }\nvec2 random2(inout Random rng) { return vec2(random(rng),random(rng)); }\nvec3 random3(inout Random rng) { return vec3(random2(rng),random(rng)); }\nvec4 random4(inout Random rng) { return vec4(random2(rng),random2(rng)); }\n\n// ranged random value < maximum value\nint range(inout Random rng, int mn, int mx) { return mn + (irandom(rng) % (mx - mn)); }\nivec2 range(inout Random rng, ivec2 mn, ivec2 mx) { return mn + (irandom2(rng) % (mx - mn)); }\nivec3 range(inout Random rng, ivec3 mn, ivec3 mx) { return mn + (irandom3(rng) % (mx - mn)); }\nivec4 range(inout Random rng, ivec4 mn, ivec4 mx) { return mn + (irandom4(rng) % (mx - mn)); }\nuint range(inout Random rng, uint mn, uint mx) { return mn + (urandom(rng) % (mx - mn)); }\nuvec2 range(inout Random rng, uvec2 mn, uvec2 mx) { return mn + (urandom2(rng) % (mx - mn)); }\nuvec3 range(inout Random rng, uvec3 mn, uvec3 mx) { return mn + (urandom3(rng) % (mx - mn)); }\nuvec4 range(inout Random rng, uvec4 mn, uvec4 mx) { return mn + (urandom4(rng) % (mx - mn)); }\nfloat range(inout Random rng, float mn, float mx) { float x=random(rng); return mn*(1.0-x) + mx*x; }\nvec2 range(inout Random rng, vec2 mn, vec2 mx) { vec2 x=random2(rng); return mn*(1.0-x) + mx*x; }\nvec3 range(inout Random rng, vec3 mn, vec3 mx) { vec3 x=random3(rng); return mn*(1.0-x) + mx*x; }\nvec4 range(inout Random rng, vec4 mn, vec4 mx) { vec4 x=random4(rng); return mn*(1.0-x) + mx*x; }\n\n// marshalling functions for storage in image buffer and rng replay\nvec2 marshal(Random a) { return uintBitsToFloat(uvec2(a.s0,a.s1)); }\nRandom unmarshal(vec2 a) { uvec2 u = floatBitsToUint(a); return Random(u.x, u.y); }\n\n//// specific distributions\n\n// normal/gaussian distribution\n// see https://en.wikipedia.org/wiki/Normal_distribution\nfloat gaussian(inout Random rng, float mu, float sigma) {\n    vec2 q = random2(rng);\n    float g2rad = sqrt(-2.0 * (log(1.0 - q.y)));\n    float z = cos(q.x*6.28318530718) * g2rad;\n    return mu + z * sigma;\n}\n\n// triangular distribution\n// see https://en.wikipedia.org/wiki/Triangular_distribution\n// mode is a mixing argument in the range 0..1\nfloat triangular(inout Random rng, float low, float high, float mode) {\n    float u = random(rng);\n    if (u > mode) {\n        return high + (low - high) * (sqrt ((1.0 - u) * (1.0 - mode)));\n    } else {\n        return low + (high - low) * (sqrt (u * mode));\n    }\n}\nfloat triangular(inout Random rng, float low, float high) { return triangular(rng, low, high, 0.5); }\n\n// after https://www.shadertoy.com/view/4t2SDh\n// triangle distribution in the range -0.5 .. 1.5\nfloat triangle(inout Random rng) {\n    float u = random(rng);\n    float o = u * 2.0 - 1.0;\n    return max(-1.0, o / sqrt(abs(o))) - sign(o) + 0.5;\n}\n\n//// geometric & euclidean distributions\n\n// uniformly random point on the edge of a unit circle\n// produces 2d normal vector as well\nvec2 uniform_circle_edge (inout Random rng) {\n    float u = random(rng);\n    float phi = 6.28318530718*u;\n    return vec2(cos(phi),sin(phi));\n}\n\n// uniformly random point in unit circle\nvec2 uniform_circle_area (inout Random rng) {\n    return uniform_circle_edge(rng)*sqrt(random(rng));\n}\n\n// gaussian random point in unit circle\nvec2 gaussian_circle_area (inout Random rng, float k) {\n    return uniform_circle_edge(rng)*sqrt(-k*log(random(rng)));\n}\nvec2 gaussian_circle_area (inout Random rng) { return gaussian_circle_area(rng, 0.5); }\n\n// barycentric coordinates of a uniformly random point within a triangle\nvec3 uniform_triangle_area (inout Random rng) {\n    vec2 u = random2(rng);\n    if (u.x + u.y > 1.0) {\n        u = 1.0 - u;\n    }\n    return vec3(u.x, u.y, 1.0-u.x-u.y);\n}\n\n// uniformly random on the surface of a sphere\n// produces normal vectors as well\nvec3 uniform_sphere_area (inout Random rng) {\n    vec2 u = random2(rng);\n    float phi = 6.28318530718*u.x;\n    float rho_c = 2.0 * u.y - 1.0;\n    float rho_s = sqrt(1.0 - (rho_c * rho_c));\n    return vec3(rho_s * cos(phi), rho_s * sin(phi), rho_c);\n}\n\n// uniformly random within the volume of a sphere\nvec3 uniform_sphere_volume (inout Random rng) {\n    return uniform_sphere_area(rng) * pow(random(rng), 1.0/3.0);\n}\n\n// barycentric coordinates of a uniformly random point within a 3-simplex\n// based on \"Generating Random Points in a Tetrahedron\" by Rocchini et al\nvec4 uniform_simplex_volume (inout Random rng) {\n    vec3 u = random3(rng);\n    if(u.x + u.y > 1.0) {\n        u = 1.0 - u;\n    }\n    if(u.y + u.z > 1.0) {\n        u.yz = vec2(1.0 - u.z, 1.0 - u.x - u.y);\n    } else if(u.x + u.y + u.z > 1.0) {\n        u.xz = vec2(1.0 - u.y - u.z, u.x + u.y + u.z - 1.0);\n    }\n    return vec4(1.0 - u.x - u.y - u.z, u); \n}\n\n// for differential evolution, in addition to index K, we need to draw three more\n// indices a,b,c for a list of N items, without any collisions between k,a,b,c.\n// this is the O(1) hardcoded fisher-yates shuffle for this situation.\nivec3 sample_k_3(inout Random rng, int N, int K) {\n    ivec3 t = range(rng, ivec3(1,2,3), ivec3(N));\n    int db = (t.y == t.x)?1:t.y;\n    int dc = (t.z == t.y)?((t.x != 2)?2:1):((t.z == t.x)?1:t.z);\n    return (K + ivec3(t.x, db, dc)) % N;\n}\n\n/////////////////////////////////////////////////////////////////////////\n\n// if it turns out that you are unhappy with the distribution or performance\n// it is possible to exchange this function without changing the interface\nuint uhash(uint a, uint b) { \n    uint x = ((a * 1597334673U) ^ (b * 3812015801U));\n#ifdef RNGL_HIGH_QUALITY\n    // from https://nullprogram.com/blog/2018/07/31/\n    x = x ^ (x >> 16u);\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n    x = x ^ (x >> 16u);\n#else\n    x = x * 0x7feb352du;\n    x = x ^ (x >> 15u);\n    x = x * 0x846ca68bu;\n#endif\n    return x;\n}\nfloat unorm(uint n) { return float(n) * (1.0 / float(0xffffffffU)); }\n\n/////////////////////////////////////////////////////////////////////////\n\nfloat gain(float x, float P) {\n    if (x > 0.5)\n        return 1.0 - 0.5*pow(2.0-2.0*x, P);\n    else\n        return 0.5*pow(2.0*x, P);\n}\n\nfloat target_func(float x) {\n#if 0\n    Random rng = seed(4);\n    float y = random(rng);\n    for (int i = 1; i < 16; ++i) {\n        y = x*y + random(rng);\n    }\n    return y * 0.5 - 0.5;\n#elif 0\n    return sin(x*pi)*0.7;\n#elif 0\n    return sqrt(x*0.5+0.5) - 0.5;\n#elif 0\n    return 4.0*x*x-0.5;\n#elif 0\n    return tanh(x*10.0) * 0.5;\n#elif 0\n    return tanh(1.0 / (x*10.0)) * 0.5;\n#elif 0\n    return smoothstep(-0.25, 0.25, x)-0.5;\n#elif 1\n    return fract(x*1.0 + 0.5) - 0.5 + sin(x*pi)*0.1;\n#elif 0\n    return 1.0 / (x + 1.5) - 1.0;\n#elif 1\n    return abs(fract(x) - 0.5);\n#elif 1\n    return min(fract(x), 0.5);\n#elif 1\n    //return step(0.0, x)-0.9 + x*x;\n    return step(0.5, fract(x*0.5)) - 0.5;\n#else\n    return smoothstep(-0.1, 0.1, x)-0.5;\n#endif\n}\n\n#ifdef FIT_POINTS\nvec2 get_point(int i, int s) {\n    Random rng = seed(seed(i),0);\n    vec2 p = random2(rng);\n    //p.x = gaussian(rng, 0.5, 0.5);\n    p.x = float(i) / float(FIT_POINTS-1);\n    #if 1\n    //p.x = gain(p.x, 1.0/2.0); // distribute more samples at the border\n    //p.x = p.x*p.x;\n    p = p*2.0 - 1.0;\n    p.y = p.y * abs(p.x) * 0.0 + target_func(p.x);\n    #else\n    p = p*2.0 - 1.0;\n    #endif\n    return p;\n}\n#endif\n\nfloat pow2(float x) { return x*x; }\n\nstruct ModelSetup {\n    int input_count;\n    int layer_count;\n    int node_count;\n    int output_count;\n};\n\n#define NUM_MODEL_WEIGHTS(M) (M.node_count*(M.node_count*(M.layer_count - 1) + M.layer_count + M.input_count + M.output_count) + M.output_count)\n#define DEFINE_MODEL(NAME, IONAME, CFGNAME, SIZENAME, INPUTS, LAYERS, NODES, OUTPUTS) \\\n    const ModelSetup CFGNAME = ModelSetup(INPUTS, LAYERS, NODES, OUTPUTS); \\\n    const int SIZENAME = NUM_MODEL_WEIGHTS(CFGNAME); \\\n    struct NAME { \\\n        float c[SIZENAME]; \\\n    }; \\\n    struct IONAME { \\\n        vec2 i[INPUTS]; \\\n        vec2 o[OUTPUTS]; \\\n    };\n\n// for layer 0, node is in the range 0..NUM_NODES-1, edge is 0..NUM_INPUTS\n// for layer 1..NUM_LAYERS-1, node is in the range 0..NUM_NODES-1, edge is 0..NUM_NODES\n// for layer NUM_LAYERS, node is in the range 0..NUM_OUTPUTS-1, edge is 0..NUM_NODES\n// edge NUM_NODES is always the bias\nint weight_index(const ModelSetup setup, int layer, int node, int edge) {\n    int index = 0;\n    if (layer > 0) {\n        index = setup.node_count * ((setup.input_count + 1) + (setup.node_count + 1) * (layer - 1)) + node * (setup.node_count + 1) + edge;\n    } else {\n        index = node * (setup.input_count + 1) + edge;\n    }\n    return index;\n}\n#if USE_TRI\n#define ACTIVATE ad_tri\n#else\n#define ACTIVATE ad_sin\n#endif\n#define N(L, K, J) vec2(c.c[weight_index(setup, L, K, J)], v.c[weight_index(setup, L, K, J)])\n#define DEFINE_MODEL_EVAL_GRAD(NAME, MODELNAME, IONAME, CFGNAME) \\\nvoid NAME(MODELNAME c, MODELNAME v, inout IONAME io) { \\\n    const ModelSetup setup = CFGNAME; \\\n    /* first hidden layer */ \\\n    vec2 tmp0[CFGNAME.node_count]; \\\n    for (int k = 0; k < CFGNAME.node_count; ++k) { \\\n        tmp0[k] = N(0, k, CFGNAME.input_count); \\\n        for (int j = 0; j < CFGNAME.input_count; ++j) { \\\n            tmp0[k] = ad_add(tmp0[k], ad_mul(N(0, k, j), io.i[j])); \\\n        } \\\n        tmp0[k] = ACTIVATE(tmp0[k]); \\\n    } \\\n    /* rest of hidden layers */ \\\n    vec2 tmp1[CFGNAME.node_count]; \\\n    for (int l = 1; l < CFGNAME.layer_count; ++l) { \\\n        for (int k = 0; k < CFGNAME.node_count; ++k) { \\\n            tmp1[k] = N(l, k, CFGNAME.node_count); \\\n            for (int j = 0; j < CFGNAME.node_count; ++j) { \\\n                tmp1[k] = ad_add(tmp1[k], ad_mul(N(l, k, j), tmp0[j])); \\\n            } \\\n            tmp1[k] = ACTIVATE(tmp1[k]); \\\n        } \\\n        tmp0 = tmp1; \\\n    } \\\n    /* assemble output */ \\\n    for (int k = 0; k < CFGNAME.output_count; ++k) { \\\n        io.o[k] = N(CFGNAME.layer_count, k, CFGNAME.node_count); \\\n        for (int j = 0; j < CFGNAME.node_count; ++j) { \\\n            io.o[k] = ad_add(io.o[k], ad_mul(N(CFGNAME.layer_count, k, j), tmp0[j])); \\\n        } \\\n    } \\\n}\n\n#if USE_TRI\n#define DECLARE_INIT_CONSTANTS() \\\n    const float W_I = 15.0; \\\n    const float W_L = 1.0; \\\n    const float W_B = 1.0;\n#else\n#define DECLARE_INIT_CONSTANTS() \\\n    const float w0 = 30.0; \\\n    const float W_I = sqrt(6.0 / float(setup.input_count)) * w0; \\\n    const float W_L = sqrt(6.0 / (w0*w0*float(setup.node_count))) * w0; \\\n    const float W_B = 3.14159265359;\n#endif\n\n#define INITN(L, K, J) c.c[weight_index(setup, L, K, J)]\n#define DEFINE_MODEL_INIT(NAME, MODELNAME, CFGNAME) \\\nvoid NAME (inout MODELNAME c, inout Random rng) { \\\n    const ModelSetup setup = CFGNAME; \\\n    DECLARE_INIT_CONSTANTS(); \\\n    /* first hidden layer */ \\\n    for (int k = 0; k < CFGNAME.node_count; ++k) { \\\n        for (int j = 0; j < CFGNAME.input_count; ++j) { \\\n            INITN(0, k, j) = (random(rng)*2.0-1.0)*W_I; \\\n        } \\\n        /* init bias */ \\\n        INITN(0, k, CFGNAME.input_count) = (random(rng)*2.0-1.0)*W_B; \\\n    } \\\n    /* rest of hidden layers */ \\\n    for (int l = 1; l < CFGNAME.layer_count; ++l) { \\\n        for (int k = 0; k < CFGNAME.node_count; ++k) { \\\n            for (int j = 0; j < CFGNAME.node_count; ++j) { \\\n                INITN(l, k, j) = (random(rng)*2.0-1.0)*W_L; \\\n            } \\\n            /* init bias */ \\\n            INITN(l, k, CFGNAME.node_count) = (random(rng)*2.0-1.0)*W_B; \\\n        } \\\n    } \\\n    /* output weights */ \\\n    for (int k = 0; k < CFGNAME.output_count; ++k) { \\\n        for (int j = 0; j < CFGNAME.node_count; ++j) { \\\n            INITN(CFGNAME.layer_count, k, j) = random(rng)*2.0-1.0; \\\n        } \\\n        /* init bias */ \\\n        INITN(CFGNAME.layer_count, k, CFGNAME.node_count) = random(rng)*2.0-1.0; \\\n    } \\\n}\n\nDEFINE_MODEL(Model, ModelIO, model_setup, ModelSize, 1, 5, 2, 1)\nDEFINE_MODEL_EVAL_GRAD(model_eval, Model, ModelIO, model_setup)\nDEFINE_MODEL_INIT(model_init, Model, model_setup)\n", "buffer_a_code": "\nvec2 loss(Model source, Model v, int frame) {\n    vec2 err = vec2(0.0);\n    for (int i = 0; i < FIT_POINTS; ++i) {\n        vec2 p = get_point(i, frame);\n        ModelIO io;\n        io.i[0] = vec2(p.x, 0.0);\n        model_eval(source, v, io);\n        err += ad_sq(ad_sub(io.o[0], p.y));\n    }\n    err /= float(FIT_POINTS);\n    err = ad_sqrt(err);\n    //vec2 cost = model_cost(source, v);\n    //err.x += pow(err.y - 1.0, 2.0);\n    return err;\n}\n\n// https://arxiv.org/abs/2307.06324\nfloat alphastep() {\n    int n = (iFrame + 1) & ~iFrame;\n    return float(n % 63) * alpha;\n}\n#define alpha alphastep()\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup_s_K(iFrame);\n    ivec2 fc = ivec2(fragCoord);\n    int ci = fc.x;\n    int mi = fc.y;\n    if (ci < ModelSize) {\n        Model startp;\n        if (iFrame == 0) {\n            Random rng = seed(ivec2(mi, 0));\n            model_init(startp, rng);\n            fragColor = vec4(startp.c[ci],0.0,0.0,0.0);\n        } else {\n            Model m, v, ema;\n            float t = float(iFrame + 1);\n            for (int i = 0; i < ModelSize; ++i) {\n                vec4 data = texelFetch(iChannel0, ivec2(i,mi), 0);\n                startp.c[i] = data.r;\n                m.c[i] = data.g;\n                v.c[i] = data.b;\n#if EMA\n                ema.c[i] = data.a;\n#endif                \n            }\n\n            vec2 l = loss(startp, startp, iFrame);\n\n            Random rng = seed(seed(mi), iFrame);\n            #if 1\n            {\n                Model testp;\n                Model testm;\n                Model testv;\n                #if EMA\n                Model testema;\n                #endif\n                // apply one round of differential evolution\n                // do more and more the later it is\n                float CR = tanh(t/(60.0*30.0));\n                float F = 0.0;\n                ivec3 k = sample_k_3(rng, int(iResolution.y), mi);\n                int R = range(rng, 0, ModelSize);\n                for (int i = 0; i < ModelSize; ++i) {\n                    if ((i == R) || (random(rng) < CR)) {\n                        vec4 ai = texelFetch(iChannel0, ivec2(i, k.x), 0);\n                        vec4 bi = texelFetch(iChannel0, ivec2(i, k.y), 0);\n                        vec4 ci = texelFetch(iChannel0, ivec2(i, k.z), 0);\n                        testp.c[i] = ai.x + F * (bi.x - ci.x);\n                        testm.c[i] = ai.y + F * (bi.y - ci.y);\n                        testv.c[i] = ai.z + F * (bi.z - ci.z);\n                        #if EMA\n                        testema.c[i] = ai.w + F * (bi.w - ci.w);\n                        #endif\n                    } else {\n                        testp.c[i] = startp.c[i];\n                        testm.c[i] = m.c[i];\n                        testv.c[i] = v.c[i];\n                        #if EMA\n                        testema.c[i] = ema.c[i];\n                        #endif\n                    }\n                }\n                vec2 newloss = loss(testp, testp, iFrame);\n                if (newloss.x < l.x) {\n                    startp = testp;\n                    m = testm;\n                    v = testv;\n                #if EMA\n                    ema = testema;\n                #endif\n                }\n            }\n            #endif\n            Model g;\n#if FULL_GRADIENT\n            Model d;\n            for (int i = 0; i < ModelSize; ++i) {\n                d.c[i] = 0.0;\n            }\n            d.c[0] = 1.0;\n            g.c[0] = loss(startp, d, iFrame).y;\n            for (int i = 1; i < ModelSize; ++i) {\n                d.c[i-1] = 0.0;\n                d.c[i] = 1.0;\n                g.c[i] = loss(startp, d, iFrame).y;\n            }\n            vec2 f_d = vec2(1.0);\n#else\n            float nf = 0.0;\n            for (int i = 0; i < ModelSize; ++i) {\n                g.c[i] = clamp(gaussian(rng, 0.0, 1.0), -gradient_clamp, gradient_clamp); \n                nf += g.c[i]*g.c[i];\n            }            \n#if NORMALIZE_MC_GRADIENT\n            nf = 1.0 / (nf + epsilon); // surface of d-sphere\n            //nf *= pow(random(rng), 1.0/float(NUM_WEIGHTS)); // inside d-ball\n            for (int i = 0; i < ModelSize; ++i) {\n                g.c[i] = g.c[i] * nf;\n            }\n#endif\n            vec2 f_d = loss(startp, g, iFrame);\n#endif\n            for (int i = 0; i < ModelSize; ++i) {\n#if STEPMETHOD == STEPMETHOD_SOFTCLAMP_NEWTON\n                // softclamped newton's method\n                float g_c_i = tanh(f_d.x / (g.c[i] * f_d.y)); \n#elif STEPMETHOD == STEPMETHOD_CLAMP_NEWTON\n                // softclamped newton's method\n                float g_c_i = clamp(f_d.x / (g.c[i] * f_d.y), -newton_clamp_limit, newton_clamp_limit);\n#elif STEPMETHOD == STEPMETHOD_NEWTON\n                // newton's method\n                float g_c_i = f_d.x / (g.c[i] * f_d.y);\n#else // STEPMETHOD == STEPMETHOD_GRADIENT\n                float g_c_i = g.c[i] * f_d.y;\n#endif\n#if (METHOD == METHOD_ADAM)                \n                // Adam gradient descent (https://arxiv.org/abs/1412.6980, algorithm 1)\n                float g2_c_i = g_c_i*g_c_i;\n                m.c[i] = mix(g_c_i, m.c[i], beta1);\n                v.c[i] = mix(g2_c_i, v.c[i], beta2);\n                float mu_c_i = m.c[i] / (1.0 - pow(beta1, t));\n                float vu_c_i = v.c[i] / (1.0 - pow(beta2, t));\n                startp.c[i] = startp.c[i] - alpha * mu_c_i / (sqrt(vu_c_i) + epsilon);\n#elif (METHOD == METHOD_ADAMAX)\n                // AdaMax gradient descent (https://arxiv.org/abs/1412.6980, algorithm 2)\n                m.c[i] = mix(g_c_i, m.c[i], beta1);                \n                v.c[i] = max(beta2 * v.c[i], abs(g_c_i));\n                startp.c[i] = startp.c[i] - (alpha / (1.0 - pow(beta1, t))) * m.c[i] / (v.c[i] + epsilon);                \n#else // FGD\n                // Gradients without Backpropagation (https://arxiv.org/abs/2202.08587)\n                startp.c[i] = startp.c[i] - alpha * g_c_i;\n#endif\n#if EMA\n                // Ema extension (https://arxiv.org/abs/1412.6980, 7.2)\n                ema.c[i] = mix(startp.c[i], ema.c[i], beta2);\n#endif                 \n            }\n            fragColor = vec4(startp.c[ci],m.c[ci],v.c[ci],ema.c[ci]);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKyDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 108, 108, 217], [219, 219, 243, 243, 311], [313, 313, 327, 327, 2057], [2119, 2119, 2176, 2176, 2262]], "test": "untested"}
{"id": "NlKcDt", "name": "Lyapunov's Fractal", "author": "incription", "description": "https://en.wikipedia.org/wiki/Lyapunov_fractal\n\nChange S to different sequences to generate different diagrams", "tags": ["fractal", "lyapunov"], "likes": 3, "viewed": 240, "published": 3, "date": "1662457041", "time_retrieved": "2024-07-30T16:32:27.201973", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float minRes = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / minRes;\n\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float sum = data.y;\n    sum /= data.z;\n    \n    float l = 1. - 1. / pow(2., abs(sum));\n\n    vec3 col = vec3(0);\n    if(sign(sum) > 0.) col = mix(col, vec3(0.380,0.380,0.839), l);\n    else col = mix(col, vec3(1.000,0.855,0.141), 1.-l);\n    if(abs(uv.x) > 0.5) col= vec3(0);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float xn = data.x;\n    float sum = data.y;\n    float n = data.z;\n    \n    float minRes = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / minRes + .5;\n    vec2 pos = uv * 4. - .5 / minRes;\n    \n    float r, xn1;\n    xn1 = xn;\n    int Sl = S.length();\n    if(iFrame == 0) xn1 = .5;\n    for(int i = 0; i < 1; i++) {\n        for(int j = 0; j < Sl; j++) {\n            r = pos.yx[S[j]];\n            xn1 = r * xn1 * (1. - xn1);\n            sum += log(abs(r*(1.-2.*xn1)));\n            n += 1.;\n        }\n    }\n\n    fragColor = vec4(xn1, sum, n, data.w);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define A 0\n#define B 1\n\nint S[] = int[](A,B); ", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 591]], "test": "untested"}
{"id": "flKyDt", "name": "Ultimate Library 2", "author": "dr2", "description": "Another endless library", "tags": ["motion", "library", "replication", "book"], "likes": 26, "viewed": 336, "published": 3, "date": "1662451822", "time_retrieved": "2024-07-30T16:32:28.279092", "image_code": "// \"Ultimate Library 2\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  (Based on \"Library Lost and Found\", but with hexagonal floor plan and\n  motion along stairs).\n  Alternating movement paths; mouseable - click in upper/lower right corners\n  for pano and monochrome views.\n\n  No. 10 in \"Library\" series\n    \"Babel's Library\"           (4slcW2)\n    \"Bibliotheque\"              (lsXcWs)\n    \"Ultimate Library\"          (4s2czR)\n    \"Books and Stairs\"          (4djczw)\n    \"Mount Book\"                (XsjcRc)\n    \"Literary Tunnel\"           (ldSyDG)\n    \"Books and Stairs 2\"        (MtsfRl)\n    \"Library Lost and Found\"    (tdlBzH)\n    \"Reading Room\"              (fs3fzn)\n*/\n\n#define AA       0    // (= 0/1) optional antialiasing\n#define DO_FADE  0    // (= 0/1) optional fading\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexVertDist (vec2 p);\nfloat HexEdgeDist (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nvec3 qHit, ltPos, ltAx, cId;\nvec2 gSize, cMid, stAngCs;\nfloat dstFar, tCur, tDir, vuHt;\nint idObj, stLib;\nbool isPano, colImg, doClimb;\nconst int idFlr = 1, idCol = 2, idRail = 3, idStr = 4, idShlf = 5, idBk = 6, idLt = 7,\n   idSeatC = 8, idSeatM = 9;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qr, qs;\n  float dMin, d, r, a, s;\n  dMin = dstFar;\n  p = vec3 (p.xz - cMid, p.y - gSize.y * (cId.y + 0.5)).xzy;\n  r = length (p.xz);\n  qs = p;\n  qs.xz = Rot2D (qs.xz, pi / 6.);\n  a = (r > 0.) ? atan (qs.z, - qs.x) / (2. * pi) : 0.;\n  qs.xz = Rot2D (qs.xz, 2. * pi * (floor (6. * a + 0.5) / 6.));\n  q = p;\n  q.y = 0.5 * gSize.y - 0.3 - abs (p.y);\n  d = max (q.y, 9.8 - r);\n  DMINQ (idFlr);\n  if (stLib >= 3) {\n    q.y = p.y;\n    q.xz = qs.xz;\n    s = length (vec2 (q.x, abs (q.z)) - vec2 (-18.5, 5.));\n    d = min (s - 0.4, max (s - 0.6, 9.5 - abs (q.y)));\n    DMINQ (idCol);\n  }\n  if (stLib >= 4) {\n    qr = p;\n    qr.xz = Rot2Cs (qr.xz, - stAngCs);\n    q = qr;\n    q.xy = Rot2D (q.xy - 0.5 * gSize.y * vec2 (1., -1.), 0.25 * pi);\n    d = 0.5 * max (q.y - abs (0.5 - abs (0.5 - fract (q.x / sqrt (2.)))) * sqrt (2.),\n       max (abs (q.z) - 2.2, -0.2 - q.y));\n    q.xy = qr.xy;\n    DMINQ (idStr);\n    q = qr;\n    q.xy = Rot2D (q.xy, 0.25 * pi);\n    q.z = abs (q.z);\n    q.yz -= vec2 (-0.3, 1.2);\n    d = PrRoundCylDf (q.yzx, 0.1, 0.02, 12.);\n    DMINQ (idLt);\n  }\n  if (stLib >= 5) {\n    q = qr;\n    d = max (length (vec2 (r - 10.2, abs (q.y + 6.) - 1.3)) - 0.13, 2. - abs (q.z));\n    d = min (d, PrRoundCylDf (vec3 (abs (q.xz) - vec2 (10., 2.), q.y + 7.), 0.2, 0.05, 2.8));\n    d = min (d, PrRoundBox2Df (vec2 (r - 9.8, q.y - 0.5 * gSize.y * sign (q.y) - 0.05),\n       vec2 (0.05, 0.3), 0.05));\n    q.xz = Rot2D (q.xz, 2. * pi / 32.);\n    a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * a + 0.5) / 16.));\n    d = min (d, PrCylDf ((q - vec3 (-10.2, -7.2, 0.)).xzy, 0.13, 2.5));\n    q = qr;\n    q.xy = Rot2D (q.xy, 0.25 * pi);\n    d = min (d, max (length (vec2 (q.y - 3.8, abs (q.z) - 2.)) - 0.17, abs (qr.x) - 10.));\n    q = qr;\n    q.x += 20.;\n    q.xy = Rot2D (q.xy, 0.25 * pi);\n    d = min (d, max (length (vec2 (q.y - 3.8, abs (q.z) - 2.)) - 0.17, abs (qr.x) - 10.));\n    DMINQ (idRail);\n  }\n  if (stLib >= 6) {\n    q = p;\n    q.y -= -6.7;\n    s = 2.5 - abs (qs.z);\n    d = max (SmoothMax (PrRoundBox2Df (vec2 (r - 16.8, q.y), vec2 (1.15, 2.95), 0.05), s, 0.05),\n       - max (max (abs (r - 16.) - 1.5, abs (abs (q.y) - 1.4) - 1.25), 0.4 + s));\n    DMINQ (idShlf);\n    d = SmoothMax (PrRoundBox2Df (vec2 (r - 19.3, q.y + 1.8), vec2 (0.7, 1.2), 0.1),\n       6.5 - abs (qs.z), 0.2);\n    DMINQ (idSeatC);\n    d = SmoothMax (PrRoundBox2Df (vec2 (gSize.x * HexVertDist (q.xz / gSize.x) - 3., q.y + 1.8),\n       vec2 (1., 1.2), 0.1), 0.2 - gSize.x * HexEdgeDist (q.xz / gSize.x), 0.2);\n    DMINQ (idSeatM);\n  }\n  if (stLib == 7 && q.y > 0. || stLib >= 8) {\n    d = max (max (abs (r - 16.8) - 0.7, abs (q.y) - 2.8), 0.2 + s);\n    DMINQ (idBk);\n  }\n  if (stLib >= 2) {\n    q = p;\n    q.y -= 9.4;\n    d = length (vec2 (r - 11., q.y)) - 0.3;\n    q.xz = qs.xz;\n    q.x -= -17.;\n    d = min (d, PrRoundCylDf (q.xzy, 1., 0.02, 0.2));\n    DMINQ (idLt);\n  }\n  return dMin;\n}\n\nvoid SetCConf ()\n{\n  float a;\n  cMid = HexToPix (cId.xz * gSize.x);\n  a = (2. * pi / 6.) * floor (6. * Hashfv2 (cId.xz + vec2 (27.1, 37.1)));\n  if (doClimb && cId.x == cId.z) a = - pi / 3. - pi * mod (floor (cId.x / 3.), 2.);\n  stAngCs = sin (a + pi / 6. + vec2 (0.5 * pi, 0.));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec4 vri, hv;\n  vec3 vf, p, cIdP;\n  vec2 edN[3], pM, s;\n  float dHit, d, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = vec4 (gSize.x / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2])),\n     1. / rd.y);\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / gSize.x;\n  pM = HexToPix (PixToHex (ro.xz / gSize.x));\n  cIdP = vec3 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro + dHit * rd;\n    cId = vec3 (PixToHex (p.xz / gSize.x), floor (p.y / gSize.y)).xzy;\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetCConf ();\n    }\n    hv = vec4 ((vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))),\n       gSize.y * (cId.y + step (0., rd.y))) * vri;\n    s = vec2 (Minv3 (hv.xyz), dHit + abs (hv.w - p.y * vri.w));\n    d = ObjDf (p);\n    if (dHit + d < Minv2 (s)) {\n      dHit += d;\n    } else if (s.x < s.y) {\n      dHit = s.x + eps;\n      pM += sqrt3 * ((s.x == hv.x) ? edN[0] : ((s.x == hv.y) ? edN[1] : edN[2]));\n    } else {\n      dHit = s.y + eps;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP;\n  float ao, d;\n  int idObjT;\n  idObjT = idObj;\n  cIdP = vec3 (-999.);\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    d = 0.1 + float (j) / 8.;\n    p = ro + d * rd;\n    cId = vec3 (PixToHex (p.xz / gSize.x), floor (p.y / gSize.y)).xzy;\n    if (cId != cIdP) {\n      cIdP = cId;\n      SetCConf ();\n    }\n    ao += max (0., d - 3. * ObjDf (p));\n  }\n  idObj = idObjT;\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  vec2 r, dr;\n  float tt, h, dh, cxm, cxmm;\n  h = vuHt;\n  if (! doClimb) {\n    tt = mod (t, 4.);\n    if (tt < 1.) r = mix (vec2 (sqrt3 * 0.5, -0.5), vec2 (sqrt3 * 0.5, 0.5), tt);\n    else if (tt < 2.) r = mix (vec2 (sqrt3 * 0.5, 0.5), vec2 (0., 1.), tt - 1.);\n    else if (tt < 3.) r = mix (vec2 (0., 1.), vec2 (0., 2.), tt - 2.);\n    else r = mix (vec2 (0., 2.), vec2 (sqrt3 * 0.5, 2.5), tt - 3.);\n    r.y += 3. * floor (t / 4.);\n    r *= gSize.x;\n    r.x += 0.01;\n  } else {\n    r = vec2 (0.01, gSize.x * t - 3. * gSize.x);\n    r = Rot2D (r, - pi / 3.);\n    cId.xz = PixToHex (r / gSize.x);\n    cxm = mod (floor (cId.x / 3.), 2.);\n    cxmm = mod (cId.x, 6.);\n    if (cId.x == cId.z) {\n      dr = r - HexToPix (cId.xz * gSize.x);\n      dh = gSize.y * 0.5 * (1. + clamp ((length (dr) * sign (Rot2D (dr, pi / 3.).y) + 5.) / 10.,\n         -1., 1.));\n      h += (cxm == 0.) ? dh : gSize.y - dh;\n      cxmm = abs (cxmm - 2.5);\n      h += gSize.y * (step (cxmm, 2.) + step (cxmm, 1.));\n    } else {\n      cxmm = abs (cxmm - 3.);\n      h += gSize.y * (step (cxmm, 2.5) + step (cxmm, 1.5) + step (cxmm, 0.5));\n    }\n  }\n  return vec3 (r, h).xzy;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, ltVec, ltDir, roo, vn;\n  vec2 vf;\n  float dstObj, ltDist, ltCeil, ao, atten, r, s, a, y, shLab[2];\n  bgCol = vec3 (0.05);\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == idFlr || idObj == idShlf || idObj == idBk) {\n      qHit.xz = Rot2D (qHit.xz, pi / 6.);\n      r = length (qHit.xz);\n      a = (r > 0.) ? atan (qHit.z, - qHit.x) / (2. * pi) + 0.5 : 0.;\n    }\n    ltCeil = 0.;\n    if (idObj == idFlr) {\n      vf = vec2 (32., 0.2);\n      if (vn.y > 0.01) {\n        col4 = vec4 (0.6, 0.4, 0.2, 0.1) * (1. - 0.3 * Fbm2 (ro.xz));\n        if (stLib >= 4) col4.rgb *= 0.7 + 0.3 * SmoothBump (0.02, 0.98, 0.01, fract (1.1 * r));\n      } else if (vn.y < -0.01) {\n        col4 = vec4 (vec3 (1.), 0.);\n        if (stLib >= 3) ltCeil = (1. - smoothstep (1., 4., length (Rot2D (qHit.xz,\n           2. * pi * floor (6. * a + 0.5) / 6.) - vec2 (17., 0.)))) +\n           (1. - smoothstep (0., 4., r - 11.));\n        else col4 = vec4 (vec3 (0.4), 0.1);\n      } else col4 = vec4 (0.6, 0.4, 0.2, 0.1);\n    } else if (idObj == idCol) {\n      col4 = vec4 (0.7, 0.7, 0.6, 0.05);\n      if (abs (vn.y) < 0.1) col4 *= 0.85 + 0.15 * smoothstep (0.08, 0.1, fract (2. * qHit.y));\n      vf = vec2 (32., 1.);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.7, 0.7, 0.75, 0.2);\n      vf = vec2 (32., 0.2);\n    } else if (idObj == idStr) {\n      if (abs (qHit.z) > 2.) {\n        col4 = vec4 (0.5, 0.55, 0.5, 0.);\n        vf = vec2 (32., 0.2);\n      } else if (vn.y > -0.01) {\n        col4 = vec4 (0.5, 0.3, 0.1, 0.05) * (1. - 0.2 * Fbm2 (2. * ro.xz));\n        vf = vec2 (32., 0.2);\n      } else {\n        col4 = vec4 (0.45, 0.45, 0.5, 0.);\n        vf = vec2 (32., 0.2);\n        ltCeil = 1. - smoothstep (0., 0.8, PrRoundBox2Df (vec2 (qHit.x, abs (qHit.z) - 1.2),\n           vec2 (12. / sqrt(2.), 0.05), 0.05));\n      }\n    } else if (idObj == idShlf) {\n      col4 = vec4 (vec3 (0.7, 0.5, 0.2) * (0.5 + 0.5 * Fbm2 ((r > 17.99) ?\n         vec2 (256. * a, 0.5 * qHit.y) :\n         ((abs (vn.y) < 0.01) ? vec2 (4. * r, 0.5 * qHit.y) : vec2 (32. * a, 4. * r)))), 0.1);\n      vf = vec2 (32., 0.1);\n      a = fract (12. * a + 0.5) - 0.5;\n      if (stLib >= 7 && r > 17.99 && abs (a) < 0.2) {\n        shLab[0] = dot (mod (vec2 (55., 45.) + cId.xz, 100.), vec2 (100., 1.));\n        shLab[1] = mod (54. + cId.y, 100.);\n        if (abs (qHit.y - 2.2) < 0.4) {\n          if (ShowInt (vec2 (- 10. * a - 0.5, (qHit.y - 2.)), vec2 (2., 0.5), 4., shLab[0]) != 0.) \n             col4 = vec4 (0., 0.6, 0.8, -1.);\n        } else if (abs (qHit.y - 1.4) < 0.4) {\n          if (ShowInt (vec2 (- 10. * a - 0.2, (qHit.y - 1.2)), vec2 (1.5, 0.5), 2., shLab[1]) != 0.)\n             col4 = vec4 (0., 0.8, 0.6, -1.);\n        }\n      }\n    } else if (idObj == idBk) {\n      a *= 300.;\n      s = Hashfv2 (vec2 (floor (a), 1. + floor (qHit.y / 2.8)));\n      y = fract (qHit.y / 2.8) / (0.9 - 0.3 * s);\n      if (y < 1.) {\n        a = fract (a);\n        col4 = vec4 (HsvToRgb (vec3 (fract (Hashfv3 (cId) + 0.3 * s), 0.7,\n           0.7 * (0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, a)))), 0.1);\n        col4.rgb *= 1. + smoothstep (0.35, 0.45, abs (y - 0.5)) * ((y > 0.5) ? 0.3 : -0.8);\n        col4.rgb = mix (mix (col4.rgb, vec3 (0.7, 0.7, 0.3), SmoothBump (0.2, 0.25, 0.01, y)),\n           vec3 (0.8, 0.8, 0.2), step (abs (y - 0.5), 0.15) *\n           step (abs (a - 0.5), 0.25) * step (0.5, Noisefv2 (cId.xz * vec2 (19., 31.) +\n           floor (vec2 (16. * a, 16. * qHit.y)))));\n        vn.xz = Rot2D (vn.xz, 0.5 * pi * (a - 0.5));\n      } else {\n        col4 = vec4 (0.1, 0.04, 0., -1.);\n      }\n    } else if (idObj == idSeatC) {\n      col4 = vec4 (0.5, 0.3, 0.1, 0.05);\n      vf = vec2 (32., 1.5);\n    } else if (idObj == idSeatM) {\n      col4 = vec4 (0.4, 0.2, 0.1, 0.05);\n      vf = vec2 (32., 1.);\n    } else if (idObj == idLt) {\n      col4 = (stLib >= 3) ? vec4 (1., 1., 0.8, -1.) : vec4 (vec3 (0.8), 0.1);\n    }\n    ltVec = roo + ltPos - ro;\n    ltDist = length (ltVec);\n    ltVec /= ltDist;\n    atten = 1. / (1. + pow (0.005 * ltDist, 1.5));\n    if (stLib <= 3 && ! isPano) atten *= 0.05 + 0.95 * smoothstep (0.7, 0.9, dot (ltAx, - ltVec));\n    ao = 1.;\n    if (stLib >= 2 && idObj != idBk) ao = ObjAO (ro, vn);\n    if (stLib == 1) vf = vec2 (256., 2.);\n    if (col4.a >= 0.) {\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      col = ao * (col4.rgb * (0.1 + 0.4 * max (vn.y, 0.) + 0.5 * max (dot (vn, ltVec), 0.)) +\n         col4.a * pow (max (dot (reflect (ltVec, vn), rd), 0.), 32.));\n      if (idObj == idBk) col += 0.3 * col4.rgb * (0.6 - 0.4 * dot (normalize (vn.xz),\n         normalize (qHit.xz)));\n      if (ltCeil > 0.) col += 0.15 * ltCeil * vec3 (1., 1., 0.8);\n      col *= atten;\n    } else col = atten * col4.rgb * (0.6 + 0.4 * max (- dot (rd, vn), 0.));\n    col = clamp (mix (bgCol, col, exp (32. * min (0., 0.7 - dstObj / dstFar))), 0., 1.);\n  } else col = bgCol;\n  col = clamp (col, 0., 1.);\n  if (stLib <= 2) col = vec3 (0.95, 0.95, 1.) * Maxv3 (col);\n  if (stLib == 1) col *= (tDir < 0.) ? vec3 (1., 0.2, 0.2) : vec3 (0.2, 1., 0.2);\n  if (! colImg) col = vec3 (0.95, 0.95, 1.) * pow (Maxv3 (col), 0.9);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, colT, colF[2], p1, p2, vd;\n  vec2 canvas, uv, uvv, um;\n  float az, el, asp, zmFac, sr, tc, t, mb, spd, regBdy, nState;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  gSize = vec2 (30., 20.);\n  regBdy = (length (uv * vec2 (1. / asp, 1.)) - 1.5 * SmoothBump (0.5, 0.995, 0.005,\n     fract ((1./106.) * tCur))) * canvas.y;\n  doClimb = (regBdy > 0.);\n  if (! doClimb) {\n    spd = 0.35;\n    vuHt = 10.;\n    p1 = TrackPath (spd * tCur + 0.3);\n    p2 = TrackPath (spd * tCur - 0.3);\n    ro = 0.5 * (p1 + p2);\n    vd = p1 - p2;\n    az = atan (vd.x, vd.z);\n    el = -0.02 * pi;\n  } else {\n    spd = 0.35;\n    vuHt = 8.5;\n    ro = TrackPath (spd * tCur);\n    az = pi / 3.;\n    el = -0.02 * pi;\n  }\n  colImg = true;\n  isPano = false;\n  mb = Minv2 (vec2 (mPtr.x, abs (mPtr.y)) + 0.05 * vec2 (1. / asp, 1.) - 0.5);\n  if (mPtr.z > 0. && mb > 0.) {\n    if (mPtr.y > 0.) isPano = ! isPano;\n    else colImg = ! colImg;\n  }\n  if (mPtr.z > 0. && colImg && ! isPano && mb < 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  vuMat = StdVuMat (el, az);\n  zmFac = isPano ? 0.3 : 3.;\n  ltPos = vuMat * vec3 (0.3, 2., -1.);\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  dstFar = 12. * gSize.x;\n  nState = 15.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (isPano ? vec3 (2. * sin (uvv.x / asp + vec2 (0., 0.5 * pi)), uvv.y).xzy : \n       vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n#if DO_FADE\n    tc = 0.6 * tCur;\n    for (int k = VAR_ZERO; k < 2; k ++) {\n      t = mod ((tc + float (k)) / nState, 2.);\n      tDir = (2. * floor (t) - 1.) * (1. - abs (t - 1.));\n      stLib = int (nState) - int (nState * abs (tDir));\n      if (k == 0 || stLib < 9) colF[k] = ShowScene (ro, rd);\n      else colF[1] = colF[0];\n    }\n    colT = mix (colF[0], colF[1], smoothstep (0.2, 0.8, fract (tc)));\n    colT *= 1. - step (5. * abs (mod ((tc + 0.5) / nState, 2.) - 1.),\n       min (1.5, length (uv * vec2 (1. / asp, 1.))));\n#else\n    stLib = int (nState);\n    colT = ShowScene (ro, rd);\n#endif\n    col += (1. / naa) * colT;\n  }\n  if (colImg && ! isPano && doClimb && stLib >= 7) {\n    um = uv - vec2 (0., -0.96) * vec2 (asp, 1.);\n    if (Maxv2 (abs (um) - vec2 (0.1, 0.05)) < 0.) col = mix (mix (col, vec3 (0., 0., 1.), 0.2),\n       vec3 (0.8, 0., 0.), ShowInt (um - vec2 (0.06, -0.02), vec2 (0.1, 0.06) * vec2 (asp, 1.), 3.,\n       mod (54. + floor (ro.y / gSize.y), 100.)));\n  }\n  if (mPtr.z > 0. && min (uv.x - asp, abs (uv.y) - 1.) > -0.1)\n     col = mix (col, vec3 (1., 1., 0.), 0.3);\n  \n  if (regBdy < -1. && abs (regBdy) < 3.) col = vec3 (0.5, 0.5, 0.);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexVertDist (vec2 p)\n{\n  p = abs (p);\n  return min (length (vec2 (p.x - (sqrt3/2.), p.y - 0.5)), length (vec2 (p.x, p.y - 1.)));\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKyDt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[2024, 2024, 2046, 2046, 4971], [4973, 4973, 4991, 4991, 5253], [5255, 5255, 5288, 5288, 6687], [6689, 6689, 6710, 6710, 6965], [6967, 6967, 6999, 6999, 7440], [7442, 7442, 7468, 7468, 8609], [8611, 8611, 8646, 8646, 13881], [13883, 13883, 13936, 13936, 17079], [17081, 17081, 17128, 17128, 17175], [17177, 17177, 17219, 17219, 17270], [17272, 17272, 17329, 17329, 17405], [17407, 17407, 17431, 17431, 17661], [17663, 17663, 17687, 17687, 17747], [17749, 17749, 17777, 17777, 17885], [17887, 17887, 17915, 17915, 17995], [17997, 17997, 18019, 18019, 18046], [18048, 18048, 18070, 18070, 18097], [18099, 18099, 18121, 18121, 18159], [18161, 18161, 18183, 18183, 18221], [18223, 18223, 18268, 18268, 18360], [18362, 18362, 18407, 18407, 18445], [18447, 18447, 18504, 18504, 18587], [18589, 18589, 18625, 18625, 18831], [18833, 18833, 18863, 18863, 18976], [18978, 18978, 19009, 19009, 19073], [19075, 19075, 19099, 19099, 19221], [19255, 19255, 19279, 19279, 19339], [19341, 19341, 19365, 19365, 19430], [19432, 19432, 19456, 19456, 19568], [19570, 19570, 19595, 19595, 19781], [19783, 19783, 19804, 19804, 19959], [19961, 19961, 19990, 19990, 20202], [20204, 20204, 20243, 20243, 20495], [20497, 20497, 20520, 20520, 20579], [20652, 20652, 20684, 20684, 21226], [21228, 21228, 21288, 21288, 21838]], "test": "untested"}
{"id": "ftKcWt", "name": "Kaleidoscope Sharingan", "author": "TomoyaAT", "description": "from NARUTO,\na sudden attempt to study shape function", "tags": ["circle", "rotation"], "likes": 1, "viewed": 277, "published": 3, "date": "1662448451", "time_retrieved": "2024-07-30T16:32:29.143782", "image_code": "\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat circle(float r,vec2 p,vec2 uv){\n    float pct;\n    float dis=distance(uv,p);\n    pct=step(r,dis);\n    return 1.-pct;\n}\nfloat circle_ring(vec2 pos,vec2 uv,float ringsize,float tolsize){\n    float pct=circle(tolsize+ringsize,pos,uv)-circle(tolsize,pos,uv);\n    return pct;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st =fragCoord/iResolution.xy;\n  st.x *= iResolution.x/iResolution.y;\n  vec3 color = vec3(0);\n  float d = 0.0;\n  float c1=circle(0.220,vec2(0.50,0.50),st);\n  float c2=circle(0.020,vec2(0.50,0.50),st);\nvec2 cr_pos=vec2(0.500,0.50);\nfloat cr_ringsize=0.012;\nfloat cr_tolsize=0.132;\n  float cr1=circle_ring(cr_pos,st,cr_ringsize,cr_tolsize);\n    // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n  // Number of sides of your shape\n  int N =3;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.y,st.x)+7.164*sin(iTime);\n  float r = PI*1.976/float(N);\n\n  // Shaping function that modulate the distance\n  d = smoothstep(0.27,0.268,cos(floor(0.384+a/r)*r-a)*length(st)*2.388);\n  vec3 red_color=vec3(1.,0.,0.);\n  \n color=c1*red_color+(1.-c1)*color;\n\n color=d*vec3(0.010,0.009,0.010)+(1.-d)*color;\n color=(1.-cr1)*color+(cr1)*vec3(0);\n color=c2*red_color+(1.-c2)*color;\n  // color = vec3(d);\n\n  fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKcWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 93, 93, 180], [181, 181, 246, 246, 334], [335, 335, 392, 392, 1332]], "test": "untested"}
{"id": "ftKyWt", "name": "Downwardtrend by Ernesto C. R.", "author": "mbaernestocr", "description": "Downwardtrend in the stock market", "tags": ["stocks", "algotrading"], "likes": 4, "viewed": 242, "published": 3, "date": "1662446897", "time_retrieved": "2024-07-30T16:32:30.260794", "image_code": "// Derivative work by Ernesto C. R.\n// Change the direction of the trend by just changing the sign of the trend in the stockFunction\n// Based on Crypto bull run: https://www.shadertoy.com/view/XlsBz2\nfloat curve(in vec2 p, in float fy, in float minLimit, in float maxLimit) {\n    \n    if(p.x < minLimit)\n        return 0.;\n    \n    if(p.x > maxLimit)\n        return 0.;\n    \n    float d = 1. - 150.*abs(p.y - fy);\n    \n    d = clamp(d, 0., 1.);\n    \n    return d;\n}\nfloat gR = 1.61;\n\nfloat nSin(in float t) {\n    \n\treturn 0.5 + 0.5 * sin(t);   \n}\n\nfloat glowingPoint(in vec2 uv, in vec2 pos, in float size) {\n    \n    float dist = distance(uv, pos);\n    \n    float d = (1. - (1./(1.*size)) *dist);\n    \n    \n    \n    d = clamp(d, 0., 1.);\n    \n    d = sqrt(sqrt(d));\n    \n    //d = (d + d*d) / 2.;\n    \n    return d;\n}\n\nfloat speed = 0.15;\nfloat trend = +1.5;\nfloat stockFunction(in float x) {\n    \n    float t = x + iTime  * speed;\n    \n    float f0 = 6.28;\n    float f1 = 3.68;\n    float f2 = 13.28;\n    float f3 = 32.43;\n    float f4 = 123.;\n    float f5 = 331.;   \n    float f6 = 730.;    \n    float f7 = 1232.;\n    \n    \n    float s0 = sin(f0 * t) * 0.4;\n    float s1 = sin(f1 * t) * 0.2;\n    float s2 = sin(f2 * t) * 0.1;\n    float s3 = cos(f3 * t) * 0.15;\n    float s4 = sin(f4 * t) * 0.1;\n    float s5 = sin(f5 * t) * 0.05;\n    float s6 = sin(f6 * t) * 0.035;\n    float s7 = sin(f7 * t) * 0.02;\n    \n    float wave = - s0 - s1 - s2 - s3 - s4 - s5 + s6 - s7;\n    \n    float mod = mod(s1 * s2, 0.1 ) * (5.*sqrt(nSin(f0*t)));\n    \n    float final = wave + -mod;\n    \n    float fy = -trend / 1.5 + (-trend)*x  - 0.5*final;\n    \n    return fy / 5.;\n}\n\n//derivative\nfloat d_stockFunction(in float x, in float delta) {\n    \n    float x0 = x;\n    float x1 = x - delta;\n    \n    float y0 = stockFunction(x0);\n    float y1 = stockFunction(x1);\n    \n    return (y1 - y0) / delta;\n}\n\nfloat longTrend(in float x) {\n    \n    float trend0 = d_stockFunction(x, 0.025);\n    float trend1 = d_stockFunction(x, 0.05);\n    float trend2 = d_stockFunction(x, 0.1);\n    \n    float finalTrend = trend0 + trend1 + trend2;\n    \n    return finalTrend / 3.;\n}\n\nfloat shortTrend(in float x) {\n    \n    float trend0 = d_stockFunction(x, 0.0040);\n    float trend1 = d_stockFunction(x, 0.0050);\n    float trend2 = d_stockFunction(x, 0.0060);\n    \n    float finalTrend = trend0 + trend1 + trend2;\n    \n    return finalTrend / 3.;\n}\n\n\nvec3 trendColor(in float trend) {\n    \n    vec3 red   = vec3(1., 0., 0.);   \n    vec3 green = vec3(0., 1., 0.);\n    \n    trend *= 100.;\n    \n    trend = atan(trend) / (1.57079632679);\n    trend += 1.;   \n    trend /= 2.;\n        \n    return mix(green, red, trend);\n}\n\nfloat grid(in vec2 uv, float tileSize, float borderSize) {\n\n    float xMod = mod(uv.x, tileSize);\n    float yMod = mod(uv.y, tileSize); \n    \n    float treshold = borderSize;\n    \n\tif(xMod < treshold || yMod < treshold)\n        return 1.;\n    \n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;   \n    \n    uv.y = uv.y - .73;\n    \n    vec3 points;\n    \n    float size = 0.025;\n    \n    float start = 0.9;\n    float end = 0.85;\n\n    float delta = end - start;\n    \n    //x20\n    for(float offset = 0.; offset < 1. ; offset += 0.05) {\n    \n        float pos = start + delta * offset; \n        \n        vec3 pColor = glowingPoint(uv, vec2(pos, stockFunction(pos)),  size) * trendColor(longTrend(pos));\n        \n        points = max(points, pColor);       \n        size *= 0.01;\n    }\n    \n    \n    vec3 line = trendColor(shortTrend(uv.x)) * curve(uv, stockFunction(uv.x), 0., start);\n    \n    vec2 gridOffset = vec2(iTime * speed, + iTime * speed * trend/5.);\n    vec3 background = vec3(1.,1.,1.) * grid(uv + gridOffset, 0.2, 0.002);\n    \n    vec3 color = max(line, points) + background * 0.05;\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 200, 275, 275, 465], [484, 484, 508, 508, 546], [548, 548, 608, 608, 818], [860, 860, 893, 893, 1653], [1655, 1668, 1719, 1719, 1878], [1880, 1880, 1909, 1909, 2138], [2140, 2140, 2170, 2170, 2405], [2408, 2408, 2441, 2441, 2674], [2676, 2676, 2734, 2734, 2936], [2938, 2938, 2995, 2995, 3870]], "test": "untested"}
{"id": "slyyDd", "name": "Neutral LUT", "author": "venus", "description": "construct the neutral color from a 2d position", "tags": ["lut", "neutral"], "likes": 0, "viewed": 190, "published": 3, "date": "1662444613", "time_retrieved": "2024-07-30T16:32:30.997823", "image_code": "const float LUTSize = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= vec2(0.49999 / (LUTSize * LUTSize), 0.49999 / LUTSize);\n\n    float scale = LUTSize / (LUTSize - 1.);\n\n    vec3 rgb;\n    rgb.r = fract(uv.x * LUTSize);\n    rgb.b = uv.x - rgb.r/LUTSize;\n    rgb.g = uv.y;\n\n    vec4 neutral = vec4(rgb * scale, 0);\n\n    fragColor = neutral;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyyDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 410]], "test": "untested"}
{"id": "stGcWd", "name": "Curves&rainbow", "author": "TomoyaAT", "description": "just mix the curves and color\nTry to practice what I have learned recently", "tags": ["curves", "colormix"], "likes": 1, "viewed": 179, "published": 3, "date": "1662436176", "time_retrieved": "2024-07-30T16:32:31.748815", "image_code": "float random(vec2 pos) {\n\treturn fract(1.0 * sin(pos.y + fract(100.0 * sin(pos.x))));\n}\n\nfloat noise(vec2 pos) {\n\tvec2 i = floor(pos);\n\tvec2 f = fract(pos);\n\tfloat a = random(i + vec2(0.0, 0.0));\n\tfloat b = random(i + vec2(1.0, 0.0));\n\tfloat c = random(i + vec2(0.0, 1.0));\n\tfloat d = random(i + vec2(1.0, 1.0));\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 pos) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100.0);\n\tmat2 rot = mat2(cos(0.15), sin(0.15), -sin(0.25), cos(0.5));\n\tfor (int i=0; i < 12; i++) {\n\t\tv += a * noise(pos);\n\t\tpos = rot * pos * 2.0 + shift;\n\t\ta *= 0.55;\n\t}\n\treturn v;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat smoothSquare (float x) {\n\tfloat delta = 0.04;\n\tfloat k = 0.5;\n\tfloat w = fract(x);\n\treturn\n\t\tsmoothstep(k - delta, k, w) *\n\t\t(1. - smoothstep(k, k + delta, w));\n}\n\nfloat lattice (vec2 p) {\n\treturn smoothSquare(p.x) + smoothSquare(p.y);\n}\n\nvec2 translateAndScale (vec2 p, float s) {\n\treturn p * s - s / 2.;\n}\n\nmat2 rotate2d(float alpha){\n\treturn mat2(\n\t\tcos(alpha), -sin(alpha),\n\t\tsin(alpha), cos(alpha)\n\t);\n}\n\nvec2 warp (vec2 p) {\n\tfloat t = 0.1;\n\tfloat r = sin((5. + 15.*sin(iTime/5.))*length(p));\n\tfloat alpha = t * r;\n\treturn rotate2d(alpha) * p;\n}\n\nvec3 field(vec2 p) {\n  float z = lattice(warp(p));\n  return vec3(z, 0., 1. - z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tvec2 pos = ( fragCoord.xy / iResolution.xy );\n\n\tvec3 color = vec3( 0.0 ) ;\n\t\n\tpos = warp(pos);\n\t\n\t//text\n\tfloat den = 0.01;\n\tfloat yy = 0.0;\n\t \n\t  for(float i=0. ; i<20. ; i++) {\n\t\t \n\t\t  yy +=2.0;\n\t    if (pos.x > 0.25+den*yy && pos.x < 0.25+den+den*yy || pos.y > 0.25+den*yy && pos.y < 0.25+den+den*yy) \n\t\t    color = 2.*hsv2rgb(vec3(pos.x/pos.y+sin(pos.y),pos.y+0.5,1.-pos.x));\n\t    \n\t  }\n\t \n\t//effect\n\t\n\t\n\t//out\n\tfragColor = vec4( color, 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 87], [89, 89, 112, 112, 425], [427, 427, 448, 448, 684], [686, 686, 708, 708, 877], [879, 879, 909, 909, 1047], [1049, 1049, 1073, 1073, 1122], [1124, 1124, 1166, 1166, 1192], [1194, 1194, 1221, 1221, 1293], [1295, 1295, 1315, 1315, 1436], [1438, 1438, 1458, 1458, 1520], [1522, 1522, 1578, 1578, 2031]], "test": "untested"}
{"id": "slyyWd", "name": "something chaos", "author": "TomoyaAT", "description": "The first chaotic attempt after getting up", "tags": ["random"], "likes": 2, "viewed": 158, "published": 3, "date": "1662435895", "time_retrieved": "2024-07-30T16:32:32.673343", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n\tfloat d = sin(.5*iTime*(length(floor((2.*fragCoord.xy - R)/R.y * 5.))));\n    fragColor = vec4( vec3(d>0.),1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyyWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 200]], "test": "untested"}
{"id": "llGcDm", "name": "Linear To Hilbert", "author": "iq", "description": "Converting form Hilbert to raster order, or from raster to Hilbert, and seeing how that affects different shapes.", "tags": ["2d", "hilbert"], "likes": 142, "viewed": 3531, "published": 3, "date": "1662423684", "time_retrieved": "2024-07-30T16:32:33.923002", "image_code": "// Created by inigo quilez - iq/2022\n\n// I'm drawing some shapes in a pixel buffer as usual where pixels are ordered\n// in \"raster\" or \"linear\", that is, left to right one row at a time, and then\n// repositioning all pixels back into the buffer following a hilbert curve.\n//\n// That is the TRANSFORM set to 0 below. You can set TRANSFORM to 1 to see the\n// opposite - drawing shapes into a buffer that has a hilbert curve in it just\n// to then stretch it into a linear string that we lay again over the plane in\n// regular \"raster\" order.\n\n\n// 0: linear  -> hilbert\n// 1: hilbert -> linear\n#define TRANSFORM 0\n\n\n// adapted from https://en.wikipedia.org/wiki/Hilbert_curve\nint hilbert( ivec2 p, int level )\n{\n    int d = 0;\n    for( int k=0; k<level; k++ )\n    {\n        int n = level-k-1;\n        ivec2 r = (p>>n)&1;\n        d += ((3*r.x)^r.y) << (2*n);\n    \tif (r.y == 0) { if (r.x == 1) { p = (1<<n)-1-p; } p = p.yx; }\n    }\n    return d;\n}\n\n// adapted from  https://en.wikipedia.org/wiki/Hilbert_curve\nivec2 ihilbert( int i, int level )\n{\n    ivec2 p = ivec2(0,0);\n    for( int k=0; k<level; k++ )\n    {\n        ivec2 r = ivec2( i>>1, i^(i>>1) ) & 1;\n        if (r.y==0) { if(r.x==1) { p = (1<<k) - 1 - p; } p = p.yx; }\n        p += r<<k;\n        i >>= 2;\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // work in integer coordinates please\n    ivec2 ip = ivec2(fragCoord);\n    ivec2 ir = ivec2(iResolution);\n\n    // select hilbert resolution\n    int             level =  7;\n    if( ir.x> 512 ) level =  8;\n    if( ir.x>1024 ) level =  9;\n    if( ir.x>2048 ) level = 10;\n\n    // two square's bottom-left corner coordinates\n    int res = (1<<level);\n    ivec2 c1 = ivec2( (ir.x-2*res)/3, (ir.y-1*res)/2 );\n    ivec2 c2 = ivec2( c1.x+res+c1.x, c1.y );\n\n    // distance to two squares\n    ivec2 e1 = abs(ip-c1-res/2)-res/2; int d1 = max(e1.x,e1.y);\n    ivec2 e2 = abs(ip-c2-res/2)-res/2; int d2 = max(e2.x,e2.y); \n        \n    // twitter \"dark\" mode background        \n    vec3 col = vec3(20,30,40)/255.0; \n    vec2 p;\n        \n    // inside left square\n    if( d1<0 )\n    {\n        #if TRANSFORM==1\n        int id = (ip.y-c1.y)*res + (ip.x-c1.x);\n        p = vec2( ihilbert(id,level) ) / float(res);\n        #else    \n        int i = hilbert(ip-c1,level);\n        p = vec2( i%res, i/res ) / float(res);\n        #endif\n    }\n    // inside right square\n    else if( d2<0 )\n    {\n        p = vec2(ip-c2)/float(res);\n    }\n    // otherwise, exterior\n    else\n    {\n        // border color\n        if( min(d1,d2)<8 ) col*=3.5;\n        fragColor = vec4(col,1.0);\n        return;\n    }\n    \n    // animate\n    int id = int(floor(iTime/4.0)) % 4;\n    float t = 0.5 - 0.5*cos(6.283185*iTime/4.0);\n\n    // render\n    float f = 0.0;\n    \n    // horizontal line\n    if( id==0 ) { f = abs(p.y-t); f = 1.0-smoothstep( 0.00, 0.02, f ); }\n    // vertical line\n    if( id==1 ) { f = abs(p.x-t); f = 1.0-smoothstep( 0.00, 0.10, f ); }\n    // circle\n    if( id==2 ) { f = abs(length(p-0.5)-0.5*t); f = 1.0-smoothstep( 0.00, 0.08, f ); }\n    // circular waves\n    if( id==3 ) \n    {\n        t = -6.283185*2.0*fract(iTime/4.0);\n        float l = length(p-0.5);\n        f  = 1.0*sin(  20.0*l+0.0 + t*1.0);\n        f += 0.5*sin(  56.0*l+1.0 + t*1.3);\n        f += 0.3*sin(  82.0*l+2.0 + t*2.1);\n        f += 0.2*sin( 132.0*l+3.0 + t*2.7);\n        f -= 0.2;\n        f = smoothstep(0.0,1.0,f);\n    }\n\n    // put color\n    col = mix( col, vec3(1.0), f );\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGcDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[612, 672, 707, 707, 942], [944, 1005, 1041, 1041, 1280], [1282, 1282, 1339, 1381, 3508]], "test": "untested"}
{"id": "7tyyWt", "name": "Simple kernelConvoution", "author": "LeifMessinger", "description": "I only coded it to do X and Y sobel for now, but it should be able to handle any kernel.", "tags": ["postprocessing"], "likes": 3, "viewed": 205, "published": 3, "date": "1662422870", "time_retrieved": "2024-07-30T16:32:34.704912", "image_code": "float grayscale(vec4 color){\n    return (0.2126*color[0] + 0.7152*color[1] + 0.0722*color[2]);\n}\n\nmat3 sobelX = mat3(vec3(-1.0, 0.0, 1.0),\n                   vec3(-2.0, 0.0, 2.0),\n                   vec3(-1.0, 0.0, 1.0));\n                   \nmat3 sobelY = mat3(vec3(-1.0, -2.0, -1.0),\n                   vec3(0.0, 0.0, 0.0),\n                   vec3(1.0, 2.0, 1.0));\n\nvec4 kernelConvolution(vec2 xy, mat3 kernel){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = xy/iResolution.xy;\n    vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n    //Don't worry about out of bounds pixels for now\n    result += texture(iChannel0, (xy+vec2(-1, -1))/iResolution.xy) * kernel[0][0];\n    result += texture(iChannel0, (xy+vec2(0, -1))/iResolution.xy) * kernel[0][1];\n    result += texture(iChannel0, (xy+vec2(1, -1))/iResolution.xy) * kernel[0][2];\n    result += texture(iChannel0, (xy+vec2(-1, 0))/iResolution.xy) * kernel[1][0];\n    result += texture(iChannel0, (xy+vec2(0, 0))/iResolution.xy) * kernel[1][1];\n    result += texture(iChannel0, (xy+vec2(1, 0))/iResolution.xy) * kernel[1][2];\n    result += texture(iChannel0, (xy+vec2(-1, 1))/iResolution.xy) * kernel[2][0];\n    result += texture(iChannel0, (xy+vec2(0, 1))/iResolution.xy) * kernel[2][1];\n    result += texture(iChannel0, (xy+vec2(1, 1))/iResolution.xy) * kernel[2][2];\n    return abs(result);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    fragColor = vec4(grayscale(kernelConvolution(fragCoord,sobelX)), grayscale(kernelConvolution(fragCoord,sobelY)), grayscale(texture(iChannel0, uv)), 0.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 96], [367, 367, 412, 462, 1353], [1355, 1355, 1412, 1412, 1619]], "test": "untested"}
{"id": "stGyWt", "name": "My third RayMarcher", "author": "SONENEIS", "description": "...", "tags": ["3d", "raymarching", "ray", "raymarch", "sun", "shadow", "light", "sphere", "marching", "march", "buffer"], "likes": 5, "viewed": 204, "published": 3, "date": "1662418535", "time_retrieved": "2024-07-30T16:32:35.622458", "image_code": "#define pi 3.1415926\n#define tau pi * 2.0\n\n#define AA 4\n\n/*settings*/\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.00001\n#define STEPS 5000\n/*end*/\n\n#define pow(a,b) pow(abs(a),b)\n\n//random\nfloat hash(float v){return fract(sin(v*dot(vec2(737.873,777.873),vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec2 uv){return fract(sin(dot(uv,vec2(173.873,515.526)))*82723.782);}\nfloat hash(vec3 uv){return fract(sin(dot(uv,vec3(173.873,515.526,726.873)))*82723.782);}\n\n//noise 1d\nfloat noise(float a){\n\tfloat f = fract(a);\n\tfloat h = f*f*(3.0-2.0*f);\n\treturn mix(hash(a),hash(a + 1.0),h);\n}\n\n//noise 2d\nfloat noise(vec2 uv){\n\tvec2 e = vec2(0.0,1.0);\n\tvec2 p = floor(uv);\n\tvec2 f = smoothstep(0.0,1.0,fract(uv));\n\treturn mix(\n\t\tmix(hash(p + e.xx),hash(p + e.yx),f.x),\n\t\tmix(hash(p + e.xy),hash(p + e.yy),f.x),\n\t\tf.y\n\t);\n}\n\n//noise 3d\nfloat noise(vec3 uv3d){\n\tvec2 e = vec2(0.0,1.0);\n\tvec3 s = vec3(110.0,241.0,171.0);\n\tvec3 i = floor(uv3d);\n\tvec3 f = fract(uv3d);\n\tfloat n = dot(i,s);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\tfloat x1 = mix(hash(n + dot(s,e.xxx)),hash(n + dot(s,e.yxx)),u.x);\n\tfloat x2 = mix(hash(n + dot(s,e.xyx)),hash(n + dot(s,e.yyx)),u.x);\n  float y1 = mix(hash(n + dot(s,e.xxy)),hash(n + dot(s,e.yxy)),u.x);\n  float y2 = mix(hash(n + dot(s,e.xyy)),hash(n + dot(s,e.yyy)),u.x);\n\treturn mix(mix(x1,x2,u.y),mix(y1,y2,u.y),u.z);\n}\n\n//clamp zero one\n#define czo(a) clamp(a,0.0,1.0)\n\n//integer mix\n#define imix(a,b,k) mix(float(a),float(b),k)\n\n//vector min\nfloat vmin(vec2 a){return min(a.x,a.y);}\nfloat vmin(vec3 a){return min(min(a.x,a.y),a.z);}\nfloat vmin(vec4 a){return min(min(a.x,a.y),min(a.z,a.w));}\n\n//vector max\nfloat vmax(vec2 a){return max(a.x,a.y);}\nfloat vmax(vec3 a){return max(max(a.x,a.y),a.z);}\nfloat vmax(vec4 a){return max(max(a.x,a.y),max(a.z,a.w));}\n\n//square\nfloat sq(float a){return pow(a,2.0);}\nvec2 sq(vec2 a){return pow(a,vec2(2.0));}\nvec3 sq(vec3 a){return pow(a,vec3(2.0));}\nvec4 sq(vec4 a){return pow(a,vec4(2.0));}\n\n//length square\n#define lsq(a) dot(a,a)\n\n//smooth min\nfloat smin(float a,float b,float k){\n\tfloat h = czo(0.5 + 0.5*(b-a)/k);\n\treturn mix(b,a,h) - k*h*(1.0-h);\n}\n\n//smooth max\nfloat smax(float a,float b,float k){\n\treturn -smin(-a,-b,k);\n}\n\nstruct Phong{\n\tfloat amb_iten;\n\tfloat diff_iten;\n\tfloat spe_iten;\n\tfloat spe_alpha;\n\tfloat back_iten;\n\tfloat diff_absl; //absorbs light\n};\n\nstruct Obj{\n\tfloat f;\n\tvec3 col;\n\tvec3 pos;\n\tint id;\n\tPhong phong;\n};\n\n//primitive 3d sdfs\nObj fSphere(int id,vec3 p,float rad,vec3 col,Phong phong){\n\tfloat sph = length(p) - rad;\n\treturn Obj(sph,col,p,id,phong);\n}\nObj fEllipsoid(int id,vec3 p,vec3 rad,vec3 col,Phong phong){\n  float p1 = length(p/rad);\n  float p2 = length(p/sq(rad));\n  float elli = p1*(p1-1.0)/p2;\n\treturn Obj(elli,col,p,id,phong);\n}\nObj fCube(int id,vec3 p,float size,vec3 col,Phong phong){\n\tp = abs(p) - size;\n\tfloat cube = length(max(p,0.0)) + min(vmax(p),0.0);\n\treturn Obj(cube,col,p,id,phong);\n}\nObj fBox(int id,vec3 p,vec3 size,vec3 col,Phong phong){\n\tp = abs(p) - size;\n\tfloat box = length(max(p,0.0)) + min(vmax(p),0.0);\n\treturn Obj(box,col,p,id,phong);\n}\nObj fBoxInf1(int id,vec3 p,vec2 size,vec3 col,Phong phong){\n\tvec2 p2 = abs(p.xy) - size;\n\tfloat box = length(max(p2,0.0)) + min(vmax(p2),0.0);\n\treturn Obj(box,col,p,id,phong);\n}\nObj fPlane(int id,vec3 p,vec3 n,float d,vec3 col,Phong phong){\n\tfloat plane = dot(p,n) - (-d);\n\treturn Obj(plane,col,p,id,phong);\n}\n\n//transform matrices\nmat3 mRotateX(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(1,0,0),\n\t\tvec3(0,c,-s),\n\t\tvec3(0,s,c)\n\t);\n}\nmat3 mRotateY(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(c,0,s),\n\t\tvec3(0,1,0),\n\t\tvec3(-s,0,c)\n\t);\n}\nmat3 mRotateZ(float theta){\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat3(\n\t\tvec3(c,-s,0),\n\t\tvec3(s,c,0),\n\t\tvec3(0,0,1)\n\t);\n}\nmat3 mRotateXYZ(float x,float y,float z){\n\treturn mRotateX(x) * mRotateY(y) * mRotateZ(z);\n}\n\n//sdf operations\n//union\nObj fOpUn(Obj a,Obj b){\n  if(a.f < b.f) return a; else return b;\n}\nObj fOpUnS(Obj a,Obj b,float k,int id){ //smooth\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/k);\n\tfloat f = smin(a.f,b.f,k);\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpUnC(Obj a,Obj b,float r,int id){ //chamfer\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/r);\n\tfloat f = min(min(a.f,b.f),(a.f - r + b.f) * sqrt(0.5));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\n//intersection\nObj fOpIn(Obj a,Obj b){\n  if(a.f > b.f) return a; else return b;\n}\nObj fOpInS(Obj a,Obj b,float k,int id){ //smooth\n\tfloat h = czo(0.5-0.5*(b.f-a.f)/k);\n\tfloat f = smax(a.f,b.f,k);\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpInC(Obj a,Obj b,float r,int id){ //chamfer\n\tfloat h = czo(0.5-0.5*(b.f-a.f)/r);\n\tfloat f = max(max(a.f,b.f),(a.f + r + b.f) * sqrt(0.5));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\n//difference\nObj fOpDi(Obj a,Obj b){\n\ta.f = -a.f;\n\treturn fOpIn(a,b);\n}\nObj fOpDiS(Obj a,Obj b,float k,int id){ //smooth\n\tfloat h = czo(0.5-0.5*(b.f+a.f)/k);\n\tfloat f = smax(-a.f,b.f,k);\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpDiC(Obj a,Obj b,float r,int id){ //chamfer\n\tfloat h = czo(0.5-0.5*(b.f+a.f)/r);\n\tfloat f = max(max(-a.f,b.f),(-a.f + r + b.f) * sqrt(0.5));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\n//difference in reverse\nObj fOpRDi(Obj a,Obj b){\n\tb.f = -b.f;\n\treturn fOpIn(a,b);\n}\nObj fOpRDiS(Obj a,Obj b,float k,int id){ //smooth\n\tfloat h = czo(0.5+0.5*(b.f+a.f)/k);\n\tfloat f = smax(a.f,-b.f,k);\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpRDiC(Obj a,Obj b,float r,int id){ //chamfer\n\tfloat h = czo(0.5+0.5*(b.f+a.f)/r);\n\tfloat f = max(max(a.f,-b.f),(a.f + r + -b.f) * sqrt(0.5));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\n//others\nObj fOpPipe(Obj a,Obj b,float r,int id){\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/r);\n\tfloat f = length(vec2(a.f,b.f)) - r;\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpEngrave(Obj a,Obj b,float r,int id){\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/r);\n\tfloat f = max(a.f,(a.f + r - abs(b.f))*sqrt(0.5));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpGroove(Obj a,Obj b,float ra,float rb,int id){\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/ra);\n\tfloat f = max(a.f,min(a.f + ra,rb - abs(b.f)));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\nObj fOpTongue(Obj a,Obj b,float ra,float rb,int id){\n\tfloat h = czo(0.5+0.5*(b.f-a.f)/ra);\n\tfloat f = min(a.f,max(a.f - ra,abs(b.f) - rb));\n  vec3 col = mix(b.col,a.col,h);\n  vec3 pos = mix(b.pos,a.pos,h);\n  Phong phong = Phong(\n  \tmix(b.phong.amb_iten,a.phong.amb_iten,h),\n  \tmix(b.phong.diff_iten,a.phong.diff_iten,h),\n  \tmix(b.phong.spe_iten,a.phong.spe_iten,h),\n  \tmix(b.phong.spe_alpha,a.phong.spe_alpha,h),\n  \tmix(b.phong.back_iten,a.phong.back_iten,h),\n  \tmix(b.phong.diff_absl,a.phong.diff_absl,h)\n  );\n\treturn Obj(f,col,pos,id,phong);\n}\n\n//texture mappings\nvec3 tpmap(sampler2D sam,vec3 p3,vec3 n){ //triplanar\n  n = abs(n);\n  return (\n  \ttexture(sam,p3.xy) * n.z +\n  \ttexture(sam,p3.xz) * n.y +\n  \ttexture(sam,p3.yz) * n.x\n  ).rgb;\n}\nvec2 cmap(vec3 p3,bool sd){ //cube mapping\n  vec3 n = abs(p3);\n  vec3 v =\n  \t(n.x>n.y && n.x>n.z) ? p3.xyz :\n    (n.y>n.x && n.y>n.z) ? p3.yzx : p3.zxy;\n  vec2 p2 = v.yz/v.x;\n  if(sd) p2 *= 1.25 - 0.25*p2*p2;\n  return 0.5+0.5*p2;\n}\nvec2 cmap(vec3 p3){return cmap(p3,false);}\nvec2 smap(vec3 p3){ //sphere mapping\n  p3 = normalize(p3);\n  vec2 p2;\n  p2.x = 0.5 + atan(p3.z,p3.x) / tau;\n  p2.y = 0.5 - asin(p3.y) / pi;\n  return p2;\n}\nfloat bumpmap(sampler2D sam,vec3 pos,vec3 n,float dist,float factor,float scale){\n\tfloat bump = 0.0;\n\tif(dist < 0.1){\n\t  vec3 normal = normalize(n);\n\t  bump += factor * tpmap(sam,pos*scale,normal).r;\n\t}\n\treturn bump;\n}\n\nObj scene(vec3 pos){\n\tObj d;\n  \n  Obj ball = fSphere(\n  \t1,pos,0.625,\n  \tvec3(1.0,0.0,0.0),\n  \tPhong(1.0,1.0,1.0,10.0,0.1,0.0)\n  );\n  //ball.f -= bumpmap(iChannel0,pos,pos+0.25,ball.f,0.25,0.625);\n\n  Obj elli = fEllipsoid(\n  \t0,pos,vec3(0.5,0.25,0.1),\n  \tvec3(0.0,1.0,0.0),\n  \tPhong(1.0,1.0,0.5,10.0,0.1,0.0)\n  );\n\n  Obj cube = fCube(\n  \t0,pos,0.5,\n  \tvec3(0.0,0.0,1.0),\n  \tPhong(1.0,1.0,0.1,10.0,0.1,0.0)\n  );\n  cube.f -= 0.01;\n\n  Obj box = fBox(\n  \t0,pos,vec3(0.5,0.25,0.1),\n  \tvec3(1.0,1.0,0.0),\n  \tPhong(1.0,1.0,0.5,10.0,0.1,0.0)\n  );\n  box.f -= 0.075;\n\n  Obj wall = fBoxInf1(\n  \t0,pos.xyz,vec2(0.25,0.5),\n  \tvec3(1.0,1.0,1.0),\n  \tPhong(1.0,1.0,0.5,10.0,0.1,0.0)\n  );\n  wall.f -= 0.05;\n\n  Obj ground = fPlane(\n  \t2,pos,vec3(0,1,0),0.5,\n    vec3(0.5+0.5*mod(floor(pos.x*5.0)+floor(pos.z*5.0),2.0)),\n  \tPhong(1.0,1.0,0.0,1.0,0.1,0.0)\n  );\n\n  //d = fOpUn(fOpDi(ball,cube),ground);\n  //d = fOpDi(ball,cube);\n  d = fOpUn(ball,ground);\n  //d = fOpUn(cube,ground);\n  //d = elli;\n  //d = ball;\n  //d = ground;\n\n  ////////////////////////////////////////////////////////////////////\n\n  //normal\n  //d = fOpUn(ball,ground);\n  //d = fOpIn(ball,ground);\n  //d = fOpDi(ball,ground);\n  //d = fOpRDi(ball,ground);\n\n  //smooth\n  //d = fOpUnS(ball,ground,0.25,0);\n  //d = fOpInS(ball,ground,0.1,0);\n  //d = fOpDiS(ball,ground,0.5,0);\n  //d = fOpRDiS(ball,ground,0.1,0);\n\n  //chamfer\n  //d = fOpUnC(ball,ground,0.25,0);\n  //d = fOpInC(ball,ground,0.12,0);\n  //d = fOpDiC(ball,ground,0.5,0);\n  //d = fOpRDiC(ball,ground,0.1,0);\n\n  //d = fOpPipe(ball,ground,0.1,0);\n  //d = fOpEngrave(ball,ground,0.1,0);\n  //d = fOpGroove(ball,ground,0.1,0.1,0);\n  //d = fOpTongue(ball,ground,0.1,0.1,0);\n\n\treturn d;\n}\n\nObj raymarch(vec3 ro,vec3 rd){\n\tfloat dist = 0.0;\n\tObj hit;\n\t\n\tfor(int i=0;i<STEPS;i++){\n\t\tvec3 uv3d = ro + dist*rd;\n\t\t\n    Obj redl = fSphere(\n    \t3,uv3d - vec3(2.5,0.1,1.0),0.25,\n    \tvec3(1.0,0.0,0.0),\n    \tPhong(1.0,1.0,1.0,10.0,0.1,0.0)\n    );\n  \tObj lights;\n  \tlights = redl;\n\t\thit = fOpUn(scene(uv3d),lights);\n    \n    dist += hit.f;\n\t\tif(abs(hit.f) < EPSILON || dist > MAX_DIST) break;\n\t}\n\n  hit.f = dist;\n\n\treturn hit;\n}\n\nfloat softShadow(vec3 ro,vec3 rd){\n\tfloat start = MIN_DIST, end = MAX_DIST;\n\tfloat k = 16.0;\n\tfloat shadow = 1.0;\n\n\tfor(float d=start;d<end;){\n\t\tfloat hit = scene(ro + d*rd).f;\n\n\t\tif(hit < 0.001) return 0.0;\n\t\tshadow = min(shadow,k*hit/d);\n\n        //d += hit / k; //low\n\t\td += hit; //fast\n\t}\n\n\treturn shadow;\n}\n\nfloat getAmbOcc(vec3 ro,vec3 rd){\n  float occ = 0.0;\n  float w = 1.0;\n\n  for(float i=0.0;i<8.0;i++){\n  \tfloat len = 0.1+0.01*sq(i);\n  \tfloat dist = scene(ro + len*rd).f;\n  \tocc += (len - dist) * w;\n  \tw *= 0.775;\n  }\n\n  return 1.0 - czo(0.75 * occ);\n}\n\nvec3 getNormal(vec3 uv3d){\n\tvec2 e = vec2(1.0,-1.0) * EPSILON;\n\treturn normalize(vec3(\n\t\te.yyx * scene(uv3d + e.yyx).f +\n\t\te.xyy * scene(uv3d + e.xyy).f +\n\t\te.yxy * scene(uv3d + e.yxy).f +\n\t\te.xxx * scene(uv3d + e.xxx).f\n\t));\n}\n\nstruct Light{\n\tvec3 pos;\n\tvec3 dir;\n\tvec3 col;\n\tvec3 shader;\n};\nLight light(vec3 uv3d,vec3 rd,vec3 normal,Obj obj,vec3 amb,float iten,vec3 pos,vec3 col){\n\tvec3 dir = normalize(pos - uv3d);\n  \n  switch(obj.id){\n  \tcase 1:\n\t    float softness = 100.0; //the lower this value, the smoother the texture.\n\t    vec3 n = pow(abs(normal),vec3(softness));\n\t    n /= n.x + n.y + n.z;\n\n\t    obj.col = tpmap(iChannel0,uv3d,normal).rgb;\n  \t  break;\n\t  case 2:\n\t    obj.col = tpmap(iChannel1,uv3d,normal).rgb;\n\t    break;\n  }\n  \n\t//shader\n\tvec3 shader = vec3(0.0);\n\t\n\tif(obj.id == 3){\n\t  shader += obj.col;\n\t}else{\n    vec3 L = dir;\n    vec3 N = normal;\n    vec3 R = reflect(-L,N);\n    vec3 V = -rd;\n  \n    //ambient\n    vec3 amb_col = amb*0.05 + obj.col*0.05;\n    float amb_iten = obj.phong.amb_iten;\n    vec3 ambient = amb_col * amb_iten;\n\n\t  //diffuse\n  \tvec3 diff_col = obj.col * (col * iten*(1.0-obj.phong.diff_absl));\n  \tfloat diff_iten = obj.phong.diff_iten;\n  \tfloat diff_val = czo(dot(N,L));\n  \tvec3 diffuse = diff_col * diff_val * diff_iten;\n\n    //specular\n    vec3 spe_col = col;\n    float spe_iten = obj.phong.spe_iten;\n    float spe_alpha = obj.phong.spe_alpha;\n    float spe_val = czo(dot(R,V));\n    vec3 specular = spe_col * pow(max(0.0,spe_val),spe_alpha) * spe_iten;\n\n    //back\n    vec3 b_col = 0.5 * obj.col;\n    float b_iten = obj.phong.back_iten;\n    float b_val = czo(dot(N,-L));\n    vec3 back = b_col * b_val * b_iten;\n\n    //fresnel\n    vec3 him_col = obj.col*0.1;\n    float him_val = czo(pow(max(0.0,1.0 + dot(rd,N)),2.0));\n    vec3 him = him_col * him_val;\n\n    //shadow\n    float shadow = 1.0;\n    shadow = softShadow(uv3d+N*0.02,normalize(pos));\n    \n  \t//ambient occlusion\n    float occ = getAmbOcc(uv3d,N);\n    \n\tshader += occ*(ambient+him + ((diffuse*shadow)+back)) + specular;\n    //shader += ambient + diffuse + specular;\n  }\n\treturn Light(pos,dir,col,shader);\n}\n\nmat3 lookAt(vec3 ro,vec3 la){\n\tvec3 cz = normalize(ro - la);\n\tvec3 cx = normalize(cross(vec3(0,1,0),cz));\n\tvec3 cy = normalize(cross(cz,cx));\n\n\treturn mat3(cx,cy,cz);\n}\n\nvec3 render(vec3 col,vec2 uv){\n  vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\n  vec3 bg = vec3(0.1,0.3,1.0);\n  vec3 fog = vec3(0.7,0.825,1.0);\n\n  //camera\n  float fov = 1.5;\n  vec3 la = vec3(0.0,0.0,0.0);\n  vec3 ro = vec3(0.0,0.0,2.5);\n  ro *= mRotateX(mouse.y - 0.5);\n  ro *= mRotateY(-mouse.x * tau * 2.0 + 1.0);\n  vec3 rd = lookAt(ro,la) * normalize(vec3(uv,-fov));\n\n  Obj d = raymarch(ro,rd);\n  {\n    vec3 uv3d = ro + d.f*rd;\n    vec3 normal = getNormal(uv3d);\n\n    bool sun_ = false;\n    Light sun = light(uv3d,rd,normal,d,bg,1.0,\n    \tvec3(10.0,35.0,-50.0),\n    \tvec3(1.0,1.0,0.7)\n    );\n\n    Light r = light(uv3d,rd,normal,d,bg,1.0,\n    \tvec3(2.5,0.1,1.0),\n    \tvec3(1.0,0.0,0.0)\n    );\n    Light g = light(uv3d,rd,normal,d,bg,1.0,\n    \tvec3(-1.0,0.1,1.5),\n    \tvec3(0.0,1.0,0.0)\n    );\n    Light b = light(uv3d,rd,normal,d,bg,1.0,\n    \tvec3(-1.0,0.1,-1.5),\n    \tvec3(0.0,0.0,1.0)\n    );\n   \n   if(uv.x <= 0.0) sun_ = true;\n   \n   if(d.f < MAX_DIST){\n      //shader\n      col += r.shader;\n      //col += g.shader;\n      //col += b.shader;\n      //col += r.shader + g.shader + b.shader;\n\n      if(sun_) col += sun.shader;\n\n      //gamma correction\n      col = pow(col,vec3(1.0/2.2));\n\n      //fog\n      if(!sun_) fog = vec3(-0.0001);\n      col = mix(col,fog,1.0-exp(-0.0001*pow(max(0.0,d.f),3.0)));\n    }else{\n    \t//sky\n  \t  if(sun_) col += mix(bg,fog,1.0-rd.y);\n      //sun\n      if(rd.x > rd.z && sun_){\n        col += sun.col * pow(max(0.0,dot(rd,normalize(sun.pos))),50.0) * 0.2;\n        col += sun.col * pow(max(0.0,dot(rd,normalize(sun.pos))),1000.0);\n      }\n    }\n    if(rd.x > rd.z && sun_)\n      col += sun.col * pow(max(0.0,dot(rd,normalize(sun.pos))),10.0) * 0.25;\n  }\n\n  //buffers ;-;\n  col += uv.y * 0.25;\n  col += vec3(0.075,0.05,0.1);\n  col = pow(col,vec3(1.25));\n\n  return col;\n}\n\nvec2 getUV(vec2 c,vec2 offset){\n  return (2.0 * (c.xy + offset) - iResolution.xy) / iResolution.y;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n  vec3 col = vec3(0.0);\n\n  if(AA == 1){\n    col += render(col,getUV(fragCoord,vec2(0.0)));\n  }else if(AA == 2){\n    float os1 = float(int(fragCoord.x + fragCoord.y) & 1);\n    float os2 = 1.0 - os1;\n    col += (\n    \trender(col,getUV(fragCoord,vec2(0.33 * os1,0.0))) +\n    \trender(col,getUV(fragCoord,vec2(0.33 * os2,0.66)))\n    ) / 2.0;\n  }else if(AA == 3){\n    float os1 = float(int(fragCoord.x + fragCoord.y) & 1);\n    float os2 = 1.0 - os1;\n    col += (\n    \trender(col,getUV(fragCoord,vec2(0.66 * os2,0.0))) +\n    \trender(col,getUV(fragCoord,vec2(0.66 * os1,0.66))) +\n    \trender(col,getUV(fragCoord,vec2(0.33,0.33)))\n    ) / 3.0;\n  }else if(AA == 4){\n    vec4 e = vec4(0.125,-0.125,0.375,-0.375);\n    col += (\n    \trender(col,getUV(fragCoord,e.xz)) +\n    \trender(col,getUV(fragCoord,e.yw)) +\n    \trender(col,getUV(fragCoord,e.wx)) +\n    \trender(col,getUV(fragCoord,e.zy))\n    ) / 4.0;\n  }\n\n  fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 207, 227, 227, 308], [309, 309, 329, 329, 389], [390, 390, 410, 410, 478], [480, 491, 512, 512, 601], [603, 614, 635, 635, 831], [833, 844, 867, 867, 1353], [1465, 1478, 1497, 1497, 1518], [1519, 1519, 1538, 1538, 1568], [1569, 1569, 1588, 1588, 1627], [1629, 1642, 1661, 1661, 1682], [1683, 1683, 1702, 1702, 1732], [1733, 1733, 1752, 1752, 1791], [1793, 1802, 1820, 1820, 1839], [1840, 1840, 1856, 1856, 1881], [1882, 1882, 1898, 1898, 1923], [1924, 1924, 1940, 1940, 1965], [2008, 2021, 2057, 2057, 2128], [2130, 2143, 2179, 2179, 2205], [2418, 2438, 2496, 2496, 2561], [2562, 2562, 2622, 2622, 2749], [2750, 2750, 2807, 2807, 2916], [2917, 2917, 2972, 2972, 3079], [3080, 3080, 3139, 3139, 3257], [3258, 3258, 3320, 3320, 3389], [3391, 3412, 3439, 3439, 3550], [3551, 3551, 3578, 3578, 3689], [3690, 3690, 3717, 3717, 3828], [3829, 3829, 3870, 3870, 3921], [3923, 3948, 3971, 3971, 4014], [4015, 4015, 4054, 4063, 4534], [4535, 4535, 4574, 4584, 5085], [5086, 5101, 5124, 5124, 5167], [5168, 5168, 5207, 5216, 5687], [5688, 5688, 5727, 5737, 6238], [6239, 6252, 6275, 6275, 6310], [6311, 6311, 6350, 6359, 6831], [6832, 6832, 6871, 6881, 7384], [7385, 7409, 7433, 7433, 7468], [7469, 7469, 7509, 7518, 7990], [7991, 7991, 8031, 8041, 8544], [8545, 8554, 8594, 8594, 9075], [9076, 9076, 9119, 9119, 9614], [9615, 9615, 9667, 9667, 10160], [10161, 10161, 10213, 10213, 10706], [10708, 10727, 10768, 10780, 10904], [10905, 10905, 10932, 10947, 11136], [11137, 11137, 11156, 11156, 11179], [11180, 11180, 11199, 11216, 11334], [11335, 11335, 11416, 11416, 11553], [11555, 11555, 11575, 11575, 13241], [13243, 13243, 13273, 13273, 13673], [13675, 13675, 13709, 13709, 13986], [13988, 13988, 14021, 14021, 14239], [14241, 14241, 14267, 14267, 14468], [14534, 14534, 14623, 14623, 16352], [16354, 16354, 16383, 16383, 16522], [16524, 16524, 16554, 16554, 18361], [18363, 18363, 18394, 18394, 18463], [18465, 18465, 18518, 18518, 19444]], "test": "untested"}
{"id": "NlyyDd", "name": "More Onions 2", "author": "SnoopethDuckDuck", "description": "a few issues but looks nice I think", "tags": ["fractal", "apollonion", "onionfans"], "likes": 13, "viewed": 239, "published": 3, "date": "1662418032", "time_retrieved": "2024-07-30T16:32:36.444261", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// RayMarching code stolen from TheArtOfCode\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;    \n    float a = -0.12 * iTime;\n    float zm = 0.65 + 0.5 * thc(4., 0.25 * iTime);\n    float r = 2.5 + zm;\n    vec3 ro = vec3(r * cos(a), zm, r * sin(a));\n    // ro.yz *= rot(-m.y*3.14+1.);\n    // ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist( vec3 p0 ){\n    float sd = mlength(p0.xz) - 1.5;\n    p0.y += 0.25 + 0.1 * iTime;\n    p0 *= 1.5 - 0.75 * thc(4., 0.1 * iTime);\n    vec4 p = vec4(p0, 1.);\n    \n    // Replace i < 4 with 2, 3, etc.\n    for(int i = 0; i < 4; i++){\n        // Looks good with i < 3\n        // p.xyz = erot(p.xyz, normalize(vec3(1)), float(i) * pi);\n        \n        p.xyz = mod(p.yxz-1., 2.)-1.;\n        // p.yzx *= exp(-0.015 * length(p));\n       \n        // Unsettling motion (best with i < 8 or more)\n        // p.y += 0.1 * cos(2. * iTime - pi * p.y);\n        p*=(1.235/dot(p.xyz, p.xyz));\n    }\n    p/=p.w;\n    float d1 = abs(p.y);\n    float d2 = abs(abs(p.x) - abs(p.z));\n    // Intersect + inflate\n    float d = 0.1 * smax(d1, d2, 0.005) - 0.001;\n    return max(sd, d);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// (bad: color not in 0-1 range)\nvec3 Bg(vec3 rd) {    \n    float k = rd.y * 4.2; \n    vec3 b = pal(abs(rd.y) * -0.2, vec3(0,1,2) / 3.);\n    return b * (1.-k);\n    //return mix(b, vec3(1.-b),1.-k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    float zm = 4. - 1. * (0.5 + 0.5 * thc(1., 0.5 * iTime));\n    vec3 rd = GetRayDir(uv, ro, vec3(0), zm);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n    vec3 p = ro + rd * d;\n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    if(d<MAX_DIST) {   \n        // float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        // dif = 4. * dif * (1.-dif);\n        // col = vec3(-0.4 + dif);\n        \n        float spec = pow(abs(r.y), 16.);\n        col += spec;\n        col += 0.6 * Bg(r); // * cos(0.1 * p.y);\n        col = mix(col, Bg(0.5 * p), 0.8);\n        \n        // could do length(p.xz - getRo().xz)\n        float fog = 1. / cosh(1.5 * length(p.xz));\n        col = mix(Bg(rd), col, fog);\n       \n    }\n    else col = Bg(r);\n        \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// Stolen from iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}\n    \n    \n    ", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyyDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 128, 128, 409], [411, 411, 436, 436, 1181], [1183, 1183, 1226, 1226, 1533], [1535, 1535, 1559, 1559, 1749], [1751, 1751, 1801, 1801, 1992], [1994, 2027, 2045, 2045, 2193], [2195, 2195, 2252, 2252, 3193]], "test": "untested"}
{"id": "flGyDd", "name": "Refraction + post proc", "author": "mrange", "description": "CC0: Refraction + post proc\nAdded a bit of post processing to the earlier refraction experiment\n", "tags": ["3d", "raymarch", "refraction", "postproc"], "likes": 190, "viewed": 13385, "published": 3, "date": "1662408326", "time_retrieved": "2024-07-30T16:32:37.282021", "image_code": "// CC0: Refraction + post proc\n// Added a bit of post processing to the earlier refraction experiment\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec3 col = vec3(0.0);\n  col = texture(iChannel0, q).xyz;\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define PHI             (sqrt(5.0)*0.5 + 0.5)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.001\n#define MAX_BOUNCES     6\n\nmat3 g_rot  = mat3(1.0); \nvec3 g_mat  = vec3(0.0);\nvec3 g_beer = vec3(0.0);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.0;\n\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.6, 0.86, 1.0));\nconst vec3 glowCol    = HSV2RGB(vec3(hoff+0.065, 0.8, 6.0));\nconst vec3 diffuseCol = HSV2RGB(vec3(hoff+0.6, 0.85, 1.0));\nconst vec3 lightPos   = vec3(0.0, 10.0, 0.0);\n\nconst float initt       = 0.1; \n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions2d/\nfloat flatTorus(vec3 p, vec2 dim) {\n  float d = length(p.xy)-dim.x;\n  d = abs(d) - dim.y;\n  vec2 w = vec2(d, abs(p.z) - dim.y);\n  return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = clamp(vec3(0.0025/abs(rd.y))*skyCol, 0.0, 1.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += vec3(0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nfloat df(vec3 p) {\n  p *= g_rot;\n  const mat2 rot0 = ROT(0.5);\n  const mat2 rot1 = ROT(1.0);\n  vec3 p0 = p;\n  vec3 p1 = p;\n  vec3 p2 = p;\n\n  p1.zx *= rot0;\n  p2.zy *= rot1;\n  const float w = 0.2;\n  const float rnd = 0.025;\n  float d0 = flatTorus(p0, vec2(2.0, w))-rnd;\n  float d1 = flatTorus(p1, vec2(1.4, w))-rnd;\n  float d2 = flatTorus(p2, vec2(0.8, w))-rnd;\n  float d3 = sphere(p, 0.4);\n  \n  vec3 mat = vec3(0.9, 0.5, 0.8);\n  const vec3 gcol = -2.5*(HSV2RGB(vec3(0.025, 0.925, 1.0)));\n//  const vec3 gcol = 3.5*(1.0-HSV2RGB(vec3(0.025, 0.9, 1.0)));\n  vec3 beer = gcol;\n  \n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  if (d3 < d) {\n    const vec3 gcol = -10.*(HSV2RGB(vec3(0.06, 0.65, 1.0)));\n    beer = gcol;\n    d = d3;\n  }\n\n  g_mat = mat;\n  g_beer = beer;\n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float dfactor, out int ii) {\n  float t = 0.0;\n  float tol = dfactor*TOLERANCE;\n  ii = MAX_RAY_MARCHES;\n  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = dfactor*df(ro + rd*t);\n    if (d < TOLERANCE) {\n      ii = i;\n      break;\n    }\n    t += d;\n  }\n  return t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  vec3 ragg = vec3(1.0);\n\n  bool isInside = df(ro) < 0.0;\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float dfactor = isInside ? -1.0 : 1.0;\n    float mragg = min(min(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.025) break;\n    int iter;\n    float st = rayMarch(ro, rd, dfactor, iter);\n    const float mrm = 1.0/float(MAX_RAY_MARCHES);\n    float ii = float(iter)*mrm;\n    vec3 mat = g_mat;\n    if (st >= MAX_RAY_LENGTH) {\n      agg += ragg*skyColor(ro, rd);\n      break; \n    }\n\n    vec3 sp = ro+rd*st;\n\n    vec3 sn = dfactor*normal(sp);\n    float fre = 1.0+dot(rd, sn);\n//    fre = clamp(abs(fre), 0.0, 1.0);\n    fre *= fre;\n    fre = mix(0.1, 1.0, fre);\n\n    vec3 ld     = normalize(lightPos - sp);\n\n    float dif   = max(dot(ld, sn), 0.0); \n    vec3 ref    = reflect(rd, sn);\n    float re    = mat.z;\n    float ire   = 1.0/re;\n    vec3 refr   = refract(rd, sn, !isInside ? re : ire);\n    vec3 rsky   = skyColor(sp, ref);\n    vec3 col = vec3(0.0);    \n    col += diffuseCol*dif*dif*(1.0-mat.x);\n    float edge = smoothstep(1.0, 0.9, fre);\n    col += rsky*mat.y*fre*vec3(1.0)*edge;\n    if (isInside) {\n      ragg *= exp(-st*g_beer);\n    }\n    agg += ragg*col;\n\n    if (refr == vec3(0.0)) {\n      rd = ref;\n    } else {\n      ragg *= mat.x;\n      isInside = !isInside;\n      rd = refr;\n    }\n\n    // TODO: if beer is active should also computer it based on initt    \n    ro = sp+initt*rd;\n  }\n\n  return agg;\n}\n\nvec3 effect(vec2 p) {\n  g_rot = rot_x(-0.3*TIME)*rot_z(0.5*TIME);\n  vec3 ro = 0.9*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  fragColor = vec4(col, 1.0);\n}\n", "buffer_a_inputs": [], "buffer_b_code": "#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\nconst mat2 brot = ROT(2.399);\n// License: Unknown, author: Dave Hoskins, found: Forgot where\nvec3 dblur(vec2 q,float rad) {\n  vec3 acc=vec3(0);\n  const float m = 0.0025;\n  vec2 pixel=vec2(m*RESOLUTION.y/RESOLUTION.x,m);\n  vec2 angle=vec2(0,rad);\n  rad=1.;\n  const int iter = 30;\n  for (int j=0; j<iter; ++j) {  \n    rad += 1./rad;\n    angle*=brot;\n    vec4 col=texture(iChannel1,q+pixel*(rad-1.)*angle);\n    acc+=clamp(col.xyz, 0.0, 10.0);\n  }\n  return acc*(1.0/float(iter));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0+2.0*q;\n  vec2 p2 = 0.9*p;\n  vec2 q2 = 0.5+0.5*p2;\n  const vec2 off = 0.0125*vec2(0.0, -1.0);\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float pp = smoothstep(0.0, 1.0, sin(0.25*TAU*TIME));\n  float bf = mix(0.66, 0.75, pp)*smoothstep(mix(0.65, 0.85, pp), 0.0, dot(p, p));\n  vec3 bcol = bf > 0.05 ? dblur(q2, mix(0.5, 1.0, pp)) : vec3(0.0);\n\n  vec3 col = vec3(0.0);\n  col = texture(iChannel0, q).xyz;\n  col += bcol*bf;\n  fragColor = vec4(col, 1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGyDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 333, 352, 352, 439], [441, 548, 574, 574, 758], [760, 760, 817, 817, 989]], "test": "untested"}
{"id": "styyDV", "name": "Lost temple", "author": "XT95", "description": "A small pathtracing + voxel test inspired by MagicaVoxel and the works of MadMaraca (https://twitter.com/MadMaraca)", "tags": ["voxel", "pathtracing"], "likes": 58, "viewed": 971, "published": 3, "date": "1662401301", "time_retrieved": "2024-07-30T16:32:38.933605", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    col /= col.a;\n\n\n    // Vignetting & color grading\n    col *= pow( uv.x * uv.y * (1.-uv.x) * (1.-uv.y)*10., .15 );\n    col = pow(col, vec4(1.1,1.1,1.0, 1.));\n    \n    // Output to screen\n    col = pow(col, vec4(1./2.2));\n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SCANLLINE_RENDER 8\n#define SUNDIR normalize(vec3(2.,.5,1.))\n\nfloat material;\n#define NONE -1.\n#define SAND 1.\n#define WALL 2.\n#define GRASS 3.\n\n\n// -----------------------------------------------------\n// Scene\n// -----------------------------------------------------\nfloat ground(vec3 p) { \n    float d = p.y;\n    float s = cos(p.x*.05+cos(p.z*.05)+cos(p.x*0.01+p.z*0.02));\n    d -= smoothstep(-1.,1.,s)*10.;\n    d += noise(p*.1)*5.;\n    return d;\n}\n\nfloat walls(vec3 p) {\n    float d = -box(p, vec3(100.));\n    d = max(d, -box(p-vec3(-100.,-60.,10.), vec3(100.,40.,30.)));\n    return d;\n}\n\n\nfloat grass(vec3 p, float w) {\n    float d = abs(box(p-vec3(0.,0.,0.), vec3(100., 103., 100.)));\n    d = max(d, p.y+0.);\n    //d = max(d,p.y+10.)*3.;\n    d -= (noise(p*vec3(.1,0.03,.1))*2.-1.)*5.;\n    d -= (noise(p*vec3(.5))*2.-1.)*3.;\n    //d = max(d, -w);\n    return d;\n}\n\n\nfloat column(vec3 p) {\n    float d = length(p.xz-vec2(-30.,50.))-5.;\n    d = max(d, p.y+30.-p.z);\n    d = min(d, box(p-vec3(-30.,-100.,50.), vec3(3.,6.,3.))-6.);\n    \n    p.xz = rotate(.5) * p.xz;\n    float dd = length(p.xy-vec2(-30.,-95))-5.;\n    dd = max(dd, p.z);\n    dd = max(dd, -p.z+p.x);\n    d = min(d, dd);\n    return d;\n\n}\n\nfloat map(vec3 p) {\n    float d = ground(p);\n    material = SAND;\n    float w = walls(p);\n    d = max(d, w);\n    if (w>-3.) {\n        if (w>-5.) \n            material = WALL;\n        d -= cos(noise(p*vec3(.1))*8.)*1.;\n        d = min(d, column(p));\n        d += pow((noise(p*.1)),10.)*5.;\n        float g = grass(p,w);\n        if (g < d) {\n            material = GRASS;\n            d = g;\n        }\n    }\n    return d;\n}\n\n\nfloat mapSimplified(vec3 p) {\n    float d = p.y-10.;\n    \n    float w = -box(p, vec3(100.));\n    w -= 5.;\n    d = max(d, w);\n    d = min(d, column(p)-1.);\n    return d;\n}\n\n\n\n\n// -----------------------------------------------------\n// Trace ray to the scene\n// It's a mix of voxel tracing and SDF tracing \n// -----------------------------------------------------\nvec3 trace(vec3 ro, vec3 rd, out vec3 mask){\n\tvec3 dRd = 1./abs(rd);\n\tvec3 sRd = sign(rd);\n\t\n    \n    // Safe start\n    vec3 p = floor(ro) + .5;\n    vec3 side = dRd*(sRd*(p - ro) + .5);\n\tfor (int i=ZERO; i<16; i++) {\n        if (map(p)<0.) return p;\n        mask = step(side, side.yzx)*(1. - step(side.zxy, side));\n\t\tside += mask*dRd;\n\t\tp += mask*sRd;\n\t}\n    \n    // Turbo\n    float d = mapSimplified(p);\n    if (d>0.) {\n        p += rd * d;\n        for(int i=0; i<32; i++) {\n            d = mapSimplified(p);\n            p += rd * d;\n            if (d < 1.) break;\n        }\n        if (p.y>30.) return p;\n    }\n    \n    // Safe landing\n    ro = p;\n    p = floor(ro) + .5;\n    side = dRd*(sRd*(p - ro) + .5);\n\tfor (int i=0; i<320; i++) {\n        if (map(p)<0.) break;\n        mask = step(side, side.yzx)*(1. - step(side.zxy, side));\n\t\tside += mask*dRd;\n\t\tp += mask*sRd;\n\t}\n    \n    return p;    \n}\n\n// -----------------------------------------------------\n// Shadow stuff\n// -----------------------------------------------------\nfloat shadow(vec3 p, vec3 ld) {\n    vec3 mask;\n    vec3 pp = trace(p,ld,mask);\n    return step(0., map(pp));\n}\nfloat shadowDistance(vec3 p, vec3 ld) {\n    vec3 mask;\n    vec3 pp = trace(p,ld,mask);\n    return length(pp-p);\n}\n\n// -----------------------------------------------------\n// Hardcoded blue area light\n// -----------------------------------------------------\nvec3 sampleAreaLight(vec2 u, vec3 p, vec3 n)\n{\n    u = u * 2.0f - 1.0f;\n    \n    vec3 lightPosition = vec3(-190.,-60.,10.);\n    vec3 lightRight = vec3(0.,0.,20.);\n    vec3 lightUp = vec3(0.,30.,0.);\n    vec3 lightForward = vec3(1.,0.,0.);\n    \n    vec3 samplePosition = lightPosition +\n                          lightRight * u.x +\n                          lightUp * u.y;\n    \n    vec3 lightDirection = samplePosition - p;\n    float lightDistance = length(lightDirection);\n    float inverseLightDistance = 1.0f / max(lightDistance, 1e-3f);\n    lightDirection *= inverseLightDistance;\n    \n    vec3 col = vec3(0.1,0.9,1.)*50.;\n    col *= (inverseLightDistance * inverseLightDistance);\n    col *= saturate(dot(-lightDirection, lightForward));\n    col *= step(lightDistance, shadowDistance(p+n,lightDirection));\n    \n    return col;\n}\n\n\n// -----------------------------------------------------\n// Pathtrace\n// -----------------------------------------------------\nvec3 pathtrace(vec3 ro, vec3 rd, vec3 seed) {\n    \n    vec3 abso = vec3(1.);\n    vec3 acc = vec3(0.);\n    \n    for(int i=0; i<2; i++) {\n        vec3 mask;\n        vec3 p = trace(ro,rd, mask);\n        if (map(p)>0.) {\n            break;\n        }\n        vec3 n = -(mask*sign( rd ));\n        float t = length(ro-p);\n        \n        \n        vec3 albedo = vec3(.1);\n        if (material == SAND)\n            albedo = vec3(0.1+(noise(p*.1)*.5+.5)*.1,0.07,0.025);\n        else if (material == WALL)\n            albedo = vec3(.1,.1,.1);\n        else if (material == GRASS) {\n            albedo = vec3(.025,.1,.0);\n            if (noise(p*.25)>.9 && p.y>-90.) albedo = vec3(.05,.01,.01);\n        }\n        \n        rd = cosineDirection(seed,n);\n        vec3 sd = mix(SUNDIR, seed*2.-1., .05);\n        \n        \n        vec3 dcol = vec3(0.);\n        dcol += vec3(.5,.7,1.)*.125 * shadow(p+n,rd);\n        dcol += vec3(1.,.3,.1)*2. * max(dot(n,sd),0.) * shadow(p+n,sd);\n        dcol += sampleAreaLight(vec2(hash(seed+1.),hash(seed)), p, n)*200.;\n        \n        abso *= albedo*5.;\n        acc += dcol * abso;\n        \n        seed = fract(seed + GOLDEN_RATIO);\n        ro = p+n;\n        \n    }\n    return acc;\n}\n\n// -----------------------------------------------------\n// Entrypoint\n// -----------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord.xy * invRes;\n    int f = iFrame % SCANLLINE_RENDER;\n    if(abs(uv.x-float(f)/float(SCANLLINE_RENDER)-.5f/float(SCANLLINE_RENDER)) > 1.f/(float(SCANLLINE_RENDER)*2.)) {\n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n    \n    \n    material = NONE;\n    \n    vec3 seed = hash3(vec3(fragCoord.xy, float(iFrame)));\n    vec2 q = (fragCoord.xy+(seed.xy-.5)*.5) * invRes;\n    vec2 v = q*2.-1.;\n    v.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(91.7, 130., -91.7)*45.5;\n    vec3 rd = normalize(vec3(v,100.));\n    rd.yz = rotate(PI*.25) * rd.yz;\n    rd.xz = rotate(PI*.25) * rd.xz;\n\n    \n    vec3 col = pathtrace(ro,rd, seed);\n    vec4 lastFrame = texture(iChannel0, uv);\n    fragColor = lastFrame+vec4(col,1.0);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// math\n#define ZERO (min(iFrame,0)) // skip unroll loop\n#define time iTime\n#define PI 3.141592653589\n#define saturate(x) clamp(x,0.,1.)\n#define GOLDEN_RATIO 0.61803398875f\nfloat hash( vec3 x );\nfloat hash( float p );\nfloat noise( vec3 x );\nmat2 rotate( float t );\nfloat box( vec3 p, vec3 b );\n\n// tone mapping\nvec3 acesToneMapping( vec3 col );\nvec3 filmicToneMapping( vec3 col );\n\n\n\n\n\n// ---------------------------------------------\n// Math\n// ---------------------------------------------\nfloat hash( float p ) \n{\n    return fract(sin(p)*43758.5453123);\n}\n\nfloat hash( vec3 p )\n{\n    return fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123);\n}\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(p*100000.+1000.);\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec3 cosineDirection( vec3 seed, in vec3 n)\n{\n    vec2 rnd = seed.xy;\n\n    float a = 6.2831853 * rnd.y;\n    rnd.x = 2.0*rnd.x - 1.0;\n    return normalize( n + vec3(sqrt(1.0-rnd.x*rnd.x) * vec2(cos(a), sin(a)), rnd.x) );\n\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n#if 0\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n#else\nfloat noise(vec3 p)\n{\n    vec3 i = floor(p);\n    vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n    vec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n    a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n    a.xy = mix(a.xz, a.yw, f.y);\n    return mix(a.x, a.y, f.z)*.5+.5;\n}\n#endif\n\nmat2 rotate( float t ) {\n    float a = cos(t);\n    float b = sin(t);\n    \n    return mat2( a, b, -b, a );\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styyDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 434]], "test": "untested"}
{"id": "flyyDt", "name": "Glowing clock var. var.", "author": "fishy", "description": "Clock constructed with distance fields. sdOrientedBox and the smoothMax functions are by @iq and the blackbody function is by @FabriceNeyret2 (modified by me). Added a bit of noise B). Added rainbow. Also made it better", "tags": ["time", "sdf", "clock"], "likes": 16, "viewed": 529, "published": 3, "date": "1662401232", "time_retrieved": "2024-07-30T16:32:40.013717", "image_code": "#define PI 3.141592653\n#define date (iDate * 1.0)\n#define smooth 0.005\n\nfloat join( float d1, float d2)\n{\n    float h = max(smooth-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/smooth;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th ) // Made by iq\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdDisk(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdDiskOutline(vec2 p, float r1, float r2)\n{\n    return abs(length(p) - r1) - r2*0.5;\n}\n\nfloat sdRotatedLine(vec2 p, vec2 start, float offset, float len, float theta, float thick)\n{\n    return sdOrientedBox(p, start + vec2(sin(theta), cos(theta)) * offset, vec2(sin(theta), cos(theta)) * (len + offset), thick);\n}\n\nvec4 sd(vec2 p)\n{\n    float seconds = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.15, (floor(date.w)/60.0)*2.0*PI, -0.001);\n    float minutes = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.11, (date.w/60.0/60.0)*2.0*PI, 0.0);\n    float hours = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.1, (date.w/60.0/60.0/12.0)*2.0*PI, 0.0);\n    float centerDisk = sdDisk(p, 0.0);\n    float outerCircle = sdDiskOutline(p, 0.23, 0.0);\n    float ticks = 1000000.0;\n    for(float i = 0.0; i < 2.0*PI; i+= 2.0*PI/12.0)\n    {\n        ticks = join(ticks, sdRotatedLine(p, vec2(0.0, 0.0), 0.18, 0.03, i, 0.0));\n    }\n    \n    for(float i = 0.0; i < 2.0*PI; i+= 2.0*PI/60.0)\n    {\n        ticks = join(ticks, sdRotatedLine(p, vec2(0.0, 0.0), 0.2, 0.01, i, -0.005));\n    }\n    return vec4(join(join(join(join(join(seconds, minutes), hours), centerDisk), outerCircle), ticks), 0.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y *= ratio;\n    \n    float px = 1.0/ratio/max(iResolution.x, iResolution.y);\n    float intensity = mapRange(0.0, 1.0, 1.5, 2.0, erp(noise(vec2(uv.x, uv.x+iDate.w*0.05 + uv.y * 0.3)*10.0), 0.01));\n    vec3 col = blackbody(.005/max(0.0, sd(uv).x + 0.01), intensity).xyz;\n    col += max(vec3(0.0), blackbody(erp(abs(fragCoord.y/iResolution.y - 0.5)*2.0, 0.1) * 0.5, intensity).xyz) * 1.0;\n    col = rgb2Hsl(col);\n    col.x = (uv.x * 0.5 + uv.y * 0.2) + fract(iDate.w*0.1);\n    col = hsl2Rgb(col);\n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(uv.xy, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "float mapRange(float x1, float x2, float y1, float y2, float v)\n{\n    return (v - x1) / (x2 - x1) * (y2 - y1) + y1;\n}\n\nvec4 blackbody(float x, float intensity) //By @FabriceNeyret2 (modified by me) https://www.shadertoy.com/view/4tdGWM\n{\n    vec4 O = vec4(0.0);\n    float m = .01+5.*intensity,\n        T = x*16000.; // absolute temperature (K)\n    \n    O -= O;\n    \n/*  // --- with physical units: (but math conditionning can be an issue)\n    float h = 6.6e-34, k=1.4e-23, c=3e8; // Planck, Boltzmann, light speed  constants\n\n    for (float i=0.; i<3.; i++) {  // +=.1 if you want to better sample the spectrum.\n        float f = 4e14 * (1.+.5*i); \n        O[int(i)] += 1e7/m* 2.*(h*f*f*f)/(c*c) / (exp((h*f)/(k*T)) - 1.);  // Planck law\n    }\n*/\n    // --- with normalized units:  f = 1 (red) to 2 (violet). \n    // const 19E3 also disappears if you normalized temperatures with 1 = 19000 K\n     for (float i=0.; i<3.; i += .05) {  // +=.1 if you want to better sample the spectrum.\n        float f = 1.+.5*i; \n        O[int(i)] += 10./m* (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\n#define ease 1.5\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\nfloat hash2(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n  \n    float tl = hash2(vec2(floor(p.x),  ceil(p.y)));\n    float bl = hash2(vec2(floor(p.x), floor(p.y)));\n    float tr = hash2(vec2( ceil(p.x),  ceil(p.y)));\n    float br = hash2(vec2( ceil(p.x), floor(p.y)));\n    \n    \n    float a = mix(bl, tl, erp(fract(p.y), ease));\n    float b = mix(br, tr, erp(fract(p.y), ease));\n    \n    return mix(a, b, erp(fract(p.x), ease));\n}\n\n\n//Both of these functions are from here: https://stackoverflow.com/questions/68901847/opengl-esconvert-rgb-to-hsv-not-hsl\nvec3 rgb2Hsl(vec3 c) { \n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); \n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); \n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r)); \n    \n    float d = q.x - min(q.w, q.y); \n    float e = 1.0e-10; \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); \n} \n\nvec3 hsl2Rgb(vec3 c) { \n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); \n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); \n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n} ", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyyDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 105, 105, 286], [288, 288, 368, 368, 585], [587, 587, 618, 618, 646], [648, 648, 697, 697, 740], [742, 742, 834, 834, 966], [968, 968, 985, 985, 1826], [1828, 1828, 1885, 1885, 2569]], "test": "untested"}
{"id": "ftycWt", "name": "Fractal mosaic 11 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 6, "viewed": 363, "published": 3, "date": "1662397132", "time_retrieved": "2024-07-30T16:32:41.387046", "image_code": "#define fmod(x,y) mod(floor(x),y)\n\nvec2 f1(vec2 a){\n    return\n        fract(a)\n        //fract(a+floor(a.x-.5)/2.)\n    ;\n}\n\nvec2 triangle_wave1(vec2 a){\n    //a += .5;\n    //a /= (1. + fmod(min(a.x,a.y)/1.5,2.));\n\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        //vec2(2.5,-1.)\n        //vec2(1.5,0.)\n        \n        //vec2(-2.,.5+mod(floor(a.x),2.))\n    ,\n    \n    a1 = a+a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    //a1 += (distance(floor(a1),round(a1)))/1.5;\n\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n        //min(abs(fract((a1)*(a2.x+a2.y))-.75),abs(fract((a1+.5)*(a2.x+a2.y))-.5))\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    return\n        triangle_wave1(a)\n        //triangle_wave1(a-.5)\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = true;\n    vec2 uv1 = vec2(0.);\n    for(int k = 0; k < 6; k++){\n        //uv.x += float(int(uv.x*8.)<<2)/8.;\n        //uv += floor(vec2(uv.x,uv.y+.5)*2./1.5)/2.;\n\n        //a really interesting pattern:\n        //uv += floor(uv/1.5)/1.5;\n        \n        //uv += floor(uv+vec2(1.,.5))/1.5;\n        t3 =\n            uv.x < uv.y\n            //uv.x < uv.y && t2.x > t2.y || !t3\n            //uv.x < uv.y || !t3\n        ;\n        \n        //another awesome pattern (looks better zoomed out)\n        //if(t3){ uv = uv.yx;t2 = -t2.yx;}\n        \n        //uv.y += fmod(uv.y*2.,4.); //lace pattern\n        \n\n        uv =\n            abs(.5+uv+t2)+uv1;\n            //fract(.5+uv+t2)\n            //abs(uv+t2+1.-floor(t2.x-t2.y)*2.)\n            //abs(uv+t2*floor(uv.x-uv.y)*floor(t2.x-t2.y))\n            //abs(.5*sign(uv.y-uv.x)+uv+t2)\n            //abs(.5+uv+t2)*fract(uv/4.) //another interesting pattern\n        ;\n        \n        //uv += (distance(floor(uv),round(uv+.5)));\n\n        //uv *= sign(uv-uv.yx);\n        \n        \n        //if(uv.y>uv.x) uv = uv.yx;\n        t2 =\n            -triangle_wave(uv-.5)\n            //-triangle_wave(uv-.5+floor(uv.x+uv.y))\n            //-triangle_wave(uv-.5)/(.5+fmod(t2.x,2.))\n            //-triangle_wave(uv-1.5+fmod(t2.x/1.5,2.))\n        ;\n        //t2 /= 1. + fmod(t2.x/1.5,1.5)*.5;\n\n        //t2 -= float(!t3)/2.;\n        \n        //uv += floor(uv.y-uv.x);\n        \n        uv =\n            t2-triangle_wave(uv.yx)\n            //abs(.5+t2+triangle_wave(uv.yx))\n            //fract(uv)*fract(uv/2.)*fract(uv/4.)\n        ;\n        //uv /= 1. + fmod(uv.x/1.5,1.5)*.5;\n        //t2 *= length(uv);\n        //uv = fract(uv);\n        float c1 =\n            uv.x-uv.y\n            //abs(uv.x-uv.y)\n            //distance(uv,t2)\n            //uv.x*uv.y\n            //length(uv)\n        ;\n        //uv /= 1.+col;\n        \n        //uv.x += floor(uv.x-uv.y);\n        \n        col = col.yzx;\n        vec3 col1 = col;\n        if(t3 || uv.y < uv.x) col1 = abs(col.yzx-vec3(col.yz,c1));\n        if(!t3 || uv.y > uv.x) col1 = abs(col1-max(col,vec3(col.yz,c1)));\n        col = col1;\n        //col *= col+.5;\n        //if(t3 && uv.y < uv.x) col = vec3(col.yz,c1);\n        //uv1 += 1.5;\n        //if(t2.x>t2.y) col=col.yzx;\n        //if(uv.y<uv.x) col=col.yzx;\n    }\n    fragColor = vec4(min(col*2.,vec3(1.)),1.0);\n}\n", "image_inputs": [], "sound_code": "\n#define smod(x,y) floor(mod(floor(x)*floor(x),y))\n#define sqmod(x,y) floor(mod(floor(x)*floor(x),y*y)/y)\n\n#define fmod(x,y) mod(floor(floor((x))+floor((x)/7.)*7.),y)\n//#define fmod(a,b) mod(floor(a*sign(.5-mod(floor(a/7./5./b),2.))),b)\n//#define fmod(a,b) mod(mod(floor((a)),floor(1.+(a)/7.)),b)\n//#define fmod(a,b) mod(floor(a) + floor((a)/2.)*2.+floor((a)/4.)*4.+floor((a)/8.)*8.+floor((a)/16.)*16.,b)\n//#define fmod(x,y) mod(floor(floor(x)+floor((x)/7./7.)/7.),y)\n//#define fmod(x,y) mod(floor(x),y)\n#define fmod0(x,y) mod(floor(x)+floor((x)/4.)*4.,y)\n#define fmod1(x,y) floor(mod(floor(x)*y,y*y)/y)\n#define fmod2(x,y) mod(floor(x-floor((x)/y)),y)\n#define fmod3(x,y) mod(floor(x)*floor((x)/y),y)\n#define fmod4(x,y) abs(floor(mod(floor((x)),y)-y/2.))*2.\n#define fmod5(x,y) mod(floor((x)*2.-mod(x,y/2.)),y)\n#define fmod6(x,y) floor(sqrt(mod((x)*4.,y*y)))\n#define fmod7(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n\n#define fpow(x,y) pow(y,fmod(x,y))\n#define floor1(x) floor(x)*floor(mod((x)/2.,2.))\n#define powmod(x,y) mod(floor(pow(y,mod(floor(x)/y,y))),y)\n\n\nint gcd (int a, int b) {    // Euclid algorithm:   gcd(a,b) = gcd(b, a%b) ; gcd(a,0) = a\n    int c;             \n    while ( b>0 && (c = a%b) != a ) a=b, b=c; \n    return b==0 ? a : c;\n}\n\nfloat gcd(float a, float b){\n   return float(gcd(int(a),int(b)));\n}\n\nvec2 mainSound(int samp, float time){\n  \n  float tempo = 1.;\n  time /= tempo;\n  \n  //time = (time + floor(time*5.)/5.)/2.;\n  \n  //for(int i = 0; i < 5; i++){ time += fmod(floor(time*5.),2.); }\n  //for(int i = 0; i < 5; i++){ time += gcd(fmod(time+1.,10.),fmod(time+2.,10.)); }\n\n  \n  //time +=\n  //    fpow(time,4.) + fpow(time,3.) + fpow(time,2.)\n  //    floor(time*5.)/5.\n  //;\n  \n  //time = time*(1. + fmod(time*5.,2.))/2.;\n  \n  float s1 =\n      5.,\n      //5./(1.+fmod(time/2.,2.)), //varying tempo\n\n  s2 = 7.,\n  t=\n      time\n      //time + fmod(time,5.+fmod(time*5.,7.))\n      //time+floor(time*s1+floor(time/s1))*s1\n      //time+floor(time*s1)*s1\n      \n      //time/(1.+fmod(floor(time*s1)*floor(time*s1)/s1/s1,2.))/2.\n      //time /(1.+fmod(time/s1+floor(time*s1),2.))\n      //time/(1.+fmod(time/s2,2.))/(1.+fmod(time*s1,2.))\n      //time/(1.+fmod(time/s1,2.))\n  ,\n  m1 =\n      fmod(t/s1+s1,s2)\n      //fmax(t/s1+s1,t/s1,s2)\n      //fmod(floor(t*s1+floor(t/s1))+s1,s2)\n      //fmod(t/s1+floor(t*s1),s2)\n  ,\n  m4 =\n      fmod(t*s1+s1,s2)\n      //fmod(t*s1+fract(t*s1)+s1,s2)\n      //fmod(fract(t/s1)*s1+s1,s2)\n      //fmax(t*s1+s1,t*s1,s2)\n      //fmod(t*s1*(1.+fmod(gcd(t,s2),2.))+s1,s2)\n      //fmod(floor(t)*(floor(t*s1)+floor(t)),s2)\n      //fmod((t*s1)/s1+t+s1,s2)\n      //fmod(t*s1+floor(t/s1),s2)\n  ,\n  m3 =\n      //fmod((t+gcd(m1,m4))*(s1)/(m1+.5),s2);\n      fmod((t+m4)*s1/(m1+.5),s2);\n      //fmod((t+m1)*s1/(m4+.5),s2);\n  \n  //m1 = fmod(t/s1,s2),\n  //m3 = fmod(t*s1/abs(2.5-m1),s2);\n  \n  //t += m3/2.;\n  //t /= (1.+fmod(t/s1,2.)); //varying tempo\n  //t += floor(t*s1)/s1;\n \n  t *=\n      s1*s1\n      //s1*s1/2./(1.+fmod(floor(t*2.+1.)*floor(t/2.+1.),2.))/(1.+fmod(floor(t*2.)*floor(t/2.+1.),2.))\n      //s1*s1/2.*(1.+fmod(floor(t/2.*s1)/s1+t/2.,2.))/(1.+fmod(t/s1,2.))\n      //(1.+fmod(t/s1,2.))\n  ;\n  //t /= max(m1,m3)+1.;\n  \n  float m2 =\n      1. + fmod(t/s1,s1);\n      //1. + fmod(t/s1*sign(m4-m3),s1);\n      //1. + fmod(floor(t/(m3*s1+s1)),s1);\n      //1. + fmod(t/s1+floor(t/s1),s1);\n      //1. + fmod(t/s1,s2);\n      //1. + min(fmod(t/s1,s2),fmod(t/s1/2.,s1));\n      //1. + fmod(time,s1)\n  ;\n  //t /= max(m2,m1+m3+1.);\n  \n  float a=\n      //pow((1.-sqrt(fract(t/s1+m2/2.)/(1.+m1)))/4.,2.)\n      64.*pow((1.-sqrt(fract(t/s1)/(1.+m1)))/4.,2.)\n      //pow(fract(-t/s1)/(1.+m1)*4.,2.)\n\n      //sqrt((1.-sqrt(fract(t/s1)))/5.)*.2\n      //sqrt(fract(-t/s1)/5.))*.2\n\n      //sqrt((1.-sqrt(fract(t/s1))))*.2\n      //(log(1.-fract(-t/s1)/5.))*.2\n  ;\n  \n  //m3 = mod(floor(t/s1*2.),s2-m3+1.);\n  //m2 = mod(floor(t/s1/2.),s1-m2+1.);\n  \n  float nb = pow(2.,(m3+m2)/5.+7.)*tempo;\n\n  //nb *= max(fmod(m1,2.),max(fmod(m4,2.),fmod(m1,2.)));\n  return\n      abs(.5-vec2(fract(time*nb*.998*2.),fract(time*nb)))*a\n      //log(abs(.5-vec2(fract(time*nb*.998/2.),fract(time*nb)))*a)\n      //vec2(fract(time*nb*.998/m2*s1)*a,fract(time*nb/m2*s1)*a)\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftycWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 51, 51, 123], [125, 125, 153, 213, 741], [743, 743, 770, 770, 846], [848, 848, 905, 905, 3529]], "test": "untested"}
{"id": "7lKyDV", "name": "Hiragana Characters", "author": "cmzw", "description": "46 Hiragana characters by combining sdf line and bezier segments. The Katakana set can be found here: [url]https://www.shadertoy.com/view/7lGyDV[/url]\n\nClick and drag to browse through every glyph / ↔ glyph, ↕ radius, hold s key for field lines", "tags": ["2d", "sdf", "bezier", "runes", "cc0", "fonts", "japanese", "hiragana"], "likes": 27, "viewed": 1083, "published": 3, "date": "1662389996", "time_retrieved": "2024-07-30T16:32:42.623739", "image_code": "// Hiragana Glyphs - License: CC0\n\n// Katakana https://www.shadertoy.com/view/7lGyDV\n\n#define SCALE 4.0\n#define GLYPH_SCALE 1.1\n#define RADIUS 0.06\n\n// Uncomment the following to display every glyph\n//#define DISPLAY_ALL\n\nfloat k1(vec2 uv) { // a\n\tfloat d = s(uv, vec2(-0.175, 0.287), vec2(-0.318, 0.318),vec2(-0.306, 0.19));\n\td = min(d, s(uv, vec2(-0.306, 0.189), vec2(-0.266, -0.062),vec2(0.044, -0.082)));\n\td = min(d, s(uv, vec2(0.044, -0.082), vec2(0.264, -0.083),vec2(0.297, 0.071)));\n\td = min(d, s(uv, vec2(-0.175, 0.287), vec2(0.013, 0.225),vec2(0.105, -0.135)));\n\td = min(d, s(uv, vec2(-0.292, -0.237), vec2(0.022, -0.228),vec2(0.243, -0.266)));\n\td = min(d, s(uv, vec2(-0.097, -0.348), vec2(-0.131, 0.113),vec2(-0.035, 0.28)));\n\treturn min(d, s(uv, vec2(0.033, 0.333), vec2(0.333, 0.299),vec2(0.297, 0.071)));\n}\n\nfloat k2(vec2 uv) { // i\n\tfloat d = s(uv, vec2(-0.121, 0.271), vec2(-0.309, 0.317),vec2(-0.292, -0.274));\n\td = min(d, s(uv, vec2(0.319, 0.198), vec2(0.304, -0.062),vec2(0.175, -0.231)));\n\treturn min(d, s(uv, vec2(-0.121, 0.271), vec2(-0.037, 0.246),vec2(-0.028, 0.084)));\n}\n\nfloat k3(vec2 uv) { // u\n\tfloat d = s(uv, vec2(0.217, 0.143), vec2(0.12, 0.291),vec2(-0.129, 0.314));\n\td = min(d, s(uv, vec2(0.198, -0.084), vec2(0.306, -0.01),vec2(0.218, 0.141)));\n\td = min(d, s(uv, vec2(-0.195, -0.327), vec2(-0.037, -0.298),vec2(0.175, -0.283)));\n\treturn min(d, s(uv, vec2(0.197, -0.085), vec2(0.072, -0.162),vec2(-0.274, -0.065)));\n}\n\nfloat k4(vec2 uv) { // e\n\tfloat d = s(uv, vec2(0.093, 0.171), vec2(0.101, 0.386),vec2(0.345, 0.277));\n\td = min(d, s(uv, vec2(0.093, 0.17), vec2(0.081, -0.032),vec2(-0.311, 0.298)));\n\td = min(d, s(uv, vec2(-0.173, -0.337), vec2(-0.037, -0.298),vec2(0.175, -0.283)));\n\td = min(d, s(uv, vec2(0.165, -0.151), vec2(0.065, -0.14),vec2(-0.253, -0.119)));\n\treturn min(d, l(uv, vec2(0.1651, -0.1503), vec2(-0.3101, 0.2973)));\n}\n\nfloat k5(vec2 uv) { // o\n\tfloat d = s(uv, vec2(-0.103, 0.022), vec2(0.111, -0.047),vec2(0.23, 0.027));\n\td = min(d, s(uv, vec2(0.23, 0.027), vec2(0.357, 0.119),vec2(0.263, 0.249)));\n\td = min(d, s(uv, vec2(-0.286, 0.265), vec2(-0.414, 0.155),vec2(-0.104, 0.022)));\n\td = min(d, s(uv, vec2(-0.12, 0.192), vec2(-0.121, 0.383),vec2(-0.286, 0.265)));\n\td = min(d, s(uv, vec2(0.262, 0.25), vec2(0.158, 0.376),vec2(0.033, 0.244)));\n\td = min(d,s(uv, vec2(-0.305, -0.181), vec2(-0.074, -0.182),vec2(0.073, -0.214)));\n\td = min(d, s(uv, vec2(0.337, -0.131), vec2(0.27, -0.219),vec2(0.169, -0.277)));\n\treturn min(d, l(uv, vec2(-0.12, -0.3504), vec2(-0.12, 0.19)));\n}\n\nfloat k6(vec2 uv) { // ka\n\tfloat d = s(uv, vec2(-0.342, -0.13), vec2(-0.206, -0.147),vec2(-0.112, -0.156));\n\td = min(d, s(uv, vec2(0.094, -0.046), vec2(0.082, -0.181),vec2(-0.11, -0.156)));\n\td = min(d, s(uv, vec2(0.06, 0.239), vec2(0.107, 0.114),vec2(0.094, -0.045)));\n\td = min(d, s(uv, vec2(0.06, 0.239), vec2(0.02, 0.345),vec2(-0.145, 0.271)));\n\td = min(d, s(uv, vec2(0.34, 0.083), vec2(0.274, -0.103),vec2(0.176, -0.235)));\n\treturn min(d, s(uv, vec2(-0.104, -0.341), vec2(-0.184, 0.092),vec2(-0.326, 0.304)));\n}\n\nfloat k7(vec2 uv) { // ki\n\tfloat d = s(uv, vec2(-0.048, -0.349), vec2(0.091, -0.023),vec2(0.239, 0.124));\n\td = min(d, s(uv, vec2(-0.149, 0.087), vec2(0.033, 0.036),vec2(0.239, 0.124)));\n\td = min(d, s(uv, vec2(-0.241, 0.176), vec2(-0.237, 0.116),vec2(-0.149, 0.087)));\n\td = min(d, s(uv, vec2(-0.291, -0.051), vec2(-0.031, -0.05),vec2(0.294, -0.127)));\n\td = min(d, s(uv, vec2(-0.29, -0.209), vec2(0.027, -0.217),vec2(0.239, -0.278)));\n\treturn min(d, s(uv, vec2(0.201, 0.288), vec2(-0.252, 0.38),vec2(-0.241, 0.176)));\n}\n\nfloat k8(vec2 uv) { // ku\n\tfloat d = s(uv, vec2(0.147, -0.329), vec2(0.018, -0.207),vec2(-0.186, -0.07));\n\td = min(d, s(uv, vec2(-0.186, -0.07), vec2(-0.254, -0.02),vec2(-0.191, 0.025)));\n\treturn min(d, s(uv, vec2(-0.19, 0.026), vec2(0.028947, 0.168335),vec2(0.183612, 0.325139)));\n}\n\nfloat k9(vec2 uv) { // ke\n\tfloat d = s(uv, vec2(0.183, -0.332), vec2(0.265, 0.268),vec2(-0.009, 0.328));\n\td = min(d, s(uv, vec2(-0.099, -0.136), vec2(0.076, -0.12),vec2(0.332, -0.158)));\n\treturn min(d, s(uv, vec2(-0.229, -0.323), vec2(-0.309, 0.089),vec2(-0.235, 0.298)));\n}\n\nfloat k10(vec2 uv) { // ko\n\tfloat d = s(uv, vec2(-0.225, -0.272), vec2(0.00429, -0.252796),vec2(0.208268, -0.268477));\n\td = min(d, s(uv, vec2(-0.002435, -0.145273), vec2(0.093951, -0.205755),vec2(0.208268, -0.266237)));\n\treturn min(d, s(uv, vec2(0.266548, 0.255698), vec2(-0.452981, 0.36098),vec2(-0.195206, 0.009291)));\n}\n\nfloat k11(vec2 uv) { // sa\n\tfloat d = s(uv, vec2(-0.048, -0.349), vec2(0.091, -0.023),vec2(0.239, 0.124));\n\td = min(d, s(uv, vec2(-0.149, 0.087), vec2(0.033, 0.036),vec2(0.239, 0.124)));\n\td = min(d, s(uv, vec2(-0.241, 0.176), vec2(-0.237, 0.116),vec2(-0.149, 0.087)));\n\td = min(d,s(uv, vec2(-0.300558, -0.165434), vec2(-0.011401, -0.149753),vec2(0.275514, -0.234876)));\n\treturn min(d, s(uv, vec2(0.201, 0.288), vec2(-0.252, 0.38),vec2(-0.241, 0.176)));\n}\n\nfloat k12(vec2 uv) { // shi\n\tfloat d = s(uv, vec2(-0.068, 0.306), vec2(-0.201, 0.289),vec2(-0.2, 0.072));\n\td = min(d, s(uv, vec2(-0.065, 0.306), vec2(0.201, 0.343),vec2(0.306895, 0.038412)));\n\treturn min(d, l(uv, vec2(-0.2, 0.07), vec2(-0.19, -0.33)));\n}\n\nfloat k13(vec2 uv) { // su\n\tfloat d = s(uv, vec2(0.08, -0.056), vec2(0.076019, 0.125774),vec2(-0.051748, 0.136974));\n\td = min(d, s(uv, vec2(-0.053, 0.137), vec2(-0.191, 0.142),vec2(-0.18, 0.004)));\n\td = min(d, s(uv, vec2(-0.18, 0.004), vec2(-0.172, -0.057),vec2(-0.126, -0.082)));\n\td = min(d, s(uv, vec2(0.044, -0.048), vec2(-0.038, -0.126),vec2(-0.124, -0.083)));\n    d = min(d, s(uv, vec2(0.04, -0.052), vec2(0.124, 0.039),vec2(0.088, 0.146)));\n\td = min(d, s(uv, vec2(0.087226, 0.148175), vec2(0.046, 0.276),vec2(-0.149, 0.316)));\n\td = min(d,s(uv, vec2(0.336035, -0.230396), vec2(-0.002435, -0.234876),vec2(-0.340905, -0.214715)));\n\treturn min(d, l(uv, vec2(0.08, -0.0559), vec2(0.08, -0.35)));\n}\n\nfloat k14(vec2 uv) { // se\n\tfloat d = s(uv, vec2(0.353967, -0.147513), vec2(0.015497, -0.136313),vec2(-0.352113, -0.113912));\n\td = min(d, s(uv, vec2(-0.18, 0.163), vec2(-0.179515, 0.3565),vec2(0.282239, 0.264658)));\n\td = min(d, s(uv, vec2(0.146, 0.08), vec2(0.188095, 0.027211),vec2(0.179129, -0.328958)));\n\td = min(d, s(uv, vec2(0.146, 0.08), vec2(0.097, 0.135),vec2(-0.018126, 0.072013)));\n\treturn min(d, l(uv, vec2(-0.18, -0.31), vec2(-0.18, 0.16)));\n}\n\nfloat k15(vec2 uv) { // so\n\tfloat d = s(uv, vec2(0.174646, -0.31), vec2(-0.015884, -0.291),vec2(-0.215, -0.299));\n\td = min(d, s(uv, vec2(0.174646, -0.31), vec2(-0.097, -0.0162),vec2(-0.332, -0.006)));\n\td = min(d, s(uv, vec2(0.33, -0.062), vec2(0.042, -0.057),vec2(-0.332, -0.006)));\n\td = min(d, s(uv, vec2(0.209, 0.309459), vec2(-0.077, 0.313),vec2(-0.068, 0.163)));\n\treturn min(d, s(uv, vec2(-0.068, 0.162), vec2(-0.056231, 0.013771),vec2(0.33, -0.062)));\n}\n\nfloat k16(vec2 uv) { // ta\n\tfloat d = s(uv, vec2(0.067052, -0.223675), vec2(-0.139168, -0.190074),vec2(-0.331939, -0.194555));\n\td = min(d, s(uv, vec2(-0.309524, 0.296019), vec2(-0.192964, 0.058572),vec2(-0.114511, -0.353599)));\n\td = min(d, s(uv, vec2(0.291205, -0.104952), vec2(0.129815, -0.111672),vec2(0.008773, -0.087032)));\n\treturn min(d, s(uv, vec2(-0.015884, 0.103373), vec2(-0.177274, 0.36098),vec2(0.322586, 0.289298)));\n}\n\nfloat k17(vec2 uv) { // chi\n\tfloat d = s(uv, vec2(-0.237155, 0.111585), vec2(-0.124465, -0.108956),vec2(-0.054034, -0.343574));\n\td = min(d, s(uv, vec2(-0.305239, -0.205149), vec2(-0.082206, -0.193419),vec2(0.255865, -0.226265)));\n\td = min(d, s(uv, vec2(0.241779, 0.048238), vec2(0.061, -0.086),vec2(-0.236, 0.111)));\n\td = min(d,s(uv, vec2(0.243, 0.23), vec2(0.139, 0.362),vec2(-0.194, 0.278164)));\n\treturn min(d, s(uv, vec2(0.243, 0.23), vec2(0.323, 0.113),vec2(0.243, 0.049)));\n}\n\nfloat k18(vec2 uv) { // tsu\n\tfloat d = s(uv, vec2(0.3, -0.072), vec2(0.237, -0.307),vec2(-0.324021, -0.165264));\n\td = min(d, s(uv, vec2(0.188, 0.182), vec2(0.324, 0.099),vec2(0.300471, -0.066725)));\n\treturn min(d, s(uv, vec2(-0.145594, 0.251), vec2(0.047, 0.253),vec2(0.186, 0.183)));\n}\n\nfloat k19(vec2 uv) { // te\n\tfloat d = s(uv, vec2(0.326296, -0.275535), vec2(0.190129, -0.280227),vec2(-0.316978, -0.233304));\n\td = min(d, s(uv, vec2(0.324, -0.274), vec2(-0.063424, -0.179),vec2(-0.071, 0.045)));\n\treturn min(d, s(uv, vec2(-0.071, 0.048), vec2(-0.077, 0.259),vec2(0.227692, 0.292241)));\n}\n\nfloat k20(vec2 uv) { // to\n\tfloat d = s(uv, vec2(-0.256, 0.164), vec2(-0.26298, -0.045609),vec2(0.234735, -0.160572));\n\td = min(d, s(uv, vec2(0.255, 0.274), vec2(-0.235, 0.353242),vec2(-0.256, 0.166)));\n\treturn min(d, s(uv, vec2(-0.132, -0.336536), vec2(-0.099, -0.158226),vec2(-0.062, -0.066)));\n}\n\nfloat k21(vec2 uv) { // na\n\tfloat d = s(uv, vec2(-0.333, -0.191072), vec2(-0.183158, -0.193419),vec2(0.011702, -0.212188));\n\td = min(d, s(uv, vec2(-0.325, 0.195), vec2(-0.205, 0.013),vec2(-0.118, -0.355)));\n\td = min(d, s(uv, vec2(0.131436, -0.233304), vec2(0.248822, -0.188726),vec2(0.323949, -0.132418)));\n\td = min(d, s(uv, vec2(-0.028209, 0.315703), vec2(0.161956, 0.357934),vec2(0.161956, 0.20074)));\n\td = min(d,s(uv, vec2(-0.032, 0.315), vec2(-0.162, 0.274),vec2(-0.098, 0.164)));\n\td = min(d, s(uv, vec2(0.333, 0.259395), vec2(0.251, 0.171),vec2(0.128, 0.129)));\n\td = min(d, s(uv, vec2(-0.096292, 0.160855), vec2(-0.041, 0.079),vec2(0.128, 0.129)));\n\treturn min(d, l(uv, vec2(0.161956, 0.198394), vec2(0.143175, -0.083148)));\n}\n\nfloat k22(vec2 uv) { // ni\n\tfloat d = s(uv, vec2(-0.251242, 0.322742), vec2(-0.312282, 0.02243),vec2(-0.23246, -0.327151));\n\td = min(d, s(uv, vec2(0.288733, -0.230957), vec2(0.086829, -0.207496),vec2(-0.063424, -0.219227)));\n\treturn min(d, s(uv, vec2(0.324, 0.24), vec2(-0.25, 0.329),vec2(-0.032, 0.024)));\n}\n\nfloat k23(vec2 uv) { // nu\n\tfloat d = s(uv, vec2(-0.071, 0.214817), vec2(-0.214, -0.052648),vec2(-0.230112, -0.294304));\n\td = min(d, s(uv, vec2(0.070395, -0.33419), vec2(0.025789, 0.010699),vec2(-0.151, 0.224)));\n\td = min(d, s(uv, vec2(-0.284, 0.239), vec2(-0.212, 0.285),vec2(-0.152, 0.225)));\n\td = min(d,s(uv, vec2(-0.04, -0.194), vec2(-0.171, -0.165264),vec2(-0.241, -0.081)));\n\td = min(d, s(uv, vec2(0.284037, -0.073763), vec2(0.187781, -0.233304),vec2(-0.04, -0.194)));\n\td = min(d, s(uv, vec2(0.268, 0.214), vec2(0.354, 0.082),vec2(0.285, -0.072)));\n\td = min(d, s(uv, vec2(0.268, 0.214), vec2(0.163, 0.35),vec2(0.058, 0.261)));\n\td = min(d, s(uv, vec2(0.056, 0.144), vec2(0.004, 0.199),vec2(0.058, 0.261)));\n\td = min(d, s(uv, vec2(0.057, 0.143), vec2(0.173, 0.043),vec2(0.367, 0.271)));\n\treturn min(d, s(uv, vec2(-0.284, 0.239), vec2(-0.415, 0.138),vec2(-0.242, -0.08)));\n}\n\nfloat k24(vec2 uv) { // ne\n\tfloat d = s(uv, vec2(-0.183158, -0.34592), vec2(-0.20194, 0.076392),vec2(-0.194896, 0.334473));\n\td = min(d, s(uv, vec2(0.183, -0.196), vec2(0.011, -0.27),vec2(-0.354, 0.189)));\n\td = min(d, s(uv, vec2(0.028137, 0.287549), vec2(0.24, 0.369),vec2(0.283, 0.132)));\n\td = min(d,s(uv, vec2(-0.006, 0.173), vec2(-0.043, 0.25),vec2(0.027, 0.287)));\n\td = min(d, s(uv, vec2(0.153, 0.123), vec2(0.032, 0.099),vec2(-0.006, 0.173)));\n\td = min(d, s(uv, vec2(0.183, -0.196), vec2(0.32, -0.135),vec2(0.283, 0.132)));\n\td = min(d, s(uv, vec2(0.376, 0.28), vec2(0.301, 0.16),vec2(0.153, 0.123)));\n\td = min(d, l(uv, vec2(-0.157333, -0.193419), vec2(-0.1908, -0.1535)));\n\treturn min(d, l(uv, vec2(-0.157333, -0.193419), vec2(-0.340455, -0.174649)));\n}\n\nfloat k25(vec2 uv) { // no\n\tfloat d = s(uv, vec2(0.008, -0.284), vec2(-0.042536, 0.308529),vec2(-0.225215, 0.238869));\n\td = min(d, s(uv, vec2(-0.31, -0.036), vec2(-0.361, 0.174012),vec2(-0.225215, 0.238869)));\n\td = min(d, s(uv, vec2(0.008, -0.284), vec2(-0.226, -0.28),vec2(-0.31, -0.036)));\n\td = min(d, s(uv, vec2(0.313, -0.032), vec2(0.338, 0.241),vec2(0.021, 0.298)));\n\treturn min(d, s(uv, vec2(0.008, -0.284), vec2(0.289169, -0.275179),vec2(0.313, -0.032)));\n}\n\nfloat k26(vec2 uv) { // ha\n\tfloat d = s(uv, vec2(-0.256402, 0.326023), vec2(-0.338065, 0.035291),vec2(-0.239389, -0.335351));\n\td = min(d, s(uv, vec2(-0.113493, -0.165332), vec2(0.196145, -0.167032),vec2(0.328846, -0.184034)));\n\td = min(d, s(uv, vec2(-0.042, 0.125), vec2(0.105975, 0.042091),vec2(0.350963, 0.247815)));\n\td = min(d, s(uv, vec2(-0.066, 0.27), vec2(-0.128, 0.18),vec2(-0.042, 0.125)));\n\td = min(d, s(uv, vec2(-0.066, 0.27), vec2(0, 0.336),vec2(0.097, 0.298)));\n\td = min(d, s(uv, vec2(0.179132, 0.174706), vec2(0.180833, 0.264817),vec2(0.097, 0.298)));\n\treturn min(d, l(uv, vec2(0.16, -0.338752), vec2(0.179132, 0.174706)));\n}\n\nfloat k27(vec2 uv) { // hi\n\tfloat d = s(uv, vec2(-0.322753, -0.262243), vec2(-0.20196, -0.255442),vec2(-0.050544, -0.297947));\n\td = min(d, s(uv, vec2(-0.050544, -0.297947), vec2(-0.397, 0.085),vec2(-0.215571, 0.261416)));\n\td = min(d, s(uv, vec2(-0.215571, 0.261416), vec2(-0.142, 0.334),vec2(0.002, 0.299)));\n\td = min(d, s(uv, vec2(0.128, -0.295), vec2(0.253989, -0.031017),vec2(0.354366, 0.013188)));\n\treturn min(d, s(uv, vec2(0.002, 0.299), vec2(0.274404, 0.222),vec2(0.128, -0.295)));\n}\n\nfloat k28(vec2 uv) { // fu\n\tfloat d = s(uv, vec2(-0.336363, 0.275018), vec2(-0.252999, 0.076095),vec2(-0.244493, -0.010615));\n\td = min(d, s(uv, vec2(0.167222, -0.255442), vec2(-0.026726, -0.255442),vec2(-0.198558, -0.314949)));\n\td = min(d, s(uv, vec2(0.167222, -0.255442), vec2(-0.166233, -0.14323),vec2(-0.009713, 0.009788)));\n\td = min(d, s(uv, vec2(-0.009713, 0.009788), vec2(0.235274, 0.241014),vec2(0, 0.310722)));\n\td = min(d, s(uv, vec2(0, 0.310722), vec2(-0.125402, 0.334524),vec2(-0.181545, 0.237613)));\n\treturn min(d, s(uv, vec2(0.342457, 0.261416), vec2(0.311833, 0.106699),vec2(0.219963, -0.017415)));\n}\n\nfloat k29(vec2 uv) { // he\n\tfloat d = s(uv, vec2(-0.030129, -0.173833), vec2(-0.101583, -0.267344),vec2(-0.171337, -0.163632));\n\td = min(d, s(uv, vec2(-0.030129, -0.173833), vec2(0.175729, 0.084596),vec2(0.35947, 0.225712)));\n\treturn min(d, l(uv, vec2(-0.351675, 0.081196), vec2(-0.171337, -0.163632)));\n}\n\nfloat k30(vec2 uv) { // ho\n\tfloat d = s(uv, vec2(-0.256402, 0.326023), vec2(-0.338065, 0.035291),vec2(-0.239389, -0.335351));\n\td = min(d, s(uv, vec2(-0.042, 0.125), vec2(0.105975, 0.042091),vec2(0.350963, 0.247815)));\n\td = min(d, s(uv, vec2(-0.066, 0.27), vec2(-0.128, 0.18),vec2(-0.042, 0.125)));\n\td = min(d, s(uv, vec2(-0.066, 0.27), vec2(0, 0.336),vec2(0.097, 0.298)));\n\td = min(d, s(uv, vec2(0.179132, 0.174706), vec2(0.180833, 0.264817),vec2(0.097, 0.298)));\n\td = min(d, s(uv, vec2(0.310132, -0.301347), vec2(0.078755, -0.272444),vec2(-0.087973, -0.284346)));\n\td = min(d, s(uv, vec2(-0.093077, -0.085423), vec2(0.100872, -0.073522),vec2(0.318638, -0.102425)));\n\treturn min(d, l(uv, vec2(0.16, -0.285), vec2(0.179132, 0.174706)));\n}\n\nfloat k31(vec2 uv) { // ma\n\tfloat d = s(uv, vec2(-0.289987, -0.236059), vec2(0.088339, -0.219379),vec2(0.290021, -0.254129));\n\td = min(d, s(uv, vec2(-0.281642, -0.066479), vec2(0.022967, -0.055359),vec2(0.291412, -0.088719)));\n\td = min(d, s(uv, vec2(0.301148, 0.27685), vec2(0.032703, 0.053061),vec2(-0.200969, 0.121171)));\n\td = min(d, s(uv, vec2(-0.200969, 0.121171), vec2(-0.288596, 0.15592),vec2(-0.26356, 0.23237)));\n\td = min(d, s(uv, vec2(-0.26356, 0.23237), vec2(-0.214757, 0.327384),vec2(-0.076284, 0.311293)));\n\td = min(d, s(uv, vec2(-0.076284, 0.311293), vec2(0.039647, 0.283938),vec2(0.027139, 0.16426)));\n\treturn min(d, l(uv, vec2(0.01184, -0.348649), vec2(0.027139, 0.16426)));\n}\n\nfloat k32(vec2 uv) { // mi\n\tfloat d = s(uv, vec2(-0.05, -0.31), vec2(0.010664, -0.313037),vec2(-0.008658, -0.232582));\n\td = min(d, s(uv, vec2(-0.008658, -0.232582), vec2(-0.079504, 0.081192),vec2(-0.16, 0.19061)));\n\td = min(d, s(uv, vec2(-0.16, 0.19061), vec2(-0.27, 0.309),vec2(-0.321026, 0.176129)));\n\td = min(d, s(uv, vec2(-0.321026, 0.176129), vec2(-0.36, 0.07),vec2(-0.25179, -0.005699)));\n\td = min(d, s(uv, vec2(-0.25179, -0.005699), vec2(-0.005438, -0.1473),vec2(0.353625, 0.143947)));\n\td = min(d, s(uv, vec2(0.239305, -0.190745), vec2(0.242525, 0.235665),vec2(0.012274, 0.322556)));\n\treturn min(d, l(uv, vec2(-0.27, -0.3), vec2(-0.05, -0.31)));\n}\n\nfloat k33(vec2 uv) { // mu\n\tfloat d = s(uv, vec2(-0.303541, -0.22891), vec2(-0.141159, -0.225933),vec2(0.062935, -0.243798));\n\td = min(d, s(uv, vec2(0.189563, -0.267618), vec2(0.261071, -0.212534),vec2(0.334068, -0.10832)));\n\td = min(d, s(uv, vec2(0.140402, 0.302581), vec2(0.337048, 0.251962),vec2(0.222338, 0.048001)));\n\td = min(d, s(uv, vec2(0.140402, 0.302581), vec2(0.003346, 0.32789),vec2(-0.13818, 0.305558)));\n\td = min(d, s(uv, vec2(-0.13818, 0.305558), vec2(-0.240972, 0.26685),vec2(-0.157547, 0.131372)));\n\td = min(d, s(uv, vec2(-0.157547, 0.131372), vec2(-0.036, -0.081522),vec2(-0.211177, -0.0845)));\n\td = min(d, s(uv, vec2(-0.211177, -0.0845), vec2(-0.332589, -0.069282),vec2(-0.316597, 0.06841)));\n\td = min(d, s(uv, vec2(-0.316597, 0.06841), vec2(-0.301834, 0.175368),vec2(-0.209569, 0.147092)));\n\td = min(d, s(uv, vec2(-0.209569, 0.147092), vec2(-0.154, 0.129),vec2(-0.126, 0.06841)));\n\treturn min(d, l(uv, vec2(-0.133711, -0.066), vec2(-0.130731, -0.343545)));\n}\n\nfloat k34(vec2 uv) { // me\n\tfloat d = s(uv, vec2(-0.031688, 0.203557), vec2(-0.129642, 0.119877),vec2(-0.205478, -0.312734));\n\td = min(d, s(uv, vec2(0.101024, -0.341154), vec2(0.00465, 0.197241),vec2(-0.197578, 0.247765)));\n\td = min(d, s(uv, vec2(-0.197578, 0.247765), vec2(-0.32397, 0.261975),vec2(-0.319231, 0.108824)));\n\td = min(d, s(uv, vec2(-0.319231, 0.108824), vec2(-0.317651, -0.056957),vec2(-0.15966, -0.15169)));\n\td = min(d, s(uv, vec2(-0.15966, -0.15169), vec2(0.097864, -0.27642),vec2(0.262174, -0.121691)));\n\td = min(d, s(uv, vec2(0.262174, -0.121691), vec2(0.377507, 0.006198),vec2(0.279553, 0.160927)));\n\treturn min(d, s(uv, vec2(0.279553, 0.160927), vec2(0.198978, 0.280922),vec2(0.00623, 0.307762)));\n}\n\nfloat k35(vec2 uv) { // mo\n\tfloat d = s(uv, vec2(-0.284473, -0.214844), vec2(-0.071186, -0.183267),vec2(0.131042, -0.202213));\n\td = min(d, s(uv, vec2(-0.311331, -0.008012), vec2(-0.112263, 0.026723),vec2(0.115243, 0.012513)));\n\td = min(d, l(uv, vec2(-0.072766, -0.341154), vec2(-0.143861, 0.081984)));\n\td = min(d, s(uv, vec2(-0.143861, 0.081984), vec2(-0.1723, 0.329867),vec2(0.037828, 0.320393)));\n\treturn min(d, s(uv, vec2(0.037828, 0.320393), vec2(0.402785, 0.315657),vec2(0.230576, -0.017485)));\n\n}\n\nfloat k36(vec2 uv) { // ya\n\tfloat d = s(uv, vec2(-0.230756, -0.317471), vec2(-0.082245, 0.113561),vec2(-0.044327, 0.340919));\n\td = min(d, s(uv, vec2(-0.33187, -0.069588), vec2(-0.012729, -0.227475),vec2(0.184, -0.211687)));\n\td = min(d, s(uv, vec2(0.32063, -0.058536), vec2(0.344329, -0.188004),vec2(0.184, -0.211687)));\n\td = min(d, s(uv, vec2(0.32063, -0.058536), vec2(0.279553, 0.148296),vec2(0.028348, 0.066195)));\n\treturn min(d, l(uv, vec2(0.061526, -0.352206), vec2(0.069426, -0.210108)));\n}\n\nfloat k37(vec2 uv) { // yu\n\tfloat d = s(uv, vec2(-0.287633, 0.19882), vec2(-0.320811, 0.020408),vec2(-0.270254, -0.295367));\n\td = min(d, s(uv, vec2(-0.287633, 0.19882), vec2(-0.200738, -0.257474),vec2(0.131, -0.229)));\n\td = min(d, s(uv, vec2(0.131, -0.229), vec2(0.344329, -0.199056),vec2(0.319051, 0.00304)));\n\td = min(d, s(uv, vec2(0.319051, 0.00304), vec2(0.300092, 0.151454),vec2(0.132, 0.203)));\n\td = min(d, s(uv, vec2(0.132, 0.203), vec2(-0.044327, 0.24145),vec2(-0.134382, 0.067774)));\n\td = min(d, s(uv, vec2(-0.104364, 0.342498), vec2(0.151581, 0.238292),vec2(0.052047, -0.353785)));\n\treturn d;\n}\n\nfloat k38(vec2 uv) { // yo\n\tfloat d = s(uv, vec2(0.035258, 0.165025), vec2(0.004476, -0.077452),vec2(0.000854, -0.343454));\n\td = min(d, s(uv, vec2(0.035258, 0.165025), vec2(0.046122, 0.284454),vec2(-0.037171, 0.298931)));\n\td = min(d, s(uv, vec2(-0.037171, 0.298931), vec2(-0.22, 0.34),vec2(-0.274375, 0.253692)));\n\td = min(d, s(uv, vec2(-0.274375, 0.253692), vec2(-0.344, 0.121),vec2(-0.13676, 0.090834)));\n\td = min(d, s(uv, vec2(-0.13676, 0.090834), vec2(0.125, 0.06),vec2(0.286947, 0.273597)));\n\treturn min(d, s(uv, vec2(0.288758, -0.187834), vec2(0.142, -0.155),vec2(0.00666, -0.163)));\n}\n\nfloat k39(vec2 uv) { // ra\n\tfloat d = s(uv, vec2(-0.154067, -0.319705), vec2(0.029707, -0.278893),vec2(0.181924, -0.256632));\n\td = min(d, s(uv, vec2(-0.256163, 0.099545), vec2(-0.241313, -0.063703),vec2(-0.209756, -0.165733)));\n\td = min(d, s(uv, vec2(-0.256163, 0.099545), vec2(-0.085383, -0.048862),vec2(0.096534, -0.028456)));\n\td = min(d, s(uv, vec2(0.096534, -0.028456), vec2(0.328, -0.001),vec2(0.263601, 0.181169)));\n\treturn min(d, s(uv, vec2(0.263601, 0.181169), vec2(0.196, 0.344837),vec2(-0.196054, 0.288222)));\n}\n\nfloat k40(vec2 uv) { // ri\n\tfloat d = s(uv, vec2(-0.208931, 0.109127), vec2(-0.260077, -0.097026),vec2(-0.171424, -0.345772));\n\td = min(d, s(uv, vec2(-0.208931, 0.109127), vec2(-0.127098, -0.28103),vec2(0.041683, -0.279326)));\n\td = min(d, s(uv, vec2(0.041683, -0.279326), vec2(0.166137, -0.279326),vec2(0.207054, -0.153249)));\n\td = min(d, s(uv, vec2(0.207054, -0.153249), vec2(0.259904, 0.046088),vec2(0.174661, 0.175573)));\n\treturn min(d, s(uv, vec2(0.174661, 0.175573), vec2(0.099648, 0.303353),vec2(-0.120278, 0.330613)));\n}\n\nfloat k41(vec2 uv) { // ru\n\tfloat d = s(uv, vec2(0.179776, -0.309994), vec2(-0.014578, -0.291252),vec2(-0.21916, -0.298067));\n\td = min(d, s(uv, vec2(0.179776, -0.309994), vec2(0.033158, -0.141323),vec2(-0.309517, 0.081867)));\n\td = min(d, s(uv, vec2(-0.309517, 0.081867), vec2(0.123516, -0.132804),vec2(0.25479, 0.022236)));\n\td = min(d, s(uv, vec2(0.25479, 0.022236), vec2(0.331508, 0.109127),vec2(0.249675, 0.221574)));\n\td= min(d, s(uv, vec2(0.249675, 0.221574), vec2(0.150793, 0.330613),vec2(-0.038445, 0.31528)));\n\td = min(d, s(uv, vec2(-0.038445, 0.31528), vec2(-0.209385, 0.293077),vec2(-0.168507, 0.176974)));\n\td = min(d, s(uv, vec2(-0.168507, 0.176974), vec2(-0.134084, 0.121072),vec2(-0.041571, 0.136123)));\n\td = min(d, s(uv, vec2(0.25479, 0.022236), vec2(0.331508, 0.109127),vec2(0.249675, 0.221574)));\n\treturn min(d, s(uv, vec2(-0.041571, 0.136123), vec2(0.088, 0.169),vec2(0.074607, 0.312)));\n}\n\nfloat k42(vec2 uv) { // re\n\tfloat d = s(uv, vec2(-0.183158, -0.34592), vec2(-0.20194, 0.076392),vec2(-0.194896, 0.334473));\n\td = min(d,  s(uv, vec2(0.152, -0.219), vec2(0.011, -0.27),vec2(-0.354, 0.189)));\n\td = min(d, s(uv, vec2(0.152, -0.219), vec2(0.247138, -0.197006),vec2(0.203037, -0.049533)));\n\td = min(d, s(uv, vec2(0.203037, -0.049533), vec2(0.158936, 0.121671),vec2(0.177594, 0.243718)));\n\td = min(d, s(uv, vec2(0.177594, 0.243718), vec2(0.201, 0.318),vec2(0.267493, 0.279315)));\n\td = min(d, l(uv, vec2(-0.157333, -0.193419), vec2(-0.1908, -0.1535)));\n\treturn min(d, l(uv, vec2(-0.157333, -0.193419), vec2(-0.340455, -0.174649)));\n}\n\nfloat k43(vec2 uv) { // ro\n\tfloat d = s(uv, vec2(0.17433, -0.296286), vec2(-0.09899, -0.280485),vec2(-0.214191, -0.287257));\n\td = min(d, s(uv, vec2(0.17433, -0.296286), vec2(-0.026707, -0.086351),vec2(-0.306803, 0.098753)));\n\td = min(d, s(uv, vec2(-0.306803, 0.098753), vec2(-0.159979, 0.008458),vec2(0.036541, -0.027659)));\n\td = min(d, s(uv, vec2(0.036541, -0.027659), vec2(0.251131, -0.057005),vec2(0.29179, 0.085209)));\n\treturn min(d, s(uv, vec2(0.29179, 0.085209), vec2(0.321155, 0.36738),vec2(-0.184826, 0.286115)));\n}\n\nfloat k44(vec2 uv) { // wa\n\tfloat d = s(uv, vec2(0.041058, -0.163101), vec2(-0.159979, -0.097638),vec2(-0.345204, 0.180018));\n\td = min(d, s(uv, vec2(0.041058, -0.163101), vec2(0.287272, -0.228565),vec2(0.318896, 0.012973)));\n\td = min(d, s(uv, vec2(0.318896, 0.012973), vec2(0.343743, 0.23871),vec2(0.034282, 0.279343)));\n\td = min(d, l(uv, vec2(-0.19, 0.34), vec2(-0.18, -0.35)));\n\td = min(d, l(uv, vec2(-0.342945, -0.176646), vec2(-0.144167, -0.196962)));\n\treturn min(d, l(uv, vec2(-0.1833, -0.12), vec2(-0.144167, -0.196962)));\n}\n\nfloat k45(vec2 uv) { // wo\n\tfloat d = s(uv, vec2(0.236574, -0.261088), vec2(-0.012916, -0.21905),vec2(-0.305921, -0.234996));\n\td = min(d, s(uv, vec2(-0.034674, -0.348063), vec2(-0.095596, -0.169765),vec2(-0.317526, 0.073764)));\n\td = min(d, s(uv, vec2(-0.317526, 0.073764), vec2(0.136488, -0.303126),vec2(0.075566, 0.175234)));\n\td = min(d, s(uv, vec2(-0.098497, 0.296999), vec2(-0.326229, 0.127398),vec2(0.330858, -0.059597)));\n\treturn min(d, s(uv, vec2(-0.098497, 0.296999), vec2(0.009, 0.362),vec2(0.288793, 0.305696)));\n}\n\nfloat k46(vec2 uv) { // n\n\tfloat d = s(uv, vec2(-0.32093, 0.31), vec2(-0.171901, -0.1093),vec2(-0.083194, -0.33));\n\td = min(d, s(uv, vec2(-0.32093, 0.31), vec2(-0.145289, -0.068),vec2(-0.002, -0.027)));\n\td = min(d, s(uv, vec2(-0.002, -0.027), vec2(0.066, -0.011),vec2(0.060512, 0.18679)));\n\td = min(d, s(uv, vec2(0.146704, 0.305019), vec2(0.300997, 0.314903),vec2(0.332647, 0.081638)));\n\treturn min(d, s(uv, vec2(0.060512, 0.18679), vec2(0.0605, 0.303042),vec2(0.146704, 0.305019)));\n}\n\nfloat hiragana(vec2 p, int char, float scale)\n{\n    float d = 1.0;\n    if (char > 45) return d;\n\tchar = int(fract(float(char)/46.0)*47.0)+1;\n    \n\tfloat s = 1.0/scale;\n\tp *= s;\n \n    if (char == 1) d = k1(p);\n    if (char == 2) d = k2(p);\n    if (char == 3) d = k3(p);\n    if (char == 4) d = k4(p);\n    if (char == 5) d = k5(p);\n    if (char == 6) d = k6(p);\n    if (char == 7) d = k7(p);\n    if (char == 8) d = k8(p);\n    if (char == 9) d = k9(p);\n    if (char == 10) d = k10(p);\n    if (char == 11) d = k11(p);\n    if (char == 12) d = k12(p);\n    if (char == 13) d = k13(p);\n    if (char == 14) d = k14(p);\n    if (char == 15) d = k15(p);\n    if (char == 16) d = k16(p);\n    if (char == 17) d = k17(p);\n    if (char == 18) d = k18(p);\n    if (char == 19) d = k19(p);\n    if (char == 20) d = k20(p);\n    if (char == 21) d = k21(p);\n    if (char == 22) d = k22(p);\n    if (char == 23) d = k23(p);\n    if (char == 24) d = k24(p);\n    if (char == 25) d = k25(p);\n    if (char == 26) d = k26(p);\n    if (char == 27) d = k27(p);\n    if (char == 28) d = k28(p);\n    if (char == 29) d = k29(p);\n    if (char == 30) d = k30(p);\n    if (char == 31) d = k31(p);\n    if (char == 32) d = k32(p);\n    if (char == 33) d = k33(p);\n    if (char == 34) d = k34(p);\n    if (char == 35) d = k35(p);\n    if (char == 36) d = k36(p);\n    if (char == 37) d = k37(p);\n    if (char == 38) d = k38(p);\n    if (char == 39) d = k39(p);\n    if (char == 40) d = k40(p);\n    if (char == 41) d = k41(p);\n    if (char == 42) d = k42(p);\n    if (char == 43) d = k43(p);\n    if (char == 44) d = k44(p);\n    if (char == 45) d = k45(p);\n    if (char == 46) d = k46(p);\n\treturn d/s;\n}\n\nfloat kset(vec2 p, float scale) {\n\tconst float g = 7.;\n    p = clamp(p*.5+.5,vec2(0),vec2(1));\n\n\tvec2 a = floor(p*g)/vec2(g);\n\tp = fract(p*g) - 0.5;\n\tfloat c = g*(a.x+floor(1./g)) + a.y*g*g;\n\treturn hiragana(p,int(c),scale);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 p = vec2(1,-1)*(2.*I - iResolution.xy) / iResolution.y;\n    vec2 _p = p;\n    p.x += iTime/30.;\n    \n    vec2 s = p*SCALE;\n    \n    float id = floor(hash12(floor(s))*46.);\n    p = fract(s)-.5;\n    \n    bool mouseDown = iMouse.z > 0.;\n    vec2 im = iMouse.xy/iResolution.xy; float r = im.y * .2 + .01;\n    \n    float d = hiragana(\n            mouseDown ? _p : p,\n        int(mouseDown ? im.x * 46. : id),\n            mouseDown ? 2. : GLYPH_SCALE\n    );\n    \n    vec3 col = vec3(smoothstep(RADIUS,RADIUS-.03,\n        #ifdef DISPLAY_ALL\n            kset(_p,GLYPH_SCALE)\n        #else\n            d\n        #endif\n        ));\n  \n\tif(mouseDown)\n    {\n\t\tcol = vec3(smoothstep(r,r-.01,d));\n        \n        // iq sdf colors on key press (s)\n        if(texelFetch(iChannel0, ivec2(83, 0), 0).x > 0.)\n        {\n            d -= r;\n            d *= 2.;\n            col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n            col *= 1.0 - exp2(-25.0*abs(d));\n            col *= 0.8 + 0.2*cos(60.0*abs(d));\n            col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n        }\n    }\n\n    O = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// segment http://iquilezles.org/articles/distfunctions2d/\nfloat l( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// http://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat dot2(vec2 v){return dot(v,v);}\n\n// bezier segment https://www.shadertoy.com/view/MlKcDD\nfloat s( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n    }\n    return sqrt( res );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKyDV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[222, 222, 241, 246, 819], [821, 821, 840, 845, 1094], [1096, 1096, 1115, 1120, 1449], [1451, 1451, 1470, 1475, 1869], [1871, 1871, 1890, 1895, 2522], [2524, 2524, 2543, 2549, 3038], [3040, 3040, 3059, 3065, 3557], [3559, 3559, 3578, 3584, 3842], [3844, 3844, 3863, 3869, 4118], [4120, 4120, 4140, 4146, 4442], [4444, 4444, 4464, 4470, 4898], [4900, 4900, 4920, 4927, 5154], [5156, 5156, 5176, 5182, 5854], [5856, 5856, 5876, 5882, 6311], [6313, 6313, 6333, 6339, 6771], [6773, 6773, 6793, 6799, 7203], [7205, 7205, 7225, 7232, 7685], [7687, 7687, 7707, 7714, 7973], [7975, 7975, 7995, 8001, 8278], [8280, 8280, 8300, 8306, 8578], [8580, 8580, 8600, 8606, 9311], [9313, 9313, 9333, 9339, 9621], [9623, 9623, 9643, 9649, 10500], [10502, 10502, 10522, 10528, 11259], [11261, 11261, 11281, 11287, 11725], [11727, 11727, 11747, 11753, 12365], [12367, 12367, 12387, 12393, 12856], [12858, 12858, 12878, 12884, 13471], [13473, 13473, 13493, 13499, 13778], [13780, 13780, 13800, 13806, 14516], [14518, 14518, 14538, 14544, 15209], [15211, 15211, 15231, 15237, 15865], [15867, 15867, 15887, 15893, 16845], [16847, 16847, 16867, 16873, 17566], [17568, 17568, 17588, 17594, 18070], [18072, 18072, 18092, 18098, 18567], [18569, 18569, 18589, 18595, 19173], [19175, 19175, 19195, 19201, 19766], [19768, 19768, 19788, 19794, 20289], [20291, 20291, 20311, 20317, 20818], [20820, 20820, 20840, 20846, 21724], [21726, 21726, 21746, 21752, 22367], [22369, 22369, 22389, 22395, 22892], [22894, 22894, 22914, 22920, 23424], [23426, 23426, 23446, 23452, 23949], [23951, 23951, 23971, 23976, 24436], [26087, 26087, 26120, 26120, 26313]], "test": "untested"}
{"id": "7lKyDc", "name": "shader - Gabbasova A", "author": "Aigul", "description": "shader for homework 1", "tags": ["hw"], "likes": 3, "viewed": 244, "published": 3, "date": "1662388250", "time_retrieved": "2024-07-30T16:32:43.436566", "image_code": "const vec3 eye = vec3(0,0,9);\nconst vec3 light = vec3(0.0, 3.0, 5.0);\nfloat sphere_move = 1.0;\n\nmat3 rotateX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,c,-s),\n        vec3(0,s,c)\n    );\n}\n\nmat3 rotateY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,0,s),\n        vec3(0,1,0),\n        vec3(-s,0,c)\n    );\n}\n\n\nfloat box ( in vec3 pos, in vec3 size )\n{\n    vec3 pt = abs ( pos ) - size;\n\n    return length ( max ( pt, 0.0 ) ) + min ( max ( pt.x, max ( pt.y, pt.z ) ), 0.0 );\n}\n\nfloat sphere ( vec3 p, in vec3 center, in float radius )\n{\n    return length ( p - center ) - radius;\n}\n\nfloat dE1 ( in vec3 p, in mat3 m)\n{\n    vec3  pt = m * p;\n    float d2 = box    ( pt, vec3 ( 0.8, 0.8, 0.8 ) );\n    \n    float res = d2;\n    for (int i = 0; i <= 1; ++i)\n    {\n        for (int j = 0; j <= 1; ++j)\n        {\n            for (int k = 0; k <= 1; ++k)\n            {\n                float ds = sphere ( pt, vec3 ( -0.8 + float(i) * 1.6, -0.8 + float(j) * 1.6, -0.8 + float(k) * 1.6 ), 0.8 );\n                res = max ( -ds, res ); \n            }\n        }\n    }\n    \n    return res;\n}\n\nfloat dE2 ( in vec3 p, in mat3 m)\n{\n    vec3  pt = m * p;\n    \n    float res = 10.0;\n    \n    sphere_move = 1.0 + sin(iTime * 1.5) / 5.0;\n    \n    for (int i = 0; i <= 1; ++i)\n    {\n        for (int j = 0; j <= 1; ++j)\n        {\n            for (int k = 0; k <= 1; ++k)\n            {\n                float ds = sphere ( pt, vec3 ( -0.8 + float(i) * 1.6, -0.8 + float(j) * 1.6, -0.8 + float(k) * 1.6 ) * sphere_move, 0.5 );\n                res = min ( ds, res ); \n            }\n        }\n    }\n    \n    return res;\n}\n\nvec3 trace ( vec3 from, vec3 dir, out bool hit, in mat3 m, out int obj)\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < 30; steps++ )\n\t{\n\t\tfloat\tdist1 = dE1 ( p, m);\n\t\tfloat\tdist2 = dE2 ( p, m);\n        \n\t\t\n\t\tif ( min(dist1, dist2) < 0.01 )\n\t\t{\n\t\t\thit = true;\n            if (dist1 < 0.01) \n            {\n                obj = 1;\n            }\n            else\n            {\n                obj = 2;\n            }\n\t\t\tbreak;\n\t\t}\n        \n\t\t\n\t\ttotalDist += min(dist1, dist2);\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += min(dist1, dist2) * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal(vec3 z, in mat3 m)\n{\n    float e = 0.001;\n    float dx1 = min(dE1(z + vec3(e,0,0), m), dE2(z + vec3(e,0,0), m));\n    float dx2 = min(dE1(z - vec3(e,0,0), m), dE2(z - vec3(e,0,0), m));\n    float dy1 = min(dE1(z + vec3(0,e,0), m), dE2(z + vec3(0,e,0), m));\n    float dy2 = min(dE1(z - vec3(0,e,0), m), dE2(z - vec3(0,e,0), m));\n    float dz1 = min(dE1(z + vec3(0,0,e), m), dE2(z + vec3(0,0,e), m));\n    float dz2 = min(dE1(z - vec3(0,0,e), m), dE2(z - vec3(0,0,e), m));\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nvec3 getTriplanarWeights ( in vec3 n ) \n{\n\tvec3 triW = abs(n);\n    \n\treturn triW / (triW.x + triW.y + triW.z);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hit;\n    int obj;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z - 0.5);\n    mat3 m = rotateX(6.0*mouse.y) * rotateY(6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy/max(iResolution.x, iResolution.y);\n    vec2 uv = scale * (fragCoord/iResolution.xy - vec2(0.5));\n    vec3 dir = normalize(vec3(uv, 0) - eye);\n    vec4 color = vec4 (0, 0, 0, 1);\n    vec3 p = trace(eye, dir, hit, m, obj);\n    vec3 l = normalize(light - p);\n    vec3 v = normalize(eye - p);\n    vec3 n = generateNormal(p, m);\n    float nl = max(0.0, dot(n,l));\n    vec3 h = normalize(l + v);\n    float hn = max(0.0, dot(h, n));\n    float sp = pow(hn, 150.0);\n    if (hit)\n    {\n        color = 0.7 * vec4(nl) + 0.9 * sp * vec4(0.5,0.5,0.5,1);\n        vec3 tx = getTriplanarWeights( n );\n        vec3 q  = m * p;\n        \n        if (obj == 1)\n        {\n            vec4 cx = texture ( iChannel0, q.yz );\n            vec4 cy = texture ( iChannel0, q.zz );\n            vec4 cz = texture ( iChannel0, q.xy );\n            color *=  tx.x * cx + tx.y * cy + tx.z * cz;\n        }\n        else\n        {\n            q  /= sphere_move;\n            vec4 cx = texture ( iChannel1, q.yz);\n            vec4 cy = texture ( iChannel1, q.zz);\n            vec4 cz = texture ( iChannel1, q.xy);\n            color *=  tx.x * cx + tx.y * cy + tx.z * cz;\n        }\n    }\n    \n    fragColor = color;\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    vec3 col1 = vec3(0.0, 1.0, cos(iTime) / 2.0 + 1.0);\n    vec3 col2 = vec3(0.0, 0.2, sin(iTime) / 2.0 + 1.0);\n            \n    float arg1 = 14.0 * p.x * (sin(iTime) / 3.0 + 1.2);\n    float arg2 = 14.0 * p.y * (sin(iTime) / 3.0 + 1.2);\n\n    float m1 = smoothstep(0.1, 0.9, sin(arg1));\n    float m2 = smoothstep(0.1, 0.9, sin(arg2));\n            \n    vec3 ret1 = mix(col1, col2, m1);\n    vec3 ret2 = mix(col1, col2, m2);\n    \n    fragColor = vec4(ret1,1.0) + vec4(ret2,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lKyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 123, 123, 264], [266, 266, 293, 293, 434], [437, 437, 478, 478, 602], [604, 604, 662, 662, 707], [709, 709, 744, 744, 1205], [1207, 1207, 1242, 1242, 1722], [1724, 1724, 1797, 1797, 2340], [2342, 2342, 2382, 2382, 2892], [2894, 2894, 2935, 2935, 3007], [3009, 3009, 3066, 3066, 4438]], "test": "untested"}
{"id": "7tVyWc", "name": "Inner Space", "author": "Manlibear", "description": "A constellation-esque shader based on an Art Of Code video", "tags": ["space"], "likes": 16, "viewed": 781, "published": 3, "date": "1662383954", "time_retrieved": "2024-07-30T16:32:44.184566", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nfloat DistLine(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa -ba *t);\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b){\n    float d = DistLine(p,a,b);\n    float d2= length(a-b);\n    float m = S(.02, .001, d);\n    m *= S(1.2, .001, length(a-b)) *.5 + S(.1, .03, abs(d2-.75));\n     return m;\n}\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.213, 853.23));\n    p += dot(p, p+23.24);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p){\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 off){\n    vec2 n = N22(id + off) * iTime;\n    return off + sin(n) *.4;\n}\n\nfloat Layer(vec2 uv){\n\n\n    vec2 gv = fract(uv) -.5;\n    vec2 id = floor(uv);\n    float m = 0.;\n\n    vec2 p[9];\n    int i = 0;\n    \n    for(float y=-1.;y<=1.;y++){\n        for(float x=-1.;x<=1.;x++){\n            p[i++] = GetPos(id, vec2(x, y));\n        }\n    }\n    \n    float t=iTime* 5.;\n    \n    \n    for(int i = 0; i < 9;i++)\n    {\n        m += Line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i] - gv) *30.;\n        float sparkle =  1./dot(j, j);\n        \n        m+= sparkle*(sin(t+fract(p[i].x)*10.)*.5 + .5);\n    }\n    \n     m += Line(gv, p[1], p[3]);\n     m += Line(gv, p[1], p[5]);\n     m += Line(gv, p[3], p[7]);\n     m += Line(gv, p[5], p[7]);\n     \n     return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy )/iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n\n    //zoom\n    uv *= 2.;\n    float m = 0.;\n    float t = iTime * .07;\n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    \n    float mouseFac = (length(uv - mouse));\n    \n    uv *= rot;\n    \n    for(float i=0.;i<1.;i+= 1./4.){\n        float z = fract(i+t);\n        float size = mix(10., .5, z);\n        float fade = S(0., .9, z) * S(1., .8, z);\n        \n        m += Layer(uv * size + i*24. + mouse) * fade;\n    }\n    \n    vec2 uvBg = (fragCoord / iChannelResolution[0].xy + (iTime * .1)) *.1;\n    float bg =  texture(iChannel0, uvBg).x * .15;\n    \n    vec3 col = vec3(.04, .04, .1) + ((vec3(m, m, .7*m))) + bg;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 75, 75, 201], [203, 203, 238, 238, 410], [412, 412, 430, 430, 525], [527, 527, 544, 544, 598], [600, 600, 631, 631, 698], [700, 700, 721, 721, 1379], [1382, 1382, 1439, 1439, 2226]], "test": "untested"}
{"id": "ftVcD3", "name": "[twigl]Capillary 2 (217 chrs)", "author": "Catzpaw", "description": "https://twitter.com/catzpaw/status/1325991950231613440", "tags": ["raymarching", "twigl"], "likes": 15, "viewed": 289, "published": 3, "date": "1662355177", "time_retrieved": "2024-07-30T16:32:45.020331", "image_code": "//--- Capillary 2\n// by Catzpaw 2020\n\n//https://bit.ly/3lfOP4T\n\nTWIGL_GEEKEST_300ES\n\nfloat i,l,d=.5;\nvec3 p,v=vec3(0,1.5,fract(t*d)*12.6);\nfor(;++i<99.&&d>.01;l+=d*.4)\n  p=vec3(l*(FC.xy*2.-r)/r.y,l)+v,\n  d=min(6.-length((p-v).xy+sin(p.yx)),dot(cos(p),sin(p.yzx)))\n    +sin(sin(p.z*3.5)+v.z)*.1+1.;\no=l*.1-v.xyyx*l/i;\n\nEND_GEEKEST_300ES\n", "image_inputs": [], "common_code": "/* ============================================ **\n\n███████        █   TWIGL GEEKEST WRAPPER\n█  █  █            for Shadertoy\n   █  ███  █████\n   █   █ ▐▌ █  █    by Catzpaw 2022\n  ███  ▐█▌▐█▌ ███\n\n ██       ██  ██\n █  ▐█████ █   █\n█▌ ▐█   █  █   ▐█  \"twigl\"\n █ ▐█   █  █   █    https://twigl.app/\n ██ ▐████ ███ ██    Copyright (c) 2020 doxas\n    ████▌\n\nMIT License\nhttps://github.com/doxas/twigl/blob/master/LICENSE\n\n** ============================================ */\n\n\n/*** NOTICE **************************************\n  No backbuffer supported.\n  No MRT supported.\n  \"s\" is always zero.\n*************************************************/\n\n\n\n// --------------------------------------------\n//  noise.glsl\n// --------------------------------------------\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec2  mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3  mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4  mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nfloat permute(float x){return mod289(((x*34.0)+1.0)*x);}\nvec3  permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);}\nvec4  permute(vec4 x) {return mod289(((x*34.0)+1.0)*x);}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4  taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise2D(vec2 v){\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\nfloat snoise3D(vec3 v){\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\nvec4 grad4(float j, vec4 ip){\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\nfloat snoise4D(vec4 v){\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  // 2 * G4\n                          0.414589803375032,  // 3 * G4\n                         -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n               i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n             + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n             + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n             + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                  + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\nfloat fsnoise      (vec2 c){return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);}\nfloat fsnoiseDigits(vec2 c){return fract(sin(dot(c, vec2(0.129898, 0.78233))) * 437.585453);}\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\nconst float PI = 3.141592653589793;\nconst float PI2 = PI * 2.0;\n\n\n// --------------------------------------------\n//  twigl geekest(300 es) aliases\n// --------------------------------------------\n#define TWIGL_GEEKEST_300ES void mainImage(out vec4 o,in vec2 _fc){vec2 r=iResolution.xy,m=iMouse.xy/r;vec4 FC=vec4(_fc,.5,1);float s=0.,t=iTime;int f=iFrame;o=vec4(0);\n#define END_GEEKEST_300ES o=clamp(o,0.,1.);}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "flKyW3", "name": "010 - Paraboloid SDF Shading", "author": "PiGIon", "description": "I tried to add shading to the Paraboloid, somewhat successful, there are many glitches though. This mainly tests if the SDF is right. As the time passes, the sides of the shape keeps growing, like a Paraboloid should.", "tags": ["mouse", "sdf", "begginer", "paraboloid"], "likes": 1, "viewed": 247, "published": 3, "date": "1662345194", "time_retrieved": "2024-07-30T16:32:45.900977", "image_code": "// 2022.09.04\n\n#define PI 3.14159265\n\n// rayMarch\n// returns the vector that hit the geometry\nvec3 rayMarch(vec3 origin, vec3 direction);\n\nvec3 mouseRot(vec3 v);\n\n// SDF main function\n// calculates distance from items in the scene\nfloat SDF();\n\nvec2 mouseScale;\nvec2 uv;\n\n// sined distance function of a paraboloid at Z\n// https://en.wikipedia.org/wiki/Signed_distance_function\nfloat paraboloidZSDF(vec2 o, vec3 p, float a, float b) {\n    float z = (pow(p.x - o.x, 2.)/pow(a, 2.)) + (pow(p.y - o.y, 2.)/pow(b, 2.));\n\n    return z - p.z;\n}\n\nfloat planeSDF(float y, vec3 p) {\n    return p.y - y;\n}\n\nfloat SDF(vec3 p) {\n    return min(\n            paraboloidZSDF(vec2(0., 0.), p, 1., 1.),\n            planeSDF(-5., p)\n            );\n}\n\nvec3 getNormal(vec3 p) {\n    float d = SDF(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        SDF(p - e.xyy),\n        SDF(p - e.yxy),\n        SDF(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat light(vec3 o, vec3 view) {\n    vec3 l = normalize(o - view);\n    vec3 n = getNormal(view);\n    float distView = length(o - view);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    float d = length(rayMarch(view + n * 0.02, l));\n    if (d < distView) dif *= .5;\n    \n    return dif;\n}\n\nvec3 rayMarch(vec3 o, vec3 d) {\n    vec3 ray;\n    vec3 mouseDir = d;\n    float t = 0.;\n\n    for (int i = 0; i < 128; i++) {\n        ray = o + mouseDir * t;\n\n        float dist = SDF(ray);\n\n    \tif(dist < 0.001) break;\n\n\t\tt += dist;\n    }\n    \n    return ray;\n}\n\n// initializes global vars\nvoid init(vec4 fragColor, vec2 fragCoord) {\n    mouseScale = vec2((iMouse.x / iResolution.x) - 0.5, (iMouse.y / iResolution.y) - 0.5);\n    \n    // if scene started, defaults to middle of screen mouse\n    if (length(iMouse) == 0.) {\n        mouseScale = vec2(((iResolution.x/2.) / iResolution.x) - 0.5, ((iResolution.y/2.) / iResolution.y) - 0.5);\n    }\n    \n    uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    init(fragColor, fragCoord);\n    \n\n    vec3 dir = normalize(vec3(uv, 1.));\n    vec3 eyes = vec3(0, 2., -5. + iTime/1.);\n    vec3 lightPos = vec3(2., 2., -4);\n    \n    eyes.xy += mouseScale * 10.;\n    lightPos.xy += mouseScale * 10.;\n    \n\n    // gest the vector where it was hit\n    vec3 hit = rayMarch(eyes, normalize(vec3(uv, 1.)));\n    \n    float l = light(lightPos, hit);\n    \n\n    fragColor = vec4(vec3(l), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flKyW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[272, 378, 434, 434, 538], [540, 540, 573, 573, 595], [597, 597, 616, 616, 731], [733, 733, 757, 757, 939], [941, 941, 973, 973, 1236], [1238, 1238, 1269, 1269, 1498], [1500, 1527, 1570, 1570, 1946], [1948, 1948, 2004, 2004, 2426]], "test": "untested"}
{"id": "stGcDc", "name": "Glowing clock variation", "author": "fishy", "description": "Clock constructed with distance fields. sdOrientedBox and the smoothMax functions are by @iq and the blackbody function is by @FabriceNeyret2 (modified by me). Added a bit of noise B)", "tags": ["time", "sdf", "clock"], "likes": 3, "viewed": 307, "published": 3, "date": "1662337363", "time_retrieved": "2024-07-30T16:32:46.683883", "image_code": "#define PI 3.141592653\n#define date (iDate * 1.0)\n#define smooth 0.005\n\nfloat join( float d1, float d2) //By iq\n{\n    float h = max(smooth-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/smooth;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th ) // Made by iq\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdDisk(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdDiskOutline(vec2 p, float r1, float r2)\n{\n    return abs(length(p) - r1) - r2*0.5;\n}\n\nfloat sdRotatedLine(vec2 p, vec2 start, float offset, float len, float theta, float thick)\n{\n    return sdOrientedBox(p, start + vec2(sin(theta), cos(theta)) * offset, vec2(sin(theta), cos(theta)) * (len + offset), thick);\n}\n\nvec4 sd(vec2 p)\n{\n    float seconds = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.15, (floor(date.w)/60.0)*2.0*PI, -0.001);\n    float minutes = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.13, (date.w/60.0/60.0)*2.0*PI, 0.0);\n    float hours = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.1, (date.w/60.0/60.0/12.0)*2.0*PI, 0.0);\n    float centerDisk = sdDisk(p, 0.0);\n    float outerCircle = sdDiskOutline(p, 0.23, 0.0);\n    float ticks = 1000000.0;\n    for(float i = 0.0; i < 2.0*PI; i+= 2.0*PI/12.0)\n    {\n        ticks = join(ticks, sdRotatedLine(p, vec2(0.0, 0.0), 0.18, 0.03, i, 0.0));\n    }\n    \n    for(float i = 0.0; i < 2.0*PI; i+= 2.0*PI/60.0)\n    {\n        ticks = join(ticks, sdRotatedLine(p, vec2(0.0, 0.0), 0.2, 0.01, i, -0.005));\n    }\n    return vec4(join(join(join(join(join(seconds, minutes), hours), centerDisk), outerCircle), ticks), 0.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y *= ratio;\n    \n    float px = 1.0/ratio/max(iResolution.x, iResolution.y);\n    float intensity = mapRange(0.0, 1.0, 1.0, 2.0, noise(vec2(uv.x, uv.x+iTime*0.1)*10.0));\n    vec4 col = blackbody(.005/max(0.0, sd(uv).x + 0.01), intensity);\n    col += max(vec4(0.0), blackbody(erp(abs(fragCoord.y/iResolution.y - 0.5)*2.0, 0.2) * 0.5, intensity)) * 1.0;\n    fragColor = col;\n    //fragColor = vec4(uv.xy, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "float mapRange(float x1, float x2, float y1, float y2, float v)\n{\n    return (v - x1) / (x2 - x1) * (y2 - y1) + y1;\n}\n\nvec4 blackbody(float x, float intensity) //By @FabriceNeyret2 (modified by me) https://www.shadertoy.com/view/4tdGWM\n{\n    vec4 O = vec4(0.0);\n    float m = .01+5.*intensity,\n        T = x*16000.; // absolute temperature (K)\n    \n    O -= O;\n    \n/*  // --- with physical units: (but math conditionning can be an issue)\n    float h = 6.6e-34, k=1.4e-23, c=3e8; // Planck, Boltzmann, light speed  constants\n\n    for (float i=0.; i<3.; i++) {  // +=.1 if you want to better sample the spectrum.\n        float f = 4e14 * (1.+.5*i); \n        O[int(i)] += 1e7/m* 2.*(h*f*f*f)/(c*c) / (exp((h*f)/(k*T)) - 1.);  // Planck law\n    }\n*/\n    // --- with normalized units:  f = 1 (red) to 2 (violet). \n    // const 19E3 also disappears if you normalized temperatures with 1 = 19000 K\n     for (float i=0.; i<3.; i += .05) {  // +=.1 if you want to better sample the spectrum.\n        float f = 1.+.5*i; \n        O[int(i)] += 10./m* (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\n#define ease 1.5\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\nfloat hash2(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n  \n    float tl = hash2(vec2(floor(p.x),  ceil(p.y)));\n    float bl = hash2(vec2(floor(p.x), floor(p.y)));\n    float tr = hash2(vec2( ceil(p.x),  ceil(p.y)));\n    float br = hash2(vec2( ceil(p.x), floor(p.y)));\n    \n    \n    float a = mix(bl, tl, erp(fract(p.y), ease));\n    float b = mix(br, tr, erp(fract(p.y), ease));\n    \n    return mix(a, b, erp(fract(p.x), ease));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGcDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 113, 113, 294], [296, 296, 376, 376, 593], [595, 595, 626, 626, 654], [656, 656, 705, 705, 748], [750, 750, 842, 842, 974], [976, 976, 993, 993, 1834], [1836, 1836, 1893, 1893, 2423]], "test": "untested"}
{"id": "styyDc", "name": "Simple Maze GoL (B3/S12345)", "author": "lukeathedev", "description": "https://conwaylife.com/wiki/OCA:Maze", "tags": ["conway", "gameoflife", "cellularautomata"], "likes": 6, "viewed": 190, "published": 3, "date": "1662336881", "time_retrieved": "2024-07-30T16:32:47.565527", "image_code": "// By Lucas\n// Check 'Buffer A' for implementation\n\nvoid mainImage(out vec4 C, in vec2 P)\n{\n    vec2 uv = P/iResolution.xy;\n    C = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// By Lucas\n// Simple Maze GoL (B3/S12345)\n\n#define START_SIZE 4.0\n#define START_FRAME 64\n#define SEED 91.34583\n\nfloat rand(float x) {\n    return fract(sin(x * SEED) * 47453.5453);\n}\n\nvec3 rand3(float x) {\n    return vec3(rand(x) > 0.5 ? 1.0 : 0.0);\n}\n\nbool alive(ivec2 pos) {\n    vec3 tex = texelFetch(iChannel0, pos, 0).rgb;\n    return tex.r > 0.0 ||\n           tex.g > 0.0 ||\n           tex.b > 0.0;\n}\n\nvec3 colorize(vec3 col, vec2 uv) {\n    return col + 0.5 + 0.5 * cos(iTime * 0.1 + uv.xyx + vec3(0, 2, 4));\n}\n\nvoid mainImage(out vec4 C, in vec2 P)\n{    \n    // Get neighbors in 3x3 square around pixel (Moore neighborhood)\n    int count = 0;\n    for (int y = -1; y < 2; ++y) {\n        for (int x = -1; x < 2; ++x) {\n            if (alive(ivec2(P.x + float(x), P.y + float(y)))) {\n                count += 1;\n                if (x == 0 && y == 0) {\n                    count -= 1;\n                }\n            }\n        }\n    }\n    \n    bool state = alive(ivec2(P.xy));\n    bool alive = false;\n    // If alive, check whether pixel has enough neighbors (this is S)\n    if (state && (count > 0 && count < 6)) { // S12345\n        alive = true;\n    }\n    \n    // If dead, check whether pixel is allowed to live (this is B)\n    else if (count == 3) { // B3\n        alive = true;\n    }\n\n    vec2 uv = P / iResolution.xy;\n    vec3 col = texelFetch(iChannel0, ivec2(P.xy), 0).rgb;\n    col = (alive == state) ? col :\n          ((alive) ? colorize(col, uv) :\n                     vec3(0.0));\n    \n    C = vec4(col, 1.0);\n    \n    // Pseudo random center starting blob (allows for going fullscreen before start)\n    if (iFrame == START_FRAME) {\n        if (P.x > iResolution.x / 2.0 - START_SIZE && P.x < iResolution.x / 2.0 + START_SIZE) {\n            if (P.y > iResolution.y / 2.0 - START_SIZE && P.y < iResolution.y / 2.0 + START_SIZE) {\n                C = vec4(colorize(rand3(P.x * P.y * (iTime + 1.0))*-1.0, uv), 1.0);            \n            }\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/styyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 91, 91, 157]], "test": "untested"}
{"id": "7tyyWc", "name": "Simple glowing clock", "author": "fishy", "description": "Clock constructed with distance fields. sdOriented box is by @iq and the blackbody function is by @FabriceNeyret2 (modified by me).", "tags": ["time", "sdf", "clock"], "likes": 6, "viewed": 335, "published": 3, "date": "1662330314", "time_retrieved": "2024-07-30T16:32:48.522966", "image_code": "#define PI 3.141592653\n#define date (iDate * 1.0)\n\nfloat join(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th ) // Made by iq\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdDisk(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdDiskOutline(vec2 p, float r1, float r2)\n{\n    return abs(length(p) - r1) - r2*0.5;\n}\n\nfloat sdRotatedLine(vec2 p, vec2 start, float offset, float len, float theta, float thick)\n{\n    return sdOrientedBox(p, start + vec2(sin(theta), cos(theta)) * offset, vec2(sin(theta), cos(theta)) * (len + offset), thick);\n}\n\nvec4 sd(vec2 p)\n{\n    float seconds = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.15, (floor(date.w)/60.0)*2.0*PI, -0.001);\n    float minutes = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.11, (date.w/60.0/60.0)*2.0*PI, 0.0);\n    float hours = sdRotatedLine(p, vec2(0.0, 0.0), 0.0, 0.1, (date.w/60.0/60.0/12.0)*2.0*PI, 0.0);\n    float centerDisk = sdDisk(p, 0.0);\n    float outerCircle = sdDiskOutline(p, 0.23, 0.0);\n    float ticks = 1000000.0;\n    for(float i = 0.0; i < 2.0*PI; i+= 2.0*PI/12.0)\n    {\n        ticks = join(ticks, sdRotatedLine(p, vec2(0.0, 0.0), 0.18, 0.03, i, 0.0));\n    }\n    \n    for(float i = 0.0; i < 2.0*PI; i+= 2.0*PI/60.0)\n    {\n        ticks = join(ticks, sdRotatedLine(p, vec2(0.0, 0.0), 0.2, 0.01, i, -0.005));\n    }\n    return vec4(join(join(join(join(join(seconds, minutes), hours), centerDisk), outerCircle), ticks), 0.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y *= ratio;\n    \n    float px = 1.0/ratio/max(iResolution.x, iResolution.y);\n\n    vec4 col = blackbody(.005/max(0.0, sd(uv).x + 0.01));\n    col += max(vec4(0.0), blackbody(erp(abs(fragCoord.y/iResolution.y - 0.5)*2.0, 0.2) * 0.5)) * 1.0;\n    fragColor = col;\n    //fragColor = vec4(uv.xy, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "vec4 blackbody(float x) //By @FabriceNeyret2 (modified by me) https://www.shadertoy.com/view/4tdGWM\n{\n    vec4 O = vec4(0.0);\n    float m = .01+5.*2.0,\n        T = x*16000.; // absolute temperature (K)\n    \n    O -= O;\n    \n/*  // --- with physical units: (but math conditionning can be an issue)\n    float h = 6.6e-34, k=1.4e-23, c=3e8; // Planck, Boltzmann, light speed  constants\n\n    for (float i=0.; i<3.; i++) {  // +=.1 if you want to better sample the spectrum.\n        float f = 4e14 * (1.+.5*i); \n        O[int(i)] += 1e7/m* 2.*(h*f*f*f)/(c*c) / (exp((h*f)/(k*T)) - 1.);  // Planck law\n    }\n*/\n    // --- with normalized units:  f = 1 (red) to 2 (violet). \n    // const 19E3 also disappears if you normalized temperatures with 1 = 19000 K\n     for (float i=0.; i<3.; i += .05) {  // +=.1 if you want to better sample the spectrum.\n        float f = 1.+.5*i; \n        O[int(i)] += 10./m* (f*f*f) / (exp((19E3*f/T)) - 1.);  // Planck law\n    }\n    return O;\n}\n\n#define ease 1.5\n\nfloat erp(float x, float k)\n{\n    return x < 0.5 ? pow(2.0*x, k)*0.5  : 1. - pow(2.0*(1.0-x), k) / 2.;\n}\n\nfloat hash2(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n  \n    float tl = hash2(vec2(floor(p.x),  ceil(p.y)));\n    float bl = hash2(vec2(floor(p.x), floor(p.y)));\n    float tr = hash2(vec2( ceil(p.x),  ceil(p.y)));\n    float br = hash2(vec2( ceil(p.x), floor(p.y)));\n    \n    \n    float a = mix(bl, tl, erp(fract(p.y), ease));\n    float b = mix(br, tr, erp(fract(p.y), ease));\n    \n    return mix(a, b, erp(fract(p.x), ease));\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tyyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 81, 81, 105], [107, 107, 187, 187, 404], [406, 406, 437, 437, 465], [467, 467, 516, 516, 559], [561, 561, 653, 653, 785], [787, 787, 804, 804, 1645], [1647, 1647, 1704, 1704, 2121]], "test": "untested"}
{"id": "flGcRt", "name": "Almost Infinite Mandelbrot Zoom", "author": "Ric3cir121", "description": "This is a concept able to render a mandelbrot set with a really high precision (192 bits) (ends at 360 seconds)\n\nI challenge anyone to improve this project\n\nIf you want a more detailed mandelbrot check https://www.shadertoy.com/view/slyyWc", "tags": ["mandelbrot", "zoom"], "likes": 5, "viewed": 292, "published": 3, "date": "1662330301", "time_retrieved": "2024-07-30T16:32:49.456470", "image_code": "// This program is able to render a mandelbrot set with a really high resolution\n// I have never decided to make it readable for others but here are a few things to know\n\n// number is a type of number with a really high precision using an array of uint\n// newnum( int | float | void ): used to create a number with the specified value, 0 if not specified\n// operators: sum(a,b): a+b, sub(a,b): a-b, mult(a,b): a*b\n// other functions: rshift(a): a>>1, neg(a): -a\n// solve(a): solves all numbers in the array above 65535\n// negate(a): flips all the bits and the .neg value\n\n// each uint in the arrays stores 16 bits\n// the first 2 elements are in the positive range while the others in the negative one\n\n// uint number.num: the array\n// bool number.neg: if true the value is negative\n// bool number.int: the number is infinite (not used)\n// int number.int: how many elements in the array are in the positive range (not used)\n\nvec2 map(int i){\n    i-=4;\n    if(i<0){\n        vec2 r = vec2(1);\n        if(i%4<2)return r*(i%2==0?1.:-1.);\n        else return r*vec2(1,-1)*(i%2==0?1.:-1.);\n    }\n    int k = i/4;\n    for(int j=2;j<100;j++){\n        if(k<1){\n            vec2 r = vec2(i/4-(j*(j-2)),j-1);\n            if(i%4<2)return r*(i%2==0?1.:-1.);\n            else return r.yx*vec2(1,-1)*(i%2==0?1.:-1.);\n        }\n        k-=j*2;\n    }\n    return vec2(1);\n}\n\nvoid mainImage(out vec4 o, vec2 u){\n    vec2 p = ((u-iResolution.xy/2.)/exp2(fract(iTime/speed)+.5)+iResolution.xy/2.)/iResolution.xy;\n    o = texture(iChannel0,p);\n    ivec2 s[] = ivec2[](ivec2(1),ivec2(1,0),ivec2(0,1),ivec2(-1,1),ivec2(1,-1),ivec2(-1,0),ivec2(0,-1),ivec2(-1));\n    bool empty = o.w<1.;\n    if(!empty)for(int i=0;i<8;i++)\n    if(texelFetch(iChannel0,ivec2(p*iResolution.xy)+s[i],0).w<1.){empty=true;break;}\n    if(empty){\n        for(int i=0;i<6*4;i++){\n            p = (((u+map(i))-iResolution.xy/2.)/exp2(fract(iTime/speed)+.5)+iResolution.xy/2.);\n            o = texelFetch(iChannel0,ivec2(p),0)/1.;\n            if(o.w>0.)break;\n        }\n        if(o.w<=0.)o=vec4(.5);\n    }\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define siz 6\n//(4+int(iTime/50.))\nstruct number{\n    uint num[10];\n    bool inf;\n    bool neg;\n    int ints;\n};\n\nnumber newnum(){\n    number a;\n    for(int i=0;i<siz;i++)a.num[i]=uint(0);\n    a.inf=false;\n    a.ints=2;\n    a.neg=false;\n    return a;\n}\nnumber newnum(int b){\n    number a;\n    for(int i=0;i<siz;i++)a.num[i]=uint(0);\n    a.inf=false;\n    a.ints=2;\n    a.neg=b<0;\n    a.num[a.ints-1] = uint(abs(b));\n    return a;\n}\nnumber newnum(float b){\n    number a;\n    for(int i=0;i<siz;i++)a.num[i]=uint(0);\n    a.inf=false;\n    a.ints=2;\n    a.neg=b<0.;\n    a.num[a.ints-1] = uint(abs(b));\n    a.num[a.ints] = uint(fract(abs(b))*65536.);\n    return a;\n}\n\nnumber mult(number a,number b){\n    number ret = newnum();\n    \n    for(int i=0;i<siz;i++){\n        for(int j=0;j<siz;j++){\n            uint mul = a.num[(siz-1)-i]*b.num[(siz-1)-j];\n            uint mul1 = mul%uint(65536);\n            uint mul2 = mul/uint(65536);\n            int slot1 = (siz*2-3)-i-j;\n            int slot2 = slot1-1;\n            if(slot1>=0&&slot1<=siz)ret.num[slot1] += mul1;\n            if(slot2>=0&&slot2<=siz)ret.num[slot2] += mul2;\n        }\n    }\n    for(int i=siz-1;i>=0;i--){\n        if(ret.num[i]>uint(65535)){\n            if(i>0)ret.num[i-1]+=ret.num[i]/uint(65536);\n            ret.num[i]%=uint(65536);\n        }\n    }\n    ret.neg=a.neg^^b.neg;\n    return ret;\n}\nnumber rshift(number a){\n    for(int i=siz-1;i>=0;i--){\n        a.num[i] /= uint(2);\n        if(i>0)if(a.num[i-1]%uint(2)==uint(1))a.num[i]+=uint(65536/2);\n    }\n    return a;\n}\nnumber negate(number a){\n    for(int i=0;i<siz;i++)a.num[i]=uint(65535)-a.num[i];\n    a.num[siz-1]++;\n    a.neg=!a.neg;\n    return a;\n}\nnumber neg(number a){\n    a.neg=!a.neg;\n    return a;\n}\nnumber solve(number a){\n    for(int i=siz-1;i>=0;i--){\n        if(a.num[i]>uint(65535)){\n            if(i>0)a.num[i-1]+=a.num[i]/uint(65536);\n            else if(uint(a.num[i]/uint(65536))>uint(0))a.neg=a.neg^^true;\n            a.num[i]%=uint(65536);\n        }\n    }\n    return a;\n}\nnumber sum(number a,number b){\n    number ret = newnum();\n    ret.neg=a.neg^^b.neg;\n    if(a.neg)a=negate(a);\n    if(b.neg)b=negate(b);\n    for(int i=siz-1;i>=0;i--){\n        ret.num[i]+=a.num[i]+b.num[i];\n        if(ret.num[i]>uint(65535)){\n            if(i>0)ret.num[i-1]+=ret.num[i]/uint(65536);\n            else if(uint(ret.num[i]/uint(65536))>uint(0))ret.neg=ret.neg^^true;\n            ret.num[i]%=uint(65536);\n        }\n    }\n    if(ret.neg)ret=solve(negate(neg(ret)));\n    return ret;\n}\nnumber sub(number a,number b){return sum(a,neg(b));}\nbool greater(number a,number b){\n    if(a.neg&&!b.neg)return false;\n    if(!a.neg&&b.neg)return true;\n    if(!a.neg)for(int i=0;i<siz;i++){\n        if(a.num[i]>b.num[i])return true;\n        if(a.num[i]<b.num[i])return false;\n    }\n    else for(int i=siz-1;i>=0;i--){\n        if(a.num[i]>b.num[i])return true;\n        if(a.num[i]<b.num[i])return false;\n    }\n    return false;\n}\nfloat nfloat(number a){\n    float r = 0.;\n    float m = 65536.;\n    for(int i=0;i<siz;i++){\n        r += float(a.num[i])*m;\n        m/=65536.;\n    }\n    return r*(a.neg?-1.:1.);\n}\nint nint(number a){\n    return int(a.num[a.ints-2]*uint(65536)+a.num[a.ints-1])*(a.neg?-1:1);\n}\n\n\n//\n\n\nfloat mandelbrot(vec2 u,float zoom){\n    int size = int(floor(iTime/speed)+zoom);\n    number uvx = newnum((u.x-iResolution.x/2.)/iResolution.x*16.);\n    number uvy = newnum((u.y-iResolution.y/2.)/iResolution.x*16.);\n    for(int i=0;i<size;i++){\n        uvx = rshift(uvx);\n        uvy = rshift(uvy);\n    }\n    \n    number limit = newnum(65535);\n    number two = newnum(2);\n    number pos = newnum(.51178137);\n    pos.num = uint[](uint(0),uint(0),uint(34401),uint(12),uint(32610),uint(10990),uint(0),uint(0),uint(0),uint(0));\n    \n    number px = newnum();\n    number py = newnum();\n    uvx = sub(uvx,pos);\n    uvy = sub(uvy,pos);\n    \n    float it = 0.;\n    number npx;\n    for(it=0.;it<floor(iTime/speed*4.)*2.+100.;it++){ \n        npx = sum( sub(mult(px,px),mult(py,py)) , uvx );\n        py = sum( mult(two,mult(px,py)) , uvy );\n        px = npx;\n        if(greater(sum(mult(px,px),mult(py,py)),limit))break;\n    }\n    return it-log2(log2(nfloat(sum(mult(px,px),mult(py,py)))));\n}\n\nvec2 map(int i){\n    i-=4;\n    if(i<0){\n        vec2 r = vec2(1);\n        if(i%4<2)return r*(i%2==0?1.:-1.);\n        else return r*vec2(1,-1)*(i%2==0?1.:-1.);\n    }\n    int k = i/4;\n    for(int j=2;j<100;j++){\n        if(k<1){\n            vec2 r = vec2(i/4-(j*(j-2)),j-1);\n            if(i%4<2)return r*(i%2==0?1.:-1.);\n            else return r.yx*vec2(1,-1)*(i%2==0?1.:-1.);\n        }\n        k-=j*2;\n    }\n    return vec2(1);\n}\n\nfloat hash(float b){return fract(sin(b*12.45872)*48123.5832);}\n\nvoid mainImage(out vec4 o, vec2 u){\n    vec2 uv = (mod(u*2.,iResolution.xy)-iResolution.xy/2.)/iResolution.x*4.;\n    o = texelFetch(iChannel0,ivec2(u),0);\n    \n    vec2 reg = floor(u/iResolution.xy*2.);\n    float zooma = mod( (reg.x+reg.y*2.) +floor(iTime/speed)*3.,4.)+1.;\n    float zoom = mod( (reg.x+reg.y*2.),4.)+1.;\n    vec2 rp = mod(u-.5,floor(iResolution.xy/2.))*2.;\n    \n    if(hash(dot(u,vec2(1.598184,1.3893889))+fract(iTime))>.99+length(uv*(fract(iTime/speed)+1.))*.005)\n    o = vec4(mandelbrot(rp,zooma),zooma,floor(zooma-iTime/speed),1);\n    if(zooma==4.&&floor(zooma-(iTime-iTimeDelta)/speed)!=o.z)o=vec4(0);\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float speed = 6.;", "buffer_b_code": "vec2 map(int i){\n    i-=4;\n    if(i<0){\n        vec2 r = vec2(1);\n        if(i%4<2)return r*(i%2==0?1.:-1.);\n        else return r*vec2(1,-1)*(i%2==0?1.:-1.);\n    }\n    int k = i/4;\n    for(int j=2;j<100;j++){\n        if(k<1){\n            vec2 r = vec2(i/4-(j*(j-2)),j-1);\n            if(i%4<2)return r*(i%2==0?1.:-1.);\n            else return r.yx*vec2(1,-1)*(i%2==0?1.:-1.);\n        }\n        k-=j*2;\n    }\n    return vec2(1);\n}\n\nvoid mainImage(out vec4 o, vec2 u){\n    vec4 r = vec4(0.);\n    float tot = 0.;\n    for(int i=0;i<6*4+1;i++){\n        vec2 m = floor(u);\n        if(i!=0)m += map(i-1);\n        float t = clamp(1.-length(m-floor(u))/(length((u-iResolution.xy/2.)/iResolution.x*8.)+2.-fract(iTime/speed)),0.,1.);\n        if(t<=0.)continue;\n        \n        float zoom = mod(floor(m.x)+floor(m.y*2.),4.);\n        float zooma = mod(floor(m.x)+floor(m.y*2.)+1.*floor(iTime/speed),4.);\n        vec2 rl = ((m-iResolution.xy/2.)*exp2(zoom)+iResolution.xy/2.);\n        if(rl == clamp(rl,vec2(0.),vec2(iResolution.xy-1.))){\n            vec2 loc = floor(rl/2.)+vec2(mod(zooma,2.),floor(zooma/2.))*floor(iResolution.xy/2.);\n            vec4 q = texelFetch(iChannel0,ivec2(loc),0);\n            if(q.w==1.){\n                if(isnan(q.x))q.xyz = vec3(.05,.1,.15);\n                else q.xyz = vec3(sin(q.x/16.+vec3(0,.3,.4)*6.28-iTime/4.-2.)/2.+.5);\n                r+=q*t;\n                tot+=t;\n            }\n            \n        }\n    }\n    o = r/tot;\n    if(tot==0.)o.w=0.;\n    else o.w=1.;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGcRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[924, 924, 940, 940, 1354]], "test": "untested"}
{"id": "slyyWc", "name": "Not Infinite Mandelbrot Zoom", "author": "Ric3cir121", "description": "This is just a regular mandelbrot zoom\n\nIf you want to go deeper check https://www.shadertoy.com/view/flGcRt", "tags": ["mandelbrot", "zoom"], "likes": 2, "viewed": 235, "published": 3, "date": "1662330298", "time_retrieved": "2024-07-30T16:32:50.637314", "image_code": "void mainImage(out vec4 o,vec2 u){\n    vec2 uv = (u-iResolution.xy/2.)/iResolution.x*8./exp2(iTime/6.);\n    uv-=vec2(.524917605448);\n    vec2 z = vec2(0);\n    float it;\n    for(it=0.;it<1000.;it++){\n        z = mat2(z,-z.y,z.x)*z+uv;\n        if(dot(z,z)>65536.)break;\n    }\n    it -= log2(log2(dot(z,z)));\n    o = vec4(sin(it/16.+vec3(0,.3,.4)*6.28-iTime/4.-2.)/2.+.5,0);\n    if(isnan(it))o.xyz = vec3(.05,.1,.15);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 416]], "test": "untested"}
{"id": "slycD3", "name": "Audio Visualizer Experiments", "author": "01000001", "description": "An experimental audio visualizer", "tags": ["audio", "visualizer"], "likes": 1, "viewed": 144, "published": 3, "date": "1662324471", "time_retrieved": "2024-07-30T16:32:51.507985", "image_code": "#define speed 5.0\n\nconst float barAmount = 0.2;//relative thickness of the bars\nconst float subdiv = 80.0;//number of bars.  \n//Try setting subdiv to 800 at barAmount to 1.  Very high resolution information is revealed\n//Bar amount 0.5 and subDiv iResolution.x/2. is cool too.\n\n// frequency sweep https://soundcloud.com/audiomix/20hz-20khz-frequency-sweep\n//set bar amount to 1.0 and subDiv to width of display\n\nconst float height = 0.5;//Maxium height of the bars relative to the screeen.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //-------------------------\n    //-- V I S U A L I Z E R --\n    //-------------------------\n    \n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 col = texture(iChannel0, vec2(floor(uv.x*subdiv)/subdiv, 0));\n    vec4 icol = texture(iChannel0, vec2(floor((1.0-uv.x)*subdiv)/subdiv, 0));\n\n\n\n    float sound = col.x * height;\n    float isound = log(icol.x * height + 1.);\n    \n    fragColor = sound > uv.y || isound > 1.0-uv.y? vec4(1):vec4(0);\n    \n    float barThickness = (1.0/subdiv)*barAmount;\n    \n    fragColor = mod(uv.x, 1.0/subdiv) > barThickness?vec4(0):fragColor;//gaps\n    \n    fragColor.xyz *= mix(vec3(0.0, 1.0, 1.0), vec3(0.6, 0.0, 0.5), abs(uv.y - 0.5)*2.0);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    //-------------------\n    //-- A R T W O R K --\n    //-------------------\n    \n    float spaceScale = 1.0 - 0.2*texture(iChannel0, vec2(0)).x;\n    uv = (fragCoord - 0.5*iResolution.xy)*spaceScale/iResolution.y*2.0;\n\n    if (length(uv) < 0.5)\n    {\n        \n        /*\n        vec3 col = vec3(1.0);\n        \n        float modSize = 0.05;\n        \n        float m = mod(length(uv), modSize);\n        \n        if (m+sin(uv.x*50.0)*0.01 < 0.02) col = vec3(0);\n        \n        \n        col *= ((m/modSize) + 0.5) / 1.7;\n        /*/\n        \n        vec3 col = vec3(0);\n        float t = .2;\n        col = (uv.x < uv.y && uv.x + t > uv.y && uv.y > -t && uv.y < t?vec3(1):col);\n        col = (uv.x > 0. && uv.x < t*0.8 && uv.y < t && uv.y > -t?vec3(1):col);\n        col = uv.x > t*0.8?vec3(0):col;\n        \n        col *= texture(iChannel1, uv*0.2).x;\n        \n        //*/\n        \n        fragColor = mix(fragColor, vec4(0.8), col.x);\n    }\n}\n\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33082, "src": "https://soundcloud.com/virtual-riot/virtual-riot-did-i-mention-i", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slycD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 492, 549, 646, 2218]], "test": "untested"}
{"id": "flGyWc", "name": "lunchbreak", "author": "nabr", "description": "you shouldn't be alone", "tags": ["sound", "minkowski", "fdn", "combfiltering"], "likes": 10, "viewed": 357, "published": 3, "date": "1662316919", "time_retrieved": "2024-07-30T16:32:52.359708", "image_code": "#define dmin(a, b)\t((a.x < b.x) ? a : b)\n#define minkowski(v, m)\tpow(dot(pow(v, v * 0. + m), v * 0. + 1.), 1. / m)\n#define char(p,C)(((p.x<0.||p.x>1.||p.y<0.||p.y>1.))?vec4(0,0,0,1e5):textureGrad(iChannel3,p/16.+fract(vec2(C,15-C/16)/16.),dFdx(p/16.),dFdy(p/16.)))\n\t\nvec2 pR(in vec2 p, float a) \n{\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n\treturn vec2(p.xy);\n}\nvec3 crt( in vec3 p )\n{\n     float r =  .5 * 6.2831 / 6.;\n     float pa = r - atan(p.x, p.y);\n           pa += mod( pa,  -2. * r );\n    return vec3(pR(p.xy, pa ), p.z);\n}\nvec2 f(vec3 p) \n{\n\tvec3 v_bb = p;\n\tv_bb.xz = pR(v_bb.xz, iTime);\n\treturn dmin(vec2(minkowski(abs(abs(crt(abs(p) - vec3(1, .1, 3. + mod(floor(2. * iTime), 3.)))) - vec3(.7 + mod(floor(iTime), 3.), 4.2, 1.3)), 1.55) - 1.25, 3.), vec2(minkowski(abs(v_bb), 3.05) - (.9 + fract(.2 * floor(iTime))), 5));\n}\n\nvec3 N(in vec3 pos) \n{\n\tconst vec3 eps = vec3(.001, 0, 0);\n\treturn normalize(vec3(f(pos + eps.xyy).x - f(pos - eps.xyy).x, f(pos + eps.yxy).x - f(pos - eps.yxy).x, f(pos + eps.yyx).x - f(pos - eps.yyx).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n\tvec2 d,\n\t     R = iResolution.xy,\n\t     st = -1. + 2. * fragCoord.xy / R, U = st;\n         U.x*=R.x/R.y;\n    float y = 0.;\n    for(int i = 0;i<10;i++){\n    y += (char(12.*vec2(U.x+1.75 , U.y+.85), int[](115,111,117, 110, 100, 32, 100, 101, 109, 111)[int(i)]).x);\n    U.x-=.0549;\n    }\n     \n    float h,aspct = max(R.x / R.y, R.y / R.x);\n\tvec3 rd, p, c,\n\t     ro = vec3(fract(iTime) , fract(iTime) , 7.),\n\t     gc = normalize( - ro),\n\t     u = normalize(cross(gc, vec3(0, 1, 0))),\n\t     v = normalize(cross(u, gc));\n\tu *= tan(1.2);\n\tv *= tan(1.2) / aspct;\n\trd = normalize(gc + st.x * u + st.y * v);\n\tp = ro;\n\tc = (1.-y)*vec3(1);\n\th = 1.;\n\td = vec2(0., 0.);\n\tfor (int i = 0; i < 32; ++i) \n    {\n\t\tp = ro + rd * h;\n\t\td = f(p);\n\t\tif (abs(d.x) < .001) \n        {\n\t\t\tfloat fr = 1e-3;\n\t\t\tvec3 n = N(p);\n\t\t\tif (d.y == 3.) \n            {\n\t\t\t\tfr = sqrt(1. - dot(-rd, n));\n\t\t\t\tc *= fr;\n\t\t\t\tro = p + n * .01;\n\t\t\t\trd = reflect(rd, n);\n\t\t\t\th = 0.;\n\t\t\t}\n\n\t\t\tif (d.y == 5.) \n            {\n\t\t\t\tfr = 1. - dot(-rd, n);\n\t\t\t\tc *= fr;\n\t\t\t\tro = p + n * .001;\n\t\t\t\trd = reflect(rd, n);\n\t\t\t\th = 0.;\n\t\t\t}\n\t\t}\n\t\th += d.x;\n\t}\n\n   fragColor = vec4(c, 1);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// phase shift and rotation experiments\n\n\n#define f fract\n#define tau\t(acos(-1.) * 2.)\n\n\n//base drum\nfloat bd(float t) \n{\n  if (t > 1.) \n  {\n    t *= 2.;\n    float o, x = 1. - f(t), k1 = 1.052502, k2 = 1.1230614;\n    x = pow(x, 8.);\n    x *= sin(60. * x);\n    o = cos(tanh(k2 * acos(x) / (k1 + x)) * 2. - 1.);\n    o *= min(1., 1e2 * f(t)) * max(0., 1. - f(t));\n    return 1. * o;\n  }\n\n  return 0.;\n}\n\n//hihat\nfloat hh(float t, float rt) \n{\n  float y = 0.;\n  y = f(f(t * 1005.3096) * t * 8000.3934);\n  y *= exp(-5. * f(t)) / (1.927 - log(y));\n  y *= min(1., 20. * f(2. * rt)) * max(0., 1. - f(2. * rt));\n  return clamp(y, -1., 1.);\n}\n\n//siren effect\nfloat fx(float t, float rt) \n{\n  #define dk(k,t,rt)((1.-exp(-k * f(t))) * exp(-k * f(rt > 12.5 || rt < 8.5 ? t : .124)))\n  float y = exp2(-vec2(1, .25)[int(1. / 7.5 * rt) % 2] * (1. - f(t)));\n  y *= sin(y * tau * 2489.6);\n  return .4 * y * dk(max(6., 4. + mod(floor(t), 15.)), y, rt);\n}\n\n//main synth\nfloat arp(float t, float rt) \n{\n  float a, y = 0., o = 0., x = 0., p[] = float[](0., 0., 0., 0., 0.);\n\n  switch (int(1. / 12. * rt) % 3) \n  {\n  case 0:\n    p = float[](54., 58., 61., 65., 54.);\n    break;\n  case 1:\n    p = float[](51., 54., 58., 61., 51.);\n    break;\n  case 2:\n    p = float[](53., 57., 60., 64., 53.);\n    break;\n  }\n\n  x = tau * t * \n  mix(.4 * 8.175799 * exp2(p[int(8. * t) % 4] / 12.), .125, vec4(5, 3.09, 2.35, 2)[int(1. / 4. * rt) % 4]);\n  \n  y = abs(.143056 - sin(.5 * x) + .7 * cos(x));\n  \n  a = .91 + sin(mod(3. * rt, 6.28));\n  o = tanh(.006069 / (.4 * sin(x) * sin(a)) + cos(a - 1.48622 * x));\n  o = cos(o * 2. - 1.);\n  \n  y *= min(1., 5. * f(8. * t)) * max(0., 1. - f(8. * t));\n  \n  return (.7 * y + .25 * o * min(1., rt / 6.)) * min(1., 50. * f(1. * t)) * max(0., 1. - f(1. * t));\n}\n\n// matrix\nvec4 mfd(inout vec4 s, const in mat4 M, in uint i) \n{\n  i = i % 4u;\n  s += (s[0] * M[i][0] + s[1] * M[(i + 1u) % 4u][1] + s[2] * M[(i + 2u) % 4u][2] + s[3] * M[(i + 3u) % 4u][3]);\n  return s;\n}\n\nvec2 mainSound(int s, float t) \n{\n  vec4 r = vec4(1e-6), y = vec4(1e-6), dt = vec4(577, 601, 641, 661) / 441e2;\n  float dlt = t, tfx = 5.076;\n\n  for (uint j = 0u; j < 2u; ++j)\n    for (uint i = 0u; i < 8u; ++i) \n    {\n    \n      y[i % 4u] = arp(dlt, t)\n                + 1.7 * fx(tfx + dlt, t) \n                + .7 * bd(dlt) \n                + .8 * hh(dlt, 4. * t);\n\n      (i % 2u == 0u) ? (r.x += y[i % 4u]) : (r.y += y[i % 4u]);//true stereo\n      (r.z += y[i % 4u]);\n      (r.w += y[i % 4u]);\n      \n      float g = .363425;\n      dt += g * mfd(dt, mat4(((i & i / 2u) == 0u) ? -1. : 1.) * 1. / sqrt(2.), i);\n      dlt += g * (dt.x + dt.y + dt.z + dt.w);\n\n    }\n\n  return.7 * (.55 * bd(t) \n            + .1 * hh(4. * t, 4. * t) \n            + .1 * fx(tfx + mod(1.001 * t, 8.), t) \n            + .2 * arp(t, t) \n            + 1. / float(16u) * mix(r.xy, r.wz, sin(t) * .5 + .5));\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGyWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 267, 297, 297, 363], [364, 364, 387, 387, 534], [535, 535, 552, 552, 835], [837, 837, 859, 859, 1045]], "test": "untested"}
{"id": "NtGyDc", "name": "reflect house", "author": "jorge2017a2", "description": "reflect house", "tags": ["reflecthouse"], "likes": 6, "viewed": 229, "published": 3, "date": "1662303987", "time_retrieved": "2024-07-30T16:32:53.262295", "image_code": "//----------image\n//por jorge2017a2-\n//reflect house----4-sep-2022\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nvec2 cuartobase(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);  \n    p.y= opRep1D(p.y, 15.5 );\n    vec3 p0=p;\n    float dcuartoGr= sdBox(p, vec3(21.0,8.0,8.0) );\n    float dcuartoCh= sdBox(p, vec3(20.0,7.0,7.0) );\n    p.y=abs(p.y)-5.0;\n    float dLinea1= sdBox(p-vec3(0.0,0.0,-8.0), vec3(22.0,0.15,0.5) );\n    float dLinea2= sdBox(p-vec3(0.0,0.5,-8.0), vec3(22.0,0.15,0.5) );\n    \n    float dfin= Difference(dcuartoGr, dcuartoCh);\n    dfin= Union(dfin, dLinea1);\n    dfin= Union(dfin, dLinea2);\n    \n    float dcuartofin=dfin;\n    \n    p=p0;\n    p.x= opRep1D(p.x, 8.0 );\n    float dventanaA= sdBox(p, vec3(3.5,3.0,8.5) );\n    \n    p.z=abs(p.z)-7.0;\n    float dMarcoA= sdBox(p, vec3(3.6,3.0,0.7) );\n    float dMarcoB= sdBox(p, vec3(3.6,3.0,0.5) );\n    \n    p=p0;\n    p.x= opRep1D(p.x, 8.0 );\n    p.y= opRep1D(p.y, 2.0 );\n    p.z=abs(p.z)-7.0;\n    float dBarroteCH= sdBox(p, vec3(3.0,0.25,1.0) );\n    p=p0;\n    p.z=abs(p.z)-7.0;\n    p.x=opRep1D(p.x, 2.0 );\n    float dBarroteCV= sdBox(p, vec3(0.25,3.5,1.0) );\n    \n    dfin= Difference(dfin, dventanaA);\n    \n    dMarcoA=Difference(dMarcoA, dBarroteCH);\n    dMarcoA=Difference(dMarcoA, dBarroteCV);\n    dMarcoB=Difference(dMarcoB,dMarcoA);\n    dMarcoB=Intersect(dcuartofin,dMarcoB);\n    res =opU2(res, vec2(dfin,16.0));\n    res =opU2(res, vec2(dMarcoB,2.0));\n    return res;\n}\n\nvec2 cuartoVidrio(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);  \n    p.y= opRep1D(p.y, 15.5 );\n    vec3 p0=p;\n    float dcuartoGr= sdBox(p, vec3(21.0,8.0,8.0) );\n    float dcuartoCh= sdBox(p, vec3(20.0,7.0,7.0) );\n    p.y=abs(p.y)-5.0;\n    float dLinea1= sdBox(p-vec3(0.0,0.0,-8.0), vec3(22.0,0.15,0.5) );\n    float dLinea2= sdBox(p-vec3(0.0,0.5,-8.0), vec3(22.0,0.15,0.5) );\n    \n    float dfin= Difference(dcuartoGr, dcuartoCh);\n    dfin= Union(dfin, dLinea1);\n    dfin= Union(dfin, dLinea2);\n    \n    float dcuartofin=dfin;\n    \n    p=p0;\n    p.x= opRep1D(p.x, 8.0 );\n    float dventanaA= sdBox(p, vec3(3.0,3.0,8.5) );\n    \n    p.z= abs(p.z)-7.5;\n    float dventanaB= sdBox(p, vec3(3.0,3.0,0.25) );\n    \n    dventanaB=Intersect(dcuartofin,dventanaB);\n    dfin= Difference(dfin, dventanaA);\n    res =opU2(res, vec2(dfin,23.0));\n    res =opU2(res, vec2(dventanaB,201.0));\n    return res;\n}\n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n     p.y=p.y+10.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    \n    res =opU2(res, vec2(planeDist1,57.0));    \n    vec2 c1= cuartobase(p);\n    p.z=p.z-50.0;\n    vec2 c2= cuartoVidrio(p);\n    res =opU2(res, c1);\n    res =opU2(res, c2);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    \n    return colOut;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    return sky;\n   \n}\n\n///iq\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.5*smoothstep(-0.05,0.06,cos(uv.x*0.4)*cos(uv.y*0.4)); \n    col *= smoothstep(-1.0,-0.95,cos(uv.x*0.8))*smoothstep(-1.0,-0.95,cos(uv.y*0.8));\n    return col;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj=vec3(0.0); \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n        \n    if (id_color==57) {return pattern( p.xz );}\n    if (id_color==58) {return pattern( p.xy );}\n    if (id_color==59) {return pattern( p.zy );}\n     return  colobj;\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 Render(vec3 ro, vec3 rd) \n{   vec3 p,colobj,col = vec3(0.0),result;\n\tvec2 t;\n    vec3 rcol=vec3(0);\n    \n    for(int i=0; i<3;i++)\n    {  vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n       if(hit.x<MAX_DIST)\n       { // geometry, hit position, normal, reflect\n\t    p =ro + rd * hit.x;\n        vec3 nor=GetNormal(p);\n\t\tvec3 ref = reflect(rd, nor);\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        \n        result= lightingv3(nor, p,light_pos1,rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd,ro,colobj,hit.x)*light_color2;\n        rcol= result/2.0;\n        rcol= (ACESFilm(rcol)+linear2srgb(rcol)+rcol+ exposureToneMapping(3.0, rcol))/4.0 ; \n             // set up the ray orgin and direction for reflection.\n\t\tro = p + nor*0.001;\n        if (int(hit.y)==201) { rd =ref; rcol-=vec3(0.25); }\n              // lighten intensity on each successive reflect.\n\t\tif(i == 0) col = rcol;\n\t\telse col = mix(rcol, col, 1.0 - exp(-0.8*float(i)));\n\t  } \n     else if(hit.x>MAX_DIST)\n    col = mix(render_sky_color(rd), col, 1.0 - exp(-0.8*float(i)));\n\t}\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t0=iTime;\n    float t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0,-50.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 120.0, -50.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(5.0,-10.0,-25.0);;\n   \n   float pt=20.0*abs(fract(t0*0.25));\n   \n   if(pt>0.0 && pt<5.0)\n       ro=vec3(0.0,-10.0,-25.0); //vista fuera edificio 1\n   if(pt>5.0 && pt<10.0)\n       ro=vec3(0.0,-10.0,0.0); //vista interior edificio 1\n   if(pt>10.0 && pt<15.0)\n       ro=vec3(0.0,-10.0,25.0); //vista edificio 2\n   if(pt>15.0 && pt<20.0)\n       ro=vec3(0.0,-10.0,15.0); //vista edificio 2 -fuera\n       \n    \n    ro= rotate_x(ro,radians(-10.*sin(t)));\n    \n\n    vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[452, 452, 484, 484, 568], [570, 570, 614, 614, 641], [642, 642, 682, 682, 709], [710, 710, 755, 755, 783], [785, 785, 821, 821, 866], [868, 868, 902, 902, 998], [999, 999, 1033, 1033, 1124], [1125, 1125, 1159, 1159, 1250], [1253, 1253, 1278, 1278, 2572], [2574, 2574, 2601, 2601, 3461], [3464, 3464, 3489, 3489, 3791], [3793, 3793, 3817, 3817, 3979], [3982, 3982, 4030, 4030, 4309], [4311, 4311, 4355, 4355, 4676], [4678, 4678, 4715, 4715, 4972], [4975, 4975, 5065, 5065, 6028], [6030, 6030, 6062, 6062, 6266], [6268, 6274, 6302, 6302, 6498], [6501, 6501, 6571, 6571, 6848], [6850, 6850, 6877, 6877, 6966], [6968, 6968, 7026, 7026, 7074], [7076, 7076, 7099, 7099, 7211], [7214, 7214, 7246, 7246, 8317], [8320, 8320, 8377, 8377, 9214]], "test": "untested"}
{"id": "ftKyDV", "name": "Infinite Soothing Balls", "author": "byt3_m3chanic", "description": "Infinite Soothing Balls - though a nice little log-polar coordinates (now mouseable!)", "tags": ["infinitesoothingballs"], "likes": 48, "viewed": 536, "published": 3, "date": "1662302695", "time_retrieved": "2024-07-30T16:32:54.157900", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Infinite Soothing Balls \n    09/04/22 @byt3_m3chanic \n    \n    Rework of a little animation though a nice little log-polar coordinates.\n    (my original shader) https://www.shadertoy.com/view/fsscWf \n*/\n\nfloat offset[3] = float[](.05,.75,2.25);\nfloat weight[3] = float[](.2,.25,.075);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec3 C = texture(iChannel0, uv).rgb;\n    vec3 R = texture(iChannel0, uv).rgb * weight[0];\n    for (int i=1; i<3; i++) {\n      R += texture(iChannel0, uv + vec2(offset[i])/iResolution.xy, .0).rgb * weight[i];\n      R += texture(iChannel0, uv - vec2(offset[i])/iResolution.xy, .0).rgb * weight[i];\n    }\n    \n    // mask for effect and mixdown \n    float mask = distance(uv.xy,vec2(.5));\n    mask = smoothstep(.52,.965,1.-mask);\n    vec3 CR = mix(R,C,mask);\n    \n    // output\n    CR=pow(CR, vec3(.4545));\n    fragColor = vec4(CR,1.);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Infinite Soothing Balls \n    09/04/22 @byt3_m3chanic \n    \n    Rework of a little animation though a nice little log-polar coordinates.\n    (my original shader) https://www.shadertoy.com/view/fsscWf \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    .0001\n#define MAX_DIST    100.\n\nfloat hash21(vec2 a){ return fract(sin(dot(a, vec2(27.609, 57.583)))*43758.5453); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat lsp(float b,float e,float t) { return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t=t-1.)*t*t+1.; }\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat box(vec2 p, vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat capp( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//global\nvec3 hp= vec3(0),hitPoint= vec3(0);\nfloat tmod=0.,ga1,ga2,ga3,ga4,ga5;\nmat2 rpi,rnp,rg1,rg2,rg3,rg4,rg1a,rg2a,rg3a,rg4a;\n\nconst float scale = 4.;\nconst float quad = scale/2.;\nconst float cell = quad/2.;\nconst float spce = cell/2.;\nconst vec2 l = vec2(scale,scale);\nconst vec2 s = l*2.;\n\nconst float density = 12.;\nconst float dshalf = density/2.;\nfloat shorten = 1.5, lpscale=0., movement=0., time=0.;\n\nvec2 map(vec3 q3) {\n    vec2 res = vec2(1e5,0.);\n\n    q3=-q3;\n    q3.y-=.5;\n    q3.xz*=rot(T*.152);\n    \n    // log-spherical map\n    float r = length(q3);\n    float mul = r/lpscale;\n    q3 = vec3(log(r), acos(q3.y / r ), atan(q3.z, q3.x));\n    q3 *= lpscale;\n    q3 -= vec3(movement,dshalf,2.);\n\n    vec2 p,\n         ip,\n         id = vec2(0),\n         ct = vec2(0);\n\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n    \n    float ld=1e5,lf=1e5,lb=1e5,bx=1e5;\n    \n    // Multi Tap distance map picked up from @Shane\n    // https://www.shadertoy.com/view/WtffDS\n    for(int i = 0; i<4; i++) {\n    \n        ct = ps4[i]/2. -  ps4[0]/2.;\t// Block center.\n        p = q3.xz - ct*s;\t\t\t\t// Local coordinates. \n        ip = floor(p/s) + .5;\t\t\t// Local tile ID. \n        p -= (ip)*s; \t\t\t\t\t// New local position.\t\t   \n        vec2 idi = (ip + ct)*s;\t\t\t// Correct position & tile ID.\n\n        vec3 q = vec3(p.x,q3.y,p.y);\n\n        vec3 q1 = vec3(p.x+cell,q3.y,p.y+cell);\n\n        q1.xz=abs(abs(q1.xz)-scale)-quad;\n \n        if(tmod<1.){\n            q1.z+=ga1*quad;\n            q1.yz*=rg2;\n        }else if(tmod<2.){\n            q1.z+=quad;\n            q1.x+=ga2*quad;\n            q1.yz*=rnp;\n            q1.yx*=rg3;\n\n        }else if(tmod<3.){\n            q1.z-=quad;\n            q1.x-=quad;\n            q1.z+=ga3*quad;\n            q1.yz*=rg2a;\n        } else {\n            q1.x+=quad;\n            q1.x-=ga4*quad;\n            q1.yx*=rpi;\n            q1.yx*=rg3a;\n        }\n\n        float s1 = length(q1)-.65;\n\n        s1=max(box(q1+vec3(spce,0,spce),vec3(.5,1,.5)),s1);\n        ld = min(ld,s1);\n\n        if(ld<res.x) {\n            res = vec2(ld,1.);\n            hp=q3-cell;\n        }\n        q.xz=abs(abs(q.xz)-quad)-cell;\n        lb = min( capp(q,.05,.75), bx); \n        lb = min( capp(q,.05,.75), lb);\n    }\n\n    if(lb<res.x) {\n        res = vec2(lb,5.);\n        hp=q3;\n    }\n        \n    float fx = q3.y+.625;\n    if(fx<res.x) {\n        res = vec2(fx,6.);\n        hp=q3;\n    }\n    \n    res.x *= mul/shorten;\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++)\n    {\n        vec2 t = map(p);\n        if(t.x<1e-8) hit = true;\n        d += i<32? t.x*.5:t.x;\n        m  = t.y;\n        p = ro + rd * d;\n        if(d>175.) break;\n    } \n    return vec2(d,m);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*4.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d) {\n        \n    vec3 RC=vec3(0);\n    vec3 p = ro;\n    float m = 0., fA = 0., f = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p, hit, 128);\n    d = ray.x;\n    m = ray.y;\n    hitPoint = hp;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(-1.5,8,-2.5);\n        vec3 l = normalize(lpos);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.0;\n        float t=.025;\n        for( int i =0; i<16; i++ ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h * .9;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 15.);\n        fresnel = mix(.0, .9, fresnel);\n\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.75 * pow(max(dot(normalize(p - ro), ret), 0.), 24.);\n\n        vec3 h = vec3(.5);\n\n        if(m==1.) {\n            vec2 id = floor(hitPoint.xz*.5);\n            h=vec3(.25);\n            if(mod(id.x+id.y,2.)<1.)h=vec3(.75);\n            ref = h*.5;\n        }\n        \n        if(m==5.) {\n            h=vec3(0.502,0.502,0.502);\n            ref = h*.25;\n        }\n\n        if(m==6.) {\n            vec2 id = floor(hitPoint.xz*.5);\n            vec2 uv = fract(hitPoint.xz*.5)-.5;\n            h=vec3(.3);\n            float fs = mod(hash21(id)*PI2,.4);\n            vec3 clr = hsv2rgb(vec3(T*.075+fs,.9,.25));\n            uv*=rot(.78);\n            float d = box(uv,vec2(.315))-.05;\n            float d1 = box(uv,vec2(.3))-.05;\n            float d2 = box(uv,vec2(.275))-.05;\n            float px = 4./R.x;\n            d1= smoothstep(px,-px,abs(d1)-.015);\n            d2= smoothstep(px,-px,abs(d2)-.035);\n            d=smoothstep(px,-px,d);\n            h=mix(h,clr,d);\n            h=mix(h,h*.5,d2);\n            h=mix(h,vec3(.9),d1);\n            ref=h;\n        }\n\n        RC = h * diff + min(spec,shdw);\n        \n        if(bnc<2) RC = mix(RC,vec3(.05), 1.-exp(-.0025*d*d*d));\n        \n        ro = p+n*.01;\n        rd = reflect(rd,n);\n        \n    } else {\n        RC = vec3(.05);\n    } \n\n    return RC;\n}\n\nconst vec3 FC = vec3(0.149,0.157,0.173);\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    tmod = mod(T*.5,4.);\n    float t1 = lsp(0.0, 1.0, tmod);\n    ga1 = eoc(t1);\n    ga1 = ga1*ga1*ga1;\n\n    float t2 = lsp(1.0, 2.0, tmod);\n    ga2 = eoc(t2);\n    ga2 = ga2*ga2*ga2;\n    \n    float t3 = lsp(2.0, 3.0, tmod);\n    ga3 = eoc(t3);\n    ga3 = ga3*ga3*ga3;\n\n    float t4 = lsp(3.0, 4.0, tmod);\n    ga4 = eoc(t4);\n    ga4 = ga4*ga4*ga4;\n    \n    rpi = rot(PI);\n    rnp = rot(-PI);\n\n    rg2 = rot(-ga1*PI);\n    rg3 = rot(ga2*PI);\n\n    rg2a = rot(-ga3*PI);\n    rg3a = rot(ga4*PI);\n\n    lpscale = floor(density)/PI;\n    movement = .55*-T*lpscale*.25;\n    \n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n\n    float zoom = 5.;\n    vec3 ro = vec3(uv*zoom,-zoom-15.);\n    vec3 rd = vec3(0.,0.,1.5);\n\n    float y = M.xy==vec2(0) || M.z<1. ? .0 : -(M.x/R.x*2.-1.)*PI;\n    mat2 rx =rot(.42);\n    mat2 ry =rot(y);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float d = 0., fA = 0.;\n    bool hit = false;\n \n    int bnc = 2;\n    for(int i = 0; i < bnc; i++){\n        RC = render(ro,rd,ref,bnc-i,d);\n        C += RC*fill;\n        fill *= ref; \n        if(i==0)fA=d;\n    }\n    \n    C = mix(C,vec3(.05), 1.-exp(-.0001*fA*fA*fA));\n    C = clamp(C,vec3(.001),vec3(.9999));\n   // C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKyDV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[384, 384, 441, 441, 1023]], "test": "untested"}
{"id": "flycWc", "name": "ZigZag Game : The Maze", "author": "Tache", "description": "I wanted to create a simple game in a single shader\nYou can create your own levels\n\nRULES :\n1) Reset the shader\n2) Click anywhere, and keep the mouse button pushed\n3) If the screen turns red, you lose\n\nOrange walls are just warnings, you can go through", "tags": ["game"], "likes": 5, "viewed": 176, "published": 3, "date": "1662302022", "time_retrieved": "2024-07-30T16:32:55.073452", "image_code": "#define PIXEL 1./iResolution.y   // Size of a pixel in UV coordinates\n#define TIME (iTime*SPEED)\n\n// GLOBAL PARAMETERS\n#define BALL 0.007     // Radius of the player in UV coordinates\n#define WALL 0.002     // Wall thickness in UV coordinates\n#define SPEED 1.       // Game speed\n#define DANGER 1.      // Time between danger appearance and wall appearance\n#define VY 0.          // Vertical level translation speed\n#define VX 0.05        // Horizontal level translation speed\n\n// COLORS\n#define backCOLOR   vec3(0.1, 0.2, 0.1)    // Background Color\n#define dangerCOLOR vec3(1.0, 0.5, 0.0)    // Danger zone Color\n#define loseCOLOR   vec3(0.9, 0.1, 0.1)    // Lose screen Color\n#define wallCOLOR   vec3(0.7, 0.7, 0.7)    // Wall Color\n#define ballCOLOR   vec3(1.0, 0.6, 0.6)    // Player Color\n\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// LEVEL\n////////////////////////////////////////////////////////////////////////////////////////////\n//   To create your own level, remove everything in this\n// section and replace the WallSDF function by your own\n// function. It has to be the distance function to the\n// walls of your level, and it can depend on time.\n////////////////////////////////////////////////////////////////////////////////////////////\n\n// PARAMETERS SPECIFIC TO THIS LEVEL\n#define GRID 0.1       // Size of a cell in in UV coordinates\n#define RATE 1.        // Wall switchings speed Rate\n#define SEED 125.      // Level seed\n\n// Functions used for WallSDF \nfloat rand(vec2 p, float time){\n    float r = fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453 + SEED + RATE*time/40.);\n    if (r>0.5){ return 1.; }\n    else      { return 0.; }\n}\nfloat diagSDF(float x, float y){\n    return min(min(\n                abs(x-y)/sqrt(2.),\n                abs(x-y-1.)/sqrt(2.)),\n                abs(x-y+1.)/sqrt(2.));\n}\n\n// The 2D SDF function of the walls at point p and time t.\nfloat WallSDF(vec2 p, float t){\n    // Before starting the maze the level\n    if (p.x<3.*GRID){\n        p.y = mod(p.y+GRID/2.,GRID)-GRID/2.;\n        float L = 3.*GRID;\n        if (p.x+p.y>L)\n            {return (p.y-p.x+L)/sqrt(2.);}\n        if (p.x-p.y>L)\n            {return (-p.y-p.x+L)/sqrt(2.);}\n        return length(p-vec2(L,0.));\n    } \n    // Inside the maze\n    float xx = floor(p.x/GRID);\n    float yy = floor(p.y/GRID);\n    float dx = mod(p.x,GRID)/GRID;\n    float dy = mod(p.y,GRID)/GRID;\n    float orientation = rand(vec2(xx,yy), t);\n    if (orientation==1.){ return GRID*diagSDF(   dx,dy); }\n    else                { return GRID*diagSDF(1.-dy,dx); }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////\n// GAME ENGINE\n////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // ENGINE\n    // Compute uv coordinates\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n    vec2 M = (iMouse.xy-0.5*iResolution.xy) / iResolution.y;\n    // Level translation\n    uv += vec2(VX,VY)*TIME;\n    M += vec2(VX,VY)*TIME;\n    // Compute the walls SDF at TIME+DANGER\n    float danger = WallSDF(uv, TIME+DANGER);\n    // Compute the walls SDF at TIME\n    float wall = WallSDF(uv, TIME);\n\n    // GRAPHICS\n    // Print the background color\n    vec3 color = backCOLOR;\n    // Print a red screen if the player touches the walls\n    if ( WallSDF(M, TIME) < WALL+BALL)\n        { color = loseCOLOR; }\n    // Print the danger zone color\n    float dangerStep = smoothstep(PIXEL+WALL,WALL,danger);\n    if (mod(fragCoord.x,2.)*mod(fragCoord.y,2.)<0.5) // Hatching effect \n        { color = mix(color, dangerCOLOR, dangerStep); }\n    // Print the walls\n    float wallStep = smoothstep(PIXEL+WALL,WALL,wall);\n    color = mix(color, wallCOLOR, wallStep);\n    // Print the ball\n    float ball = sqrt((uv.x-M.x)*(uv.x-M.x)+(uv.y-M.y)*(uv.y-M.y));\n    ball = smoothstep(BALL+PIXEL,BALL,ball);\n    color = mix(color, ballCOLOR, ball);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flycWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1495, 1526, 1557, 1557, 1710], [1711, 1711, 1743, 1743, 1878], [1880, 1939, 1970, 2012, 2606], [2811, 2811, 2866, 2910, 4043]], "test": "untested"}
{"id": "stKyR3", "name": "2D Virus Shape", "author": "W_Master", "description": "Simple 2D virus shape shader with animation and drag simulation. Designed to fit on a 1 by 1 quad with radius 1. Insert velocity with the mouse.", "tags": ["2d", "shape", "simplistic", "virus"], "likes": 6, "viewed": 208, "published": 3, "date": "1662300229", "time_retrieved": "2024-07-30T16:32:55.897249", "image_code": "// Created by Walter Jansen (2022-09-04)\n//\n//\n// Editable variables at line 45 and in defines.\n\n#define PI 3.1416\n#define TAU (PI * 2.0)\n\n#define SPOKES 9.0\n#define MAX_VEL 1.0\n#define DRAG_EFFECT 1.0\n#define SWAY_FREQUENCY 1.0\n#define SWAY_EFFECT 0.5\n#define SWAY_MAG 0.2\n\nfloat Sway(float dist, float radius, vec2 normal)\n{\n    vec2 velocity = (iMouse.xy / iResolution.xy - vec2(0.5,0.5)) * vec2(iResolution.x/iResolution.y * 2.0, 2.0);\n    float speed;\n    float offset;\n    float sign;\n    float mag;\n    speed = min(MAX_VEL, length(velocity));\n    velocity = normalize(velocity);\n    offset = max(0.0, dist - radius);\n    \n    sign = smoothstep(-0.15, 0.15, dot(normal.yx * vec2(1,-1), velocity));\n    sign = sign * 2.0 - 1.0;\n    \n    mag = (dot(normal, velocity) + 1.0) * DRAG_EFFECT;\n    mag += sin(iTime * SWAY_FREQUENCY * TAU) * 0.2 * SWAY_EFFECT;\n    mag *= speed * offset * sign;\n    \n    return (mag * SWAY_MAG);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 2.;\n    \n    // EDITABLE Vars\n    float radius = 0.42;\n    float spokeThickness = 0.05;\n    float spokeTransitionRatio = 1.1;\n    float spokeTransitionLength = 0.11;\n    float spokeRadius = 0.07;\n    vec3 colorBG    = vec3(0.12, 0.15, 0.60);\n    vec3 colorSpoke = vec3(1.00, 1.00, 1.00);\n    vec3 colorBase  = vec3(0.40, 0.20, 0.20);\n    vec3 colorEnds  = vec3(0.34, 0.34, 0.34);\n    \n    // Other\n    float spokeDist = (1.0 - spokeRadius);\n    \n    // Polar coordinates\n    float a;\n    float d;\n    a = atan(uv.y, uv.x) / (PI * 2.0) + 0.5; // Range 0.0 - 1.0\n    d = length(uv);\n    \n    // Spoke Cell\n    float c;\n    c = floor(a * SPOKES); // Range 0 - (SPOKES - 1)\n    \n    // Spoke Normal\n    float sway;\n    vec2 normal;\n    vec2 n;\n    a = ((0.5 + c) / SPOKES) * TAU;\n    normal = vec2(-cos(a), -sin(a));\n    sway = Sway(d, radius, normal);\n    n = vec2(-cos(a + sway), -sin(a + sway));\n    \n    vec2 uv2;\n    uv2.x = dot(vec2(n.y, -n.x), uv);\n    uv2.y = dot(n, uv);\n    \n    // Spoke Line\n    float line;\n    line = smoothstep(spokeThickness * 0.5 + 0.0025,spokeThickness * 0.5 - 0.0025, abs(uv2.x));\n    line = line * smoothstep(spokeDist, spokeDist - 0.01, uv2.y);\n    \n    // Circle Shape\n    float circle;\n    float rAdd;  // Transition to spokes\n    rAdd = (cos(min(max(0.0, abs(uv2.x)-spokeThickness*spokeTransitionRatio*0.5) / (spokeThickness * 1.9), 0.5) * TAU) + 1.0) * 0.5 * spokeTransitionLength;\n    circle = smoothstep((radius + rAdd), (radius + rAdd)-0.008, d);\n    \n    // Spoke Circle\n    float sCircle;\n    vec2 p;\n    sway = Sway(spokeDist, radius, normal);\n    p = vec2(-cos(a + sway), -sin(a + sway)) * spokeDist;\n    sCircle = smoothstep(spokeRadius, spokeRadius-0.008, length(uv-p));\n    \n    // Coloring\n    vec3 color;\n    color = mix(colorBG, colorSpoke, line);\n    color = mix(color, colorBase, circle);\n    color = mix(color, colorEnds, sCircle);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stKyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 275, 326, 326, 928], [930, 930, 987, 987, 3017]], "test": "untested"}
{"id": "flycD3", "name": "Dot simulation", "author": "foxes", "description": "Well, this is an interesting simulation idea that I found on youtube and decided to save in some form for myself. There are parameters of the rules in the code here, you can play with them. https://www.youtube.com/watch?v=0Kx4Y9TVMGg", "tags": ["2d", "simulation", "life", "artificial"], "likes": 9, "viewed": 280, "published": 3, "date": "1662298397", "time_retrieved": "2024-07-30T16:32:56.737004", "image_code": "#define SIZEX 300\n\nvec2 getpos(vec2 uv)\n{\n    return textureLod(iChannel0,vec2((uv+0.5)/iResolution.xy),0.0).xy;\n}\n\nfloat sqr(float x)\n{\n    return x*x*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    fragColor = vec4(0.,0.,0.,1.0);\n    for (int i=0;i<SIZEX;i++) {\n        float lr = length(getpos(vec2(i,0.))-uv);\n        fragColor.xyz += vec3(1.,0.,0.)*clamp(1.-lr*100.,0.,1.);\n        float lb = length(getpos(vec2(i,2.))-uv);\n        fragColor.xyz += vec3(0.,0.,1.)*clamp(1.-lb*100.,0.,1.);\n        float lg = length(getpos(vec2(i,4.))-uv);\n        fragColor.xyz += vec3(0.,1.,0.)*clamp(1.-lg*100.,0.,1.);\n        float lh = length(getpos(vec2(i,6.))-uv);\n        fragColor.xyz += vec3(0.4,0.4,0.4)*clamp(1.-lh*100.,0.,1.);\n    }\n\n    fragColor.xyz = clamp(fragColor.xyz,vec3(0.),vec3(1.));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define RULE_R_R -0.1\n#define RULE_R_B -0.05\n#define RULE_R_G -0.01\n#define RULE_R_H 0.01\n\n#define RULE_B_R 0.1\n#define RULE_B_B 0.05\n#define RULE_B_G 0.\n#define RULE_B_H 0.\n\n#define RULE_G_R -0.01\n#define RULE_G_B 0.\n#define RULE_G_G 0.05\n#define RULE_G_H 0.\n\n#define RULE_H_R -0.09\n#define RULE_H_B 0.\n#define RULE_H_G 0.\n#define RULE_H_H -0.01\n\n#define SIZEX 300\n//#define RANGE 0.9\n#define RANGE 0.2\n\nfloat hash1(float x){ return fract(fract(x*0.31830988618379067153776752674503)*fract(x*0.15915494309189533576888376337251)*265871.1723); }\n//float hash1( float n ) { return fract(sin(n)*753.5453123); }\nvec2 hash2( vec2 n ) { return fract(sin(n)*753.5453123); }\nvec4 hash4( vec4 n ) { return fract(sin(n)*753.5453123); }\n\nfloat sqr(float x)\n{\n    x=x*x;\n    x=x*x;\n    x=x*x;\n    return x*x;\n}\n\nvec2 getpos(vec2 uv)\n{\n    return textureLod(iChannel0,vec2((uv+0.5)/iResolution.xy),0.0).xy;\n}\n\nvec2 rule(vec2 pos,float v,float g)\n{\n    vec2 f;\n    for (int i=0;i<SIZEX;i++)\n    {\n        vec2 b = getpos(vec2(i,v));\n//        float d = length(pos-b)/RANGE;\n//        if (d>0. && d<1.) {\n//            f += vec2(pos-b)*(g*0.1/(1./sqr(1.-d)-1.));\n//        }\n        float d = length(pos-b);\n        if (d>0. && d<RANGE) {\n            f += vec2(pos-b)*(g*0.01/d);\n        }\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1./iResolution.y;\n    vec2 fc = fragCoord;\n    fc -= fract(fc);\n    vec2 pos = vec2(0.);\n    if (iFrame==0)\n    {\n        if (fract(fc.y*0.5)<0.1)\n            pos = vec2(hash1(dot(fc,vec2(1.,0.139755)))*iResolution.x*scale,hash1(dot(fc,vec2(0.54,1.2))+0.5));\n    } else {\n        pos = getpos(fc);\n        if (fract(fc.y*0.5)<0.1) {\n            vec2 vel = getpos(fc+vec2(0.,1.));\n            pos += vel;\n        } else {\n            vec2 f=vec2(0.);\n            vec2 vel = getpos(fc-vec2(0.,1.0));\n            if (fc.y==1.) {\n                f = rule(vel,0.,RULE_R_R);\n                f += rule(vel,2.,RULE_R_B);\n                f += rule(vel,4.,RULE_R_G);\n                f += rule(vel,6.,RULE_R_H);\n            }\n            if (fc.y==3.) {\n                f = rule(vel,0.,RULE_B_R);\n                f += rule(vel,2.,RULE_B_B);\n                f += rule(vel,4.,RULE_B_G);\n                f += rule(vel,6.,RULE_B_H);\n            }\n            if (fc.y==5.) {\n                f = rule(vel,0.,RULE_G_R);\n                f += rule(vel,2.,RULE_G_B);\n                f += rule(vel,4.,RULE_G_G);\n                f += rule(vel,6.,RULE_G_H);\n            }\n            if (fc.y==7.) {\n                f = rule(vel,0.,RULE_H_R);\n                f += rule(vel,2.,RULE_H_B);\n                f += rule(vel,4.,RULE_H_G);\n                f += rule(vel,6.,RULE_H_H);\n            }\n            pos = (pos+f)*0.5;\n            vel += pos;\n            if (vel.x<0. || vel.x>iResolution.x*scale) pos.x*=-1.;\n            if (vel.y<0. || vel.y>1.) pos.y*=-1.;\n        }\n    }\n    fragColor = vec4(pos,0.,0.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flycD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 41, 41, 114], [116, 116, 136, 136, 156], [158, 158, 215, 215, 855]], "test": "untested"}
{"id": "ftGcD3", "name": "Inside the mandelbulb", "author": "mrange", "description": "CC0: Inside the mandelbulb\nSimple extension of the earlier refraction shaders but it turned out mandelbulb had a bit of an interesting inside\nso shared the result\n", "tags": ["3d", "mandelbulb"], "likes": 48, "viewed": 1003, "published": 3, "date": "1662296981", "time_retrieved": "2024-07-30T16:32:57.668515", "image_code": "// CC0: Inside the mandelbulb\n//  Simple extension of the earlier refraction shaders but it turned out mandelbulb had a bit of an interesting inside\n//  so shared the result\n\n//  Mandelbulb iterations => atan, asin and pow => Poor GPU.\n\n// --\n#define LOOPS   2    // 4+ and higher to show off you expensive GPU\n#define POWER   8.0\n#define ANIMATE\n// --\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define PHI             (sqrt(5.0)*0.5 + 0.5)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.001\n#define MAX_BOUNCES     5\n\nmat3 g_rot  = mat3(1.0); \nvec3 g_mat  = vec3(0.0);\nvec3 g_beer = vec3(0.0);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.0;\n\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.6, 0.86, 1.0));\nconst vec3 glowCol    = HSV2RGB(vec3(hoff+0.065, 0.8, 6.0));\nconst vec3 diffuseCol = HSV2RGB(vec3(hoff+0.6, 0.85, 1.0));\nconst vec3 lightPos   = vec3(0.0, 10.0, 0.0);\n\nconst float initt       = 0.1; \n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: Unknown, author: EvilRyu, found: https://www.shadertoy.com/view/MdXSWn\nfloat mandelBulb(vec3 p) {\n\n  const float power = POWER;\n  vec3 z  = p;\n  vec3 dz = vec3(0.0);\n  float r, theta, phi;\n  float dr = 1.0;\n  \n  for(int i = 0; i < LOOPS; ++i) {\n    r = length(z);\n    if(r > 2.0) continue;\n    theta = atan(z.y, z.x);\n#ifdef ANIMATE\n    phi = asin(z.z / r) + TIME*0.2;\n#else\n    phi = asin(z.z / r);\n#endif\n    \n    dr = pow(r, power - 1.0) * dr * power + 1.0;\n  \n    r = pow(r, power);\n    theta = theta * power;\n    phi = phi * power;\n    \n    z = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n  }\n  return 0.5 * log(r) * r / dr;\n}\n\n\n\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = clamp(vec3(0.0025/abs(rd.y))*skyCol, 0.0, 1.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += vec3(0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nfloat df(vec3 p) {\n  p *= g_rot;\n  vec3 p1 = p;\n  const float z1 = 2.0;\n  float d1 = mandelBulb(p1/z1)*z1;\n\n  vec3 mat = vec3(0.8, 0.5, (1.-0.025));\n  const vec3 gcol = HSV2RGB(vec3(0.05, 0.95, 2.0)); \n  vec3 beer = -gcol;\n\n  float d = d1;\n  \n  \n  g_mat = mat;\n  g_beer = beer;\n  return d;\n}\n\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float dfactor, out int ii) {\n  float t = 0.0;\n  float tol = dfactor*TOLERANCE;\n  ii = MAX_RAY_MARCHES;\n  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = dfactor*df(ro + rd*t);\n    if (d < TOLERANCE) {\n      ii = i;\n      break;\n    }\n    t += d;\n  }\n  return t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  vec3 ragg = vec3(1.0);\n\n  bool isInside = df(ro) < 0.0;\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float dfactor = isInside ? -1.0 : 1.0;\n    float mragg = min(min(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.025) break;\n    int iter;\n    float st = rayMarch(ro, rd, dfactor, iter);\n    const float mrm = 1.0/float(MAX_RAY_MARCHES);\n    float ii = float(iter)*mrm;\n    vec3 mat = g_mat;\n    if (st >= MAX_RAY_LENGTH) {\n      agg += ragg*skyColor(ro, rd);\n      break; \n    }\n\n    vec3 sp = ro+rd*st;\n\n    vec3 sn = dfactor*normal(sp);\n    float fre = 1.0+dot(rd, sn);\n//    fre = clamp(abs(fre), 0.0, 1.0);\n    fre *= fre;\n    fre = mix(0.1, 1.0, fre);\n\n    vec3 ld     = normalize(lightPos - sp);\n\n    float dif   = max(dot(ld, sn), 0.0); \n    vec3 ref    = reflect(rd, sn);\n    float re    = mat.z;\n    float ire   = 1.0/re;\n    vec3 refr   = refract(rd, sn, !isInside ? re : ire);\n    vec3 rsky   = skyColor(sp, ref);\n    vec3 col = vec3(0.0);    \n    col += diffuseCol*dif*dif*(1.0-mat.x);\n    float edge = smoothstep(1.0, 0.9, fre);\n    col += rsky*mat.y*fre*vec3(1.0)*edge;\n    if (isInside) {\n      ragg *= exp(-st*g_beer);\n    }\n    agg += ragg*col;\n\n    if (refr == vec3(0.0)) {\n      rd = ref;\n    } else {\n      ragg *= mat.x;\n      isInside = !isInside;\n      rd = refr;\n    }\n\n    // TODO: if beer is active should also computer it based on initt    \n    ro = sp+initt*rd;\n  }\n\n  return agg;\n}\n\nvec3 effect(vec2 p) {\n  g_rot = rot_x(0.2*TIME)*rot_y(0.3*TIME);\n  vec3 ro = 0.6*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[910, 910, 932, 932, 1078], [1659, 1759, 1778, 1778, 1865], [1867, 1974, 2000, 2000, 2184], [2186, 2304, 2331, 2331, 2407], [2409, 2521, 2563, 2563, 2610], [2612, 2695, 2721, 2721, 3277], [3282, 3282, 3303, 3303, 3403], [3405, 3405, 3426, 3426, 3526], [3528, 3528, 3549, 3549, 3652], [3654, 3654, 3687, 3687, 4361], [4363, 4363, 4381, 4381, 4654], [4657, 4657, 4680, 4680, 4888], [4890, 4890, 4951, 4951, 5275], [5277, 5277, 5308, 5308, 6769], [6771, 6771, 6792, 6792, 7191], [7193, 7193, 7250, 7250, 7468]], "test": "untested"}
{"id": "7lGyDV", "name": "Katakana Characters", "author": "cmzw", "description": "46 Katakana characters by combining sdf line and bezier segments. The Hiragana set can be found here: [url]https://www.shadertoy.com/view/7lKyDV[/url]\n\nClick and drag to browse through every glyph / ↔ glyph, ↕ radius, hold s key for field lines", "tags": ["2d", "sdf", "bezier", "runes", "cc0", "fonts", "japanese", "katakana"], "likes": 17, "viewed": 586, "published": 3, "date": "1662267656", "time_retrieved": "2024-07-30T16:32:58.638919", "image_code": "// Katakana Glyphs - License: CC0\n\n// Hiragana https://www.shadertoy.com/view/7lKyDV\n\n#define SCALE 4.0\n#define GLYPH_SCALE 1.1\n#define RADIUS 0.06\n\n// Uncomment the following to display every glyph\n// #define DISPLAY_ALL\n\nfloat k1(vec2 uv) { // a\n\tfloat d = s(uv, vec2(0.084, -0.004), vec2(0.399, -0.195),vec2(0.26, -0.28));\n\td = min(d, s(uv, vec2(-0.278, 0.318), vec2(-0.009, 0.227),vec2(-0.021, -0.133)));\n\td = min(d, l(uv, vec2(-0.31, -0.28), vec2(0.26, -0.28)));\n\treturn d;\n}\n\nfloat k2(vec2 uv) { // i\n\tfloat d = s(uv, vec2(0.264, -0.319), vec2(0, -0.051),vec2(-0.309, 0.045));\n\treturn min(d, l(uv, vec2(0.0385, 0.3155), vec2(0.0385, -0.126)));\n}\n\nfloat k3(vec2 uv) { // u\n\tfloat d = s(uv, vec2(0.289, -0.21), vec2(0.297, 0.234),vec2(-0.117, 0.324));\n\td = min(d, l(uv, vec2(0, -0.21), vec2(0, -0.3281)));\n\td = min(d, l(uv, vec2(-0.28, -0.21), vec2(0.289, -0.21)));\n\treturn min(d, l(uv, vec2(-0.28, 0), vec2(-0.28, -0.21)));\n}\n\nfloat k4(vec2 uv) { // e\n\tfloat d = l(uv, vec2(0.28, -0.25), vec2(-0.28, -0.25));\n\td = min(d, l(uv, vec2(0, -0.25), vec2(0, 0.25)));\n\td = min(d, l(uv, vec2(0.34, 0.25), vec2(-0.34, 0.25)));\n\treturn d;\n}\n\nfloat k5(vec2 uv) { // o\n\tfloat d = s(uv, vec2(0.09, -0.19), vec2(-0.013, 0.065),vec2(-0.325, 0.228));\n\td = min(d, l(uv, vec2(0.12, -0.33), vec2(0.12, 0.33)));\n\treturn min(d, l(uv, vec2(-0.31, -0.19), vec2(0.31, -0.19)));\n}\n\nfloat k6(vec2 uv) { // ka\n\tfloat d = s(uv, vec2(-0.039, -0.334136), vec2(0.006, 0.105),vec2(-0.319, 0.302));\n\td = min(d, l(uv, vec2(-0.29, -0.19), vec2(0.28, -0.19)));\n\td = min(d, s(uv, vec2(0.246, 0.217), vec2(0.231, 0.325),vec2(0.054, 0.28)));\n\td = min(d, l(uv, vec2(0.2469, 0.2153), vec2(0.28, -0.19)));\n\treturn d;\n}\n\nfloat k7(vec2 uv) { // ki\n\tfloat d = l(uv, vec2(0.07, 0.33), vec2(-0.07, -0.33));\n\td = min(d, l(uv, vec2(0.25, -0.23), vec2(-0.31, -0.14)));\n\td = min(d, l(uv, vec2(0.31, 0), vec2(-0.33, 0.1)));\n\treturn d;\n}\n\nfloat k8(vec2 uv) { // ku\n\tfloat d = s(uv, vec2(-0.212, 0.319), vec2(0.281, 0.158),vec2(0.259, -0.21));\n\td = min(d, s(uv, vec2(-0.053, -0.328), vec2(-0.141, -0.11),vec2(-0.295, -0.023)));\n\td = min(d, l(uv, vec2(0.2565, -0.22), vec2(-0.0918, -0.2193)));\n\treturn d;\n}\n\n\nfloat k9(vec2 uv) { // ke\n\tfloat d = s(uv, vec2(-0.192, 0.319), vec2(0.136, 0.167),vec2(0.128, -0.181));\n\td = min(d, s(uv, vec2(-0.124, -0.332), vec2(-0.198, -0.131),vec2(-0.336, -0.01)));\n\td = min(d, l(uv, vec2(0.3279, -0.19), vec2(-0.19, -0.19)));\n\treturn d;\n}\n\nfloat k10(vec2 uv) { // ko\n\tfloat d = l(uv, vec2(0.25, -0.24), vec2(-0.27, -0.24));\n\td = min(d, l(uv, vec2(0.25, -0.24), vec2(0.25, 0.25)));\n\td = min(d, l(uv, vec2(-0.28, 0.25), vec2(0.25, 0.25)));\n\treturn d;\n}\n\nfloat k11(vec2 uv) { // sa\n\tfloat d = l(uv, vec2(-0.342, -0.1604), vec2(0.34, -0.16));\n\td = min(d, l(uv, vec2(-0.17, -0.33), vec2(-0.17, 0.0844)));\n\td = min(d, s(uv, vec2(0.17, -0.068), vec2(0.176, 0.287),vec2(-0.11, 0.315)));\n\td = min(d, l(uv, vec2(0.17, -0.33), vec2(0.17, -0.03)));\n\treturn d;\n}\n\nfloat k12(vec2 uv) { // shi\n\tfloat d = s(uv, vec2(-0.22, -0.306), vec2(-0.117, -0.267),vec2(-0.03, -0.204));\n\td = min(d, s(uv, vec2(0.313, -0.153), vec2(0.177, 0.267),vec2(-0.273, 0.299)));\n\td = min(d, s(uv, vec2(-0.289, -0.098), vec2(-0.154, -0.05),vec2(-0.087, 0.013)));\n\treturn d;\n}\n\nfloat k13(vec2 uv) { // su\n\tfloat d = s(uv, vec2(0.057, 0.044), vec2(0.195, 0.126),vec2(0.314, 0.286));\n\td = min(d, s(uv, vec2(0.221, -0.269), vec2(0.1, 0.14),vec2(-0.316, 0.288)));\n\td = min(d, l(uv, vec2(-0.27, -0.27), vec2(0.22, -0.27)));\n\treturn d;\n}\n\nfloat k14(vec2 uv) { // se\n\tfloat d = s(uv, vec2(0.252, -0.182), vec2(0.41, -0.176),vec2(0.119, 0.078));\n\td = min(d, s(uv, vec2(-0.137, 0.15), vec2(-0.142, 0.352),vec2(0.278, 0.269)));\n\td = min(d, l(uv, vec2(-0.1353, -0.3247), vec2(-0.1373, 0.1509)));\n\td = min(d, l(uv, vec2(-0.3301, -0.0978), vec2(0.2521, -0.1818)));\n\treturn d;\n}\n\nfloat k15(vec2 uv) { // so\n\tfloat d = s(uv, vec2(0.265, -0.28), vec2(0.257, 0.135),vec2(-0.194, 0.309));\n\td = min(d, s(uv, vec2(-0.276, -0.285), vec2(-0.199, -0.188),vec2(-0.148, -0.033)));\n\treturn d;\n}\n\nfloat k16(vec2 uv) { // ta\n\tfloat d = s(uv, vec2(-0.212, 0.319), vec2(0.281, 0.158),vec2(0.259, -0.22));\n\td = min(d, s(uv, vec2(-0.053, -0.328), vec2(-0.141, -0.11),vec2(-0.295, -0.023)));\n\td = min(d, l(uv, vec2(0.2575, -0.22), vec2(-0.1038, -0.2193)));\n\td = min(d, s(uv, vec2(-0.102, -0.058), vec2(0.028, 0.025),vec2(0.126, 0.132)));\n\treturn d;\n}\n\nfloat k17(vec2 uv) { // chi\n\tfloat d = s(uv, vec2(-0.269, -0.23), vec2(0.044, -0.237),vec2(0.265, -0.316));\n\td = min(d, l(uv, vec2(0.338, -0.04), vec2(-0.3238, -0.04)));\n\td = min(d, s(uv, vec2(-0.213, 0.324), vec2(0.044, 0.229),vec2(0.04, -0.038)));\n\td = min(d, l(uv, vec2(0.04, -0.249), vec2(0.04, -0.0363)));\n\treturn d;\n}\n\nfloat k18(vec2 uv) { // tsu\n\tfloat d = s(uv, vec2(-0.175, 0.296), vec2(0.228, 0.222),vec2(0.292, -0.271));\t\n\td = min(d, s(uv, vec2(-0.071, -0.297), vec2(0, -0.144),vec2(0.013, -0.068)));\n\td = min(d, s(uv, vec2(-0.29, -0.253), vec2(-0.222, -0.11),vec2(-0.204, -0.032)));\n\treturn d;\n}\n\nfloat k19(vec2 uv) { // te\n\tfloat d = l(uv, vec2(-0.25, -0.29), vec2(0.25, -0.29));\n\td = min(d, l(uv, vec2(-0.33, -0.0704), vec2(0.33, -0.07)));\n\td = min(d, s(uv, vec2(-0.225, 0.32), vec2(0.029, 0.261),vec2(0.03, -0.068)));\n\treturn d;\n}\n\nfloat k20(vec2 uv) { // to\n\tfloat d = s (uv, vec2(-0.159, -0.093), vec2(0.104, -0.02),vec2(0.294, 0.08));\n\treturn min(d, l(uv, vec2(-0.16, -0.3254), vec2(-0.16, 0.32)));\n}\n\nfloat k21(vec2 uv) { // na\n\tfloat d = s(uv, vec2(-0.252, 0.32), vec2(0.045, 0.253),vec2(0.039, -0.118));\n\td = min(d, l(uv, vec2(0.039, -0.1141), vec2(0.0393, -0.33)));\n\td = min(d, l(uv, vec2(-0.32, -0.12), vec2(0.33, -0.12)));\n\treturn d;\n}\n\nfloat k22(vec2 uv) { // ni\n\tfloat d = l(uv, vec2(-0.24, -0.23), vec2(0.25, -0.23));\n\td = min(d, l(uv, vec2(-0.33, 0.24), vec2(0.33, 0.24)));\n\treturn d;\n}\n\nfloat k23(vec2 uv) { // nu\n\tfloat d = s(uv, vec2(-0.268, 0.311), vec2(0.178, 0.145),vec2(0.266, -0.28));\n\td = min(d, s(uv, vec2(-0.143, -0.092), vec2(0.125, 0.079),vec2(0.253, 0.23)));\n\treturn min(d, l(uv, vec2(-0.2553, -0.28), vec2(0.2661, -0.28)));\n}\n\nfloat k24(vec2 uv) { // ne\n\tfloat d = l(uv, vec2(0, -0.2201), vec2(0, -0.35));\n\td = min(d, l(uv, vec2(0, 0.0031), vec2(0, 0.34)));\n\td = min(d, s(uv, vec2(-0.327, 0.144), vec2(0.134, -0.013),vec2(0.25, -0.219)));\n\td = min(d, s(uv, vec2(0.333, 0.161), vec2(0.125, 0.041),vec2(0, 0.005)));\n\treturn min(d, l(uv, vec2(-0.27, -0.22), vec2(0.25, -0.22)));\n}\n\nfloat k25(vec2 uv) { // no\n\treturn s(uv, vec2(-0.284, 0.284), vec2(0.19, 0.094),vec2(0.24, -0.294));\n}\n\nfloat k26(vec2 uv) { // ha\n\tuv.x = -abs(uv.x);\n\treturn s(uv, vec2(-0.329, 0.271), vec2(-0.178, 0.12946),vec2(-0.148, -0.283));\n}\n\nfloat k27(vec2 uv) { // hi\n\tfloat d = s(uv, vec2(0.269, 0.262), vec2(-0.208, 0.326),vec2(-0.21, 0.18));\n\td = min(d, s(uv, vec2(-0.212, -0.049), vec2(0.057, -0.09),vec2(0.235, -0.186)));\n\treturn min(d, l(uv, vec2(-0.2159, -0.3062), vec2(-0.21, 0.18)));\n}\n\nfloat k28(vec2 uv) { // fu\n\tfloat d = s(uv, vec2(-0.193, 0.302), vec2(0.298, 0.141),vec2(0.28, -0.27));\n\treturn min(d, l(uv, vec2(-0.28, -0.27), vec2(0.28, -0.27)));\n}\n\nfloat k29(vec2 uv) { // he\n\tfloat d = l(uv, vec2(-0.0793, -0.222), vec2(0.3384, 0.2195));\n\treturn min(d, l(uv, vec2(-0.0793, -0.222), vec2(-0.3366, 0.0766)));\n}\n\nfloat k30(vec2 uv) { // ho\n\tfloat d = l(uv, vec2(0, -0.33), vec2(0, 0.32));\n\td = min(d, l(uv, vec2(-0.33, -0.21), vec2(0.33, -0.21)));\n\tuv.x = -abs(uv.x);\n\treturn min(d, s(uv, vec2(-0.328, 0.249), vec2(-0.215, 0.059),vec2(-0.208, -0.047)));\n}\n\nfloat k31(vec2 uv) { // ma\n\tfloat d = s(uv, vec2(0.31, -0.25), vec2(0.311, -0.135),vec2(-0.024, 0.136));\n\td = min(d, s(uv, vec2(0.115, 0.314), vec2(-0.009, 0.136),vec2(-0.208, -0.047)));\n\treturn min(d, l(uv, vec2(-0.32, -0.25), vec2(0.31, -0.25)));\n}\n\nfloat k32(vec2 uv) { // mi\n\tfloat d = s(uv, vec2(-0.211, -0.303), vec2(0.055, -0.276),vec2(0.249, -0.215));\n\td = min(d, s(uv, vec2(0.219, 0.019), vec2(-0.017, -0.05),vec2(-0.228, -0.072)));\n\treturn min(d, s(uv, vec2(0.27, 0.309), vec2(-0.017, 0.211),vec2(-0.288, 0.174)));\n}\n\nfloat k33(vec2 uv) { // mu\n\tfloat d = s(uv, vec2(-0.335, 0.265), vec2(0.068, 0.262),vec2(0.287, 0.198));\n\td = min(d, s(uv, vec2(-0.244, 0.264), vec2(-0.139, 0.064),vec2(-0.021, -0.331)));\n\treturn min(d, s(uv, vec2(0.33, 0.304), vec2(0.253, 0.09),vec2(0.128, -0.094)));\n}\n\nfloat k34(vec2 uv) { // me\n\tfloat d = s(uv, vec2(-0.283, 0.293), vec2(0.069, 0.165),vec2(0.219, -0.315));\n\treturn min(d, s(uv, vec2(-0.19, -0.191), vec2(0.076, -0.021),vec2(0.258, 0.211)));\n}\n\nfloat k35(vec2 uv) { // mo\n\tfloat d = l(uv, vec2(-0.28, -0.28), vec2(0.28, -0.28));\n\td = min(d, s(uv, vec2(-0.07, 0.171), vec2(-0.077, 0.351),vec2(0.32, 0.267)));\n\td = min(d, l(uv, vec2(-0.07, -0.28), vec2(-0.07, 0.17)));\n\treturn min(d, l(uv, vec2(-0.32, -0.04), vec2(0.33, -0.04)));\n}\n\nfloat k36(vec2 uv) { // ya\n\tfloat d = l(uv, vec2(-0.1546, -0.3368), vec2(-0.0156, 0.3389));\n\td = min(d, s(uv, vec2(0.107, 0.07), vec2(0.41, -0.144),vec2(0.265, -0.222)));\n\treturn min(d,l(uv, vec2(-0.325, -0.1285), vec2(0.2631, -0.2219)));\n}\n\nfloat k37(vec2 uv) { // yu\n\tfloat d = s(uv, vec2(0.103, 0.239), vec2(0.216, -0.251),vec2(0.143, -0.248));\n\td = min(d, l(uv, vec2(-0.26, -0.25), vec2(0.1425, -0.248)));\n\treturn min(d, l(uv, vec2(-0.33, 0.24), vec2(0.34, 0.24)));\n}\n\nfloat k38(vec2 p) { // yo\n\tconst vec2 a = vec2(0);\n    const float b = 0.25;\n    float c = abs(p.y)-0.25;\n\n    float d = length(max(vec2(abs(c),p.x-b),a));\n    float d1 = min(d, length(max(vec2(abs(p.y),p.x-b),a)));\n    d = min(d, length(max(vec2(abs(p.x-b),c),a)));\n    d = length(max(vec2(d,-p.x-0.25),a));\n    d = min(d,length(max(vec2(d1,-p.x-0.22),a)));\n\treturn d;\n}\n\nfloat k39(vec2 uv) { // ra\n\tfloat d = s(uv, vec2(0.27, -0.1), vec2(0.264, 0.221),vec2(-0.159, 0.319));\n\td = min(d, l(uv, vec2(-0.3, -0.1), vec2(0.27, -0.1)));\n\treturn min(d, l(uv, vec2(-0.23, -0.3), vec2(0.23, -0.3)));\n}\n\nfloat k40(vec2 uv) { // ri\n\tfloat d = l(uv, vec2(-0.21, -0.31), vec2(-0.21, 0.06));\n\td = min(d, s(uv, vec2(0.21, -0.07), vec2(0.218, 0.254),vec2(-0.148, 0.317)));\n\treturn min(d, l(uv, vec2(0.21, -0.31), vec2(0.21, -0.07)));\n}\n\nfloat k41(vec2 uv) { // ru\n\tfloat d = s(uv, vec2(0.05, 0.237), vec2(0.109, 0.416),vec2(0.354, 0.052));\n\td = min(d, s(uv, vec2(-0.169, -0.301), vec2(-0.144, 0.2),vec2(-0.322, 0.317)));\n\treturn min(d, l(uv, vec2(0.05, -0.31), vec2(0.05, 0.2371)));\n}\n\nfloat k42(vec2 uv) { // re\n\tfloat d = s(uv, vec2(-0.21, 0.237), vec2(-0.216, 0.348),vec2(0.003, 0.26));\n\td = min(d, s(uv, vec2(0, 0.261), vec2(0.171, 0.192),vec2(0.322, -0.021)));\n\treturn min(d, l(uv, vec2(-0.21, -0.31), vec2(-0.21, 0.2371)));\n}\n\nfloat k43(vec2 uv) { // ro\n\treturn abs(sdBox(uv ,vec2(0.25,0.25)));\n}\n\nfloat k44(vec2 uv) { // wa\n\tfloat d = l(uv, vec2(-0.271, -0.28), vec2(-0.271, -0.04));\n\td = min(d, s(uv, vec2(0.28, -0.28), vec2(0.303, 0.193),vec2(-0.115, 0.313)));\n\treturn min(d, l(uv, vec2(-0.271, -0.28), vec2(0.28, -0.28)));\n}\n\nfloat k45(vec2 uv) { // wo\n\treturn min(l(uv, vec2(-0.255, -0.058), vec2(0.25, -0.058)),k28(uv));\n}\n\nfloat k46(vec2 uv) { // n\n\tfloat d = s(uv, vec2(0.313, -0.196), vec2(0.221, 0.217),vec2(-0.267, 0.279));\n\treturn min(d, s(uv, vec2(-0.078, -0.099), vec2(-0.14, -0.181),vec2(-0.273, -0.268)));\n}\n\n\nfloat katakana(vec2 p, int char, float scale)\n{\n    float d = 1.0;\n    if (char > 45) return d;\n\tchar = int(fract(float(char)/46.0)*47.0)+1;\n    \n\tfloat s = 1.0/scale;\n\tp *= s;\n \n    if (char == 1) d = k1(p);\n    if (char == 2) d = k2(p);\n    if (char == 3) d = k3(p);\n    if (char == 4) d = k4(p);\n    if (char == 5) d = k5(p);\n    if (char == 6) d = k6(p);\n    if (char == 7) d = k7(p);\n    if (char == 8) d = k8(p);\n    if (char == 9) d = k9(p);\n    if (char == 10) d = k10(p);\n    if (char == 11) d = k11(p);\n    if (char == 12) d = k12(p);\n    if (char == 13) d = k13(p);\n    if (char == 14) d = k14(p);\n    if (char == 15) d = k15(p);\n    if (char == 16) d = k16(p);\n    if (char == 17) d = k17(p);\n    if (char == 18) d = k18(p);\n    if (char == 19) d = k19(p);\n    if (char == 20) d = k20(p);\n    if (char == 21) d = k21(p);\n    if (char == 22) d = k22(p);\n    if (char == 23) d = k23(p);\n    if (char == 24) d = k24(p);\n    if (char == 25) d = k25(p);\n    if (char == 26) d = k26(p);\n    if (char == 27) d = k27(p);\n    if (char == 28) d = k28(p);\n    if (char == 29) d = k29(p);\n    if (char == 30) d = k30(p);\n    if (char == 31) d = k31(p);\n    if (char == 32) d = k32(p);\n    if (char == 33) d = k33(p);\n    if (char == 34) d = k34(p);\n    if (char == 35) d = k35(p);\n    if (char == 36) d = k36(p);\n    if (char == 37) d = k37(p);\n    if (char == 38) d = k38(p);\n    if (char == 39) d = k39(p);\n    if (char == 40) d = k40(p);\n    if (char == 41) d = k41(p);\n    if (char == 42) d = k42(p);\n    if (char == 43) d = k43(p);\n    if (char == 44) d = k44(p);\n    if (char == 45) d = k45(p);\n    if (char == 46) d = k46(p);\n\treturn d/s;\n}\n\nfloat kset(vec2 p, int char, float scale) {\n\tconst float g = 7.;\n    p = clamp(p*.5+.5,vec2(0),vec2(1));\n\n\tvec2 a = floor(p*g)/vec2(g);\n\tp = fract(p*g) - 0.5;\n\tfloat c = g*(a.x+floor(1.0/g)) + a.y*g*g;\n\treturn katakana(p,int(c),scale);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 p = vec2(1,-1)*(2.*I - iResolution.xy) / iResolution.y;\n    vec2 _p = p;\n    p.x += iTime/30.;\n    \n    vec2 s = p*SCALE;\n    \n    float id = floor(hash12(floor(s))*46.);\n    p = fract(s)-.5;\n\t\n    bool mouseDown = iMouse.z > 0.;\n    vec2 im = iMouse.xy/iResolution.xy; float r = im.y * .2 + .01;\n    \n    float d = katakana(\n            mouseDown ? _p : p,\n        int(mouseDown ? im.x * 46. : id),\n            mouseDown ? 2. : GLYPH_SCALE\n    );\n    \n    vec3 col = vec3(smoothstep(RADIUS,RADIUS-.03,\n        #ifdef DISPLAY_ALL\n            kset(_p,GLYPH_SCALE)\n        #else\n            d\n        #endif\n        ));\n  \n\tif(mouseDown)\n    {\n\t\tcol = vec3(smoothstep(r,r-.01,d));\n        \n        // iq sdf colors on key press (s)\n        if(texelFetch(iChannel0, ivec2(83, 0), 0).x > 0.)\n        {\n            d -= r;\n            d *= 2.;\n            col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n            col *= 1.0 - exp2(-25.0*abs(d));\n            col *= 0.8 + 0.2*cos(60.0*abs(d));\n            col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n        }\n    }\n    O = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// segment http://iquilezles.org/articles/distfunctions2d/\nfloat l( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// box http://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat dot2(vec2 v){return dot(v,v);}\n\n// bezier segment https://www.shadertoy.com/view/MlKcDD\nfloat s( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n    }\n    return sqrt( res );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGyDV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[223, 223, 242, 247, 480], [482, 482, 501, 506, 651], [653, 653, 672, 677, 930], [932, 932, 951, 956, 1134], [1136, 1136, 1155, 1160, 1359], [1361, 1361, 1380, 1386, 1680], [1682, 1682, 1701, 1707, 1888], [1890, 1890, 1909, 1915, 2155], [2158, 2158, 2177, 2183, 2420], [2422, 2422, 2442, 2448, 2632], [2634, 2634, 2654, 2660, 2931], [2933, 2933, 2953, 2960, 3218], [3220, 3220, 3240, 3246, 3473], [3475, 3475, 3495, 3501, 3806], [3808, 3808, 3828, 3834, 4010], [4012, 4012, 4032, 4038, 4359], [4361, 4361, 4381, 4388, 4684], [4686, 4686, 4706, 4713, 4968], [4970, 4970, 4990, 4996, 5206], [5208, 5208, 5228, 5234, 5379], [5381, 5381, 5401, 5407, 5620], [5622, 5622, 5642, 5648, 5775], [5777, 5777, 5797, 5803, 6029], [6031, 6031, 6051, 6057, 6381], [6383, 6383, 6403, 6409, 6485], [6487, 6487, 6507, 6513, 6615], [6617, 6617, 6637, 6643, 6870], [6872, 6872, 6892, 6898, 7039], [7041, 7041, 7061, 7067, 7201], [7203, 7203, 7223, 7229, 7445], [7447, 7447, 7467, 7473, 7697], [7699, 7699, 7719, 7725, 7973], [7975, 7975, 7995, 8001, 8245], [8247, 8247, 8267, 8273, 8438], [8440, 8440, 8460, 8466, 8725], [8727, 8727, 8747, 8753, 8967], [8969, 8969, 8989, 8995, 9198], [9200, 9200, 9219, 9225, 9571], [9573, 9573, 9593, 9599, 9793], [9795, 9795, 9815, 9821, 10020], [10022, 10022, 10042, 10048, 10269], [10271, 10271, 10291, 10297, 10516], [10518, 10518, 10538, 10544, 10587], [10589, 10589, 10609, 10615, 10819], [10821, 10821, 10841, 10847, 10919], [10921, 10921, 10941, 10946, 11114], [12766, 12766, 12809, 12809, 13003]], "test": "untested"}
{"id": "NtycWK", "name": "Bubble Portraits of Britney", "author": "fenix", "description": "Another experiment with particles that become larger to fill space when far apart. I wanted to try the bubble rendering method with portraiture, and realized I could stake stills from this video.\n*mouse gravity*\n*space to reset* ", "tags": ["2d", "voronoi", "simulation", "particles", "bubble", "britney"], "likes": 18, "viewed": 365, "published": 3, "date": "1662242283", "time_retrieved": "2024-07-30T16:33:00.026211", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another experiment with particles that become larger to fill space when far apart.\n//  I wanted to try the bubble rendering method with portraiture, and realized I\n//  could stake stills from this video.\n//\n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a voronoi search to help out building neighborhoods\n//  Buffer C records still images of Britney\n//  Buffer D computes a sobel filter of buffer C\n//\n// ---------------------------------------------------------------------------------------\n\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = sqrt(linePointDist2(p.pos, p.pos - p.vel, fragCoord, iResolution, closest));\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n\n    float wd =  2./(min(iResolution.x, iResolution.y));\n    fragColor.xyz = 1.0*min(fragColor.xyz, (mix(vec3(1), p.color, 1.-smoothstep(0.0, wd, abs(dist - p.size)))));\n\n    // Render neighbor lines\n#if 0\n    vec3 color = vec3(1);\n    for(int i = 0; i < 4; i++){\n        ivec4 neighbors = p.neighbors[i];\n        for (int j = 0; j < 4; ++j)\n        {\n            int cid = neighbors[j];\n            if(cid==-1 || cid >= maxParticles || cid == 0) continue;\n\n            vec2 otherPos = fxGetParticleData(cid, POS_VEL).xy;\n            otherPos.x *= iResolution.y / iResolution.x;\n\n            //if (length(otherPos - p.pos) < 0.1)\n            {\n                float distToLin = linePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution, closest);\n                fragColor.xyz += 10.*color * max(0.0, 0.0004 - sqrt(distToLin)) / (0.0004);\n            }\n        }\n    }\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    vig = pow(vig, 0.25); // change pow for modifying the extend of the  vignette\n    fragColor = vec4(vig, vig, vig, 1);\n    \n  \tvec2 p = fragCoord/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n    \n    //fragColor = texture(iChannel2, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 20000; \nconst int PARTICLE_INIT_X = 10;\nconst float PARTICLE_REPEL_SIZE = 0.03;\nconst float WALL_REPEL_SIZE = 0.01;\nconst float MOVING_WALL_MAG = 0.0;\nconst float MOVING_WALL_TIME = 3.0;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return p * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution);\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\n\nconst int NUM_WING_POINTS = 25;\nvec2 WING_POINTS[NUM_WING_POINTS] = vec2[](\n    vec2(-0.9,  0.8),\n    vec2(-0.65,  0.5),\n    vec2(-0.85,  0.45),\n    vec2(-0.55,  0.3),\n    vec2(-0.75,  0.125),\n    vec2(-0.45,  0.1),\n    vec2(-0.63,  -0.2),\n    vec2(-0.35, -0.1),\n    vec2(-0.51,  -0.45),\n    vec2(-0.25, -0.3),\n    vec2(-0.2, -0.3),\n    vec2(-0.1, -0.4),\n    vec2(-0.075, -0.6),\n    vec2(-0.175, -0.75),\n    vec2(-0.05, -0.7),\n    vec2(-0.15, -0.85),\n    vec2(-0.045, -0.8),\n    vec2(-0.05, -0.9),\n    vec2(-0.0, -0.85),\n    vec2(-0.0, 0.125),\n    vec2(-0.045, 0.0),\n    vec2(-0.125, -0.1),\n    vec2(-0.2, -0.0),\n    vec2(-0.3,  0.2),\n    vec2(-0.6,  0.6)\n);\n\nfloat sdPolygon( in vec2[NUM_WING_POINTS] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=NUM_WING_POINTS-1; i<NUM_WING_POINTS; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\nconst int NUM_HEAD_POINTS = 9;\nvec2 HEAD_POINTS[NUM_HEAD_POINTS] = vec2[](\n    vec2(-0.0, -0.2),\n    vec2(0.0, 0.3),\n    vec2(-0.1, 0.4),\n    vec2(-0.2, 0.425),\n    vec2(-0.145, 0.5),\n    vec2(-0.05, 0.7),\n    vec2(0.15, 0.75),\n    vec2(0.25, 0.55),\n    vec2(0.2, 0.35)\n);\n\nfloat sdPolygon( in vec2[NUM_HEAD_POINTS] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=NUM_HEAD_POINTS-1; i<NUM_HEAD_POINTS; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;  \n    }\n    return s*sqrt(d);\n}\n\n\nfloat sdPhoenix(in vec2 p)\n{\n#if 1\n    float minDist = sdPolygon(WING_POINTS, p);\n    minDist = min(minDist, sdPolygon(WING_POINTS, vec2(-p.x, p.y)));\n    minDist = min(minDist, sdPolygon(HEAD_POINTS, p));\n    return minDist;\n#else\n    float minDist = sdBox(p, vec2(0.05, 0.1));\n    minDist = min(minDist, sdTriangle(p, vec2(-0.9, 0.9), vec2(-0.0, -0.0), vec2(-0.5, 0.9)));\n    minDist = min(minDist, sdTriangle(p, vec2( 0.9, 0.9), vec2(-0.0, -0.0), vec2( 0.5, 0.9)));\n    return minDist;\n#endif\n}\n\nvec2 normPhoenix(in vec2 p)\n{\n    const float DELTA = 0.001;\n    return vec2(sdPhoenix(p + vec2(DELTA, 0.0)) - sdPhoenix(p - vec2(DELTA, 0.0)),\n                sdPhoenix(p + vec2(0.0, DELTA)) - sdPhoenix(p - vec2(0.0, DELTA)));\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, point.x);\n    minDist = min(minDist, resolution.x / resolution.y - point.x);\n    minDist = min(minDist, point.y);\n    minDist = min(minDist, 1.0 - point.y);\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define SIZE 5\n#define COLOR 6\n#define NUM_PARTICLE_DATA_TYPES 7\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    float size;\n    float closestDist;\n    vec3 color;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, SIZE), 0);\n    vec4 particleData6 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, COLOR), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.size = particleData5.x;\n    particle.closestDist = particleData5.y;\n    particle.color = particleData6.xyz;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case SIZE:\n        return vec4(p.size, p.closestDist, 0, 0);\n    case COLOR:\n        return vec4(p.color, 0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nconst float PI = 3.141592653589793;\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n", "buffer_a_code": "// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\nconst vec2 GRAVITY = vec2(0.0000, -0.0000);\nconst float DAMPING = 1.0;\nconst float PARTICLE_REPEL = 0.00000008;\nconst float WALL_REPEL = 0.0;\nconst float IDEAL_DENSITY = 106.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    if (id == 0) return;\n    \n    fxParticle data = fxGetParticle(id);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    \n    if (dataType >= POS_VEL)\n    {\n        if (iFrame == 0 || state.z > 0.)\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = (vec2(i / particlesPerRow, j / particlesPerRow) * 0.8 + 0.1) * vec2(iResolution.x / iResolution.y, 1.0);\n            data.vel = vec2(0);\n            data.size = 1e6;\n        }\n        else\n        {\n            vec2 force = vec2(0);\n            \n            // Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = screen2world(iMouse.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n                const float MOUSE_FIELD_SIZE = 0.7;\n                float MOUSE_FIELD_STRENGTH = 0.03 / sqrt(iFrameRate);\n                vec2 mDelta = data.pos - disturbPos;\n                float dist = length(mDelta);\n                if (dist < MOUSE_FIELD_SIZE)\n                {\n                    force -= normalize(mDelta)*(MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH;\n                }\n            }\n                        \n            // downward force near tail to keep it from becoming empty, also creates firey heart\n            float ddist = length2(data.pos - vec2(0.0, -0.3));\n            if (ddist < 0.5)\n            {\n                force += 0.00000025 * vec2(0.0, -1.0) / sqrt(ddist);\n            }\n\n            struct solverParticle\n            {\n                vec2 pos;\n                vec2 vel;\n            };\n            \n            float totalDensity = SPHKernel(0.0);\n            vec2 densityGrad = vec2(0);\n            float minDist = 1e6;\n            float minCirc = 1e6;\n\n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    vec4 otherPosVel = fxGetParticleData(cid, POS_VEL);\n                    vec4 otherSize = fxGetParticleData(cid, SIZE);\n                    \n                    \n                    vec2 deltaPos = otherPosVel.xy - data.pos;\n                    //deltaPos.x /= iResolution.y / iResolution.x;\n                    float dist = length(deltaPos) + 0.0001;\n                    //if (dist > 0.01)\n                    {\n                        minDist = min(minDist, dist*0.5);\n                        minCirc = min(minCirc, max(dist*0.5, 0.5*(dist - otherSize.x)));\n                    }\n                    float nbDensity = SPHKernel(dist);\n                    totalDensity += nbDensity;\n                    densityGrad += nbDensity * deltaPos / dist;\n                    \n                    // Apply crazy auto-stirring force\n                    vec2 dir = vec2(1.0, 1.0);\n                    if (data.pos.x < 0.0) dir *= -1.0;\n                    //data.vel -= 0.0001 * dir * vec2(deltaPos.y, -deltaPos.x) / dist;\n\n                    force -= PARTICLE_REPEL * normalize(deltaPos) / dist;// * SPHgradKernel(dist / PARTICLE_REPEL_SIZE) / dist;\n                }\n            }       \n\n            // Apply motion based on Britney image density grad\n            vec2 delta = vec2(iResolution.y*0.01, 0.0);\n            vec2 adjust = data.pos * vec2(iResolution.y / iResolution.x, 1.0);\n            vec2 grad = texture(iChannel3, adjust).xy;\n            \n            force += grad*.000000005*iResolution.y;\n            vec2 suction = data.pos - vec2(.9, 0.5);\n            \n            // Extra suction force towards the middle of the frame to counteract stirring\n            force -= suction*0.00000*iResolution.y;\n            \n            // Apply force\n            data.vel = data.vel + force;\n            data.closestDist = minDist;\n            data.size = minCirc;\n            data.color = texture(iChannel2, adjust).rgb*.75;\n            if (distance(data.color, vec3(0, 0.5, 0)) < 0.3) data.color = vec3(1);\n            else data.color.g = min(max(data.color.r, data.color.b)*.8, data.color.g);\n            //else data.color = vec3(1);\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, iTime - iTimeDelta);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n            if (distToScene < WALL_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - WALL_REPEL_SIZE);\n                data.vel -= 1.0 * distNormal * (distToScene - WALL_REPEL_SIZE);\n                float velToClip = dot(data.vel, distNormal);\n                if (velToClip > 0.0)\n                {\n                    data.vel -= 2.*distNormal * (distToSceneOld - distToScene);                    \n                }\n            }\n            \n            // Damping\n            data.vel -= data.vel * 0.15;\n\n            // Clamping\n            float maxSpeed = 1.; // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos * vec2(iResolution.y / iResolution.x, 1.0))));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(data.neighbors[0][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[1][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[2][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[3][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            //int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n            //pick random id of particle\n            int p = int(mod(h*3434534.0, float(MAX_PARTICLES)));\n            sort0(bestIds, bestDists, id, int(p), dataType, data.pos);  //sort this\n        }\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 || id >= MAX_PARTICLES ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    //if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    if (iFragCoord == ivec2(0))\n    {\n        vec4 state = texelFetch(iChannel1, iFragCoord, 0);\n        \n        if (iFrame == 0 || iResolution.xy != state.xy || keyDown(KEY_SPACE))\n        {\n            state.xy = iResolution.xy;\n            state.z = 1.;\n            state.w = 1.;\n        }\n        else\n        {\n            state.z = 0.;\n            state.w = 0.;\n        }\n        if (iFrame == 5 || ((iFrame - 50) % 300) == 0)\n        {\n            state.w = 1.;\n        }\n        \n        fragColor = state;\n        return;\n    }\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n    \n    ivec4 old   = fxGetClosest( iFragCoord );      \n\n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, screen2world(fragCoord));\n        insertion_sort( new, dis, id, dis2 );\n    }\n    \n    // Search randomly in the nearest 15x15 neighbors instead of just\n    // the next-door neighbors. Seems to allow faster particle movement\n    uint searchRange = 15u;\n    uint searchCount = 16u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, screen2world(fragCoord));\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++)\n    {\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 state = texelFetch(iChannel2, ivec2(0), 0);\n\n    if (state.w > 0.)\n        fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n}", "buffer_c_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\n\nfloat step = 5.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec4 state = texelFetch(iChannel2, ivec2(0), 0);\n    \n    if (state.w == 0.)\n    {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return;\n    }\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 delta = vec2(step/iResolution.x, step/iResolution.y);\n\n    vec2 grad = vec2(length(texture(iChannel0, uv + delta.xy)) - \n                    length(texture(iChannel0, uv - delta.xy)),\n                    length(texture(iChannel0, uv + delta.yx)) - \n                    length(texture(iChannel0, uv - delta.yx)));\n    fragColor.xy -= grad*100.;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtycWK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[739, 739, 818, 818, 1983], [1985, 1985, 2039, 2132, 2950]], "test": "untested"}
{"id": "ftKcDK", "name": "Other audio visualizer", "author": "fishy", "description": "I tried making a sort of \"averaging\" thing so that the higher frequencies didn't shake so much. Use the mouse x position to control this reactivity value.", "tags": ["audio"], "likes": 4, "viewed": 321, "published": 3, "date": "1662234869", "time_retrieved": "2024-07-30T16:33:00.979661", "image_code": "#define xScale 1.0\n#define yScale 0.4\n#define barCount 20.0\n#define barWidth 0.5\n#define barHeight 0.2\n#define clipWidth 0.9\n#define curveDepth 0.4\n#define reflectionDepth 0.25\n#define reflectionHeight 0.6\n#define yPos -0.1\n\nfloat yOffset(float x)\n{\n    return sqrt(1.0-pow(max(0.0, x), 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.0, yPos);\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    uv.x = abs(uv.x - 0.5)*3.0;\n\n    \n    float discreteX = floor(uv.x*barCount)/barCount;\n    \n    uv.y -= yOffset(abs(discreteX))*curveDepth;\n    \n    float height = texture(iChannel0, vec2(discreteX * xScale, 0.0)).x * yScale + barHeight;\n\n    \n    \n    float intensity = 1.0;\n    \n    if(barHeight - uv.y > 0.0)\n    {\n        uv.y = abs(uv.y - barHeight) + curveDepth - reflectionDepth;\n        height *= reflectionHeight;\n        intensity = pow(1.0 - uv.y, 3.0);\n    }\n    \n    fragColor = vec4(float(abs(mod(uv.x * barCount, 1.0) - 0.5) < barWidth * 0.5 && uv.y < height && uv.y > barHeight && uv.x < clipWidth)*intensity);\n    //fragColor = vec4(texture(iChannel0, uv).xxx, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//Comment this define out if you want mouse controls\n//#define reactivity 0.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    #ifdef reactivity\n    float r = reactivity;\n    #else\n    float r = iMouse.x == 0.0? 0.5 : iMouse.x/iResolution.x;\n    #endif\n\n    fragColor = vec4(mix(texture(iChannel1, uv).x, texture(iChannel0, vec2(uv.x, 0.0)).x, clamp(0.0, 1.0, (1.0-uv.x) * r)));\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29940, "src": "https://soundcloud.com/suitofbullets/flashback", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftKcDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[225, 225, 249, 249, 295], [297, 297, 354, 354, 1150]], "test": "untested"}
{"id": "NlKcWK", "name": "Refraction \"madness\"", "author": "mrange", "description": "CC0: Refraction \"madness\"\nExpandning a bit further on the previous refraction shader experimented with\ntweaking refraction.", "tags": ["3d", "raymarch", "refraction"], "likes": 25, "viewed": 394, "published": 3, "date": "1662228600", "time_retrieved": "2024-07-30T16:33:01.913165", "image_code": "// CC0: Refraction \"madness\"\n//  Expandning a bit further on the previous refraction shader experimented with\n//  tweaking refraction.\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define PHI             (sqrt(5.0)*0.5 + 0.5)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.001\n#define MAX_BOUNCES     5\n\nmat3 g_rot  = mat3(1.0); \nvec3 g_mat  = vec3(0.0);\nvec3 g_beer = vec3(0.0);\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float hoff = 0.0;\n\nconst vec3 skyCol     = HSV2RGB(vec3(hoff+0.6, 0.86, 1.0));\nconst vec3 glowCol    = HSV2RGB(vec3(hoff+0.065, 0.8, 6.0));\nconst vec3 diffuseCol = HSV2RGB(vec3(hoff+0.6, 0.85, 1.0));\nconst vec3 lightPos   = vec3(0.0, 10.0, 0.0);\n\nconst float initt       = 0.1; \n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\nfloat sphere4(vec3 p, float r) {\n  p *= p;\n  return pow(dot(p, p), 0.25)-r;\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = clamp(vec3(0.0025/abs(rd.y))*skyCol, 0.0, 1.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += vec3(0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nfloat df(vec3 p) {\n  p *= g_rot;\n  vec3 p0 = p;\n  vec3 p1 = p;\n  p1 *= g_rot;\n  float d0 = box(p0, vec3(1.5, 1.5, 1.5))-0.025;\n  float d1 = sphere4(p1, 1.0);\n  float d2 = d1 - 0.5 + initt;\n  float d3 = d1 + 0.3;\n\n  const float refraction = 0.8;\n  float d = d0;\n  d = max(d, -d1);\n  float dd = smoothstep(-0.5, 0.5, sin(-TIME+(20.0*(d2 - d0))));\n  vec3 mat = vec3(0.8, 0.5, mix(0.8, -1.2, dd));\n  vec3 beer = 1.0*vec3(0.1, 0.2, 0.05);\n  \n  if (d3 < d) {\n    d = d3;\n    mat = vec3(0.5, 0.5, 0.8);\n    beer = -glowCol;\n  }\n  \n  g_mat = mat;\n  g_beer = beer;\n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float dfactor, out int ii) {\n  float t = 0.0;\n  float tol = dfactor*TOLERANCE;\n  ii = MAX_RAY_MARCHES;\n  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = dfactor*df(ro + rd*t);\n    if (d < TOLERANCE) {\n      ii = i;\n      break;\n    }\n    t += d;\n  }\n  return t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  vec3 ragg = vec3(1.0);\n\n  bool isInside = df(ro) < 0.0;\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float dfactor = isInside ? -1.0 : 1.0;\n    float mragg = min(min(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.025) break;\n    int iter;\n    float st = rayMarch(ro, rd, dfactor, iter);\n    const float mrm = 1.0/float(MAX_RAY_MARCHES);\n    float ii = float(iter)*mrm;\n    vec3 mat = g_mat;\n    if (st >= MAX_RAY_LENGTH) {\n      agg += ragg*skyColor(ro, rd);\n      break; \n    }\n\n    vec3 sp = ro+rd*st;\n\n    vec3 sn = dfactor*normal(sp);\n    float fre = 1.0+dot(rd, sn);\n//    fre = clamp(abs(fre), 0.0, 1.0);\n    fre *= fre;\n    fre = mix(0.1, 1.0, fre);\n\n    vec3 ld     = normalize(lightPos - sp);\n\n    float dif   = max(dot(ld, sn), 0.0); \n    vec3 ref    = reflect(rd, sn);\n    float re    = mat.z;\n    float ire   = 1.0/re;\n    vec3 refr   = refract(rd, sn, !isInside ? re : ire);\n    vec3 rsky   = skyColor(sp, ref);\n    vec3 col = vec3(0.0);    \n    col += diffuseCol*dif*dif*(1.0-mat.x);\n    float edge = smoothstep(1.0, 0.9, fre);\n    col += rsky*mat.y*fre*vec3(1.0)*edge;\n    if (isInside) {\n      ragg *= exp(-st*g_beer);\n    }\n    agg += ragg*col;\n\n    if (refr == vec3(0.0)) {\n      rd = ref;\n    } else {\n      ragg *= mat.x;\n      isInside = !isInside;\n      rd = refr;\n    }\n\n    // TODO: if beer is active should also computer it based on initt    \n    ro = sp+initt*rd;\n  }\n\n  return agg;\n}\n\nvec3 effect(vec2 p) {\n  g_rot = rot_x(0.2*TIME)*rot_y(0.3*TIME);\n  vec3 ro = 0.5*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlKcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[691, 691, 713, 713, 859], [1440, 1540, 1559, 1559, 1646], [1648, 1755, 1781, 1781, 1965], [1967, 2085, 2112, 2112, 2188], [2190, 2302, 2344, 2344, 2391], [2393, 2393, 2414, 2414, 2514], [2516, 2516, 2537, 2537, 2637], [2639, 2639, 2660, 2660, 2763], [2765, 2765, 2797, 2797, 2842], [2844, 2844, 2871, 2871, 2958], [2960, 2960, 2993, 2993, 3667], [3669, 3669, 3687, 3687, 4238], [4240, 4240, 4263, 4263, 4471], [4473, 4473, 4534, 4534, 4858], [4860, 4860, 4891, 4891, 6352], [6354, 6354, 6375, 6375, 6774], [6776, 6776, 6833, 6833, 7051]], "test": "untested"}
{"id": "stGcWV", "name": "Rolling Shutter - Spi3lot", "author": "Spi3lot", "description": "Control the speed of the propeller with the mouse (x), with the center being speed 0", "tags": ["sin", "cos", "plane", "trig", "matrix", "airplane", "tangent", "tangent", "trigonometry", "aircraft", "shutter", "tan", "windmill", "rolling", "propeller"], "likes": 4, "viewed": 161, "published": 3, "date": "1662224171", "time_retrieved": "2024-07-30T16:33:02.700061", "image_code": "#define AA 4\n\n#define ROLLING_SHUTTER\n#define CENTER_RADIUS 0.125\n#define BLADE_RADIUS 0.25\n#define BLADE_THICKNESS 0.25\n#define BLADES 3.0\n#define SPEED 50.0 * (iMouse.x / iResolution.x - 0.5)\n\n\nconst float pi = 3.1415926535;\nconst float tau = pi * 2.0;\nconst float dist = CENTER_RADIUS + BLADE_RADIUS - 0.05;\n\n\nbool circle(vec2 p, vec2 center, float radius)\n{\n    return distance(p, center) <= radius;\n}\n\nfloat collides(vec2 p)\n{\n    // Center\n    bool collision = circle(p, vec2(0), CENTER_RADIUS);\n    float t = iTime;\n    \n#ifdef ROLLING_SHUTTER\n    t += p.y * 0.125;\n#endif\n\n    for (float i = 0.; i < BLADES; i++)\n    {\n        float a = i * tau / BLADES + t * SPEED;\n        vec2 cs = vec2(cos(a), sin(a));\n        mat2 m = mat2(cs.x, cs.y/BLADE_THICKNESS, -cs.y, cs.x/BLADE_THICKNESS);\n\n        // Blade\n        collision = collision || circle(m * p, vec2(dist, 0), BLADE_RADIUS);\n    }\n\n    return float(collision);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mini = min(iResolution.x, iResolution.y);\n    float c = 0.0;\n\n    // MSAA\n    for (int j = 0; j < AA; j++)\n        for (int i = 0; i < AA; i++)\n        {\n            vec2 co = floor(fragCoord);\n            vec2 offset = vec2(i, j) / float(AA);\n            vec2 uv = (2.0 * (co + offset) - iResolution.xy) / mini;\n            c += collides(uv);\n        }\n\n    c /= float(AA * AA);\n    fragColor = vec4(c);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGcWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 361, 361, 405], [407, 407, 431, 445, 927], [930, 930, 987, 987, 1404]], "test": "untested"}
{"id": "stGyDV", "name": "Dynamic Animated Wave Background", "author": "janekb04", "description": "Dynamic Animated Wave Background\nInspired by new dynamic Keynote backgrounds", "tags": ["dynamic"], "likes": 2, "viewed": 248, "published": 3, "date": "1662219506", "time_retrieved": "2024-07-30T16:33:03.599655", "image_code": "// Global speed of the animation: higher means faster; default(0.15)\n#define SPEED 0.15\n\n// You can use the 'time' variable inside of these defines\n// like e.g. #define OPACITY sin(time)\n\n// How much are background layers blured: higher gives more blur; default(0.03)\n#define BLUR_FACTOR 0.03\n// The opacity of a layer: 0.0 means transparent, 1.0 means opaque; default(0.35)\n#define OPACITY 0.35\n// Layer count: how many layers are there; default(10)\n#define LAYER_COUNT 10\n// Horizon height: higher makes peaks higher\n#define HORIZON_HEIGHT map_range(smoothstep(0.0, 0.5, abs(fract(time*0.05) - 0.5)), 0.0, 0.5, 0.2, 0.4)\n// Moves everything up or down (default 0.05)\n#define Y_OFFSET 0.05\n// Fog: the higher, the more transparent are deeper layers; default(2.5)\n#define FOG 2.5\n\n// Background color (default vec3(0.03, 0.06, 0.19)) \n#define BACKGROUND vec3(0.03, 0.06, 0.19)\n// Front Hue: the Hue of the front most layer color; default(0.45)\n#define H0 0.45\n// Middle Hue: the Hue of the middle layer color; default(0.53)\n#define H1 0.53\n// Last Hue: the Hue of the last layer color; default(0.84)\n#define H2 0.84\n// Saturation all layer colors; default(0.59)\n#define SATURATION 0.59\n// Value of all layer colors; default(1.0)\n#define VALUE 1.0\n\n// Enable MSAA; default(0)\n#define MSAA 0\n// Size of MSAA lookup area: larger gives a more antialiased output; (default 0.5)\n#define MSAA_SIZE 0.5\n// Number of MSAA samples: more gives higher quality, but slower; default(4.0)\n#define MSAA_SAMPLES 4.0\n\nfloat map_range(float val, float old_min, float old_max, float new_min, float new_max)\n{\n    return mix(new_min, new_max, (val - old_min) / (old_max - old_min));\n}\n\nfloat wave(vec2 UV, vec2 translate, vec2 scale, float time)\n{\n    return sin((UV.x + time) * scale.x + translate.x) * scale.y + translate.y;\n}\nfloat layer(vec2 UV, float depth, float time)\n{\n    float scaleX = depth * 0.25;\n    float scaleY = 0.1 / depth;\n    vec2 translate = vec2(pow(depth, 5.0) * 1.618033, (HORIZON_HEIGHT + Y_OFFSET) - HORIZON_HEIGHT / depth);\n\n    const int SIZE = 2;\n    vec2[] s = vec2[](\n        vec2(5.0 * scaleX, scaleY),\n        vec2(7.0 * scaleX, scaleY)\n    );\n\n    float r = 0.0;\n    for (int i = 0; i < SIZE; ++i) {\n        r += wave(UV, translate, s[i], time * 0.1 + time * 0.1 * float(i + 1));\n    }    \n    \n    float x = UV.y - r;\n    float f = (depth - 1.0) * BLUR_FACTOR;\n    float a = smoothstep(0.0, 1.0, clamp(-x / f + 0.5, 0.0, 1.0));\n    \n    return float(a) * OPACITY;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map(int i, int n)\n{\n    float x = float(i) / float(n);\n    return clamp(pow(x, 0.3) - 0.1, 0.0, 1.0);\n}\n\nvec3 color(float x, float time)\n{\n    float h;\n    if (x <= 0.5)\n        h = mix(H0, H1, smoothstep(0.0, 0.5, x));\n    else\n        h = mix(H1, H2, smoothstep(0.5, 1.0, x));\n    return hsv2rgb(vec3(h, SATURATION, VALUE));\n}\n\nvec3 calculate(vec2 UV, float time)\n{\n    vec3 r = BACKGROUND;\n    for (int i = LAYER_COUNT - 1; i >= 0; --i)\n    {\n        float opacity = max(layer(UV, float(i), time), 0.0);\n        opacity *= pow((1.0 - float(i) / float(LAYER_COUNT)), FOG);\n        r = opacity * color(map(i, LAYER_COUNT), time) + (1.0 - opacity) * r;\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * SPEED;\n    \n    vec2 UV = fragCoord/iResolution.xy;\n    \n#if MSAA\n    vec3 r = vec3(0.0);\n    float samples = 0.0;\n    for (float x = fragCoord.x - MSAA_SIZE; x <= fragCoord.x + MSAA_SIZE; x += 2.0 * MSAA_SIZE / MSAA_SAMPLES) {\n    for (float y = fragCoord.y - MSAA_SIZE; y <= fragCoord.y + MSAA_SIZE; y += 2.0 * MSAA_SIZE / MSAA_SAMPLES) {\n        r += calculate(vec2(x, y)/iResolution.xy, time);\n        samples += 1.0;\n    }}\n    r /= samples;\n#else\n    vec3 r = calculate(fragCoord/iResolution.xy, time);\n#endif\n    fragColor = vec4(r, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGyDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1500, 1500, 1588, 1588, 1663], [1665, 1665, 1726, 1726, 1807], [2481, 2481, 2503, 2503, 2672], [2674, 2674, 2699, 2699, 2783], [2785, 2785, 2818, 2818, 3008], [3010, 3010, 3047, 3047, 3354], [3356, 3356, 3413, 3413, 3986]], "test": "untested"}
{"id": "7lGyWw", "name": "New (92 chars)", "author": "hnh", "description": "Sadly, couldn't do more than the obvious so far.\nHas anyone tried yet?", "tags": ["fork", "short", "golf"], "likes": 0, "viewed": 205, "published": 3, "date": "1662204485", "time_retrieved": "2024-07-30T16:33:04.429437", "image_code": "// Fork of \"\" by None. https://shadertoy.com/view/-1\n// 2022-09-03 11:11:11\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    \n    \n    \n    \n    \n    O = .5 + .5*cos(iTime + (I/iResolution.xy).xyxx + vec4(0,2,4,1));\n\n\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGyWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 116, 116, 218]], "test": "untested"}
{"id": "flGcDV", "name": "random curve rotate", "author": "TomoyaAT", "description": "some random noise and rotate of the curve", "tags": ["2d", "curve"], "likes": 2, "viewed": 195, "published": 3, "date": "1662193567", "time_retrieved": "2024-07-30T16:33:05.248248", "image_code": "\nmat2 rotate2D(float r)\n{\n\treturn mat2(10.0 + cos(r) / sin(r), -sin(r) * 20.0, sin(r) * 4.0 + cos(r) / 2.0, cos(r * 10.0));\n}\n\nfloat random(float seed)\n{\n\treturn fract(sin(seed)*1e4);\n}\n\nfloat row(float x, float y, float row_idx)\n{\n\tconst float ANTIALIZE_FACTOR = 0.15;\n\t\n\tfloat rand_factor = 0.25+random(row_idx)*0.75;\n\tfloat color = step(0.2, y) * step(y, 0.8) * step(0.5, random(floor(x*rand_factor + 15.*iTime*random(rand_factor))));\n\tfloat antialiser = smoothstep(0.2, 0.2+ANTIALIZE_FACTOR, y) * smoothstep(0.8, 0.8-ANTIALIZE_FACTOR, y);\n\treturn color * antialiser;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n\tuv *= rotate2D(radians(uv.x*15.));\n\tuv.x *= 25.0;\n\tuv.y *= 35.0;\n\t\n\tfloat c = row(uv.x, fract(uv.y), floor(uv.y));\n\t\n\tfragColor = vec4(mix(vec3(.2, .6, .8), vec3(0.), 1.0-c), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 125], [127, 127, 153, 153, 185], [187, 187, 231, 231, 572], [573, 573, 630, 630, 875]], "test": "untested"}
{"id": "ftGcDV", "name": "Tring to draw some lines", "author": "TomoyaAT", "description": "The stupid way I experimented with to draw shapes and lines, I used smoothstep to modify it to make it look a little better", "tags": ["2d", "smoothstep", "shape"], "likes": 1, "viewed": 165, "published": 3, "date": "1662192448", "time_retrieved": "2024-07-30T16:33:06.232616", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    vec3 color=vec3(0.0);\n    vec3 down_color = vec3(1.000,0.970,0.851);\n\n    //red\n\t vec3 red_color=vec3(1.000,0.010,0.010);\n    float rbottom=smoothstep(-0.032,0.600,st.y);\n    float rleft=smoothstep(0.,0.00,st.x);\n    float rtop=1.0-smoothstep(0.99999,1.0,st.y);\n    float rright=1.0-smoothstep(0.1999,0.20,st.x);\n\t float red=rbottom*rleft*rtop*rright;\n    vec3 red_zone=red_color*red;\n   //yellow\n\t vec3 yellow_color=vec3(1.000,0.869,0.125);\n    float ybottom=smoothstep(0.59999,0.60,st.y);\n    float yleft=smoothstep(0.028,0.90,st.x);\n    float ytop=1.0-smoothstep(0.99,1.0,st.y);\n    float yright=1.0-smoothstep(0.99999,1.0,st.x);\n\t float yellow=ybottom*yleft*ytop*yright;\n    vec3 yellow_zone=yellow_color*yellow;\n    //blue\n\t vec3 blue_color=vec3(0.105,0.310,0.685);\n    float bbottom=smoothstep(0.0,0.000,st.y);\n    float bleft=smoothstep(0.692,0.70,st.x);\n    float btop=1.0-smoothstep(0.09999,0.636,st.y);\n    float bright=1.0-smoothstep(0.99999,1.0,st.x);\n\t float blue=bbottom*bleft*btop*bright;\n    vec3 blue_zone=blue_color*blue;\n    //line\n    vec3 line_color=vec3(0.014,0.014,0.015);\n    float lw=0.018;\n    float vline1=0.072;\n        \n    \n    vec2 v1_lb = step(vec2(vline1,0.6),vec2(st));\n    vec2 v1_rt= vec2(1.)-step(vec2(vline1+lw,1),st);\n        \n    vec2 h1_lb = step(vec2(0.2,0.1),vec2(st));\n    vec2 h1_rt= vec2(1.)-step(vec2(1,0.1+lw),st);\n    \n    vec2 h2_lb = step(vec2(0,0.8),vec2(st));\n    vec2 h2_rt=vec2(1.)-step(vec2(1,0.8+lw),st);\n    \n    vec2 h3_lb = step(vec2(0,0.6-lw),vec2(st));\n    vec2 h3_rt=vec2(1.)-step(vec2(1,0.6),st);\n    \n    float b=step(0.20,st.x)-step(0.20+lw,st.x)+step(0.70-lw,st.x)-step(0.70,st.x)+step(0.90-lw,st.x)-step(0.90,st.x);\n    float line_zone=\n        v1_lb.x*v1_lb.y*v1_rt.x*v1_rt.y\n        +h1_lb.x*h1_lb.y*h1_rt.x*h1_rt.y\n        +h2_lb.x*h2_lb.y*h2_rt.x*h2_rt.y\n        +h3_lb.x*h3_lb.y*h3_rt.x*h3_rt.y\n        +b;\n\t//mix color\n\tcolor=red_zone\n        +yellow_zone\n        +blue_zone\n        \n\n        \n        \n        ;\n    color+=(1.-yellow-red-blue)*down_color;\n    color*=(1.0-line_zone);\n    \n    //color=line_zone*vec3(1.000,0.830,0.454);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftGcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 2297]], "test": "untested"}
{"id": "NlyyDV", "name": "Trying to make a rainbowcolor", "author": "TomoyaAT", "description": "my stupid way to  achieve color mixing ,maybe i 'll find better way someday", "tags": ["2d", "colormix"], "likes": 1, "viewed": 163, "published": 3, "date": "1662192246", "time_retrieved": "2024-07-30T16:33:07.080349", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    float x=st.x;\n    float y=st.y;\n    vec3 color;\n    vec3 color1=vec3(1.792,0.053,0.104);\n        vec3 color2=vec3(1.000,0.635,0.000);\n        vec3 color3=vec3(1.792,1.719,0.000);\n        vec3 color4=vec3(0.510,1.792,0.023);\n        vec3 color5=vec3(0.005,1.792,1.324);\n        vec3 color6=vec3(0.017,0.169,1.792);\n        vec3 color7=vec3(1.398,0.000,1.792);\n\t\n    float x1=step(0.0/7.0,x)-step(1.0/7.0,x);\n    float x2=step(1.0/7.0,x)-step(2.0/7.0,x);\n    float x3=step(2.0/7.0,x)-step(3.0/7.0,x);\n    float x4=step(3.0/7.0,x)-step(4.0/7.0,x);\n    float x5=step(4.0/7.0,x)-step(5.0/7.0,x);\n    float x6=step(5.0/7.0,x)-step(6.0/7.0,x);\n    float x7=step(6.0/7.0,x)-step(7.0/7.0,x);  \n    //color=color1*(x1)+color2*x2+color3*x3+color4*x4+color5*x5+color6*x6+color7*x7;\n\tfloat rg=smoothstep(0.0,4.0/7.0,x);\n    float gb=smoothstep(3.0/7.0,6.0/7.0,x);\n    float br=smoothstep(5.0/7.0,1.0,x);\n    vec3 color_rg=mix(color1,color4,rg);\n    vec3 color_gb=mix(color4,color6,gb);\n    vec3 color_br=mix(color6,color7,br);\n    vec3 color_rggb=mix(color_rg,color_gb,smoothstep(rg,gb,x));\n    vec3 color_gbbr=mix(color_gb,color_br,smoothstep(gb,br,x));\n    vec3 color_rgb=mix(color_rggb,color_gbbr,smoothstep(smoothstep(rg,gb,x),smoothstep(gb,br,x),x));\n    fragColor = vec4(color_rgb,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlyyDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1383]], "test": "untested"}
{"id": "NtGyDK", "name": "Fractal mosaic 10 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 5, "viewed": 351, "published": 3, "date": "1662177901", "time_retrieved": "2024-07-30T16:33:07.830344", "image_code": "vec2 f1(vec2 a){\n    return\n        fract(a)\n        //fract(a-floor(a.x-1.5)/2.)\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    //a += .5;\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        //vec2(2.5,-1.)\n        //vec2(1.5,0.)\n        \n    ,\n    \n    a1 = a+a2;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    //a1 += (distance(floor(a1),round(a1)))*1.5;\n\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n        //sqrt(abs(f1((a1)*(a2.x+a2.y))-.5))\n        //min(abs(fract((a1)*(a2.x+a2.y))-.75),abs(fract((a1+.5)*(a2.x+a2.y))-.5))\n    ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.;\n    vec2 u = (fragCoord)/iResolution.y/t1/2.0;\n    u += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    u = u.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    bool t3 = false;\n    float c1 = 0.;\n    vec2 uv1 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n        //u += floor(vec2(u.x,u.y+.5)*2./1.5)/2.;\n\n        \n        //u.y += .5;\n        //u.y += pow(floor(u.x*1.5+.5),6.)*1.5;\n\n        //a really interesting pattern:\n        //u += floor(u/1.5)/1.5;\n        \n         //u.y += fmod(u.y,1.5); //lace pattern\n\n        //u.x += fmod(u.x*5.,5.);\n        //u.y += fmod(u.y*2.,4.); //lace pattern\n        t3 =\n            u.x < u.y\n            //u.x < u.y || !t3\n            //u.x < u.y && t2.x > t2.y || !t3\n        ;\n        \n       //another awesome pattern (looks better zoomed out)\n       //if(t3){ u = u.yx;t2 = -t2.yx;}\n        u =\n            abs(.5+u+t2)+uv1\n            //abs(.5*sign(u.x-u.y)+u+t2)\n        ;\n        //u *= sign(u.yx-u);\n        \n        //Arabesque pattern\n        //if(u.y>u.x) u = u.yx;\n        \n        t2 =\n            -triangle_wave(u-.5)\n            //-triangle_wave(u-.5)*float(t3)\n            //-triangle_wave(u-.5*sign(u.x-u.y))\n            //-triangle_wave(u-.5)/(.5+fmod(t2.x,2.))\n\n            //-triangle_wave(u-.5-fmod(t2.x/1.5,2.))\n        ;\n        \n        //u += floor(u.y-u.x);\n        \n        u =\n            t2-triangle_wave(u.yx)\n            //t2*length(u)-triangle_wave(u.yx)\n        ;\n        c1 =\n            //abs(col.x-u.x+u.y)\n            u.x-u.y\n            //max(c1,u.x-u.y)\n            //abs(u.x-u.y)\n        ;\n        \n        //u = fract(u);\n        col = col.yzx;\n        //col *= col +.5;\n        //if(!t3 || u.y < u.x) col = max(col.yzx,vec3(col.yz,c1));\n        if(t3 || u.y > u.x) col =\n            max(abs(col-vec3(col.zy,u.x-u.y)/3.),vec3(col.yz,u.x-u.y))\n            //max(abs(col/3.-vec3(col.zy,u.x-u.y)),vec3(col.yz,u.x-u.y))\n            //max(col,vec3(col.yz,c1))\n            //vec3(col.yz,c1)\n        ;\n        //if(t2.x<t2.y||t2.x>t2.y) {u=u.yx;t2=t2.yx;}\n        //if(t3 && u.y < u.x) col = vec3(col.yz,c1);\n        //if(t2.x>t2.y) {u=-u.yx;t2=-t2.yx;}\n        //uv1 += 2.5;\n\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "#define smod(x,y) floor(mod(floor(x)*floor(x),y))\n#define sqmod(x,y) floor(mod(floor(x)*floor(x),y*y)/y)\n#define fmod1(x,y) floor(mod(floor(x+floor((x)/y)),y*y)/y)\n#define fmod2(x,y) mod(floor(x-floor((x)/y)),y)\n#define fmod3(x,y) mod(floor(x)*floor((x)/y),y)\n#define fmod4(x,y) floor(pow(mod(floor(x),y),2.)/y)\n#define fmod5(x,y) floor(pow(mod((x),y),2.)/y)\n#define fmod6(x,y) floor(sqrt(mod((x)*4.,y*y)))\n#define fmod7(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n\nfloat fmod(float a, float b){\n    //divide by powers of 2 to get interesting rhythms\n    float a1 = floor(a);\n    //a /= 1. + mod(floor(a1/32.),2.);\n    //a /= 1. + mod(floor(a1/16.),2.);\n    //a /= 1. + mod(floor(a1/8.),2.);\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(mod(floor(a/2.+8.),floor(a/8.+8.)),b)\n        //mod(floor(floor(a)*sign(.5-mod(floor(a/b),2.))),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n//#define fmod(x,y) mod(floor(floor(x)+floor((x)/4.)/4./4.),y)\n\n//multiply by prime numbers to get an interesting rhythm\n//#define fmod(a,b) mod(floor((a)/2.)*11.+floor((a)/4.)*7.,b)\n\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fpow(x,y) pow(y,fmod(x,y))\n#define floor1(x) floor(x)*floor(mod((x)/4.,2.))\n\n#define powmod(x,y) mod(floor(pow(y,mod(floor(x)/y,y))),y)\n#define powmod1(x,y) mod(floor(x+powmod(x+y,y)),y)\n\n\nint gcd (int a, int b) {    // Euclid algorithm:   gcd(a,b) = gcd(b, a%b) ; gcd(a,0) = a\n    int c;             \n    while ( b>0 && (c = a%b) != a ) a=b, b=c; \n    return b==0 ? a : c;\n}\n\nfloat gcd(float a, float b){\n   return float(gcd(int(a),int(b)));\n}\n\nvec2 mainSound(int samp, float time){\n  time += floor(time*pow(2.,fmod(time/2.,4.)));\n  float tempo = 1.;\n  time /= tempo;\n  //time = (time + pow(2.,fmod(time*2.,3.)));\n  \n  //time = mod(time,4.)+mod(floor(time/2./4.),4.)*4.;\n  \n  //time = time*(1. + fmod(time*4.,2.))/2.;\n  \n  //for(int i = 0; i < 2; i++){ time +=  fmod(floor(time*4.),2.); }\n  float limit = 8.;\n  //for(int i = 0; i < 4; i++){time += gcd(fmod(time*4.,limit),limit);}\n\n  //time += floor(time*2.)/2.;\n  float s1 = 4.,\n  t=\n      time\n      //time - fmod(time,5.+fmod(time*s1,7.))\n      //time + floor(time*s1+floor(time/s1))/s1\n      //time + floor(time*s1)*s1\n      //time/(1.+fmod(time*s1,2.))/(1.+fmod(time/s1,2.))\n      //time/(1.+fmod(time/s1,2.))\n  ,\n  f1=floor(t/4.),\n  m1 =\n      fmod(f1,4.)\n      //fmax(f1,floor(t*4.),4.)\n      //pow(fmod(floor(t/4.),4.),2.)\n      //fmod(floor(t/4.)*floor(t),4.)\n      //fmod(t/4.+floor(t*4.),4.)\n  ,\n  \n  m3 =\n      fmod((t*s1/abs(2.5-m1)),s1)\n      //pow(fmod((t*s1/abs(2.5-m1)),s1),2.)\n      //fmod((floor(t)*(floor(t*s1)+floor(t))/abs(2.5-m1)),s1)\n      //fmod(t/s1+floor(t/s1),s1);\n  ;\n  \n  //t *= (1.+fmod(t/4.,2.))/(1.+fmod(t/8.,2.)); //varying tempo;\n  //t += floor(t*s1+floor(t/s1))/s1;\n  //t += m1+m3;\n  t *=\n      s1*s1\n      //s1*s1*(1.+fmod(floor(t*s1*2.)/s1,2.))/(1.+fmod(floor(t*s1/2.)/s1,2.))\n  ;\n  \n  //t /= (1.+fmod(t/4.,2.))/(1.+fmod(t/8.,2.)); //varying tempo;\n\n  float m2 =\n      1. + fmod((t/s1),s1)\n      //1. + fmod((t/s1-fpow(t/s1,s1)),s1)\n      //1. + fmod((t/s1),s1-fmod(-t,s1))-fmod(-t,s1)\n      //1. + fmod((t/s1)+mod(t/s1,s1/2.),s1)\n      //1. + fmod((t/(s1+m3*s1)),s1)\n  ;\n\n  t /=\n      max(m2,m1+1.)\n      //max(min(m2,m3),m1)\n  ;\n  \n  float a=\n      //pow(fract(-t/s1),2.)\n      64.*((1.-sqrt(fract(t/s1)))/s1)*.2\n      //pow((1.-sqrt(fract(t/s1)))/2.,2.)\n\n      //sqrt((1.-sqrt(fract(t/s1)))/5.)*.2\n  ,\n  \n  nb = pow(2.,(m3+m2)/6.+7.)*tempo;\n\n  return\n      abs(.5-vec2(fract(time*nb*.998*2.),fract(time*nb)))*a\n      //vec2(fract(time*nb*.998/m2)*a,fract(time*nb/m2)*a)\n  ;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtGyDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 89], [91, 91, 118, 133, 663], [665, 665, 722, 722, 3036]], "test": "untested"}
{"id": "7tGcRm", "name": "Bubble Square Dance", "author": "fenix", "description": "It's the Kaplan Five-Color Hinged Squares, but rendered using ten thousand circles (really capsules), which are being stirred around by the colors. Why? I don't know, I wondered if it would look cool, and I think it did!\n*mouse gravity*\n*space to reset* ", "tags": ["2d", "voronoi", "simulation", "particles"], "likes": 17, "viewed": 352, "published": 3, "date": "1662167744", "time_retrieved": "2024-07-30T16:33:08.767837", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  I wanted to experiment with particles that automatically increase in size when far\n//  apart from other particles. Little did I know how many bugs I would find in my\n//  neighbor calculations! So hopefully future shaders will benefit from those fixes also.\n// \n//  The coloration and movement are controlled by the incorporation of my recent shaders:\n//      * Kaplan Hinged Squares https://www.shadertoy.com/view/NtGcDm\n//      * Kaplan Five Color Squares https://www.shadertoy.com/view/slGyzy\n//\n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a voronoi search to help out building neighborhoods\n//\n// ---------------------------------------------------------------------------------------\n\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = sqrt(linePointDist2(p.pos, p.pos - p.vel, fragCoord, iResolution, closest));\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n\n    float wd =  2./(min(iResolution.x, iResolution.y));\n    fragColor.xyz = 1.0*max(fragColor.xyz, (1.-smoothstep(0.0, wd, abs(dist - p.size)))*p.color);\n\n    // Render neighbor lines\n#if 0\n    vec3 color = vec3(1);\n    for(int i = 0; i < 4; i++){\n        ivec4 neighbors = p.neighbors[i];\n        for (int j = 0; j < 4; ++j)\n        {\n            int cid = neighbors[j];\n            if(cid==-1 || cid >= maxParticles || cid == 0) continue;\n\n            vec2 otherPos = fxGetParticleData(cid, POS_VEL).xy;\n            otherPos.x *= iResolution.y / iResolution.x;\n\n            //if (length(otherPos - p.pos) < 0.1)\n            {\n                float distToLin = linePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution, closest);\n                fragColor.xyz += 10.*color * max(0.0, 0.0004 - sqrt(distToLin)) / (0.0004);\n            }\n        }\n    }\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    fragColor = vec4(0);\n  \tvec2 p = fragCoord/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n    \n    fragColor.xyz = sqrt(fragColor.xyz);\n    fragColor.w = 1.;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 10000; \nconst int PARTICLE_INIT_X = 10;\nconst float PARTICLE_REPEL_SIZE = 0.03;\nconst float WALL_REPEL_SIZE = 0.01;\nconst float MOVING_WALL_MAG = 0.0;\nconst float MOVING_WALL_TIME = 3.0;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return p * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution);\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, point.x);\n    minDist = min(minDist, resolution.x / resolution.y - point.x);\n    minDist = min(minDist, point.y);\n    minDist = min(minDist, 1.0 - point.y);\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define SIZE 5\n#define COLOR 6\n#define NUM_PARTICLE_DATA_TYPES 7\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    float size;\n    float closestDist;\n    vec3 color;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, SIZE), 0);\n    vec4 particleData6 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, COLOR), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.size = particleData5.x;\n    particle.closestDist = particleData5.y;\n    particle.color = particleData6.xyz;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case SIZE:\n        return vec4(p.size, p.closestDist, 0, 0);\n    case COLOR:\n        return vec4(p.color, 0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nconst float PI = 3.141592653589793;\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n#define r(a) mat2(cos(vec4(0,11,33,0)+ a))\n\nfloat kaplanHingedSquares( vec2 u, float time, vec2 res )\n{\n    vec2 R = res;\n    u = 2.0 * u/R.y - vec2(R.x/R.y, 1.);\n    \n    float c, i, a = modf(time * .5, i) * .78; // PI / 4\n    \n    u += vec2(-.1 - sin(a * 4.) * .04, .1) + sin(a + a) * .1;\n    u *= r(-a);\n    \n    c = abs(sin(a + a)) / 12.5 + .2;\n    \n    u = mod(u, c+c);\n    \n    a = u.x > c ^^ u.y > c ? -a : a;\n    \n    u = mod(u, c);\n    \n    vec2 d = abs(r(-a) * (u - c*.5)) - .1;\n    \n    return clamp(max(0., abs(length(max(d,0.)) + min(max(d.x,d.y),0.)) - .004) * R.y * .5, 0., 1.);\n}\n\n\n#define C(i) vec4[](vec4(1, .6, .2, 1),vec4(.6, .2, .7,1),vec4(.9, .2, .2, 1),vec4(.3, .6, .1, 1),vec4(0, .6, .5, 1))[(i) % 5]\n\nvec3 kaplanFiveColoredSquares( vec2 u, float time, vec2 res )\n{\n    vec4 O;\n    vec2 R = 1./res;\n    float i, a = modf(time * .5, i) * .78; // .78 = PI / 4\n          \n    u = (2./R.xy - 4.*u) * R.y * (mod(i, 2.) - .5) + vec2(sin(a * 4.) * .04 + .1, -.1) - sin(a + a) * .1;\n        \n    mat2 M = mat2(cos(vec4(0,11,33,0) - a));\n    u *= M;\n    \n    float c = abs(sin(a + a)) * .08 + .2,\n          m = cos(a)*.2,\n          n = sin(a)*.2;\n    \n    vec2 D = mod(u / (c+c), 5.),\n         q = u = mod(u, c+c),\n         b = mod(u, c) - c * .5;\n\n    O = mix(\n        ((q.y < m || q.y > c+c - m) && (q.x < n || q.x > c+c - n)) ?\n            C(int(D.y + 3.5) + int(D.x + 2.5) * 3) :\n        (q.y - c > -m && q.y - c < m && q.x - c > -n && q.x - c < n) ?\n            C((int(7. - D.y) * 2 + int(5. - D.x) + 2) * 2) :\n        (q.x - c > -m && q.x - c < m) && (q.y < n || q.y > c+c - n) ?\n            C(int(D.y + 2.5) + int(D.x + 2.) * 3) :\n        ((q.x < m || q.x > c+c - m) && (q.y - c > -n && q.y - c < n)) ?\n            C((int(8. - D.y) * 2 + int(7.5 - D.x)) * 2) : C(1),\n            \n        C(int(mod(D.x*-2., 5.)) + 3 * int(mod(D.y+D.y, 5.)) + 1),\n               smoothstep(-R.y, R.y,\n               -length(max(q = abs(u.x > c ^^ u.y > c ? b * M : M * b) - .1,0.)) - min(max(q.x,q.y),0.)));\n\n    return clamp(O.xyz * O.xyz, 0., 1.);\n}\n\n", "buffer_a_code": "// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\nconst vec2 GRAVITY = vec2(0.0000, -0.0000);\nconst float DAMPING = 1.0;\nconst float PARTICLE_REPEL = 0.000001;\nconst float WALL_REPEL = 0.0;\nconst float IDEAL_DENSITY = 106.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    if (id == 0) return;\n    \n    fxParticle data = fxGetParticle(id);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    \n    if (dataType >= POS_VEL)\n    {\n        if (iFrame == 0 || keyDown(32) || state.z > 0.)\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = (vec2(i / particlesPerRow, j / particlesPerRow) * 0.8 + 0.1) * vec2(iResolution.x / iResolution.y, 1.0);\n            data.vel = vec2(0);\n            data.size = 1e6;\n        }\n        else\n        {\n            vec2 force = vec2(0);\n            \n            // Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = screen2world(iMouse.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n                const float MOUSE_FIELD_SIZE = 0.7;\n                float MOUSE_FIELD_STRENGTH = 0.03 / sqrt(iFrameRate);\n                vec2 mDelta = data.pos - disturbPos;\n                float dist = length(mDelta);\n                if (dist < MOUSE_FIELD_SIZE)\n                {\n                    force -= normalize(mDelta)*(MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH;\n                }\n            }\n                        \n            float totalDensity = SPHKernel(0.0);\n            vec2 densityGrad = vec2(0);\n            float minDist = 1e6;\n            float minCirc = 1e6;\n\n            // Compute neighborhood density and density gradient\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    vec4 otherPosVel = fxGetParticleData(cid, POS_VEL);\n                    vec4 otherSize = fxGetParticleData(cid, SIZE);\n                    \n                    \n                    vec2 deltaPos = otherPosVel.xy - data.pos;\n                    //deltaPos.x /= iResolution.y / iResolution.x;\n                    float dist = length(deltaPos) + 0.0001;\n                    //if (dist > 0.01)\n                    {\n                        minDist = min(minDist, dist*0.5);\n                        minCirc = min(minCirc, max(dist*0.5, 0.5*(dist - otherSize.x)));\n                    }\n                    float nbDensity = SPHKernel(dist);\n                    totalDensity += nbDensity;\n                    densityGrad += nbDensity * deltaPos / dist;\n                    \n                    // Apply crazy auto-stirring force\n                    vec2 dir = vec2(1.0, 1.0);\n                    if (data.pos.x < 0.0) dir *= -1.0;\n                    data.vel -= 0.0001 * dir * vec2(deltaPos.y, -deltaPos.x) / dist;\n\n                    force -= PARTICLE_REPEL * normalize(deltaPos) / dist;// * SPHgradKernel(dist / PARTICLE_REPEL_SIZE) / dist;\n                }\n            }       \n\n            // Apply motion based on b&w hinged square pattern\n            vec2 delta = vec2(iResolution.y*0.01, 0.0);\n            vec2 adjust = data.pos * vec2(iResolution.y / iResolution.x, 1.0) * iResolution.xy;\n            vec2 grad = vec2(kaplanHingedSquares(adjust + delta.xy, iTime, iResolution.xy) -\n                kaplanHingedSquares(adjust - delta.xy, iTime, iResolution.xy),\n                kaplanHingedSquares(adjust + delta.yx, iTime, iResolution.xy) -\n                kaplanHingedSquares(adjust - delta.yx, iTime, iResolution.xy));\n            \n            force += grad*.000002*iResolution.y;\n            vec2 suction = data.pos - vec2(.9, 0.5);\n            \n            // Extra suction force towards the middle of the frame to counteract stirring\n            force -= suction*0.000001*iResolution.y;\n            \n            // Apply force\n            data.vel = data.vel + force;\n            data.closestDist = minDist;\n            data.size = minCirc;\n            data.color = kaplanFiveColoredSquares(adjust, iTime, iResolution.xy);\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, iTime - iTimeDelta);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n            if (distToScene < WALL_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - WALL_REPEL_SIZE);\n                data.vel -= 1.0 * distNormal * (distToScene - WALL_REPEL_SIZE);\n                float velToClip = dot(data.vel, distNormal);\n                if (velToClip > 0.0)\n                {\n                    data.vel -= 2.*distNormal * (distToSceneOld - distToScene);                    \n                }\n            }\n            \n            // Damping\n            data.vel -= data.vel * 0.5;\n\n            // Clamping\n            float maxSpeed = 1.; // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos * vec2(iResolution.y / iResolution.x, 1.0))));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(data.neighbors[0][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[1][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[2][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(data.neighbors[3][i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            //int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n            //pick random id of particle\n            int p = int(mod(h*3434534.0, float(MAX_PARTICLES)));\n            sort0(bestIds, bestDists, id, int(p), dataType, data.pos);  //sort this\n        }\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id < 0 || id >= MAX_PARTICLES ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    //if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    if (iFragCoord == ivec2(0))\n    {\n        vec4 state = texelFetch(iChannel1, iFragCoord, 0);\n        \n        if (iFrame == 0 || iResolution.xy != state.xy)\n        {\n            state.xy = iResolution.xy;\n            state.z = 1.;\n        }\n        else\n        {\n            state.z = 0.;\n        }\n        \n        fragColor = state;\n        return;\n    }\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n    \n    ivec4 old   = fxGetClosest( iFragCoord );      \n\n    for(int j=0; j<4; j++){\n        int id = old[j];\n        float dis2 = distance2Particle(id, screen2world(fragCoord));\n        insertion_sort( new, dis, id, dis2 );\n    }\n    \n    // Search randomly in the nearest 15x15 neighbors instead of just\n    // the next-door neighbors. Seems to allow faster particle movement\n    uint searchRange = 15u;\n    uint searchCount = 16u;\n    \n    for(uint i=0u; i<searchCount; ++i)\n    {\n        uvec4 h0 = hash(uvec4(fragCoord, iFrame, iResolution.x) * i);\n\n        ivec4 old   = fxGetClosest( iFragCoord + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n        for(int j=0; j<2; j++){\n            int id = old[j];\n            float dis2 = distance2Particle(id, screen2world(fragCoord));\n            insertion_sort( new, dis, id, dis2 );\n        }        \n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++)\n    {\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGcRm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[936, 936, 1015, 1015, 2165], [2167, 2167, 2221, 2221, 2749]], "test": "untested"}
{"id": "7lVcWy", "name": " A Pollo Onion", "author": "SnoopethDuckDuck", "description": "Fractal equation taken from here:\nhttps://jbaker.graphics/writings/DEC.html\n\nIt's just a cross-section, with the colors taken from an old shader (very messy!)", "tags": ["e"], "likes": 48, "viewed": 531, "published": 3, "date": "1662158298", "time_retrieved": "2024-07-30T16:33:09.589641", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// RayMarching code stolen from TheArtOfCode\n\n// Stolen from BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    \n    float a = -0.25 * iTime;\n    float zm = (0.5 + 0.5 * thc(2., - 0.5 * iTime));\n    float r = 3. + zm;\n    vec3 ro = vec3(r * cos(a), 1. + zm, r * sin(a));\n   // ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist( vec3 p0 ){\n    p0.y += 0.15;\n    float sd = abs(p0.y) - 0.01;\n    sd -= 0.3;// * (0.5 + 0.5 * thc(4., length(p0.xz) - 0.5 * iTime));\n    sd = max(sd, length(p0.xz) - 1.34);\n   // p0.xz += 0.1 * thc(2., 5. * p0.y);\n    p0 *= 0.5;\n    vec4 p = vec4(p0, 1.);\n      \n    //p.xyz = erot(p.xyz, normalize(p.yzx), 0.5 * iTime);\n    p.y += 0.05 * iTime;\n    for(int i = 0; i < 8; i++){\n      p.xyz = mod(p.xyz-1., 2.)-1.;\n     // p.xyz *= 1. + 0.12 * cos(p.zxy * 8.);\n     // p.xyz *= 1. +  0.15 * cos(length(p.xyz) * 10.);\n     // p.y += .05 * cos(6. * length(p.xz) + iTime);// cos(iTime) * 0.5;\n      \n      // float r1 = 0.5;\n      // float r2 = 0.1;\n      // float d1 = length(p.xz) - r1;\n      // float d2 = length(vec2(d1, p.y)) - r2;     \n      // p.y = d2;//mlength(p.xyz);\n     \n      //This one looks really cool\n      //p.y = 0.5 + 0.4 * cos(0.25 * iTime - pi * p.y);\n      p*=(1.34/dot(p.xyz, p.xyz));\n    }\n    p/=p.w;\n    return max(sd, abs(p.y)*0.5 - 0.00);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    float zm = 5. - 1. * (0.5 + 0.5 * thc(1., -0.5 * iTime));\n    vec3 rd = GetRayDir(uv, ro, vec3(0), zm);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n   \n    float IOR = 1.2;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        vec3 pIn = p - 20. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit);\n        \n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n       \n        float fres = pow(1. + dot(rd, n), 5.);\n        \n        // Change me\n        float c = 4.; // [0.6,6] is an okay range (<1 is like fresnel)\n        float I = 3.; // anything above 0. lower numbers more intense\n        \n        vec3 n1 = 0.8 * (abs(r) - abs(n));\n        float mx2 = exp(-5. * length(abs(r)-abs(n1)));\n\n        vec3 r2 = c * (abs(r)-abs(n));\n        vec3 n2 = c * (abs(r2)-abs(n));\n        \n        float mx = exp(-I * length(abs(r2)-abs(n2)));\n \n        float cl = 0.5 + 0.25 * dif + max(0.5 * fres, max(mx,mx2));\n\n        vec3 e = vec3(0.5);\n        vec3 col2 = pal(1. + p.y - 0.1 * iTime + 4. * length(p) - p.y * 0.05  + 0.75 * mx, e, e, e, 0.5 * vec3(0,1,2)/3.);\n        vec3 col3 = pal(1. + p.y - 0.1 * iTime + 4. * length(p) - p.y * 0.05  + 1.5 * mx2, e, e, e, 0.5 * vec3(0,1,2)/3.);\n        \n        float c1 = texture(iChannel0, 0.05 * iTime + 3. * p.xy).r;\n        float c2 = texture(iChannel0, 0.05 * iTime + 3. * p.yz).r;\n        float c3 = texture(iChannel0, 0.05 * iTime + 3. * p.zx).r;\n        \n        vec3 n3 = abs(n);\n        float c4 = n3.z * c1 + n3.x * c2 + n3.y * c3;\n        \n        // add (dif + reflections) * base color\n        col = cl * col2;\n\n        // mix to second color based on ray distance inside object\n        float mx3 = exp(-0.333 * dIn);\n        //col = cl * col3;\n        //col = mix(col, col3, mx3);\n        // col= cl * col3;\n        col *= 2. * col3;\n        \n        // add vertical shading (\"light source\" from above)\n        col += 0.3 * n.y;\n        col *= 0.8 + 0.5 * c4;\n        \n        // more color + reflections to match background \n        col += 0.075 * (exp(vec3(abs(rd.x),rd.y,abs(rd.z))) + exp(-r) + 0.1 * exp(r2) - 1.05);\n    } else {    \n        col = 0.65 * exp(vec3(abs(rd.x),rd.y,abs(rd.z)));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// Stolen from iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}\n    \n    \n    ", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lVcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 226, 226, 302], [304, 304, 342, 342, 407], [409, 409, 428, 428, 511], [513, 513, 542, 542, 623], [625, 625, 639, 639, 926], [928, 928, 953, 953, 1909], [1911, 1911, 1954, 1954, 2261], [2263, 2263, 2287, 2287, 2477], [2479, 2479, 2529, 2529, 2720], [2722, 2722, 2779, 2779, 5378]], "test": "untested"}
{"id": "slycW1", "name": "Interesting audio visualizer", "author": "fishy", "description": "audio visualizer. setting the barWidth to 1.0 and the barCount to 2000.0 yields interesting results as well", "tags": ["audio"], "likes": 7, "viewed": 414, "published": 3, "date": "1662153292", "time_retrieved": "2024-07-30T16:33:10.331656", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define xScale 1.0\n#define yScale 0.4\n#define barCount 20.0\n#define barWidth 0.5\n#define barHeight 0.2\n#define clipWidth 0.9\n#define curveDepth 0.4\n#define reflectionDepth 0.25\n#define reflectionHeight 0.6\n#define yPos -0.1\n\nfloat yOffset(float x)\n{\n    return sqrt(1.0-pow(max(0.0, x), 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.0, yPos);\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    uv.x = abs(uv.x - 0.5)*3.0;\n\n    \n    float discreteX = floor(uv.x*barCount)/barCount;\n    \n    uv.y -= yOffset(abs(discreteX))*curveDepth;\n    \n    float height = texture(iChannel0, vec2(discreteX * xScale, 0.0)).x * yScale + barHeight;\n\n    \n    \n    float intensity = 1.0;\n    \n    if(barHeight - uv.y > 0.0)\n    {\n        uv.y = abs(uv.y - barHeight) + curveDepth - reflectionDepth;\n        height *= reflectionHeight;\n        intensity = pow(1.0 - uv.y, 3.0);\n    }\n    \n    fragColor = vec4(float(abs(mod(uv.x * barCount, 1.0) - 0.5) < barWidth * 0.5 && uv.y < height && uv.y > barHeight && uv.x < clipWidth)*intensity);\n    //fragColor = vec4(1.0 - uv.yyy, 1.0);\n}", "buffer_a_inputs": [{"id": 29707, "src": "https://soundcloud.com/nocopyrightsounds/electro-light-symbolism-ncs-release", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slycW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 144]], "test": "untested"}
{"id": "7tVyWy", "name": "009 - SDF Paraboloid at Z", "author": "PiGIon", "description": "I played a bit with a paraboloid function that I learned and tried to draw it with a simple ray marching.", "tags": ["mouse", "beginner", "paraboloid"], "likes": 1, "viewed": 179, "published": 3, "date": "1662149603", "time_retrieved": "2024-07-30T16:33:11.095613", "image_code": "// 2022.09.02\n\n#define PI 3.14159265\n\nfloat constCycle(float perSecond, float range) {\n    return ((iTime + iTimeDelta) * perSecond) * range;\n}\n\n// sined distance function of a paraboloid at Z\n// https://en.wikipedia.org/wiki/Signed_distance_function\nfloat paraboloidZSDF(vec3 p, float a, float b) {\n    return (pow(p.x, 2.)/pow(a, 2.)) + (pow(p.y, 2.)/pow(b, 2.)) - p.z;\n}\n\n// from https://scrapbox.io/sayachang/fragments_of_fragment_shaders\nvec3 rotX(vec3 p,float a){return vec3(p.x,p.y*cos(a)-p.z*sin(a),p.y*sin(a)+p.z*cos(a));}\nvec3 rotY(vec3 p,float a){return vec3(p.x*cos(a)-p.z*sin(a),p.y,p.x*sin(a)+p.z*cos(a));}\n\nvec3 mouseRot(vec2 mouseScale, vec3 v) {\n    return rotX(rotY(v, -mouseScale.x * PI), -mouseScale.y * PI);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouseScale = vec2((iMouse.x / iResolution.x) - 0.5, (iMouse.y / iResolution.y) - 0.5);\n    \n    if (length(iMouse) == 0.) {\n        mouseScale = vec2(((iResolution.x/2.) / iResolution.x) - 0.5, ((iResolution.y/2.) / iResolution.y) - 0.5);\n    }\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 eyes = vec3(0., 0., -5.);\n    vec3 dir = normalize( vec3( uv, 1. ) );\n\n    vec3 ray;\n    float t = 0.0;\n    for (int i = 0; i < 32; i++) {\n        ray = mouseRot(mouseScale, eyes + dir * t);\n\n        float dist = paraboloidZSDF(ray, 1., 2.);\n\n    \tif(dist < 0.001) break;\n\n\t\tt += dist;\n    }\n\n    fragColor = vec4(normalize(ray), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 86, 86, 143], [145, 251, 299, 299, 373], [375, 443, 469, 469, 531], [532, 532, 558, 558, 620], [622, 622, 662, 662, 734], [736, 736, 793, 793, 1468]], "test": "untested"}
{"id": "fsByDz", "name": "Pebble Fire (134 chars)", "author": "ruudhelderman", "description": "Using the pebbles texture as a noise pattern saved me a lot of code. It doesn't come much smaller than this.", "tags": ["fire", "flames", "codegolf"], "likes": 18, "viewed": 573, "published": 3, "date": "1662148815", "time_retrieved": "2024-07-30T16:33:11.834638", "image_code": "// Pebble Fire - simple and compact 2D fire implementation\n//\n// Similar to \"Burn down the gym\" https://www.shadertoy.com/view/fdtczl\n// but this time using a texture (pebbles) instead of simplex noise.\n// See also: https://helderman.github.io/blend-fire/\n//\n// Copyright 2022 Ruud Helderman\n// MIT License\n\n// 134 chars - codegolfed by @spalmer, slightly changed the movement\n/**/\n#define n texture(iChannel0, u - iTime*o.ga++*.2).r + u.y\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u /= iResolution.x;\n    \n    o = vec4(3, .5, 2, 5);\n    o -= (n + n)*2.;\n}\n/**/\n\n// 139 chars - codegolfed by @Xor\n/**\n#define n texture(iChannel0, u - iTime*o.ga++*.2).r + u.y\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u /= iResolution.x;\n    \n    o = vec4(3, -.5, 2, 4.5);\n    o -= (n + n)*2.; n;\n}\n/**/\n\n// 148 chars - original code by @ruudhelderman\n/**\n#define n(d) texture(iChannel0, u - iTime * (vec2(0, 1) + d)).r * 2.\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u /= iResolution.x;\n    o = vec4(3, 2.5, 2, 9) - n(.1) - n(-.1) - u.y * 4.;\n}\n/**/\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29678, "src": "https://soundcloud.com/user-918612934-506355840/fire-sfx", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsByDz.jpg", "access": "api", "license": "mit", "functions": [[441, 441, 477, 477, 556]], "test": "untested"}
{"id": "7tVcWG", "name": "Julia Set #28760", "author": "muio", "description": "Because we can't get enough of them.", "tags": ["fractal", "juliaset"], "likes": 1, "viewed": 190, "published": 3, "date": "1662137785", "time_retrieved": "2024-07-30T16:33:12.669406", "image_code": "// Under LGPL v2.1 loicense\n// https://www.gnu.org/licenses/old-licenses/lgpl-2.1.html\n\n// Implemented from https://wikipedia.org/wiki/Julia_set#Pseudocode_for_normal_Julia_sets\n// uv.y goes from -1 to 1, so R is always 2.\n\n#define MAX_ITER 200.0\n\nfloat julia(vec2 uv, vec2 c) {\n    float iter = 0.0;\n    \n    float perturbation = sin(iTime) / 25.;\n    for(;\n        dot(uv, uv) < 4.0 \n        && iter < MAX_ITER;\n        iter++) {\n        uv = vec2(uv.x * uv.x - uv.y * uv.y, 2.0 * uv.x * uv.y) + c + vec2(perturbation);\n    }    \n    return iter;\n}\n\nvec3 color_julia(float iter) {\n    float c = (MAX_ITER - iter < 0.0) ? 1.0\n                                      : iter / MAX_ITER;\n    return smoothstep(0.0, 1.0, 2.0 * c  - vec3(2, 0, 0));                       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv.y in [-1, 1] and uv.x in [- aspect-ratio, aspect-ratio]\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    uv *= .5;                           // zoom in by 2x\n    uv *= abs(sin(iTime * 0.6)) + .07;  // adjust zoom\n    uv -= vec2(.212094, .403085);       // offset center\n    \n    const vec2 c = vec2(-0.70176, -0.3842);  // copied off wiki\n    float iter = julia(uv, c);\n    vec3 col = color_julia(iter);\n    \n    //vec3 col = uv.xyx;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVcWG.jpg", "access": "api", "license": "lgpl-2.1", "functions": [[248, 248, 278, 278, 550], [552, 552, 582, 582, 767], [769, 769, 826, 892, 1332]], "test": "untested"}
{"id": "7tKcWG", "name": "Watercolor movement (Simple)", "author": "spenceryonce", "description": "Simple watercolor fluid movement shader. \n\n*updated dec 2023:\n- added simple mouse movement\n*", "tags": ["simple", "math", "fluid", "dynamic", "watercolor"], "likes": 8, "viewed": 351, "published": 3, "date": "1662136604", "time_retrieved": "2024-07-30T16:33:13.700649", "image_code": "const int AMOUNT = 12;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 20.0 * (fragCoord.xy-iResolution.xy/ 2.0 )/ min(iResolution.x, iResolution.y);\n    float len;\n    uv+=iMouse.xy/-iResolution.xy*20.;\n    \n    for(int i = 0; i < AMOUNT; i++) {\n        len = length(vec2(uv.x, uv.y));\n\n        uv.x = uv.x - cos(uv.y +sin(len)) + cos(iTime / 9.0);\n        uv.y = uv.y - sin(uv.x +cos(len)) + sin(iTime / 12.0);\n    }\n\n    vec3 color = vec3(\n        cos(len*0.1),\n        cos(len*0.2),\n        cos(len*0.5)\n        );\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tKcWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 578]], "test": "untested"}
{"id": "NtKcDG", "name": "Polonia wiggle ", "author": "GabrielKepecs", "description": "bandeira polonia mexendo ", "tags": ["polonia"], "likes": 0, "viewed": 157, "published": 3, "date": "1662127261", "time_retrieved": "2024-07-30T16:33:14.452639", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float wiggle =sin(iTime*2.0+(uv.x*5.0))*0.01;\n   float wi=wiggle*0.01;\n    \n    fragColor = vec4(1,0,0,0);\n    \n    \n    if(uv.y>0.5+wiggle){\n          fragColor = vec4(1,1,1,0);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtKcDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 344]], "test": "untested"}
{"id": "NlVyDG", "name": "Bandeira Noruega", "author": "GabrielKepecs", "description": "bandeira noruega", "tags": ["flag"], "likes": 0, "viewed": 146, "published": 3, "date": "1662127063", "time_retrieved": "2024-07-30T16:33:15.207619", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    float r = 0.85, b = 0.5, w = 0.98;\n    vec3 col = vec3(w);\n    if (uv.x<-0.8 && uv.y>0.25) col = vec3(r,0,0);    else\n    if (uv.x>-0.3 && uv.y>0.25) col = vec3(r,0,0);    else\n    if (uv.x<-0.8 && uv.y<-0.25) col = vec3(r,0,0);    else\n    if (uv.x>-0.3 && uv.y<-0.25) col = vec3(r,0,0);    else\n    if (uv.x>-0.7 && uv.x<-0.4) col = vec3(0,0,b);    else\n    if (uv.y>-0.15 && uv.y<0.15) col = vec3(0,0,b);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlVyDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 560]], "test": "untested"}
{"id": "7lycDy", "name": "Julia Set with cool colors", "author": "Varyemez", "description": "lorem ipsum", "tags": ["fractal"], "likes": 1, "viewed": 220, "published": 3, "date": "1662117201", "time_retrieved": "2024-07-30T16:33:16.053358", "image_code": "float julia_set(vec2 z, vec2 c)\n{\n    //int MAX_ITER = int(sin(iTime)*49.0+51.0);\n    int MAX_ITER = 195;\n    int i = 0;\n    for (; i < MAX_ITER; i++)\n    {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if (length(z) > 2.0)\n            break;\n    }\n    return float(i) / float(MAX_ITER);\n}\n\nvec3 get_color(float v)\n{\n    v *= 3.0;\n    return vec3(\n        smoothstep(0.0, 1.0, v),\n        smoothstep(1.0, 2.0, v), \n        smoothstep(2.0, 3.0, v));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.x;\n    uv *= 2.1;\n    uv *= 0.08;\n    uv.y -= 0.12;\n    \n    float c = julia_set(vec2(abs(uv.x), uv.y), vec2(0.375));\n    vec3 color = get_color(c);\n    fragColor = vec4(color.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lycDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 81, 305], [307, 307, 332, 332, 466], [468, 468, 523, 523, 776]], "test": "untested"}
{"id": "7lycWy", "name": "Leaking Circles", "author": "MysteryPancake", "description": "This happens when the grid is not rounded to an integer", "tags": ["circles", "grid", "blur", "sphere", "circle", "flow", "flowing", "leak", "leaking"], "likes": 0, "viewed": 183, "published": 3, "date": "1662111172", "time_retrieved": "2024-07-30T16:33:16.809337", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 noDistort = fragCoord / iResolution.x;\n    \n    float grid = length(fract(noDistort * 14.0) - 0.5);\n    float radius = iTime * 0.03;\n    float falloff = radius / length(uv - 0.5);\n    float blurred = smoothstep(0.4, 0.6, falloff - grid);\n    \n    vec3 color = mix(vec3(uv.x, 0.0, uv.y), vec3(1.0), blurred);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lycWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 451]], "test": "untested"}
{"id": "7tGcWy", "name": "Walk on spheres for Laplace eq2b", "author": "FabriceNeyret2", "description": "Solving the Laplace equation in a domain specified by an SDF using the walk-on-spheres algorithm\n\nVariant of lisyarus [url] https://shadertoy.com/view/7lVcz3 [/url]\nusing animation-compatible boundary conditions + MIPmap for filtering ( click to compare).", "tags": ["montecarlo", "pde", "laplace", "walkonspheres"], "likes": 10, "viewed": 420, "published": 3, "date": "1662110647", "time_retrieved": "2024-07-30T16:33:17.711923", "image_code": "// variant of https://shadertoy.com/view/7lVczc\n// Fork of \"Walk on spheres for Laplace eqn\" by lisyarus. https://shadertoy.com/view/7lVcz3 \n\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    U /= iResolution.xy;\n//  O = texture(iChannel0,U, 2.); O = vec4( O.w > 0. ? .5+.5*sin(40.*O.y/O.w) : 0. );\n\n    O = texture(iChannel0,U, iMouse.z>0. ? 0. : 3.);\n    O = vec4( texture(iChannel0,U).w > 0. ? .5+.5*sin(40.*O.x ) : 0. );\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define C(p,r) ( r - length(p) )                             // circle SDF\n#define B(p,r) ( r - max(abs(p).x,abs(p).y) )                // box SDF\n#define D(c,v) l = c, l < d ? d=l, b=v : v  \n\n#define T iTime\n\nfloat SDF(vec2 p, out float b ) {                            // scene SDF. out = border id or value\n    float d = 1e4, l; \n          D( B(p, 1.) , 1. );\n          D( -C(p - 1., .4) , 1. );\n          D( -C(p - vec2(-1, 1), .7) , 1. );\n          D( -C(p - vec2( 1,-1), .5), 1. );\n          D( -C(p +  1., .8), 1. );\n          D( -C(p+.3*vec2(cos(T),sin(1.3*T)), .5), 0. );\n    return   d;\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy, s,\n          p = ( u+u - R ) / R.y; \n    float v = 0., j,i = v, b,  N = 256.;\n    \n    if ( SDF(p,b) < -.05 ) { O-=O; return; }\n\n    for ( ; i++ < N                                          // diffusion = averaging N random walks\n          ; v += b                                           // boundary condition\n        ) \n        for ( s = p, j = 0.; j++ < 8.; )                     // random walk from sphere marching ( S steps )\n            s += SDF(s,b) * cos( 6.28* fract(sin( dot(s,R-17.) + (i-T)*269. ) *4e4 ) // CosSin( 2pi*hash(s) )\n                               + vec2(0,11));\n    \n    O =  vec4(  v/N , SDF(p,b) < 0. ? 0. : v/N, 0, SDF(p,b) > 0.);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 180, 180, 419]], "test": "untested"}
{"id": "7tGcDG", "name": "Nested transparent sphere4s", "author": "mrange", "description": "CC0: Nested Sphere4s\n Reminded by the weekly shader \"simple refraction test\" by drschizzo (https://www.shadertoy.com/view/flcSW2)\nthat refractions are cool looking decided to tinker a bit with them again.\nThought it looked neat so shared.\n", "tags": ["3d", "refraction"], "likes": 25, "viewed": 507, "published": 3, "date": "1662098720", "time_retrieved": "2024-07-30T16:33:18.519764", "image_code": "// CC0: Nested transparent sphere4s\n//  Reminded by the weekly shader \"simple refraction test\" by drschizzo (https://www.shadertoy.com/view/flcSW2)\n//  that refractions are cool looking decided to tinker a bit with them again.\n//  Thought it looked neat so shared.\n\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define TOLERANCE       0.0001\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.001\n#define MAX_BOUNCES     5\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst vec3 skyCol     = HSV2RGB(vec3(0.6, 0.86, 1.0));\nconst vec3 lightPos   = vec3(0.0, 10.0, 0.0);\n\nconst float initt       = 0.1; \nconst float refraction  = 0.8;\n\nmat3 g_rot = mat3(1.0); \nvec2 g_mat = vec2(0.0);\nvec3 g_beer = vec3(0.0);\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\nfloat sphere4(vec3 p, float r) {\n  p *= p;\n  return pow(dot(p, p), 0.25)-r;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  vec3 col = clamp(vec3(0.0025/abs(rd.y))*skyCol, 0.0, 1.0);\n\n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n  }\n\n  if (tp0 > 0.0) {\n    vec3 pos  = ro + tp0*rd;\n    vec2 pp = pos.xz;\n    float ds = length(pp) - 0.5;\n    \n    col += vec3(0.25)*skyCol*exp(-.5*max(ds, 0.0));\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nfloat df(vec3 p) {\n  p *= g_rot;\n  vec3 p0 = p;\n  p *= g_rot;\n  vec3 p1 = p;\n  float d0 = sphere4(p0, 1.0);\n  float d1 = sphere4(p1, 1.75);\n  d1 = max(d1, -(d0-0.2));\n\n  vec2 mat = vec2(0.05, 0.5);\n  vec3 beer = -vec3(2., 1.0, 2.0);\n  \n  float d = d0;\n  if (d1 < d) {\n    mat = vec2(0.99, 0.6);\n    d = d1;\n    beer = vec3(0.1, 0.2, 0.);\n  }\n  \n  g_mat = mat;\n  g_beer = beer;\n  return d;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float dfactor, out int ii) {\n  float t = 0.0;\n  float tol = dfactor*TOLERANCE;\n  ii = MAX_RAY_MARCHES;\n  for (int i = 0; i < MAX_RAY_MARCHES; ++i) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = dfactor*df(ro + rd*t);\n    if (d < TOLERANCE) {\n      ii = i;\n      break;\n    }\n    t += d;\n  }\n  return t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  vec3 ragg = vec3(1.0);\n\n  bool isInside = df(ro) < 0.0;\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float dfactor = isInside ? -1.0 : 1.0;\n    float mragg = min(min(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.025) break;\n    int iter;\n    float st = rayMarch(ro, rd, dfactor, iter);\n    const float mrm = 1.0/float(MAX_RAY_MARCHES);\n    float ii = float(iter)*mrm;\n    vec2 mat = g_mat;\n    vec3 beer = g_beer;\n    if (st >= MAX_RAY_LENGTH) {\n      agg += ragg*skyColor(ro, rd);\n      break; \n    }\n\n    vec3 sp = ro+rd*st;\n\n    vec3 sn = dfactor*normal(sp);\n    float fre = 1.0+dot(rd, sn);\n    fre *= fre;\n    fre = mix(0.1, 1.0, fre);\n\n    vec3 ld     = normalize(lightPos - sp);\n\n    float dif   = max(dot(ld, sn), 0.0); \n    vec3 ref    = reflect(rd, sn);\n    const float irefraction = 1.0/refraction;\n    vec3 refr   = refract(rd, sn, !isInside ? refraction : irefraction);\n    vec3 rsky   = skyColor(sp, ref);\n    const vec3 dcol = HSV2RGB(vec3(0.6, 0.85, 1.0));\n    vec3 col = vec3(0.0);    \n    col += dcol*dif*dif*(1.0-mat.x);\n    col += rsky*mat.y*fre*vec3(1.0)*smoothstep(1.0, 0.9, fre);\n\n    if (isInside) {\n      ragg *= exp(-st*beer);\n    }\n    agg += ragg*col;\n\n    ragg *= mat.x;\n    if (refr == vec3(0.0)) {\n      rd = ref;\n    } else {\n      isInside = !isInside;\n      rd = refr;\n    }\n\n    // TODO: if inside should also compute beer factor based on initt    \n    ro = sp+initt*rd;\n  }\n\n  return agg;\n}\n\nvec3 effect(vec2 p) {\n  g_rot = rot_x(0.2*TIME)*rot_y(0.3*TIME);\n  vec3 ro = 0.6*vec3(0.0, 2.0, 5.0);\n  const vec3 la = vec3(0.0, 0.0, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = tan(TAU/6.);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tGcDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[700, 700, 722, 722, 868], [1404, 1504, 1523, 1523, 1610], [1612, 1719, 1745, 1745, 1929], [1931, 1991, 2019, 2085, 2161], [2163, 2281, 2308, 2308, 2384], [2386, 2498, 2540, 2540, 2587], [2589, 2589, 2610, 2610, 2710], [2712, 2712, 2733, 2733, 2833], [2835, 2835, 2856, 2856, 2959], [2961, 2961, 2993, 2993, 3038], [3040, 3040, 3073, 3073, 3747], [3749, 3749, 3767, 3767, 4139], [4141, 4141, 4164, 4164, 4372], [4374, 4374, 4435, 4435, 4759], [4761, 4761, 4792, 4792, 6270], [6272, 6272, 6293, 6293, 6692], [6694, 6694, 6749, 6749, 6968]], "test": "untested"}
{"id": "7lGcWG", "name": "Fractal mosaic 9 (music)", "author": "jarble", "description": "Yet another fractal mosaic pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "likes": 5, "viewed": 417, "published": 3, "date": "1662095437", "time_retrieved": "2024-07-30T16:33:19.286713", "image_code": "vec2 f1(vec2 a){\n    float s1 = 8.;\n    return\n        fract(a)\n        //max(abs(.5-fract(a.yx)),abs(.5-fract(a+.5)))\n        //abs(fract(a)-(fract(a/s1)/s1))\n    ;\n}\n\nvec2 triangle_wave(vec2 a){\n    //a += .5;\n    vec2 a2 = //change this constant to get other interesting patterns\n        vec2(1.,0.5)\n        //vec2(2.5,-1.)\n        //vec2(1.5,0.)\n        \n        //vec2(-2.,.5+mod(floor(a.x),2.))\n    ,\n    \n    a1 =\n        a+a2\n        //a+a2+floor(a.x)\n        //a+a2+floor(a.y)\n    ;\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n\n    //a1 *= (1. + fmod(abs(a1/2.),2.));\n    return\n        abs(f1((a1)*(a2.x+a2.y))-.5)\n        //abs(fract((a1)*(a2.x+a2.y))*sign(a.yx-a)-.5)\n        //abs(fract((a1+.25)*(a2.x+a2.y))-.5)\n    ;\n}\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.*2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    float scale = 1.5,c1=0.;\n    vec2 t2 = vec2(0.);\n    bool t3 = false;\n    vec2 uv1 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n        //uv += t1_(floor(uv/2.),floor(uv/2.))/2.;\n        //uv += floor(vec2(uv.x,uv.y+.5))/1.5;\n\n        \n        //a really interesting pattern:\n        //uv -= floor(iTime+uv/1.5)/1.5;\n        \n        //uv.x += floor(uv.x*8.)/8.;\n\n        //uv.x += fmod(uv.x*5.,5.); //fractured pattern\n        //uv.y += fmod(uv.y,1.5); //lace pattern\n        //uv += floor(uv+vec2(-.5,0.))/1.5;\n        t3 =\n            uv.x > uv.y\n            //uv.x < uv.y || !t3\n            //uv.x < uv.y && t2.x > t2.y || !t3\n        ;\n\n        //another awesome pattern (looks better zoomed out)\n        //if(t3){ uv = uv.yx+.5;t2 = -t2.yx-.5;}\n        \n        //arabesque pattern\n        //if(t3){ uv = uv.yx;t2 = t2.yx;}\n        \n        //t3 = !t3 && uv.x > uv.y || t3 && uv.x < uv.y;\n        //t3 = !(t3 || uv.x < uv.y) && (!t3 || uv.x > uv.y);\n        \n        //if(t3)\n        uv =\n            abs(.5+uv+t2)+uv1\n            //abs(.5+uv+t2*fmod(uv.y+t2.y,2.))+uv1\n            //uv = max(abs(.5+uv+t2),abs(-.5+uv+t2))+uv1\n            \n            //abs(.5+uv+t2+pow(floor(uv.y*2./1.5),2.))\n            //fract(abs(2.+uv+t2))\n            //*sign(uv.y-uv.x)\n        ;\n        //uv = abs(fract(vec2(uv+vec2(.5,1.5))*1.5)-.5)/1.5;\n        //uv.y += .5;\n\n        //uv += float(!t3);\n        \n        //star pattern on black background\n        //uv += floor(uv.x+uv.y+1.)*floor(t2.x+t2.y)/2.;\n        \n        //arabesque knot pattern\n        //if(uv.y>uv.x) uv = -uv.yx; else uv *= -sign(uv-uv.yx);\n        \n        t2 =\n            -triangle_wave(uv-.5)\n            //-triangle_wave(uv+.5+floor(uv.y*1.5-.5))\n            //-triangle_wave(uv-.5)*float(t3)\n            //-triangle_wave(uv-.5+floor(uv.x+uv.y))\n            //-triangle_wave(uv+.5*sign(uv.x-uv.y))\n            //-triangle_wave(uv-.5+fmod(uv.y*2.,8.))\n            //triangle_wave(uv+.5*sign(uv.x-uv.y))*sign(uv.x-uv.y)\n            //-triangle_wave(u-.5)/(.5+fmod(t2.x,2.))\n            //-triangle_wave(uv-1.5-fmod(t2.x/1.5,2.))\n            //*sign(uv.y-uv.x)\n        ;\n        \n\n        uv =\n            t2-triangle_wave(uv.yx)\n            //fract(t2-triangle_wave(uv.yx)+.5)/1.5\n            //t2-triangle_wave(uv.yx-floor(t2.y-t2.x))\n            //t2-triangle_wave(uv.yx-floor(t2.y-t2.x)*floor(uv.y-uv.x))\n        ;\n        //uv = fract(uv);\n        \n        //uv.x += floor((uv.x-uv.y));\n        \n        c1 =\n            uv.x-uv.y\n            //max(c1,(uv.x-uv.y))\n        ;\n        col = col.yzx;\n        //col *= col + .5;\n        if(t3 || uv.y < uv.x) col =\n            vec3(col.yz,c1)\n            //vec3(col.yz,max(c1,col.x))\n            //max(vec3(col.yz,c1),abs(col-c1)/3.)\n        ;\n        //else if(k>4) uv.x -= iTime;\n        //if(!t3 || uv.y > uv.x) col = vec3(col.yz,max(c1,0.));\n        //if(!t3 && uv.y < uv.x) col = vec3(col.yz,max(c1,0.));\n        //if(t2.x<t2.y||t2.x>t2.y) {uv=uv.yx;t2=t2.yx;}\n        //uv1 += 1.;\n        //if(uv.x>uv.y) uv.y += .5;\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "sound_code": "vec2 mainSound(int samp, float time){\n  //time += floor(time*2.)/2.;\n  //time += fmod(time*2.,2.)+fmod(time*4.,4.);\n\n  //time += fpow(time,2.)*fpow(time*4.,2.);\n  \n  float tempo = 1.;\n  time /= tempo;\n  \n  //time += floor(time*pow(2.,fmod(time/8.,3.)));\n  float s1 =\n      4.\n      //pow(2.,1.+fmod(time,3.))\n  ;\n  //time -= floor(time*s1);\n  //time += fmod(time,5.+fmod(time*s1,7.));\n  float t=\n      time\n      //time + floor(time*s1+floor(time/s1))/s1\n      //time/(1.+fmod(time*s1,2.))/(1.+fmod(time/s1,2.))\n      //time/(1.+fmod(time/s1,2.))\n  ,\n  m1 =\n      fmod(t/4.,4.)\n      //fmax(t*4.+floor(t),floor(t*4.)+t,4.)\n      //fmax(t/4.,t/4.+fmod(t*4.,4.),4.)\n      //fmod(t*4.+floor(t/4.),4.)\n      //fmod(floor(t/s1)*(floor(t)+floor(t*s1)),s1)\n      //fmod(t/4.+ceil(t*4.),4.)\n  ,\n  //m1 = fmod(floor(t/4.)-t*4.,4.),\n  \n      //4.*(1.+fmod(t/(1.+fmod(t,2.)),2.)), //varying tempo\n  m3 = \n      fmod(t*s1/abs(2.5-m1),s1)\n      //fmod((t+floor(t*2.))*s1/abs(2.5-m1),s1)\n  ;\n  \n  //t *= (1.+fmod(t/4.,2.))/(1.+fmod(t/8.,2.)); //varying tempo\n  //t += floor(t*s1+floor(t/s1))/s1;\n  //t += m1+m3;\n  t *=\n      s1*s1\n      //s1*s1/(1.+fmod((t/s1+floor(t/s1/s1))/2.,2.))\n      //s1*s1*(1.+floor(m1/2.))\n      //s1*s1/abs(2.5-m1)\n      //s1*s1*(1.+fmod(floor(t*s1/4.)/s1,2.))/(1.+fmod(floor(t*s1/2.)/s1,2.))\n  ;\n  //t /= (1.+fmod(t/4.,2.))/(1.+fmod(t/8.,2.)); //varying tempo\n  \n  float m2 =\n      1. + fmod((t/s1),s1)\n      //1. + fmod((t/(s1+s1*m3)),s1)\n  ;\n\n  t /=\n      max(m2,m1+1.)\n      //max(min(m2,m3),m1+1.)\n  ;\n  \n  //m3 = mod(floor(t/s1*2.),s1-m3);\n  //m2 = mod(floor(t/s1*2.),s1-m2);\n  \n  float a =\n      128.*sqrt((1.-sqrt(fract(t/s1)))/s1)*.2\n      //(2.-log(fract(t/s1)))*(2.-log(fract(t/s1)))\n,\n  nb = time*pow(2.,m3/2.+7.5)*tempo;\n\n  return\n      log(abs(.5-vec2(fract(nb*.998),fract(nb)))*a)\n      \n      //sitar\n      //log(abs(a/16.-abs(.5-vec2(fract(nb*.998),fract(nb)))*a))\n      \n      //vec2(fract(time*nb*.998/m2*s1)*a,fract(time*nb/m2*s1)*a)\n  ;\n\n}\n\n/*\nvec2 mainSound(int samp, float time){\n  float t=time*4.;\n  float m1 = mod(floor(t/4.),4.),\n  m3 = mod(floor(t/abs(2.5-m1)),4.);\n  \n  t *= 4.;\n  float m2 = 1. + min(mod(floor(t/4.),4.),t);\n\n  t /= max(m2,m1+1.);\n  \n  float a=sqrt((1.-sqrt(fract(t/4.)))/4.)*.2,\n  \n  nb = pow(2.,m3/2.+6.5);\n\n  return vec2(fract(time*nb*.998)*a\n   ,fract(time*nb)*a);\n\n}\n*/", "sound_inputs": [], "common_code": "\n#define smod(x,y) floor(mod(floor(x)*floor(x),y))\n#define sqmod(x,y) floor(mod(floor(x)*floor(x),y*y)/y)\nfloat fmod1(float a, float b){\n    /*\n    for(float i = 1.; i < mod(floor(a/b),b); i++){\n        a += mod(floor(a/b),b)*i;\n    }\n    */\n    //divide by powers of 2 to get interesting rhythms\n    float a1 = floor(a);\n    //a /= 1. + mod(floor(a1/32.),2.);\n    //a /= 1. + mod(floor(a1/16.),2.);\n    //a /= 1. + mod(floor(a1/8.),2.);\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //abs(b-mod(floor(a),b*2.))\n        //mod(mod(floor(a/2.+2.),b),b)\n        //mod(mod(floor(a)+4.,floor(a/4.)+4.),b)\n        //mod(floor(floor(a/2.*b)/4.+floor(a/2.)),b)\n        //mod(floor(floor(a*2./b)*sign(.5-mod(float(a*2./b),2.))),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    return\n        fmod1(a,b)\n        //fmod1(a+fmod1(a/4., b), b)\n    ;\n}\n\n//#define fmod(a,b) mod(mod(floor((a)),floor(1.+(a)/3.)),b)\n\n//multiply by prime numbers to get an interesting rhythm\n//#define fmod(a,b) mod(floor((a)/2.)*3.+floor((a)/4.)*7.,b)\n\n#define fmod1(x,y) mod(floor(x)+floor(floor(x)/y),y)\n#define fmod2(x,y) mod(floor(x+y/2.)*floor(x-y/2.),y)\n#define fmod3(x,y) mod(floor(x)*(mod(floor(time/s1),s1)+floor(x)),y)\n#define fmod4(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fpow(x,y) pow(y,fmod(x,y))\n#define floor1(x) floor(x)*floor(mod((x)/4.,2.))\n\n#define powmod(x,y) mod(floor(pow(y,mod(floor(x)/y,y))),y)\n#define powmod1(x,y) mod(floor(x+powmod(x+y,y)),y)", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lGcWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 167], [169, 169, 196, 211, 771], [888, 888, 914, 914, 1003], [1005, 1005, 1062, 1062, 4384]], "test": "untested"}
{"id": "slyyWG", "name": "[twigl]LCD Maze (242chrs)", "author": "Catzpaw", "description": "https://twitter.com/catzpaw/status/1524599980157448192", "tags": ["2d", "twigl"], "likes": 8, "viewed": 284, "published": 3, "date": "1662094879", "time_retrieved": "2024-07-30T16:33:20.277065", "image_code": "//--- LCD Maze\n// by Catzpaw 2022\n\n//https://bit.ly/37BlsZ0\n\nTWIGL_GEEKEST_300ES\n\n#define F q=fract(p)-.5;g=fract(p*2.+.05);o.q=q.x*sign(ceil(fsnoise(ceil(p))-.5+sin(t)*.2)-.5);o-=step(.99,cos(o.q+q.y))*step(o.q*q.y,0.)*step(.1,min(g.x,g.y))\nvec2 p=(FC.xy-r*.5)/r.y*mat2(5,5,-5,7)+t,q,g;F*.5;p.y+=.1;F*.2-FC.baba-(p.y-t)*.1;\n\nEND_GEEKEST_300ES\n", "image_inputs": [], "common_code": "/* ============================================ **\n\n███████        █   TWIGL GEEKEST WRAPPER\n█  █  █            for Shadertoy\n   █  ███  █████\n   █   █ ▐▌ █  █    by Catzpaw 2022\n  ███  ▐█▌▐█▌ ███\n\n ██       ██  ██\n █  ▐█████ █   █\n█▌ ▐█   █  █   ▐█  \"twigl\"\n █ ▐█   █  █   █    https://twigl.app/\n ██ ▐████ ███ ██    Copyright (c) 2020 doxas\n    ████▌\n\nMIT License\nhttps://github.com/doxas/twigl/blob/master/LICENSE\n\n** ============================================ */\n\n\n/*** NOTICE **************************************\n  No backbuffer supported.\n  No MRT supported.\n  \"s\" is always zero.\n*************************************************/\n\n\n\n// --------------------------------------------\n//  noise.glsl\n// --------------------------------------------\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n//\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec2  mod289(vec2 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3  mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4  mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nfloat permute(float x){return mod289(((x*34.0)+1.0)*x);}\nvec3  permute(vec3 x) {return mod289(((x*34.0)+1.0)*x);}\nvec4  permute(vec4 x) {return mod289(((x*34.0)+1.0)*x);}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4  taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\nfloat snoise2D(vec2 v){\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                       -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\nfloat snoise3D(vec3 v){\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\nvec4 grad4(float j, vec4 ip){\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n    return p;\n}\nfloat snoise4D(vec4 v){\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  // 2 * G4\n                          0.414589803375032,  // 3 * G4\n                         -0.447213595499958); // -1 + 4 * G4\n\n    // First corner\n    vec4 i  = floor(v + dot(v, vec4(F4)) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n    //  x1 = x0 - i1  + 1.0 * C.xxxx\n    //  x2 = x0 - i2  + 2.0 * C.xxxx\n    //  x3 = x0 - i3  + 3.0 * C.xxxx\n    //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n    vec4 x1 = x0 - i1 + C.xxxx;\n    vec4 x2 = x0 - i2 + C.yyyy;\n    vec4 x3 = x0 - i3 + C.zzzz;\n    vec4 x4 = x0 + C.wwww;\n\n    // Permutations\n    i = mod289(i);\n    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute( permute( permute( permute (\n               i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n             + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n             + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n             + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n    // Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = grad4(j0,   ip);\n    vec4 p1 = grad4(j1.x, ip);\n    vec4 p2 = grad4(j1.y, ip);\n    vec4 p3 = grad4(j1.z, ip);\n    vec4 p4 = grad4(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n                  + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\nfloat fsnoise      (vec2 c){return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);}\nfloat fsnoiseDigits(vec2 c){return fract(sin(dot(c, vec2(0.129898, 0.78233))) * 437.585453);}\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\nconst float PI = 3.141592653589793;\nconst float PI2 = PI * 2.0;\n\n\n// --------------------------------------------\n//  twigl geekest(300 es) aliases\n// --------------------------------------------\n#define TWIGL_GEEKEST_300ES void mainImage(out vec4 o,in vec2 _fc){vec2 r=iResolution.xy,m=iMouse.xy/r;vec4 FC=vec4(_fc,.5,1);float s=0.,t=iTime;int f=iFrame;o=vec4(0);\n#define END_GEEKEST_300ES o=vec4(clamp(o.xyz,0.,1.),1);}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "NtBcz3", "name": "segment closest point & distance", "author": "ArmandB", "description": "explains how the closest point on line segment to point and distance to line segment algorithms work\nclick a point on the screen to move the point", "tags": ["sdf", "tutorial"], "likes": 1, "viewed": 261, "published": 3, "date": "1662092671", "time_retrieved": "2024-07-30T16:33:21.209572", "image_code": "//uses the algorithm explained below to get the signed distance to a line segment\n//a = line start, b = line end, r = radius of line, p = point to get distance\nfloat sdLine(vec2 a, vec2 b, float r, vec2 p){\n    vec2 ab = b - a;\n    float t = dot(p - a, ab) / dot(ab, ab);\n    vec2 p2 = a + clamp(t,0.0,1.0) * ab;\n    return length(p - p2) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized uv coords\n    vec2 uv = fragCoord/iResolution.y;\n    //normalized mouse click coords\n    vec2 m = abs(iMouse.zw)/iResolution.y;\n    if (m == vec2(0,0)) {\n        m = vec2(0.7,0.4);\n    }\n    \n    vec2 a = vec2(0.5,0.5); //line segment start point\n    vec2 b = vec2(0.8,0.7); //line segment end point\n    vec2 p = m; //point to get distance of\n    \n    vec2 ab = b-a; //the vector from point a to point b\n    vec2 ap = p-a; //the vector from point a to point p\n    float t = dot(ap,ab)/dot(ab,ab); //vector ap projected onto vector ab\n    vec2 p2 = a + clamp(t, 0.0, 1.0)*ab; //the projected point on ab, with t clamped so that p2 stays on the segment\n    \n    float d = distance(p, p2); //the distance from the point to the line segment\n\n    //lines used to show example\n    vec3 col = sdLine(a, b, 0.01, uv) < 0.0 ? vec3(1) : vec3(0);\n    col = sdLine(a, p, 0.004, uv) < 0.0 ? vec3(0.8) : col;\n    col = sdLine(p, p2, 0.002, uv) < 0.0 ? vec3(0.6) : col;\n    col = sdLine(a, p2, 0.006, uv) < 0.0 ? vec3(0,1,0) : col;\n    col = distance(p,uv) < 0.015 ? vec3(0,0,1) : col;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBcz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 160, 206, 206, 345], [347, 347, 404, 431, 1550]], "test": "untested"}
{"id": "flByzy", "name": "round sdf", "author": "ArmandB", "description": "rounds an sdf\n*note that there is no cast shadow", "tags": ["sdf"], "likes": 0, "viewed": 246, "published": 3, "date": "1662074702", "time_retrieved": "2024-07-30T16:33:22.057305", "image_code": "const vec3 light = vec3(-0.3,-0.6,-0.3);\nconst vec3 lightCol = vec3(1,1,0.9);\n\n//a sdf circle\nfloat sdCircle(vec2 uv, float r){\n    return length(uv)-r;\n}\n \n//returns the normal of a sdf circle\nvec3 sdCircleNormal(vec2 uv){\n    vec2 base = normalize(uv)*sqrt(6.0)/3.0;\n    return vec3(base.x,sqrt(3.0)/3.0,base.y);\n}\n\n//a sdf line\nfloat sdLine(vec2 a, vec2 b, float r, vec2 p){\n    vec2 ab = b - a;\n    float t = dot(p - a, ab) / dot(ab, ab);\n    vec2 p2 = a + clamp(t,0.0,1.0) * ab;\n    return length(p - p2) - r;\n}\n\n//returns the normal of a sdf line\nvec3 sdLineNormal(vec2 a, vec2 b, vec2 p){\n    vec2 ab = b - a;\n    float t = dot(p - a, ab) / dot(ab, ab);\n    vec2 p2 = a + clamp(t,0.0,1.0) * ab;\n    vec2 base = normalize(p-p2)*sqrt(6.0)/3.0;\n    return vec3(base.x,sqrt(3.0)/3.0,base.y);\n}\n\n//given a radius and distance value, warps the distance to be circular\nfloat roundSdf(float r, float d){\n    if (d < -r) return -r;\n    float b = d*d + 2.0*d*r;\n    return sign(b)*sqrt(abs(b));\n}\n\n//given a radius, distance, and normal, bends the normal to add a circular bevel\nvec3 roundNormal(float r, float d, vec3 normal){\n    if (d < -r) return vec3(0,1,0);\n    float b = d*d + 2.0*d*r;\n    float m = (d+r)/sqrt(abs(b));\n    float l = sqrt(d*d*(m*m + 1.0));\n    vec2 v = sign(d)*vec2(-m*d,d)/l;\n    vec2 a = normalize(normal.xz)*v.x;\n    vec3 x = vec3(-a.y,v.y,-a.x);\n    return x/length(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y;\n    \n    float circleDist = sdCircle(uv, 0.2);\n    float lineDist = sdLine(vec2(-0.2,0.3),vec2(0.2,0.3),0.03,uv);\n    float dist = 0.0;\n    vec3 normal = vec3(0,1,0);\n    if (lineDist < circleDist){\n        dist = lineDist;\n        //get normal of line and bend it\n        normal = sdLineNormal(vec2(-0.2,0.3),vec2(0.2,0.3),uv);\n        normal = roundNormal(0.03, dist, normal);\n    } else {\n        dist = circleDist;\n        //get normal of circle and bend it\n        normal = sdCircleNormal(uv);\n        normal = roundNormal(0.2, dist, normal);\n    }\n    //base color\n    vec3 col = dist < 0.0 ? vec3(0.3,0.4,0.8) : vec3(0.8,0.4,0.2);\n    //lighting\n    float diffuse = clamp(dot(normal,normalize(-light)),0.0,1.0);\n    vec3 specularAngle = reflect(vec3(0,-1,0),normal);\n    float specular = max(dot(specularAngle,normalize(-light)),0.0);\n    float ambient = 0.2;\n    col = col*diffuse + col*ambient + lightCol*pow(specular,10.0)*0.5;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flByzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 94, 127, 127, 154], [157, 194, 223, 223, 316], [318, 331, 377, 377, 516], [518, 553, 595, 595, 796], [798, 869, 902, 902, 993], [995, 1076, 1124, 1124, 1396], [1398, 1398, 1455, 1455, 2488]], "test": "untested"}
{"id": "flGcWy", "name": "sliced terrain", "author": "sympou", "description": "a strange way to visualize a heightmap in an orthographic projection.\nthe code could be simpler, but i added another buffer to have better performance !\nalso, there is a glitch on top, dedicated to all the glitch amateurs out there.", "tags": ["heightmap"], "likes": 13, "viewed": 268, "published": 3, "date": "1662073644", "time_retrieved": "2024-07-30T16:33:23.153375", "image_code": "//palette found here : https://www.shadertoy.com/view/XtGGzG\nfloat saturate( float x ) { return clamp( x, 0.0, 1.0 ); }\nvec3 magma_quintic( float x ) {\n\tx = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( -0.023226960, +1.087154378, -0.109964741, +6.333665763 ) ) + dot( x2.xy, vec2( -11.640596589, +5.337625354 ) ),\n\t\tdot( x1.xyzw, vec4( +0.010680993, +0.176613780, +1.638227448, -6.743522237 ) ) + dot( x2.xy, vec2( +11.426396979, -5.523236379 ) ),\n\t\tdot( x1.xyzw, vec4( -0.008260782, +2.244286052, +3.005587601, -24.279769818 ) ) + dot( x2.xy, vec2( +32.484310068, -12.688259703 ) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float interSpace3 = interSpace1*interSpace2;\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float maxHeight = 0.;\n    int   maxIndex  = 0;\n\n    for (int i = 0; i <= int(interSpace2); i++) {\n            \n        float val = texture( iChannel0, uv ).r;\n\n        if (val > maxHeight ) {\n            maxHeight = val;\n            maxIndex = i;\n        }\n        uv.y += 1./iResolution.y;\n    }\n        \n    float finalHeight = max(maxHeight - float(maxIndex)/interSpace3/slices,0.);\n    \n    float wall = float(maxIndex>0);\n    \n    float finalVal = pow(finalHeight,0.75)*(1.-wall*0.45);\n            \n    fragColor = vec4(magma_quintic(finalVal), 1.0);\n    \n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//parameters :\n\nfloat slices = 16.;\nfloat interSpace1 = 4.;\nfloat interSpace2 = 4.;\nfloat mapSize = 600.;\nfloat tilt = 2.;\n\n//the height of a slice = interSpace1*interSpace2", "buffer_a_code": "float getVal( vec2 fc, vec2 res ) {\n    vec2 offset = -iTime*vec2(0.05,0.03);\n\n    vec2 uv = (fc - res*offset)/mapSize;\n    uv.y *= tilt;\n    \n    return sqrt(texture( iChannel0, uv ).r)\n     *(texture( iChannel0, uv/sqrt(2.)*0.6 ).r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 fc = fragCoord;\n\n    float interSpace3 = interSpace1*interSpace2;\n    \n    float maxHeight = 0.;\n\n    int i = int(slices);\n    while (maxHeight == 0. && i > 0) {\n    \n        float val = getVal(fc,iResolution.xy);\n        \n        float currentSlice = float(i) / slices;\n        \n        if (val >= currentSlice) {\n            maxHeight = currentSlice;\n            break;\n        }\n        \n        fc.y += interSpace3;\n        i--;\n    }\n        \n    fragColor = vec4(maxHeight,0.,0.,1.);\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    float maxHeight = 0.;\n    int   maxIndex  = 0;\n\n    for (int i = 0; i < int(interSpace1); i++) {\n    \n        float val = texture( iChannel0, uv ).r;\n        \n        if (val > maxHeight) {\n            maxHeight = val;\n            maxIndex = i;\n        }\n        \n        uv.y += interSpace2/iResolution.y;\n\n    }\n    \n    float finalHeight = maxHeight - float(maxIndex)/interSpace1/slices;\n    \n    fragColor = vec4(finalHeight,0.,0.,1.);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flGcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 61, 88, 88, 119], [120, 120, 151, 151, 692], [695, 695, 752, 752, 1411]], "test": "untested"}
{"id": "flyyWy", "name": "Replicate Texture - by hugolnx", "author": "hugolnx", "description": "Trying to replicate texture", "tags": ["procedural", "texture", "wall", "replicate", "hugolnx"], "likes": 2, "viewed": 186, "published": 3, "date": "1662069068", "time_retrieved": "2024-07-30T16:33:24.150708", "image_code": "// GITHUB: https://github.com/HugoLnx/shaders-laboratory/tree/master/shaders/replicate-wall01\n// SHADERTOY: https://www.shadertoy.com/view/flyyWy\n// ORIGINAL: https://github.com/HugoLnx/shaders-laboratory/blob/master/textures/wall01.jpg\n\n#define SHADERTOY 1\n\n// Aux simple functions\n#define TWO_PI 6.283185\n#define PI 3.14159\nfloat norm(float x) { return x*.5 + .5; }\nfloat denorm(float x) { return x*2. - 1.; }\nfloat xstep(float b, float e, float v) {\n    return step(b, v) - step(e, v);\n}\nfloat xsmoothstep(float b, float e, float v) {\n    return smoothstep(b, e, v) - step(e, v);\n}\nfloat flatten(float v, float layers) {\n  return floor(v*layers) * (1./layers);\n}\nfloat nsin(float t) {return norm(sin(t * TWO_PI));}\nfloat ncos(float t) {return norm(cos(t * TWO_PI));}\nfloat ntan(float t) {return norm(tan(t * TWO_PI));}\nfloat sat(float t) {return clamp(t, 0., 1.);}\nfloat rsat(float t) {return mod(t+10000.0, 1.);}\nfloat xclamp(float v, float minV, float maxV) {\n  return clamp(v, minV, maxV) * xstep(minV, maxV, v);\n}\nfloat xclampnorm(float v, float minV, float maxV) {\n  return (xclamp(v, minV, maxV) - minV) / (maxV-minV);\n}\n\n// -------------------\n// BEGIN https://github.com/stegu/webgl-noise\n// -------------------\n\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 mod7(vec3 x) {return x - floor(x * (1.0 / 7.0)) * 7.0;}\nvec3 permute(vec3 x) {return mod289((34.0 * x + 10.0) * x);}\nvec4 permute(vec4 x) {return mod289(((x*34.0)+10.0)*x);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n// Cellular\nvec2 cellular(vec3 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n\n\tvec3 Pi = mod289(floor(P));\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod7(floor(p11*K))*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod7(floor(p12*K))*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod7(floor(p13*K))*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod7(floor(p21*K))*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod7(floor(p22*K))*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod7(floor(p23*K))*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod7(floor(p31*K))*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod7(floor(p32*K))*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod7(floor(p33*K))*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\tvec3 d1 = min(min(d11,d12), d13);\n\tvec3 d2 = min(min(d21,d22), d23);\n\tvec3 d3 = min(min(d31,d32), d33);\n\tvec3 d = min(min(d1,d2), d3);\n\td.x = min(min(d.x,d.y),d.z);\n\treturn vec2(sqrt(d.x)); // F1 duplicated, no F2 computed\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n#endif\n}\n\nvec2 ncellular(vec2 p, float seed) {\n  p *= 15.;\n  seed *= 0.3;\n  return cellular(vec3(p, seed));\n}\n\n// Classic Perlin noise\nfloat perlin(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat nperlin(vec2 p, float seed) {\n  p *= 20.;\n  seed *= 0.5;\n  return norm(perlin(vec3(p, seed)));\n}\n\n// Simplex Noise\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat nsimplex(vec2 x, float seed) {\n  x *= 10.;\n  seed *= 0.3;\n  return norm(simplex(vec3(x, seed)));\n}\n\n\n// -------------------\n// END noise3D\n// -------------------\n\n// -------------------\n// BEGIN https://www.shadertoy.com/view/4dS3Wd\n// -------------------\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat morgan(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat morgan(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat morgan(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat nmorgan(float x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x, float seed) {\n  x *= 20.;\n  seed *= 0.5;\n  return morgan(vec3(x, seed));\n}\n// -------------------\n// END Morgan Noises\n// -------------------\n\n\n// -------------------\n// BEGIN http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// -------------------\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 P = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, P.wz) : vec4(c.gb, P.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n    // vec4 p = mix(vec4(c.bg, P.wz), vec4(c.gb, P.xy), step(c.b, c.g));\n    // vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 P = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + P.xyz) * 6.0 - P.www);\n    return c.z * mix(P.xxx, clamp(p - P.xxx, 0.0, 1.0), c.y);\n}\n// -------------------\n// END HSV Conversion \n// -------------------\n\nvec3 hsv(float h, float s, float v) {return hsv2rgb(vec3(h, s, v));}\n\n\n// Noise Aux Functions\nfloat random(vec2 uv, float seed) {\n    const float a = 12.9898;\n    const float b = 78.233;\n    const float c = 43758.543123;\n    return fract(sin(dot(uv, vec2(a, b)) + seed) * c);\n}\n\n#define OCTAVES 6\n#define OCTAVES_F 6.0\n\n// Simplex Variations\n#define SIMPLEX_VARS_SCALE 1.0\nfloat turbSimplex( vec3 p ) {\n  p *= SIMPLEX_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(100.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( simplex( power * p + shift ) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbSimplex(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.08;\n  return 1.-sat(-1.2*turbSimplex(vec3(p, seed)));\n}\n\nfloat nturb2Simplex(vec2 st2, float seed) {\n  seed *= 0.04;\n  vec3 st = vec3(st2, seed);\n  st *= SIMPLEX_VARS_SCALE * 3.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(200.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(simplex(st));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmSimplex(vec3 x) {\n  x *= SIMPLEX_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(300.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * simplex(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmSimplex(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmSimplex(vec3(x, seed)));\n}\n\n\n// Morgan Variations\n#define MORGAN_VARS_SCALE 2.5\nfloat turbMorgan( vec3 p ) {\n  p *= MORGAN_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(0.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(morgan( power * p + shift )) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbMorgan(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.05;\n  return 1.-sat(-2.0*turbMorgan(vec3(p, seed)));\n}\n\nfloat nturb2Morgan(vec2 st2, float seed) {\n  seed *= 0.03;\n  vec3 st = vec3(st2, seed);\n  st *= MORGAN_VARS_SCALE * 6.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(0.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(morgan(st)));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmMorgan(vec3 x) {\n  x *= MORGAN_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = .9;\n\tvec3 shift = vec3(0.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * (denorm(morgan(x))+0.05);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmMorgan(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmMorgan(vec3(x, seed)));\n}\n\n\n\n// Cellular Variations\n#define CELLULAR_VARS_SCALE 1.5\nfloat turbCellular( vec3 p ) {\n  p *= CELLULAR_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(700.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(cellular( power * p + shift ).x) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbCellular(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.07;\n  return sat(0.85+2.*turbCellular(vec3(p, seed)));\n}\n\nfloat nturb2Cellular(vec2 st2, float seed) {\n  seed *= 0.02;\n  vec3 st = vec3(st2, seed);\n  st *= CELLULAR_VARS_SCALE * 5.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(800.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(cellular(st).x));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmCellular(vec3 x) {\n  x *= CELLULAR_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(900.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * denorm(cellular(x).x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmCellular(vec2 x, float seed) {\n  seed *= 0.1;\n  x *= 5.;\n  return norm(fbmCellular(vec3(x, seed)));\n}\n\n\nvec2 rotate(vec2 v, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c) * v;\n}\n\n#define RED vec3(1., 0., 0.)\n#define GRE vec3(0., 1., 0.)\n#define BLU vec3(0., 0., 1.)\n#define WRED vec3(1., .8, .8)\n#define WGRE vec3(.8, 1., .8)\n#define WBLU vec3(.8, .8, 1.)\n#define BLU2 vec3(0.35, 0.5, 1.)\n#define PUR vec3(1., 0., 1.)\n#define YEL vec3(1., 1., 0.)\n#define CYA vec3(0., 1., 1.)\n#define WHI vec3(1., 1., 1.)\n#define BLANK vec3(0.35, 0., 0.35)\n\nvec4 getNoise(vec2 uv, float t) {\n  float tseed = floor(t*0.1);\n  float seed  = tseed;\n  float seed2 = tseed + 373.297;\n  float seed3 = tseed + 793.713;\n  float seed4 = tseed + 127.139;\n  float seed5 = tseed + 929.197;\n  vec2 roll = -0.05*t*vec2(1.);\n  //uv += roll;\n\n  float v = 0.;\n  float v1 = 0.;\n  float v2 = 0.;\n  float v3 = 0.;\n\n  float rand = random(uv, seed);\n\n  float back = mix(0.45, 0.55, rand);\n  float cut = 0.99;\n  back = rand > cut ? xclampnorm(rand, cut, 1.0) : back;\n\n  float midRaw = flatten(nturb2Simplex(uv*3., seed), 2.0);\n  float mid = mix(-0.02, 0.02, midRaw);\n\n  vec2 b2uv = uv;\n  float b2Scale = 2.;\n  b2uv /= b2Scale;\n\n  float b2uvTurb1 = ncellular(b2uv*3., seed2).x;\n  b2uvTurb1 = rsat(b2uvTurb1*2.);\n  b2uvTurb1 = flatten(b2uvTurb1, 8.0);\n  b2uv *= vec2(5., 1.5);\n  b2uv += denorm(b2uvTurb1) * 0.9 * b2Scale;\n\n  vec2 cel1 = ncellular(b2uv, seed);\n  float back2a = cel1.x;\n  back2a = rsat(back2a*30.);\n  back2a = flatten(back2a, 7.0);\n  float back2Raw = back2a;\n  float back2 = denorm(back2Raw)*0.06 + 0.02;\n  back2 += xclampnorm(back2Raw, 0.0, 0.2)*0.2;\n  back2 -= xclamp(back2Raw, 0.9, 1.0)*0.1;\n\n  float final = back + mid + back2;\n\n  v1 = back2Raw;\n  v2 = b2uvTurb1;\n  v3 = midRaw;\n  v = final;//final;\n\n  return vec4(v1, v2, v3, v);\n}\n\n\n#ifndef SHADERTOY\nuniform sampler2D iChannel0;\nuniform float iTime;\nuniform vec2 iResolution2D;\n#define iResolution vec4(iResolution2D, 0., 0.)\nout vec4 outColor;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from -0.5 to 0.5)\n  float mx = max(iResolution.x, iResolution.y);\n  vec2 ct = iResolution.xy / mx / 2.0;\n  vec2 uv = fragCoord/mx - ct;\n  vec2 uv2 = fragCoord / iResolution.xy - .5;\n\n  float t = iTime;\n  t *= 0.35;\n\n\n  int count = 0;\n  vec3 sims[30];\n\n  vec2 uvZoom1 = uv / 2.;\n  vec2 uvZoom2 = uvZoom1 / 2.;\n  float txdiv = 3.;\n\n  vec4 noises1 = getNoise(uv, t);\n  vec4 noises2 = getNoise(uvZoom1, t);\n  vec4 noises3 = getNoise(uvZoom2, t);\n\n  sims[count++] = WHI * noises1.x;\n  sims[count++] = WHI * noises1.w;\n  sims[count++] = WHI * noises1.x;\n  sims[count++] = WHI * noises1.w; //texture(iChannel0, uv/txdiv).rgb;\n  sims[count++] = WHI * noises1.y;\n  sims[count++] = WHI * noises1.w;\n  sims[count++] = WHI * noises1.y;\n  sims[count++] = WHI * noises1.w; //texture(iChannel0, uvZoom1/txdiv).rgb;\n  sims[count++] = WHI * noises1.z;\n  sims[count++] = WHI * noises2.w;\n  sims[count++] = WHI * noises1.z;\n  sims[count++] = WHI * noises3.w; //texture(iChannel0, uvZoom2/txdiv).rgb;\n\n  uv2 += .5;\n  float gridWidth = 2.0;\n  float gridHeight = 6.0;\n  float gridX = floor(uv2.x*gridWidth);\n  float gridY = floor((1.-uv2.y)*gridHeight);\n  int gridInx = int(floor(gridY*gridWidth + gridX));\n  vec3 c;\n  //count = min(count, 66);\n  for (int i = 0; i < count; i++) {\n    c += sims[i] * (gridInx == i ? 1.0 : 0.0);\n  }\n  //c = vec3(1.0-gridInx*1.0/(gridWidth*gridHeight));\n  //c = c*0.03 + 0.97*vec3(uv, length(uv));\n  //c = vec3(length(uv2));\n  \n\n  // Output to screen\n  fragColor = vec4(c, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n  mainImage(outColor, gl_FragCoord.xy);\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flyyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 326, 347, 347, 367], [368, 368, 391, 391, 411], [412, 412, 452, 452, 490], [491, 491, 537, 537, 584], [585, 585, 623, 623, 665], [666, 666, 687, 687, 717], [718, 718, 739, 739, 769], [770, 770, 791, 791, 821], [822, 822, 842, 842, 867], [868, 868, 889, 889, 916], [917, 917, 964, 964, 1020], [1021, 1021, 1072, 1072, 1129], [1224, 1224, 1245, 1245, 1290], [1291, 1291, 1312, 1312, 1357], [1358, 1358, 1377, 1377, 1418], [1419, 1419, 1441, 1441, 1479], [1480, 1480, 1502, 1502, 1536], [1537, 1537, 1564, 1564, 1612], [1613, 1613, 1632, 1632, 1668], [1670, 1682, 1705, 1705, 6512], [6514, 6514, 6550, 6550, 6613], [6615, 6639, 6661, 6661, 8956], [8958, 8958, 8993, 8993, 9060], [9062, 9079, 9104, 9104, 11243], [11245, 11245, 11281, 11281, 11349], [11414, 11581, 11602, 11602, 11669], [11670, 11670, 11690, 11690, 11795], [11797, 11797, 11820, 11820, 11952], [11954, 11954, 11976, 11976, 12610], [12613, 12613, 12635, 12635, 13396], [13398, 13398, 13422, 13422, 13456], [13457, 13457, 13480, 13480, 13514], [13515, 13515, 13550, 13550, 13611], [13681, 13792, 13814, 13814, 14275], [14277, 14277, 14299, 14299, 14468], [14539, 14539, 14576, 14576, 14607], [14610, 14633, 14668, 14668, 14816], [14912, 14912, 14941, 14941, 15175], [15177, 15177, 15217, 15217, 15296], [15298, 15298, 15341, 15341, 15664], [15666, 15666, 15692, 15692, 15903], [15905, 15905, 15944, 15944, 16014], [16068, 16068, 16096, 16096, 16334], [16336, 16336, 16375, 16375, 16453], [16455, 16455, 16497, 16497, 16824], [16826, 16826, 16851, 16851, 17073], [17075, 17075, 17113, 17113, 17182], [17241, 17241, 17271, 17271, 17517], [17519, 17519, 17560, 17560, 17640], [17642, 17642, 17686, 17686, 18021], [18023, 18023, 18050, 18050, 18273], [18275, 18275, 18315, 18315, 18386], [18389, 18389, 18423, 18423, 18505], [18869, 18869, 18902, 18902, 20136], [20310, 20310, 20367, 20420, 21893]], "test": "untested"}
{"id": "NlGyWy", "name": "Noises Analysis - by hugolnx", "author": "hugolnx", "description": "Testing and experimenting with noises", "tags": ["noise", "testing", "analysis"], "likes": 7, "viewed": 232, "published": 3, "date": "1662068600", "time_retrieved": "2024-07-30T16:33:25.323572", "image_code": "// GITHUB: https://github.com/HugoLnx/shaders-laboratory/tree/master/shaders/noises-analysis\n// SHADERTOY: https://www.shadertoy.com/view/NlGyWy\n\n#define MIXES 1\n#define SHADERTOY 1\n\n// Aux simple functions\n#define TWO_PI 6.283185\n#define PI 3.14159\nfloat norm(float x) { return x*.5 + .5; }\nfloat denorm(float x) { return x*2. - 1.; }\nfloat xstep(float b, float e, float v) {\n    return step(b, v) - step(e, v);\n}\nfloat xsmoothstep(float b, float e, float v) {\n    return smoothstep(b, e, v) - step(e, v);\n}\nfloat flatten(float v, float layers) {\n  return floor(v*layers) * (1./layers);\n}\nfloat nsin(float t) {return norm(sin(t * TWO_PI));}\nfloat ncos(float t) {return norm(cos(t * TWO_PI));}\nfloat ntan(float t) {return norm(tan(t * TWO_PI));}\nfloat sat(float t) {return clamp(t, 0., 1.);}\nfloat rsat(float t) {return mod(t+10000.0, 1.);}\nfloat xclamp(float v, float minV, float maxV) {\n  return clamp(v, minV, maxV) * xstep(minV, maxV, v);\n}\nfloat xclampnorm(float v, float minV, float maxV) {\n  return (xclamp(v, minV, maxV) - minV) / (maxV-minV);\n}\n\n// -------------------\n// BEGIN https://github.com/stegu/webgl-noise\n// -------------------\n\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 mod7(vec3 x) {return x - floor(x * (1.0 / 7.0)) * 7.0;}\nvec3 permute(vec3 x) {return mod289((34.0 * x + 10.0) * x);}\nvec4 permute(vec4 x) {return mod289(((x*34.0)+10.0)*x);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n// Cellular\nvec2 cellular(vec3 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 1.0 // smaller jitter gives more regular pattern\n\n\tvec3 Pi = mod289(floor(P));\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod7(floor(p11*K))*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod7(floor(p12*K))*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod7(floor(p13*K))*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod7(floor(p21*K))*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod7(floor(p22*K))*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod7(floor(p23*K))*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod7(floor(p31*K))*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod7(floor(p32*K))*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod7(floor(p33*K))*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;\n\tvec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;\n\tvec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;\n\tvec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;\n\tvec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;\n\tvec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;\n\tvec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;\n\tvec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;\n\tvec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\tvec3 d1 = min(min(d11,d12), d13);\n\tvec3 d2 = min(min(d21,d22), d23);\n\tvec3 d3 = min(min(d31,d32), d33);\n\tvec3 d = min(min(d1,d2), d3);\n\td.x = min(min(d.x,d.y),d.z);\n\treturn vec2(sqrt(d.x)); // F1 duplicated, no F2 computed\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n#endif\n}\n\nvec2 ncellular(vec2 p, float seed) {\n  p *= 15.;\n  seed *= 0.3;\n  return cellular(vec3(p, seed));\n}\n\n// Classic Perlin noise\nfloat perlin(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nfloat nperlin(vec2 p, float seed) {\n  p *= 20.;\n  seed *= 0.5;\n  return norm(perlin(vec3(p, seed)));\n}\n\n// Simplex Noise\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat nsimplex(vec2 x, float seed) {\n  x *= 10.;\n  seed *= 0.3;\n  return norm(simplex(vec3(x, seed)));\n}\n\n\n// -------------------\n// END noise3D\n// -------------------\n\n// -------------------\n// BEGIN https://www.shadertoy.com/view/4dS3Wd\n// -------------------\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat morgan(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat morgan(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nfloat morgan(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat nmorgan(float x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x) {\n  x *= 20.;\n  return morgan(x);\n}\nfloat nmorgan(vec2 x, float seed) {\n  x *= 20.;\n  seed *= 0.5;\n  return morgan(vec3(x, seed));\n}\n// -------------------\n// END Morgan Noises\n// -------------------\n\n\n// -------------------\n// BEGIN http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// -------------------\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 P = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, P.wz) : vec4(c.gb, P.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n    // vec4 p = mix(vec4(c.bg, P.wz), vec4(c.gb, P.xy), step(c.b, c.g));\n    // vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 P = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + P.xyz) * 6.0 - P.www);\n    return c.z * mix(P.xxx, clamp(p - P.xxx, 0.0, 1.0), c.y);\n}\n// -------------------\n// END HSV Conversion \n// -------------------\n\nvec3 hsv(float h, float s, float v) {return hsv2rgb(vec3(h, s, v));}\n\n\n// Noise Aux Functions\nfloat random(vec2 uv, float seed) {\n    const float a = 12.9898;\n    const float b = 78.233;\n    const float c = 43758.543123;\n    return fract(sin(dot(uv, vec2(a, b)) + seed) * c);\n}\n\n#define OCTAVES 6\n#define OCTAVES_F 6.0\n\n// Simplex Variations\n#define SIMPLEX_VARS_SCALE 1.0\nfloat turbSimplex( vec3 p ) {\n  p *= SIMPLEX_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(100.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( simplex( power * p + shift ) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbSimplex(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.08;\n  return 1.-sat(-1.2*turbSimplex(vec3(p, seed)));\n}\n\nfloat nturb2Simplex(vec2 st2, float seed) {\n  seed *= 0.04;\n  vec3 st = vec3(st2, seed);\n  st *= SIMPLEX_VARS_SCALE * 3.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(200.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(simplex(st));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmSimplex(vec3 x) {\n  x *= SIMPLEX_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(300.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * simplex(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmSimplex(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmSimplex(vec3(x, seed)));\n}\n\n\n// Morgan Variations\n#define MORGAN_VARS_SCALE 2.5\nfloat turbMorgan( vec3 p ) {\n  p *= MORGAN_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(0.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(morgan( power * p + shift )) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbMorgan(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.05;\n  return 1.-sat(-2.0*turbMorgan(vec3(p, seed)));\n}\n\nfloat nturb2Morgan(vec2 st2, float seed) {\n  seed *= 0.03;\n  vec3 st = vec3(st2, seed);\n  st *= MORGAN_VARS_SCALE * 6.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(0.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(morgan(st)));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmMorgan(vec3 x) {\n  x *= MORGAN_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = .9;\n\tvec3 shift = vec3(0.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * (denorm(morgan(x))+0.05);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmMorgan(vec2 x, float seed) {\n  x *= 5.;\n  seed *= 0.2;\n  return norm(fbmMorgan(vec3(x, seed)));\n}\n\n\n\n// Cellular Variations\n#define CELLULAR_VARS_SCALE 1.5\nfloat turbCellular( vec3 p ) {\n  p *= CELLULAR_VARS_SCALE;\n\tfloat w = 100.0;\n\tfloat t = -.5;\n  vec3 shift = vec3(700.);\n\n\tfor (float f = 1.0 ; f < OCTAVES_F ; f++ ){\n\t\tfloat power = pow( 2.0, f );\n\t\tt += abs( denorm(cellular( power * p + shift ).x) / power );\n\t}\n\n\treturn t;\n}\n\nfloat nturbCellular(vec2 p, float seed) {\n  p *= 2.;\n  seed *= 0.07;\n  return sat(0.85+2.*turbCellular(vec3(p, seed)));\n}\n\nfloat nturb2Cellular(vec2 st2, float seed) {\n  seed *= 0.02;\n  vec3 st = vec3(st2, seed);\n  st *= CELLULAR_VARS_SCALE * 5.;\n  float value = 0.0;\n  float amplitude = 1.0;\n  vec3 shift = vec3(800.);\n  for (int i = 0; i < OCTAVES; i++) {\n      value += amplitude * abs(denorm(cellular(st).x));\n      st = st * 2. + shift;\n      amplitude *= .5;\n  }\n  return clamp(value, -1., 1.);\n}\n\nfloat fbmCellular(vec3 x) {\n  x *= CELLULAR_VARS_SCALE;\n\tfloat v = 0.0;\n\tfloat a = 1.;\n\tvec3 shift = vec3(900.);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * denorm(cellular(x).x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn clamp(v, -1., 1.);\n}\n\nfloat nfbmCellular(vec2 x, float seed) {\n  seed *= 0.1;\n  x *= 5.;\n  return norm(fbmCellular(vec3(x, seed)));\n}\n\n\nvec2 rotate(vec2 v, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c) * v;\n}\n\n#define RED vec3(1., 0., 0.)\n#define GRE vec3(0., 1., 0.)\n#define BLU vec3(0., 0., 1.)\n#define BLU2 vec3(0.35, 0.5, 1.)\n#define PUR vec3(1., 0., 1.)\n#define YEL vec3(1., 1., 0.)\n#define CYA vec3(0., 1., 1.)\n#define WHI vec3(1., 1., 1.)\n#define BLANK vec3(0.35, 0., 0.35)\n\n\nvec3 v2layers(float v) {\n  // below\n  float vup = 1.;\n  float vhi = 0.65;\n  float r0 = -0.5;\n  vec3 c1b = vec3(0, 0, vhi);\n  vec3 c1e = vec3(0, 0, vup);\n  float r1 = 0.0;\n\n  // very low\n  vec3 c2b = vec3(0, vhi, vhi);\n  vec3 c2e = vec3(0, vup, vup);\n  float r2 = 0.1;\n\n  // low\n  vec3 c3b = vec3(vhi*0.7, 0, vhi);\n  vec3 c3e = vec3(vup*0.7, 0, vup);\n  float r3 = 0.3;\n\n  // midlow\n  vec3 c4b = vec3(vhi, vhi, vhi)*0.35;\n  vec3 c4e = vec3(vup, vup, vup)*0.35;\n  float r4 = 0.5;\n\n  // midhigh\n  vec3 c5b = vec3(vhi, vhi, vhi);\n  vec3 c5e = vec3(vup, vup, vup);\n  float r5 = 0.7;\n\n  // high\n  vec3 c6b = vec3(vhi, vhi, 0);\n  vec3 c6e = vec3(vup, vup, 0);\n  float r6 = 0.9;\n\n  // very high\n  vec3 c7b = vec3(vhi, vhi*0.7, 0);\n  vec3 c7e = vec3(vup, vup*0.7, 0);\n  float r7 = 1.00001;\n\n  // above\n  vec3 c8b = vec3(vhi, 0, 0);\n  vec3 c8e = vec3(vup, 0, 0);\n  float r8 = 1.5;\n\n  vec3 c;\n  c += xstep(r0, r1, v) * mix(c1b, c1e, (v-r0)/(r1-r0));\n  c += xstep(r1, r2, v) * mix(c2b, c2e, (v-r1)/(r2-r1));\n  c += xstep(r2, r3, v) * mix(c3b, c3e, (v-r2)/(r3-r2));\n  c += xstep(r3, r4, v) * mix(c4b, c4e, (v-r3)/(r4-r3));\n  c += xstep(r4, r5, v) * mix(c5b, c5e, (v-r4)/(r5-r4));\n  c += xstep(r5, r6, v) * mix(c6b, c6e, (v-r5)/(r6-r5));\n  c += xstep(r6, r7, v) * mix(c7b, c7e, (v-r6)/(r7-r6));\n  c += xstep(r7, r8, v) * mix(c8b, c8e, (v-r7)/(r8-r7));\n  return c;\n}\n\nfloat getNoise(vec2 uv, float seed, float t, int inx) {\n  vec2 roll = -0.02*t*vec2(1.);\n  uv += roll;\n  float vs[3];\n  float vRand = random(uv, seed);\n  //float vTurbSimplex = nturbSimplex(uv, seed);\n  //float vTurb2Simplex = nturb2Simplex(uv, seed);\n  //float vFbmSimplex = nfbmSimplex(uv, seed);\n  //float vTurbMorgan = nturbMorgan(uv, seed);\n  float vTurb2Morgan = nturb2Morgan(uv, seed);\n  //float vFbmMorgan = nfbmMorgan(uv, seed);\n  //float vTurbCellular = nturbCellular(uv, seed);\n  //float vTurb2Cellular = nturb2Cellular(uv, seed);\n  //float vFbmCellular = nfbmCellular(uv, seed);\n  //float vMorgan = nmorgan(uv, seed);\n  float vSimplex = nsimplex(uv, seed);\n  //float vPerlin = nperlin(uv, seed);\n  vec2 cel = ncellular(uv, seed);\n  float vCelX = cel.x;\n  //float vCelY = cel.y;\n  //float vCelAvg = (cel.x + cel.y)*.5;\n\n  vs[0] = vCelX;\n  vs[1] = vSimplex;\n  vs[2] = vTurb2Morgan;\n#ifndef MIXES\n  vs[0] = flatten(vs[0], 5.0);\n  vs[1] = flatten(vs[1], 5.0);\n  vs[2] = flatten(vs[2], 5.0);\n#endif\n  return vs[inx];\n}\n\nstruct st_value {\n  float v;\n  float x0_2;\n  float x0_5;\n  float x1_2;\n  float x2;\n  float x5;\n  float x10;\n  float x20;\n};\n\nst_value buildValues(vec2 uv, float seed, float t, int inx) {\n  st_value v;\n  v.v = getNoise(uv, seed, t, inx);\n  v.x0_2 = getNoise(uv*0.2, seed, t, inx);\n  v.x0_5 = getNoise(uv*0.5, seed, t, inx);\n  v.x1_2 = getNoise(uv*1.2, seed, t, inx);\n  v.x2 = getNoise(uv*2., seed, t, inx);\n  v.x5 = getNoise(uv*5., seed, t, inx);\n  v.x10 = getNoise(uv*10., seed, t, inx);\n  v.x20 = getNoise(uv*20., seed, t, inx);\n  //v.x30 = getNoise(uv*30., seed, t, inx);\n  //v.x100 = getNoise(uv*100., seed, t, inx);\n  return v;\n}\n\nvoid drawNoiseDescRows(inout vec3[100] sims, inout int count, inout st_value v) {\n  // row 1\n  sims[count++] = v2layers(v.v);\n  sims[count++] = WHI * v.v;\n  sims[count++] = GRE * max(v.v, v.x10);\n  sims[count++] = RED * min(v.v, v.x10);\n  sims[count++] = CYA * flatten(v.v, 10.0);\n  sims[count++] = CYA * flatten(v.v, 3.0);\n  sims[count++] = YEL * flatten(xclampnorm(v.v, 0.4, 0.6), 2.0);\n  sims[count++] = GRE * xclampnorm(v.v, .0, 0.5);\n  sims[count++] = GRE * xclampnorm(v.v, 1./3., 2./3.);\n\n  // row 2\n  sims[count++] = hsv(v.v, 1., 1.);\n  sims[count++] = WHI * v.x5;\n  sims[count++] = WHI * v.x20;\n  sims[count++] = PUR * nsin(v.v);\n  sims[count++] = PUR * ncos(v.v);\n  sims[count++] = PUR * ntan(v.v);\n  sims[count++] = BLU * (v.v/v.x2)/2.;\n  sims[count++] = BLU * (v.x10/v.v)/2.;\n  sims[count++] = CYA * (v.x5+v.x10)/2.;\n\n  // row 3\n  sims[count++] = hsv(rsat(v.v*6.), 1., 1.);\n  sims[count++] = GRE * rsat(v.v*2.);\n  sims[count++] = GRE * rsat(v.x5*2.);\n  sims[count++] = GRE * rsat(v.v*10.);\n\n  sims[count++] = RED * rsat(1.-v.x5);\n\n  sims[count++] = BLU * rsat(1./v.v);\n  sims[count++] = BLU * rsat(1./v.x5);\n  sims[count++] = PUR * rsat(v.v-nsin(v.v));\n  sims[count++] = PUR * rsat(v.v+ntan(v.v));\n}\n\nvoid drawBlendDescRows(inout vec3[100] sims, inout int count,\n  float t, st_value v1, st_value v2) {\n  st_value va = v1;\n  st_value vb = v2;\n  int invert = int(t*0.1) % 2;\n  if (invert == 1) {\n    v1 = vb;\n    v2 = va;\n  }\n\n  // row 1\n  sims[count++] = v2layers((v1.v+v2.v)/2.);\n  sims[count++] = v2layers(rsat(v1.v+v2.v));\n  sims[count++] = hsv(rsat(v1.v+v2.v), 1., 1.);\n  sims[count++] = hsv(rsat((v1.v+v2.v)*3.), 1., 1.);\n  sims[count++] = vec3(v1.v, 0., v2.v);\n  sims[count++] = vec3((v1.v+v2.v)/2., v1.v, rsat(v2.v*5.));\n  sims[count++] = vec3(1.-v1.v, v1.v, rsat(v2.v*5.));\n  sims[count++] = BLANK;\n  sims[count++] = BLANK;\n\n  // row 2\n  sims[count++] = WHI * max(v1.v, v2.v);\n  sims[count++] = WHI * min(v1.v, v2.v);\n  sims[count++] = WHI * xclamp(v2.v, v2.x10, v1.v);\n  sims[count++] = WHI * xclamp(v2.v, v2.x2, v1.x10);\n  sims[count++] = WHI * (xclamp(v1.v, .0, .5) + xclamp(v2.v, .5, 1.));\n  sims[count++] = WHI * (xclampnorm(v1.v, .0, .5) + xclampnorm(v2.v, .5, 1.));\n  sims[count++] = WHI * flatten(\n    max(xclampnorm(v1.v, .45, .55), xclampnorm(v2.v, .45, .55))\n  , 2.0);\n  sims[count++] = BLANK;\n\n  // row 3\n  sims[count++] = GRE * rsat(v1.v + v2.v);\n  sims[count++] = GRE * rsat(v1.v + v2.x5);\n  sims[count++] = RED * rsat(v1.v - v2.v);\n  sims[count++] = RED * rsat(v1.x5-v2.x10);\n  sims[count++] = BLU * (v2.x10/v1.v)/2.;\n  sims[count++] = BLU * (v1.v/v2.x10)/2.;\n  sims[count++] = BLU * rsat(v1.v / v2.v);\n  sims[count++] = BLU * rsat(1./ v1.v / v2.v);\n}\n\n\n#ifndef SHADERTOY\nuniform float iTime;\nuniform vec2 iResolution2D;\n#define iResolution vec4(iResolution2D, 0., 0.)\nout vec4 outColor;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Normalized pixel coordinates (from -0.5 to 0.5)\n  float mx = max(iResolution.x, iResolution.y);\n  vec2 ct = iResolution.xy / mx / 2.0;\n  vec2 uv = fragCoord/mx - ct;\n  vec2 uv2 = fragCoord / iResolution.xy - .5;\n\n  float t = iTime;\n  float seed  = t;\n  float seed2 = t + 373.297;\n  float seed3 = t + 793.713;\n\n  st_value v1 = buildValues(uv, seed, t, 0);\n  st_value v2 = buildValues(uv, seed2, t, 1);\n  st_value v3 = buildValues(uv, seed3, t, 2);\n\n  int count = 0;\n  vec3 sims[100];\n\n#ifdef MIXES\n  float gridWidth = 9.0;\n  float gridHeight = 9.0;\n  drawNoiseDescRows(sims, count, v1);\n  drawNoiseDescRows(sims, count, v2);\n  drawBlendDescRows(sims, count, t, v1, v2);\n#else\n  float gridWidth = 3.0;\n  float gridHeight = 3.0;\n  sims[count++] = WHI * v1.x0_5;\n  sims[count++] = WHI * v1.x2;\n  sims[count++] = WHI * v1.x5;\n\n  sims[count++] = WHI * v2.x0_5;\n  sims[count++] = WHI * v2.x2;\n  sims[count++] = WHI * v2.x5;\n\n  sims[count++] = WHI * v3.x0_5;\n  sims[count++] = WHI * v3.x2;\n  sims[count++] = WHI * v3.x5;\n#endif\n\n  uv2 += .5;\n  float gridX = floor(uv2.x*gridWidth);\n  float gridY = floor((1.-uv2.y)*gridHeight);\n  int gridInx = int(floor(gridY*gridWidth + gridX));\n  vec3 c;\n\n  for (int i = 0; i < count; i++) {\n    c += sims[i] * (gridInx == i ? 1.0 : 0.0);\n  }\n  \n\n  // Output to screen\n  fragColor = vec4(c, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n  mainImage(outColor, gl_FragCoord.xy);\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlGyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 271, 271, 291], [292, 292, 315, 315, 335], [336, 336, 376, 376, 414], [415, 415, 461, 461, 508], [509, 509, 547, 547, 589], [590, 590, 611, 611, 641], [642, 642, 663, 663, 693], [694, 694, 715, 715, 745], [746, 746, 766, 766, 791], [792, 792, 813, 813, 840], [841, 841, 888, 888, 944], [945, 945, 996, 996, 1053], [1148, 1148, 1169, 1169, 1214], [1215, 1215, 1236, 1236, 1281], [1282, 1282, 1301, 1301, 1342], [1343, 1343, 1365, 1365, 1403], [1404, 1404, 1426, 1426, 1460], [1461, 1461, 1488, 1488, 1536], [1537, 1537, 1556, 1556, 1592], [1594, 1606, 1629, 1629, 6436], [6438, 6438, 6474, 6474, 6537], [6539, 6563, 6585, 6585, 8880], [8882, 8882, 8917, 8917, 8984], [8986, 9003, 9028, 9028, 11167], [11169, 11169, 11205, 11205, 11273], [11338, 11505, 11526, 11526, 11593], [11594, 11594, 11614, 11614, 11719], [11721, 11721, 11744, 11744, 11876], [11878, 11878, 11900, 11900, 12534], [12537, 12537, 12559, 12559, 13320], [13322, 13322, 13346, 13346, 13380], [13381, 13381, 13404, 13404, 13438], [13439, 13439, 13474, 13474, 13535], [13605, 13716, 13738, 13738, 14199], [14201, 14201, 14223, 14223, 14392], [14463, 14463, 14500, 14500, 14531], [14534, 14557, 14592, 14592, 14740], [14836, 14836, 14865, 14865, 15099], [15101, 15101, 15141, 15141, 15220], [15222, 15222, 15265, 15265, 15588], [15590, 15590, 15616, 15616, 15827], [15829, 15829, 15868, 15868, 15938], [15992, 15992, 16020, 16020, 16258], [16260, 16260, 16299, 16299, 16377], [16379, 16379, 16421, 16421, 16748], [16750, 16750, 16775, 16775, 16997], [16999, 16999, 17037, 17037, 17106], [17165, 17165, 17195, 17195, 17441], [17443, 17443, 17484, 17484, 17564], [17566, 17566, 17610, 17610, 17945], [17947, 17947, 17974, 17974, 18197], [18199, 18199, 18239, 18239, 18310], [18313, 18313, 18347, 18347, 18429], [18704, 18704, 18728, 18739, 20054], [20056, 20056, 20111, 20111, 21080], [21207, 21207, 21268, 21268, 21715], [24546, 24546, 24603, 24656, 25935]], "test": "untested"}
{"id": "slVyRd", "name": "Circle + Background", "author": "SnoopethDuckDuck", "description": "just something simple", "tags": ["e"], "likes": 3, "viewed": 164, "published": 3, "date": "1662049835", "time_retrieved": "2024-07-30T16:33:26.151359", "image_code": "#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ms = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float mx = 19. * (0.5 - 0.5 * thc(3., 0.25 * iTime));\n    ms.x = 0.52 * thc(6., iTime + mx * uv.x) * iResolution.x / iResolution.y;\n    ms.y = 0.52 * thc(4., 1.5 * iTime + mx * uv.y);\n\n    float a = 0.5 * atan(uv.x - ms.x, uv.y - ms.y);\n\n    vec3 col = vec3(cos(a + 0.25 * iTime), \n                    sin(uv.y), \n                    sin(a + 0.25 * iTime));\n    col = sqrt(0.5 + 0.5 * col);\n\n    float d = length(uv);\n    float k = 1. / iResolution.y;\n    float s = smoothstep(-k, k, -d + 0.2 * (0.6 + 0.4 * cos(iTime + a)));\n    \n    col = mix(col, 0.8 * col * col, s);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slVyRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 117, 117, 867]], "test": "untested"}
{"id": "7tVyRd", "name": "clamp on different systems", "author": "FabriceNeyret2", "description": "top: clamp on your system\nmiddle: simulating the spec  ( Left: ok for OpenGL & Windows. Right: not ok on OpenGL )\nbottom: reverse of the spec\nleft: clamp(x, .3,.7)   right: clamp(.3,.7,x)", "tags": ["test", "glsl", "compatibility"], "likes": 6, "viewed": 211, "published": 3, "date": "1662049676", "time_retrieved": "2024-07-30T16:33:27.053946", "image_code": "#define spec(a,b,c)  min( max(a,b) ,c )\n#define alt(a,b,c)   max( min(a,b) ,c )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, U = u/R;\n    float a,b,c,v = fract(2.*U.x);\n    U.x < .5 ?  ( a = v,  b = .3, c = .7 )\n             :  ( a = .3, b = .7, c = v );\n    \n    v = U.y > .667 ?  clamp(a,b,c)\n      : U.y > .333 ?   spec(a,b,c) // = clamp according to spec  https://registry.khronos.org/OpenGL-Refpages/gl4/html/clamp.xhtml\n      :                 alt(a,b,c);\n\n    O = vec4( sin(476.5 * v ) );\n    \n    if ( int(u.y)%int(R.y/3.) < 1 || int(u.x)%int(R.x/2.) < 1 ) O = vec4(1,0,0,0); // red separators\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tVyRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 119, 119, 627]], "test": "untested"}
{"id": "slKyRd", "name": "Towers [99 Chars]", "author": "Xor", "description": "Another 3D shader in less than 100 characters. Does \"O-=O++\" work on your machine?", "tags": ["golf"], "likes": 10, "viewed": 293, "published": 3, "date": "1662048856", "time_retrieved": "2024-07-30T16:33:27.965508", "image_code": "//<100 chars playlist: https://www.shadertoy.com/playlist/f3lGDN\n/*\n    \"Towers\" by @XorDev\n\n    Another 3D shader in less than 100 characters.\n    Also see \"Debris\": shadertoy.com/view/7lyyzd\n*/\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    //Clear the fragcolor, texture sample with parallax, iterate\n    for(O=vec4(1); O.r>texture(iChannel0, (I-3e2)/O.r/1e5).r; O-=.01);\n    \n    //Textureless experiment [98 chars]:\n    //for(O-=O++; O.r>sin((O.ba=ceil(I/O.r/1e2+iTime))*O.w).x; O-=.01);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKyRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 233, 298, 489]], "test": "untested"}
{"id": "slKczt", "name": "Spirals wee", "author": "lechuga", "description": "!!", "tags": ["3d", "spheres", "stars", "spirals"], "likes": 7, "viewed": 311, "published": 3, "date": "1662048319", "time_retrieved": "2024-07-30T16:33:28.723482", "image_code": "\n#define nois texture(iChannel0, vec2(0.1)).x * 3.5\n#define t mod(iTime, 100.)\n#define fin return vec2(d, id)\n#define pi acos(-1.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat h(float a){\n  return fract(sin(a*324.43)*455.3434);\n}\nfloat h(vec2 a){\n  return fract(sin(dot(a,vec2(234.45,456.5))*347.734));\n}\nfloat c(float tt){\n  tt *= .5;\n  return mix(h(floor(tt)), h(floor(tt)+1.), pow(smoothstep(0., 1., fract(tt)), 40.));\n}\nfloat pp = 1.;\nvec2 m(vec3 p){\n  float d,id;\n  vec3 ppp = p;\n  p.x += sin(p.z*smoothstep(1.21, -1.25,nois))*.25+.25;\n  vec3 p2 = p;\n  p2.x = atan(p.y,p.x)*20./3.141592;\n  p2.x -= p.z*.1+t*16.;\n  p2.y = length(p.xy)-19.;\n  float s = 5.;\n  p2.z += t*26.75;\n  p2 = (fract(p2/s-.5)-.5)*s;\n  d = length(p2)-.125-nois*.0625;\n  pp += 1./(1.+d*d)*nois;\n  fin;\n}\n\nvec3 nm(vec3 p){\n  vec2 e= vec2(0.01,0.);\n  return normalize(m(p).x-vec3(m(p-e.xyy).x, m(p-e.yxy).x, m(p-e.yyx).x));\n}\n\nvoid ray(inout vec3 p, inout vec3 r, inout vec3 co){\n  vec3 l = vec3(-1.);\n  float dd = 1.;\n  for(float i = 0.; i < 100.; i++){\n    vec2 e = m(p);\n    float d = e.x;\n    float id = e.y;\n    if(d < .01){\n      \n      vec3 n = nm(p);\n      float dif = clamp(dot(l,n), 0., 1.);\n      co = vec3(dif);\n      dd += d;\n      break;\n      \n    }\n    else if(dd > 100.) break;\n    p+=d*r;\n    \n  }\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 s = vec3(0.01,0.01,-10.01);\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= .5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.);\n  \n  vec3 p = s;\n  vec3 tg = vec3(0.01+sin(t+pi)*.15, 0.01+sin(t+pi)*.16, 0.01);\n  vec3 cz = normalize(tg-s);\n  vec3 cx = normalize(cross(cz,vec3(0., -1., 0.)));\n  vec3 cy = normalize(cross(cz,cx));\n  vec3 r = mat3(cx,cy,cz)*normalize(vec3(uv, 1.+c(t)*10.));\n  vec3 co = vec3(0.165);\n  \n  ray(p,r,co);\n  co += pp*vec3(.23,.45,.56);\n  co = pow(co, vec3(.3435));\n  co *= 1.-length(p)*.005;\n\tfragColor = vec4(co, 1.);\n}", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slKczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 198, 198, 240], [241, 241, 257, 257, 315], [316, 316, 334, 334, 434], [450, 450, 465, 465, 788], [790, 790, 806, 806, 908], [910, 910, 962, 962, 1303], [1306, 1306, 1363, 1363, 1922]], "test": "untested"}
{"id": "ftVczd", "name": "Stone mosaic", "author": "jarble", "description": "A colorful stone pattern.", "tags": ["fractal", "mosaic", "stone"], "likes": 2, "viewed": 169, "published": 3, "date": "1662037799", "time_retrieved": "2024-07-30T16:33:29.471482", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n        vec2 t2 = vec2(0.);\n        for(int k = 0; k < 9; k++){\n            bool c2 = uv.x < uv.y;\n            uv = abs(-.5+uv+t2);\n            \n            //if(uv.y>uv.x) uv = uv.yx; else uv *= -sign(uv.y-uv.x);\n            t2 = triangle_wave(uv+.5);\n            //t2 = abs(t2);\n\n            uv = t2-triangle_wave(uv.yx);\n            float c1 = uv.y-uv.x;\n            //c1 = max(c1,t2.x-t2.y);\n            col = .5-vec3(abs(c1-uv.x)/2.,col.yz);\n            \n            //col = col.xzy;\n            if(uv.x < uv.y) col = col.yzx;\n            if(c2) col = vec3(col.x/1.5);\n            //if(t2.x*uv.x < t2.y*uv.y) col = col.yzx;\n            //if(t2.x-t2.y > uv.x-uv.y) col = col.yzx;\n\n\n        }\n    fragColor = vec4(abs(col)*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftVczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 1065]], "test": "untested"}
{"id": "flVyzt", "name": "roundEven, fwidth &  textures", "author": "FabriceNeyret2", "description": "From left to right: texelFetch, fwidth(texelFetch),   fwidth(texture), texture\nFrom bottom to top:   U, U+.5, roundEven(U), roundEven(U)+.5", "tags": ["test", "glsl", "compatibility"], "likes": 2, "viewed": 253, "published": 3, "date": "1662016259", "time_retrieved": "2024-07-30T16:33:30.337167", "image_code": "// #define fwidth(v) sqrt( dFdx(v)*dFdx(v) + dFdy(v)*dFdy(v) )  // true gradient\n#define T(x,y)  texture(iChannel0, (I+.5+vec2(x,y))/256.)\n//#define texture(ch,U) ( I=floor(U*256.-.5),F=fract(U*256.-.5),F*=F*(3.-F*F), mix( mix( T(0,0), T(1,0), F.x ), mix( T(0,1), T(1,1), F.x ), F.y ) ) // = texture with spline interp\n//#define texture(ch,U) ( I=floor(U*256.-.5),F=fract(U*256.-.5),               mix( mix( T(0,0), T(1,0), F.x ), mix( T(0,1), T(1,1), F.x ), F.y ) ) // = texture with bilin interp = builtin\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy, I,F;\n // R/=2.; U/=2.; \n    if ( U.y > R.y/2. )        U  = roundEven(U);\n    if ( abs(U/R-.5).y < .25 ) U += .5;\n    O = U.x < R.x/2.         ? texelFetch(iChannel0, ivec2(U)%256, 0)\n                             : texture(iChannel0,U/256.);\n    if ( abs(U/R-.5).x < .25 ) O = fwidth(O);\n    O = sqrt(.75*O);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flVyzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[509, 509, 547, 547, 887]], "test": "untested"}
{"id": "slyczd", "name": "Fractal mosaic 8", "author": "jarble", "description": "A fractal rug pattern.", "tags": ["fractal", "mosaic", "rug"], "likes": 3, "viewed": 274, "published": 3, "date": "1662002795", "time_retrieved": "2024-07-30T16:33:31.170938", "image_code": "#define T(a) abs(fract( ( a+vec2(1.,.5 )) *1.5 ) -.5 )\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 U = u/iResolution.y/2. + vec2(iTime/16.,0), V, t2=U-U;\n    O-=O;\n    for(int k = 0; k < 6; k++)\n        V = U,\n        U = (U+t2)/1.5,  \n        t2 = abs(T(U+.5)-.5),\n        U = .5+t2-T(U.yx),\n        O.x = abs( U.y-U.x -.5 +O.x ) / 2.,\n        O = V.x < V.y                ? O.yzxw\n          : U.x > U.y || t2.x > t2.y ? O.zyxw / 2.\n          :                           .5 - O.xxxx;\n\n    O = abs(O+O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slyczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[56, 56, 97, 97, 513]], "test": "untested"}
{"id": "stGyRd", "name": "Fork modified  TEST 2", "author": "lome", "description": "I edited [url=https://www.shadertoy.com/view/wtlyR8]ntsutae's \"Circuit Diagram2\" [/url] to make this animation. Surprisingly, it has several moving patterns that resemble \"gliders\" from cellular automata.", "tags": ["xor"], "likes": 1, "viewed": 175, "published": 3, "date": "1661993537", "time_retrieved": "2024-07-30T16:33:32.000719", "image_code": "// \"Circuit Diagram2\" by ntsutae (modified by jarble)\n// https://twitter.com/ntsutae/status/1268820823952916486\n// https://www.openprocessing.org/sketch/912094\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int x = int(fragCoord.x);\n  int y = int(fragCoord.y + 10.0 * iTime);\n  int r = (x)^(y);//(x+y)^(x-y);\n  bool b = abs(r*r*r/(y+x+int(iTime*20.))) % (19970) < 600;\n  fragColor = vec4(vec3(b ? 1.0 : 0.0), 1.0);\n}\n\n\n/*\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int x = int(fragCoord.x);\n  int y = int(fragCoord.y + 30.0 * iTime);\n  int r = (x+y)^(x-y);\n  bool b = abs(r*r*r/(y+x+int(iTime*50.0))) % (9970) < 1000;\n  fragColor = vec4(vec3(b ? 1.0 : 0.0), 1.0);\n}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGyRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 217, 217, 429]], "test": "untested"}
{"id": "stGyzt", "name": "Circle Wave - distance", "author": "iq", "description": "Exact distance to a cute wave made of circular arcs", "tags": ["2d", "distancefield", "wave", "sdf", "arcs"], "likes": 37, "viewed": 1604, "published": 3, "date": "1661990823", "time_retrieved": "2024-07-30T16:33:32.842470", "image_code": "// The MIT License\n// Copyright © 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A cute wave made of circular arcs\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\nfloat sdCircleWave( in vec2 p, in float tb, in float ra )\n{\n    tb = 3.1415927*5.0/6.0 * max(tb,0.0001);\n    vec2 co = ra*vec2(sin(tb),cos(tb));\n\n    p.x = abs(mod(p.x,co.x*4.0)-co.x*2.0);\n\n    vec2 p1 = p;\n    vec2 p2 = vec2(abs(p.x-2.0*co.x),-p.y+2.0*co.y);\n    float d1 = ((co.y*p1.x>co.x*p1.y) ? length(p1-co) : abs(length(p1)-ra));\n    float d2 = ((co.y*p2.x>co.x*p2.y) ? length(p2-co) : abs(length(p2)-ra));\n    \n    return min( d1, d2); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // animation\n    float tb = 0.5-0.5*cos(iTime/2.2);\n\n    // distance\n    float d = sdCircleWave(p,tb, 0.3);\n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-7.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdCircleWave(m,tb,0.3);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stGyzt.jpg", "access": "api", "license": "mit", "functions": [[1246, 1246, 1305, 1305, 1692], [1694, 1694, 1751, 1787, 2525]], "test": "untested"}
{"id": "fdycWd", "name": "prime spiral 2234", "author": "ArmandB", "description": "the prime spiral", "tags": ["primes"], "likes": 2, "viewed": 147, "published": 3, "date": "1661983541", "time_retrieved": "2024-07-30T16:33:33.652304", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "int imod(int a,int b) {\n    float m=float(a)-floor((float(a)+0.5)/float(b))*float(b);\n    return int(m+0.5);\n}\n\nbool is_prime(int n){\n\tif (n == 2 || n == 3) {\n\t\treturn true;\n\t}\n\tif (n <= 1 || imod(n,2) == 0 || imod(n,3) == 0) {\n\t\treturn false;\n\t}\n\tfor (int i = 5; i * i <= n; i += 6) {\n\t\tif (imod(n,i) == 0 || imod(n,i) + 2 == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 2) {\n        ivec2 p = ivec2(fragCoord) - ivec2(iResolution.xy)/2;\n        int i = 0;\n        if (abs(p.y) >= abs(p.x)) {\n          i = 4 * p.y * p.y - p.y - p.x;\n          if (p.y < p.x) {\n            i = i - 2 * (p.y - p.x);\n          }\n        } else {\n          i = 4 * p.x * p.x - p.y - p.x;\n          if (p.y < p.x) {\n            i = i + 2 *(p.y - p.x);\n          }\n        }\n\n        fragColor = vec4(is_prime(i));\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdycWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 119]], "test": "untested"}
{"id": "NlXcWf", "name": "mixrgba", "author": "ArmandB", "description": "Mixes 2 colors with opacity", "tags": ["color", "alpha"], "likes": 2, "viewed": 200, "published": 3, "date": "1661983396", "time_retrieved": "2024-07-30T16:33:34.498043", "image_code": "float sdfCircle(vec2 o, float r, vec2 uv){\n    return distance(o, uv) - r;\n}\n\nvec4 coloredCircle(vec2 o, float r, vec4 col, vec2 uv){\n    return vec4(col.rgb, mix(0.0, col.a, smoothstep(0.005, 0.0, sdfCircle(o, r, uv))));\n}\n\n//mixes 2 colors with opacity\nvec4 mixrgba(vec4 s, vec4 d){\n    float a = s.a + d.a*(1.0-s.a);\n    if (a == 0.0){\n        return vec4(0.0);\n    } \n    vec3 c = s.rgb*s.a + d.rgb*d.a*(1.0-s.a);\n    return vec4(c/a, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 grid = mod(floor(uv.x*20.0), 2.0) + mod(floor(uv.y*20.0), 2.0) == 1.0 ? vec3(0.8) : vec3(1.0);\n    vec4 col = vec4(grid, 1.0);\n    \n    vec4 circle1 = coloredCircle(vec2(0.5, 0.4), 0.2, vec4(1, 0.5, 0, 0.5), uv);\n    vec4 circle2 = coloredCircle(vec2(0.5, 0.6), 0.2, vec4(0, 0.7, 0.7, 0.5), uv);\n    \n    col = mixrgba(circle1, mixrgba(circle2, col));\n\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXcWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 76], [78, 78, 133, 133, 223], [225, 255, 284, 284, 444], [446, 446, 503, 503, 933]], "test": "untested"}
